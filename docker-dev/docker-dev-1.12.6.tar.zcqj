strates the use of \f(CW\*(C`hexpand\*(C'\fR
with a handler:
.PP
.Vb 12
\&    DB<7> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children, sub { $_[0]\->{t} = "X" })
\&    DB<8> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
\&     \*(Aqt\*(Aq => \*(AqX\*(Aq
.Ve
.ie n .SS "$node\->type"
.el .SS "\f(CW$node\fP\->type"
.IX Subsection "$node->type"
Returns (or sets) the type (class) of the node.
It can be called as a subroutine when \f(CW$node\fR is not
a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR like this:
.PP
.Vb 1
\&                     Parse::Eyapp::Node::type($scalar)
.Ve
.PP
This is the case when visiting \f(CW\*(C`CODE\*(C'\fR nodes.
.PP
The following session with the debugger illustrates how it works:
.PP
.Vb 10
\&  > perl \-MParse::Eyapp::Node \-de0
\&  DB<1> @t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  DB<2> x map { $_\->type } @t # Get the types of the three nodes
\&  0  \*(AqA\*(Aq
\&  1  \*(AqB\*(Aq
\&  2  \*(AqC\*(Aq
\&  DB<3> x Parse::Eyapp::Node::type(sub {})
\&  0  \*(AqCODE\*(Aq
\&  DB<4> x Parse::Eyapp::Node::type("hola")
\&  0  \*(AqParse::Eyapp::Node::STRING\*(Aq
\&  DB<5> x Parse::Eyapp::Node::type({ a=> 1})
\&  0  \*(AqHASH\*(Aq
\&  DB<6> x Parse::Eyapp::Node::type([ a, 1 ])
\&  0  \*(AqARRAY\*(Aq
.Ve
.PP
As it is shown in the example it can be called as a subroutine with 
a (\s-1CODE/HASH/ARRAY\s0) reference or an ordinary scalar.
.PP
The words \s-1HASH, CODE, ARRAY\s0 and \s-1STRING\s0 are reserved for 
ordinary Perl references. Avoid naming a \s-1AST\s0 node with one of those words.
.PP
To be used as a setter, be sure Parse::Eyapp::Driver
is loaded:
.PP
.Vb 10
\&  $ perl \-MParse::Eyapp::Driver \-MParse::Eyapp::Node \-wde0
\&  main::(\-e:1):   0
\&    DB<1> x $t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  0  A=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<2> x $t\->type(\*(AqFUN\*(Aq) # Change the type of $t to \*(AqFUN\*(Aq
\&  0  \*(AqFUN\*(Aq
\&    DB<3> x $t
\&  0  FUN=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<4> x $t\->isa(\*(AqParse::Eyapp::Node\*(Aq)
\&  0  1
.Ve
.ie n .SS "$node\->child"
.el .SS "\f(CW$node\fP\->child"
.IX Subsection "$node->child"
Setter-getter to modify a specific child of a node.
It is called like:
.PP
.Vb 1
\&                   $node\->child($i)
.Ve
.PP
Returns the child with index \f(CW$i\fR. Returns \f(CW\*(C`undef\*(C'\fR if the child does not exists.
It has two obligatory parameters: the node (since it is a method)
and the index of the child. Sets the new value if called
.PP
.Vb 1
\&                    $node\->child($i, $tree)
.Ve
.PP
The method will croak if the obligatory parameters are not provided.
.PP
In the files \f(CW\*(C`examples/Node/TSwithtreetransformations2.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/node/usetswithtreetransformations2.pl\*(C'\fR) you can find a 
somewhat complicated example of call to \f(CW\*(C`child\*(C'\fR as a setter. It is inside a transformation
that swaps the children of a \f(CW\*(C`PLUS\*(C'\fR node (remember that the tree
is a concrete tree including code since it is a translation scheme
built under the directive \f(CW%metatree\fR):
.PP
.Vb 2
\&  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&     ........................................................
\&
\&     commutative_add: PLUS($x, ., $y, .) # 1st dot correspond to \*(Aq+\*(Aq 2nd dot to CODE
\&       => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&
\&     ........................................................
\&  }
.Ve
.ie n .SS "Child Access Through ""%tree alias"""
.el .SS "Child Access Through \f(CW%tree alias\fP"
.IX Subsection "Child Access Through %tree alias"
Remember that when the \f(CW\*(C`Eyapp\*(C'\fR program runs 
under the \f(CW\*(C`%tree alias\*(C'\fR directive 
The \fIdot and dollar notations\fR can be used 
to generate named getter-setters to access the children:
.PP
.Vb 10
\&  examples/Node$ cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    40
\&    .............................
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
Here methods with names \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR will be created
inside the class \f(CW\*(C`R::S\*(C'\fR (see the use of the \f(CW%prefix\fR directive
in line 7) to access the corresponding children associated with the 
two instances of \f(CW\*(C`exp\*(C'\fR in the right hand side of
the production rule. when executed, teh former program produces this
output:
.PP
.Vb 6
\&  examples/Node$ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.ie n .SS "$node\->children"
.el .SS "\f(CW$node\fP\->children"
.IX Subsection "$node->children"
Returns the array of children of the node. When the tree is a
translation scheme the \s-1CODE\s0 references are also included.
See \f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example of use
inside a Translation Scheme:
.PP
.Vb 2
\&  examples/Node$ cat TSPostfix3.eyp
\&  ...................... # precedence declarations
\&
\&  %metatree
\&
\&  %defaultaction {
\&    if (@_==2) {  # NUM and VAR
\&      $lhs\->{t} = $_[1]\->{attr};
\&      return
\&    }
\&    if (@_==4) { # binary operations
\&      $lhs\->{t} = "$_[1]\->{t} $_[3]\->{t} $_[2]\->{attr}";
\&      return
\&    }
\&    die "Fatal Error. Unexpected input. Numargs = ".scalar(@_)."\en".Parse::Eyapp::Node\->str(@_);
\&  }
\&
\&  %%
\&  line: %name PROG
\&         exp <%name EXP + \*(Aq;\*(Aq>
\&           { @{$lhs\->{t}} = map { $_\->{t}} ($_[1]\->children()); }
\&
\&  ;
\&
\&  exp:        %name NUM NUM
\&          |   %name VAR VAR
\&          |   %name ASSIGN VAR \*(Aq=\*(Aq exp  {  $lhs\->{t} = "$_[1]\->{attr} $_[3]\->{t} ="; }
\&          |   %name PLUS   exp \*(Aq+\*(Aq exp
\&          |   %name MINUS  exp \*(Aq\-\*(Aq exp
\&          |   %name TIMES  exp \*(Aq*\*(Aq exp
\&          |   %name DIV    exp \*(Aq/\*(Aq exp
\&          |   %name NEG    \*(Aq\-\*(Aq exp %prec NEG { $_[0]\->{t} = "$_[2]\->{t} NEG" }
\&          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq %begin { $_[2] }
\&  ;
\&
\&  %%
\&
\&  ........................
.Ve
.PP
The tree in a Translation Scheme contains the references to
the \f(CW\*(C`CODE\*(C'\fR implementing the semantic actions.
For example,  the syntax tree built by 
the parser for the input \f(CW\*(C`a=\-b*3\*(C'\fR in \f(CW\*(C`TSPostfix3.eyp\*(C'\fR is:
.PP
.Vb 10
\& PROG(EXP(
\&     ASSIGN(
\&       TERMINAL[a],
\&       TERMINAL[=],
\&       TIMES(
\&         NEG(TERMINAL[\-], VAR(TERMINAL[b], CODE), CODE),
\&         TERMINAL[*],
\&         NUM(TERMINAL[3], CODE),
\&         CODE
\&       ) # TIMES,
\&       CODE
\&     ) # ASSIGN
\&   ) # EXP,
\&   CODE
\& ) # PROG
.Ve
.PP
\&\f(CW\*(C`$node\->children\*(C'\fR can also be used as a setter.
.ie n .SS "$node\->Children"
.el .SS "\f(CW$node\fP\->Children"
.IX Subsection "$node->Children"
Returns the array of children of the node.
When dealing with a translation scheme,
the  \f(CW\*(C`$node\->Children\*(C'\fR method 
(Notice the case difference with \f(CW\*(C`$node\->children\*(C'\fR, first in uppercase) 
returns the non \f(CW\*(C`CODE\*(C'\fR children of the node.
The following execution with the debugger
of the example in \f(CW\*(C`examples/Node/ts_with_ast.pl\*(C'\fR
illustrates the difference:
.PP
.Vb 3
\&  examples/Node$ perl \-wd ts_with_ast.pl
\&  main::(ts_with_ast.pl:6):       my $translationscheme = q{
\&  main::(ts_with_ast.pl:7):       %{
.Ve
.PP
The \f(CW$translationscheme\fR variable contains the code
of a small calculator:
.PP
.Vb 1
\&  %metatree
\&
\&  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left   \*(Aq*\*(Aq
\&  %left   NEG
\&
\&  %%
\&  line:       %name EXP
\&                $exp  { $lhs\->{n} = $exp\->{n} }
\&  ;
\&
\&  exp:
\&              %name PLUS
\&                exp.left \*(Aq+\*(Aq  exp.right
\&                  { $lhs\->{n} .= $left\->{n} + $right\->{n} }
\&          |   %name TIMES
\&                exp.left \*(Aq*\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} * $right\->{n} }
\&          |   %name NUM   $NUM
\&                  { $lhs\->{n} = $NUM\->{attr} }
\&          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&          |   exp.left \*(Aq\-\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} \- $right\->{n} }
\&
\&          |   \*(Aq\-\*(Aq $exp %prec NEG
\&                  { $lhs\->{n} = \-$exp\->{n} }
\&  ;
.Ve
.PP
We run the program with input \f(CW\*(C`2+(3)\*(C'\fR and stop
it at line 88, just after the augmented \s-1AST \s0(\f(CW\*(C`CODE\*(C'\fR node included)
has been built:
.PP
.Vb 2
\&    DB<1> c 88
\&  main::(ts_with_ast.pl:88):      $t\->translation_scheme;
.Ve
.PP
Now, let us see the difference between the methods \f(CW\*(C`children\*(C'\fR
and \f(CW\*(C`Children\*(C'\fR:
.PP
.Vb 7
\&    DB<2> @a = $t\->children; @b = $t\->Children
\&    DB<3> print Parse::Eyapp::Node::str($_)."\en" for @a
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&  CODE
\&    DB<4> print $_\->str."\en" for @b
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&    DB<5>
.Ve
.ie n .SS "$node\->last_child"
.el .SS "\f(CW$node\fP\->last_child"
.IX Subsection "$node->last_child"
Return the last child of the node. When dealing with translation
schemes, the last can be a \f(CW\*(C`CODE\*(C'\fR node.
.ie n .SS "$node\->Last_child"
.el .SS "\f(CW$node\fP\->Last_child"
.IX Subsection "$node->Last_child"
The \f(CW\*(C`$node\->Last_child\*(C'\fR method returns the last non \s-1CODE\s0 child of the node.
See an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %prefix Calc::
\&    15
\&    16  %defaultaction {
\&    17     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    18  }
\&    19
\&    20  %metatree
\&    21
\&    22  %right   \*(Aq=\*(Aq
\&    23  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    24  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    25
\&    26  %%
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    30  ;
\&    31
\&    32  exp:
\&    33              %name PLUS
\&    34                exp.left \*(Aq+\*(Aq exp.right
\&    35          |   %name MINUS
\&    36                exp.left \*(Aq\-\*(Aq exp.right
\&    37          |   %name TIMES
\&    38                exp.left \*(Aq*\*(Aq exp.right
\&    39          |   %name DIV
\&    40                exp.left \*(Aq/\*(Aq exp.right
\&    41          |   %name NUM
\&    42                $NUM
\&    43                  { $lhs\->{n} = $NUM\->{attr} }
\&    44          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    45          |   %name VAR
\&    46                $VAR
\&    47                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    48          |   %name ASSIGN
\&    49                $VAR \*(Aq=\*(Aq $exp
\&    50                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    51
\&    52  ;
\&    53
\&    54  %%
\&    55  # tail code is available at tree construction time
\&    ......................................................
\&    77  }; # end translation scheme
\&    78
\&    ......................................................
.Ve
.PP
The node associated with \f(CW$_[1]\fR in
.PP
.Vb 3
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
is associated with the whole expression
.PP
.Vb 1
\&                               exp <+ \*(Aq;\*(Aq>
.Ve
.PP
and is a \f(CW\*(C`Calc::_PLUS_LIST\*(C'\fR node. 
When feed with input \f(CW\*(C`a=3;b=4\*(C'\fR the children are
the two \f(CW\*(C`Calc::ASSIGN\*(C'\fR subtrees associated with
\&\f(CW\*(C`a=3\*(C'\fR and \f(CW\*(C`b=4\*(C'\fR and the \f(CW\*(C`CODE\*(C'\fR associated with the
semantic action:
.PP
.Vb 1
\&            { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
Using \f(CW\*(C`Last_child\*(C'\fR we are avoiding the last \f(CW\*(C`CODE\*(C'\fR
child and setting the \f(CW\*(C`n\*(C'\fR(umeric) attribute
of the \f(CW\*(C`EXP\*(C'\fR node to the one associated with \f(CW\*(C`b=4\*(C'\fR (i.e. \f(CW4\fR).
.PP
.Vb 3
\&  examples/Node$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=3;b=4
\&  ***********Tree*************
\&
\&  Calc::EXP(
\&    Calc::_PLUS_LIST(
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN,
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN
\&    ) # Calc::_PLUS_LIST,
\&    CODE
\&  ) # Calc::EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => { \*(Aqn\*(Aq => \*(Aq3\*(Aq },
\&    \*(Aqb\*(Aq => { \*(Aqn\*(Aq => \*(Aq4\*(Aq }
\&  }
\&
\&  ************Result**********
\&  4
.Ve
.ie n .SS "$node\->descendant"
.el .SS "\f(CW$node\fP\->descendant"
.IX Subsection "$node->descendant"
The \f(CW\*(C` descendant\*(C'\fR method 
returns the descendant of a node given its \fIcoordinates\fR. 
The coordinates of a node \f(CW$s\fR relative to a tree \f(CW$t\fR
to which it belongs is a string of numbers
separated by dots like  \f(CW".1.3.2"\fR which
denotes the \fIchild path\fR from \f(CW$t\fR to \f(CW$s\fR, i.e.
\&\f(CW\*(C`$s == $t\->child(1)\->child(3)\->child(2)\*(C'\fR.
.PP
See a session
with the debugger:
.PP
.Vb 9
\&   DB<7> x $t\->child(0)\->child(0)\->child(1)\->child(0)\->child(2)\->child(1)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
\& )
\&   DB<8> x $t\->descendant(\*(Aq.0.0.1.0.2.1\*(Aq)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
.Ve
.ie n .SS "$node\->str"
.el .SS "\f(CW$node\fP\->str"
.IX Subsection "$node->str"
The \f(CW\*(C`str\*(C'\fR method returns a string representation of the tree. 
The \fIstr\fR method traverses the syntax tree dumping the type
of the node being visited in a string. To be specific
the value returned by the function referenced by \f(CW$CLASS_HANDLER\fR 
will be dumped. The default value fo such function is to return the type
of the node.
If the node being visited
has a method \f(CW\*(C`info\*(C'\fR it will
be executed and its result inserted between \f(CW$DELIMITER\fRs
into the string. Thus, in the \*(L"\s-1SYNOPSIS\*(R"\s0
example, by adding the \f(CW\*(C`info\*(C'\fR method to the class \f(CW\*(C`TERMINAL\*(C'\fR:
.PP
.Vb 3
\& sub TERMINAL::info {
\&   $_[0]{attr}
\& }
.Ve
.PP
we achieve the insertion of attributes in the string being built 
by \f(CW\*(C`str\*(C'\fR.
.PP
The existence of some methods (like \f(CW\*(C`footnote\*(C'\fR) and
the values of some package variables
influence the behavior of \f(CW\*(C`str\*(C'\fR. Among the most
important are:
.PP
.Vb 12
\&  @PREFIXES = qw(Parse::Eyapp::Node::);                                # Prefixes to suppress 
\&  $INDENT = 0; # \-1 compact, no info, no footnotes 
\&               # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
\&  $STRSEP = \*(Aq,\*(Aq;                                # Separator between nodes, by default a comma
\&  $DELIMITER = \*(Aq[\*(Aq;                         # The string returned by C<info> will be enclosed 
\&  $FOOTNOTE_HEADER = "\en\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en"; 
\&  $FOOTNOTE_SEP = ")\en"; 
\&  $FOOTNOTE_LEFT = \*(Aq^{\*(Aq;                               # Left delimiter for a footnote number
\&  $FOOTNOTE_RIGHT = \*(Aq}\*(Aq;                              # Right delimiter for a footnote number
\&  $LINESEP = 4;                             # When indent=2 the enclosing parenthesis will be
\&                                            # commented if more than $LINESEP apart
\&  $CLASS_HANDLER = sub { type($_[0]) }; # What to print to identify the node
.Ve
.PP
Footnotes and attribute info will not be inserted when \f(CW$INDENT\fR 
is \-1. A compact representation will be obtained. Such representation 
can be feed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`hnew\*(C'\fR to obtain a copy of the tree. 
See the following session with the debugger:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->new(\*(AqA(B(C,D),D)\*(Aq, sub { $_\->{order} = $i++ for @_; })
\&    DB<2> *A::info = *B::info = *C::info = *D::info = sub { shift()\->{order} }
\&    DB<3> p $x\->str
\&  A[0](B[1](C[2],D[3]),D[4])
\&    DB<4> $Parse::Eyapp::Node::INDENT=\-1
\&    DB<5> p $x\->str
\&  A(B(C,D),D)
\&    DB<6> x Parse::Eyapp::Node\->hnew($x\->str)
\&  0  A=HASH(0x8574704)
\&     \*(Aqchildren\*(Aq => ARRAY(0x85745d8)
\&        0  B=HASH(0x857468c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8574608)
\&              0  C=HASH(0x85745b4)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x8509670)
\&                      empty array
\&              1  D=HASH(0x8574638)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x857450c)
\&                      empty array
\&        1  D=HASH(0x8574638)
\&           \-> REUSED_ADDRESS
\&  1  B=HASH(0x857468c)
\&     \-> REUSED_ADDRESS
\&  2  C=HASH(0x85745b4)
\&     \-> REUSED_ADDRESS
\&  3  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
\&  4  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
.Ve
.PP
The following list defines the \f(CW$DELIMITER\fRs you can choose for 
attribute representation:
.PP
.Vb 1
\&          \*(Aq[\*(Aq => \*(Aq]\*(Aq, \*(Aq{\*(Aq => \*(Aq}\*(Aq, \*(Aq(\*(Aq => \*(Aq)\*(Aq, \*(Aq<\*(Aq => \*(Aq>\*(Aq
.Ve
.PP
If the node being visited has a method  \f(CW\*(C`footnote\*(C'\fR, the string
returned by the method will be concatenated at the end of the 
string as a footnote. The variables \f(CW$FOOTNOTE_LEFT\fR and
\&\f(CW$FOOTNOTE_RIGHT\fR govern the displaying of footnote numbers.
.PP
Follows an example of output using \f(CW\*(C`footnotes\*(C'\fR.
.PP
.Vb 10
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/script> \e
\&                                          usetypes.pl prueba24.c
\& PROGRAM^{0}(FUNCTION[f]^{1}(RETURNINT(TIMES(INUM(TERMINAL[2:2]),VAR(TERMINAL[a:2])))))
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0)
\& Types:
\& $VAR1 = {
\&   \*(AqCHAR\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqCHAR\*(Aq ),
\&   \*(AqVOID\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqVOID\*(Aq ),
\&   \*(AqINT\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqINT\*(Aq ),
\&   \*(AqF(X_1(INT),INT)\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => [
\&       bless( {
\&         \*(Aqchildren\*(Aq => [
\&           $VAR1\->{\*(AqINT\*(Aq}
\&         ]
\&       }, \*(AqX_1\*(Aq ),
\&       $VAR1\->{\*(AqINT\*(Aq}
\&     ]
\&   }, \*(AqF\*(Aq )
\& };
\& Symbol Table:
\& $VAR1 = {
\&   \*(Aqf\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqF(X_1(INT),INT)\*(Aq,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 1)
\& $VAR1 = {
\&   \*(Aqa\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqINT\*(Aq,
\&     \*(Aqparam\*(Aq => 1,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
.Ve
.PP
The first footnote was due to a call to \f(CW\*(C`PROGRAM:footnote\*(C'\fR.
The \f(CW\*(C`footnote\*(C'\fR method for the \f(CW\*(C`PROGRAM\*(C'\fR node was defined as:
.PP
.Vb 8
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                             sed \-n \-e \*(Aq691,696p\*(Aq Types.eyp | cat \-n
\&     1  sub PROGRAM::footnote {
\&     2    return "Types:\en"
\&     3           .Dumper($_[0]\->{types}).
\&     4           "Symbol Table:\en"
\&     5           .Dumper($_[0]\->{symboltable})
\&     6  }
.Ve
.PP
The second footnote was produced by the existence of a
\&\f(CW\*(C`FUNCTION::footnote\*(C'\fR method:
.PP
.Vb 5
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                            sed \-n \-e \*(Aq702,704p\*(Aq Types.eyp | cat \-n
\& 1  sub FUNCTION::footnote {
\& 2    return Dumper($_[0]\->{symboltable})
\& 3  }
.Ve
.PP
The source program for the example was:
.PP
.Vb 3
\&     1  int f(int a) {
\&     2    return 2*a;
\&     3  }
.Ve
.ie n .SS "$node\->equal"
.el .SS "\f(CW$node\fP\->equal"
.IX Subsection "$node->equal"
A call  \f(CW\*(C`$tree1\->equal($tree2)\*(C'\fR  
compare the two trees \f(CW$tree1\fR and \f(CW$tree2\fR. 
Two trees are considered equal if their root nodes belong to the same class,
they have the same number of children and the children are (recursively) equal.
.PP
In Addition to the two trees the programmer can specify
pairs \f(CW\*(C`attribute_key => equality_handler\*(C'\fR:
.PP
.Vb 1
\&  $tree1\->equal($tree2, attr1 => \e&handler1, attr2 => \e&handler2, ...)
.Ve
.PP
In such case 
the definition of equality is more restrictive:
Two trees are considered equal if
.IP "\(bu" 2
Their root nodes belong to the same class,
.IP "\(bu" 2
They have the same number of children
.IP "\(bu" 2
For each of the specified attributes occur
that for both nodes the existence and definition of the key
is the same
.IP "\(bu" 2
Assuming the key exists and is defined for both 
nodes, the equality handlers return
true for each of its attributes and
.IP "\(bu" 2
The respective children are (recursively) equal.
.PP
An attribute handler receives as arguments the values of the attributes
of the two nodes being compared and must return true if, and only if,
these two attributes are considered equal. Follows an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n equal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  my $string1 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     6  my $string2 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     7  my $t1 = Parse::Eyapp::Node\->new($string1, sub { my $i = 0; $_\->{n} = $i++ for @_ });
\&     8  my $t2 = Parse::Eyapp::Node\->new($string2);
\&     9
\&    10  # Without attributes
\&    11  if ($t1\->equal($t2)) {
\&    12    print "\enNot considering attributes: Equal\en";
\&    13  }
\&    14  else {
\&    15    print "\enNot considering attributes: Not Equal\en";
\&    16  }
\&    17
\&    18  # Equality with attributes
\&    19  if ($t1\->equal($t2, n => sub { return $_[0] == $_[1] })) {
\&    20    print "\enConsidering attributes: Equal\en";
\&    21  }
\&    22  else {
\&    23    print "\enConsidering attributes: Not Equal\en";
\&    24  }
.Ve
.PP
When the former program is run without arguments produces the following
output:
.PP
.Vb 1
\&  examples/Node$ equal.pl
\&
\&  Not considering attributes: Equal
\&
\&  Considering attributes: Not Equal
.Ve
.ie n .SS "Using ""equal"" During Testing"
.el .SS "Using \f(CWequal\fP During Testing"
.IX Subsection "Using equal During Testing"
During the development of your compiler you add new stages
to the existing ones. The consequence is that the \s-1AST\s0 is decorated
with new attributes. Unfortunately, this implies that tests you wrote using 
\&\f(CW\*(C`is_deeply\*(C'\fR and comparisons against formerly correct abstract syntax trees are no longer valid.
This is due to the fact that \f(CW\*(C`is_deeply\*(C'\fR requires both tree structures to be
equivalent in every detail and that our new code produces a tree with new attributes.
.PP
Instead of \f(CW\*(C`is_deeply\*(C'\fR use the \f(CW\*(C`equal\*(C'\fR method to check for partial equivalence between
abstract syntax trees. You can follow these steps:
.IP "\(bu" 2
Dump the tree for the source inserting \f(CW\*(C`Data::Dumper\*(C'\fR statements
.IP "\(bu" 2
Carefully check that the tree is really correct
.IP "\(bu" 2
Decide which attributes will be used for comparison
.IP "\(bu" 2
Write the code for the expected value
editing the output produced by \f(CW\*(C`Data::Dumper\*(C'\fR
.IP "\(bu" 2
Write the handlers for the attributes you decided.
Write the comparison using \f(CW\*(C`equal\*(C'\fR.
.PP
Tests using this methodology will not fail even if later code decorating 
the \s-1AST\s0 with new attributes is introduced.
.PP
See an example that checks an abstract syntax tree produced
by the simple compiler (see  \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR) 
for a really simple source:
.PP
.Vb 3
\&  Simple\-Types/script$ cat prueba27.c
\&  int f() {
\&  }
.Ve
.PP
The first thing is to obtain a description of the tree,
that can be done executing the compiler under the control of
the Perl debugger, stopping just after the 
tree has been built and dumping the tree
with Data::Dumper:
.PP
.Vb 11
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-wd usetypes.pl prueba27.c
\&  main::(usetypes.pl:5):  my $filename = shift || die "Usage:\en$0 file.c\en";
\&    DB<1> c 12
\&  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
\&    DB<2> use Data::Dumper
\&    DB<3> $Data::Dumper::Purity = 1
\&    DB<4> p Dumper($t)
\&  $VAR1 = bless( {
\&                   ..............................................
\&                 }, \*(AqPROGRAM\*(Aq );
\&  ...............................................................
.Ve
.PP
Once we have the shape of a correct tree we can write
our tests:
.PP
.Vb 10
\&  examples/Node$ cat \-n testequal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4  use Data::Dumper;
\&     5  use Data::Compare;
\&     6
\&     7  my $debugging = 0;
\&     8
\&     9  my $handler = sub {
\&    10    print Dumper($_[0], $_[1]) if $debugging;
\&    11    Compare($_[0], $_[1])
\&    12  };
\&    13
\&    14  my $t1 = bless( {
\&    15                   \*(Aqtypes\*(Aq => {
\&    16                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    17                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    18                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    19                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    20                                   \*(Aqchildren\*(Aq => [
\&    21                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    22                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    23                                 }, \*(AqF\*(Aq )
\&    24                              },
\&    25                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    26                   \*(Aqlines\*(Aq => 2,
\&    27                   \*(Aqchildren\*(Aq => [
\&    28                                   bless( {
\&    29                                            \*(Aqsymboltable\*(Aq => {},
\&    30                                            \*(Aqfatherblock\*(Aq => {},
\&    31                                            \*(Aqchildren\*(Aq => [],
\&    32                                            \*(Aqdepth\*(Aq => 1,
\&    33                                            \*(Aqparameters\*(Aq => [],
\&    34                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    35                                            \*(AqsymboltableLabel\*(Aq => {},
\&    36                                            \*(Aqline\*(Aq => 1
\&    37                                          }, \*(AqFUNCTION\*(Aq )
\&    38                                 ],
\&    39                   \*(Aqdepth\*(Aq => 0,
\&    40                   \*(Aqline\*(Aq => 1
\&    41                 }, \*(AqPROGRAM\*(Aq );
\&    42  $t1\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t1;
\&    43
\&    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    45  my $t2 = bless( {
\&    46                   \*(Aqtypes\*(Aq => {
\&    47                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    48                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    49                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    50                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    51                                   \*(Aqchildren\*(Aq => [
\&    52                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    53                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    54                                 }, \*(AqF\*(Aq )
\&    55                              },
\&    56                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    57                   \*(Aqchildren\*(Aq => [
\&    58                                   bless( {
\&    59                                            \*(Aqsymboltable\*(Aq => {},
\&    60                                            \*(Aqfatherblock\*(Aq => {},
\&    61                                            \*(Aqchildren\*(Aq => [],
\&    62                                            \*(Aqparameters\*(Aq => [],
\&    63                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    64                                          }, \*(AqFUNCTION\*(Aq )
\&    65                                 ],
\&    66                 }, \*(AqPROGRAM\*(Aq );
\&    67  $t2\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    68
\&    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    70  # and without the symboltable and types attributes used in the comparison
\&    71  my $t3 = bless( {
\&    72                   \*(Aqtypes\*(Aq => {
\&    73                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    74                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    75                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    76                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    77                                   \*(Aqchildren\*(Aq => [
\&    78                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    79                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    80                                 }, \*(AqF\*(Aq )
\&    81                              },
\&    82                   \*(Aqchildren\*(Aq => [
\&    83                                   bless( {
\&    84                                            \*(Aqsymboltable\*(Aq => {},
\&    85                                            \*(Aqfatherblock\*(Aq => {},
\&    86                                            \*(Aqchildren\*(Aq => [],
\&    87                                            \*(Aqparameters\*(Aq => [],
\&    88                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    89                                          }, \*(AqFUNCTION\*(Aq )
\&    90                                 ],
\&    91                 }, \*(AqPROGRAM\*(Aq );
\&    92
\&    93  $t3\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    94
\&    95  # Without attributes
\&    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
\&    97    print "\enNot considering attributes: Equal\en";
\&    98  }
\&    99  else {
\&   100    print "\enNot considering attributes: Not Equal\en";
\&   101  }
\&   102
\&   103  # Equality with attributes
\&   104  if (Parse::Eyapp::Node::equal(
\&   105        $t1, $t2,
\&   106        symboltable => $handler,
\&   107        types => $handler,
\&   108      )
\&   109     ) {
\&   110        print "\enConsidering attributes: Equal\en";
\&   111  }
\&   112  else {
\&   113    print "\enConsidering attributes: Not Equal\en";
\&   114  }
\&   115
\&   116  # Equality with attributes
\&   117  if (Parse::Eyapp::Node::equal(
\&   118        $t1, $t3,
\&   119        symboltable => $handler,
\&   120        types => $handler,
\&   121      )
\&   122     ) {
\&   123        print "\enConsidering attributes: Equal\en";
\&   124  }
\&   125  else {
\&   126    print "\enConsidering attributes: Not Equal\en";
\&   127  }
.Ve
.PP
The code defining tree \f(CW$t1\fR was obtained from an output using \f(CW\*(C`Data::Dumper\*(C'\fR.
The code for trees \f(CW$t2\fR and \f(CW$t3\fR was written using cut-and-paste from \f(CW$t1\fR.
They have the same shape than \f(CW$t1\fR but differ in their attributes. Tree \f(CW$t2\fR
shares with \f(CW$t1\fR the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR used in the comparison
and so \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`true\*(C'\fR when compared. Since \f(CW$t3\fR differs from \f(CW$t1\fR
in the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR the call to \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$node\->delete"
.el .SS "\f(CW$node\fP\->delete"
.IX Subsection "$node->delete"
The \f(CW\*(C`$node\->delete($child)\*(C'\fR method is used to delete the specified child of \f(CW$node\fR.
The child to delete can be specified using the index or a
reference. It returns the deleted child.
.PP
Throws an exception if the object can't do \f(CW\*(C`children\*(C'\fR or has no \f(CW\*(C`children\*(C'\fR.
See also the delete method of treeregexes 
(\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects)
to delete the node being visited.
.PP
The following example moves out of a loop an assignment statement
assuming is an invariant of the loop. To do it, it uses
the \f(CW\*(C`delete\*(C'\fR and \f(CW\*(C`insert_before\*(C'\fR methods:
.PP
.Vb 10
\&  nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&              sed \-ne \*(Aq98,113p\*(Aq moveinvariantoutofloopcomplexformula.pl
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&    FIRSTLINE => 99,
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
.Ve
.PP
The example below deletes \s-1CODE\s0 nodes
from the tree build for a translation scheme:
.PP
.Vb 5
\&  my $transform = Parse::Eyapp::Treeregexp\->new( 
\&    STRING=>q{
\&      delete_code: CODE => { Parse::Eyapp::Node::delete($CODE) }
\&    },
\&  )
.Ve
.PP
Observe how delete is called as a subroutine.
.ie n .SS "$node\->unshift($newchild)"
.el .SS "\f(CW$node\fP\->unshift($newchild)"
.IX Subsection "$node->unshift($newchild)"
Inserts \f(CW$newchild\fR at the beginning of the list of children of \f(CW$node\fR.
See also the unshift method 
for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->push($newchild)"
.el .SS "\f(CW$node\fP\->push($newchild)"
.IX Subsection "$node->push($newchild)"
Inserts \f(CW$newchild\fR at the end of the list of children of \f(CW$node\fR.
.ie n .SS "$node\->insert_before($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_before($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_before($position, $new_child)"
Inserts \f(CW$newchild\fR before \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index
and is not in range. Also if \f(CW$node\fR has no children.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not define
an actual child. In such case \f(CW$new_child\fR is not inserted.
.PP
See also the insert_before 
method for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->insert_after($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_after($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_after($position, $new_child)"
Inserts \f(CW$newchild\fR after \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index and is not
in the range of \f(CW\*(C`$node\-\*(C'\fRchildren>.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not exists
in the list of children. In such case \f(CW$new_child\fR is not inserted.
.ie n .SS "$node\->translation_scheme"
.el .SS "\f(CW$node\fP\->translation_scheme"
.IX Subsection "$node->translation_scheme"
Traverses \f(CW$node\fR. Each time a \s-1CODE\s0 node is visited the subroutine referenced
is called with arguments the node and its children. Usually the code will decorate
the nodes with new attributes or will update existing ones. Obviously this method
does nothing for an ordinary \s-1AST.\s0 It is used after compiling
an Eyapp program that makes use of the \f(CW%metatree\fR directive. (See
\&\f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example).
.ie n .SS "$node\->bud(@transformations)"
.el .SS "\f(CW$node\fP\->bud(@transformations)"
.IX Subsection "$node->bud(@transformations)"
Bottom-up decorator. The tree is traversed bottom-up. The set of
transformations in \f(CW@transformations\fR
is applied to each node in the tree referenced by \f(CW$node\fR
in the order
supplied by the user. \fIAs soon as one succeeds
no more transformations are applied\fR.
.PP
For an example  see the files \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
and \f(CW\*(C`lib/Simple/Trans.trg\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
shows an extract of the type-checking phase of a toy-example compiler:
.PP
.Vb 10
\&  examples/typechecking/Simple\-Types\-0.4/lib/Simple$  sed \-ne \*(Aq600,613p\*(Aq Types.eyp
\&   my @typecheck = (     # Check typing transformations for
\&     our $inum,          # \- Numerical constantss
\&     our $charconstant,  # \- Character constants
\&     our $bin,           # \- Binary Operations
\&     our $arrays,        # \- Arrays
\&     our $assign,        # \- Assignments
\&     our $control,       # \- Flow control sentences
\&     our $functioncall,  # \- Function calls
\&     our $statements,    # \- Those nodes with void type
\&                         #   (STATEMENTS, PROGRAM, etc.)
\&     our $returntype,    # \- Return
\&   );
\&
\&   $t\->bud(@typecheck);
.Ve
.PP
You can find another example of use of \f(CW\*(C`bud\*(C'\fR
in the file \f(CW\*(C`examples/ParsingStringsAndTrees/infix2pir.pl\*(C'\fR
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Node5.16.3pm                   0100644 0001750 0001750 00000223157 12566242265 025056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Node 3"
.TH Parse::Eyapp::Node 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Node \- The nodes of the Syntax Trees
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  sub TERMINAL::info {
\&    $_[0]{attr}
\&  }
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line:
\&        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    /* The %name directive defines the name of the class to 
\&       which the node being built belongs */
\&    exp:
\&        %name NUM
\&        NUM
\&      | %name VAR
\&        VAR
\&      | %name ASSIGN
\&        VAR \*(Aq=\*(Aq exp
\&      | %name PLUS
\&        exp \*(Aq+\*(Aq exp
\&      | %name MINUS
\&        exp \*(Aq\-\*(Aq exp
\&      | %name TIMES
\&        exp \*(Aq*\*(Aq exp
\&      | %name DIV
\&        exp \*(Aq/\*(Aq exp
\&      | %name UMINUS
\&        \*(Aq\-\*(Aq exp %prec NEG
\&      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&          { $_[2] }  /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&
\&    sub _Lexer {
\&      my($parser)=shift; # The parser object
\&
\&      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&        m{\eG\es+}gc;
\&        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&        m{\eG(.)}gcs and return($1,$1);
\&      }
\&      return(\*(Aq\*(Aq,undef);
\&    }
\&
\&    sub Run {
\&        my($self)=shift;
\&        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    }
\&  }; # end grammar
\&
\&  our (@all, $uminus);
\&
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&  );
\&  my $parser = Calc\->new();                # Create a parser
\&  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&  my $t = $parser\->Run;                    # Parse it!
\&  local $Parse::Eyapp::Node::INDENT=2;
\&  print "Syntax Tree:",$t\->str;
\&
\&  # Let us transform the tree. Define the tree\-regular expressions ..
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&      { #  Example of support code
\&        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&      }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&        => {
\&          my $op = $Op{ref($bin)};
\&          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&          $_[0] = $NUM[0];
\&        }
\&      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    },
\&    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&  );
\&  $p\->generate(); # Create the tranformations
\&
\&  $t\->s($uminus); # Transform UMINUS nodes
\&  $t\->s(@all);    # constant folding and mult. by zero
\&
\&  local $Parse::Eyapp::Node::INDENT=0;
\&  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.SH "METHODS"
.IX Header "METHODS"
The \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR objects represent the nodes of the syntax
tree. 
All the node classes build by \f(CW%tree\fR and \f(CW%metatree\fR directives
inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and consequently have
acces to the methods provided in such module.
.PP
The examples used in this document can be found in the directory
\&\f(CW\*(C`examples/Node\*(C'\fR accompanying the distribution of Parse::Eyapp.
.SS "Parse::Eyapp::Node\->new"
.IX Subsection "Parse::Eyapp::Node->new"
Nodes are usually created from a Eyapp grammar 
using the \f(CW%tree\fR or \f(CW%metatree\fR
directives. The \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR constructor \f(CW\*(C`new\*(C'\fR
offers an alternative way to create forests.
.PP
This class method can be used to build multiple nodes on a row.
It receives a string describing the tree and optionally a
reference to a subroutine. Such subroutine (called the attribute
handler) is in charge to initialize
the attributes of the just created nodes.
The attribute handler is called with the array of references to the
nodes as they appear in the string from left to right.
.PP
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns an array of pointers to the nodes created
as they appear in the input string from left to right.
In scalar context returns a pointer to the first of these trees.
.PP
The following example (see file \f(CW\*(C`examples/Node/28foldwithnewwithvars.pl\*(C'\fR) of
a treeregexp transformation creates a new \f(CW\*(C`NUM(TERMINAL)\*(C'\fR node
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
.PP
.Vb 7
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   {
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|MINUS|DIV/(NUM($x), NUM($y))
\&      => {
\&     my $op = $Op{ref($_[0])};
\&
\&     my $res = Parse::Eyapp::Node\->new(
\&       q{NUM(TERMINAL)},
\&       sub {
\&         my ($NUM, $TERMINAL) = @_;
\&         $TERMINAL\->{attr} = eval "$x\->{attr} $op $y\->{attr}";
\&         $TERMINAL\->{token} = \*(AqNUM\*(Aq;
\&       },
\&     );
\&     $_[0] = $res;
\&   }
\&   },
\& );
.Ve
.PP
The call to \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR creates a tree \f(CW\*(C`NUM(TERMINAL)\*(C'\fR
and decorates the \f(CW\*(C`TERMINAL\*(C'\fR leaf with attributes \f(CW\*(C`attr\*(C'\fR
and \f(CW\*(C`token\*(C'\fR. The \f(CW\*(C`constantfold\*(C'\fR transformation substitutes
all the binary operation trees whose children are numbers
for a \f(CW\*(C`NUM(TERMINAL)\*(C'\fR tree holding as attribute the 
number resulting of operating the two numbers.
.PP
The input string can describe more than one tree. Different trees 
are separated by white spaces. Consider the following example
(in \f(CW\*(C`examples/Node/builder.pl\*(C'\fR):
.PP
.Vb 10
\&  $ cat \-n builder.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  use Data::Dumper;
\&     6  $Data::Dumper::Indent = 1;
\&     7  $Data::Dumper::Purity = 1;
\&     8
\&     9  my $string = shift || \*(AqASSIGN(VAR(TERMINAL), TIMES(NUM(TERMINAL),NUM(TERMINAL)))  \*(Aq;
\&    10  my @t = Parse::Eyapp::Node\->new(
\&    11             $string,
\&    12             sub { my $i = 0; $_\->{n} = $i++ for @_ }
\&    13          );
\&    14
\&    15  print "****************\en";
\&    16  print Dumper(\e@t);
.Ve
.PP
When feed with input \f(CW\*(AqA(C,D) E(F)\*(Aq\fR 
the following forest is built:
.PP
.Vb 10
\&  $ builder.pl \*(AqA(C,D) E(F)\*(Aq
\&  ****************
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqn\*(Aq => 0,
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqn\*(Aq => 1, \*(Aqchildren\*(Aq => [] }, \*(AqC\*(Aq ),
\&        bless( { \*(Aqn\*(Aq => 2, \*(Aqchildren\*(Aq => [] }, \*(AqD\*(Aq )
\&      ]
\&    }, \*(AqA\*(Aq ),
\&    {},
\&    {},
\&    bless( {
\&      \*(Aqn\*(Aq => 3,
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqn\*(Aq => 4, \*(Aqchildren\*(Aq => [] }, \*(AqF\*(Aq )
\&      ]
\&    }, \*(AqE\*(Aq ),
\&    {}
\&  ];
\&  $VAR1\->[1] = $VAR1\->[0]{\*(Aqchildren\*(Aq}[0];
\&  $VAR1\->[2] = $VAR1\->[0]{\*(Aqchildren\*(Aq}[1];
\&  $VAR1\->[4] = $VAR1\->[3]{\*(Aqchildren\*(Aq}[0];
.Ve
.PP
Thusm, the forest \f(CW@t\fR contains 5 subtrees 
\&\f(CW\*(C`A(C,D), C, D, E(F)\*(C'\fR and \f(CW\*(C`F\*(C'\fR.
.ie n .SS "Directed Acyclic Graphs with ""Parse::Eyapp::Node\->hnew"""
.el .SS "Directed Acyclic Graphs with \f(CWParse::Eyapp::Node\->hnew\fP"
.IX Subsection "Directed Acyclic Graphs with Parse::Eyapp::Node->hnew"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR provides the method \f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR
to build \fIDirected Acyclic Graphs\fR (DAGs) instead of trees. They are built using 
\&\fIhashed consing\fR, i.e. \fImemoizing\fR the creation of nodes.
.PP
The method \f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR works very much like \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
but if one of the implied trees was previously built, \f(CW\*(C`hnew\*(C'\fR 
returns a reference to the existing one.
.PP
See the following debugger session where several DAGs describing
\&\fItype expressions\fR are built:
.PP
.Vb 10
\&  DB<2> x $a = Parse::Eyapp::Node\->hnew(\*(AqF(X_3(A_3(A_5(INT)), CHAR, A_5(INT)),CHAR)\*(Aq)
\& 0  F=HASH(0x85f6a20)
\&    \*(Aqchildren\*(Aq => ARRAY(0x85e92e4)
\&    |\- 0  X_3=HASH(0x83f55fc)
\&    |     \*(Aqchildren\*(Aq => ARRAY(0x83f5608)
\&    |     |\- 0  A_3=HASH(0x85a0488)
\&    |     |     \*(Aqchildren\*(Aq => ARRAY(0x859fad4)
\&    |     |        0  A_5=HASH(0x85e5d3c)
\&    |     |           \*(Aqchildren\*(Aq => ARRAY(0x83f4120)
\&    |     |              0  INT=HASH(0x83f5200)
\&    |     |                 \*(Aqchildren\*(Aq => ARRAY(0x852ccb4)
\&    |     |                      empty array
\&    |     |\- 1  CHAR=HASH(0x8513564)
\&    |     |     \*(Aqchildren\*(Aq => ARRAY(0x852cad4)
\&    |     |          empty array
\&    |     \`\- 2  A_5=HASH(0x85e5d3c)
\&    |           \-> REUSED_ADDRESS
\&    \`\- 1  CHAR=HASH(0x8513564)
\&          \-> REUSED_ADDRESS
\&  DB<3> x $a\->str
\& 0  \*(AqF(X_3(A_3(A_5(INT)),CHAR,A_5(INT)),CHAR)\*(Aq
.Ve
.PP
The second occurrence of \f(CW\*(C`A_5(INT)\*(C'\fR is labelled \f(CW\*(C`REUSED_ADDRESS\*(C'\fR. The
same occurs with the second instance  of \f(CW\*(C`CHAR\*(C'\fR.
.PP
\&\f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR
can be more convenient than \f(CW\*(C`new\*(C'\fR 
in some compiler phases and tasks like 
detecting \fIcommon subexpressions\fR
or during \fItype checking\fR. 
See file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
for a more comprehensive example.
.ie n .SS "Expanding Directed Acyclic Graphs with ""Parse::Eyapp::Node\->hexpand"""
.el .SS "Expanding Directed Acyclic Graphs with \f(CWParse::Eyapp::Node\->hexpand\fP"
.IX Subsection "Expanding Directed Acyclic Graphs with Parse::Eyapp::Node->hexpand"
Calls to \f(CW\*(C`Parse::Eyapp::Node\->hexpand\*(C'\fR have the syntax
.PP
.Vb 1
\&    $z = Parse::Eyapp::Node\->hexpand(\*(AqCLASS\*(Aq, @children, \e&handler)
.Ve
.PP
Creates a dag of type \f(CW\*(AqCLASS\*(Aq\fR with children \f(CW@children\fR in a way compatible with
\&\f(CW\*(C`hnew\*(C'\fR. The last 
optional argument can be a reference to a sub.  Such sub will be called after the
creation of the \s-1DAG\s0 with a reference to the root of the \s-1DAG\s0 as single argument.
The following session with the debugger illustrates the use of
 \f(CW\*(C`Parse::Eyapp::Node\->hexpand\*(C'\fR. First we create a \s-1DAG\s0 using \f(CW\*(C`hnew\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->hnew(\*(AqA(C(B),C(B))\*(Aq)
\&    DB<2> x $x
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
.Ve
.PP
We obtain the \f(CW\*(C`REUSED_ADDRESS\*(C'\fR for the second child since
the \f(CWC(B)\fR subtree appears twice.
Now, suppose we want to expand the exsting tree/DAG \f(CWC(B)\fR to \f(CW\*(C`A(C(B))\*(C'\fR. We can do
that using \f(CW\*(C`hexpand\*(C'\fR:
.PP
.Vb 12
\&    DB<3> $y = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->child(0))
\&    DB<4> x $y
\&  0  A=HASH(0x8592558)
\&     \*(Aqchildren\*(Aq => ARRAY(0x832613c)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&We get new memory for C<$y>: C<HASH(0x8592558)> is anew address.
\&Assume we want to expand the tree/DAG C<C(B)> to C<A(C(B),C(B))>.
\&We can do it this way:
\&
\&    DB<5> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children)
\&    DB<6> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
.Ve
.PP
Notice that the address c<0x850c850> for \f(CW$z\fR is the same than the address for \f(CW$x\fR.
No new memory has been allocated for \f(CW$z\fR.
.PP
The following command illustrates the use of \f(CW\*(C`hexpand\*(C'\fR
with a handler:
.PP
.Vb 12
\&    DB<7> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children, sub { $_[0]\->{t} = "X" })
\&    DB<8> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
\&     \*(Aqt\*(Aq => \*(AqX\*(Aq
.Ve
.ie n .SS "$node\->type"
.el .SS "\f(CW$node\fP\->type"
.IX Subsection "$node->type"
Returns (or sets) the type (class) of the node.
It can be called as a subroutine when \f(CW$node\fR is not
a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR like this:
.PP
.Vb 1
\&                     Parse::Eyapp::Node::type($scalar)
.Ve
.PP
This is the case when visiting \f(CW\*(C`CODE\*(C'\fR nodes.
.PP
The following session with the debugger illustrates how it works:
.PP
.Vb 10
\&  > perl \-MParse::Eyapp::Node \-de0
\&  DB<1> @t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  DB<2> x map { $_\->type } @t # Get the types of the three nodes
\&  0  \*(AqA\*(Aq
\&  1  \*(AqB\*(Aq
\&  2  \*(AqC\*(Aq
\&  DB<3> x Parse::Eyapp::Node::type(sub {})
\&  0  \*(AqCODE\*(Aq
\&  DB<4> x Parse::Eyapp::Node::type("hola")
\&  0  \*(AqParse::Eyapp::Node::STRING\*(Aq
\&  DB<5> x Parse::Eyapp::Node::type({ a=> 1})
\&  0  \*(AqHASH\*(Aq
\&  DB<6> x Parse::Eyapp::Node::type([ a, 1 ])
\&  0  \*(AqARRAY\*(Aq
.Ve
.PP
As it is shown in the example it can be called as a subroutine with 
a (\s-1CODE/HASH/ARRAY\s0) reference or an ordinary scalar.
.PP
The words \s-1HASH\s0, \s-1CODE\s0, \s-1ARRAY\s0 and \s-1STRING\s0 are reserved for 
ordinary Perl references. Avoid naming a \s-1AST\s0 node with one of those words.
.PP
To be used as a setter, be sure Parse::Eyapp::Driver
is loaded:
.PP
.Vb 10
\&  $ perl \-MParse::Eyapp::Driver \-MParse::Eyapp::Node \-wde0
\&  main::(\-e:1):   0
\&    DB<1> x $t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  0  A=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<2> x $t\->type(\*(AqFUN\*(Aq) # Change the type of $t to \*(AqFUN\*(Aq
\&  0  \*(AqFUN\*(Aq
\&    DB<3> x $t
\&  0  FUN=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<4> x $t\->isa(\*(AqParse::Eyapp::Node\*(Aq)
\&  0  1
.Ve
.ie n .SS "$node\->child"
.el .SS "\f(CW$node\fP\->child"
.IX Subsection "$node->child"
Setter-getter to modify a specific child of a node.
It is called like:
.PP
.Vb 1
\&                   $node\->child($i)
.Ve
.PP
Returns the child with index \f(CW$i\fR. Returns \f(CW\*(C`undef\*(C'\fR if the child does not exists.
It has two obligatory parameters: the node (since it is a method)
and the index of the child. Sets the new value if called
.PP
.Vb 1
\&                    $node\->child($i, $tree)
.Ve
.PP
The method will croak if the obligatory parameters are not provided.
.PP
In the files \f(CW\*(C`examples/Node/TSwithtreetransformations2.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/node/usetswithtreetransformations2.pl\*(C'\fR) you can find a 
somewhat complicated example of call to \f(CW\*(C`child\*(C'\fR as a setter. It is inside a transformation
that swaps the children of a \f(CW\*(C`PLUS\*(C'\fR node (remember that the tree
is a concrete tree including code since it is a translation scheme
built under the directive \f(CW%metatree\fR):
.PP
.Vb 2
\&  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&     ........................................................
\&
\&     commutative_add: PLUS($x, ., $y, .) # 1st dot correspond to \*(Aq+\*(Aq 2nd dot to CODE
\&       => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&
\&     ........................................................
\&  }
.Ve
.ie n .SS "Child Access Through ""%tree alias"""
.el .SS "Child Access Through \f(CW%tree alias\fP"
.IX Subsection "Child Access Through %tree alias"
Remember that when the \f(CW\*(C`Eyapp\*(C'\fR program runs 
under the \f(CW\*(C`%tree alias\*(C'\fR directive 
The \fIdot and dollar notations\fR can be used 
to generate named getter-setters to access the children:
.PP
.Vb 10
\&  examples/Node$ cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    40
\&    .............................
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
Here methods with names \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR will be created
inside the class \f(CW\*(C`R::S\*(C'\fR (see the use of the \f(CW%prefix\fR directive
in line 7) to access the corresponding children associated with the 
two instances of \f(CW\*(C`exp\*(C'\fR in the right hand side of
the production rule. when executed, teh former program produces this
output:
.PP
.Vb 6
\&  examples/Node$ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.ie n .SS "$node\->children"
.el .SS "\f(CW$node\fP\->children"
.IX Subsection "$node->children"
Returns the array of children of the node. When the tree is a
translation scheme the \s-1CODE\s0 references are also included.
See \f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example of use
inside a Translation Scheme:
.PP
.Vb 2
\&  examples/Node$ cat TSPostfix3.eyp
\&  ...................... # precedence declarations
\&
\&  %metatree
\&
\&  %defaultaction {
\&    if (@_==2) {  # NUM and VAR
\&      $lhs\->{t} = $_[1]\->{attr};
\&      return
\&    }
\&    if (@_==4) { # binary operations
\&      $lhs\->{t} = "$_[1]\->{t} $_[3]\->{t} $_[2]\->{attr}";
\&      return
\&    }
\&    die "Fatal Error. Unexpected input. Numargs = ".scalar(@_)."\en".Parse::Eyapp::Node\->str(@_);
\&  }
\&
\&  %%
\&  line: %name PROG
\&         exp <%name EXP + \*(Aq;\*(Aq>
\&           { @{$lhs\->{t}} = map { $_\->{t}} ($_[1]\->children()); }
\&
\&  ;
\&
\&  exp:        %name NUM NUM
\&          |   %name VAR VAR
\&          |   %name ASSIGN VAR \*(Aq=\*(Aq exp  {  $lhs\->{t} = "$_[1]\->{attr} $_[3]\->{t} ="; }
\&          |   %name PLUS   exp \*(Aq+\*(Aq exp
\&          |   %name MINUS  exp \*(Aq\-\*(Aq exp
\&          |   %name TIMES  exp \*(Aq*\*(Aq exp
\&          |   %name DIV    exp \*(Aq/\*(Aq exp
\&          |   %name NEG    \*(Aq\-\*(Aq exp %prec NEG { $_[0]\->{t} = "$_[2]\->{t} NEG" }
\&          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq %begin { $_[2] }
\&  ;
\&
\&  %%
\&
\&  ........................
.Ve
.PP
The tree in a Translation Scheme contains the references to
the \f(CW\*(C`CODE\*(C'\fR implementing the semantic actions.
For example,  the syntax tree built by 
the parser for the input \f(CW\*(C`a=\-b*3\*(C'\fR in \f(CW\*(C`TSPostfix3.eyp\*(C'\fR is:
.PP
.Vb 10
\& PROG(EXP(
\&     ASSIGN(
\&       TERMINAL[a],
\&       TERMINAL[=],
\&       TIMES(
\&         NEG(TERMINAL[\-], VAR(TERMINAL[b], CODE), CODE),
\&         TERMINAL[*],
\&         NUM(TERMINAL[3], CODE),
\&         CODE
\&       ) # TIMES,
\&       CODE
\&     ) # ASSIGN
\&   ) # EXP,
\&   CODE
\& ) # PROG
.Ve
.PP
\&\f(CW\*(C`$node\->children\*(C'\fR can also be used as a setter.
.ie n .SS "$node\->Children"
.el .SS "\f(CW$node\fP\->Children"
.IX Subsection "$node->Children"
Returns the array of children of the node.
When dealing with a translation scheme,
the  \f(CW\*(C`$node\->Children\*(C'\fR method 
(Notice the case difference with \f(CW\*(C`$node\->children\*(C'\fR, first in uppercase) 
returns the non \f(CW\*(C`CODE\*(C'\fR children of the node.
The following execution with the debugger
of the example in \f(CW\*(C`examples/Node/ts_with_ast.pl\*(C'\fR
illustrates the difference:
.PP
.Vb 3
\&  examples/Node$ perl \-wd ts_with_ast.pl
\&  main::(ts_with_ast.pl:6):       my $translationscheme = q{
\&  main::(ts_with_ast.pl:7):       %{
.Ve
.PP
The \f(CW$translationscheme\fR variable contains the code
of a small calculator:
.PP
.Vb 1
\&  %metatree
\&
\&  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left   \*(Aq*\*(Aq
\&  %left   NEG
\&
\&  %%
\&  line:       %name EXP
\&                $exp  { $lhs\->{n} = $exp\->{n} }
\&  ;
\&
\&  exp:
\&              %name PLUS
\&                exp.left \*(Aq+\*(Aq  exp.right
\&                  { $lhs\->{n} .= $left\->{n} + $right\->{n} }
\&          |   %name TIMES
\&                exp.left \*(Aq*\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} * $right\->{n} }
\&          |   %name NUM   $NUM
\&                  { $lhs\->{n} = $NUM\->{attr} }
\&          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&          |   exp.left \*(Aq\-\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} \- $right\->{n} }
\&
\&          |   \*(Aq\-\*(Aq $exp %prec NEG
\&                  { $lhs\->{n} = \-$exp\->{n} }
\&  ;
.Ve
.PP
We run the program with input \f(CW\*(C`2+(3)\*(C'\fR and stop
it at line 88, just after the augmented \s-1AST\s0 (\f(CW\*(C`CODE\*(C'\fR node included)
has been built:
.PP
.Vb 2
\&    DB<1> c 88
\&  main::(ts_with_ast.pl:88):      $t\->translation_scheme;
.Ve
.PP
Now, let us see the difference between the methods \f(CW\*(C`children\*(C'\fR
and \f(CW\*(C`Children\*(C'\fR:
.PP
.Vb 7
\&    DB<2> @a = $t\->children; @b = $t\->Children
\&    DB<3> print Parse::Eyapp::Node::str($_)."\en" for @a
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&  CODE
\&    DB<4> print $_\->str."\en" for @b
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&    DB<5>
.Ve
.ie n .SS "$node\->last_child"
.el .SS "\f(CW$node\fP\->last_child"
.IX Subsection "$node->last_child"
Return the last child of the node. When dealing with translation
schemes, the last can be a \f(CW\*(C`CODE\*(C'\fR node.
.ie n .SS "$node\->Last_child"
.el .SS "\f(CW$node\fP\->Last_child"
.IX Subsection "$node->Last_child"
The \f(CW\*(C`$node\->Last_child\*(C'\fR method returns the last non \s-1CODE\s0 child of the node.
See an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %prefix Calc::
\&    15
\&    16  %defaultaction {
\&    17     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    18  }
\&    19
\&    20  %metatree
\&    21
\&    22  %right   \*(Aq=\*(Aq
\&    23  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    24  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    25
\&    26  %%
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    30  ;
\&    31
\&    32  exp:
\&    33              %name PLUS
\&    34                exp.left \*(Aq+\*(Aq exp.right
\&    35          |   %name MINUS
\&    36                exp.left \*(Aq\-\*(Aq exp.right
\&    37          |   %name TIMES
\&    38                exp.left \*(Aq*\*(Aq exp.right
\&    39          |   %name DIV
\&    40                exp.left \*(Aq/\*(Aq exp.right
\&    41          |   %name NUM
\&    42                $NUM
\&    43                  { $lhs\->{n} = $NUM\->{attr} }
\&    44          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    45          |   %name VAR
\&    46                $VAR
\&    47                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    48          |   %name ASSIGN
\&    49                $VAR \*(Aq=\*(Aq $exp
\&    50                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    51
\&    52  ;
\&    53
\&    54  %%
\&    55  # tail code is available at tree construction time
\&    ......................................................
\&    77  }; # end translation scheme
\&    78
\&    ......................................................
.Ve
.PP
The node associated with \f(CW$_[1]\fR in
.PP
.Vb 3
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
is associated with the whole expression
.PP
.Vb 1
\&                               exp <+ \*(Aq;\*(Aq>
.Ve
.PP
and is a \f(CW\*(C`Calc::_PLUS_LIST\*(C'\fR node. 
When feed with input \f(CW\*(C`a=3;b=4\*(C'\fR the children are
the two \f(CW\*(C`Calc::ASSIGN\*(C'\fR subtrees associated with
\&\f(CW\*(C`a=3\*(C'\fR and \f(CW\*(C`b=4\*(C'\fR and the \f(CW\*(C`CODE\*(C'\fR associated with the
semantic action:
.PP
.Vb 1
\&            { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
Using \f(CW\*(C`Last_child\*(C'\fR we are avoiding the last \f(CW\*(C`CODE\*(C'\fR
child and setting the \f(CW\*(C`n\*(C'\fR(umeric) attribute
of the \f(CW\*(C`EXP\*(C'\fR node to the one associated with \f(CW\*(C`b=4\*(C'\fR (i.e. \f(CW4\fR).
.PP
.Vb 3
\&  examples/Node$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=3;b=4
\&  ***********Tree*************
\&
\&  Calc::EXP(
\&    Calc::_PLUS_LIST(
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN,
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN
\&    ) # Calc::_PLUS_LIST,
\&    CODE
\&  ) # Calc::EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => { \*(Aqn\*(Aq => \*(Aq3\*(Aq },
\&    \*(Aqb\*(Aq => { \*(Aqn\*(Aq => \*(Aq4\*(Aq }
\&  }
\&
\&  ************Result**********
\&  4
.Ve
.ie n .SS "$node\->descendant"
.el .SS "\f(CW$node\fP\->descendant"
.IX Subsection "$node->descendant"
The \f(CW\*(C` descendant\*(C'\fR method 
returns the descendant of a node given its \fIcoordinates\fR. 
The coordinates of a node \f(CW$s\fR relative to a tree \f(CW$t\fR
to which it belongs is a string of numbers
separated by dots like  \f(CW".1.3.2"\fR which
denotes the \fIchild path\fR from \f(CW$t\fR to \f(CW$s\fR, i.e.
\&\f(CW\*(C`$s == $t\->child(1)\->child(3)\->child(2)\*(C'\fR.
.PP
See a session
with the debugger:
.PP
.Vb 9
\&   DB<7> x $t\->child(0)\->child(0)\->child(1)\->child(0)\->child(2)\->child(1)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
\& )
\&   DB<8> x $t\->descendant(\*(Aq.0.0.1.0.2.1\*(Aq)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
.Ve
.ie n .SS "$node\->str"
.el .SS "\f(CW$node\fP\->str"
.IX Subsection "$node->str"
The \f(CW\*(C`str\*(C'\fR method returns a string representation of the tree. 
The \fIstr\fR method traverses the syntax tree dumping the type
of the node being visited in a string. To be specific
the value returned by the function referenced by \f(CW$CLASS_HANDLER\fR 
will be dumped. The default value fo such function is to return the type
of the node.
If the node being visited
has a method \f(CW\*(C`info\*(C'\fR it will
be executed and its result inserted between \f(CW$DELIMITER\fRs
into the string. Thus, in the \*(L"\s-1SYNOPSIS\s0\*(R"
example, by adding the \f(CW\*(C`info\*(C'\fR method to the class \f(CW\*(C`TERMINAL\*(C'\fR:
.PP
.Vb 3
\& sub TERMINAL::info {
\&   $_[0]{attr}
\& }
.Ve
.PP
we achieve the insertion of attributes in the string being built 
by \f(CW\*(C`str\*(C'\fR.
.PP
The existence of some methods (like \f(CW\*(C`footnote\*(C'\fR) and
the values of some package variables
influence the behavior of \f(CW\*(C`str\*(C'\fR. Among the most
important are:
.PP
.Vb 12
\&  @PREFIXES = qw(Parse::Eyapp::Node::);                                # Prefixes to suppress 
\&  $INDENT = 0; # \-1 compact, no info, no footnotes 
\&               # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
\&  $STRSEP = \*(Aq,\*(Aq;                                # Separator between nodes, by default a comma
\&  $DELIMITER = \*(Aq[\*(Aq;                         # The string returned by C<info> will be enclosed 
\&  $FOOTNOTE_HEADER = "\en\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en"; 
\&  $FOOTNOTE_SEP = ")\en"; 
\&  $FOOTNOTE_LEFT = \*(Aq^{\*(Aq;                               # Left delimiter for a footnote number
\&  $FOOTNOTE_RIGHT = \*(Aq}\*(Aq;                              # Right delimiter for a footnote number
\&  $LINESEP = 4;                             # When indent=2 the enclosing parenthesis will be
\&                                            # commented if more than $LINESEP apart
\&  $CLASS_HANDLER = sub { type($_[0]) }; # What to print to identify the node
.Ve
.PP
Footnotes and attribute info will not be inserted when \f(CW$INDENT\fR 
is \-1. A compact representation will be obtained. Such representation 
can be feed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`hnew\*(C'\fR to obtain a copy of the tree. 
See the following session with the debugger:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->new(\*(AqA(B(C,D),D)\*(Aq, sub { $_\->{order} = $i++ for @_; })
\&    DB<2> *A::info = *B::info = *C::info = *D::info = sub { shift()\->{order} }
\&    DB<3> p $x\->str
\&  A[0](B[1](C[2],D[3]),D[4])
\&    DB<4> $Parse::Eyapp::Node::INDENT=\-1
\&    DB<5> p $x\->str
\&  A(B(C,D),D)
\&    DB<6> x Parse::Eyapp::Node\->hnew($x\->str)
\&  0  A=HASH(0x8574704)
\&     \*(Aqchildren\*(Aq => ARRAY(0x85745d8)
\&        0  B=HASH(0x857468c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8574608)
\&              0  C=HASH(0x85745b4)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x8509670)
\&                      empty array
\&              1  D=HASH(0x8574638)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x857450c)
\&                      empty array
\&        1  D=HASH(0x8574638)
\&           \-> REUSED_ADDRESS
\&  1  B=HASH(0x857468c)
\&     \-> REUSED_ADDRESS
\&  2  C=HASH(0x85745b4)
\&     \-> REUSED_ADDRESS
\&  3  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
\&  4  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
.Ve
.PP
The following list defines the \f(CW$DELIMITER\fRs you can choose for 
attribute representation:
.PP
.Vb 1
\&          \*(Aq[\*(Aq => \*(Aq]\*(Aq, \*(Aq{\*(Aq => \*(Aq}\*(Aq, \*(Aq(\*(Aq => \*(Aq)\*(Aq, \*(Aq<\*(Aq => \*(Aq>\*(Aq
.Ve
.PP
If the node being visited has a method  \f(CW\*(C`footnote\*(C'\fR, the string
returned by the method will be concatenated at the end of the 
string as a footnote. The variables \f(CW$FOOTNOTE_LEFT\fR and
\&\f(CW$FOOTNOTE_RIGHT\fR govern the displaying of footnote numbers.
.PP
Follows an example of output using \f(CW\*(C`footnotes\*(C'\fR.
.PP
.Vb 10
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/script> \e
\&                                          usetypes.pl prueba24.c
\& PROGRAM^{0}(FUNCTION[f]^{1}(RETURNINT(TIMES(INUM(TERMINAL[2:2]),VAR(TERMINAL[a:2])))))
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0)
\& Types:
\& $VAR1 = {
\&   \*(AqCHAR\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqCHAR\*(Aq ),
\&   \*(AqVOID\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqVOID\*(Aq ),
\&   \*(AqINT\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqINT\*(Aq ),
\&   \*(AqF(X_1(INT),INT)\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => [
\&       bless( {
\&         \*(Aqchildren\*(Aq => [
\&           $VAR1\->{\*(AqINT\*(Aq}
\&         ]
\&       }, \*(AqX_1\*(Aq ),
\&       $VAR1\->{\*(AqINT\*(Aq}
\&     ]
\&   }, \*(AqF\*(Aq )
\& };
\& Symbol Table:
\& $VAR1 = {
\&   \*(Aqf\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqF(X_1(INT),INT)\*(Aq,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 1)
\& $VAR1 = {
\&   \*(Aqa\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqINT\*(Aq,
\&     \*(Aqparam\*(Aq => 1,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
.Ve
.PP
The first footnote was due to a call to \f(CW\*(C`PROGRAM:footnote\*(C'\fR.
The \f(CW\*(C`footnote\*(C'\fR method for the \f(CW\*(C`PROGRAM\*(C'\fR node was defined as:
.PP
.Vb 8
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                             sed \-n \-e \*(Aq691,696p\*(Aq Types.eyp | cat \-n
\&     1  sub PROGRAM::footnote {
\&     2    return "Types:\en"
\&     3           .Dumper($_[0]\->{types}).
\&     4           "Symbol Table:\en"
\&     5           .Dumper($_[0]\->{symboltable})
\&     6  }
.Ve
.PP
The second footnote was produced by the existence of a
\&\f(CW\*(C`FUNCTION::footnote\*(C'\fR method:
.PP
.Vb 5
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                            sed \-n \-e \*(Aq702,704p\*(Aq Types.eyp | cat \-n
\& 1  sub FUNCTION::footnote {
\& 2    return Dumper($_[0]\->{symboltable})
\& 3  }
.Ve
.PP
The source program for the example was:
.PP
.Vb 3
\&     1  int f(int a) {
\&     2    return 2*a;
\&     3  }
.Ve
.ie n .SS "$node\->equal"
.el .SS "\f(CW$node\fP\->equal"
.IX Subsection "$node->equal"
A call  \f(CW\*(C`$tree1\->equal($tree2)\*(C'\fR  
compare the two trees \f(CW$tree1\fR and \f(CW$tree2\fR. 
Two trees are considered equal if their root nodes belong to the same class,
they have the same number of children and the children are (recursively) equal.
.PP
In Addition to the two trees the programmer can specify
pairs \f(CW\*(C`attribute_key => equality_handler\*(C'\fR:
.PP
.Vb 1
\&  $tree1\->equal($tree2, attr1 => \e&handler1, attr2 => \e&handler2, ...)
.Ve
.PP
In such case 
the definition of equality is more restrictive:
Two trees are considered equal if
.IP "\(bu" 2
Their root nodes belong to the same class,
.IP "\(bu" 2
They have the same number of children
.IP "\(bu" 2
For each of the specified attributes occur
that for both nodes the existence and definition of the key
is the same
.IP "\(bu" 2
Assuming the key exists and is defined for both 
nodes, the equality handlers return
true for each of its attributes and
.IP "\(bu" 2
The respective children are (recursively) equal.
.PP
An attribute handler receives as arguments the values of the attributes
of the two nodes being compared and must return true if, and only if,
these two attributes are considered equal. Follows an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n equal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  my $string1 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     6  my $string2 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     7  my $t1 = Parse::Eyapp::Node\->new($string1, sub { my $i = 0; $_\->{n} = $i++ for @_ });
\&     8  my $t2 = Parse::Eyapp::Node\->new($string2);
\&     9
\&    10  # Without attributes
\&    11  if ($t1\->equal($t2)) {
\&    12    print "\enNot considering attributes: Equal\en";
\&    13  }
\&    14  else {
\&    15    print "\enNot considering attributes: Not Equal\en";
\&    16  }
\&    17
\&    18  # Equality with attributes
\&    19  if ($t1\->equal($t2, n => sub { return $_[0] == $_[1] })) {
\&    20    print "\enConsidering attributes: Equal\en";
\&    21  }
\&    22  else {
\&    23    print "\enConsidering attributes: Not Equal\en";
\&    24  }
.Ve
.PP
When the former program is run without arguments produces the following
output:
.PP
.Vb 1
\&  examples/Node$ equal.pl
\&
\&  Not considering attributes: Equal
\&
\&  Considering attributes: Not Equal
.Ve
.ie n .SS "Using ""equal"" During Testing"
.el .SS "Using \f(CWequal\fP During Testing"
.IX Subsection "Using equal During Testing"
During the development of your compiler you add new stages
to the existing ones. The consequence is that the \s-1AST\s0 is decorated
with new attributes. Unfortunately, this implies that tests you wrote using 
\&\f(CW\*(C`is_deeply\*(C'\fR and comparisons against formerly correct abstract syntax trees are no longer valid.
This is due to the fact that \f(CW\*(C`is_deeply\*(C'\fR requires both tree structures to be
equivalent in every detail and that our new code produces a tree with new attributes.
.PP
Instead of \f(CW\*(C`is_deeply\*(C'\fR use the \f(CW\*(C`equal\*(C'\fR method to check for partial equivalence between
abstract syntax trees. You can follow these steps:
.IP "\(bu" 2
Dump the tree for the source inserting \f(CW\*(C`Data::Dumper\*(C'\fR statements
.IP "\(bu" 2
Carefully check that the tree is really correct
.IP "\(bu" 2
Decide which attributes will be used for comparison
.IP "\(bu" 2
Write the code for the expected value
editing the output produced by \f(CW\*(C`Data::Dumper\*(C'\fR
.IP "\(bu" 2
Write the handlers for the attributes you decided.
Write the comparison using \f(CW\*(C`equal\*(C'\fR.
.PP
Tests using this methodology will not fail even if later code decorating 
the \s-1AST\s0 with new attributes is introduced.
.PP
See an example that checks an abstract syntax tree produced
by the simple compiler (see  \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR) 
for a really simple source:
.PP
.Vb 3
\&  Simple\-Types/script$ cat prueba27.c
\&  int f() {
\&  }
.Ve
.PP
The first thing is to obtain a description of the tree,
that can be done executing the compiler under the control of
the Perl debugger, stopping just after the 
tree has been built and dumping the tree
with Data::Dumper:
.PP
.Vb 11
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-wd usetypes.pl prueba27.c
\&  main::(usetypes.pl:5):  my $filename = shift || die "Usage:\en$0 file.c\en";
\&    DB<1> c 12
\&  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
\&    DB<2> use Data::Dumper
\&    DB<3> $Data::Dumper::Purity = 1
\&    DB<4> p Dumper($t)
\&  $VAR1 = bless( {
\&                   ..............................................
\&                 }, \*(AqPROGRAM\*(Aq );
\&  ...............................................................
.Ve
.PP
Once we have the shape of a correct tree we can write
our tests:
.PP
.Vb 10
\&  examples/Node$ cat \-n testequal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4  use Data::Dumper;
\&     5  use Data::Compare;
\&     6
\&     7  my $debugging = 0;
\&     8
\&     9  my $handler = sub {
\&    10    print Dumper($_[0], $_[1]) if $debugging;
\&    11    Compare($_[0], $_[1])
\&    12  };
\&    13
\&    14  my $t1 = bless( {
\&    15                   \*(Aqtypes\*(Aq => {
\&    16                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    17                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    18                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    19                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    20                                   \*(Aqchildren\*(Aq => [
\&    21                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    22                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    23                                 }, \*(AqF\*(Aq )
\&    24                              },
\&    25                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    26                   \*(Aqlines\*(Aq => 2,
\&    27                   \*(Aqchildren\*(Aq => [
\&    28                                   bless( {
\&    29                                            \*(Aqsymboltable\*(Aq => {},
\&    30                                            \*(Aqfatherblock\*(Aq => {},
\&    31                                            \*(Aqchildren\*(Aq => [],
\&    32                                            \*(Aqdepth\*(Aq => 1,
\&    33                                            \*(Aqparameters\*(Aq => [],
\&    34                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    35                                            \*(AqsymboltableLabel\*(Aq => {},
\&    36                                            \*(Aqline\*(Aq => 1
\&    37                                          }, \*(AqFUNCTION\*(Aq )
\&    38                                 ],
\&    39                   \*(Aqdepth\*(Aq => 0,
\&    40                   \*(Aqline\*(Aq => 1
\&    41                 }, \*(AqPROGRAM\*(Aq );
\&    42  $t1\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t1;
\&    43
\&    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    45  my $t2 = bless( {
\&    46                   \*(Aqtypes\*(Aq => {
\&    47                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    48                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    49                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    50                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    51                                   \*(Aqchildren\*(Aq => [
\&    52                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    53                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    54                                 }, \*(AqF\*(Aq )
\&    55                              },
\&    56                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    57                   \*(Aqchildren\*(Aq => [
\&    58                                   bless( {
\&    59                                            \*(Aqsymboltable\*(Aq => {},
\&    60                                            \*(Aqfatherblock\*(Aq => {},
\&    61                                            \*(Aqchildren\*(Aq => [],
\&    62                                            \*(Aqparameters\*(Aq => [],
\&    63                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    64                                          }, \*(AqFUNCTION\*(Aq )
\&    65                                 ],
\&    66                 }, \*(AqPROGRAM\*(Aq );
\&    67  $t2\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    68
\&    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    70  # and without the symboltable and types attributes used in the comparison
\&    71  my $t3 = bless( {
\&    72                   \*(Aqtypes\*(Aq => {
\&    73                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    74                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    75                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    76                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    77                                   \*(Aqchildren\*(Aq => [
\&    78                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    79                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    80                                 }, \*(AqF\*(Aq )
\&    81                              },
\&    82                   \*(Aqchildren\*(Aq => [
\&    83                                   bless( {
\&    84                                            \*(Aqsymboltable\*(Aq => {},
\&    85                                            \*(Aqfatherblock\*(Aq => {},
\&    86                                            \*(Aqchildren\*(Aq => [],
\&    87                                            \*(Aqparameters\*(Aq => [],
\&    88                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    89                                          }, \*(AqFUNCTION\*(Aq )
\&    90                                 ],
\&    91                 }, \*(AqPROGRAM\*(Aq );
\&    92
\&    93  $t3\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    94
\&    95  # Without attributes
\&    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
\&    97    print "\enNot considering attributes: Equal\en";
\&    98  }
\&    99  else {
\&   100    print "\enNot considering attributes: Not Equal\en";
\&   101  }
\&   102
\&   103  # Equality with attributes
\&   104  if (Parse::Eyapp::Node::equal(
\&   105        $t1, $t2,
\&   106        symboltable => $handler,
\&   107        types => $handler,
\&   108      )
\&   109     ) {
\&   110        print "\enConsidering attributes: Equal\en";
\&   111  }
\&   112  else {
\&   113    print "\enConsidering attributes: Not Equal\en";
\&   114  }
\&   115
\&   116  # Equality with attributes
\&   117  if (Parse::Eyapp::Node::equal(
\&   118        $t1, $t3,
\&   119        symboltable => $handler,
\&   120        types => $handler,
\&   121      )
\&   122     ) {
\&   123        print "\enConsidering attributes: Equal\en";
\&   124  }
\&   125  else {
\&   126    print "\enConsidering attributes: Not Equal\en";
\&   127  }
.Ve
.PP
The code defining tree \f(CW$t1\fR was obtained from an output using \f(CW\*(C`Data::Dumper\*(C'\fR.
The code for trees \f(CW$t2\fR and \f(CW$t3\fR was written using cut-and-paste from \f(CW$t1\fR.
They have the same shape than \f(CW$t1\fR but differ in their attributes. Tree \f(CW$t2\fR
shares with \f(CW$t1\fR the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR used in the comparison
and so \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`true\*(C'\fR when compared. Since \f(CW$t3\fR differs from \f(CW$t1\fR
in the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR the call to \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$node\->delete"
.el .SS "\f(CW$node\fP\->delete"
.IX Subsection "$node->delete"
The \f(CW\*(C`$node\->delete($child)\*(C'\fR method is used to delete the specified child of \f(CW$node\fR.
The child to delete can be specified using the index or a
reference. It returns the deleted child.
.PP
Throws an exception if the object can't do \f(CW\*(C`children\*(C'\fR or has no \f(CW\*(C`children\*(C'\fR.
See also the delete method of treeregexes 
(\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects)
to delete the node being visited.
.PP
The following example moves out of a loop an assignment statement
assuming is an invariant of the loop. To do it, it uses
the \f(CW\*(C`delete\*(C'\fR and \f(CW\*(C`insert_before\*(C'\fR methods:
.PP
.Vb 10
\&  nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&              sed \-ne \*(Aq98,113p\*(Aq moveinvariantoutofloopcomplexformula.pl
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&    FIRSTLINE => 99,
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
.Ve
.PP
The example below deletes \s-1CODE\s0 nodes
from the tree build for a translation scheme:
.PP
.Vb 5
\&  my $transform = Parse::Eyapp::Treeregexp\->new( 
\&    STRING=>q{
\&      delete_code: CODE => { Parse::Eyapp::Node::delete($CODE) }
\&    },
\&  )
.Ve
.PP
Observe how delete is called as a subroutine.
.ie n .SS "$node\->unshift($newchild)"
.el .SS "\f(CW$node\fP\->unshift($newchild)"
.IX Subsection "$node->unshift($newchild)"
Inserts \f(CW$newchild\fR at the beginning of the list of children of \f(CW$node\fR.
See also the unshift method 
for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->push($newchild)"
.el .SS "\f(CW$node\fP\->push($newchild)"
.IX Subsection "$node->push($newchild)"
Inserts \f(CW$newchild\fR at the end of the list of children of \f(CW$node\fR.
.ie n .SS "$node\->insert_before($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_before($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_before($position, $new_child)"
Inserts \f(CW$newchild\fR before \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index
and is not in range. Also if \f(CW$node\fR has no children.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not define
an actual child. In such case \f(CW$new_child\fR is not inserted.
.PP
See also the insert_before 
method for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->insert_after($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_after($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_after($position, $new_child)"
Inserts \f(CW$newchild\fR after \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index and is not
in the range of \f(CW\*(C`$node\-\*(C'\fRchildren>.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not exists
in the list of children. In such case \f(CW$new_child\fR is not inserted.
.ie n .SS "$node\->translation_scheme"
.el .SS "\f(CW$node\fP\->translation_scheme"
.IX Subsection "$node->translation_scheme"
Traverses \f(CW$node\fR. Each time a \s-1CODE\s0 node is visited the subroutine referenced
is called with arguments the node and its children. Usually the code will decorate
the nodes with new attributes or will update existing ones. Obviously this method
does nothing for an ordinary \s-1AST\s0. It is used after compiling
an Eyapp program that makes use of the \f(CW%metatree\fR directive. (See
\&\f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example).
.ie n .SS "$node\->bud(@transformations)"
.el .SS "\f(CW$node\fP\->bud(@transformations)"
.IX Subsection "$node->bud(@transformations)"
Bottom-up decorator. The tree is traversed bottom-up. The set of
transformations in \f(CW@transformations\fR
is applied to each node in the tree referenced by \f(CW$node\fR
in the order
supplied by the user. \fIAs soon as one succeeds
no more transformations are applied\fR.
.PP
For an example  see the files \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
and \f(CW\*(C`lib/Simple/Trans.trg\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
shows an extract of the type-checking phase of a toy-example compiler:
.PP
.Vb 10
\&  examples/typechecking/Simple\-Types\-0.4/lib/Simple$  sed \-ne \*(Aq600,613p\*(Aq Types.eyp
\&   my @typecheck = (     # Check typing transformations for
\&     our $inum,          # \- Numerical constantss
\&     our $charconstant,  # \- Character constants
\&     our $bin,           # \- Binary Operations
\&     our $arrays,        # \- Arrays
\&     our $assign,        # \- Assignments
\&     our $control,       # \- Flow control sentences
\&     our $functioncall,  # \- Function calls
\&     our $statements,    # \- Those nodes with void type
\&                         #   (STATEMENTS, PROGRAM, etc.)
\&     our $returntype,    # \- Return
\&   );
\&
\&   $t\->bud(@typecheck);
.Ve
.PP
You can find another example of use of \f(CW\*(C`bud\*(C'\fR
in the file \f(CW\*(C`examples/ParsingStringsAndTrees/infix2pir.pl\*(C'\fR
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW  Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at http://code.google.com/p/parse\-eyapp/ <http://code.google.com/p/parse-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Node5.18.3pm                   0100644 0001750 0001750 00000223213 12566242263 025047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Node 3"
.TH Parse::Eyapp::Node 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Node \- The nodes of the Syntax Trees
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  sub TERMINAL::info {
\&    $_[0]{attr}
\&  }
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line:
\&        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    /* The %name directive defines the name of the class to 
\&       which the node being built belongs */
\&    exp:
\&        %name NUM
\&        NUM
\&      | %name VAR
\&        VAR
\&      | %name ASSIGN
\&        VAR \*(Aq=\*(Aq exp
\&      | %name PLUS
\&        exp \*(Aq+\*(Aq exp
\&      | %name MINUS
\&        exp \*(Aq\-\*(Aq exp
\&      | %name TIMES
\&        exp \*(Aq*\*(Aq exp
\&      | %name DIV
\&        exp \*(Aq/\*(Aq exp
\&      | %name UMINUS
\&        \*(Aq\-\*(Aq exp %prec NEG
\&      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&          { $_[2] }  /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&
\&    sub _Lexer {
\&      my($parser)=shift; # The parser object
\&
\&      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&        m{\eG\es+}gc;
\&        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&        m{\eG(.)}gcs and return($1,$1);
\&      }
\&      return(\*(Aq\*(Aq,undef);
\&    }
\&
\&    sub Run {
\&        my($self)=shift;
\&        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    }
\&  }; # end grammar
\&
\&  our (@all, $uminus);
\&
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&  );
\&  my $parser = Calc\->new();                # Create a parser
\&  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&  my $t = $parser\->Run;                    # Parse it!
\&  local $Parse::Eyapp::Node::INDENT=2;
\&  print "Syntax Tree:",$t\->str;
\&
\&  # Let us transform the tree. Define the tree\-regular expressions ..
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&      { #  Example of support code
\&        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&      }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&        => {
\&          my $op = $Op{ref($bin)};
\&          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&          $_[0] = $NUM[0];
\&        }
\&      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    },
\&    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&  );
\&  $p\->generate(); # Create the tranformations
\&
\&  $t\->s($uminus); # Transform UMINUS nodes
\&  $t\->s(@all);    # constant folding and mult. by zero
\&
\&  local $Parse::Eyapp::Node::INDENT=0;
\&  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.SH "METHODS"
.IX Header "METHODS"
The \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR objects represent the nodes of the syntax
tree. 
All the node classes build by \f(CW%tree\fR and \f(CW%metatree\fR directives
inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and consequently have
acces to the methods provided in such module.
.PP
The examples used in this document can be found in the directory
\&\f(CW\*(C`examples/Node\*(C'\fR accompanying the distribution of Parse::Eyapp.
.SS "Parse::Eyapp::Node\->new"
.IX Subsection "Parse::Eyapp::Node->new"
Nodes are usually created from a Eyapp grammar 
using the \f(CW%tree\fR or \f(CW%metatree\fR
directives. The \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR constructor \f(CW\*(C`new\*(C'\fR
offers an alternative way to create forests.
.PP
This class method can be used to build multiple nodes on a row.
It receives a string describing the tree and optionally a
reference to a subroutine. Such subroutine (called the attribute
handler) is in charge to initialize
the attributes of the just created nodes.
The attribute handler is called with the array of references to the
nodes as they appear in the string from left to right.
.PP
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns an array of pointers to the nodes created
as they appear in the input string from left to right.
In scalar context returns a pointer to the first of these trees.
.PP
The following example (see file \f(CW\*(C`examples/Node/28foldwithnewwithvars.pl\*(C'\fR) of
a treeregexp transformation creates a new \f(CW\*(C`NUM(TERMINAL)\*(C'\fR node
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
.PP
.Vb 7
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   {
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|MINUS|DIV/(NUM($x), NUM($y))
\&      => {
\&     my $op = $Op{ref($_[0])};
\&
\&     my $res = Parse::Eyapp::Node\->new(
\&       q{NUM(TERMINAL)},
\&       sub {
\&         my ($NUM, $TERMINAL) = @_;
\&         $TERMINAL\->{attr} = eval "$x\->{attr} $op $y\->{attr}";
\&         $TERMINAL\->{token} = \*(AqNUM\*(Aq;
\&       },
\&     );
\&     $_[0] = $res;
\&   }
\&   },
\& );
.Ve
.PP
The call to \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR creates a tree \f(CW\*(C`NUM(TERMINAL)\*(C'\fR
and decorates the \f(CW\*(C`TERMINAL\*(C'\fR leaf with attributes \f(CW\*(C`attr\*(C'\fR
and \f(CW\*(C`token\*(C'\fR. The \f(CW\*(C`constantfold\*(C'\fR transformation substitutes
all the binary operation trees whose children are numbers
for a \f(CW\*(C`NUM(TERMINAL)\*(C'\fR tree holding as attribute the 
number resulting of operating the two numbers.
.PP
The input string can describe more than one tree. Different trees 
are separated by white spaces. Consider the following example
(in \f(CW\*(C`examples/Node/builder.pl\*(C'\fR):
.PP
.Vb 10
\&  $ cat \-n builder.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  use Data::Dumper;
\&     6  $Data::Dumper::Indent = 1;
\&     7  $Data::Dumper::Purity = 1;
\&     8
\&     9  my $string = shift || \*(AqASSIGN(VAR(TERMINAL), TIMES(NUM(TERMINAL),NUM(TERMINAL)))  \*(Aq;
\&    10  my @t = Parse::Eyapp::Node\->new(
\&    11             $string,
\&    12             sub { my $i = 0; $_\->{n} = $i++ for @_ }
\&    13          );
\&    14
\&    15  print "****************\en";
\&    16  print Dumper(\e@t);
.Ve
.PP
When feed with input \f(CW\*(AqA(C,D) E(F)\*(Aq\fR 
the following forest is built:
.PP
.Vb 10
\&  $ builder.pl \*(AqA(C,D) E(F)\*(Aq
\&  ****************
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqn\*(Aq => 0,
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqn\*(Aq => 1, \*(Aqchildren\*(Aq => [] }, \*(AqC\*(Aq ),
\&        bless( { \*(Aqn\*(Aq => 2, \*(Aqchildren\*(Aq => [] }, \*(AqD\*(Aq )
\&      ]
\&    }, \*(AqA\*(Aq ),
\&    {},
\&    {},
\&    bless( {
\&      \*(Aqn\*(Aq => 3,
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqn\*(Aq => 4, \*(Aqchildren\*(Aq => [] }, \*(AqF\*(Aq )
\&      ]
\&    }, \*(AqE\*(Aq ),
\&    {}
\&  ];
\&  $VAR1\->[1] = $VAR1\->[0]{\*(Aqchildren\*(Aq}[0];
\&  $VAR1\->[2] = $VAR1\->[0]{\*(Aqchildren\*(Aq}[1];
\&  $VAR1\->[4] = $VAR1\->[3]{\*(Aqchildren\*(Aq}[0];
.Ve
.PP
Thusm, the forest \f(CW@t\fR contains 5 subtrees 
\&\f(CW\*(C`A(C,D), C, D, E(F)\*(C'\fR and \f(CW\*(C`F\*(C'\fR.
.ie n .SS "Directed Acyclic Graphs with ""Parse::Eyapp::Node\->hnew"""
.el .SS "Directed Acyclic Graphs with \f(CWParse::Eyapp::Node\->hnew\fP"
.IX Subsection "Directed Acyclic Graphs with Parse::Eyapp::Node->hnew"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR provides the method \f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR
to build \fIDirected Acyclic Graphs\fR (DAGs) instead of trees. They are built using 
\&\fIhashed consing\fR, i.e. \fImemoizing\fR the creation of nodes.
.PP
The method \f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR works very much like \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
but if one of the implied trees was previously built, \f(CW\*(C`hnew\*(C'\fR 
returns a reference to the existing one.
.PP
See the following debugger session where several DAGs describing
\&\fItype expressions\fR are built:
.PP
.Vb 10
\&  DB<2> x $a = Parse::Eyapp::Node\->hnew(\*(AqF(X_3(A_3(A_5(INT)), CHAR, A_5(INT)),CHAR)\*(Aq)
\& 0  F=HASH(0x85f6a20)
\&    \*(Aqchildren\*(Aq => ARRAY(0x85e92e4)
\&    |\- 0  X_3=HASH(0x83f55fc)
\&    |     \*(Aqchildren\*(Aq => ARRAY(0x83f5608)
\&    |     |\- 0  A_3=HASH(0x85a0488)
\&    |     |     \*(Aqchildren\*(Aq => ARRAY(0x859fad4)
\&    |     |        0  A_5=HASH(0x85e5d3c)
\&    |     |           \*(Aqchildren\*(Aq => ARRAY(0x83f4120)
\&    |     |              0  INT=HASH(0x83f5200)
\&    |     |                 \*(Aqchildren\*(Aq => ARRAY(0x852ccb4)
\&    |     |                      empty array
\&    |     |\- 1  CHAR=HASH(0x8513564)
\&    |     |     \*(Aqchildren\*(Aq => ARRAY(0x852cad4)
\&    |     |          empty array
\&    |     \`\- 2  A_5=HASH(0x85e5d3c)
\&    |           \-> REUSED_ADDRESS
\&    \`\- 1  CHAR=HASH(0x8513564)
\&          \-> REUSED_ADDRESS
\&  DB<3> x $a\->str
\& 0  \*(AqF(X_3(A_3(A_5(INT)),CHAR,A_5(INT)),CHAR)\*(Aq
.Ve
.PP
The second occurrence of \f(CW\*(C`A_5(INT)\*(C'\fR is labelled \f(CW\*(C`REUSED_ADDRESS\*(C'\fR. The
same occurs with the second instance  of \f(CW\*(C`CHAR\*(C'\fR.
.PP
\&\f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR
can be more convenient than \f(CW\*(C`new\*(C'\fR 
in some compiler phases and tasks like 
detecting \fIcommon subexpressions\fR
or during \fItype checking\fR. 
See file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
for a more comprehensive example.
.ie n .SS "Expanding Directed Acyclic Graphs with ""Parse::Eyapp::Node\->hexpand"""
.el .SS "Expanding Directed Acyclic Graphs with \f(CWParse::Eyapp::Node\->hexpand\fP"
.IX Subsection "Expanding Directed Acyclic Graphs with Parse::Eyapp::Node->hexpand"
Calls to \f(CW\*(C`Parse::Eyapp::Node\->hexpand\*(C'\fR have the syntax
.PP
.Vb 1
\&    $z = Parse::Eyapp::Node\->hexpand(\*(AqCLASS\*(Aq, @children, \e&handler)
.Ve
.PP
Creates a dag of type \f(CW\*(AqCLASS\*(Aq\fR with children \f(CW@children\fR in a way compatible with
\&\f(CW\*(C`hnew\*(C'\fR. The last 
optional argument can be a reference to a sub.  Such sub will be called after the
creation of the \s-1DAG\s0 with a reference to the root of the \s-1DAG\s0 as single argument.
The following session with the debugger illustrates the use of
 \f(CW\*(C`Parse::Eyapp::Node\->hexpand\*(C'\fR. First we create a \s-1DAG\s0 using \f(CW\*(C`hnew\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->hnew(\*(AqA(C(B),C(B))\*(Aq)
\&    DB<2> x $x
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
.Ve
.PP
We obtain the \f(CW\*(C`REUSED_ADDRESS\*(C'\fR for the second child since
the \f(CWC(B)\fR subtree appears twice.
Now, suppose we want to expand the exsting tree/DAG \f(CWC(B)\fR to \f(CW\*(C`A(C(B))\*(C'\fR. We can do
that using \f(CW\*(C`hexpand\*(C'\fR:
.PP
.Vb 12
\&    DB<3> $y = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->child(0))
\&    DB<4> x $y
\&  0  A=HASH(0x8592558)
\&     \*(Aqchildren\*(Aq => ARRAY(0x832613c)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&We get new memory for C<$y>: C<HASH(0x8592558)> is anew address.
\&Assume we want to expand the tree/DAG C<C(B)> to C<A(C(B),C(B))>.
\&We can do it this way:
\&
\&    DB<5> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children)
\&    DB<6> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
.Ve
.PP
Notice that the address c<0x850c850> for \f(CW$z\fR is the same than the address for \f(CW$x\fR.
No new memory has been allocated for \f(CW$z\fR.
.PP
The following command illustrates the use of \f(CW\*(C`hexpand\*(C'\fR
with a handler:
.PP
.Vb 12
\&    DB<7> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children, sub { $_[0]\->{t} = "X" })
\&    DB<8> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
\&     \*(Aqt\*(Aq => \*(AqX\*(Aq
.Ve
.ie n .SS "$node\->type"
.el .SS "\f(CW$node\fP\->type"
.IX Subsection "$node->type"
Returns (or sets) the type (class) of the node.
It can be called as a subroutine when \f(CW$node\fR is not
a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR like this:
.PP
.Vb 1
\&                     Parse::Eyapp::Node::type($scalar)
.Ve
.PP
This is the case when visiting \f(CW\*(C`CODE\*(C'\fR nodes.
.PP
The following session with the debugger illustrates how it works:
.PP
.Vb 10
\&  > perl \-MParse::Eyapp::Node \-de0
\&  DB<1> @t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  DB<2> x map { $_\->type } @t # Get the types of the three nodes
\&  0  \*(AqA\*(Aq
\&  1  \*(AqB\*(Aq
\&  2  \*(AqC\*(Aq
\&  DB<3> x Parse::Eyapp::Node::type(sub {})
\&  0  \*(AqCODE\*(Aq
\&  DB<4> x Parse::Eyapp::Node::type("hola")
\&  0  \*(AqParse::Eyapp::Node::STRING\*(Aq
\&  DB<5> x Parse::Eyapp::Node::type({ a=> 1})
\&  0  \*(AqHASH\*(Aq
\&  DB<6> x Parse::Eyapp::Node::type([ a, 1 ])
\&  0  \*(AqARRAY\*(Aq
.Ve
.PP
As it is shown in the example it can be called as a subroutine with 
a (\s-1CODE/HASH/ARRAY\s0) reference or an ordinary scalar.
.PP
The words \s-1HASH, CODE, ARRAY\s0 and \s-1STRING\s0 are reserved for 
ordinary Perl references. Avoid naming a \s-1AST\s0 node with one of those words.
.PP
To be used as a setter, be sure Parse::Eyapp::Driver
is loaded:
.PP
.Vb 10
\&  $ perl \-MParse::Eyapp::Driver \-MParse::Eyapp::Node \-wde0
\&  main::(\-e:1):   0
\&    DB<1> x $t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  0  A=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<2> x $t\->type(\*(AqFUN\*(Aq) # Change the type of $t to \*(AqFUN\*(Aq
\&  0  \*(AqFUN\*(Aq
\&    DB<3> x $t
\&  0  FUN=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<4> x $t\->isa(\*(AqParse::Eyapp::Node\*(Aq)
\&  0  1
.Ve
.ie n .SS "$node\->child"
.el .SS "\f(CW$node\fP\->child"
.IX Subsection "$node->child"
Setter-getter to modify a specific child of a node.
It is called like:
.PP
.Vb 1
\&                   $node\->child($i)
.Ve
.PP
Returns the child with index \f(CW$i\fR. Returns \f(CW\*(C`undef\*(C'\fR if the child does not exists.
It has two obligatory parameters: the node (since it is a method)
and the index of the child. Sets the new value if called
.PP
.Vb 1
\&                    $node\->child($i, $tree)
.Ve
.PP
The method will croak if the obligatory parameters are not provided.
.PP
In the files \f(CW\*(C`examples/Node/TSwithtreetransformations2.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/node/usetswithtreetransformations2.pl\*(C'\fR) you can find a 
somewhat complicated example of call to \f(CW\*(C`child\*(C'\fR as a setter. It is inside a transformation
that swaps the children of a \f(CW\*(C`PLUS\*(C'\fR node (remember that the tree
is a concrete tree including code since it is a translation scheme
built under the directive \f(CW%metatree\fR):
.PP
.Vb 2
\&  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&     ........................................................
\&
\&     commutative_add: PLUS($x, ., $y, .) # 1st dot correspond to \*(Aq+\*(Aq 2nd dot to CODE
\&       => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&
\&     ........................................................
\&  }
.Ve
.ie n .SS "Child Access Through ""%tree alias"""
.el .SS "Child Access Through \f(CW%tree alias\fP"
.IX Subsection "Child Access Through %tree alias"
Remember that when the \f(CW\*(C`Eyapp\*(C'\fR program runs 
under the \f(CW\*(C`%tree alias\*(C'\fR directive 
The \fIdot and dollar notations\fR can be used 
to generate named getter-setters to access the children:
.PP
.Vb 10
\&  examples/Node$ cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    40
\&    .............................
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
Here methods with names \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR will be created
inside the class \f(CW\*(C`R::S\*(C'\fR (see the use of the \f(CW%prefix\fR directive
in line 7) to access the corresponding children associated with the 
two instances of \f(CW\*(C`exp\*(C'\fR in the right hand side of
the production rule. when executed, teh former program produces this
output:
.PP
.Vb 6
\&  examples/Node$ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.ie n .SS "$node\->children"
.el .SS "\f(CW$node\fP\->children"
.IX Subsection "$node->children"
Returns the array of children of the node. When the tree is a
translation scheme the \s-1CODE\s0 references are also included.
See \f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example of use
inside a Translation Scheme:
.PP
.Vb 2
\&  examples/Node$ cat TSPostfix3.eyp
\&  ...................... # precedence declarations
\&
\&  %metatree
\&
\&  %defaultaction {
\&    if (@_==2) {  # NUM and VAR
\&      $lhs\->{t} = $_[1]\->{attr};
\&      return
\&    }
\&    if (@_==4) { # binary operations
\&      $lhs\->{t} = "$_[1]\->{t} $_[3]\->{t} $_[2]\->{attr}";
\&      return
\&    }
\&    die "Fatal Error. Unexpected input. Numargs = ".scalar(@_)."\en".Parse::Eyapp::Node\->str(@_);
\&  }
\&
\&  %%
\&  line: %name PROG
\&         exp <%name EXP + \*(Aq;\*(Aq>
\&           { @{$lhs\->{t}} = map { $_\->{t}} ($_[1]\->children()); }
\&
\&  ;
\&
\&  exp:        %name NUM NUM
\&          |   %name VAR VAR
\&          |   %name ASSIGN VAR \*(Aq=\*(Aq exp  {  $lhs\->{t} = "$_[1]\->{attr} $_[3]\->{t} ="; }
\&          |   %name PLUS   exp \*(Aq+\*(Aq exp
\&          |   %name MINUS  exp \*(Aq\-\*(Aq exp
\&          |   %name TIMES  exp \*(Aq*\*(Aq exp
\&          |   %name DIV    exp \*(Aq/\*(Aq exp
\&          |   %name NEG    \*(Aq\-\*(Aq exp %prec NEG { $_[0]\->{t} = "$_[2]\->{t} NEG" }
\&          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq %begin { $_[2] }
\&  ;
\&
\&  %%
\&
\&  ........................
.Ve
.PP
The tree in a Translation Scheme contains the references to
the \f(CW\*(C`CODE\*(C'\fR implementing the semantic actions.
For example,  the syntax tree built by 
the parser for the input \f(CW\*(C`a=\-b*3\*(C'\fR in \f(CW\*(C`TSPostfix3.eyp\*(C'\fR is:
.PP
.Vb 10
\& PROG(EXP(
\&     ASSIGN(
\&       TERMINAL[a],
\&       TERMINAL[=],
\&       TIMES(
\&         NEG(TERMINAL[\-], VAR(TERMINAL[b], CODE), CODE),
\&         TERMINAL[*],
\&         NUM(TERMINAL[3], CODE),
\&         CODE
\&       ) # TIMES,
\&       CODE
\&     ) # ASSIGN
\&   ) # EXP,
\&   CODE
\& ) # PROG
.Ve
.PP
\&\f(CW\*(C`$node\->children\*(C'\fR can also be used as a setter.
.ie n .SS "$node\->Children"
.el .SS "\f(CW$node\fP\->Children"
.IX Subsection "$node->Children"
Returns the array of children of the node.
When dealing with a translation scheme,
the  \f(CW\*(C`$node\->Children\*(C'\fR method 
(Notice the case difference with \f(CW\*(C`$node\->children\*(C'\fR, first in uppercase) 
returns the non \f(CW\*(C`CODE\*(C'\fR children of the node.
The following execution with the debugger
of the example in \f(CW\*(C`examples/Node/ts_with_ast.pl\*(C'\fR
illustrates the difference:
.PP
.Vb 3
\&  examples/Node$ perl \-wd ts_with_ast.pl
\&  main::(ts_with_ast.pl:6):       my $translationscheme = q{
\&  main::(ts_with_ast.pl:7):       %{
.Ve
.PP
The \f(CW$translationscheme\fR variable contains the code
of a small calculator:
.PP
.Vb 1
\&  %metatree
\&
\&  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left   \*(Aq*\*(Aq
\&  %left   NEG
\&
\&  %%
\&  line:       %name EXP
\&                $exp  { $lhs\->{n} = $exp\->{n} }
\&  ;
\&
\&  exp:
\&              %name PLUS
\&                exp.left \*(Aq+\*(Aq  exp.right
\&                  { $lhs\->{n} .= $left\->{n} + $right\->{n} }
\&          |   %name TIMES
\&                exp.left \*(Aq*\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} * $right\->{n} }
\&          |   %name NUM   $NUM
\&                  { $lhs\->{n} = $NUM\->{attr} }
\&          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&          |   exp.left \*(Aq\-\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} \- $right\->{n} }
\&
\&          |   \*(Aq\-\*(Aq $exp %prec NEG
\&                  { $lhs\->{n} = \-$exp\->{n} }
\&  ;
.Ve
.PP
We run the program with input \f(CW\*(C`2+(3)\*(C'\fR and stop
it at line 88, just after the augmented \s-1AST \s0(\f(CW\*(C`CODE\*(C'\fR node included)
has been built:
.PP
.Vb 2
\&    DB<1> c 88
\&  main::(ts_with_ast.pl:88):      $t\->translation_scheme;
.Ve
.PP
Now, let us see the difference between the methods \f(CW\*(C`children\*(C'\fR
and \f(CW\*(C`Children\*(C'\fR:
.PP
.Vb 7
\&    DB<2> @a = $t\->children; @b = $t\->Children
\&    DB<3> print Parse::Eyapp::Node::str($_)."\en" for @a
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&  CODE
\&    DB<4> print $_\->str."\en" for @b
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&    DB<5>
.Ve
.ie n .SS "$node\->last_child"
.el .SS "\f(CW$node\fP\->last_child"
.IX Subsection "$node->last_child"
Return the last child of the node. When dealing with translation
schemes, the last can be a \f(CW\*(C`CODE\*(C'\fR node.
.ie n .SS "$node\->Last_child"
.el .SS "\f(CW$node\fP\->Last_child"
.IX Subsection "$node->Last_child"
The \f(CW\*(C`$node\->Last_child\*(C'\fR method returns the last non \s-1CODE\s0 child of the node.
See an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %prefix Calc::
\&    15
\&    16  %defaultaction {
\&    17     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    18  }
\&    19
\&    20  %metatree
\&    21
\&    22  %right   \*(Aq=\*(Aq
\&    23  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    24  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    25
\&    26  %%
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    30  ;
\&    31
\&    32  exp:
\&    33              %name PLUS
\&    34                exp.left \*(Aq+\*(Aq exp.right
\&    35          |   %name MINUS
\&    36                exp.left \*(Aq\-\*(Aq exp.right
\&    37          |   %name TIMES
\&    38                exp.left \*(Aq*\*(Aq exp.right
\&    39          |   %name DIV
\&    40                exp.left \*(Aq/\*(Aq exp.right
\&    41          |   %name NUM
\&    42                $NUM
\&    43                  { $lhs\->{n} = $NUM\->{attr} }
\&    44          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    45          |   %name VAR
\&    46                $VAR
\&    47                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    48          |   %name ASSIGN
\&    49                $VAR \*(Aq=\*(Aq $exp
\&    50                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    51
\&    52  ;
\&    53
\&    54  %%
\&    55  # tail code is available at tree construction time
\&    ......................................................
\&    77  }; # end translation scheme
\&    78
\&    ......................................................
.Ve
.PP
The node associated with \f(CW$_[1]\fR in
.PP
.Vb 3
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
is associated with the whole expression
.PP
.Vb 1
\&                               exp <+ \*(Aq;\*(Aq>
.Ve
.PP
and is a \f(CW\*(C`Calc::_PLUS_LIST\*(C'\fR node. 
When feed with input \f(CW\*(C`a=3;b=4\*(C'\fR the children are
the two \f(CW\*(C`Calc::ASSIGN\*(C'\fR subtrees associated with
\&\f(CW\*(C`a=3\*(C'\fR and \f(CW\*(C`b=4\*(C'\fR and the \f(CW\*(C`CODE\*(C'\fR associated with the
semantic action:
.PP
.Vb 1
\&            { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
Using \f(CW\*(C`Last_child\*(C'\fR we are avoiding the last \f(CW\*(C`CODE\*(C'\fR
child and setting the \f(CW\*(C`n\*(C'\fR(umeric) attribute
of the \f(CW\*(C`EXP\*(C'\fR node to the one associated with \f(CW\*(C`b=4\*(C'\fR (i.e. \f(CW4\fR).
.PP
.Vb 3
\&  examples/Node$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=3;b=4
\&  ***********Tree*************
\&
\&  Calc::EXP(
\&    Calc::_PLUS_LIST(
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN,
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN
\&    ) # Calc::_PLUS_LIST,
\&    CODE
\&  ) # Calc::EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => { \*(Aqn\*(Aq => \*(Aq3\*(Aq },
\&    \*(Aqb\*(Aq => { \*(Aqn\*(Aq => \*(Aq4\*(Aq }
\&  }
\&
\&  ************Result**********
\&  4
.Ve
.ie n .SS "$node\->descendant"
.el .SS "\f(CW$node\fP\->descendant"
.IX Subsection "$node->descendant"
The \f(CW\*(C` descendant\*(C'\fR method 
returns the descendant of a node given its \fIcoordinates\fR. 
The coordinates of a node \f(CW$s\fR relative to a tree \f(CW$t\fR
to which it belongs is a string of numbers
separated by dots like  \f(CW".1.3.2"\fR which
denotes the \fIchild path\fR from \f(CW$t\fR to \f(CW$s\fR, i.e.
\&\f(CW\*(C`$s == $t\->child(1)\->child(3)\->child(2)\*(C'\fR.
.PP
See a session
with the debugger:
.PP
.Vb 9
\&   DB<7> x $t\->child(0)\->child(0)\->child(1)\->child(0)\->child(2)\->child(1)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
\& )
\&   DB<8> x $t\->descendant(\*(Aq.0.0.1.0.2.1\*(Aq)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
.Ve
.ie n .SS "$node\->str"
.el .SS "\f(CW$node\fP\->str"
.IX Subsection "$node->str"
The \f(CW\*(C`str\*(C'\fR method returns a string representation of the tree. 
The \fIstr\fR method traverses the syntax tree dumping the type
of the node being visited in a string. To be specific
the value returned by the function referenced by \f(CW$CLASS_HANDLER\fR 
will be dumped. The default value fo such function is to return the type
of the node.
If the node being visited
has a method \f(CW\*(C`info\*(C'\fR it will
be executed and its result inserted between \f(CW$DELIMITER\fRs
into the string. Thus, in the \*(L"\s-1SYNOPSIS\*(R"\s0
example, by adding the \f(CW\*(C`info\*(C'\fR method to the class \f(CW\*(C`TERMINAL\*(C'\fR:
.PP
.Vb 3
\& sub TERMINAL::info {
\&   $_[0]{attr}
\& }
.Ve
.PP
we achieve the insertion of attributes in the string being built 
by \f(CW\*(C`str\*(C'\fR.
.PP
The existence of some methods (like \f(CW\*(C`footnote\*(C'\fR) and
the values of some package variables
influence the behavior of \f(CW\*(C`str\*(C'\fR. Among the most
important are:
.PP
.Vb 12
\&  @PREFIXES = qw(Parse::Eyapp::Node::);                                # Prefixes to suppress 
\&  $INDENT = 0; # \-1 compact, no info, no footnotes 
\&               # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
\&  $STRSEP = \*(Aq,\*(Aq;                                # Separator between nodes, by default a comma
\&  $DELIMITER = \*(Aq[\*(Aq;                         # The string returned by C<info> will be enclosed 
\&  $FOOTNOTE_HEADER = "\en\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en"; 
\&  $FOOTNOTE_SEP = ")\en"; 
\&  $FOOTNOTE_LEFT = \*(Aq^{\*(Aq;                               # Left delimiter for a footnote number
\&  $FOOTNOTE_RIGHT = \*(Aq}\*(Aq;                              # Right delimiter for a footnote number
\&  $LINESEP = 4;                             # When indent=2 the enclosing parenthesis will be
\&                                            # commented if more than $LINESEP apart
\&  $CLASS_HANDLER = sub { type($_[0]) }; # What to print to identify the node
.Ve
.PP
Footnotes and attribute info will not be inserted when \f(CW$INDENT\fR 
is \-1. A compact representation will be obtained. Such representation 
can be feed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`hnew\*(C'\fR to obtain a copy of the tree. 
See the following session with the debugger:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->new(\*(AqA(B(C,D),D)\*(Aq, sub { $_\->{order} = $i++ for @_; })
\&    DB<2> *A::info = *B::info = *C::info = *D::info = sub { shift()\->{order} }
\&    DB<3> p $x\->str
\&  A[0](B[1](C[2],D[3]),D[4])
\&    DB<4> $Parse::Eyapp::Node::INDENT=\-1
\&    DB<5> p $x\->str
\&  A(B(C,D),D)
\&    DB<6> x Parse::Eyapp::Node\->hnew($x\->str)
\&  0  A=HASH(0x8574704)
\&     \*(Aqchildren\*(Aq => ARRAY(0x85745d8)
\&        0  B=HASH(0x857468c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8574608)
\&              0  C=HASH(0x85745b4)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x8509670)
\&                      empty array
\&              1  D=HASH(0x8574638)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x857450c)
\&                      empty array
\&        1  D=HASH(0x8574638)
\&           \-> REUSED_ADDRESS
\&  1  B=HASH(0x857468c)
\&     \-> REUSED_ADDRESS
\&  2  C=HASH(0x85745b4)
\&     \-> REUSED_ADDRESS
\&  3  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
\&  4  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
.Ve
.PP
The following list defines the \f(CW$DELIMITER\fRs you can choose for 
attribute representation:
.PP
.Vb 1
\&          \*(Aq[\*(Aq => \*(Aq]\*(Aq, \*(Aq{\*(Aq => \*(Aq}\*(Aq, \*(Aq(\*(Aq => \*(Aq)\*(Aq, \*(Aq<\*(Aq => \*(Aq>\*(Aq
.Ve
.PP
If the node being visited has a method  \f(CW\*(C`footnote\*(C'\fR, the string
returned by the method will be concatenated at the end of the 
string as a footnote. The variables \f(CW$FOOTNOTE_LEFT\fR and
\&\f(CW$FOOTNOTE_RIGHT\fR govern the displaying of footnote numbers.
.PP
Follows an example of output using \f(CW\*(C`footnotes\*(C'\fR.
.PP
.Vb 10
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/script> \e
\&                                          usetypes.pl prueba24.c
\& PROGRAM^{0}(FUNCTION[f]^{1}(RETURNINT(TIMES(INUM(TERMINAL[2:2]),VAR(TERMINAL[a:2])))))
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0)
\& Types:
\& $VAR1 = {
\&   \*(AqCHAR\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqCHAR\*(Aq ),
\&   \*(AqVOID\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqVOID\*(Aq ),
\&   \*(AqINT\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqINT\*(Aq ),
\&   \*(AqF(X_1(INT),INT)\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => [
\&       bless( {
\&         \*(Aqchildren\*(Aq => [
\&           $VAR1\->{\*(AqINT\*(Aq}
\&         ]
\&       }, \*(AqX_1\*(Aq ),
\&       $VAR1\->{\*(AqINT\*(Aq}
\&     ]
\&   }, \*(AqF\*(Aq )
\& };
\& Symbol Table:
\& $VAR1 = {
\&   \*(Aqf\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqF(X_1(INT),INT)\*(Aq,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 1)
\& $VAR1 = {
\&   \*(Aqa\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqINT\*(Aq,
\&     \*(Aqparam\*(Aq => 1,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
.Ve
.PP
The first footnote was due to a call to \f(CW\*(C`PROGRAM:footnote\*(C'\fR.
The \f(CW\*(C`footnote\*(C'\fR method for the \f(CW\*(C`PROGRAM\*(C'\fR node was defined as:
.PP
.Vb 8
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                             sed \-n \-e \*(Aq691,696p\*(Aq Types.eyp | cat \-n
\&     1  sub PROGRAM::footnote {
\&     2    return "Types:\en"
\&     3           .Dumper($_[0]\->{types}).
\&     4           "Symbol Table:\en"
\&     5           .Dumper($_[0]\->{symboltable})
\&     6  }
.Ve
.PP
The second footnote was produced by the existence of a
\&\f(CW\*(C`FUNCTION::footnote\*(C'\fR method:
.PP
.Vb 5
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                            sed \-n \-e \*(Aq702,704p\*(Aq Types.eyp | cat \-n
\& 1  sub FUNCTION::footnote {
\& 2    return Dumper($_[0]\->{symboltable})
\& 3  }
.Ve
.PP
The source program for the example was:
.PP
.Vb 3
\&     1  int f(int a) {
\&     2    return 2*a;
\&     3  }
.Ve
.ie n .SS "$node\->equal"
.el .SS "\f(CW$node\fP\->equal"
.IX Subsection "$node->equal"
A call  \f(CW\*(C`$tree1\->equal($tree2)\*(C'\fR  
compare the two trees \f(CW$tree1\fR and \f(CW$tree2\fR. 
Two trees are considered equal if their root nodes belong to the same class,
they have the same number of children and the children are (recursively) equal.
.PP
In Addition to the two trees the programmer can specify
pairs \f(CW\*(C`attribute_key => equality_handler\*(C'\fR:
.PP
.Vb 1
\&  $tree1\->equal($tree2, attr1 => \e&handler1, attr2 => \e&handler2, ...)
.Ve
.PP
In such case 
the definition of equality is more restrictive:
Two trees are considered equal if
.IP "\(bu" 2
Their root nodes belong to the same class,
.IP "\(bu" 2
They have the same number of children
.IP "\(bu" 2
For each of the specified attributes occur
that for both nodes the existence and definition of the key
is the same
.IP "\(bu" 2
Assuming the key exists and is defined for both 
nodes, the equality handlers return
true for each of its attributes and
.IP "\(bu" 2
The respective children are (recursively) equal.
.PP
An attribute handler receives as arguments the values of the attributes
of the two nodes being compared and must return true if, and only if,
these two attributes are considered equal. Follows an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n equal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  my $string1 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     6  my $string2 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     7  my $t1 = Parse::Eyapp::Node\->new($string1, sub { my $i = 0; $_\->{n} = $i++ for @_ });
\&     8  my $t2 = Parse::Eyapp::Node\->new($string2);
\&     9
\&    10  # Without attributes
\&    11  if ($t1\->equal($t2)) {
\&    12    print "\enNot considering attributes: Equal\en";
\&    13  }
\&    14  else {
\&    15    print "\enNot considering attributes: Not Equal\en";
\&    16  }
\&    17
\&    18  # Equality with attributes
\&    19  if ($t1\->equal($t2, n => sub { return $_[0] == $_[1] })) {
\&    20    print "\enConsidering attributes: Equal\en";
\&    21  }
\&    22  else {
\&    23    print "\enConsidering attributes: Not Equal\en";
\&    24  }
.Ve
.PP
When the former program is run without arguments produces the following
output:
.PP
.Vb 1
\&  examples/Node$ equal.pl
\&
\&  Not considering attributes: Equal
\&
\&  Considering attributes: Not Equal
.Ve
.ie n .SS "Using ""equal"" During Testing"
.el .SS "Using \f(CWequal\fP During Testing"
.IX Subsection "Using equal During Testing"
During the development of your compiler you add new stages
to the existing ones. The consequence is that the \s-1AST\s0 is decorated
with new attributes. Unfortunately, this implies that tests you wrote using 
\&\f(CW\*(C`is_deeply\*(C'\fR and comparisons against formerly correct abstract syntax trees are no longer valid.
This is due to the fact that \f(CW\*(C`is_deeply\*(C'\fR requires both tree structures to be
equivalent in every detail and that our new code produces a tree with new attributes.
.PP
Instead of \f(CW\*(C`is_deeply\*(C'\fR use the \f(CW\*(C`equal\*(C'\fR method to check for partial equivalence between
abstract syntax trees. You can follow these steps:
.IP "\(bu" 2
Dump the tree for the source inserting \f(CW\*(C`Data::Dumper\*(C'\fR statements
.IP "\(bu" 2
Carefully check that the tree is really correct
.IP "\(bu" 2
Decide which attributes will be used for comparison
.IP "\(bu" 2
Write the code for the expected value
editing the output produced by \f(CW\*(C`Data::Dumper\*(C'\fR
.IP "\(bu" 2
Write the handlers for the attributes you decided.
Write the comparison using \f(CW\*(C`equal\*(C'\fR.
.PP
Tests using this methodology will not fail even if later code decorating 
the \s-1AST\s0 with new attributes is introduced.
.PP
See an example that checks an abstract syntax tree produced
by the simple compiler (see  \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR) 
for a really simple source:
.PP
.Vb 3
\&  Simple\-Types/script$ cat prueba27.c
\&  int f() {
\&  }
.Ve
.PP
The first thing is to obtain a description of the tree,
that can be done executing the compiler under the control of
the Perl debugger, stopping just after the 
tree has been built and dumping the tree
with Data::Dumper:
.PP
.Vb 11
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-wd usetypes.pl prueba27.c
\&  main::(usetypes.pl:5):  my $filename = shift || die "Usage:\en$0 file.c\en";
\&    DB<1> c 12
\&  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
\&    DB<2> use Data::Dumper
\&    DB<3> $Data::Dumper::Purity = 1
\&    DB<4> p Dumper($t)
\&  $VAR1 = bless( {
\&                   ..............................................
\&                 }, \*(AqPROGRAM\*(Aq );
\&  ...............................................................
.Ve
.PP
Once we have the shape of a correct tree we can write
our tests:
.PP
.Vb 10
\&  examples/Node$ cat \-n testequal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4  use Data::Dumper;
\&     5  use Data::Compare;
\&     6
\&     7  my $debugging = 0;
\&     8
\&     9  my $handler = sub {
\&    10    print Dumper($_[0], $_[1]) if $debugging;
\&    11    Compare($_[0], $_[1])
\&    12  };
\&    13
\&    14  my $t1 = bless( {
\&    15                   \*(Aqtypes\*(Aq => {
\&    16                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    17                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    18                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    19                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    20                                   \*(Aqchildren\*(Aq => [
\&    21                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    22                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    23                                 }, \*(AqF\*(Aq )
\&    24                              },
\&    25                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    26                   \*(Aqlines\*(Aq => 2,
\&    27                   \*(Aqchildren\*(Aq => [
\&    28                                   bless( {
\&    29                                            \*(Aqsymboltable\*(Aq => {},
\&    30                                            \*(Aqfatherblock\*(Aq => {},
\&    31                                            \*(Aqchildren\*(Aq => [],
\&    32                                            \*(Aqdepth\*(Aq => 1,
\&    33                                            \*(Aqparameters\*(Aq => [],
\&    34                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    35                                            \*(AqsymboltableLabel\*(Aq => {},
\&    36                                            \*(Aqline\*(Aq => 1
\&    37                                          }, \*(AqFUNCTION\*(Aq )
\&    38                                 ],
\&    39                   \*(Aqdepth\*(Aq => 0,
\&    40                   \*(Aqline\*(Aq => 1
\&    41                 }, \*(AqPROGRAM\*(Aq );
\&    42  $t1\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t1;
\&    43
\&    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    45  my $t2 = bless( {
\&    46                   \*(Aqtypes\*(Aq => {
\&    47                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    48                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    49                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    50                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    51                                   \*(Aqchildren\*(Aq => [
\&    52                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    53                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    54                                 }, \*(AqF\*(Aq )
\&    55                              },
\&    56                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    57                   \*(Aqchildren\*(Aq => [
\&    58                                   bless( {
\&    59                                            \*(Aqsymboltable\*(Aq => {},
\&    60                                            \*(Aqfatherblock\*(Aq => {},
\&    61                                            \*(Aqchildren\*(Aq => [],
\&    62                                            \*(Aqparameters\*(Aq => [],
\&    63                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    64                                          }, \*(AqFUNCTION\*(Aq )
\&    65                                 ],
\&    66                 }, \*(AqPROGRAM\*(Aq );
\&    67  $t2\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    68
\&    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    70  # and without the symboltable and types attributes used in the comparison
\&    71  my $t3 = bless( {
\&    72                   \*(Aqtypes\*(Aq => {
\&    73                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    74                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    75                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    76                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    77                                   \*(Aqchildren\*(Aq => [
\&    78                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    79                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    80                                 }, \*(AqF\*(Aq )
\&    81                              },
\&    82                   \*(Aqchildren\*(Aq => [
\&    83                                   bless( {
\&    84                                            \*(Aqsymboltable\*(Aq => {},
\&    85                                            \*(Aqfatherblock\*(Aq => {},
\&    86                                            \*(Aqchildren\*(Aq => [],
\&    87                                            \*(Aqparameters\*(Aq => [],
\&    88                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    89                                          }, \*(AqFUNCTION\*(Aq )
\&    90                                 ],
\&    91                 }, \*(AqPROGRAM\*(Aq );
\&    92
\&    93  $t3\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    94
\&    95  # Without attributes
\&    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
\&    97    print "\enNot considering attributes: Equal\en";
\&    98  }
\&    99  else {
\&   100    print "\enNot considering attributes: Not Equal\en";
\&   101  }
\&   102
\&   103  # Equality with attributes
\&   104  if (Parse::Eyapp::Node::equal(
\&   105        $t1, $t2,
\&   106        symboltable => $handler,
\&   107        types => $handler,
\&   108      )
\&   109     ) {
\&   110        print "\enConsidering attributes: Equal\en";
\&   111  }
\&   112  else {
\&   113    print "\enConsidering attributes: Not Equal\en";
\&   114  }
\&   115
\&   116  # Equality with attributes
\&   117  if (Parse::Eyapp::Node::equal(
\&   118        $t1, $t3,
\&   119        symboltable => $handler,
\&   120        types => $handler,
\&   121      )
\&   122     ) {
\&   123        print "\enConsidering attributes: Equal\en";
\&   124  }
\&   125  else {
\&   126    print "\enConsidering attributes: Not Equal\en";
\&   127  }
.Ve
.PP
The code defining tree \f(CW$t1\fR was obtained from an output using \f(CW\*(C`Data::Dumper\*(C'\fR.
The code for trees \f(CW$t2\fR and \f(CW$t3\fR was written using cut-and-paste from \f(CW$t1\fR.
They have the same shape than \f(CW$t1\fR but differ in their attributes. Tree \f(CW$t2\fR
shares with \f(CW$t1\fR the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR used in the comparison
and so \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`true\*(C'\fR when compared. Since \f(CW$t3\fR differs from \f(CW$t1\fR
in the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR the call to \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$node\->delete"
.el .SS "\f(CW$node\fP\->delete"
.IX Subsection "$node->delete"
The \f(CW\*(C`$node\->delete($child)\*(C'\fR method is used to delete the specified child of \f(CW$node\fR.
The child to delete can be specified using the index or a
reference. It returns the deleted child.
.PP
Throws an exception if the object can't do \f(CW\*(C`children\*(C'\fR or has no \f(CW\*(C`children\*(C'\fR.
See also the delete method of treeregexes 
(\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects)
to delete the node being visited.
.PP
The following example moves out of a loop an assignment statement
assuming is an invariant of the loop. To do it, it uses
the \f(CW\*(C`delete\*(C'\fR and \f(CW\*(C`insert_before\*(C'\fR methods:
.PP
.Vb 10
\&  nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&              sed \-ne \*(Aq98,113p\*(Aq moveinvariantoutofloopcomplexformula.pl
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&    FIRSTLINE => 99,
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
.Ve
.PP
The example below deletes \s-1CODE\s0 nodes
from the tree build for a translation scheme:
.PP
.Vb 5
\&  my $transform = Parse::Eyapp::Treeregexp\->new( 
\&    STRING=>q{
\&      delete_code: CODE => { Parse::Eyapp::Node::delete($CODE) }
\&    },
\&  )
.Ve
.PP
Observe how delete is called as a subroutine.
.ie n .SS "$node\->unshift($newchild)"
.el .SS "\f(CW$node\fP\->unshift($newchild)"
.IX Subsection "$node->unshift($newchild)"
Inserts \f(CW$newchild\fR at the beginning of the list of children of \f(CW$node\fR.
See also the unshift method 
for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->push($newchild)"
.el .SS "\f(CW$node\fP\->push($newchild)"
.IX Subsection "$node->push($newchild)"
Inserts \f(CW$newchild\fR at the end of the list of children of \f(CW$node\fR.
.ie n .SS "$node\->insert_before($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_before($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_before($position, $new_child)"
Inserts \f(CW$newchild\fR before \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index
and is not in range. Also if \f(CW$node\fR has no children.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not define
an actual child. In such case \f(CW$new_child\fR is not inserted.
.PP
See also the insert_before 
method for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->insert_after($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_after($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_after($position, $new_child)"
Inserts \f(CW$newchild\fR after \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index and is not
in the range of \f(CW\*(C`$node\-\*(C'\fRchildren>.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not exists
in the list of children. In such case \f(CW$new_child\fR is not inserted.
.ie n .SS "$node\->translation_scheme"
.el .SS "\f(CW$node\fP\->translation_scheme"
.IX Subsection "$node->translation_scheme"
Traverses \f(CW$node\fR. Each time a \s-1CODE\s0 node is visited the subroutine referenced
is called with arguments the node and its children. Usually the code will decorate
the nodes with new attributes or will update existing ones. Obviously this method
does nothing for an ordinary \s-1AST.\s0 It is used after compiling
an Eyapp program that makes use of the \f(CW%metatree\fR directive. (See
\&\f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example).
.ie n .SS "$node\->bud(@transformations)"
.el .SS "\f(CW$node\fP\->bud(@transformations)"
.IX Subsection "$node->bud(@transformations)"
Bottom-up decorator. The tree is traversed bottom-up. The set of
transformations in \f(CW@transformations\fR
is applied to each node in the tree referenced by \f(CW$node\fR
in the order
supplied by the user. \fIAs soon as one succeeds
no more transformations are applied\fR.
.PP
For an example  see the files \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
and \f(CW\*(C`lib/Simple/Trans.trg\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
shows an extract of the type-checking phase of a toy-example compiler:
.PP
.Vb 10
\&  examples/typechecking/Simple\-Types\-0.4/lib/Simple$  sed \-ne \*(Aq600,613p\*(Aq Types.eyp
\&   my @typecheck = (     # Check typing transformations for
\&     our $inum,          # \- Numerical constantss
\&     our $charconstant,  # \- Character constants
\&     our $bin,           # \- Binary Operations
\&     our $arrays,        # \- Arrays
\&     our $assign,        # \- Assignments
\&     our $control,       # \- Flow control sentences
\&     our $functioncall,  # \- Function calls
\&     our $statements,    # \- Those nodes with void type
\&                         #   (STATEMENTS, PROGRAM, etc.)
\&     our $returntype,    # \- Return
\&   );
\&
\&   $t\->bud(@typecheck);
.Ve
.PP
You can find another example of use of \f(CW\*(C`bud\*(C'\fR
in the file \f(CW\*(C`examples/ParsingStringsAndTrees/infix2pir.pl\*(C'\fR
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Parse.3pm                      0100644 0001750 0001750 00000531024 12566242263 024722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Parse 3"
.TH Parse::Eyapp::Parse 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Parse \- The parser of Eyapp grammars
.SH "THE EYAPP LANGUAGE"
.IX Header "THE EYAPP LANGUAGE"
The parser for the \f(CW\*(C`Eyapp\*(C'\fR language
was written and generated
using \f(CW\*(C`Parse::Eyapp\*(C'\fR and the \f(CW\*(C`eyapp\*(C'\fR compiler (actually
the first version 
was bootstrapped using the yapp compiler).
The Eyapp program parsing the \f(CW\*(C`Eyapp\*(C'\fR language
is in the file \f(CW\*(C`Parse/Eyapp/Parse.yp\*(C'\fR 
in the \f(CW\*(C`Parse::Eyapp\*(C'\fR distribution.
Therefore \f(CW\*(C`Parse::Eyapp::Parse\*(C'\fR 
objects have all the methods in \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR.
.PP
A \f(CW\*(C`Parse::Eyapp::Parse\*(C'\fR is nothing but a particular kind of \f(CW\*(C`Parse::Eyapp\*(C'\fR
parser: \fIthe one that parses\fR \f(CW\*(C`Eyapp\*(C'\fR \fIgrammars\fR.
.SS "Eyapp Grammar"
.IX Subsection "Eyapp Grammar"
This section describes the syntax of the Eyapp language using its own notation.
The grammar extends yacc and yapp grammars.  Semicolons have been omitted
to save space.  Between C\-like comments you can find an (informal) explanation
of the language associated with each token.
.PP
.Vb 10
\&  %token ASSOC /* is %(left|right|nonassoc) */                                                                                                          
\&  %token BEGINCODE /* is %begin { Perl code ... } */                                                                                                    
\&  %token CODE /* is { Perl code ... } */                                                                                                                
\&  %token CONFLICT /* is %conflict */                                                                                                                    
\&  %token DEFAULTACTION /* is %defaultaction */                                                                                                          
\&  %token EXPECT /* is %expect */                                                                                                                        
\&  %token HEADCODE /* is %{ Perl code ... %} */                                                                                                          
\&  %token IDENT /* is [A\-Za\-z_][A\-Za\-z0\-9_]* */                                                                                                          
\&  %token LABEL /* is :[A\-Za\-z0\-9_]+ */                                                                                                                  
\&  %token LITERAL /* is a string literal like \*(Aqhello\*(Aq */                                                                                                 
\&  %token METATREE /* is %metatree */                                                                                                                    
\&  %token NAME /* is %name */                                                                                                                            
\&  %token NAMINGSCHEME /* is %namingscheme */                                                                                                            
\&  %token NOCOMPACT /* is %nocompact */                                                                                                                  
\&  %token NUMBER /* is \ed+ */                                                                                                                            
\&  %token OPTION /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e? */                                                                                                 
\&  %token PLUS /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+ */                                                                                                   
\&  %token PREC /* is %prec */                                                                                                                            
\&  %token PREFIX /* is %prefix\es+([A\-Za\-z_][A\-Za\-z0\-9_:]*::) */                                                                                          
\&  %token SEMANTIC /* is %semantic\es+token */                                                                                                            
\&  %token STAR /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e* */                                                                                                   
\&  %token START /* is %start */                                                                                                                          
\&  %token STRICT /* is %strict */                                                                                                                        
\&  %token SYNTACTIC /* is %syntactic\es+token */                                                                                                          
\&  %token TAILCODE /* is { Perl code ... } */                                                                                                            
\&  %token TOKEN /* is %token */                                                                                                                          
\&  %token TREE /* is %tree */                                                                                                                            
\&  %token TYPE /* is %type */                                                                                                                            
\&  %token UNION /* is %union */                                                                                                                          
\&  %start eyapp                                                                                                                                          
\&
\&  %%
\&
\&  # Main rule
\&  eyapp:     
\&        head body tail 
\&  ;                    
\&  #Common rules:       
\&  symbol:              
\&        LITERAL        
\&      | ident #default action
\&  ;                          
\&  ident:                     
\&        IDENT                
\&  ;                          
\&  # Head section:            
\&  head:                      
\&        headsec \*(Aq%%\*(Aq         
\&  ;                          
\&  headsec:                   
\&        #empty  #default action
\&      | decls #default action  
\&  ;                            
\&  decls:                       
\&        decls decl #default action
\&      | decl #default action      
\&  ;                               
\&  decl:                           
\&        \*(Aq\en\*(Aq #default action      
\&      | SEMANTIC typedecl symlist \*(Aq\en\*(Aq
\&      | SYNTACTIC typedecl symlist \*(Aq\en\*(Aq
\&      | TOKEN typedecl toklist \*(Aq\en\*(Aq    
\&      | ASSOC typedecl symlist \*(Aq\en\*(Aq    
\&      | START ident \*(Aq\en\*(Aq               
\&      | PREFIX \*(Aq\en\*(Aq                    
\&      | WHITES CODE \*(Aq\en\*(Aq               
\&      | WHITES REGEXP \*(Aq\en\*(Aq             
\&      | WHITES \*(Aq=\*(Aq CODE \*(Aq\en\*(Aq           
\&      | WHITES \*(Aq=\*(Aq REGEXP \*(Aq\en\*(Aq         
\&      | NAMINGSCHEME CODE \*(Aq\en\*(Aq         
\&      | HEADCODE \*(Aq\en\*(Aq                  
\&      | UNION CODE \*(Aq\en\*(Aq  #ignore       
\&      | DEFAULTACTION CODE \*(Aq\en\*(Aq        
\&      | LEXER CODE \*(Aq\en\*(Aq                
\&      | TREE \*(Aq\en\*(Aq                      
\&      | METATREE \*(Aq\en\*(Aq                  
\&      | STRICT \*(Aq\en\*(Aq                    
\&      | NOCOMPACT \*(Aq\en\*(Aq                 
\&      | TYPE typedecl identlist \*(Aq\en\*(Aq   
\&      | CONFLICT ident CODE \*(Aq\en\*(Aq       
\&      | EXPECT NUMBER \*(Aq\en\*(Aq             
\&      | EXPECT NUMBER NUMBER \*(Aq\en\*(Aq      
\&      | EXPECTRR NUMBER \*(Aq\en\*(Aq           
\&      | error \*(Aq\en\*(Aq                     
\&  ;                                    
\&  typedecl:                            
\&        #empty                         
\&      | \*(Aq<\*(Aq IDENT \*(Aq>\*(Aq                  
\&  ;                                    
\&  symlist:                             
\&        symlist symbol                 
\&      | symbol                         
\&  ;                                    
\&  toklist:                             
\&        toklist tokendef               
\&      | tokendef                       
\&  ;                                    
\&  tokendef:                            
\&        symbol \*(Aq=\*(Aq REGEXP              
\&      | symbol \*(Aq=\*(Aq CODE                
\&      | symbol                         
\&  ;                                    
\&  identlist:                           
\&        identlist ident                
\&      | ident                          
\&  ;                                    
\&  # Rule section                       
\&  body:                                
\&        rulesec \*(Aq%%\*(Aq                   
\&      | \*(Aq%%\*(Aq                           
\&  ;                                    
\&  rulesec:                             
\&        rulesec rules #default action  
\&      | startrules #default action     
\&  ;                                    
\&  startrules:                          
\&        IDENT \*(Aq:\*(Aq  rhss \*(Aq;\*(Aq            
\&      | error \*(Aq;\*(Aq                      
\&  ;                                    
\&  rules:                               
\&        IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq             
\&      | error \*(Aq;\*(Aq                      
\&  ;                                    
\&  rhss:                                
\&        rhss \*(Aq|\*(Aq rule                  
\&      | rule                           
\&  ;                                    
\&  rule:                                
\&        optname rhs prec epscode       
\&      | optname rhs                    
\&  ;                                    
\&  rhs:                                 
\&        #empty      #default action (will return undef)
\&      | rhselts #default action                        
\&  ;                                                    
\&  rhselts:                                             
\&        rhselts rhseltwithid                           
\&      | rhseltwithid                                   
\&  ;                                                    
\&  rhseltwithid:                                        
\&        rhselt \*(Aq.\*(Aq IDENT
\&      | \*(Aq$\*(Aq rhselt
\&      | \*(Aq$\*(Aq error
\&      | rhselt
\&  ;
\&  rhselt:
\&        symbol
\&      | code
\&      | DPREC ident
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq
\&      | rhselt STAR
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq
\&      | rhselt OPTION
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS
\&  ;
\&  optname:
\&        /* empty */
\&      | NAME IDENT
\&      | NAME IDENT LABEL
\&      | NAME LABEL
\&  ;
\&  prec:
\&        PREC symbol
\&  ;
\&  epscode:
\&      | code
\&  ;
\&  code:
\&        CODE
\&      | BEGINCODE
\&  ;
\&  # Tail section:
\&  tail:
\&        /*empty*/
\&      | TAILCODE
\&  ;
\&
\&  %%
.Ve
.PP
The semantic of \f(CW\*(C`Eyapp\*(C'\fR agrees with the semantic of \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`yapp\*(C'\fR for
all the common constructions.
.SS "Comments"
.IX Subsection "Comments"
Comments are either Perl style, from \f(CW\*(C`#\*(C'\fR
up to the end of line, or C style, enclosed between  \f(CW\*(C`/*\*(C'\fR and \f(CW\*(C`*/\*(C'\fR.
.SS "Syntactic Variables, Symbolic Tokens and String Literals"
.IX Subsection "Syntactic Variables, Symbolic Tokens and String Literals"
Two kind of symbols may appear inside a Parse::Eyapp program:
\&\fINon-terminal\fR symbols or \fIsyntactic variables\fR, 
called also \fIleft-hand-side\fR symbols
and \fITerminal\fR symbols, called
also \fITokens\fR.
.PP
Tokens are the symbols the lexical analyzer function returns to the parser.
There are two kinds of tokens: \fIsymbolic tokens\fR and \fIstring
literals\fR.
.PP
\&\fISyntactic variables\fR and \fIsymbolic tokens\fR identifiers must conform
to the regular expression \f(CW\*(C`[A\-Za\-z][A\-Za\-z0\-9_]*\*(C'\fR.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIsymbolic tokens\fR will be considered \fIsemantic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R"). \fISymbolic tokens\fR yield nodes
in the Abstract Syntax Tree.
.PP
String literals are enclosed in single quotes and can contain almost
anything. They will be received by the parser as double-quoted strings. 
Any special character as \f(CW\*(Aq"\*(Aq\fR, \f(CW\*(Aq$\*(Aq\fR and \f(CW\*(Aq@\*(Aq\fR is escaped.
To have a single quote inside a literal, escape it with '\e'.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIstring literals\fR will be considered \fIsyntactic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R"). \fISyntactic tokens\fR do not produce
nodes in the Abstract Syntax Tree.
.PP
The examples used along this document can be found in the directory 
\&\f(CW\*(C`examples/eyapplanguageref\*(C'\fR accompanying this distribution.
.ie n .SS "Parts of an ""eyapp"" Program"
.el .SS "Parts of an \f(CWeyapp\fP Program"
.IX Subsection "Parts of an eyapp Program"
An Eyapp program has three parts called head, body and tail:
.PP
.Vb 1
\&                                 eyapp: head body tail ;
.Ve
.PP
Each part is separated from the former by the symbol \f(CW\*(C`%%\*(C'\fR:
.PP
.Vb 2
\&                                 head: headsec \*(Aq%%\*(Aq
\&                                 body: rulesec \*(Aq%%\*(Aq
.Ve
.SH "THE HEAD SECTION"
.IX Header "THE HEAD SECTION"
The head section contains a list of declarations
.PP
.Vb 1
\&                                 headsec:  decl *
.Ve
.PP
There are different kinds of declarations.
.PP
This reference does not 
fully describes all the declarations that are shared with \f(CW\*(C`yacc\*(C'\fR and 
yapp.
.SS "Example of Head Section"
.IX Subsection "Example of Head Section"
In this and the next sections we will describe the basics
of the Eyapp language using the file \f(CW\*(C`examples/eyapplanguageref/Calc.eyp\*(C'\fR 
that accompanies this distribution. This file implements a trivial 
calculator. Here is the header section:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,/%%/p\*(Aq Calc.eyp | cat \-n
\&     1  # examples/eyapplanguageref/Calc.eyp
\&     2  %whites    =  /([ \et]*(?:#.*)?)/
\&     3  %token NUM =  /([0\-9]+(?:\e.[0\-9]+)?)/
\&     4  %token VAR =  /([A\-Za\-z][A\-Za\-z0\-9_]*)/
\&     5
\&     6  %right  \*(Aq=\*(Aq
\&     7  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     8  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     9  %left   NEG
\&    10  %right  \*(Aq^\*(Aq
\&    11
\&    12  %{
\&    13  my %s; # symbol table
\&    14  %}
\&    15
\&    16  %%
.Ve
.PP
Eyapp produces a lexical generator from the descriptions given
by the \f(CW%token\fR and \f(CW%whites\fR directives plus the tokens used 
inside the body section.
.PP
.Vb 3
\&       %whites    =  /([ \et]*(?:#.*)?)/
\&       %token NUM =  /([0\-9]+(?:\e.[0\-9]+)?)/
\&       %token VAR =  /([A\-Za\-z][A\-Za\-z0\-9_]*)/
.Ve
.PP
See section \*(L"Automatic Generation of Lexical Analyzers\*(R" for more details.
.SS "Declarations and Precedence"
.IX Subsection "Declarations and Precedence"
Lines 2\-5 declare several tokens. The usual way to declare
tokens is through the \f(CW%token\fR directive. The declarations 
\&\f(CW%nonassoc\fR, \f(CW%left\fR and \f(CW%right\fR 
not only declare the tokens but also associate a \fIpriority\fR with them.  
Tokens declared in the same line have the same precedence. 
Tokens declared with these directives in lines below have more
precedence than those declared above. Thus, in the example
above
we are saying that \f(CW"+"\fR and \f(CW"\-"\fR have the same precedence
but higher precedence than =. The final effect of \f(CW"\-"\fR
having greater precedence than = will be that an
expression like:
.PP
.Vb 1
\&                        a = 4 \- 5
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                        a = (4 \- 5)
.Ve
.PP
and not as
.PP
.Vb 1
\&                        (a = 4) \- 5
.Ve
.PP
The use of the \f(CW%left\fR indicates that \- in case of ambiguity 
and a match between precedences \- the parser must build the tree corresponding
to a left parenthesizing. Thus, the expression
.PP
.Vb 1
\&                         4 \- 5 \- 9
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                         (4 \- 5) \- 9
.Ve
.PP
You can refer to the token end-of-input in the header section using the string \f(CW\*(Aq\*(Aq\fR (for example
to give it some priority, see the example in \f(CW\*(C`examples/debuggingtut/typicalrrwithprec.eyp\*(C'\fR).
.SS "Header Code"
.IX Subsection "Header Code"
Perl code surrounded by \f(CW\*(C`%{\*(C'\fR and \f(CW\*(C`%}\*(C'\fR
can be inserted in the head section. Such code will be inserted in the module
generated by \f(CW\*(C`eyapp\*(C'\fR near the beginning. Therefore, declarations like the
one of the calculator symbol table \f(CW%s\fR
.PP
.Vb 3
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
.Ve
.PP
will be visible from almost any point in the file.
.SS "The Start Symbol of the Grammar"
.IX Subsection "The Start Symbol of the Grammar"
\&\f(CW\*(C`%start program\*(C'\fR declares \f(CW\*(C`program\*(C'\fR as the start symbol of 
the grammar. When \f(CW%start\fR is not
used, the first rule in the body section will be used.
.SS "Expect"
.IX Subsection "Expect"
The \f(CW\*(C`%expect #NUMBER\*(C'\fR directive works as in \f(CW\*(C`bison\*(C'\fR 
and  suppress warnings when the number of Shift/Reduce
conflicts is exactly \f(CW\*(C`#NUMBER\*(C'\fR.
.PP
The directive has been extended to be called with two numbers:
.PP
.Vb 1
\&  %expect NUMSHIFTRED NUMREDRED
.Ve
.PP
no warnings will be emitted if the number of shift-reduce 
conflicts is exactly \f(CW\*(C`NUMSHIFTRED\*(C'\fR and the number of reduce-reduce
conflicts is \f(CW\*(C`NUMREDRED\*(C'\fR.
.SS "Type and Union"
.IX Subsection "Type and Union"
C oriented declarations like \f(CW%type\fR and \f(CW%union\fR are
parsed but ignored.
.ie n .SS "The %strict Directive"
.el .SS "The \f(CW%strict\fP Directive"
.IX Subsection "The %strict Directive"
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ls \-ltr | tail \-1
\&  \-rw\-r\-\-r\-\- 1 pl users 2395 2008\-10\-02 09:41 bugyapp3.pm
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.ie n .SS "The %prefix Directive"
.el .SS "The \f(CW%prefix\fP Directive"
.IX Subsection "The %prefix Directive"
The \f(CW%prefix\fR directive 
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix
.PP
.Vb 1
\&  %prefix Some::Prefix::
.Ve
.PP
See the example in \f(CW\*(C`examples/eyapplanguageref/alias_and_yyprefix.pl\*(C'\fR.
See also section \*(L"Grammar Reuse\*(R" in Parse::Eyapp::defaultactionsintro
for an example that does not involve the \f(CW%tree\fR directive.
.SS "Default Action Directive"
.IX Subsection "Default Action Directive"
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify the default action 
using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. See section \*(L"\s-1DEFAULT ACTIONS\*(R"\s0.
The examples \f(CW\*(C`examples/eyapplanguageref/Postfix.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/eyapplanguageref/Lhs.eyp\*(C'\fR illustrate the use of the directive.
.SS "Tree Construction Directives"
.IX Subsection "Tree Construction Directives"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
and \f(CW%metatree\fR directives. See sections
\&\*(L"\s-1ABSTRACT SYNTAX TREES:\s0 \f(CW%tree\fR \s-1AND\s0 \f(CW%name\fR\*(R"
and
Parse::Eyapp::translationschemestut.
.SS "Tokens and the Abstract Syntax Tree"
.IX Subsection "Tokens and the Abstract Syntax Tree"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the way \f(CW\*(C`eyapp\*(C'\fR builds the abstract syntax tree.
See section \*(L"Syntactic and Semantic tokens\*(R".
.ie n .SS "The %nocompact directive"
.el .SS "The \f(CW%nocompact\fP directive"
.IX Subsection "The %nocompact directive"
This directive influences the generation of the \s-1LALR\s0 tables.
They will not be compacted and the tokens
for the \f(CW\*(C`DEFAULT\*(C'\fR reduction will be explicitly set.
It can be used to produce an \f(CW\*(C`.output\*(C'\fR file (option \f(CW\*(C`\-v\*(C'\fR)
with more information.
.SH "THE BODY"
.IX Header "THE BODY"
The body section contains the rules describing the grammar:
.PP
.Vb 3
\&                       body:   rules * \*(Aq%%\*(Aq
\&                       rules:  IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&                       rhss:   (optname rhs (prec epscode)?) <+ \*(Aq|\*(Aq>
.Ve
.SS "Rules"
.IX Subsection "Rules"
A rule is made of a left-hand-side symbol (the \fIsyntactic variable\fR), 
followed by a \f(CW\*(Aq:\*(Aq\fR and one
or more \fIright-hand-sides\fR (or \fIproductions\fR)
 separated by \f(CW\*(Aq|\*(Aq\fR and terminated by a \f(CW\*(Aq;\*(Aq\fR
like in:
.PP
.Vb 5
\&                          exp: 
\&                               exp \*(Aq+\*(Aq exp
\&                            |  exp \*(Aq\-\*(Aq exp
\&                            |  NUM
\&                          ;
.Ve
.PP
A \fIproduction\fR (\fIright hand side\fR) may be empty:
.PP
.Vb 4
\&                          input:   
\&                               /* empty */
\&                            |  input line
\&                          ;
.Ve
.PP
The former two productions can be abbreviated as
.PP
.Vb 3
\&                          input: 
\&                               line *
\&                          ;
.Ve
.PP
The operators \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`?\*(C'\fR are presented in section
\&\*(L"\s-1LISTS AND OPTIONALS\*(R"\s0.
.PP
A \fIsyntactic variable cannot appear more than once as
a rule name\fR (This differs from \f(CW\*(C`yacc\*(C'\fR).  So you can't 
write
.PP
.Vb 2
\&    thing: foo bar ;
\&    thing: foo baz ;
.Ve
.PP
instead, write:
.PP
.Vb 4
\&    thing: 
\&           foo bar 
\&         | foo baz 
\&    ;
.Ve
.SS "Semantic Values and Semantic Actions"
.IX Subsection "Semantic Values and Semantic Actions"
In \f(CW\*(C`Parse::Eyapp\*(C'\fR 
a production rule
.PP
.Vb 1
\&                          A \-> X_1 X_2 ... X_n
.Ve
.PP
can be followed by a 
\&\fIsemantic action\fR:
.PP
.Vb 1
\&                    A \-> X_1 X_2 ... X_n { Perl Code }
.Ve
.PP
Such
semantic action is nothing but Perl code that will be treated 
as an anonymous subroutine.  The semantic action associated 
with production rule \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR  is executed
after any actions associated with the subtrees of \f(CW\*(C`X_1\*(C'\fR,
\&\f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR.
\&\f(CW\*(C`Eyapp\*(C'\fR parsers build the syntax tree using a left-right
bottom-up traverse of the syntax tree. Each times
the Parser visits the node associated with the 
production \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR
the associated semantic action is called. 
Associated with each symbol
of a Parse::Eyapp grammar there is a scalar \fISemantic Value\fR
or \fIAttribute\fR. The semantic values of terminals are provided
by the lexical analyzer. In the calculator example
(see file \f(CW\*(C`examples/eyapplanguageref/Calc.yp\*(C'\fR in the distribution),
the semantic value associated with an expression
is its numeric value. Thus in the rule:
.PP
.Vb 1
\&                       exp \*(Aq+\*(Aq exp { $_[1] + $_[3] }
.Ve
.PP
\&\f(CW$_[1]\fR refers to the attribute of the first \f(CW\*(C`exp\*(C'\fR, \f(CW$_[2]\fR 
is the attribute associated with \f(CW\*(Aq+\*(Aq\fR, which is the second component of the 
pair provided by the lexical analyzer and \f(CW$_[3]\fR refers to the attribute of 
the second \f(CW\*(C`exp\*(C'\fR.
.PP
When the semantic action/anonymous subroutine is called,
the arguments are as follows:
.IP "\(bu" 4
\&\f(CW$_[1]\fR to \f(CW$_[n]\fR are the attributes of
the symbols \f(CW\*(C`X_1\*(C'\fR, \f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR. 
Just as \f(CW$1\fR to \f(CW$n\fR in \f(CW\*(C`yacc\*(C'\fR,
.IP "\(bu" 4
\&\f(CW$_[0]\fR is the parser object itself.
Having \f(CW$_[0]\fR being the parser object itself allows you to call
parser methods. Most \f(CW\*(C`yacc\*(C'\fR macros have been converted into
parser methods. See section \*(L"\s-1METHODS AVAILABLE IN THE GENERATED CLASS\*(R"\s0 in Parse::Eyapp.
.PP
The returned value will be the attribute associated 
with the left hand side of the production.
.PP
Names can be given to the attributes using the dot notation
(see file \f(CW\*(C`examples/eyapplanguageref/CalcSimple.eyp\*(C'\fR):
.PP
.Vb 1
\&                     exp.left \*(Aq+\*(Aq exp.right { $left + $right }
.Ve
.PP
See section \*(L"\s-1NAMES FOR ATTRIBUTES\*(R"\s0 for more details about the \fIdot\fR and \fIdollar\fR 
notations.
.PP
If no action is specified and no \f(CW%defaultaction\fR is specified
the default action
.PP
.Vb 1
\&                               { $_[1] }
.Ve
.PP
will be executed instead. See section \*(L"\s-1DEFAULT ACTIONS\*(R"\s0 to know more.
.SS "Actions in Mid-Rule"
.IX Subsection "Actions in Mid-Rule"
Actions can be inserted in the middle of a production like in:
.PP
.Vb 1
\& block: \*(Aq{\*(Aq.bracket { $ids\->begin_scope(); } declaration*.decs statement*.sts \*(Aq}\*(Aq { ... }
.Ve
.PP
A middle production action is managed by inserting a new rule in the grammar and associating
the semantic action with it:
.PP
.Vb 1
\&                     Temp: /* empty */ { $ids\->begin_scope(); }
.Ve
.PP
Middle production actions can refer to the attributes on its left. They count
as one of the components of the production. Thus the program:
.PP
.Vb 5
\&  ~/LEyapp/examples/eyapplanguageref$ cat intermediateaction2.yp 
\&  %%
\&  S:  \*(Aqa\*(Aq { $_[1]x4 }.mid \*(Aqa\*(Aq { print "\en<<$_[2], $mid, $_[3]>>\en"; }
\&  ;
\&  %%
.Ve
.PP
The auxiliar syntactic variables are named \f(CW\*(C`@#position\-#order\*(C'\fR where \f(CW\*(C`#position\*(C'\fR
is the position of the action in the rhs and \f(CW\*(C`order\*(C'\fR is an ordinal number. See
the \f(CW\*(C`.output\*(C'\fR file for the former example:
.PP
.Vb 7
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-v intermediateaction2.yp
\&  ~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,5p\*(Aq intermediateaction2.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:  $start \-> S $end
\&  1:  S \-> \*(Aqa\*(Aq @1\-1 \*(Aqa\*(Aq
\&  2:  @1\-1 \-> /* empty */
.Ve
.PP
We can build an executable \f(CW\*(C`ia.pl\*(C'\fR from the former grammar using \f(CW\*(C`eyapp\*(C'\fR option \f(CW\*(C`\-C\*(C'\fR:
.PP
.Vb 1
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-C \-o ia.pl intermediateaction2.yp
.Ve
.PP
The \f(CW\*(C`main\*(C'\fR, error and lexer methods are provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR.
When given input \f(CW\*(C`aa\*(C'\fR the execution will produce as output \f(CW\*(C`aaaa, aaaa, a\*(C'\fR. The option
\&\f(CW\*(C`\-d\*(C'\fR activates the debug mode, the option \f(CW\*(C`\-c\*(C'\fR tells the program to get the input from the command line::
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ ./ia.pl \-d \-c \*(Aqaa\*(Aq
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:
\&  Stack: 0
\&  Need token. Got >a<
\&  Shift and go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack: 0\->\*(Aqa\*(Aq\->2
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (@1\-1 \-\-> /* empty */): Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack: 0\->\*(Aqa\*(Aq\->2\->\*(Aq@1\-1\*(Aq\->4
\&  Need token. Got >a<
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack: 0\->\*(Aqa\*(Aq\->2\->\*(Aq@1\-1\*(Aq\->4\->\*(Aqa\*(Aq\->5
\&  Don\*(Aqt need token.
\&  Reduce using rule 1 (S \-\-> a @1\-1 a): 
\&  <<aaaa, aaaa, a>>
\&  Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack: 0\->\*(AqS\*(Aq\->1
\&  Need token. Got ><
\&  Shift and go to state 3.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 3:
\&  Stack: 0\->\*(AqS\*(Aq\->1\->\*(Aq\*(Aq\->3
\&  Don\*(Aqt need token.
\&  Accept.
.Ve
.SS "Example of Body Section"
.IX Subsection "Example of Body Section"
Following with the calculator example, the body is:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq17,/%%/p\*(Aq Calc.eyp | cat \-n 
\&     1  start:                                                                              
\&     2      input { \e%s }                                                                   
\&     3  ;
\&     4
\&     5  input: line *
\&     6  ;
\&     7
\&     8  line:
\&     9      \*(Aq\en\*(Aq       { undef }
\&    10    | exp \*(Aq\en\*(Aq   {
\&    11                    print "$_[1]\en" if defined($_[1]);
\&    12                    $_[1]
\&    13                 }
\&    14    | error  \*(Aq\en\*(Aq
\&    15        {
\&    16          $_[0]\->YYErrok;
\&    17          undef
\&    18        }
\&    19  ;
\&    20
\&    21  exp:
\&    22      NUM
\&    23    | $VAR                   { $s{$VAR} }
\&    24    | $VAR \*(Aq=\*(Aq $exp          { $s{$VAR} = $exp }
\&    25    | exp.left \*(Aq+\*(Aq exp.right { $left + $right }
\&    26    | exp.left \*(Aq\-\*(Aq exp.right { $left \- $right }
\&    27    | exp.left \*(Aq*\*(Aq exp.right { $left * $right }
\&    28    | exp.left \*(Aq/\*(Aq exp.right
\&    29      {
\&    30         $_[3] and return($_[1] / $_[3]);
\&    31         $_[0]\->YYData\->{ERRMSG} = "Illegal division by zero.\en";
\&    32         $_[0]\->YYError;
\&    33         undef
\&    34      }
\&    35    | \*(Aq\-\*(Aq $exp %prec NEG     { \-$exp }
\&    36    | exp.left \*(Aq^\*(Aq exp.right { $left ** $right }
\&    37    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq           { $exp }
\&    38  ;
\&    39
\&    40  %%
.Ve
.PP
This body does not uses any of the Eyapp extensions (with the exception of the 
\&\f(CW\*(C`*\*(C'\fR operator at line 5) and the dot and dollar notations.
.SS "Solving Ambiguities and Conflicts"
.IX Subsection "Solving Ambiguities and Conflicts"
When Eyapp analyzes a grammar like:
.PP
.Vb 7
\&  examples/eyapplanguageref$ cat \-n ambiguities.eyp
\&     1  %%
\&     2  exp:
\&     3      NUM
\&     4    | exp \*(Aq\-\*(Aq exp
\&     5  ;
\&     6  %%
.Ve
.PP
it will produce a warning announcing the existence of 
\&\fIshift-reduce\fR conflicts:
.PP
.Vb 5
\&  examples/eyapplanguageref$ eyapp ambiguities.eyp
\&  1 shift/reduce conflict (see .output file)
\&  State 5: reduce by rule 2: exp \-> exp \*(Aq\-\*(Aq exp (default action)
\&  State 5: shifts:
\&    to state    3 with \*(Aq\-\*(Aq
.Ve
.PP
when \f(CW\*(C`eyapp\*(C'\fR finds warnings automatically produces a \f(CW\*(C`.output\*(C'\fR file
describing the conflict.
.PP
What the warning is saying is that an expression like \f(CW\*(C`exp \*(Aq\-\*(Aq exp\*(C'\fR (rule 2) followed by a
minus \f(CW\*(Aq\-\*(Aq\fR can be parsed in more than one way. If we
have an input like \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR the activity of a \s-1\fILALR\s0\fR\|(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of \fIshift and reduce actions\fR. A \fIshift action\fR
has as consequence the reading of the next token. A \fIreduce action\fR
is finding a production rule that matches and substituting 
the rhs of the production by the lhs.  For input \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR
the activity will be as follows (the dot is used to indicate where the next 
input token is):
.PP
.Vb 6
\&                           .NUM \- NUM \- NUM # shift
\&                            NUM.\- NUM \- NUM # reduce exp: NUM 
\&                            exp.\- NUM \- NUM # shift
\&                            exp \-.NUM \- NUM # shift
\&                            exp \- NUM.\- NUM # reduce exp: NUM
\&                            exp \- exp.\- NUM # shift/reduce conflict
.Ve
.PP
up this point two different decisions can be taken: the next description can be
.PP
.Vb 1
\&                                  exp.\- NUM # reduce by exp: exp \*(Aq\-\*(Aq exp (rule 2)
.Ve
.PP
or:
.PP
.Vb 1
\&                            exp \- exp \-.NUM # shift \*(Aq\-\*(Aq (to state 3)
.Ve
.PP
that is why it is called a \fIshift-reduce conflict\fR.
.PP
That is also the reason for the precedence declarations in the 
head section. Another kind of conflicts are \fIreduce-reduce conflicts\fR.
They arise when more that rhs can be applied for a reduction
action.
.PP
Eyapp solves the conflicts applying the following rules:
.IP "\(bu" 4
In a shift/reduce conflict, the default is the shift.
.IP "\(bu" 4
In a reduce/reduce conflict, the default is to reduce by the
earlier grammar production (in the input sequence).
.IP "\(bu" 4
Precedences and associativities can be given to tokens in
the declarations section. This is made by a sequence of lines beginning
with one of the directives: \f(CW%left\fR, \f(CW%right\fR, or \f(CW%nonassoc\fR, 
followed by a list of
tokens. All the tokens on the same line
have the same precedence and associativity; 
the lines are listed in order of increasing precedence.
.IP "\(bu" 4
A precedence and associativity is associated with each grammar
production; it is the precedence and associativity of the \fIlast token\fR 
or \fIliteral\fR in the right hand side of the production.
.IP "\(bu" 4
The \f(CW%prec\fR directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional \f(CW\*(C`%prec token\*(C'\fR directive
giving the production the precedence of the \f(CW\*(C`token\*(C'\fR
.Sp
.Vb 1
\&                          exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
.Ve
.IP "\(bu" 4
If there is a shift/reduce conflict, and both the grammar production
and the input token have precedence and associativity associated
with them, then the conflict is solved in favor of the action (shift or
reduce) associated with the higher precedence. If the precedences are the
same, then the associativity is used; left associative implies reduce,
right associative implies shift, and non associative implies error.
The last is used to describe operators, like the operator \f(CW\*(C`.LT.\*(C'\fR in \s-1FORTRAN, \s0
that may not associate with themselves. That is, because
.Sp
.Vb 1
\&                             A .LT. B .LT. C
.Ve
.Sp
is invalid in \s-1FORTRAN, \s0\f(CW\*(C`.LT.\*(C'\fR would be described with the keyword \f(CW%nonassoc\fR in eyapp.
.PP
To solve a shift-reduce conflict between a production \f(CW\*(C`A \-\-> SOMETHING\*(C'\fR
and a token \f(CW\*(Aqa\*(Aq\fR you can follow this procedure:
.ie n .IP "1. Edit the "".output"" file" 4
.el .IP "1. Edit the \f(CW.output\fR file" 4
.IX Item "1. Edit the .output file"
.PD 0
.IP "2. Search for the state where the conflict between the production and the token is. In our example it looks like:" 4
.IX Item "2. Search for the state where the conflict between the production and the token is. In our example it looks like:"
.PD
.Vb 2
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq56,65p\*(Aq ambiguities.output
\& State 5:
\&
\&        exp \-> exp . \*(Aq\-\*(Aq exp    (Rule 2)
\&        exp \-> exp \*(Aq\-\*(Aq exp .    (Rule 2)
\&
\&        \*(Aq\-\*(Aq     shift, and go to state 3
\&
\&        \*(Aq\-\*(Aq     [reduce using rule 2 (exp)]
\&        $default        reduce using rule 2 (exp)
.Ve
.ie n .IP "3. Inside the state there has to be a production of the type ""A \-\-> SOMETHING."" (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form ""A \-\-> prefix . suffix"", where suffix can \fIstart\fR with the involved token \*(Aqa\*(Aq." 4
.el .IP "3. Inside the state there has to be a production of the type \f(CWA \-\-> SOMETHING.\fR (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form \f(CWA \-\-> prefix . suffix\fR, where suffix can \fIstart\fR with the involved token \f(CW\*(Aqa\*(Aq\fR." 4
.IX Item "3. Inside the state there has to be a production of the type A --> SOMETHING. (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form A --> prefix . suffix, where suffix can start with the involved token a."
.PD 0
.ie n .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want ""NUM \- NUM \- NUM"" to produce a tree like ""MINUS(MINUS(NUM, NUM), NUM)"" and not ""MINUS(NUM, MINUS(NUM, NUM))"". We want the conflict in ""exp \- exp.\- NUM"" to be solved in favor of the reduction by ""exp: exp \*(Aq\-\*(Aq exp"". This is achieved by declaring ""%left \*(Aq\-\*(Aq""." 4
.el .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want \f(CWNUM \- NUM \- NUM\fR to produce a tree like \f(CWMINUS(MINUS(NUM, NUM), NUM)\fR and not \f(CWMINUS(NUM, MINUS(NUM, NUM))\fR. We want the conflict in \f(CWexp \- exp.\- NUM\fR to be solved in favor of the reduction by \f(CWexp: exp \*(Aq\-\*(Aq exp\fR. This is achieved by declaring \f(CW%left \*(Aq\-\*(Aq\fR." 4
.IX Item "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want NUM - NUM - NUM to produce a tree like MINUS(MINUS(NUM, NUM), NUM) and not MINUS(NUM, MINUS(NUM, NUM)). We want the conflict in exp - exp.- NUM to be solved in favor of the reduction by exp: exp - exp. This is achieved by declaring %left -."
.PD
.SS "Error Recovery"
.IX Subsection "Error Recovery"
The token name \f(CW\*(C`error\*(C'\fR is reserved for error handling. This name can
be used in grammar productions; it suggests places where errors are
expected, and recovery can take place:
.PP
.Vb 8
\&     line:
\&       \*(Aq\en\*(Aq         { undef }
\&       | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\&       | error  \*(Aq\en\*(Aq
\&           {
\&             $_[0]\->YYErrok;
\&             undef
\&           }
.Ve
.PP
The parser pops its stack until
it enters a state where the token \f(CW\*(C`error\*(C'\fR is legal. It then shifts
the token \f(CW\*(C`error\*(C'\fR and proceeds to discard tokens until finding 
one that is acceptable. In the example
all the tokens until finding a \f(CW\*(Aq\en\*(Aq\fR will be skipped. 
If no special error productions have been specified,
the processing will halt.
.PP
In order to prevent a cascade of error messages, the parser, after
detecting an error, remains in error state until three tokens have been
successfully read and shifted. If an error is detected when the parser
is already in error state, no message is given, and the input token is
quietly deleted. The method \f(CW\*(C`YYErrok\*(C'\fR used in the example 
communicates to the parser
that a satisfactory recovery has been reached 
and that it can safely emit new error
messages.
.PP
You cannot have a literal \fI'error'\fR in your grammar as it would
confuse the driver with the \fIerror\fR token. Use a symbolic token instead.
.SH "THE TAIL"
.IX Header "THE TAIL"
The tail section contains Perl code. Usually it is empty, but you
can if you want put here your own lexical analyzer and 
error management subroutines.
An example of this is in
files \f(CW\*(C`examples/eyapplanguageref/List3_tree_d_sem.yp\*(C'\fR (the grammar)
and \f(CW\*(C`use_list3_tree_d_dem.pl\*(C'\fR (the client).
.SH "THE LEXICAL ANALYZER"
.IX Header "THE LEXICAL ANALYZER"
The Lexical Analyzer 
is called each time the parser needs a new token.
It is called with only one argument (the parser object)
and returns a pair 
containing the next token and its associated attribute.
.PP
The fact that is a method of the parser object means that the parser
methods are accessible inside the lexical analyzer.
.PP
When the lexical analyzer reaches the end of input, it must return the
pair \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
.SS "Automatic Generation of Lexical Analyzers"
.IX Subsection "Automatic Generation of Lexical Analyzers"
By default a lexical analyzer is built.
The \f(CW\*(C`eyapp\*(C'\fR option \f(CW\*(C`\-l\*(C'\fR
can be used to inhibit the generation of 
the default lexical analyzer. In such case,
one must be explictly provided.
.PP
\fINo token Definitions\fR
.IX Subsection "No token Definitions"
.PP
When no token definitions are given in the head section, 
the default lexical analyzer simply assumes
that the token is the string literal. See this example in 
file \f(CW\*(C`examples/lexergeneration/simple.yp\*(C'\fR:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat simple.yp
\&  %%
\&  A:    a
\&      | A d
\&  ;
\&  %%
.Ve
.PP
The grammar does not describes the lexical analyzer nor the error default subroutine.
Eyapp will generate default lexical and error subroutines:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-o simple.pl \-TC simple.yp
\&
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ls \-ltr | tail \-2
\&  \-rw\-r\-\-r\-\- 1 pl pl   27 2010\-06\-29 10:28 simple.yp
\&  \-rwxr\-xr\-x 1 pl pl 3245 2010\-06\-29 10:35 simple.pl
.Ve
.PP
The option \f(CW\*(C`\-T\*(C'\fR is equivalent to insert the \f(CW%tree\fR directive in the head section.
Since no names were explicitly given to the productions, the names of the productions are built using
the pattern \f(CW\*(C`Lhs_is_RHS\*(C'\fR.
.PP
Option \f(CW\*(C`\-C\*(C'\fR instructs the \f(CW\*(C`eyapp\*(C'\fR compiler to produce an executable by setting the execution permits
(see \f(CW\*(C`simple.pl\*(C'\fR permits above), inserting the appropriate she bang directive:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ head simple.pl | head \-1
\&  #!/usr/bin/perl
.Ve
.PP
and inserting a call to the package \f(CW\*(C`main\*(C'\fR subroutine at the end of the generated parser:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ tail \-6 simple.pl
\&  unless (caller) {
\&    exit !_\|_PACKAGE_\|_\->main(\*(Aq\*(Aq);
\&  }
.Ve
.PP
If no \f(CW\*(C`main\*(C'\fR was provided, \f(CW\*(C`eyapp\*(C'\fR will provide one.
.PP
Tokens \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`d\*(C'\fR are assumed to represent strings \f(CW\*(Aqa\*(Aq\fR
and \f(CW\*(Aqd\*(Aq\fR respectively.
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-i \-t \-c \*(Aqa d d\*(Aq
\&  A_is_A_d(A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d]),TERMINAL[d])
.Ve
.PP
The \f(CW\*(C`main\*(C'\fR method provided by \f(CW\*(C`eyapp\*(C'\fR accepts several options in the command line:
.IP "\(bu" 2
\&\f(CW\*(C`\-t\*(C'\fR Prints the abstract syntax tree
.IP "\(bu" 2
\&\f(CW\*(C`\-i\*(C'\fR Shows the semantic value associated with each terminal
.IP "\(bu" 2
\&\f(CW\*(C`\-c string\*(C'\fR Indicates that the input is given by the \f(CW\*(C`string\*(C'\fR that follows the option
.PP
You can get the set of available options using \f(CW\*(C`\-\-help\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-h
\&  Available options:
\&    \-\-debug                    sets yydebug on
\&    \-\-nodebug                  sets yydebug off
\&    \-\-file filepath            read input from filepath
\&    \-\-commandinput string      read input from string
\&    \-\-tree                     prints $tree\->str
\&    \-\-notree                   does not print $tree\->str
\&    \-\-info                     When printing $tree\->str shows the value of TERMINALs
\&    \-\-help                     shows this help
\&    \-\-slurp                    read until EOF reached
\&    \-\-noslurp                  read until CR is reached
\&    \-\-argfile                  main() will take the input string from its @_
\&    \-\-noargfile                main() will not take the input string from its @_
\&    \-\-yaml                     dumps YAML for $tree: YAML module must be installed
\&    \-\-margin=i                 controls the indentation of $tree\->str (i.e. $Parse::Eyapp::Node::INDENT)
.Ve
.PP
If we try to feed it with an illegal input, an error message is emitted:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-i \-t \-c \*(Aqa e d\*(Aq
\&  Error inside the lexical analyzer near \*(Aqe\*(Aq. Line: 1. File: \*(Aqsimple.yp\*(Aq. No match found.
.Ve
.PP
In the example above we have taken advantage of the \f(CW\*(C`main\*(C'\fR method provided by Eyapp.
If we want to keep in control of the parsing process, we can write a client program that 
makes use of the generated modulino:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n usesimple.pl
\&     1  #!/usr/bin/env perl
\&     2  use warnings;
\&     3  use strict;
\&     4
\&     5  use simple;
\&     6
\&     7  # build a parser object
\&     8  my $parser = simple\->new();
\&     9
\&    10  # take the input from the command line arguments
\&    11  # or from STDIN
\&    12  my $input = join \*(Aq \*(Aq,@ARGV;
\&    13  $input = <> unless $input;
\&    14
\&    15  # set the input
\&    16  $parser\->input($input);
\&    17
\&    18  # parse the input and get the AST
\&    19  my $tree = $parser\->YYParse();
\&    20
\&    21  print $tree\->str()."\en";
.Ve
.PP
Here is an example of execution:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-T simple.yp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimple.pl a d d
\&  A_is_A_d(A_is_A_d(A_is_a(TERMINAL),TERMINAL),TERMINAL)
.Ve
.PP
\fIToken Definitions: Regular Expressions\fR
.IX Subsection "Token Definitions: Regular Expressions"
.PP
Eyapp extends the \f(CW%token\fR directive with the syntax:
.PP
.Vb 1
\&     %token TOKENID = /regexp/
.Ve
.PP
If such definition is used, an entry with the shape:
.PP
.Vb 1
\&   /\eG$regexp/gc and return (\*(AqTOKENID\*(Aq, $1);
.Ve
.PP
will be added to the generated lexical analyzer.
Therefore the string associated with the first parenthesis in \f(CW\*(C`/regexp/\*(C'\fR
will be used as semantic value for \f(CW\*(C`TOKENID\*(C'\fR. If \f(CW\*(C`/regexp/\*(C'\fR has no
parenthesis \f(CW\*(C`undef\*(C'\fR will be the semantic value.
See this example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n numlist.eyp
\&     1  %token NUM = /(\ed+)/
\&     2  %token ID  = /(\ew+)/
\&     3
\&     4  %%
\&     5  A:
\&     6        B
\&     7      | A B
\&     8  ;
\&     9
\&    10  B:
\&    11        ID
\&    12      | a
\&    13      | NUM
\&    14  ;
\&    15  %%
.Ve
.PP
The order of the \f(CW%token\fR declarations is important. 
In the example the token \f(CW\*(C`NUM\*(C'\fR is a subset of the token \f(CW\*(C`ID\*(C'\fR.
Since it appears first, it will be tried first:
.PP
.Vb 2
\&     /\eG(\ed+)/gc and return (\*(AqNUM\*(Aq, $1);
\&     /\eG(\ew+)/gc and return (\*(AqID\*(Aq, $1);
.Ve
.PP
Also observe that token \f(CW\*(Aqa\*(Aq\fR (line 12) is contained
in token \f(CW\*(C`ID\*(C'\fR. However, any implicit token like this that appears in the
body section and was not 
declared using an explicit \f(CW%token\fR directive in the
head section takes priority over the ones declared.
See the behavior of the former program:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC numlist
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./numlist.pm \-t \-i \-c \*(Aq4 a b\*(Aq
\&  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
.Ve
.PP
The lexical analyzer returned \f(CW\*(C`NUM\*(C'\fR and not \f(CW\*(C`ID\*(C'\fR when \f(CW4\fR was processed,
also it returned \f(CW\*(C`a\*(C'\fR and not \f(CW\*(C`ID\*(C'\fR when \f(CW\*(Aqa\*(Aq\fR was 
processed.
.PP
A \f(CW%token\fR declaration without assignment like in:
.PP
.Vb 1
\&   %token A B
.Ve
.PP
is equivalent to
.PP
.Vb 2
\&  %token A   = /(A)/
\&  %token B   = /(B)/
.Ve
.PP
(in that order).
.PP
\fIToken Definitions via Code\fR
.IX Subsection "Token Definitions via Code"
.PP
An alternative way to define a token is via Perl code:
.PP
.Vb 1
\&      %token TOKENID = { ... }
.Ve
.PP
in such case the code defining \f(CW\*(C`TOKENID\*(C'\fR will be inserted
verbatim in the corresponding place of the generated lexical 
analyzer. When the code \f(CW\*(C`{ ... }\*(C'\fR
is executed, the variable \f(CW$_\fR 
contains the input being parsed and
the special variable \f(CW$self\fR refers to the parser object.
The following example is equivalent to the one used in the previous
section:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n tokensemdef.eyp
\&     1  %token NUM = /(\ed+)/
\&     2  %token ID  = { /\eG(\ew+)/gc and return (\*(AqID\*(Aq, $1); }
\&     3
\&     4  %%
\&     5  A:
\&     6        B
\&     7      | A B
\&     8  ;
\&     9
\&    10  B:
\&    11        ID
\&    12      | a
\&    13      | NUM
\&    14  ;
\&    15  %%
.Ve
.PP
Follows an example of compilation and execution:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC tokensemdef.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./tokensemdef.pm \-t \-i \-nos
\&  4 a b
\&  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
.Ve
.PP
\fIToken Definitions: Controling whites\fR
.IX Subsection "Token Definitions: Controling whites"
.PP
By default, the generated lexical analyzer skips 
white spaces, defined as \f(CW\*(C`/\es*/\*(C'\fR. The programmer
can change this behavior using the \f(CW%whites\fR directive.
The following example permits Perl-like comments 
in the input:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n simplewithwhites.eyp
\&     1  %whites  /(\es*(?:#.*)?\es*)/
\&     2  %%
\&     3  A:    a
\&     4      | A d
\&     5  ;
\&     6  %%
.Ve
.PP
Follows an example of execution:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-nA input
\&       1  a # 1$
\&       2  $
\&       3  d ^I#2$
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC simplewithwhites.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simplewithwhites.pm \-t \-i \-f input
\&  A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d])
.Ve
.PP
The \f(CW%white\fR directive can be followed by some Perl
code defining the white spaces:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n simplewithwhitescode.eyp
\&     1  %whites  { /\eG(\es*(?:#.*)?\es*)/gc and $self\->tokenline($1 =~ tr{\en}{}) }
\&     2  %%
\&     3  A:    a
\&     4      | A d
\&     5  ;
\&     6  %%
.Ve
.SS "Reading Input from File"
.IX Subsection "Reading Input from File"
You can use the method \f(CW\*(C`YYSlurpFile\*(C'\fR to read the input from a file
and set the input for the parser to its contents.
Yo can also use the \f(CW\*(C`YYInput\*(C'\fR method to set the input.
.PP
See the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n usesimplefromfile.pl
\&     1  #!/usr/bin/env perl
\&     2  use warnings;
\&     3  use strict;
\&     4
\&     5  use simplewithwhites;
\&     6
\&     7  my $parser = simplewithwhites\->new();
\&     8
\&     9  # take the input from the specified file
\&    10  my $fn = shift;
\&    11
\&    12  $parser\->YYSlurpFile($fn);
\&    13
\&    14  # parse the input and get the AST
\&    15  my $tree = $parser\->YYParse();
\&    16
\&    17  print $tree\->str()."\en";
.Ve
.PP
First, compile the grammar \f(CW\*(C`simplewithwhites.eyp\*(C'\fR presented above:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-T simplewithwhites
.Ve
.PP
And then run it:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n  input
\&     1  a # 1
\&     2
\&     3  d       #2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimplefromfile.pl input
\&  A_is_A_d(A_is_a(TERMINAL),TERMINAL)
.Ve
.SS "Huge input and Incremental Lexical Analyzers"
.IX Subsection "Huge input and Incremental Lexical Analyzers"
If your input is huge, try to make use of an incremental
lexical analyzer. In an incremental lexer the input
is read and parsed in chunks. Read up to a 
point where  it is safe to parse.
In the example below, the lexer reads a new line
each time we reach the end of the input string \f(CW\*(C`${$parser\->YYInput}\*(C'\fR.
In the case of the arithmetic expressions grammar below,
by reading up to \f(CW\*(Aq\en\*(Aq\fR, we are sure that the input is not
broken in the middle of a token.
Instead of having the whole huge input in memory,
we only keep a small substring.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n Incremental.eyp                    
\&     1  %right  \*(Aq=\*(Aq                                                                     
\&     2  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq                                                                 
\&     3  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq                                                                 
\&     4  %left   NEG                                                                     
\&     5                                                                                  
\&     6  %tree                                                                           
\&     7                                                                                  
\&     8  %%                                                                              
\&     9  input:                                                                          
\&    10          |   input $line  { print $line\->str."\en" }                              
\&    11  ;                                                                               
\&    12                                                                                  
\&    13  line:     \*(Aq\en\*(Aq                                                                  
\&    14          | exp \*(Aq\en\*(Aq
\&    15          | error \*(Aq\en\*(Aq
\&    16  ;
\&    17
\&    18  exp:        NUM
\&    19          |   VAR
\&    20          |   VAR \*(Aq=\*(Aq exp
\&    21          |   exp \*(Aq+\*(Aq exp
\&    22          |   exp \*(Aq\-\*(Aq exp
\&    23          |   exp \*(Aq*\*(Aq exp
\&    24          |   exp \*(Aq/\*(Aq exp
\&    25          |   \*(Aq\-\*(Aq exp %prec NEG
\&    26          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    27  ;
\&    28
\&    29  %%
\&    30
\&    31  sub _Lexer {
\&    32      my($parser)=shift;
\&    33
\&    34      if ($parser\->YYEndOfInput) {
\&    35        my $input = <STDIN>;
\&    36        return(\*(Aq\*(Aq, undef) unless $input;
\&    37        $parser\->input($input);
\&    38      };
\&    39
\&    40      for (${$parser\->YYInput}) {
\&    41          m/\eG[ \et]*/gc;
\&    42          m/\eG([0\-9]+(?:\e.[0\-9]+)?)/gc and return(\*(AqNUM\*(Aq,$1);
\&    43          m/\eG([A\-Za\-z][A\-Za\-z0\-9_]*)/gc and return(\*(AqVAR\*(Aq,$1);
\&    44          m/\eG(.)/gcs and return($1,$1);
\&    45          return(\*(Aq\*(Aq, undef);
\&    46      }
\&    47  }
\&    48
\&    49  _\|_PACKAGE_\|_\->lexer(\e&_Lexer);
.Ve
.PP
This approach has limitations. The code will get more tangled if some token
can take more than one line. For example, if we extend this language to accept 
C\-like comments \f(CW\*(C`/* ... */\*(C'\fR which expands over several lines.
.PP
Here follows an example of execution. 
This is the client program:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat useincremental.pl
\&  #!/usr/bin/perl \-w
\&  use Incremental;
\&
\&  Incremental\->new\->YYParse;
.Ve
.PP
This is a small test input file:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat inputforincremental
\&  a = 2
\&  a+3
\&  b=4
\&  b*2+a
.Ve
.PP
Finally, see the results of the execution:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./useincremental.pl < inputforincremental
\&  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
\&  line_4(exp_9(exp_7(TERMINAL),exp_6(TERMINAL)))
\&  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
\&  line_4(exp_9(exp_11(exp_7(TERMINAL),exp_6(TERMINAL)),exp_7(TERMINAL)))
.Ve
.PP
The numbers in the output refer to the production number:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-v Incremental.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ sed \-ne \*(Aq/Rules:/,/^$/p\*(Aq Incremental.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> input $end
\&  1:      input \-> /* empty */
\&  2:      input \-> input line
\&  3:      line \-> \*(Aq\en\*(Aq
\&  4:      line \-> exp \*(Aq\en\*(Aq
\&  5:      line \-> error \*(Aq\en\*(Aq
\&  6:      exp \-> NUM
\&  7:      exp \-> VAR
\&  8:      exp \-> VAR \*(Aq=\*(Aq exp
\&  9:      exp \-> exp \*(Aq+\*(Aq exp
\&  10:     exp \-> exp \*(Aq\-\*(Aq exp
\&  11:     exp \-> exp \*(Aq*\*(Aq exp
\&  12:     exp \-> exp \*(Aq/\*(Aq exp
\&  13:     exp \-> \*(Aq\-\*(Aq exp
\&  14:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.SS "Using Several Lexical Analyzers for the Same Parser"
.IX Subsection "Using Several Lexical Analyzers for the Same Parser"
At any time during the parsing you can use the method
\&\f(CW\*(C`$parser\->YYLexer\*(C'\fR to set a new lexical analyzer.
.PP
The following grammar starts setting the lexer
to  sub \f(CW\*(C`Lexer1\*(C'\fR (line 44). It later changes
the lexer to \f(CW\*(C`Lexer2\*(C'\fR (ine 24)
after the token \f(CW\*(Aq%%\*(Aq\fR is seen. 
Inside \f(CW\*(C`Lexer2\*(C'\fR the token \f(CW\*(C`A\*(C'\fR represents a \f(CW\*(AqB\*(Aq\fR.
This capability
allows the parsing of languages where different sections 
require different lexical analysis. For example, in \f(CW\*(C`yacc\*(C'\fR,
carriage returns separates declarations in the header 
section but is considered a white space inside the
body and tail sections. This feature has 
similar power to the \fIstate\fR concept of the
lexical analyzer generator \f(CW\*(C`flex\*(C'\fR.
.PP
.Vb 10
\&  $ cat \-n twolexers.eyp 
\&     1  %%
\&     2  s:  first \*(Aq%%\*(Aq second
\&     3  ;
\&     4  
\&     5  first:
\&     6      A first
\&     7    | A
\&     8  ;
\&     9  
\&    10  second:
\&    11      A second
\&    12    | A
\&    13  ;
\&    14  
\&    15  %%
\&    16  
\&    17  sub Lexer1 {
\&    18      my($parser)=shift;
\&    19  
\&    20      print "In Lexer 1 \en";
\&    21      for (${$parser\->YYInput}) {
\&    22          m/\eG\es*/gc;
\&    23          m/\eG(%%)/gc and do {
\&    24            $parser\->YYLexer(\e&Lexer2);
\&    25            return ($1, undef);
\&    26          };
\&    27          m/\eG(.)/gcs and return($1,$1);
\&    28          return(\*(Aq\*(Aq, undef);
\&    29      }
\&    30  }
\&    31  
\&    32  sub Lexer2 {
\&    33      my($parser)=shift;
\&    34  
\&    35      print "In Lexer 2 \en";
\&    36      for (${$parser\->YYInput}) {
\&    37          m/\eG\es*/gc;
\&    38          m/\eGB/gc    and return(\*(AqA\*(Aq,\*(AqB\*(Aq);
\&    39          m/\eG(.)/gcs and die "Error. Expected \*(AqB\*(Aq, found $1\en";
\&    40      }
\&    41          return(\*(Aq\*(Aq, undef);
\&    42  }
\&    43  
\&    44  _\|_PACKAGE_\|_\->lexer(\e&Lexer1);
.Ve
.PP
When executed, it behaves like this:
.PP
.Vb 7
\&        $ ./twolexers.pm \-t \-i \-m 1 \-c \*(AqA A %% B B\*(Aq
\&        In Lexer 1 
\&        In Lexer 1 
\&        In Lexer 1 
\&        In Lexer 2 
\&        In Lexer 2 
\&        In Lexer 2 
\&
\&        s_is_first_second(
\&          first_is_A_first(
\&            TERMINAL[A],
\&            first_is_A(
\&              TERMINAL[A]
\&            )
\&          ),
\&          second_is_A_second(
\&            TERMINAL[B],
\&            second_is_A(
\&              TERMINAL[B]
\&            )
\&          )
\&        )
.Ve
.PP
The lexer can bechanged at any time. The following example
starts using the default lexer generated by \f(CW\*(C`eyapp\*(C'\fR.
It changes the lexer to \f(CW\*(C`Lexer2\*(C'\fRinside an intermediate semantic action (line 7).
Inside \f(CW\*(C`Lexer2\*(C'\fR  the token \f(CW\*(C`A\*(C'\fR is interpreted as a word \f(CW\*(C`\ew+\*(C'\fR.
.PP
.Vb 10
\&   $ cat \-n twolexers2.eyp 
\&     1  # Compile it with:
\&     2  # $ eyapp \-TC twolexers2.eyp 
\&     3  # Run it with:
\&     4  # $ ./twolexers2.pm \-t \-i \-c \*(AqA A %% d3 c2\*(Aq
\&     5  
\&     6  %%
\&     7  s:  first \*(Aq%%\*(Aq { $_[0]\->YYLexer(\e&Lexer2) } second
\&     8  ;
\&     9  
\&    10  first:
\&    11      A first
\&    12    | A
\&    13  ;
\&    14  
\&    15  second:
\&    16      A second
\&    17    | A
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Lexer2 {
\&    23      my($parser)=shift;
\&    24  
\&    25      print "In Lexer 2 \en";
\&    26      for (${$parser\->YYInput}) {
\&    27          m/\eG\es*/gc;
\&    28          m/\eG(\ew+)/gc    and return(\*(AqA\*(Aq,$1);
\&    29          m/\eG(.)/gcs and die "Error. Expected a word,Found $1\en";
\&    30      }
\&    31      return(\*(Aq\*(Aq, undef);
\&    32  }
.Ve
.SH "THE ERROR REPORT SUBROUTINE"
.IX Header "THE ERROR REPORT SUBROUTINE"
The Error Report subroutine is also a parser attribute, 
and must be defined. By default \f(CW\*(C`Parse::Eyapp\*(C'\fR
provides a convenient error handler.
.PP
See the Parse::Yapp pages and elsewhere documentation
on \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`bison\*(C'\fR for more information.
.SH "USING AN EYAPP GRAMMAR"
.IX Header "USING AN EYAPP GRAMMAR"
The following is an example of a program that uses the calculator explained 
in the two previous sections:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n usecalc.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Calc;
\&     4
\&     5  my $parser = Calc\->new();
\&     6  $parser\->input(\e<<\*(AqEOI\*(Aq
\&     7  a = 2*3       # 1: 6
\&     8  d = 5/(a\-6)   # 2: division by zero
\&     9  b = (a+1)/7   # 3: 1
\&    10  c=a*3+4)\-5    # 4: syntax error
\&    11  a = a+1       # 5: 7
\&    12  EOI
\&    13  );
\&    14  my $t = $parser\->Run();
\&    15  print "========= Symbol Table ==============\en";
\&    16  print "$_ = $t\->{$_}\en" for sort keys %$t;
.Ve
.PP
The output for this program is (the input for each output
appear as a Perl comment on the right):
.PP
.Vb 1
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
\&
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./usecalc.pl
\&  6
\&  Illegal division by zero.
\&  1
\&
\&  Syntax error near \*(Aq)\*(Aq (line number 4).
\&  Expected one of these terminals: \*(Aq\-\*(Aq \*(Aq/\*(Aq \*(Aq^\*(Aq \*(Aq*\*(Aq \*(Aq+\*(Aq \*(Aq
\&  \*(Aq
\&  7
\&  ========= Symbol Table ==============
\&  a = 7
\&  b = 1
\&  c = 22
.Ve
.SH "LISTS AND OPTIONALS"
.IX Header "LISTS AND OPTIONALS"
The elements of the right hand side of a production (abbreviated \fIrhs\fR) can be one of these:
.PP
.Vb 9
\&  rhselt:     
\&        symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
.Ve
.PP
The \f(CW\*(C`STAR\*(C'\fR, \f(CW\*(C`OPTION\*(C'\fR and \f(CW\*(C`PLUS\*(C'\fR operators provide a simple mechanism
to express lists:
.IP "\(bu" 4
In Eyapp the \f(CW\*(C`+\*(C'\fR operator indicates one or more repetitions of the element
to the left of \f(CW\*(C`+\*(C'\fR, thus a rule like:
.Sp
.Vb 1
\&                        decls:  decl +
.Ve
.Sp
is the same as:
.Sp
.Vb 2
\&                        decls:  decls decl 
\&                             |  decl
.Ve
.Sp
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
.Sp
.Vb 1
\&                       rhss: rule <+ \*(Aq|\*(Aq>
.Ve
.Sp
is equivalent to:
.Sp
.Vb 2
\&                       rhss: rhss \*(Aq|\*(Aq rule 
\&                           | rule
.Ve
.IP "\(bu" 4
The operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR have their usual meaning: 0 or more for
\&\f(CW\*(C`*\*(C'\fR and optionality for \f(CW\*(C`?\*(C'\fR. Is legal to parenthesize 
a \f(CW\*(C`rhs\*(C'\fR expression as in:
.Sp
.Vb 1
\&                       optname: (NAME IDENT)?
.Ve
.ie n .SS "The ""+"" operator"
.el .SS "The \f(CW+\fP operator"
.IX Subsection "The + operator"
The grammar:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat List3.yp 
\&  %semantic token \*(Aqc\*(Aq 
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  \*(Aqd\*(Aq+ 
\&             { 
\&                print Dumper($_[1]);
\&                print Dumper($_[2]);
\&             } 
\&  ;
\&  %%
.Ve
.PP
Is equivalent to:
.PP
.Vb 9
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-v List3.yp; head \-9 List3.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:  $start \-> S $end
\&  1:  PLUS\-1 \-> PLUS\-1 \*(Aqc\*(Aq
\&  2:  PLUS\-1 \-> \*(Aqc\*(Aq
\&  3:  PLUS\-2 \-> PLUS\-2 \*(Aqd\*(Aq
\&  4:  PLUS\-2 \-> \*(Aqd\*(Aq
\&  5:  S \-> PLUS\-1 PLUS\-2
.Ve
.PP
By default, the semantic action associated with a \f(CW\*(C`+\*(C'\fR returns the lists of attributes
to which the \f(CW\*(C`+\*(C'\fR applies:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = [ \*(Aqc\*(Aq, \*(Aqc\*(Aq ];
\&  $VAR1 = [ \*(Aqd\*(Aq, \*(Aqd\*(Aq ];
.Ve
.PP
Observe that, in spite of \f(CW\*(Aqd\*(Aq\fR being a syntactic token
the actions related with the \f(CW\*(C`d+\*(C'\fR element (i.e. the actions associated
with the \f(CW\*(C`PLUS\-2\*(C'\fR productions) create the list of \f(CW\*(C`d\*(C'\fRs.
.PP
The semantic associated with a \f(CW\*(C`+\*(C'\fR changes 
when one of the tree creation directives is active (for instance \f(CW%tree\fR or \f(CW%metatree\fR)
or it has been explicitly requested with a call to the \f(CW\*(C`YYBuildingTree\*(C'\fR method:
.PP
.Vb 1
\&                            $self\->YYBuildingTree(1);
.Ve
.PP
Other ways to change the associated semantic are to use the 
\&\f(CW\*(C`yybuildingtree\*(C'\fR option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 4
\&         $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&                           yybuildingtree => 1,
\&                         # yydebug => 0x1F
\&         );
.Ve
.PP
In such case the associated semantic action creates a node labelled
.PP
.Vb 1
\&                     _PLUS_LIST
.Ve
.PP
whose children are the attributes associated with the items in the plus list. 
As it happens when using the \f(CW%tree\fR directive, \fIsyntactic tokens\fR are skipped.
.PP
When executing the example above but under the \f(CW%tree\fR directive
the output changes. The \f(CW\*(C`\-T\*(C'\fR option tells the \f(CW\*(C`eyapp\*(C'\fR compiler
to introduce an implicit \f(CW%tree\fR directive>:
.PP
.Vb 1
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-T List3.yp
.Ve
.PP
If we now run the client program with input \f(CW\*(C`ccdd\*(C'\fR we get
a couple of syntax trees:
.PP
.Vb 9
\&  ~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.PP
The node associated with the list of \f(CW\*(C`d\*(C'\fRs is empty since
terminal \f(CW\*(C`d\*(C'\fR wasn't declared semantic.
.SS "When Nodes Disappear from Lists"
.IX Subsection "When Nodes Disappear from Lists"
When under the influence of the \f(CW%tree\fR directive
the action associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes don't show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat ListWithRefs1.eyp 
\&  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  D+ 
\&             { 
\&                print Dumper($_[1]);
\&                print $_[1]\->str."\en";
\&                print Dumper($_[2]);
\&                print $_[2]\->str."\en";
\&             } 
\&  ;
\&
\&  D: \*(Aqd\*(Aq
\&  ;
\&
\&  %%
\&
\&  sub Run {
\&    my ($self) = shift;
\&    return $self\->YYParse( yybuildingtree => 1 );
\&  }
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR (line 26).
.PP
The execution gives an output like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs1.eyp; ./use_listwithrefs1.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  _PLUS_LIST(TERMINAL,TERMINAL)
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq ); _PLUS_LIST
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
associated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.SS "Recovering the Missing Nodes"
.IX Subsection "Recovering the Missing Nodes"
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs.eyp
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:  \*(Aqc\*(Aq+  D+ 
\&     8        { 
\&     9           print Dumper($_[1]);
\&    10           print Dumper($_[2]);
\&    11        } 
\&    12  ;
\&    13  
\&    14  D: \*(Aqd\*(Aq
\&    15       {
\&    16         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&    17       }
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Run {
\&    23    my ($self) = shift;
\&    24    return $self\->YYParse( yybuildingtree => 1 );
\&    25  }
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs.eyp; ./use_listwithrefs.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.ie n .SS "Building a Tree with ""Parse::Eyapp::Node\->new"""
.el .SS "Building a Tree with \f(CWParse::Eyapp::Node\->new\fP"
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
The following execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the just created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  ~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explicitly constructed:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs2.eyp 
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:      \*(Aqc\*(Aq+  D+ 
\&     8             { 
\&     9                print Dumper($_[1]);
\&    10                print $_[1]\->str."\en";
\&    11                print Dumper($_[2]);
\&    12                print $_[2]\->str."\en";
\&    13             } 
\&    14  ;
\&    15  
\&    16  D: \*(Aqd\*(Aq.d
\&    17       {
\&    18         Parse::Eyapp::Node\->new(
\&    19           \*(AqDES(TERMINAL)\*(Aq, 
\&    20            sub { 
\&    21              my ($DES, $TERMINAL) = @_;
\&    22              $TERMINAL\->{attr} = $d;
\&    23            }
\&    24         );
\&    25       }
\&    26  ;
\&    27  
\&    28  %%
\&    29  
\&    30  sub Run {
\&    31    my ($self) = shift;
\&    32    return $self\->YYParse( yybuildingtree => 1 );
\&    33  }
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the section for \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  $ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.ie n .SS "The ""*"" operator"
.el .SS "The \f(CW*\fP operator"
.IX Subsection "The * operator"
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obviated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been suppressed.
.SS "Giving Names to Lists"
.IX Subsection "Giving Names to Lists"
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The grammar describes the language of sequences
.PP
.Vb 1
\&                  c,...,cd c,...,cd c,...,cd ....
.Ve
.PP
The right hand side of the production has only one term which is a list, 
but the factor to which the star applies is itself a list. 
We are naming the term with the name \f(CW\*(C`Cs_and_d\*(C'\fR and the factor with 
the name \f(CW\*(C`Cs\*(C'\fR.
.PP
The execution shows the renamed nodes:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ use_csbetweencommansanddwithnames.pl
\&  c,c,c,cd
\&
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.SS "Optionals"
.IX Subsection "Optionals"
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an \f(CW\*(C`_OPTIONAL\*(C'\fR
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.SS "Parenthesis"
.IX Subsection "Parenthesis"
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the \f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explicitly created
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or reverse derivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.SS "Actions Inside Parenthesis"
.IX Subsection "Actions Inside Parenthesis"
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SH "NAMES FOR ATTRIBUTES"
.IX Header "NAMES FOR ATTRIBUTES"
Attributes can be referenced by meaningful names using the \fIdot notation\fR
instead of using the classic error-prone positional approach:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdollar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SH "DEFAULT ACTIONS"
.IX Header "DEFAULT ACTIONS"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.SS "An Example of Default Action: Translator from Infix to Postfix"
.IX Subsection "An Example of Default Action: Translator from Infix to Postfix"
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.ie n .SS "Default Actions, %name and ""YYName"""
.el .SS "Default Actions, \f(CW%name\fP and \f(CWYYName\fP"
.IX Subsection "Default Actions, %name and YYName"
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  $ sed \-n \*(Aq29,50p\*(Aq YYNameDynamic.eyp | cat \-n
\&     1  exp:
\&     2              NUM   { $_[1] }
\&     3          |   VAR   { $_[1] }
\&     4          |   %name ASSIGN
\&     5              VAR \*(Aq=\*(Aq exp
\&     6          |   %name PLUS
\&     7              exp \*(Aq+\*(Aq exp
\&     8          |   %name MINUS
\&     9              exp \*(Aq\-\*(Aq exp
\&    10                {
\&    11                  my $self = shift;
\&    12                  $self\->YYName(\*(AqSUBTRACT\*(Aq); # rename it
\&    13                  $self\->YYBuildAST(@_); # build the node
\&    14                }
\&    15          |   %name TIMES
\&    16              exp \*(Aq*\*(Aq exp
\&    17          |   %name DIV
\&    18              exp \*(Aq/\*(Aq exp
\&    19          |   %name UMINUS
\&    20              \*(Aq\-\*(Aq exp %prec NEG
\&    21          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    22  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBTRACT\*(Aq )
\&  ];
.Ve
.SH "GRAMMAR REUSE"
.IX Header "GRAMMAR REUSE"
.SS "Reusing Grammars Using Inheritance"
.IX Subsection "Reusing Grammars Using Inheritance"
An method to reuse a grammar is via inheritance. 
The client inherits the generated parser module and expands it 
with methods that inherit or overwrite the actions.
Here is an example. Initially we have this Eyapp grammar:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n NoacInh.eyp
\&     1  %left   \*(Aq+\*(Aq
\&     2  %left   \*(Aq*\*(Aq
\&     3
\&     4  %defaultaction {
\&     5    my $self = shift;
\&     6
\&     7    my $action = $self\->YYName;
\&     8
\&     9    $self\->$action(@_);
\&    10  }
\&    11
\&    12  %%
\&    13  exp:        %name NUM
\&    14                NUM
\&    15          |   %name PLUS
\&    16                exp \*(Aq+\*(Aq exp
\&    17          |   %name TIMES
\&    18                exp \*(Aq*\*(Aq exp
\&    19          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    20                { $_[2] }
\&    21  ;
\&    22
\&    23  %%
\&    24
\&    25  sub _Error {
\&    26    my($token)=$_[0]\->YYCurval;
\&    27    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    28    my @expected = $_[0]\->YYExpect();
\&    29
\&    30    local $" = \*(Aq, \*(Aq;
\&    31    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    32  }
\&    33
\&    34
\&    35  my $x = \*(Aq\*(Aq;
\&    36
\&    37  sub _Lexer {
\&    38    my($parser)=shift;
\&    39
\&    40    for ($x) {
\&    41      s/^\es+//;
\&    42      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    43
\&    44      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    45      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    46      s/^(.)//s                    and return($1,$1);
\&    47    }
\&    48  }
\&    49
\&    50  sub Run {
\&    51    my($self)=shift;
\&    52    $x = shift;
\&    53    my $debug = shift;
\&    54
\&    55    $self\->YYParse(
\&    56      yylex => \e&_Lexer,
\&    57      yyerror => \e&_Error,
\&    58      yydebug => $debug,
\&    59    );
\&    60  }
.Ve
.PP
The following program defines two classes: \f(CW\*(C`CalcActions\*(C'\fR
that implements the actions for the calculator
and package \f(CW\*(C`PostActions\*(C'\fR that implements the actions
for the infix to postfix translation. This way we have an 
example that reuses the former grammar twice:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n icalcu_and_ipost.pl
\&     1  #!/usr/bin/perl \-w
\&     2  package CalcActions;
\&     3  use strict;
\&     4  use base qw{NoacInh};
\&     5
\&     6  sub NUM {
\&     7    return $_[1];
\&     8  }
\&     9
\&    10  sub PLUS {
\&    11    $_[1]+$_[3];
\&    12  }
\&    13
\&    14  sub TIMES {
\&    15    $_[1]*$_[3];
\&    16  }
\&    17
\&    18  package PostActions;
\&    19  use strict;
\&    20  use base qw{NoacInh};
\&    21
\&    22  sub NUM {
\&    23    return $_[1];
\&    24  }
\&    25
\&    26  sub PLUS {
\&    27    "$_[1] $_[3] +";
\&    28  }
\&    29
\&    30  sub TIMES {
\&    31    "$_[1] $_[3] *";
\&    32  }
\&    33
\&    34  package main;
\&    35  use strict;
\&    36
\&    37  my $calcparser = CalcActions\->new();
\&    38  print "Write an expression: ";
\&    39  my $x = <STDIN>;
\&    40  my $e = $calcparser\->Run($x);
\&    41
\&    42  print "$e\en";
\&    43
\&    44  my $postparser = PostActions\->new();
\&    45  my $p = $postparser\->Run($x);
\&    46
\&    47  print "$p\en";
.Ve
.PP
The subroutine used as default action in \f(CW\*(C`NoacInh.eyp\*(C'\fR is so useful 
that is packed as the Parse::Eyapp::Driver method 
\&\f(CW\*(C`YYDelegateaction\*(C'\fR.
.PP
See files \f(CW\*(C`examples/recycle/NoacYYDelegateaction.eyp\*(C'\fR
and \f(CW\*(C`examples/recycle/icalcu_and_ipost_yydel.pl\*(C'\fR
for an example of use of \f(CW\*(C`YYDelegateaction\*(C'\fR.
.SS "Reusing Grammars by Dynamic Substitution of Semantic Actions"
.IX Subsection "Reusing Grammars by Dynamic Substitution of Semantic Actions"
The methods \f(CW\*(C`YYSetaction\*(C'\fR and \f(CW\*(C`YYAction\*(C'\fR of the parser object provide a way
to selectively substitute some actions of a given grammar.
Let us consider once more a postfix to infix translator:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n PostfixWithActions.eyp
\&     1  # File PostfixWithActions.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6
\&     7  %%
\&     8  line: $exp  { print "$exp\en" }
\&     9  ;
\&    10
\&    11  exp:        $NUM
\&    12                  { $NUM }
\&    13          |   $VAR
\&    14                  { $VAR }
\&    15          |   %name ASSIGN
\&    16                VAR.left \*(Aq=\*(Aqexp.right
\&    17                  { "$_[3] &$_[1] ASSIGN"; }
\&    18          |   %name PLUS
\&    19                exp.left \*(Aq+\*(Aqexp.right
\&    20                  { "$_[1] $_[3] PLUS"; }
\&    21          |   %name MINUS
\&    22                exp.left \*(Aq\-\*(Aqexp.right
\&    23                  { "$_[1] $_[3] MINUS"; }
\&    24          |   %name TIMES
\&    25                exp.left \*(Aq*\*(Aqexp.right
\&    26                  { "$_[1] $_[3] TIMES"; }
\&    27          |   %name DIV
\&    28                exp.left \*(Aq/\*(Aqexp.right
\&    29                  { "$_[1] $_[3] DIV"; }
\&    30          |   %name NEG \*(Aq\-\*(Aq $exp %prec NEG
\&    31                  { "$exp NEG" }
\&    32          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq
\&    33                  { $exp }
\&    34  ;
\&    35
\&    36  %%
\&    37
\&    38  sub _Error {
\&    39    my($token)=$_[0]\->YYCurval;
\&    40    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    41    my @expected = $_[0]\->YYExpect();
\&    42
\&    43    local $" = \*(Aq, \*(Aq;
\&    44    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    45  }
\&    46
\&    47  my $x;
\&    48
\&    49  sub _Lexer {
\&    50    my($parser)=shift;
\&    51
\&    52    for ($x) {
\&    53      s/^\es+//;
\&    54      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    55
\&    56      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    57      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    58      s/^(.)//s                    and return($1,$1);
\&    59    }
\&    60  }
\&    61
\&    62  sub Run {
\&    63    my($self)=shift;
\&    64    $x = shift;
\&    65    $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    66      #yydebug => 0xFF
\&    67    );
\&    68  }
.Ve
.PP
The program \f(CW\*(C`rewritepostfixwithactions.pl\*(C'\fR uses the former grammar
to translate infix expressions to postfix expressions.
It also implements a calculator reusing the grammar in
\&\f(CW\*(C`PostfixWithActions.eyp\*(C'\fR. It does so using
the \f(CW\*(C`YYSetaction\*(C'\fR method.
The semantic actions for the productions named
.IP "\(bu" 2
\&\s-1ASSIGN\s0
.IP "\(bu" 2
\&\s-1PLUS\s0
.IP "\(bu" 2
\&\s-1TIMES\s0
.IP "\(bu" 2
\&\s-1DIV\s0
.IP "\(bu" 2
\&\s-1NEG\s0
.PP
are selectively substituted by the appropriate actions, while the other
semantic actions remain unchanged:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n rewritepostfixwithactions.pl
\&     1  #!/usr/bin/perl
\&     2  use warnings;
\&     3  use PostfixWithActions;
\&     4
\&     5  my $debug = shift || 0;
\&     6  my $pparser = PostfixWithActions\->new();
\&     7  print "Write an expression: ";
\&     8  my $x = <STDIN>;
\&     9
\&    10  # First, trasnlate to postfix ...
\&    11  $pparser\->Run($x, $debug);
\&    12
\&    13  # And then selectively substitute
\&    14  # some semantic actions
\&    15  # to obtain an infix calculator ...
\&    16  my %s;            # symbol table
\&    17  $pparser\->YYSetaction(
\&    18    ASSIGN => sub { $s{$_[1]} = $_[3] },
\&    19    PLUS   => sub { $_[1] + $_[3] },
\&    20    TIMES  => sub { $_[1] * $_[3] },
\&    21    DIV    => sub { $_[1] / $_[3] },
\&    22    NEG    => sub { \-$_[2] },
\&    23  );
\&    24
\&    25  $pparser\->Run($x, $debug);
.Ve
.PP
When running this program the output is:
.PP
.Vb 8
\&  examples/recycle$ ./rewritepostfixwithactions.pl
\&  Write an expression: 2*3+4
\&  2 3 TIMES 4 PLUS
\&  10
\&  examples/recycle$ rewritepostfixwithactions.pl
\&  Write an expression: a = 2*(b = 3+5)
\&  2 3 5 PLUS &b ASSIGN TIMES &a ASSIGN
\&  16
.Ve
.ie n .SH "ABSTRACT SYNTAX TREES: %tree AND %name"
.el .SH "ABSTRACT SYNTAX TREES: \f(CW%tree\fP AND \f(CW%name\fP"
.IX Header "ABSTRACT SYNTAX TREES: %tree AND %name"
.ie n .SS "%tree Default Names"
.el .SS "\f(CW%tree\fP Default Names"
.IX Subsection "%tree Default Names"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. Actually, the \f(CW%tree\fR directive is equivalent to a call
to the \f(CW\*(C`YYBuildAST\*(C'\fR method of the parser object.
.PP
Any production production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
can be named using a directive \f(CW\*(C`%name someclass\*(C'\fR.
.PP
When reducing by a production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
the \f(CW%tree\fR directive (i.e., the \f(CW\*(C`YYBuildAST\*(C'\fR method) 
builds an anonymous hash blessed in \f(CW\*(C`someclass\*(C'\fR.
The hash has an attribute \f(CW\*(C`children\*(C'\fR containing the references
to the \s-1AST\s0 trees associated with the symbols in the right hand
side \f(CW\*(C`X\*(C'\fR, C>Y>, etc.
.PP
If no explicit name was given to the production rule,
\&\f(CW\*(C`YYBuildAST\*(C'\fR blesses the node in the class name resulting 
from the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,27p\*(Aq treewithoutnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&         NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&      | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
\&
\&    %%
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ ./treewithoutnames.pl
\&
\&  ************
\&  _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
\&  ************
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR setting the \f(CW\*(C`outputfile\*(C'\fR
of \f(CW\*(C`Parse::Eyapp\*(C'\fR:
.PP
.Vb 6
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>9,      # String $grammar starts at line 9 (for error diagnostics)
\&    outputfile=>\*(Aqtreewithoutnames\*(Aq
\&  );
.Ve
.PP
The grammar with the expanded rules appears in the \f(CW\*(C`.output\*(C'\fR file:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> line $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&  2:      PLUS\-1 \-> exp
\&  3:      line \-> PLUS\-1
\&  4:      exp \-> NUM
\&  5:      exp \-> VAR
\&  6:      exp \-> VAR \*(Aq=\*(Aq exp
\&  7:      exp \-> exp \*(Aq+\*(Aq exp
\&  8:      exp \-> exp \*(Aq\-\*(Aq exp
\&  9:      exp \-> exp \*(Aq*\*(Aq exp
\&  10:     exp \-> exp \*(Aq/\*(Aq exp
\&  11:     exp \-> \*(Aq\-\*(Aq exp
\&  12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.ie n .SS "%tree Giving Explicit Names"
.el .SS "\f(CW%tree\fP Giving Explicit Names"
.IX Subsection "%tree Giving Explicit Names"
A production rule can be \fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive.  For
each production rule a namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR 
\&\fIis the name of the associated package\fR.  Therefore, by modifying the former
grammar with additional \f(CW%name\fR directives:
.PP
.Vb 7
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&        %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&      | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&      | %name DIV    exp \*(Aq/\*(Aq exp
\&      | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
.Ve
.PP
we are explicitly naming the productions. Thus, all the node instances 
corresponding to the production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. 
Now the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ ./treewithnames.pl
\&
\&  ************
\&  EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
\&  ************
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.SS "\s-1TERMINAL\s0 Nodes"
.IX Subsection "TERMINAL Nodes"
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the tokens provided by the lexical
analyzer.  \f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol than Parse::Yapp for
communication between the parser and the lexical analyzer: A couple \f(CW\*(C`($token,
$attribute)\*(C'\fR is returned by the lexical analyzer.  These values are stored
under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.  \f(CW\*(C`TERMINAL\*(C'\fR nodes as all
\&\f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost
always \- empty.
.ie n .SS "Explicit Actions Inside %tree"
.el .SS "Explicit Actions Inside \f(CW%tree\fP"
.IX Subsection "Explicit Actions Inside %tree"
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.ie n .SS "Explicitly Building Nodes With ""YYBuildAST"""
.el .SS "Explicitly Building Nodes With \f(CWYYBuildAST\fP"
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation (see
file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
inside \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-n \*(Aq397,408p\*(Aq lib/Simple/Types.eyp
\&  Variable:
\&      %name VAR
\&      ID
\&    | %name  VARARRAY
\&      $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&        {
\&          my $self = shift;
\&          my $node =  $self\->YYBuildAST(@_);
\&          $node\->{line} = $ID\->[1];# $_[1]\->[1]
\&          return $node;
\&        }
\&  ;
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.ie n .SS "Returning non References Under %tree"
.el .SS "Returning non References Under \f(CW%tree\fP"
.IX Subsection "Returning non References Under %tree"
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to suppress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,17p\*(Aq returnnonode.yp | cat \-n
\&     1  %tree
\&     2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     3  %%
\&     4  S:    %name EMPTY
\&     5          /* empty */
\&     6      | %name AES
\&     7          S A
\&     8      | %name BES
\&     9          S B
\&    10  ;
\&    11  A : %name A
\&    12        \*(Aqa\*(Aq
\&    13  ;
\&    14  B : %name B
\&    15        \*(Aqb\*(Aq { }
\&    16  ;
\&    17  %%
.Ve
.PP
since the action at line 15 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\&  $ usereturnnonode.pl
\&  ababa
\&  AES(BES(AES(BES(AES(EMPTY,A(TERMINAL[a]))),A(TERMINAL[a]))),A(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.ie n .SS "Intermediate actions and %tree"
.el .SS "Intermediate actions and \f(CW%tree\fP"
.IX Subsection "Intermediate actions and %tree"
Intermediate actions can be used to change the shape of the \s-1AST \s0(prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,15p\*(Aq intermediateactiontree.yp | cat \-n
\&     1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     2  %tree bypass
\&     3  %%
\&     4  S:    %name EMPTY
\&     5         /* empty */
\&     6      | %name SA
\&     7         S A.f { $f\->{attr} = "A"; $f; } A
\&     8      | %name SB
\&     9         S B.f { $f\->{attr} = "B"; $f; } B
\&    10  ;
\&    11  A : %name A \*(Aqa\*(Aq
\&    12  ;
\&    13  B : %name B \*(Aqb\*(Aq
\&    14  ;
\&    15  %%
.Ve
.PP
See the client program:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
.Ve
.PP
When it runs produces this output:
.PP
.Vb 3
\&  $ useintermediateactiontree.pl
\&  aabbaa
\&  SA(SB(SA(EMPTY,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.SS "Syntactic and Semantic tokens"
.IX Subsection "Syntactic and Semantic tokens"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR differences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the section Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 10
\&  $ cat \-n synopsis.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Parse::Eyapp::Treeregexp;
\&     5
\&     6  sub TERMINAL::info {
\&     7    $_[0]{attr}
\&     8  }
\&     9
\&    10  my $grammar = q{
\&    11    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    12    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    13    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    14    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    15    %tree           # Let us build an abstract syntax tree ...
\&    16
\&    17    %%
\&    18    line:
\&    19        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&    20          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    21    ;
\&    22
\&    23    /* The %name directive defines the name of the class */
\&    24    exp:
\&    25        %name NUM
\&    26        NUM
\&    27      | %name VAR
\&    28        VAR
\&    29      | %name ASSIGN
\&    30        VAR \*(Aq=\*(Aq exp
\&    31      | %name PLUS
\&    32        exp \*(Aq+\*(Aq exp
\&    33      | %name MINUS
\&    34        exp \*(Aq\-\*(Aq exp
\&    35      | %name TIMES
\&    36        exp \*(Aq*\*(Aq exp
\&    37      | %name DIV
\&    38        exp \*(Aq/\*(Aq exp
\&    39      | %name UMINUS
\&    40        \*(Aq\-\*(Aq exp %prec NEG
\&    41      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    42          { $_[2] }  /* Let us simplify a bit the tree */
\&    43    ;
\&    44
\&    45    %%
\&    46    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&    47
\&    48    sub _Lexer {
\&    49      my($parser)=shift; # The parser object
\&    50
\&    51      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&    52        m{\eG\es+}gc;
\&    53        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    54        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&    55        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&    56        m{\eG(.)}gcs and return($1,$1);
\&    57      }
\&    58      return(\*(Aq\*(Aq,undef);
\&    59    }
\&    60
\&    61    sub Run {
\&    62        my($self)=shift;
\&    63        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    64    }
\&    65  }; # end grammar
\&    66
\&    67  our (@all, $uminus);
\&    68
\&    69  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    70    input=>$grammar,
\&    71    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    72    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&    73  );
\&    74  my $parser = Calc\->new();                # Create a parser
\&    75  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&    76  my $t = $parser\->Run;                    # Parse it!
\&    77  local $Parse::Eyapp::Node::INDENT=2;
\&    78  print "Syntax Tree:",$t\->str;
\&    79
\&    80  # Let us transform the tree. Define the tree\-regular expressions ..
\&    81  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    82      { #  Example of support code
\&    83        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&    84      }
\&    85      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&    86        => {
\&    87          my $op = $Op{ref($bin)};
\&    88          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&    89          $_[0] = $NUM[0];
\&    90        }
\&    91      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&    92      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    93      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    94    },
\&    95    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&    96  );
\&    97  $p\->generate(); # Create the tranformations
\&    98
\&    99  $t\->s($uminus); # Transform UMINUS nodes
\&   100  $t\->s(@all);    # constant folding and mult. by zero
\&   101
\&   102  local $Parse::Eyapp::Node::INDENT=0;
\&   103  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESSION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESSION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifier, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST.\s0
.SS "Changing the Status of a Token"
.IX Subsection "Changing the Status of a Token"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.SS "Saving the Information of Syntactic Tokens in their Father"
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR
in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.ie n .SS "The  ""bypass"" clause and the ""%no bypass"" directive"
.el .SS "The  \f(CWbypass\fP clause and the \f(CW%no bypass\fP directive"
.IX Subsection "The bypass clause and the %no bypass directive"
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \s-1SYNOPSIS\s0 example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.ie n .SS "The ""alias"" clause of the %tree directive"
.el .SS "The \f(CWalias\fP clause of the \f(CW%tree\fP directive"
.IX Subsection "The alias clause of the %tree directive"
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dollar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods will provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
The \f(CW%prefix\fR directive used in line 7 of the following example
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix: \f(CW\*(C`R::S::\*(C'\fR in this example.
.PP
.Vb 10
\& cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    ..    ....
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
The tree \f(CW$t\fR for the expression \f(CW"a = \-(2*3+5\-1)\en"\fR is:
.PP
.Vb 9
\&  R::S::ASSIGN(
\&     R::S::TERMINAL,
\&     R::S::UMINUS(
\&       R::S::MINUS(
\&         R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM),
\&         R::S::NUM
\&       )
\&     )
\&  )
.Ve
.PP
The \f(CW\*(C`R::S::ASSIGN\*(C'\fR class has methods \f(CW\*(C`VAR\*(C'\fR (see line 89 above)
and \f(CW\*(C`exp\*(C'\fR (see lines 91 and 93) to refer to its two children. 
The result of the execution is:
.PP
.Vb 6
\&  $ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.PP
As a second example of the use of \f(CW%alias\fR, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST.\s0
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
\&
\& CalcwithAttributeGrammar.pl
.Ve
.PP
The program computes the tree for expression for expression
\&\f(CW\*(C`a = \-(2*3+5\-1)\*(C'\fR which is:
.PP
.Vb 1
\&  ASSIGN(TERMINAL,UMINUS(MINUS(PLUS(TIMES(NUM,NUM),NUM),NUM)))
.Ve
.PP
The children of the binary nodes can be accessed through the \f(CW\*(C`left\*(C'\fR
and \f(CW\*(C`right\*(C'\fR methods.
.SS "About the Encapsulation of Nodes"
.IX Subsection "About the Encapsulation of Nodes"
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
.SH "SOLVING CONFLICTS WITH THE \fIPOSTPONED CONFLICT\fP STRATEGY"
.IX Header "SOLVING CONFLICTS WITH THE POSTPONED CONFLICT STRATEGY"
Yacc-like parser generators provide ways to solve shift-reduce mechanims
based on token precedence. No mechanisms are provided for the resolution
of reduce-reduce conflicts. The solution for such kind of conflicts is to modify
the grammar. The strategy We present here provides a way to broach conflicts
that can't be solved using static precedences.
.SS "The \fIPostponed Conflict Resolution\fP Strategy"
.IX Subsection "The Postponed Conflict Resolution Strategy"
The \fIpostponed conflict strategy\fR presented here can be used whenever there 
is a shift-reduce or reduce-reduce conflict that can not be solved using static 
precedences.
.SS "\fIPostponed Conflict Resolution\fP: Reduce-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Reduce-Reduce Conflicts"
Let us assume we have a reduce-reduce conflict between to productions
.PP
.Vb 2
\&                      A \-> alpha .
\&                      B \-> beta .
.Ve
.PP
for some token \f(CW\*(C`@\*(C'\fR. Let also assume that production
.PP
.Vb 1
\&                      A \-> alpha
.Ve
.PP
has name \f(CW\*(C`ruleA\*(C'\fR and production
.PP
.Vb 1
\&                      B \-> beta
.Ve
.PP
has name \f(CW\*(C`ruleB\*(C'\fR.
.PP
The postponed conflict resolution strategy consists
in modifying the conflictive grammar by marking the points where the  conflict occurs
with the new \f(CW%PREC\fR directive. In this case at then end of the involved productions:
.PP
.Vb 2
\&                      A \-> alpha %PREC IsAorB 
\&                      B \-> beta  $PREC IsAorB
.Ve
.PP
The \f(CW\*(C`IsAorB\*(C'\fR identifier is called the \fIconflict name\fR.
.PP
Inside the head section, the programmer associates with the 
conflict name a code
whose mission is to solve the conflict by dynamically changing the
parsing table like this:
.PP
.Vb 2
\&                     %conflict IsAorB {
\&                          my $self = shift;
\&
\&                          if (looks_like_A($self)) {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleA\*(Aq );
\&                          }
\&                          else {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleB\*(Aq );
\&                          }
\&                       }
.Ve
.PP
The code associated with the \fIconflict name\fR
receives the name of \fI conflict handler\fR.
The code of \f(CW\*(C`looks_like_A\*(C'\fR stands for some form of nested parsing
which will decide which production applies.
.SS "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
.IX Subsection "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
In file \f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR we apply the postponed conflict resolution strategy
to the reduce reduce conflict that arises in Extended Pascal between the declaration of ranges and
the declaration of enumerated types (see section \*(L"Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal\*(R").
Here is the solution:
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ cat \-n pascalenumeratedvsrangesolvedviadyn.eyp
\&     1  %{
\&     2  =head1 SYNOPSIS
\&     3  
\&     4  See 
\&     5  
\&     6  =over 2
\&     7  
\&     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
\&     9  
\&    10  =item * The Bison manual L<http://www.gnu.org/software/bison/manual/html_mono/bison.html>
\&    11  
\&    12  =back
\&    13  
\&    14  Compile it with:
\&    15  
\&    16              eyapp \-b \*(Aq\*(Aq pascalenumeratedvsrangesolvedviadyn.eyp
\&    17  
\&    18  run it with this options:
\&    19  
\&    20              ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&    21  
\&    22  Try these inputs:
\&    23  
\&    24                  type r = (x) ..  y ;
\&    25                  type r = (x+2)*3 ..  y/2 ;
\&    26                  type e = (x, y, z);
\&    27                  type e = (x);
\&    28  
\&    29  =cut
\&    30  
\&    31  use base q{DebugTail}; 
\&    32  
\&    33  my $ID = qr{[A\-Za\-z][A\-Za\-z0\-9_]*};
\&    34               # Identifiers separated by commas
\&    35  my $IDLIST = qr{ \es*(?:\es*,\es* $ID)* \es* }x;
\&    36               # list followed by a closing par and a semicolon 
\&    37  my $RESTOFLIST = qr{$IDLIST \e) \es* ; }x;
\&    38  %}
\&    39  
\&    40  %namingscheme {
\&    41    #Receives a Parse::Eyapp object describing the grammar
\&    42    my $self = shift;
\&    43  
\&    44    $self\->tokennames(
\&    45      \*(Aq(\*(Aq => \*(AqLP\*(Aq,
\&    46      \*(Aq..\*(Aq => \*(AqDOTDOT\*(Aq,
\&    47      \*(Aq,\*(Aq => \*(AqCOMMA\*(Aq,
\&    48      \*(Aq)\*(Aq => \*(AqRP\*(Aq,
\&    49      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    50      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    51      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    52      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    53    );
\&    54  
\&    55    # returns the handler that will give names
\&    56    # to the right hand sides
\&    57    \e&give_rhs_name;
\&    58  }
\&    59  
\&    60  %strict
\&    61  
\&    62  %token ID NUM DOTDOT TYPE
\&    63  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    64  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    65  
\&    66  %tree
\&    67  
\&    68  %%
\&    69  
\&    70  type_decl : TYPE ID \*(Aq=\*(Aq type \*(Aq;\*(Aq
\&    71  ;
\&    72  
\&    73  type : 
\&    74        %name ENUM
\&    75        \*(Aq(\*(Aq id_list \*(Aq)\*(Aq
\&    76      | %name RANGE
\&    77        expr DOTDOT expr
\&    78  ;
\&    79  
\&    80  id_list : 
\&    81        %name EnumID
\&    82        ID rangeORenum
\&    83      | id_list \*(Aq,\*(Aq ID
\&    84  ;
\&    85  
\&    86  expr : \*(Aq(\*(Aq expr \*(Aq)\*(Aq
\&    87      | expr \*(Aq+\*(Aq expr
\&    88      | expr \*(Aq\-\*(Aq expr
\&    89      | expr \*(Aq*\*(Aq expr
\&    90      | expr \*(Aq/\*(Aq expr
\&    91      | %name RangeID
\&    92        ID rangeORenum
\&    93      | NUM
\&    94  ;
\&    95  
\&    96  rangeORenum: /* empty: postponed conflict resolution */
\&    97        {
\&    98            my $parser = shift;
\&    99            if (${$parser\->input()} =~ m{\eG(?= $RESTOFLIST)}gcx) {
\&   100                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqEnumID\*(Aq );
\&   101              }
\&   102              else {
\&   103                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqRangeID\*(Aq );
\&   104              }
\&   105        }
\&   106  ;
\&   107  
\&   108  %%
\&   109  
\&   110  _\|_PACKAGE_\|_\->lexer(
\&   111    sub {
\&   112      my $parser = shift;
\&   113  
\&   114      for (${$parser\->input()}) {    # contextualize
\&   115        m{\eG(\es*)}gc;
\&   116        $parser\->tokenline($1 =~ tr{\en}{});
\&   117  
\&   118        m{\eGtype\eb}gic                 and return (\*(AqTYPE\*(Aq, \*(AqTYPE\*(Aq);
\&   119  
\&   120        m{\eG($ID)}gc                   and return (\*(AqID\*(Aq,  $1);
\&   121  
\&   122        m{\eG([0\-9]+)}gc                and return (\*(AqNUM\*(Aq, $1);
\&   123  
\&   124        m{\eG\e.\e.}gc                    and return (\*(AqDOTDOT\*(Aq,  \*(Aq..\*(Aq);
\&   125  
\&   126        m{\eG(.)}gc                     and return ($1,    $1);
\&   127  
\&   128        return(\*(Aq\*(Aq,undef);
\&   129      }
\&   130    }
\&   131  );
\&   132  
\&   133  unless (caller()) {
\&   134    $Parse::Eyapp::Node::INDENT = 1;
\&   135    my $prompt = << \*(AqEOP\*(Aq;
\&   136  Try this input:
\&   137      type 
\&   138      r
\&   139      =
\&   140      (x)
\&   141      ..
\&   142      y
\&   143      ;
\&   144  
\&   145  Here other inputs you can try:
\&   146  
\&   147      type r = (x+2)*3 ..  y/2 ;
\&   148      type e = (x, y, z);
\&   149      type e = (x);
\&   150  
\&   151  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&   152  EOP
\&   153    _\|_PACKAGE_\|_\->main($prompt); 
\&   154  }
.Ve
.PP
This example also illustrates how to modify the default production
naming schema. Follows the result of several executions:
.PP
.Vb 9
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type r = (x+2)*3 ..  y/2 ;
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[r],
\&    RANGE(
\&      expr_is_expr_TIMES_expr(
\&        expr_is_LP_expr_RP(
\&          expr_is_expr_PLUS_expr(
\&            RangeID(
\&              TERMINAL[x]
\&            ),
\&            expr_is_NUM(
\&              TERMINAL[2]
\&            )
\&          )
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[3]
\&        )
\&      ),
\&      TERMINAL[..],
\&      expr_is_expr_DIV_expr(
\&        RangeID(
\&          TERMINAL[y]
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[2]
\&        )
\&      )
\&    )
\&  )
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type e = (x);
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[e],
\&    ENUM(
\&      EnumID(
\&        TERMINAL[x]
\&      )
\&    )
\&  )
.Ve
.SS "\fIPostponed Conflict Resolution\fP: Shift-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Shift-Reduce Conflicts"
The program in \f(CW\*(C`examples/debuggingtut/DynamicallyChangingTheParser2.eyp\*(C'\fR illustrates how the postponed
conflict strategy is used for shift-reduce conflicts.
This is an extension of the grammar in \f(CW\*(C`examples/debuggingtut/Debug.eyp\*(C'\fR.
The generated language is constituted by sequences like:
.PP
.Vb 1
\&    { D; D; S; S; S; } {D; S} { S }
.Ve
.PP
As you remember the conflict was:
.PP
.Vb 2
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/^St.*13:/,/^St.*14/p\*(Aq DynamicallyChangingTheParser.output  
\&  State 13:
\&
\&      ds \-> D conflict . \*(Aq;\*(Aq ds   (Rule 6)
\&      ds \-> D conflict .  (Rule 7)
\&
\&      \*(Aq;\*(Aq shift, and go to state 16
\&
\&      \*(Aq;\*(Aq [reduce using rule 7 (ds)]
\&
\&  State 14:
.Ve
.PP
The \f(CW\*(C`conflict\*(C'\fR handler below sets the \s-1LR\s0 action
to reduce by the production with name \f(CW\*(C`D1\*(C'\fR
.PP
.Vb 1
\&                 ds \-> D
.Ve
.PP
in the presence of token \f(CW\*(Aq;\*(Aq\fR if indeed is the last \f(CW\*(AqD\*(Aq\fR, that is, if:
.PP
.Vb 1
\&       ${$self\->input()} =~ m{^\es*;\es*S}
.Ve
.PP
Otherwise we set the \f(CW\*(C`shift\*(C'\fR action via a call to the 
\&\f(CW\*(C`YYSetShift\*(C'\fR method.
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq30,$p\*(Aq DynamicallyChangingTheParser.eyp | cat \-n
\&     1  %token D S
\&     2  
\&     3  %tree bypass
\&     4  
\&     5  # Expect just 1 shift\-reduce conflict
\&     6  %expect 1 
\&     7  
\&     8  %%
\&     9  p: %name PROG
\&    10      block +
\&    11  ;
\&    12  
\&    13  block:
\&    14      %name BLOCK_DS
\&    15      \*(Aq{\*(Aq ds \*(Aq;\*(Aq ss \*(Aq}\*(Aq 
\&    16    | %name BLOCK_S
\&    17      \*(Aq{\*(Aq ss \*(Aq}\*(Aq
\&    18  ;
\&    19  
\&    20  ds:
\&    21      %name D2
\&    22      D conflict \*(Aq;\*(Aq ds    
\&    23    | %name D1
\&    24      D conflict        
\&    25  ;
\&    26  
\&    27  ss:
\&    28      %name S2
\&    29      S \*(Aq;\*(Aq ss      
\&    30    | %name S1
\&    31      S       
\&    32  ;
\&    33  
\&    34  conflict:
\&    35        /* empty. This action solves the conflict using dynamic precedence */
\&    36        {
\&    37          my $self = shift;
\&    38  
\&    39          if (${$self\->input()} =~ m{^\es*;\es*S}) {
\&    40            $self\->YYSetReduce(\*(Aq;\*(Aq, \*(AqD1\*(Aq )
\&    41          }
\&    42          else {
\&    43            $self\->YYSetShift(\*(Aq;\*(Aq)
\&    44          }
\&    45  
\&    46          undef; # skip this node in the AST
\&    47        }
\&    48  ;
\&    49  
\&    50  %%
\&    51  
\&    52  my $prompt = \*(AqProvide a statement like "{D; S} {D; D; S}" and press <CR><CTRL\-D>: \*(Aq;
\&    53  _\|_PACKAGE_\|_\->main($prompt) unless caller;
.Ve
.SH "NAMING SCHEMES"
.IX Header "NAMING SCHEMES"
Explicit names can be given to grammar productions
via the \f(CW%name\fR directive. An alternative to explicitly gave 
names to rules is to define a \fInaming scheme\fR via the Eyapp directive
\&\f(CW%namingscheme\fR. This can be helpful when you inherit a large grammar
and want to quickly build a parser. The \s-1ANSI C\s0 parser in 
\&\f(CW\*(C`examples/languages/C/ansic.eyp\*(C'\fR is a good example. Another
example is the Pascal parser in \f(CW\*(C`examples/languages/pascal/pascal.eyp\*(C'\fR.
.PP
The Eyapp directive \f(CW%namingscheme\fR is followed by some Perl code. Such Perl
code must return a reference to a subroutine that will be called each time a new
production right hand side is parsed. The subroutine returns the name for the production.
.PP
The Perl code defining the handler receives a \f(CW\*(C`Parse::Eyapp\*(C'\fR object
that describes the grammar. The code after the \f(CW%namingscheme\fR
directive is evaluated during the early phases of the compilation of the input 
grammar. As an example of how to set a naming scheme, 
see lines 22\-38 below (you can find this example and others in the directory
\&\f(CW\*(C`examples/naming\*(C'\fR of the accompanying distribution):
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ cat \-n GiveNamesToCalc.eyp
\&     1  # GiveNamesToCalc.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6  %right  \*(Aq^\*(Aq
\&     7
\&     8  %tree bypass
\&     9
\&    10  %{
\&    11  use base q{Tail};
\&    12
\&    13  sub exp_is_NUM::info {
\&    14    my $self = shift;
\&    15
\&    16    $self\->{attr}[0];
\&    17  }
\&    18
\&    19  *exp_is_VAR::info = *var_is_VAR::info = \e&exp_is_NUM::info;
\&    20  %}
\&    21
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
\&    39  %%
\&    40
\&    41  line:
\&    42      exp
\&    43  ;
\&    44
\&    45  exp:
\&    46      NUM
\&    47    | VAR
\&    48    | var \*(Aq=\*(Aq exp
\&    49    | exp \*(Aq+\*(Aq exp
\&    50    | exp \*(Aq\-\*(Aq exp
\&    51    | exp \*(Aq*\*(Aq exp
\&    52    | exp \*(Aq/\*(Aq exp
\&    53    | %no bypass exp_is_NEG
\&    54       \*(Aq\-\*(Aq exp %prec NEG
\&    55    | exp \*(Aq^\*(Aq exp
\&    56    | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    57  ;
\&    58
\&    59  var:
\&    60      VAR
\&    61  ;
\&    62  %%
\&    63
\&    64  unless (caller) {
\&    65    my $t = _\|_PACKAGE_\|_\->main(@ARGV);
\&    66    print $t\->str."\en";
\&    67  }
.Ve
.PP
The example uses a naming scheme that is provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR: \f(CW\*(C`Parse::Eyapp::Grammar::give_token_name\*(C'\fR.
The current provided naming schemes handlers are:
.IP "\(bu" 2
\&\f(CW\*(C`give_default_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule
concatenated with an underscore and the index of the production
.IP "\(bu" 2
\&\f(CW\*(C`give_lhs_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule (this
is the naming scheme used by the \f(CW%tree\fR directive when no explicit name was given)
.IP "\(bu" 2
\&\f(CW\*(C`give_token_name\*(C'\fR: The name of the production is the Left Hand Side of the Production Rule followed by the 
word \f(CW\*(C`_is_\*(C'\fR followed by the concatenation of the names of the tokens in the right and side (separated by underscores).
.PP
All of these handlers are implemented inside the class \f(CW\*(C`Parse::Eyapp::Grammar\*(C'\fR. There is no need at line 
37 to explicit the class name prefix since the naming scheme code is evaluated inside such class:
.PP
.Vb 10
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
.Ve
.PP
As it is illustrated in this example, the method \f(CW\*(C`tokennames\*(C'\fR of \f(CW\*(C`Parse::Eyapp\*(C'\fR
objects provide a way to give identifier names to tokens that are defined by strings.
When we execute the former module/program (modulino) with input \f(CW\*(C`a=2*\-3\*(C'\fR we got the following
output:
.PP
.Vb 5
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ eyapp \-b \*(Aq\*(Aq GiveNamesToCalc.eyp
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ ./GiveNamesToCalc.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a=2*\-3
\&  line_is_exp(var_is_VAR[a],exp_is_TIMES(exp_is_NUM[2],exp_is_NEG(exp_is_NUM[3])))
.Ve
.PP
For each production rule the handler is called with arguments:
.IP "\(bu" 2
the \f(CW\*(C`Parse::Eyapp\*(C'\fR object,
.IP "\(bu" 2
the production index (inside the grammar),
.IP "\(bu" 2
the left hand side
symbol and a reference to a list with the symbols in the right hand side.
.PP
The following code of some version of \f(CW\*(C`give_token_name\*(C'\fR exemplifies how a
naming scheme handler can be written:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp$ sed \-ne \*(Aq101,132p\*(Aq lib/Parse/Eyapp/Grammar.pm | cat \-n
\&     1  sub give_token_name {
\&     2    my ($self, $index, $lhs, $rhs) = @_;
\&     3
\&     4    my @rhs = @$rhs;
\&     5    $rhs = \*(Aq\*(Aq;
\&     6
\&     7    unless (@rhs) { # Empty RHS
\&     8      return $lhs.\*(Aq_is_empty\*(Aq;
\&     9    }
\&    10
\&    11    my $names = $self\->{GRAMMAR}{TOKENNAMES} || {};
\&    12    for (@rhs) {
\&    13      if ($self\->is_token($_)) {
\&    14        s/^\*(Aq(.*)\*(Aq$/$1/;
\&    15        my $name = $names\->{$_} || \*(Aq\*(Aq;
\&    16        unless ($name) {
\&    17          $name = $_ if /^\ew+$/;
\&    18        }
\&    19        $rhs .= "_$name" if $name;
\&    20      }
\&    21    }
\&    22
\&    23    unless ($rhs) { # no \*(Aqword\*(Aq tokens in the RHS
\&    24      for (@rhs) {
\&    25        $rhs .= "_$_" if /^\ew+$/;
\&    26      }
\&    27    }
\&    28
\&    29    # check if another production with such name exists?
\&    30    my $name = $lhs.\*(Aq_is\*(Aq.$rhs;
\&    31    return $name;
\&    32  }
.Ve
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 2546:" 4
.IX Item "Around line 2546:"
Non-ASCII character seen before =encoding in 'va\*'lida\en";'. Assuming \s-1ISO8859\-1\s0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Parse5.16.3pm                  0100644 0001750 0001750 00000530472 12566242264 025243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Parse 3"
.TH Parse::Eyapp::Parse 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Parse \- The parser of Eyapp grammars
.SH "THE EYAPP LANGUAGE"
.IX Header "THE EYAPP LANGUAGE"
The parser for the \f(CW\*(C`Eyapp\*(C'\fR language
was written and generated
using \f(CW\*(C`Parse::Eyapp\*(C'\fR and the \f(CW\*(C`eyapp\*(C'\fR compiler (actually
the first version 
was bootstrapped using the yapp compiler).
The Eyapp program parsing the \f(CW\*(C`Eyapp\*(C'\fR language
is in the file \f(CW\*(C`Parse/Eyapp/Parse.yp\*(C'\fR 
in the \f(CW\*(C`Parse::Eyapp\*(C'\fR distribution.
Therefore \f(CW\*(C`Parse::Eyapp::Parse\*(C'\fR 
objects have all the methods in \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR.
.PP
A \f(CW\*(C`Parse::Eyapp::Parse\*(C'\fR is nothing but a particular kind of \f(CW\*(C`Parse::Eyapp\*(C'\fR
parser: \fIthe one that parses\fR \f(CW\*(C`Eyapp\*(C'\fR \fIgrammars\fR.
.SS "Eyapp Grammar"
.IX Subsection "Eyapp Grammar"
This section describes the syntax of the Eyapp language using its own notation.
The grammar extends yacc and yapp grammars.  Semicolons have been omitted
to save space.  Between C\-like comments you can find an (informal) explanation
of the language associated with each token.
.PP
.Vb 10
\&  %token ASSOC /* is %(left|right|nonassoc) */                                                                                                          
\&  %token BEGINCODE /* is %begin { Perl code ... } */                                                                                                    
\&  %token CODE /* is { Perl code ... } */                                                                                                                
\&  %token CONFLICT /* is %conflict */                                                                                                                    
\&  %token DEFAULTACTION /* is %defaultaction */                                                                                                          
\&  %token EXPECT /* is %expect */                                                                                                                        
\&  %token HEADCODE /* is %{ Perl code ... %} */                                                                                                          
\&  %token IDENT /* is [A\-Za\-z_][A\-Za\-z0\-9_]* */                                                                                                          
\&  %token LABEL /* is :[A\-Za\-z0\-9_]+ */                                                                                                                  
\&  %token LITERAL /* is a string literal like \*(Aqhello\*(Aq */                                                                                                 
\&  %token METATREE /* is %metatree */                                                                                                                    
\&  %token NAME /* is %name */                                                                                                                            
\&  %token NAMINGSCHEME /* is %namingscheme */                                                                                                            
\&  %token NOCOMPACT /* is %nocompact */                                                                                                                  
\&  %token NUMBER /* is \ed+ */                                                                                                                            
\&  %token OPTION /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e? */                                                                                                 
\&  %token PLUS /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+ */                                                                                                   
\&  %token PREC /* is %prec */                                                                                                                            
\&  %token PREFIX /* is %prefix\es+([A\-Za\-z_][A\-Za\-z0\-9_:]*::) */                                                                                          
\&  %token SEMANTIC /* is %semantic\es+token */                                                                                                            
\&  %token STAR /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e* */                                                                                                   
\&  %token START /* is %start */                                                                                                                          
\&  %token STRICT /* is %strict */                                                                                                                        
\&  %token SYNTACTIC /* is %syntactic\es+token */                                                                                                          
\&  %token TAILCODE /* is { Perl code ... } */                                                                                                            
\&  %token TOKEN /* is %token */                                                                                                                          
\&  %token TREE /* is %tree */                                                                                                                            
\&  %token TYPE /* is %type */                                                                                                                            
\&  %token UNION /* is %union */                                                                                                                          
\&  %start eyapp                                                                                                                                          
\&
\&  %%
\&
\&  # Main rule
\&  eyapp:     
\&        head body tail 
\&  ;                    
\&  #Common rules:       
\&  symbol:              
\&        LITERAL        
\&      | ident #default action
\&  ;                          
\&  ident:                     
\&        IDENT                
\&  ;                          
\&  # Head section:            
\&  head:                      
\&        headsec \*(Aq%%\*(Aq         
\&  ;                          
\&  headsec:                   
\&        #empty  #default action
\&      | decls #default action  
\&  ;                            
\&  decls:                       
\&        decls decl #default action
\&      | decl #default action      
\&  ;                               
\&  decl:                           
\&        \*(Aq\en\*(Aq #default action      
\&      | SEMANTIC typedecl symlist \*(Aq\en\*(Aq
\&      | SYNTACTIC typedecl symlist \*(Aq\en\*(Aq
\&      | TOKEN typedecl toklist \*(Aq\en\*(Aq    
\&      | ASSOC typedecl symlist \*(Aq\en\*(Aq    
\&      | START ident \*(Aq\en\*(Aq               
\&      | PREFIX \*(Aq\en\*(Aq                    
\&      | WHITES CODE \*(Aq\en\*(Aq               
\&      | WHITES REGEXP \*(Aq\en\*(Aq             
\&      | WHITES \*(Aq=\*(Aq CODE \*(Aq\en\*(Aq           
\&      | WHITES \*(Aq=\*(Aq REGEXP \*(Aq\en\*(Aq         
\&      | NAMINGSCHEME CODE \*(Aq\en\*(Aq         
\&      | HEADCODE \*(Aq\en\*(Aq                  
\&      | UNION CODE \*(Aq\en\*(Aq  #ignore       
\&      | DEFAULTACTION CODE \*(Aq\en\*(Aq        
\&      | LEXER CODE \*(Aq\en\*(Aq                
\&      | TREE \*(Aq\en\*(Aq                      
\&      | METATREE \*(Aq\en\*(Aq                  
\&      | STRICT \*(Aq\en\*(Aq                    
\&      | NOCOMPACT \*(Aq\en\*(Aq                 
\&      | TYPE typedecl identlist \*(Aq\en\*(Aq   
\&      | CONFLICT ident CODE \*(Aq\en\*(Aq       
\&      | EXPECT NUMBER \*(Aq\en\*(Aq             
\&      | EXPECT NUMBER NUMBER \*(Aq\en\*(Aq      
\&      | EXPECTRR NUMBER \*(Aq\en\*(Aq           
\&      | error \*(Aq\en\*(Aq                     
\&  ;                                    
\&  typedecl:                            
\&        #empty                         
\&      | \*(Aq<\*(Aq IDENT \*(Aq>\*(Aq                  
\&  ;                                    
\&  symlist:                             
\&        symlist symbol                 
\&      | symbol                         
\&  ;                                    
\&  toklist:                             
\&        toklist tokendef               
\&      | tokendef                       
\&  ;                                    
\&  tokendef:                            
\&        symbol \*(Aq=\*(Aq REGEXP              
\&      | symbol \*(Aq=\*(Aq CODE                
\&      | symbol                         
\&  ;                                    
\&  identlist:                           
\&        identlist ident                
\&      | ident                          
\&  ;                                    
\&  # Rule section                       
\&  body:                                
\&        rulesec \*(Aq%%\*(Aq                   
\&      | \*(Aq%%\*(Aq                           
\&  ;                                    
\&  rulesec:                             
\&        rulesec rules #default action  
\&      | startrules #default action     
\&  ;                                    
\&  startrules:                          
\&        IDENT \*(Aq:\*(Aq  rhss \*(Aq;\*(Aq            
\&      | error \*(Aq;\*(Aq                      
\&  ;                                    
\&  rules:                               
\&        IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq             
\&      | error \*(Aq;\*(Aq                      
\&  ;                                    
\&  rhss:                                
\&        rhss \*(Aq|\*(Aq rule                  
\&      | rule                           
\&  ;                                    
\&  rule:                                
\&        optname rhs prec epscode       
\&      | optname rhs                    
\&  ;                                    
\&  rhs:                                 
\&        #empty      #default action (will return undef)
\&      | rhselts #default action                        
\&  ;                                                    
\&  rhselts:                                             
\&        rhselts rhseltwithid                           
\&      | rhseltwithid                                   
\&  ;                                                    
\&  rhseltwithid:                                        
\&        rhselt \*(Aq.\*(Aq IDENT
\&      | \*(Aq$\*(Aq rhselt
\&      | \*(Aq$\*(Aq error
\&      | rhselt
\&  ;
\&  rhselt:
\&        symbol
\&      | code
\&      | DPREC ident
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq
\&      | rhselt STAR
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq
\&      | rhselt OPTION
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS
\&  ;
\&  optname:
\&        /* empty */
\&      | NAME IDENT
\&      | NAME IDENT LABEL
\&      | NAME LABEL
\&  ;
\&  prec:
\&        PREC symbol
\&  ;
\&  epscode:
\&      | code
\&  ;
\&  code:
\&        CODE
\&      | BEGINCODE
\&  ;
\&  # Tail section:
\&  tail:
\&        /*empty*/
\&      | TAILCODE
\&  ;
\&
\&  %%
.Ve
.PP
The semantic of \f(CW\*(C`Eyapp\*(C'\fR agrees with the semantic of \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`yapp\*(C'\fR for
all the common constructions.
.SS "Comments"
.IX Subsection "Comments"
Comments are either Perl style, from \f(CW\*(C`#\*(C'\fR
up to the end of line, or C style, enclosed between  \f(CW\*(C`/*\*(C'\fR and \f(CW\*(C`*/\*(C'\fR.
.SS "Syntactic Variables, Symbolic Tokens and String Literals"
.IX Subsection "Syntactic Variables, Symbolic Tokens and String Literals"
Two kind of symbols may appear inside a Parse::Eyapp program:
\&\fINon-terminal\fR symbols or \fIsyntactic variables\fR, 
called also \fIleft-hand-side\fR symbols
and \fITerminal\fR symbols, called
also \fITokens\fR.
.PP
Tokens are the symbols the lexical analyzer function returns to the parser.
There are two kinds of tokens: \fIsymbolic tokens\fR and \fIstring
literals\fR.
.PP
\&\fISyntactic variables\fR and \fIsymbolic tokens\fR identifiers must conform
to the regular expression \f(CW\*(C`[A\-Za\-z][A\-Za\-z0\-9_]*\*(C'\fR.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIsymbolic tokens\fR will be considered \fIsemantic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R"). \fISymbolic tokens\fR yield nodes
in the Abstract Syntax Tree.
.PP
String literals are enclosed in single quotes and can contain almost
anything. They will be received by the parser as double-quoted strings. 
Any special character as \f(CW\*(Aq"\*(Aq\fR, \f(CW\*(Aq$\*(Aq\fR and \f(CW\*(Aq@\*(Aq\fR is escaped.
To have a single quote inside a literal, escape it with '\e'.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIstring literals\fR will be considered \fIsyntactic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R"). \fISyntactic tokens\fR do not produce
nodes in the Abstract Syntax Tree.
.PP
The examples used along this document can be found in the directory 
\&\f(CW\*(C`examples/eyapplanguageref\*(C'\fR accompanying this distribution.
.ie n .SS "Parts of an ""eyapp"" Program"
.el .SS "Parts of an \f(CWeyapp\fP Program"
.IX Subsection "Parts of an eyapp Program"
An Eyapp program has three parts called head, body and tail:
.PP
.Vb 1
\&                                 eyapp: head body tail ;
.Ve
.PP
Each part is separated from the former by the symbol \f(CW\*(C`%%\*(C'\fR:
.PP
.Vb 2
\&                                 head: headsec \*(Aq%%\*(Aq
\&                                 body: rulesec \*(Aq%%\*(Aq
.Ve
.SH "THE HEAD SECTION"
.IX Header "THE HEAD SECTION"
The head section contains a list of declarations
.PP
.Vb 1
\&                                 headsec:  decl *
.Ve
.PP
There are different kinds of declarations.
.PP
This reference does not 
fully describes all the declarations that are shared with \f(CW\*(C`yacc\*(C'\fR and 
yapp.
.SS "Example of Head Section"
.IX Subsection "Example of Head Section"
In this and the next sections we will describe the basics
of the Eyapp language using the file \f(CW\*(C`examples/eyapplanguageref/Calc.eyp\*(C'\fR 
that accompanies this distribution. This file implements a trivial 
calculator. Here is the header section:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,/%%/p\*(Aq Calc.eyp | cat \-n
\&     1  # examples/eyapplanguageref/Calc.eyp
\&     2  %whites    =  /([ \et]*(?:#.*)?)/
\&     3  %token NUM =  /([0\-9]+(?:\e.[0\-9]+)?)/
\&     4  %token VAR =  /([A\-Za\-z][A\-Za\-z0\-9_]*)/
\&     5
\&     6  %right  \*(Aq=\*(Aq
\&     7  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     8  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     9  %left   NEG
\&    10  %right  \*(Aq^\*(Aq
\&    11
\&    12  %{
\&    13  my %s; # symbol table
\&    14  %}
\&    15
\&    16  %%
.Ve
.PP
Eyapp produces a lexical generator from the descriptions given
by the \f(CW%token\fR and \f(CW%whites\fR directives plus the tokens used 
inside the body section.
.PP
.Vb 3
\&       %whites    =  /([ \et]*(?:#.*)?)/
\&       %token NUM =  /([0\-9]+(?:\e.[0\-9]+)?)/
\&       %token VAR =  /([A\-Za\-z][A\-Za\-z0\-9_]*)/
.Ve
.PP
See section \*(L"Automatic Generation of Lexical Analyzers\*(R" for more details.
.SS "Declarations and Precedence"
.IX Subsection "Declarations and Precedence"
Lines 2\-5 declare several tokens. The usual way to declare
tokens is through the \f(CW%token\fR directive. The declarations 
\&\f(CW%nonassoc\fR, \f(CW%left\fR and \f(CW%right\fR 
not only declare the tokens but also associate a \fIpriority\fR with them.  
Tokens declared in the same line have the same precedence. 
Tokens declared with these directives in lines below have more
precedence than those declared above. Thus, in the example
above
we are saying that \f(CW"+"\fR and \f(CW"\-"\fR have the same precedence
but higher precedence than =. The final effect of \f(CW"\-"\fR
having greater precedence than = will be that an
expression like:
.PP
.Vb 1
\&                        a = 4 \- 5
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                        a = (4 \- 5)
.Ve
.PP
and not as
.PP
.Vb 1
\&                        (a = 4) \- 5
.Ve
.PP
The use of the \f(CW%left\fR indicates that \- in case of ambiguity 
and a match between precedences \- the parser must build the tree corresponding
to a left parenthesizing. Thus, the expression
.PP
.Vb 1
\&                         4 \- 5 \- 9
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                         (4 \- 5) \- 9
.Ve
.PP
You can refer to the token end-of-input in the header section using the string \f(CW\*(Aq\*(Aq\fR (for example
to give it some priority, see the example in \f(CW\*(C`examples/debuggingtut/typicalrrwithprec.eyp\*(C'\fR).
.SS "Header Code"
.IX Subsection "Header Code"
Perl code surrounded by \f(CW\*(C`%{\*(C'\fR and \f(CW\*(C`%}\*(C'\fR
can be inserted in the head section. Such code will be inserted in the module
generated by \f(CW\*(C`eyapp\*(C'\fR near the beginning. Therefore, declarations like the
one of the calculator symbol table \f(CW%s\fR
.PP
.Vb 3
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
.Ve
.PP
will be visible from almost any point in the file.
.SS "The Start Symbol of the Grammar"
.IX Subsection "The Start Symbol of the Grammar"
\&\f(CW\*(C`%start program\*(C'\fR declares \f(CW\*(C`program\*(C'\fR as the start symbol of 
the grammar. When \f(CW%start\fR is not
used, the first rule in the body section will be used.
.SS "Expect"
.IX Subsection "Expect"
The \f(CW\*(C`%expect #NUMBER\*(C'\fR directive works as in \f(CW\*(C`bison\*(C'\fR 
and  suppress warnings when the number of Shift/Reduce
conflicts is exactly \f(CW\*(C`#NUMBER\*(C'\fR.
.PP
The directive has been extended to be called with two numbers:
.PP
.Vb 1
\&  %expect NUMSHIFTRED NUMREDRED
.Ve
.PP
no warnings will be emitted if the number of shift-reduce 
conflicts is exactly \f(CW\*(C`NUMSHIFTRED\*(C'\fR and the number of reduce-reduce
conflicts is \f(CW\*(C`NUMREDRED\*(C'\fR.
.SS "Type and Union"
.IX Subsection "Type and Union"
C oriented declarations like \f(CW%type\fR and \f(CW%union\fR are
parsed but ignored.
.ie n .SS "The %strict Directive"
.el .SS "The \f(CW%strict\fP Directive"
.IX Subsection "The %strict Directive"
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ls \-ltr | tail \-1
\&  \-rw\-r\-\-r\-\- 1 pl users 2395 2008\-10\-02 09:41 bugyapp3.pm
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.ie n .SS "The %prefix Directive"
.el .SS "The \f(CW%prefix\fP Directive"
.IX Subsection "The %prefix Directive"
The \f(CW%prefix\fR directive 
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix
.PP
.Vb 1
\&  %prefix Some::Prefix::
.Ve
.PP
See the example in \f(CW\*(C`examples/eyapplanguageref/alias_and_yyprefix.pl\*(C'\fR.
See also section \*(L"Grammar Reuse\*(R" in Parse::Eyapp::defaultactionsintro
for an example that does not involve the \f(CW%tree\fR directive.
.SS "Default Action Directive"
.IX Subsection "Default Action Directive"
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify the default action 
using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. See section \*(L"\s-1DEFAULT\s0 \s-1ACTIONS\s0\*(R".
The examples \f(CW\*(C`examples/eyapplanguageref/Postfix.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/eyapplanguageref/Lhs.eyp\*(C'\fR illustrate the use of the directive.
.SS "Tree Construction Directives"
.IX Subsection "Tree Construction Directives"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
and \f(CW%metatree\fR directives. See sections
\&\*(L"\s-1ABSTRACT\s0 \s-1SYNTAX\s0 \s-1TREES:\s0 \f(CW%tree\fR \s-1AND\s0 \f(CW%name\fR\*(R"
and
Parse::Eyapp::translationschemestut.
.SS "Tokens and the Abstract Syntax Tree"
.IX Subsection "Tokens and the Abstract Syntax Tree"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the way \f(CW\*(C`eyapp\*(C'\fR builds the abstract syntax tree.
See section \*(L"Syntactic and Semantic tokens\*(R".
.ie n .SS "The %nocompact directive"
.el .SS "The \f(CW%nocompact\fP directive"
.IX Subsection "The %nocompact directive"
This directive influences the generation of the \s-1LALR\s0 tables.
They will not be compacted and the tokens
for the \f(CW\*(C`DEFAULT\*(C'\fR reduction will be explicitly set.
It can be used to produce an \f(CW\*(C`.output\*(C'\fR file (option \f(CW\*(C`\-v\*(C'\fR)
with more information.
.SH "THE BODY"
.IX Header "THE BODY"
The body section contains the rules describing the grammar:
.PP
.Vb 3
\&                       body:   rules * \*(Aq%%\*(Aq
\&                       rules:  IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&                       rhss:   (optname rhs (prec epscode)?) <+ \*(Aq|\*(Aq>
.Ve
.SS "Rules"
.IX Subsection "Rules"
A rule is made of a left-hand-side symbol (the \fIsyntactic variable\fR), 
followed by a \f(CW\*(Aq:\*(Aq\fR and one
or more \fIright-hand-sides\fR (or \fIproductions\fR)
 separated by \f(CW\*(Aq|\*(Aq\fR and terminated by a \f(CW\*(Aq;\*(Aq\fR
like in:
.PP
.Vb 5
\&                          exp: 
\&                               exp \*(Aq+\*(Aq exp
\&                            |  exp \*(Aq\-\*(Aq exp
\&                            |  NUM
\&                          ;
.Ve
.PP
A \fIproduction\fR (\fIright hand side\fR) may be empty:
.PP
.Vb 4
\&                          input:   
\&                               /* empty */
\&                            |  input line
\&                          ;
.Ve
.PP
The former two productions can be abbreviated as
.PP
.Vb 3
\&                          input: 
\&                               line *
\&                          ;
.Ve
.PP
The operators \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`?\*(C'\fR are presented in section
\&\*(L"\s-1LISTS\s0 \s-1AND\s0 \s-1OPTIONALS\s0\*(R".
.PP
A \fIsyntactic variable cannot appear more than once as
a rule name\fR (This differs from \f(CW\*(C`yacc\*(C'\fR).  So you can't 
write
.PP
.Vb 2
\&    thing: foo bar ;
\&    thing: foo baz ;
.Ve
.PP
instead, write:
.PP
.Vb 4
\&    thing: 
\&           foo bar 
\&         | foo baz 
\&    ;
.Ve
.SS "Semantic Values and Semantic Actions"
.IX Subsection "Semantic Values and Semantic Actions"
In \f(CW\*(C`Parse::Eyapp\*(C'\fR 
a production rule
.PP
.Vb 1
\&                          A \-> X_1 X_2 ... X_n
.Ve
.PP
can be followed by a 
\&\fIsemantic action\fR:
.PP
.Vb 1
\&                    A \-> X_1 X_2 ... X_n { Perl Code }
.Ve
.PP
Such
semantic action is nothing but Perl code that will be treated 
as an anonymous subroutine.  The semantic action associated 
with production rule \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR  is executed
after any actions associated with the subtrees of \f(CW\*(C`X_1\*(C'\fR,
\&\f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR.
\&\f(CW\*(C`Eyapp\*(C'\fR parsers build the syntax tree using a left-right
bottom-up traverse of the syntax tree. Each times
the Parser visits the node associated with the 
production \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR
the associated semantic action is called. 
Associated with each symbol
of a Parse::Eyapp grammar there is a scalar \fISemantic Value\fR
or \fIAttribute\fR. The semantic values of terminals are provided
by the lexical analyzer. In the calculator example
(see file \f(CW\*(C`examples/eyapplanguageref/Calc.yp\*(C'\fR in the distribution),
the semantic value associated with an expression
is its numeric value. Thus in the rule:
.PP
.Vb 1
\&                       exp \*(Aq+\*(Aq exp { $_[1] + $_[3] }
.Ve
.PP
\&\f(CW$_[1]\fR refers to the attribute of the first \f(CW\*(C`exp\*(C'\fR, \f(CW$_[2]\fR 
is the attribute associated with \f(CW\*(Aq+\*(Aq\fR, which is the second component of the 
pair provided by the lexical analyzer and \f(CW$_[3]\fR refers to the attribute of 
the second \f(CW\*(C`exp\*(C'\fR.
.PP
When the semantic action/anonymous subroutine is called,
the arguments are as follows:
.IP "\(bu" 4
\&\f(CW$_[1]\fR to \f(CW$_[n]\fR are the attributes of
the symbols \f(CW\*(C`X_1\*(C'\fR, \f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR. 
Just as \f(CW$1\fR to \f(CW$n\fR in \f(CW\*(C`yacc\*(C'\fR,
.IP "\(bu" 4
\&\f(CW$_[0]\fR is the parser object itself.
Having \f(CW$_[0]\fR being the parser object itself allows you to call
parser methods. Most \f(CW\*(C`yacc\*(C'\fR macros have been converted into
parser methods. See section \*(L"\s-1METHODS\s0 \s-1AVAILABLE\s0 \s-1IN\s0 \s-1THE\s0 \s-1GENERATED\s0 \s-1CLASS\s0\*(R" in Parse::Eyapp.
.PP
The returned value will be the attribute associated 
with the left hand side of the production.
.PP
Names can be given to the attributes using the dot notation
(see file \f(CW\*(C`examples/eyapplanguageref/CalcSimple.eyp\*(C'\fR):
.PP
.Vb 1
\&                     exp.left \*(Aq+\*(Aq exp.right { $left + $right }
.Ve
.PP
See section \*(L"\s-1NAMES\s0 \s-1FOR\s0 \s-1ATTRIBUTES\s0\*(R" for more details about the \fIdot\fR and \fIdollar\fR 
notations.
.PP
If no action is specified and no \f(CW%defaultaction\fR is specified
the default action
.PP
.Vb 1
\&                               { $_[1] }
.Ve
.PP
will be executed instead. See section \*(L"\s-1DEFAULT\s0 \s-1ACTIONS\s0\*(R" to know more.
.SS "Actions in Mid-Rule"
.IX Subsection "Actions in Mid-Rule"
Actions can be inserted in the middle of a production like in:
.PP
.Vb 1
\& block: \*(Aq{\*(Aq.bracket { $ids\->begin_scope(); } declaration*.decs statement*.sts \*(Aq}\*(Aq { ... }
.Ve
.PP
A middle production action is managed by inserting a new rule in the grammar and associating
the semantic action with it:
.PP
.Vb 1
\&                     Temp: /* empty */ { $ids\->begin_scope(); }
.Ve
.PP
Middle production actions can refer to the attributes on its left. They count
as one of the components of the production. Thus the program:
.PP
.Vb 5
\&  ~/LEyapp/examples/eyapplanguageref$ cat intermediateaction2.yp 
\&  %%
\&  S:  \*(Aqa\*(Aq { $_[1]x4 }.mid \*(Aqa\*(Aq { print "\en<<$_[2], $mid, $_[3]>>\en"; }
\&  ;
\&  %%
.Ve
.PP
The auxiliar syntactic variables are named \f(CW\*(C`@#position\-#order\*(C'\fR where \f(CW\*(C`#position\*(C'\fR
is the position of the action in the rhs and \f(CW\*(C`order\*(C'\fR is an ordinal number. See
the \f(CW\*(C`.output\*(C'\fR file for the former example:
.PP
.Vb 7
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-v intermediateaction2.yp
\&  ~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,5p\*(Aq intermediateaction2.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:  $start \-> S $end
\&  1:  S \-> \*(Aqa\*(Aq @1\-1 \*(Aqa\*(Aq
\&  2:  @1\-1 \-> /* empty */
.Ve
.PP
We can build an executable \f(CW\*(C`ia.pl\*(C'\fR from the former grammar using \f(CW\*(C`eyapp\*(C'\fR option \f(CW\*(C`\-C\*(C'\fR:
.PP
.Vb 1
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-C \-o ia.pl intermediateaction2.yp
.Ve
.PP
The \f(CW\*(C`main\*(C'\fR, error and lexer methods are provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR.
When given input \f(CW\*(C`aa\*(C'\fR the execution will produce as output \f(CW\*(C`aaaa, aaaa, a\*(C'\fR. The option
\&\f(CW\*(C`\-d\*(C'\fR activates the debug mode, the option \f(CW\*(C`\-c\*(C'\fR tells the program to get the input from the command line::
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ ./ia.pl \-d \-c \*(Aqaa\*(Aq
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:
\&  Stack: 0
\&  Need token. Got >a<
\&  Shift and go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack: 0\->\*(Aqa\*(Aq\->2
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (@1\-1 \-\-> /* empty */): Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack: 0\->\*(Aqa\*(Aq\->2\->\*(Aq@1\-1\*(Aq\->4
\&  Need token. Got >a<
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack: 0\->\*(Aqa\*(Aq\->2\->\*(Aq@1\-1\*(Aq\->4\->\*(Aqa\*(Aq\->5
\&  Don\*(Aqt need token.
\&  Reduce using rule 1 (S \-\-> a @1\-1 a): 
\&  <<aaaa, aaaa, a>>
\&  Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack: 0\->\*(AqS\*(Aq\->1
\&  Need token. Got ><
\&  Shift and go to state 3.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 3:
\&  Stack: 0\->\*(AqS\*(Aq\->1\->\*(Aq\*(Aq\->3
\&  Don\*(Aqt need token.
\&  Accept.
.Ve
.SS "Example of Body Section"
.IX Subsection "Example of Body Section"
Following with the calculator example, the body is:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq17,/%%/p\*(Aq Calc.eyp | cat \-n 
\&     1  start:                                                                              
\&     2      input { \e%s }                                                                   
\&     3  ;
\&     4
\&     5  input: line *
\&     6  ;
\&     7
\&     8  line:
\&     9      \*(Aq\en\*(Aq       { undef }
\&    10    | exp \*(Aq\en\*(Aq   {
\&    11                    print "$_[1]\en" if defined($_[1]);
\&    12                    $_[1]
\&    13                 }
\&    14    | error  \*(Aq\en\*(Aq
\&    15        {
\&    16          $_[0]\->YYErrok;
\&    17          undef
\&    18        }
\&    19  ;
\&    20
\&    21  exp:
\&    22      NUM
\&    23    | $VAR                   { $s{$VAR} }
\&    24    | $VAR \*(Aq=\*(Aq $exp          { $s{$VAR} = $exp }
\&    25    | exp.left \*(Aq+\*(Aq exp.right { $left + $right }
\&    26    | exp.left \*(Aq\-\*(Aq exp.right { $left \- $right }
\&    27    | exp.left \*(Aq*\*(Aq exp.right { $left * $right }
\&    28    | exp.left \*(Aq/\*(Aq exp.right
\&    29      {
\&    30         $_[3] and return($_[1] / $_[3]);
\&    31         $_[0]\->YYData\->{ERRMSG} = "Illegal division by zero.\en";
\&    32         $_[0]\->YYError;
\&    33         undef
\&    34      }
\&    35    | \*(Aq\-\*(Aq $exp %prec NEG     { \-$exp }
\&    36    | exp.left \*(Aq^\*(Aq exp.right { $left ** $right }
\&    37    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq           { $exp }
\&    38  ;
\&    39
\&    40  %%
.Ve
.PP
This body does not uses any of the Eyapp extensions (with the exception of the 
\&\f(CW\*(C`*\*(C'\fR operator at line 5) and the dot and dollar notations.
.SS "Solving Ambiguities and Conflicts"
.IX Subsection "Solving Ambiguities and Conflicts"
When Eyapp analyzes a grammar like:
.PP
.Vb 7
\&  examples/eyapplanguageref$ cat \-n ambiguities.eyp
\&     1  %%
\&     2  exp:
\&     3      NUM
\&     4    | exp \*(Aq\-\*(Aq exp
\&     5  ;
\&     6  %%
.Ve
.PP
it will produce a warning announcing the existence of 
\&\fIshift-reduce\fR conflicts:
.PP
.Vb 5
\&  examples/eyapplanguageref$ eyapp ambiguities.eyp
\&  1 shift/reduce conflict (see .output file)
\&  State 5: reduce by rule 2: exp \-> exp \*(Aq\-\*(Aq exp (default action)
\&  State 5: shifts:
\&    to state    3 with \*(Aq\-\*(Aq
.Ve
.PP
when \f(CW\*(C`eyapp\*(C'\fR finds warnings automatically produces a \f(CW\*(C`.output\*(C'\fR file
describing the conflict.
.PP
What the warning is saying is that an expression like \f(CW\*(C`exp \*(Aq\-\*(Aq exp\*(C'\fR (rule 2) followed by a
minus \f(CW\*(Aq\-\*(Aq\fR can be parsed in more than one way. If we
have an input like \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR the activity of a \s-1\fILALR\s0\fR\|(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of \fIshift and reduce actions\fR. A \fIshift action\fR
has as consequence the reading of the next token. A \fIreduce action\fR
is finding a production rule that matches and substituting 
the rhs of the production by the lhs.  For input \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR
the activity will be as follows (the dot is used to indicate where the next 
input token is):
.PP
.Vb 6
\&                           .NUM \- NUM \- NUM # shift
\&                            NUM.\- NUM \- NUM # reduce exp: NUM 
\&                            exp.\- NUM \- NUM # shift
\&                            exp \-.NUM \- NUM # shift
\&                            exp \- NUM.\- NUM # reduce exp: NUM
\&                            exp \- exp.\- NUM # shift/reduce conflict
.Ve
.PP
up this point two different decisions can be taken: the next description can be
.PP
.Vb 1
\&                                  exp.\- NUM # reduce by exp: exp \*(Aq\-\*(Aq exp (rule 2)
.Ve
.PP
or:
.PP
.Vb 1
\&                            exp \- exp \-.NUM # shift \*(Aq\-\*(Aq (to state 3)
.Ve
.PP
that is why it is called a \fIshift-reduce conflict\fR.
.PP
That is also the reason for the precedence declarations in the 
head section. Another kind of conflicts are \fIreduce-reduce conflicts\fR.
They arise when more that rhs can be applied for a reduction
action.
.PP
Eyapp solves the conflicts applying the following rules:
.IP "\(bu" 4
In a shift/reduce conflict, the default is the shift.
.IP "\(bu" 4
In a reduce/reduce conflict, the default is to reduce by the
earlier grammar production (in the input sequence).
.IP "\(bu" 4
Precedences and associativities can be given to tokens in
the declarations section. This is made by a sequence of lines beginning
with one of the directives: \f(CW%left\fR, \f(CW%right\fR, or \f(CW%nonassoc\fR, 
followed by a list of
tokens. All the tokens on the same line
have the same precedence and associativity; 
the lines are listed in order of increasing precedence.
.IP "\(bu" 4
A precedence and associativity is associated with each grammar
production; it is the precedence and associativity of the \fIlast token\fR 
or \fIliteral\fR in the right hand side of the production.
.IP "\(bu" 4
The \f(CW%prec\fR directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional \f(CW\*(C`%prec token\*(C'\fR directive
giving the production the precedence of the \f(CW\*(C`token\*(C'\fR
.Sp
.Vb 1
\&                          exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
.Ve
.IP "\(bu" 4
If there is a shift/reduce conflict, and both the grammar production
and the input token have precedence and associativity associated
with them, then the conflict is solved in favor of the action (shift or
reduce) associated with the higher precedence. If the precedences are the
same, then the associativity is used; left associative implies reduce,
right associative implies shift, and non associative implies error.
The last is used to describe operators, like the operator \f(CW\*(C`.LT.\*(C'\fR in \s-1FORTRAN\s0, 
that may not associate with themselves. That is, because
.Sp
.Vb 1
\&                             A .LT. B .LT. C
.Ve
.Sp
is invalid in \s-1FORTRAN\s0, \f(CW\*(C`.LT.\*(C'\fR would be described with the keyword \f(CW%nonassoc\fR in eyapp.
.PP
To solve a shift-reduce conflict between a production \f(CW\*(C`A \-\-> SOMETHING\*(C'\fR
and a token \f(CW\*(Aqa\*(Aq\fR you can follow this procedure:
.ie n .IP "1. Edit the "".output"" file" 4
.el .IP "1. Edit the \f(CW.output\fR file" 4
.IX Item "1. Edit the .output file"
.PD 0
.IP "2. Search for the state where the conflict between the production and the token is. In our example it looks like:" 4
.IX Item "2. Search for the state where the conflict between the production and the token is. In our example it looks like:"
.PD
.Vb 2
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq56,65p\*(Aq ambiguities.output
\& State 5:
\&
\&        exp \-> exp . \*(Aq\-\*(Aq exp    (Rule 2)
\&        exp \-> exp \*(Aq\-\*(Aq exp .    (Rule 2)
\&
\&        \*(Aq\-\*(Aq     shift, and go to state 3
\&
\&        \*(Aq\-\*(Aq     [reduce using rule 2 (exp)]
\&        $default        reduce using rule 2 (exp)
.Ve
.ie n .IP "3. Inside the state there has to be a production of the type ""A \-\-> SOMETHING."" (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form ""A \-\-> prefix . suffix"", where suffix can \fIstart\fR with the involved token \*(Aqa\*(Aq." 4
.el .IP "3. Inside the state there has to be a production of the type \f(CWA \-\-> SOMETHING.\fR (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form \f(CWA \-\-> prefix . suffix\fR, where suffix can \fIstart\fR with the involved token \f(CW\*(Aqa\*(Aq\fR." 4
.IX Item "3. Inside the state there has to be a production of the type A --> SOMETHING. (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form A --> prefix . suffix, where suffix can start with the involved token a."
.PD 0
.ie n .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want ""NUM \- NUM \- NUM"" to produce a tree like ""MINUS(MINUS(NUM, NUM), NUM)"" and not ""MINUS(NUM, MINUS(NUM, NUM))"". We want the conflict in ""exp \- exp.\- NUM"" to be solved in favor of the reduction by ""exp: exp \*(Aq\-\*(Aq exp"". This is achieved by declaring ""%left \*(Aq\-\*(Aq""." 4
.el .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want \f(CWNUM \- NUM \- NUM\fR to produce a tree like \f(CWMINUS(MINUS(NUM, NUM), NUM)\fR and not \f(CWMINUS(NUM, MINUS(NUM, NUM))\fR. We want the conflict in \f(CWexp \- exp.\- NUM\fR to be solved in favor of the reduction by \f(CWexp: exp \*(Aq\-\*(Aq exp\fR. This is achieved by declaring \f(CW%left \*(Aq\-\*(Aq\fR." 4
.IX Item "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want NUM - NUM - NUM to produce a tree like MINUS(MINUS(NUM, NUM), NUM) and not MINUS(NUM, MINUS(NUM, NUM)). We want the conflict in exp - exp.- NUM to be solved in favor of the reduction by exp: exp - exp. This is achieved by declaring %left -."
.PD
.SS "Error Recovery"
.IX Subsection "Error Recovery"
The token name \f(CW\*(C`error\*(C'\fR is reserved for error handling. This name can
be used in grammar productions; it suggests places where errors are
expected, and recovery can take place:
.PP
.Vb 8
\&     line:
\&       \*(Aq\en\*(Aq         { undef }
\&       | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\&       | error  \*(Aq\en\*(Aq
\&           {
\&             $_[0]\->YYErrok;
\&             undef
\&           }
.Ve
.PP
The parser pops its stack until
it enters a state where the token \f(CW\*(C`error\*(C'\fR is legal. It then shifts
the token \f(CW\*(C`error\*(C'\fR and proceeds to discard tokens until finding 
one that is acceptable. In the example
all the tokens until finding a \f(CW\*(Aq\en\*(Aq\fR will be skipped. 
If no special error productions have been specified,
the processing will halt.
.PP
In order to prevent a cascade of error messages, the parser, after
detecting an error, remains in error state until three tokens have been
successfully read and shifted. If an error is detected when the parser
is already in error state, no message is given, and the input token is
quietly deleted. The method \f(CW\*(C`YYErrok\*(C'\fR used in the example 
communicates to the parser
that a satisfactory recovery has been reached 
and that it can safely emit new error
messages.
.PP
You cannot have a literal \fI'error'\fR in your grammar as it would
confuse the driver with the \fIerror\fR token. Use a symbolic token instead.
.SH "THE TAIL"
.IX Header "THE TAIL"
The tail section contains Perl code. Usually it is empty, but you
can if you want put here your own lexical analyzer and 
error management subroutines.
An example of this is in
files \f(CW\*(C`examples/eyapplanguageref/List3_tree_d_sem.yp\*(C'\fR (the grammar)
and \f(CW\*(C`use_list3_tree_d_dem.pl\*(C'\fR (the client).
.SH "THE LEXICAL ANALYZER"
.IX Header "THE LEXICAL ANALYZER"
The Lexical Analyzer 
is called each time the parser needs a new token.
It is called with only one argument (the parser object)
and returns a pair 
containing the next token and its associated attribute.
.PP
The fact that is a method of the parser object means that the parser
methods are accessible inside the lexical analyzer.
.PP
When the lexical analyzer reaches the end of input, it must return the
pair \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
.SS "Automatic Generation of Lexical Analyzers"
.IX Subsection "Automatic Generation of Lexical Analyzers"
By default a lexical analyzer is built.
The \f(CW\*(C`eyapp\*(C'\fR option \f(CW\*(C`\-l\*(C'\fR
can be used to inhibit the generation of 
the default lexical analyzer. In such case,
one must be explictly provided.
.PP
\fINo token Definitions\fR
.IX Subsection "No token Definitions"
.PP
When no token definitions are given in the head section, 
the default lexical analyzer simply assumes
that the token is the string literal. See this example in 
file \f(CW\*(C`examples/lexergeneration/simple.yp\*(C'\fR:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat simple.yp
\&  %%
\&  A:    a
\&      | A d
\&  ;
\&  %%
.Ve
.PP
The grammar does not describes the lexical analyzer nor the error default subroutine.
Eyapp will generate default lexical and error subroutines:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-o simple.pl \-TC simple.yp
\&
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ls \-ltr | tail \-2
\&  \-rw\-r\-\-r\-\- 1 pl pl   27 2010\-06\-29 10:28 simple.yp
\&  \-rwxr\-xr\-x 1 pl pl 3245 2010\-06\-29 10:35 simple.pl
.Ve
.PP
The option \f(CW\*(C`\-T\*(C'\fR is equivalent to insert the \f(CW%tree\fR directive in the head section.
Since no names were explicitly given to the productions, the names of the productions are built using
the pattern \f(CW\*(C`Lhs_is_RHS\*(C'\fR.
.PP
Option \f(CW\*(C`\-C\*(C'\fR instructs the \f(CW\*(C`eyapp\*(C'\fR compiler to produce an executable by setting the execution permits
(see \f(CW\*(C`simple.pl\*(C'\fR permits above), inserting the appropriate she bang directive:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ head simple.pl | head \-1
\&  #!/usr/bin/perl
.Ve
.PP
and inserting a call to the package \f(CW\*(C`main\*(C'\fR subroutine at the end of the generated parser:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ tail \-6 simple.pl
\&  unless (caller) {
\&    exit !_\|_PACKAGE_\|_\->main(\*(Aq\*(Aq);
\&  }
.Ve
.PP
If no \f(CW\*(C`main\*(C'\fR was provided, \f(CW\*(C`eyapp\*(C'\fR will provide one.
.PP
Tokens \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`d\*(C'\fR are assumed to represent strings \f(CW\*(Aqa\*(Aq\fR
and \f(CW\*(Aqd\*(Aq\fR respectively.
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-i \-t \-c \*(Aqa d d\*(Aq
\&  A_is_A_d(A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d]),TERMINAL[d])
.Ve
.PP
The \f(CW\*(C`main\*(C'\fR method provided by \f(CW\*(C`eyapp\*(C'\fR accepts several options in the command line:
.IP "\(bu" 2
\&\f(CW\*(C`\-t\*(C'\fR Prints the abstract syntax tree
.IP "\(bu" 2
\&\f(CW\*(C`\-i\*(C'\fR Shows the semantic value associated with each terminal
.IP "\(bu" 2
\&\f(CW\*(C`\-c string\*(C'\fR Indicates that the input is given by the \f(CW\*(C`string\*(C'\fR that follows the option
.PP
You can get the set of available options using \f(CW\*(C`\-\-help\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-h
\&  Available options:
\&    \-\-debug                    sets yydebug on
\&    \-\-nodebug                  sets yydebug off
\&    \-\-file filepath            read input from filepath
\&    \-\-commandinput string      read input from string
\&    \-\-tree                     prints $tree\->str
\&    \-\-notree                   does not print $tree\->str
\&    \-\-info                     When printing $tree\->str shows the value of TERMINALs
\&    \-\-help                     shows this help
\&    \-\-slurp                    read until EOF reached
\&    \-\-noslurp                  read until CR is reached
\&    \-\-argfile                  main() will take the input string from its @_
\&    \-\-noargfile                main() will not take the input string from its @_
\&    \-\-yaml                     dumps YAML for $tree: YAML module must be installed
\&    \-\-margin=i                 controls the indentation of $tree\->str (i.e. $Parse::Eyapp::Node::INDENT)
.Ve
.PP
If we try to feed it with an illegal input, an error message is emitted:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-i \-t \-c \*(Aqa e d\*(Aq
\&  Error inside the lexical analyzer near \*(Aqe\*(Aq. Line: 1. File: \*(Aqsimple.yp\*(Aq. No match found.
.Ve
.PP
In the example above we have taken advantage of the \f(CW\*(C`main\*(C'\fR method provided by Eyapp.
If we want to keep in control of the parsing process, we can write a client program that 
makes use of the generated modulino:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n usesimple.pl
\&     1  #!/usr/bin/env perl
\&     2  use warnings;
\&     3  use strict;
\&     4
\&     5  use simple;
\&     6
\&     7  # build a parser object
\&     8  my $parser = simple\->new();
\&     9
\&    10  # take the input from the command line arguments
\&    11  # or from STDIN
\&    12  my $input = join \*(Aq \*(Aq,@ARGV;
\&    13  $input = <> unless $input;
\&    14
\&    15  # set the input
\&    16  $parser\->input($input);
\&    17
\&    18  # parse the input and get the AST
\&    19  my $tree = $parser\->YYParse();
\&    20
\&    21  print $tree\->str()."\en";
.Ve
.PP
Here is an example of execution:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-T simple.yp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimple.pl a d d
\&  A_is_A_d(A_is_A_d(A_is_a(TERMINAL),TERMINAL),TERMINAL)
.Ve
.PP
\fIToken Definitions: Regular Expressions\fR
.IX Subsection "Token Definitions: Regular Expressions"
.PP
Eyapp extends the \f(CW%token\fR directive with the syntax:
.PP
.Vb 1
\&     %token TOKENID = /regexp/
.Ve
.PP
If such definition is used, an entry with the shape:
.PP
.Vb 1
\&   /\eG$regexp/gc and return (\*(AqTOKENID\*(Aq, $1);
.Ve
.PP
will be added to the generated lexical analyzer.
Therefore the string associated with the first parenthesis in \f(CW\*(C`/regexp/\*(C'\fR
will be used as semantic value for \f(CW\*(C`TOKENID\*(C'\fR. If \f(CW\*(C`/regexp/\*(C'\fR has no
parenthesis \f(CW\*(C`undef\*(C'\fR will be the semantic value.
See this example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n numlist.eyp
\&     1  %token NUM = /(\ed+)/
\&     2  %token ID  = /(\ew+)/
\&     3
\&     4  %%
\&     5  A:
\&     6        B
\&     7      | A B
\&     8  ;
\&     9
\&    10  B:
\&    11        ID
\&    12      | a
\&    13      | NUM
\&    14  ;
\&    15  %%
.Ve
.PP
The order of the \f(CW%token\fR declarations is important. 
In the example the token \f(CW\*(C`NUM\*(C'\fR is a subset of the token \f(CW\*(C`ID\*(C'\fR.
Since it appears first, it will be tried first:
.PP
.Vb 2
\&     /\eG(\ed+)/gc and return (\*(AqNUM\*(Aq, $1);
\&     /\eG(\ew+)/gc and return (\*(AqID\*(Aq, $1);
.Ve
.PP
Also observe that token \f(CW\*(Aqa\*(Aq\fR (line 12) is contained
in token \f(CW\*(C`ID\*(C'\fR. However, any implicit token like this that appears in the
body section and was not 
declared using an explicit \f(CW%token\fR directive in the
head section takes priority over the ones declared.
See the behavior of the former program:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC numlist
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./numlist.pm \-t \-i \-c \*(Aq4 a b\*(Aq
\&  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
.Ve
.PP
The lexical analyzer returned \f(CW\*(C`NUM\*(C'\fR and not \f(CW\*(C`ID\*(C'\fR when \f(CW4\fR was processed,
also it returned \f(CW\*(C`a\*(C'\fR and not \f(CW\*(C`ID\*(C'\fR when \f(CW\*(Aqa\*(Aq\fR was 
processed.
.PP
A \f(CW%token\fR declaration without assignment like in:
.PP
.Vb 1
\&   %token A B
.Ve
.PP
is equivalent to
.PP
.Vb 2
\&  %token A   = /(A)/
\&  %token B   = /(B)/
.Ve
.PP
(in that order).
.PP
\fIToken Definitions via Code\fR
.IX Subsection "Token Definitions via Code"
.PP
An alternative way to define a token is via Perl code:
.PP
.Vb 1
\&      %token TOKENID = { ... }
.Ve
.PP
in such case the code defining \f(CW\*(C`TOKENID\*(C'\fR will be inserted
verbatim in the corresponding place of the generated lexical 
analyzer. When the code \f(CW\*(C`{ ... }\*(C'\fR
is executed, the variable \f(CW$_\fR 
contains the input being parsed and
the special variable \f(CW$self\fR refers to the parser object.
The following example is equivalent to the one used in the previous
section:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n tokensemdef.eyp
\&     1  %token NUM = /(\ed+)/
\&     2  %token ID  = { /\eG(\ew+)/gc and return (\*(AqID\*(Aq, $1); }
\&     3
\&     4  %%
\&     5  A:
\&     6        B
\&     7      | A B
\&     8  ;
\&     9
\&    10  B:
\&    11        ID
\&    12      | a
\&    13      | NUM
\&    14  ;
\&    15  %%
.Ve
.PP
Follows an example of compilation and execution:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC tokensemdef.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./tokensemdef.pm \-t \-i \-nos
\&  4 a b
\&  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
.Ve
.PP
\fIToken Definitions: Controling whites\fR
.IX Subsection "Token Definitions: Controling whites"
.PP
By default, the generated lexical analyzer skips 
white spaces, defined as \f(CW\*(C`/\es*/\*(C'\fR. The programmer
can change this behavior using the \f(CW%whites\fR directive.
The following example permits Perl-like comments 
in the input:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n simplewithwhites.eyp
\&     1  %whites  /(\es*(?:#.*)?\es*)/
\&     2  %%
\&     3  A:    a
\&     4      | A d
\&     5  ;
\&     6  %%
.Ve
.PP
Follows an example of execution:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-nA input
\&       1  a # 1$
\&       2  $
\&       3  d ^I#2$
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC simplewithwhites.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simplewithwhites.pm \-t \-i \-f input
\&  A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d])
.Ve
.PP
The \f(CW%white\fR directive can be followed by some Perl
code defining the white spaces:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n simplewithwhitescode.eyp
\&     1  %whites  { /\eG(\es*(?:#.*)?\es*)/gc and $self\->tokenline($1 =~ tr{\en}{}) }
\&     2  %%
\&     3  A:    a
\&     4      | A d
\&     5  ;
\&     6  %%
.Ve
.SS "Reading Input from File"
.IX Subsection "Reading Input from File"
You can use the method \f(CW\*(C`YYSlurpFile\*(C'\fR to read the input from a file
and set the input for the parser to its contents.
Yo can also use the \f(CW\*(C`YYInput\*(C'\fR method to set the input.
.PP
See the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n usesimplefromfile.pl
\&     1  #!/usr/bin/env perl
\&     2  use warnings;
\&     3  use strict;
\&     4
\&     5  use simplewithwhites;
\&     6
\&     7  my $parser = simplewithwhites\->new();
\&     8
\&     9  # take the input from the specified file
\&    10  my $fn = shift;
\&    11
\&    12  $parser\->YYSlurpFile($fn);
\&    13
\&    14  # parse the input and get the AST
\&    15  my $tree = $parser\->YYParse();
\&    16
\&    17  print $tree\->str()."\en";
.Ve
.PP
First, compile the grammar \f(CW\*(C`simplewithwhites.eyp\*(C'\fR presented above:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-T simplewithwhites
.Ve
.PP
And then run it:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n  input
\&     1  a # 1
\&     2
\&     3  d       #2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimplefromfile.pl input
\&  A_is_A_d(A_is_a(TERMINAL),TERMINAL)
.Ve
.SS "Huge input and Incremental Lexical Analyzers"
.IX Subsection "Huge input and Incremental Lexical Analyzers"
If your input is huge, try to make use of an incremental
lexical analyzer. In an incremental lexer the input
is read and parsed in chunks. Read up to a 
point where  it is safe to parse.
In the example below, the lexer reads a new line
each time we reach the end of the input string \f(CW\*(C`${$parser\->YYInput}\*(C'\fR.
In the case of the arithmetic expressions grammar below,
by reading up to \f(CW\*(Aq\en\*(Aq\fR, we are sure that the input is not
broken in the middle of a token.
Instead of having the whole huge input in memory,
we only keep a small substring.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n Incremental.eyp                    
\&     1  %right  \*(Aq=\*(Aq                                                                     
\&     2  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq                                                                 
\&     3  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq                                                                 
\&     4  %left   NEG                                                                     
\&     5                                                                                  
\&     6  %tree                                                                           
\&     7                                                                                  
\&     8  %%                                                                              
\&     9  input:                                                                          
\&    10          |   input $line  { print $line\->str."\en" }                              
\&    11  ;                                                                               
\&    12                                                                                  
\&    13  line:     \*(Aq\en\*(Aq                                                                  
\&    14          | exp \*(Aq\en\*(Aq
\&    15          | error \*(Aq\en\*(Aq
\&    16  ;
\&    17
\&    18  exp:        NUM
\&    19          |   VAR
\&    20          |   VAR \*(Aq=\*(Aq exp
\&    21          |   exp \*(Aq+\*(Aq exp
\&    22          |   exp \*(Aq\-\*(Aq exp
\&    23          |   exp \*(Aq*\*(Aq exp
\&    24          |   exp \*(Aq/\*(Aq exp
\&    25          |   \*(Aq\-\*(Aq exp %prec NEG
\&    26          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    27  ;
\&    28
\&    29  %%
\&    30
\&    31  sub _Lexer {
\&    32      my($parser)=shift;
\&    33
\&    34      if ($parser\->YYEndOfInput) {
\&    35        my $input = <STDIN>;
\&    36        return(\*(Aq\*(Aq, undef) unless $input;
\&    37        $parser\->input($input);
\&    38      };
\&    39
\&    40      for (${$parser\->YYInput}) {
\&    41          m/\eG[ \et]*/gc;
\&    42          m/\eG([0\-9]+(?:\e.[0\-9]+)?)/gc and return(\*(AqNUM\*(Aq,$1);
\&    43          m/\eG([A\-Za\-z][A\-Za\-z0\-9_]*)/gc and return(\*(AqVAR\*(Aq,$1);
\&    44          m/\eG(.)/gcs and return($1,$1);
\&    45          return(\*(Aq\*(Aq, undef);
\&    46      }
\&    47  }
\&    48
\&    49  _\|_PACKAGE_\|_\->lexer(\e&_Lexer);
.Ve
.PP
This approach has limitations. The code will get more tangled if some token
can take more than one line. For example, if we extend this language to accept 
C\-like comments \f(CW\*(C`/* ... */\*(C'\fR which expands over several lines.
.PP
Here follows an example of execution. 
This is the client program:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat useincremental.pl
\&  #!/usr/bin/perl \-w
\&  use Incremental;
\&
\&  Incremental\->new\->YYParse;
.Ve
.PP
This is a small test input file:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat inputforincremental
\&  a = 2
\&  a+3
\&  b=4
\&  b*2+a
.Ve
.PP
Finally, see the results of the execution:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./useincremental.pl < inputforincremental
\&  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
\&  line_4(exp_9(exp_7(TERMINAL),exp_6(TERMINAL)))
\&  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
\&  line_4(exp_9(exp_11(exp_7(TERMINAL),exp_6(TERMINAL)),exp_7(TERMINAL)))
.Ve
.PP
The numbers in the output refer to the production number:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-v Incremental.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ sed \-ne \*(Aq/Rules:/,/^$/p\*(Aq Incremental.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> input $end
\&  1:      input \-> /* empty */
\&  2:      input \-> input line
\&  3:      line \-> \*(Aq\en\*(Aq
\&  4:      line \-> exp \*(Aq\en\*(Aq
\&  5:      line \-> error \*(Aq\en\*(Aq
\&  6:      exp \-> NUM
\&  7:      exp \-> VAR
\&  8:      exp \-> VAR \*(Aq=\*(Aq exp
\&  9:      exp \-> exp \*(Aq+\*(Aq exp
\&  10:     exp \-> exp \*(Aq\-\*(Aq exp
\&  11:     exp \-> exp \*(Aq*\*(Aq exp
\&  12:     exp \-> exp \*(Aq/\*(Aq exp
\&  13:     exp \-> \*(Aq\-\*(Aq exp
\&  14:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.SS "Using Several Lexical Analyzers for the Same Parser"
.IX Subsection "Using Several Lexical Analyzers for the Same Parser"
At any time during the parsing you can use the method
\&\f(CW\*(C`$parser\->YYLexer\*(C'\fR to set a new lexical analyzer.
.PP
The following grammar starts setting the lexer
to  sub \f(CW\*(C`Lexer1\*(C'\fR (line 44). It later changes
the lexer to \f(CW\*(C`Lexer2\*(C'\fR (ine 24)
after the token \f(CW\*(Aq%%\*(Aq\fR is seen. 
Inside \f(CW\*(C`Lexer2\*(C'\fR the token \f(CW\*(C`A\*(C'\fR represents a \f(CW\*(AqB\*(Aq\fR.
This capability
allows the parsing of languages where different sections 
require different lexical analysis. For example, in \f(CW\*(C`yacc\*(C'\fR,
carriage returns separates declarations in the header 
section but is considered a white space inside the
body and tail sections. This feature has 
similar power to the \fIstate\fR concept of the
lexical analyzer generator \f(CW\*(C`flex\*(C'\fR.
.PP
.Vb 10
\&  $ cat \-n twolexers.eyp 
\&     1  %%
\&     2  s:  first \*(Aq%%\*(Aq second
\&     3  ;
\&     4  
\&     5  first:
\&     6      A first
\&     7    | A
\&     8  ;
\&     9  
\&    10  second:
\&    11      A second
\&    12    | A
\&    13  ;
\&    14  
\&    15  %%
\&    16  
\&    17  sub Lexer1 {
\&    18      my($parser)=shift;
\&    19  
\&    20      print "In Lexer 1 \en";
\&    21      for (${$parser\->YYInput}) {
\&    22          m/\eG\es*/gc;
\&    23          m/\eG(%%)/gc and do {
\&    24            $parser\->YYLexer(\e&Lexer2);
\&    25            return ($1, undef);
\&    26          };
\&    27          m/\eG(.)/gcs and return($1,$1);
\&    28          return(\*(Aq\*(Aq, undef);
\&    29      }
\&    30  }
\&    31  
\&    32  sub Lexer2 {
\&    33      my($parser)=shift;
\&    34  
\&    35      print "In Lexer 2 \en";
\&    36      for (${$parser\->YYInput}) {
\&    37          m/\eG\es*/gc;
\&    38          m/\eGB/gc    and return(\*(AqA\*(Aq,\*(AqB\*(Aq);
\&    39          m/\eG(.)/gcs and die "Error. Expected \*(AqB\*(Aq, found $1\en";
\&    40      }
\&    41          return(\*(Aq\*(Aq, undef);
\&    42  }
\&    43  
\&    44  _\|_PACKAGE_\|_\->lexer(\e&Lexer1);
.Ve
.PP
When executed, it behaves like this:
.PP
.Vb 7
\&        $ ./twolexers.pm \-t \-i \-m 1 \-c \*(AqA A %% B B\*(Aq
\&        In Lexer 1 
\&        In Lexer 1 
\&        In Lexer 1 
\&        In Lexer 2 
\&        In Lexer 2 
\&        In Lexer 2 
\&
\&        s_is_first_second(
\&          first_is_A_first(
\&            TERMINAL[A],
\&            first_is_A(
\&              TERMINAL[A]
\&            )
\&          ),
\&          second_is_A_second(
\&            TERMINAL[B],
\&            second_is_A(
\&              TERMINAL[B]
\&            )
\&          )
\&        )
.Ve
.PP
The lexer can bechanged at any time. The following example
starts using the default lexer generated by \f(CW\*(C`eyapp\*(C'\fR.
It changes the lexer to \f(CW\*(C`Lexer2\*(C'\fRinside an intermediate semantic action (line 7).
Inside \f(CW\*(C`Lexer2\*(C'\fR  the token \f(CW\*(C`A\*(C'\fR is interpreted as a word \f(CW\*(C`\ew+\*(C'\fR.
.PP
.Vb 10
\&   $ cat \-n twolexers2.eyp 
\&     1  # Compile it with:
\&     2  # $ eyapp \-TC twolexers2.eyp 
\&     3  # Run it with:
\&     4  # $ ./twolexers2.pm \-t \-i \-c \*(AqA A %% d3 c2\*(Aq
\&     5  
\&     6  %%
\&     7  s:  first \*(Aq%%\*(Aq { $_[0]\->YYLexer(\e&Lexer2) } second
\&     8  ;
\&     9  
\&    10  first:
\&    11      A first
\&    12    | A
\&    13  ;
\&    14  
\&    15  second:
\&    16      A second
\&    17    | A
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Lexer2 {
\&    23      my($parser)=shift;
\&    24  
\&    25      print "In Lexer 2 \en";
\&    26      for (${$parser\->YYInput}) {
\&    27          m/\eG\es*/gc;
\&    28          m/\eG(\ew+)/gc    and return(\*(AqA\*(Aq,$1);
\&    29          m/\eG(.)/gcs and die "Error. Expected a word,Found $1\en";
\&    30      }
\&    31      return(\*(Aq\*(Aq, undef);
\&    32  }
.Ve
.SH "THE ERROR REPORT SUBROUTINE"
.IX Header "THE ERROR REPORT SUBROUTINE"
The Error Report subroutine is also a parser attribute, 
and must be defined. By default \f(CW\*(C`Parse::Eyapp\*(C'\fR
provides a convenient error handler.
.PP
See the Parse::Yapp pages and elsewhere documentation
on \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`bison\*(C'\fR for more information.
.SH "USING AN EYAPP GRAMMAR"
.IX Header "USING AN EYAPP GRAMMAR"
The following is an example of a program that uses the calculator explained 
in the two previous sections:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n usecalc.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Calc;
\&     4
\&     5  my $parser = Calc\->new();
\&     6  $parser\->input(\e<<\*(AqEOI\*(Aq
\&     7  a = 2*3       # 1: 6
\&     8  d = 5/(a\-6)   # 2: division by zero
\&     9  b = (a+1)/7   # 3: 1
\&    10  c=a*3+4)\-5    # 4: syntax error
\&    11  a = a+1       # 5: 7
\&    12  EOI
\&    13  );
\&    14  my $t = $parser\->Run();
\&    15  print "========= Symbol Table ==============\en";
\&    16  print "$_ = $t\->{$_}\en" for sort keys %$t;
.Ve
.PP
The output for this program is (the input for each output
appear as a Perl comment on the right):
.PP
.Vb 1
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
\&
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./usecalc.pl
\&  6
\&  Illegal division by zero.
\&  1
\&
\&  Syntax error near \*(Aq)\*(Aq (line number 4).
\&  Expected one of these terminals: \*(Aq\-\*(Aq \*(Aq/\*(Aq \*(Aq^\*(Aq \*(Aq*\*(Aq \*(Aq+\*(Aq \*(Aq
\&  \*(Aq
\&  7
\&  ========= Symbol Table ==============
\&  a = 7
\&  b = 1
\&  c = 22
.Ve
.SH "LISTS AND OPTIONALS"
.IX Header "LISTS AND OPTIONALS"
The elements of the right hand side of a production (abbreviated \fIrhs\fR) can be one of these:
.PP
.Vb 9
\&  rhselt:     
\&        symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
.Ve
.PP
The \f(CW\*(C`STAR\*(C'\fR, \f(CW\*(C`OPTION\*(C'\fR and \f(CW\*(C`PLUS\*(C'\fR operators provide a simple mechanism
to express lists:
.IP "\(bu" 4
In Eyapp the \f(CW\*(C`+\*(C'\fR operator indicates one or more repetitions of the element
to the left of \f(CW\*(C`+\*(C'\fR, thus a rule like:
.Sp
.Vb 1
\&                        decls:  decl +
.Ve
.Sp
is the same as:
.Sp
.Vb 2
\&                        decls:  decls decl 
\&                             |  decl
.Ve
.Sp
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
.Sp
.Vb 1
\&                       rhss: rule <+ \*(Aq|\*(Aq>
.Ve
.Sp
is equivalent to:
.Sp
.Vb 2
\&                       rhss: rhss \*(Aq|\*(Aq rule 
\&                           | rule
.Ve
.IP "\(bu" 4
The operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR have their usual meaning: 0 or more for
\&\f(CW\*(C`*\*(C'\fR and optionality for \f(CW\*(C`?\*(C'\fR. Is legal to parenthesize 
a \f(CW\*(C`rhs\*(C'\fR expression as in:
.Sp
.Vb 1
\&                       optname: (NAME IDENT)?
.Ve
.ie n .SS "The ""+"" operator"
.el .SS "The \f(CW+\fP operator"
.IX Subsection "The + operator"
The grammar:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat List3.yp 
\&  %semantic token \*(Aqc\*(Aq 
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  \*(Aqd\*(Aq+ 
\&             { 
\&                print Dumper($_[1]);
\&                print Dumper($_[2]);
\&             } 
\&  ;
\&  %%
.Ve
.PP
Is equivalent to:
.PP
.Vb 9
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-v List3.yp; head \-9 List3.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:  $start \-> S $end
\&  1:  PLUS\-1 \-> PLUS\-1 \*(Aqc\*(Aq
\&  2:  PLUS\-1 \-> \*(Aqc\*(Aq
\&  3:  PLUS\-2 \-> PLUS\-2 \*(Aqd\*(Aq
\&  4:  PLUS\-2 \-> \*(Aqd\*(Aq
\&  5:  S \-> PLUS\-1 PLUS\-2
.Ve
.PP
By default, the semantic action associated with a \f(CW\*(C`+\*(C'\fR returns the lists of attributes
to which the \f(CW\*(C`+\*(C'\fR applies:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = [ \*(Aqc\*(Aq, \*(Aqc\*(Aq ];
\&  $VAR1 = [ \*(Aqd\*(Aq, \*(Aqd\*(Aq ];
.Ve
.PP
Observe that, in spite of \f(CW\*(Aqd\*(Aq\fR being a syntactic token
the actions related with the \f(CW\*(C`d+\*(C'\fR element (i.e. the actions associated
with the \f(CW\*(C`PLUS\-2\*(C'\fR productions) create the list of \f(CW\*(C`d\*(C'\fRs.
.PP
The semantic associated with a \f(CW\*(C`+\*(C'\fR changes 
when one of the tree creation directives is active (for instance \f(CW%tree\fR or \f(CW%metatree\fR)
or it has been explicitly requested with a call to the \f(CW\*(C`YYBuildingTree\*(C'\fR method:
.PP
.Vb 1
\&                            $self\->YYBuildingTree(1);
.Ve
.PP
Other ways to change the associated semantic are to use the 
\&\f(CW\*(C`yybuildingtree\*(C'\fR option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 4
\&         $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&                           yybuildingtree => 1,
\&                         # yydebug => 0x1F
\&         );
.Ve
.PP
In such case the associated semantic action creates a node labelled
.PP
.Vb 1
\&                     _PLUS_LIST
.Ve
.PP
whose children are the attributes associated with the items in the plus list. 
As it happens when using the \f(CW%tree\fR directive, \fIsyntactic tokens\fR are skipped.
.PP
When executing the example above but under the \f(CW%tree\fR directive
the output changes. The \f(CW\*(C`\-T\*(C'\fR option tells the \f(CW\*(C`eyapp\*(C'\fR compiler
to introduce an implicit \f(CW%tree\fR directive>:
.PP
.Vb 1
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-T List3.yp
.Ve
.PP
If we now run the client program with input \f(CW\*(C`ccdd\*(C'\fR we get
a couple of syntax trees:
.PP
.Vb 9
\&  ~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.PP
The node associated with the list of \f(CW\*(C`d\*(C'\fRs is empty since
terminal \f(CW\*(C`d\*(C'\fR wasn't declared semantic.
.SS "When Nodes Disappear from Lists"
.IX Subsection "When Nodes Disappear from Lists"
When under the influence of the \f(CW%tree\fR directive
the action associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes don't show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat ListWithRefs1.eyp 
\&  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  D+ 
\&             { 
\&                print Dumper($_[1]);
\&                print $_[1]\->str."\en";
\&                print Dumper($_[2]);
\&                print $_[2]\->str."\en";
\&             } 
\&  ;
\&
\&  D: \*(Aqd\*(Aq
\&  ;
\&
\&  %%
\&
\&  sub Run {
\&    my ($self) = shift;
\&    return $self\->YYParse( yybuildingtree => 1 );
\&  }
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR (line 26).
.PP
The execution gives an output like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs1.eyp; ./use_listwithrefs1.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  _PLUS_LIST(TERMINAL,TERMINAL)
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq ); _PLUS_LIST
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
associated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.SS "Recovering the Missing Nodes"
.IX Subsection "Recovering the Missing Nodes"
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs.eyp
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:  \*(Aqc\*(Aq+  D+ 
\&     8        { 
\&     9           print Dumper($_[1]);
\&    10           print Dumper($_[2]);
\&    11        } 
\&    12  ;
\&    13  
\&    14  D: \*(Aqd\*(Aq
\&    15       {
\&    16         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&    17       }
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Run {
\&    23    my ($self) = shift;
\&    24    return $self\->YYParse( yybuildingtree => 1 );
\&    25  }
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs.eyp; ./use_listwithrefs.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.ie n .SS "Building a Tree with ""Parse::Eyapp::Node\->new"""
.el .SS "Building a Tree with \f(CWParse::Eyapp::Node\->new\fP"
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
The following execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the just created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  ~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explicitly constructed:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs2.eyp 
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:      \*(Aqc\*(Aq+  D+ 
\&     8             { 
\&     9                print Dumper($_[1]);
\&    10                print $_[1]\->str."\en";
\&    11                print Dumper($_[2]);
\&    12                print $_[2]\->str."\en";
\&    13             } 
\&    14  ;
\&    15  
\&    16  D: \*(Aqd\*(Aq.d
\&    17       {
\&    18         Parse::Eyapp::Node\->new(
\&    19           \*(AqDES(TERMINAL)\*(Aq, 
\&    20            sub { 
\&    21              my ($DES, $TERMINAL) = @_;
\&    22              $TERMINAL\->{attr} = $d;
\&    23            }
\&    24         );
\&    25       }
\&    26  ;
\&    27  
\&    28  %%
\&    29  
\&    30  sub Run {
\&    31    my ($self) = shift;
\&    32    return $self\->YYParse( yybuildingtree => 1 );
\&    33  }
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the section for \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  $ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.ie n .SS "The ""*"" operator"
.el .SS "The \f(CW*\fP operator"
.IX Subsection "The * operator"
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obviated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been suppressed.
.SS "Giving Names to Lists"
.IX Subsection "Giving Names to Lists"
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The grammar describes the language of sequences
.PP
.Vb 1
\&                  c,...,cd c,...,cd c,...,cd ....
.Ve
.PP
The right hand side of the production has only one term which is a list, 
but the factor to which the star applies is itself a list. 
We are naming the term with the name \f(CW\*(C`Cs_and_d\*(C'\fR and the factor with 
the name \f(CW\*(C`Cs\*(C'\fR.
.PP
The execution shows the renamed nodes:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ use_csbetweencommansanddwithnames.pl
\&  c,c,c,cd
\&
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.SS "Optionals"
.IX Subsection "Optionals"
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an \f(CW\*(C`_OPTIONAL\*(C'\fR
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.SS "Parenthesis"
.IX Subsection "Parenthesis"
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the \f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explicitly created
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or reverse derivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.SS "Actions Inside Parenthesis"
.IX Subsection "Actions Inside Parenthesis"
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SH "NAMES FOR ATTRIBUTES"
.IX Header "NAMES FOR ATTRIBUTES"
Attributes can be referenced by meaningful names using the \fIdot notation\fR
instead of using the classic error-prone positional approach:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdollar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SH "DEFAULT ACTIONS"
.IX Header "DEFAULT ACTIONS"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.SS "An Example of Default Action: Translator from Infix to Postfix"
.IX Subsection "An Example of Default Action: Translator from Infix to Postfix"
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.ie n .SS "Default Actions, %name and ""YYName"""
.el .SS "Default Actions, \f(CW%name\fP and \f(CWYYName\fP"
.IX Subsection "Default Actions, %name and YYName"
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  $ sed \-n \*(Aq29,50p\*(Aq YYNameDynamic.eyp | cat \-n
\&     1  exp:
\&     2              NUM   { $_[1] }
\&     3          |   VAR   { $_[1] }
\&     4          |   %name ASSIGN
\&     5              VAR \*(Aq=\*(Aq exp
\&     6          |   %name PLUS
\&     7              exp \*(Aq+\*(Aq exp
\&     8          |   %name MINUS
\&     9              exp \*(Aq\-\*(Aq exp
\&    10                {
\&    11                  my $self = shift;
\&    12                  $self\->YYName(\*(AqSUBTRACT\*(Aq); # rename it
\&    13                  $self\->YYBuildAST(@_); # build the node
\&    14                }
\&    15          |   %name TIMES
\&    16              exp \*(Aq*\*(Aq exp
\&    17          |   %name DIV
\&    18              exp \*(Aq/\*(Aq exp
\&    19          |   %name UMINUS
\&    20              \*(Aq\-\*(Aq exp %prec NEG
\&    21          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    22  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBTRACT\*(Aq )
\&  ];
.Ve
.SH "GRAMMAR REUSE"
.IX Header "GRAMMAR REUSE"
.SS "Reusing Grammars Using Inheritance"
.IX Subsection "Reusing Grammars Using Inheritance"
An method to reuse a grammar is via inheritance. 
The client inherits the generated parser module and expands it 
with methods that inherit or overwrite the actions.
Here is an example. Initially we have this Eyapp grammar:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n NoacInh.eyp
\&     1  %left   \*(Aq+\*(Aq
\&     2  %left   \*(Aq*\*(Aq
\&     3
\&     4  %defaultaction {
\&     5    my $self = shift;
\&     6
\&     7    my $action = $self\->YYName;
\&     8
\&     9    $self\->$action(@_);
\&    10  }
\&    11
\&    12  %%
\&    13  exp:        %name NUM
\&    14                NUM
\&    15          |   %name PLUS
\&    16                exp \*(Aq+\*(Aq exp
\&    17          |   %name TIMES
\&    18                exp \*(Aq*\*(Aq exp
\&    19          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    20                { $_[2] }
\&    21  ;
\&    22
\&    23  %%
\&    24
\&    25  sub _Error {
\&    26    my($token)=$_[0]\->YYCurval;
\&    27    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    28    my @expected = $_[0]\->YYExpect();
\&    29
\&    30    local $" = \*(Aq, \*(Aq;
\&    31    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    32  }
\&    33
\&    34
\&    35  my $x = \*(Aq\*(Aq;
\&    36
\&    37  sub _Lexer {
\&    38    my($parser)=shift;
\&    39
\&    40    for ($x) {
\&    41      s/^\es+//;
\&    42      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    43
\&    44      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    45      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    46      s/^(.)//s                    and return($1,$1);
\&    47    }
\&    48  }
\&    49
\&    50  sub Run {
\&    51    my($self)=shift;
\&    52    $x = shift;
\&    53    my $debug = shift;
\&    54
\&    55    $self\->YYParse(
\&    56      yylex => \e&_Lexer,
\&    57      yyerror => \e&_Error,
\&    58      yydebug => $debug,
\&    59    );
\&    60  }
.Ve
.PP
The following program defines two classes: \f(CW\*(C`CalcActions\*(C'\fR
that implements the actions for the calculator
and package \f(CW\*(C`PostActions\*(C'\fR that implements the actions
for the infix to postfix translation. This way we have an 
example that reuses the former grammar twice:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n icalcu_and_ipost.pl
\&     1  #!/usr/bin/perl \-w
\&     2  package CalcActions;
\&     3  use strict;
\&     4  use base qw{NoacInh};
\&     5
\&     6  sub NUM {
\&     7    return $_[1];
\&     8  }
\&     9
\&    10  sub PLUS {
\&    11    $_[1]+$_[3];
\&    12  }
\&    13
\&    14  sub TIMES {
\&    15    $_[1]*$_[3];
\&    16  }
\&    17
\&    18  package PostActions;
\&    19  use strict;
\&    20  use base qw{NoacInh};
\&    21
\&    22  sub NUM {
\&    23    return $_[1];
\&    24  }
\&    25
\&    26  sub PLUS {
\&    27    "$_[1] $_[3] +";
\&    28  }
\&    29
\&    30  sub TIMES {
\&    31    "$_[1] $_[3] *";
\&    32  }
\&    33
\&    34  package main;
\&    35  use strict;
\&    36
\&    37  my $calcparser = CalcActions\->new();
\&    38  print "Write an expression: ";
\&    39  my $x = <STDIN>;
\&    40  my $e = $calcparser\->Run($x);
\&    41
\&    42  print "$e\en";
\&    43
\&    44  my $postparser = PostActions\->new();
\&    45  my $p = $postparser\->Run($x);
\&    46
\&    47  print "$p\en";
.Ve
.PP
The subroutine used as default action in \f(CW\*(C`NoacInh.eyp\*(C'\fR is so useful 
that is packed as the Parse::Eyapp::Driver method 
\&\f(CW\*(C`YYDelegateaction\*(C'\fR.
.PP
See files \f(CW\*(C`examples/recycle/NoacYYDelegateaction.eyp\*(C'\fR
and \f(CW\*(C`examples/recycle/icalcu_and_ipost_yydel.pl\*(C'\fR
for an example of use of \f(CW\*(C`YYDelegateaction\*(C'\fR.
.SS "Reusing Grammars by Dynamic Substitution of Semantic Actions"
.IX Subsection "Reusing Grammars by Dynamic Substitution of Semantic Actions"
The methods \f(CW\*(C`YYSetaction\*(C'\fR and \f(CW\*(C`YYAction\*(C'\fR of the parser object provide a way
to selectively substitute some actions of a given grammar.
Let us consider once more a postfix to infix translator:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n PostfixWithActions.eyp
\&     1  # File PostfixWithActions.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6
\&     7  %%
\&     8  line: $exp  { print "$exp\en" }
\&     9  ;
\&    10
\&    11  exp:        $NUM
\&    12                  { $NUM }
\&    13          |   $VAR
\&    14                  { $VAR }
\&    15          |   %name ASSIGN
\&    16                VAR.left \*(Aq=\*(Aqexp.right
\&    17                  { "$_[3] &$_[1] ASSIGN"; }
\&    18          |   %name PLUS
\&    19                exp.left \*(Aq+\*(Aqexp.right
\&    20                  { "$_[1] $_[3] PLUS"; }
\&    21          |   %name MINUS
\&    22                exp.left \*(Aq\-\*(Aqexp.right
\&    23                  { "$_[1] $_[3] MINUS"; }
\&    24          |   %name TIMES
\&    25                exp.left \*(Aq*\*(Aqexp.right
\&    26                  { "$_[1] $_[3] TIMES"; }
\&    27          |   %name DIV
\&    28                exp.left \*(Aq/\*(Aqexp.right
\&    29                  { "$_[1] $_[3] DIV"; }
\&    30          |   %name NEG \*(Aq\-\*(Aq $exp %prec NEG
\&    31                  { "$exp NEG" }
\&    32          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq
\&    33                  { $exp }
\&    34  ;
\&    35
\&    36  %%
\&    37
\&    38  sub _Error {
\&    39    my($token)=$_[0]\->YYCurval;
\&    40    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    41    my @expected = $_[0]\->YYExpect();
\&    42
\&    43    local $" = \*(Aq, \*(Aq;
\&    44    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    45  }
\&    46
\&    47  my $x;
\&    48
\&    49  sub _Lexer {
\&    50    my($parser)=shift;
\&    51
\&    52    for ($x) {
\&    53      s/^\es+//;
\&    54      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    55
\&    56      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    57      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    58      s/^(.)//s                    and return($1,$1);
\&    59    }
\&    60  }
\&    61
\&    62  sub Run {
\&    63    my($self)=shift;
\&    64    $x = shift;
\&    65    $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    66      #yydebug => 0xFF
\&    67    );
\&    68  }
.Ve
.PP
The program \f(CW\*(C`rewritepostfixwithactions.pl\*(C'\fR uses the former grammar
to translate infix expressions to postfix expressions.
It also implements a calculator reusing the grammar in
\&\f(CW\*(C`PostfixWithActions.eyp\*(C'\fR. It does so using
the \f(CW\*(C`YYSetaction\*(C'\fR method.
The semantic actions for the productions named
.IP "\(bu" 2
\&\s-1ASSIGN\s0
.IP "\(bu" 2
\&\s-1PLUS\s0
.IP "\(bu" 2
\&\s-1TIMES\s0
.IP "\(bu" 2
\&\s-1DIV\s0
.IP "\(bu" 2
\&\s-1NEG\s0
.PP
are selectively substituted by the appropriate actions, while the other
semantic actions remain unchanged:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n rewritepostfixwithactions.pl
\&     1  #!/usr/bin/perl
\&     2  use warnings;
\&     3  use PostfixWithActions;
\&     4
\&     5  my $debug = shift || 0;
\&     6  my $pparser = PostfixWithActions\->new();
\&     7  print "Write an expression: ";
\&     8  my $x = <STDIN>;
\&     9
\&    10  # First, trasnlate to postfix ...
\&    11  $pparser\->Run($x, $debug);
\&    12
\&    13  # And then selectively substitute
\&    14  # some semantic actions
\&    15  # to obtain an infix calculator ...
\&    16  my %s;            # symbol table
\&    17  $pparser\->YYSetaction(
\&    18    ASSIGN => sub { $s{$_[1]} = $_[3] },
\&    19    PLUS   => sub { $_[1] + $_[3] },
\&    20    TIMES  => sub { $_[1] * $_[3] },
\&    21    DIV    => sub { $_[1] / $_[3] },
\&    22    NEG    => sub { \-$_[2] },
\&    23  );
\&    24
\&    25  $pparser\->Run($x, $debug);
.Ve
.PP
When running this program the output is:
.PP
.Vb 8
\&  examples/recycle$ ./rewritepostfixwithactions.pl
\&  Write an expression: 2*3+4
\&  2 3 TIMES 4 PLUS
\&  10
\&  examples/recycle$ rewritepostfixwithactions.pl
\&  Write an expression: a = 2*(b = 3+5)
\&  2 3 5 PLUS &b ASSIGN TIMES &a ASSIGN
\&  16
.Ve
.ie n .SH "ABSTRACT SYNTAX TREES: %tree AND %name"
.el .SH "ABSTRACT SYNTAX TREES: \f(CW%tree\fP AND \f(CW%name\fP"
.IX Header "ABSTRACT SYNTAX TREES: %tree AND %name"
.ie n .SS "%tree Default Names"
.el .SS "\f(CW%tree\fP Default Names"
.IX Subsection "%tree Default Names"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. Actually, the \f(CW%tree\fR directive is equivalent to a call
to the \f(CW\*(C`YYBuildAST\*(C'\fR method of the parser object.
.PP
Any production production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
can be named using a directive \f(CW\*(C`%name someclass\*(C'\fR.
.PP
When reducing by a production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
the \f(CW%tree\fR directive (i.e., the \f(CW\*(C`YYBuildAST\*(C'\fR method) 
builds an anonymous hash blessed in \f(CW\*(C`someclass\*(C'\fR.
The hash has an attribute \f(CW\*(C`children\*(C'\fR containing the references
to the \s-1AST\s0 trees associated with the symbols in the right hand
side \f(CW\*(C`X\*(C'\fR, C>Y>, etc.
.PP
If no explicit name was given to the production rule,
\&\f(CW\*(C`YYBuildAST\*(C'\fR blesses the node in the class name resulting 
from the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,27p\*(Aq treewithoutnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&         NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&      | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
\&
\&    %%
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ ./treewithoutnames.pl
\&
\&  ************
\&  _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
\&  ************
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR setting the \f(CW\*(C`outputfile\*(C'\fR
of \f(CW\*(C`Parse::Eyapp\*(C'\fR:
.PP
.Vb 6
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>9,      # String $grammar starts at line 9 (for error diagnostics)
\&    outputfile=>\*(Aqtreewithoutnames\*(Aq
\&  );
.Ve
.PP
The grammar with the expanded rules appears in the \f(CW\*(C`.output\*(C'\fR file:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> line $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&  2:      PLUS\-1 \-> exp
\&  3:      line \-> PLUS\-1
\&  4:      exp \-> NUM
\&  5:      exp \-> VAR
\&  6:      exp \-> VAR \*(Aq=\*(Aq exp
\&  7:      exp \-> exp \*(Aq+\*(Aq exp
\&  8:      exp \-> exp \*(Aq\-\*(Aq exp
\&  9:      exp \-> exp \*(Aq*\*(Aq exp
\&  10:     exp \-> exp \*(Aq/\*(Aq exp
\&  11:     exp \-> \*(Aq\-\*(Aq exp
\&  12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.ie n .SS "%tree Giving Explicit Names"
.el .SS "\f(CW%tree\fP Giving Explicit Names"
.IX Subsection "%tree Giving Explicit Names"
A production rule can be \fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive.  For
each production rule a namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR 
\&\fIis the name of the associated package\fR.  Therefore, by modifying the former
grammar with additional \f(CW%name\fR directives:
.PP
.Vb 7
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&        %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&      | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&      | %name DIV    exp \*(Aq/\*(Aq exp
\&      | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
.Ve
.PP
we are explicitly naming the productions. Thus, all the node instances 
corresponding to the production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. 
Now the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ ./treewithnames.pl
\&
\&  ************
\&  EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
\&  ************
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.SS "\s-1TERMINAL\s0 Nodes"
.IX Subsection "TERMINAL Nodes"
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the tokens provided by the lexical
analyzer.  \f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol than Parse::Yapp for
communication between the parser and the lexical analyzer: A couple \f(CW\*(C`($token,
$attribute)\*(C'\fR is returned by the lexical analyzer.  These values are stored
under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.  \f(CW\*(C`TERMINAL\*(C'\fR nodes as all
\&\f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost
always \- empty.
.ie n .SS "Explicit Actions Inside %tree"
.el .SS "Explicit Actions Inside \f(CW%tree\fP"
.IX Subsection "Explicit Actions Inside %tree"
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.ie n .SS "Explicitly Building Nodes With ""YYBuildAST"""
.el .SS "Explicitly Building Nodes With \f(CWYYBuildAST\fP"
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation (see
file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
inside \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-n \*(Aq397,408p\*(Aq lib/Simple/Types.eyp
\&  Variable:
\&      %name VAR
\&      ID
\&    | %name  VARARRAY
\&      $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&        {
\&          my $self = shift;
\&          my $node =  $self\->YYBuildAST(@_);
\&          $node\->{line} = $ID\->[1];# $_[1]\->[1]
\&          return $node;
\&        }
\&  ;
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.ie n .SS "Returning non References Under %tree"
.el .SS "Returning non References Under \f(CW%tree\fP"
.IX Subsection "Returning non References Under %tree"
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to suppress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,17p\*(Aq returnnonode.yp | cat \-n
\&     1  %tree
\&     2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     3  %%
\&     4  S:    %name EMPTY
\&     5          /* empty */
\&     6      | %name AES
\&     7          S A
\&     8      | %name BES
\&     9          S B
\&    10  ;
\&    11  A : %name A
\&    12        \*(Aqa\*(Aq
\&    13  ;
\&    14  B : %name B
\&    15        \*(Aqb\*(Aq { }
\&    16  ;
\&    17  %%
.Ve
.PP
since the action at line 15 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\&  $ usereturnnonode.pl
\&  ababa
\&  AES(BES(AES(BES(AES(EMPTY,A(TERMINAL[a]))),A(TERMINAL[a]))),A(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.ie n .SS "Intermediate actions and %tree"
.el .SS "Intermediate actions and \f(CW%tree\fP"
.IX Subsection "Intermediate actions and %tree"
Intermediate actions can be used to change the shape of the \s-1AST\s0 (prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,15p\*(Aq intermediateactiontree.yp | cat \-n
\&     1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     2  %tree bypass
\&     3  %%
\&     4  S:    %name EMPTY
\&     5         /* empty */
\&     6      | %name SA
\&     7         S A.f { $f\->{attr} = "A"; $f; } A
\&     8      | %name SB
\&     9         S B.f { $f\->{attr} = "B"; $f; } B
\&    10  ;
\&    11  A : %name A \*(Aqa\*(Aq
\&    12  ;
\&    13  B : %name B \*(Aqb\*(Aq
\&    14  ;
\&    15  %%
.Ve
.PP
See the client program:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
.Ve
.PP
When it runs produces this output:
.PP
.Vb 3
\&  $ useintermediateactiontree.pl
\&  aabbaa
\&  SA(SB(SA(EMPTY,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.SS "Syntactic and Semantic tokens"
.IX Subsection "Syntactic and Semantic tokens"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR differences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the section Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 10
\&  $ cat \-n synopsis.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Parse::Eyapp::Treeregexp;
\&     5
\&     6  sub TERMINAL::info {
\&     7    $_[0]{attr}
\&     8  }
\&     9
\&    10  my $grammar = q{
\&    11    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    12    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    13    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    14    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    15    %tree           # Let us build an abstract syntax tree ...
\&    16
\&    17    %%
\&    18    line:
\&    19        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&    20          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    21    ;
\&    22
\&    23    /* The %name directive defines the name of the class */
\&    24    exp:
\&    25        %name NUM
\&    26        NUM
\&    27      | %name VAR
\&    28        VAR
\&    29      | %name ASSIGN
\&    30        VAR \*(Aq=\*(Aq exp
\&    31      | %name PLUS
\&    32        exp \*(Aq+\*(Aq exp
\&    33      | %name MINUS
\&    34        exp \*(Aq\-\*(Aq exp
\&    35      | %name TIMES
\&    36        exp \*(Aq*\*(Aq exp
\&    37      | %name DIV
\&    38        exp \*(Aq/\*(Aq exp
\&    39      | %name UMINUS
\&    40        \*(Aq\-\*(Aq exp %prec NEG
\&    41      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    42          { $_[2] }  /* Let us simplify a bit the tree */
\&    43    ;
\&    44
\&    45    %%
\&    46    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&    47
\&    48    sub _Lexer {
\&    49      my($parser)=shift; # The parser object
\&    50
\&    51      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&    52        m{\eG\es+}gc;
\&    53        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    54        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&    55        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&    56        m{\eG(.)}gcs and return($1,$1);
\&    57      }
\&    58      return(\*(Aq\*(Aq,undef);
\&    59    }
\&    60
\&    61    sub Run {
\&    62        my($self)=shift;
\&    63        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    64    }
\&    65  }; # end grammar
\&    66
\&    67  our (@all, $uminus);
\&    68
\&    69  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    70    input=>$grammar,
\&    71    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    72    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&    73  );
\&    74  my $parser = Calc\->new();                # Create a parser
\&    75  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&    76  my $t = $parser\->Run;                    # Parse it!
\&    77  local $Parse::Eyapp::Node::INDENT=2;
\&    78  print "Syntax Tree:",$t\->str;
\&    79
\&    80  # Let us transform the tree. Define the tree\-regular expressions ..
\&    81  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    82      { #  Example of support code
\&    83        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&    84      }
\&    85      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&    86        => {
\&    87          my $op = $Op{ref($bin)};
\&    88          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&    89          $_[0] = $NUM[0];
\&    90        }
\&    91      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&    92      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    93      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    94    },
\&    95    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&    96  );
\&    97  $p\->generate(); # Create the tranformations
\&    98
\&    99  $t\->s($uminus); # Transform UMINUS nodes
\&   100  $t\->s(@all);    # constant folding and mult. by zero
\&   101
\&   102  local $Parse::Eyapp::Node::INDENT=0;
\&   103  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESSION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESSION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifier, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST\s0.
.SS "Changing the Status of a Token"
.IX Subsection "Changing the Status of a Token"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.SS "Saving the Information of Syntactic Tokens in their Father"
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR
in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.ie n .SS "The  ""bypass"" clause and the ""%no bypass"" directive"
.el .SS "The  \f(CWbypass\fP clause and the \f(CW%no bypass\fP directive"
.IX Subsection "The  bypass clause and the %no bypass directive"
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \s-1SYNOPSIS\s0 example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.ie n .SS "The ""alias"" clause of the %tree directive"
.el .SS "The \f(CWalias\fP clause of the \f(CW%tree\fP directive"
.IX Subsection "The alias clause of the %tree directive"
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dollar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods will provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
The \f(CW%prefix\fR directive used in line 7 of the following example
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix: \f(CW\*(C`R::S::\*(C'\fR in this example.
.PP
.Vb 10
\& cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    ..    ....
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
The tree \f(CW$t\fR for the expression \f(CW"a = \-(2*3+5\-1)\en"\fR is:
.PP
.Vb 9
\&  R::S::ASSIGN(
\&     R::S::TERMINAL,
\&     R::S::UMINUS(
\&       R::S::MINUS(
\&         R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM),
\&         R::S::NUM
\&       )
\&     )
\&  )
.Ve
.PP
The \f(CW\*(C`R::S::ASSIGN\*(C'\fR class has methods \f(CW\*(C`VAR\*(C'\fR (see line 89 above)
and \f(CW\*(C`exp\*(C'\fR (see lines 91 and 93) to refer to its two children. 
The result of the execution is:
.PP
.Vb 6
\&  $ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.PP
As a second example of the use of \f(CW%alias\fR, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST\s0.
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
\&
\& CalcwithAttributeGrammar.pl
.Ve
.PP
The program computes the tree for expression for expression
\&\f(CW\*(C`a = \-(2*3+5\-1)\*(C'\fR which is:
.PP
.Vb 1
\&  ASSIGN(TERMINAL,UMINUS(MINUS(PLUS(TIMES(NUM,NUM),NUM),NUM)))
.Ve
.PP
The children of the binary nodes can be accessed through the \f(CW\*(C`left\*(C'\fR
and \f(CW\*(C`right\*(C'\fR methods.
.SS "About the Encapsulation of Nodes"
.IX Subsection "About the Encapsulation of Nodes"
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
.SH "SOLVING CONFLICTS WITH THE \fIPOSTPONED CONFLICT\fP STRATEGY"
.IX Header "SOLVING CONFLICTS WITH THE POSTPONED CONFLICT STRATEGY"
Yacc-like parser generators provide ways to solve shift-reduce mechanims
based on token precedence. No mechanisms are provided for the resolution
of reduce-reduce conflicts. The solution for such kind of conflicts is to modify
the grammar. The strategy We present here provides a way to broach conflicts
that can't be solved using static precedences.
.SS "The \fIPostponed Conflict Resolution\fP Strategy"
.IX Subsection "The Postponed Conflict Resolution Strategy"
The \fIpostponed conflict strategy\fR presented here can be used whenever there 
is a shift-reduce or reduce-reduce conflict that can not be solved using static 
precedences.
.SS "\fIPostponed Conflict Resolution\fP: Reduce-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Reduce-Reduce Conflicts"
Let us assume we have a reduce-reduce conflict between to productions
.PP
.Vb 2
\&                      A \-> alpha .
\&                      B \-> beta .
.Ve
.PP
for some token \f(CW\*(C`@\*(C'\fR. Let also assume that production
.PP
.Vb 1
\&                      A \-> alpha
.Ve
.PP
has name \f(CW\*(C`ruleA\*(C'\fR and production
.PP
.Vb 1
\&                      B \-> beta
.Ve
.PP
has name \f(CW\*(C`ruleB\*(C'\fR.
.PP
The postponed conflict resolution strategy consists
in modifying the conflictive grammar by marking the points where the  conflict occurs
with the new \f(CW%PREC\fR directive. In this case at then end of the involved productions:
.PP
.Vb 2
\&                      A \-> alpha %PREC IsAorB 
\&                      B \-> beta  $PREC IsAorB
.Ve
.PP
The \f(CW\*(C`IsAorB\*(C'\fR identifier is called the \fIconflict name\fR.
.PP
Inside the head section, the programmer associates with the 
conflict name a code
whose mission is to solve the conflict by dynamically changing the
parsing table like this:
.PP
.Vb 2
\&                     %conflict IsAorB {
\&                          my $self = shift;
\&
\&                          if (looks_like_A($self)) {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleA\*(Aq );
\&                          }
\&                          else {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleB\*(Aq );
\&                          }
\&                       }
.Ve
.PP
The code associated with the \fIconflict name\fR
receives the name of \fI conflict handler\fR.
The code of \f(CW\*(C`looks_like_A\*(C'\fR stands for some form of nested parsing
which will decide which production applies.
.SS "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
.IX Subsection "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
In file \f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR we apply the postponed conflict resolution strategy
to the reduce reduce conflict that arises in Extended Pascal between the declaration of ranges and
the declaration of enumerated types (see section \*(L"Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal\*(R").
Here is the solution:
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ cat \-n pascalenumeratedvsrangesolvedviadyn.eyp
\&     1  %{
\&     2  =head1 SYNOPSIS
\&     3  
\&     4  See 
\&     5  
\&     6  =over 2
\&     7  
\&     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
\&     9  
\&    10  =item * The Bison manual L<http://www.gnu.org/software/bison/manual/html_mono/bison.html>
\&    11  
\&    12  =back
\&    13  
\&    14  Compile it with:
\&    15  
\&    16              eyapp \-b \*(Aq\*(Aq pascalenumeratedvsrangesolvedviadyn.eyp
\&    17  
\&    18  run it with this options:
\&    19  
\&    20              ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&    21  
\&    22  Try these inputs:
\&    23  
\&    24                  type r = (x) ..  y ;
\&    25                  type r = (x+2)*3 ..  y/2 ;
\&    26                  type e = (x, y, z);
\&    27                  type e = (x);
\&    28  
\&    29  =cut
\&    30  
\&    31  use base q{DebugTail}; 
\&    32  
\&    33  my $ID = qr{[A\-Za\-z][A\-Za\-z0\-9_]*};
\&    34               # Identifiers separated by commas
\&    35  my $IDLIST = qr{ \es*(?:\es*,\es* $ID)* \es* }x;
\&    36               # list followed by a closing par and a semicolon 
\&    37  my $RESTOFLIST = qr{$IDLIST \e) \es* ; }x;
\&    38  %}
\&    39  
\&    40  %namingscheme {
\&    41    #Receives a Parse::Eyapp object describing the grammar
\&    42    my $self = shift;
\&    43  
\&    44    $self\->tokennames(
\&    45      \*(Aq(\*(Aq => \*(AqLP\*(Aq,
\&    46      \*(Aq..\*(Aq => \*(AqDOTDOT\*(Aq,
\&    47      \*(Aq,\*(Aq => \*(AqCOMMA\*(Aq,
\&    48      \*(Aq)\*(Aq => \*(AqRP\*(Aq,
\&    49      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    50      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    51      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    52      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    53    );
\&    54  
\&    55    # returns the handler that will give names
\&    56    # to the right hand sides
\&    57    \e&give_rhs_name;
\&    58  }
\&    59  
\&    60  %strict
\&    61  
\&    62  %token ID NUM DOTDOT TYPE
\&    63  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    64  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    65  
\&    66  %tree
\&    67  
\&    68  %%
\&    69  
\&    70  type_decl : TYPE ID \*(Aq=\*(Aq type \*(Aq;\*(Aq
\&    71  ;
\&    72  
\&    73  type : 
\&    74        %name ENUM
\&    75        \*(Aq(\*(Aq id_list \*(Aq)\*(Aq
\&    76      | %name RANGE
\&    77        expr DOTDOT expr
\&    78  ;
\&    79  
\&    80  id_list : 
\&    81        %name EnumID
\&    82        ID rangeORenum
\&    83      | id_list \*(Aq,\*(Aq ID
\&    84  ;
\&    85  
\&    86  expr : \*(Aq(\*(Aq expr \*(Aq)\*(Aq
\&    87      | expr \*(Aq+\*(Aq expr
\&    88      | expr \*(Aq\-\*(Aq expr
\&    89      | expr \*(Aq*\*(Aq expr
\&    90      | expr \*(Aq/\*(Aq expr
\&    91      | %name RangeID
\&    92        ID rangeORenum
\&    93      | NUM
\&    94  ;
\&    95  
\&    96  rangeORenum: /* empty: postponed conflict resolution */
\&    97        {
\&    98            my $parser = shift;
\&    99            if (${$parser\->input()} =~ m{\eG(?= $RESTOFLIST)}gcx) {
\&   100                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqEnumID\*(Aq );
\&   101              }
\&   102              else {
\&   103                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqRangeID\*(Aq );
\&   104              }
\&   105        }
\&   106  ;
\&   107  
\&   108  %%
\&   109  
\&   110  _\|_PACKAGE_\|_\->lexer(
\&   111    sub {
\&   112      my $parser = shift;
\&   113  
\&   114      for (${$parser\->input()}) {    # contextualize
\&   115        m{\eG(\es*)}gc;
\&   116        $parser\->tokenline($1 =~ tr{\en}{});
\&   117  
\&   118        m{\eGtype\eb}gic                 and return (\*(AqTYPE\*(Aq, \*(AqTYPE\*(Aq);
\&   119  
\&   120        m{\eG($ID)}gc                   and return (\*(AqID\*(Aq,  $1);
\&   121  
\&   122        m{\eG([0\-9]+)}gc                and return (\*(AqNUM\*(Aq, $1);
\&   123  
\&   124        m{\eG\e.\e.}gc                    and return (\*(AqDOTDOT\*(Aq,  \*(Aq..\*(Aq);
\&   125  
\&   126        m{\eG(.)}gc                     and return ($1,    $1);
\&   127  
\&   128        return(\*(Aq\*(Aq,undef);
\&   129      }
\&   130    }
\&   131  );
\&   132  
\&   133  unless (caller()) {
\&   134    $Parse::Eyapp::Node::INDENT = 1;
\&   135    my $prompt = << \*(AqEOP\*(Aq;
\&   136  Try this input:
\&   137      type 
\&   138      r
\&   139      =
\&   140      (x)
\&   141      ..
\&   142      y
\&   143      ;
\&   144  
\&   145  Here other inputs you can try:
\&   146  
\&   147      type r = (x+2)*3 ..  y/2 ;
\&   148      type e = (x, y, z);
\&   149      type e = (x);
\&   150  
\&   151  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&   152  EOP
\&   153    _\|_PACKAGE_\|_\->main($prompt); 
\&   154  }
.Ve
.PP
This example also illustrates how to modify the default production
naming schema. Follows the result of several executions:
.PP
.Vb 9
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type r = (x+2)*3 ..  y/2 ;
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[r],
\&    RANGE(
\&      expr_is_expr_TIMES_expr(
\&        expr_is_LP_expr_RP(
\&          expr_is_expr_PLUS_expr(
\&            RangeID(
\&              TERMINAL[x]
\&            ),
\&            expr_is_NUM(
\&              TERMINAL[2]
\&            )
\&          )
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[3]
\&        )
\&      ),
\&      TERMINAL[..],
\&      expr_is_expr_DIV_expr(
\&        RangeID(
\&          TERMINAL[y]
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[2]
\&        )
\&      )
\&    )
\&  )
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type e = (x);
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[e],
\&    ENUM(
\&      EnumID(
\&        TERMINAL[x]
\&      )
\&    )
\&  )
.Ve
.SS "\fIPostponed Conflict Resolution\fP: Shift-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Shift-Reduce Conflicts"
The program in \f(CW\*(C`examples/debuggingtut/DynamicallyChangingTheParser2.eyp\*(C'\fR illustrates how the postponed
conflict strategy is used for shift-reduce conflicts.
This is an extension of the grammar in \f(CW\*(C`examples/debuggingtut/Debug.eyp\*(C'\fR.
The generated language is constituted by sequences like:
.PP
.Vb 1
\&    { D; D; S; S; S; } {D; S} { S }
.Ve
.PP
As you remember the conflict was:
.PP
.Vb 2
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/^St.*13:/,/^St.*14/p\*(Aq DynamicallyChangingTheParser.output  
\&  State 13:
\&
\&      ds \-> D conflict . \*(Aq;\*(Aq ds   (Rule 6)
\&      ds \-> D conflict .  (Rule 7)
\&
\&      \*(Aq;\*(Aq shift, and go to state 16
\&
\&      \*(Aq;\*(Aq [reduce using rule 7 (ds)]
\&
\&  State 14:
.Ve
.PP
The \f(CW\*(C`conflict\*(C'\fR handler below sets the \s-1LR\s0 action
to reduce by the production with name \f(CW\*(C`D1\*(C'\fR
.PP
.Vb 1
\&                 ds \-> D
.Ve
.PP
in the presence of token \f(CW\*(Aq;\*(Aq\fR if indeed is the last \f(CW\*(AqD\*(Aq\fR, that is, if:
.PP
.Vb 1
\&       ${$self\->input()} =~ m{^\es*;\es*S}
.Ve
.PP
Otherwise we set the \f(CW\*(C`shift\*(C'\fR action via a call to the 
\&\f(CW\*(C`YYSetShift\*(C'\fR method.
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq30,$p\*(Aq DynamicallyChangingTheParser.eyp | cat \-n
\&     1  %token D S
\&     2  
\&     3  %tree bypass
\&     4  
\&     5  # Expect just 1 shift\-reduce conflict
\&     6  %expect 1 
\&     7  
\&     8  %%
\&     9  p: %name PROG
\&    10      block +
\&    11  ;
\&    12  
\&    13  block:
\&    14      %name BLOCK_DS
\&    15      \*(Aq{\*(Aq ds \*(Aq;\*(Aq ss \*(Aq}\*(Aq 
\&    16    | %name BLOCK_S
\&    17      \*(Aq{\*(Aq ss \*(Aq}\*(Aq
\&    18  ;
\&    19  
\&    20  ds:
\&    21      %name D2
\&    22      D conflict \*(Aq;\*(Aq ds    
\&    23    | %name D1
\&    24      D conflict        
\&    25  ;
\&    26  
\&    27  ss:
\&    28      %name S2
\&    29      S \*(Aq;\*(Aq ss      
\&    30    | %name S1
\&    31      S       
\&    32  ;
\&    33  
\&    34  conflict:
\&    35        /* empty. This action solves the conflict using dynamic precedence */
\&    36        {
\&    37          my $self = shift;
\&    38  
\&    39          if (${$self\->input()} =~ m{^\es*;\es*S}) {
\&    40            $self\->YYSetReduce(\*(Aq;\*(Aq, \*(AqD1\*(Aq )
\&    41          }
\&    42          else {
\&    43            $self\->YYSetShift(\*(Aq;\*(Aq)
\&    44          }
\&    45  
\&    46          undef; # skip this node in the AST
\&    47        }
\&    48  ;
\&    49  
\&    50  %%
\&    51  
\&    52  my $prompt = \*(AqProvide a statement like "{D; S} {D; D; S}" and press <CR><CTRL\-D>: \*(Aq;
\&    53  _\|_PACKAGE_\|_\->main($prompt) unless caller;
.Ve
.SH "NAMING SCHEMES"
.IX Header "NAMING SCHEMES"
Explicit names can be given to grammar productions
via the \f(CW%name\fR directive. An alternative to explicitly gave 
names to rules is to define a \fInaming scheme\fR via the Eyapp directive
\&\f(CW%namingscheme\fR. This can be helpful when you inherit a large grammar
and want to quickly build a parser. The \s-1ANSI\s0 C parser in 
\&\f(CW\*(C`examples/languages/C/ansic.eyp\*(C'\fR is a good example. Another
example is the Pascal parser in \f(CW\*(C`examples/languages/pascal/pascal.eyp\*(C'\fR.
.PP
The Eyapp directive \f(CW%namingscheme\fR is followed by some Perl code. Such Perl
code must return a reference to a subroutine that will be called each time a new
production right hand side is parsed. The subroutine returns the name for the production.
.PP
The Perl code defining the handler receives a \f(CW\*(C`Parse::Eyapp\*(C'\fR object
that describes the grammar. The code after the \f(CW%namingscheme\fR
directive is evaluated during the early phases of the compilation of the input 
grammar. As an example of how to set a naming scheme, 
see lines 22\-38 below (you can find this example and others in the directory
\&\f(CW\*(C`examples/naming\*(C'\fR of the accompanying distribution):
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ cat \-n GiveNamesToCalc.eyp
\&     1  # GiveNamesToCalc.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6  %right  \*(Aq^\*(Aq
\&     7
\&     8  %tree bypass
\&     9
\&    10  %{
\&    11  use base q{Tail};
\&    12
\&    13  sub exp_is_NUM::info {
\&    14    my $self = shift;
\&    15
\&    16    $self\->{attr}[0];
\&    17  }
\&    18
\&    19  *exp_is_VAR::info = *var_is_VAR::info = \e&exp_is_NUM::info;
\&    20  %}
\&    21
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
\&    39  %%
\&    40
\&    41  line:
\&    42      exp
\&    43  ;
\&    44
\&    45  exp:
\&    46      NUM
\&    47    | VAR
\&    48    | var \*(Aq=\*(Aq exp
\&    49    | exp \*(Aq+\*(Aq exp
\&    50    | exp \*(Aq\-\*(Aq exp
\&    51    | exp \*(Aq*\*(Aq exp
\&    52    | exp \*(Aq/\*(Aq exp
\&    53    | %no bypass exp_is_NEG
\&    54       \*(Aq\-\*(Aq exp %prec NEG
\&    55    | exp \*(Aq^\*(Aq exp
\&    56    | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    57  ;
\&    58
\&    59  var:
\&    60      VAR
\&    61  ;
\&    62  %%
\&    63
\&    64  unless (caller) {
\&    65    my $t = _\|_PACKAGE_\|_\->main(@ARGV);
\&    66    print $t\->str."\en";
\&    67  }
.Ve
.PP
The example uses a naming scheme that is provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR: \f(CW\*(C`Parse::Eyapp::Grammar::give_token_name\*(C'\fR.
The current provided naming schemes handlers are:
.IP "\(bu" 2
\&\f(CW\*(C`give_default_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule
concatenated with an underscore and the index of the production
.IP "\(bu" 2
\&\f(CW\*(C`give_lhs_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule (this
is the naming scheme used by the \f(CW%tree\fR directive when no explicit name was given)
.IP "\(bu" 2
\&\f(CW\*(C`give_token_name\*(C'\fR: The name of the production is the Left Hand Side of the Production Rule followed by the 
word \f(CW\*(C`_is_\*(C'\fR followed by the concatenation of the names of the tokens in the right and side (separated by underscores).
.PP
All of these handlers are implemented inside the class \f(CW\*(C`Parse::Eyapp::Grammar\*(C'\fR. There is no need at line 
37 to explicit the class name prefix since the naming scheme code is evaluated inside such class:
.PP
.Vb 10
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
.Ve
.PP
As it is illustrated in this example, the method \f(CW\*(C`tokennames\*(C'\fR of \f(CW\*(C`Parse::Eyapp\*(C'\fR
objects provide a way to give identifier names to tokens that are defined by strings.
When we execute the former module/program (modulino) with input \f(CW\*(C`a=2*\-3\*(C'\fR we got the following
output:
.PP
.Vb 5
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ eyapp \-b \*(Aq\*(Aq GiveNamesToCalc.eyp
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ ./GiveNamesToCalc.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a=2*\-3
\&  line_is_exp(var_is_VAR[a],exp_is_TIMES(exp_is_NUM[2],exp_is_NEG(exp_is_NUM[3])))
.Ve
.PP
For each production rule the handler is called with arguments:
.IP "\(bu" 2
the \f(CW\*(C`Parse::Eyapp\*(C'\fR object,
.IP "\(bu" 2
the production index (inside the grammar),
.IP "\(bu" 2
the left hand side
symbol and a reference to a list with the symbols in the right hand side.
.PP
The following code of some version of \f(CW\*(C`give_token_name\*(C'\fR exemplifies how a
naming scheme handler can be written:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp$ sed \-ne \*(Aq101,132p\*(Aq lib/Parse/Eyapp/Grammar.pm | cat \-n
\&     1  sub give_token_name {
\&     2    my ($self, $index, $lhs, $rhs) = @_;
\&     3
\&     4    my @rhs = @$rhs;
\&     5    $rhs = \*(Aq\*(Aq;
\&     6
\&     7    unless (@rhs) { # Empty RHS
\&     8      return $lhs.\*(Aq_is_empty\*(Aq;
\&     9    }
\&    10
\&    11    my $names = $self\->{GRAMMAR}{TOKENNAMES} || {};
\&    12    for (@rhs) {
\&    13      if ($self\->is_token($_)) {
\&    14        s/^\*(Aq(.*)\*(Aq$/$1/;
\&    15        my $name = $names\->{$_} || \*(Aq\*(Aq;
\&    16        unless ($name) {
\&    17          $name = $_ if /^\ew+$/;
\&    18        }
\&    19        $rhs .= "_$name" if $name;
\&    20      }
\&    21    }
\&    22
\&    23    unless ($rhs) { # no \*(Aqword\*(Aq tokens in the RHS
\&    24      for (@rhs) {
\&    25        $rhs .= "_$_" if /^\ew+$/;
\&    26      }
\&    27    }
\&    28
\&    29    # check if another production with such name exists?
\&    30    my $name = $lhs.\*(Aq_is\*(Aq.$rhs;
\&    31    return $name;
\&    32  }
.Ve
.IP "\(bu" 4
The project home is at http://code.google.com/p/parse\-eyapp/ <http://code.google.com/p/parse-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Parse5.18.3pm                  0100644 0001750 0001750 00000531024 12566242263 025236  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Parse 3"
.TH Parse::Eyapp::Parse 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Parse \- The parser of Eyapp grammars
.SH "THE EYAPP LANGUAGE"
.IX Header "THE EYAPP LANGUAGE"
The parser for the \f(CW\*(C`Eyapp\*(C'\fR language
was written and generated
using \f(CW\*(C`Parse::Eyapp\*(C'\fR and the \f(CW\*(C`eyapp\*(C'\fR compiler (actually
the first version 
was bootstrapped using the yapp compiler).
The Eyapp program parsing the \f(CW\*(C`Eyapp\*(C'\fR language
is in the file \f(CW\*(C`Parse/Eyapp/Parse.yp\*(C'\fR 
in the \f(CW\*(C`Parse::Eyapp\*(C'\fR distribution.
Therefore \f(CW\*(C`Parse::Eyapp::Parse\*(C'\fR 
objects have all the methods in \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR.
.PP
A \f(CW\*(C`Parse::Eyapp::Parse\*(C'\fR is nothing but a particular kind of \f(CW\*(C`Parse::Eyapp\*(C'\fR
parser: \fIthe one that parses\fR \f(CW\*(C`Eyapp\*(C'\fR \fIgrammars\fR.
.SS "Eyapp Grammar"
.IX Subsection "Eyapp Grammar"
This section describes the syntax of the Eyapp language using its own notation.
The grammar extends yacc and yapp grammars.  Semicolons have been omitted
to save space.  Between C\-like comments you can find an (informal) explanation
of the language associated with each token.
.PP
.Vb 10
\&  %token ASSOC /* is %(left|right|nonassoc) */                                                                                                          
\&  %token BEGINCODE /* is %begin { Perl code ... } */                                                                                                    
\&  %token CODE /* is { Perl code ... } */                                                                                                                
\&  %token CONFLICT /* is %conflict */                                                                                                                    
\&  %token DEFAULTACTION /* is %defaultaction */                                                                                                          
\&  %token EXPECT /* is %expect */                                                                                                                        
\&  %token HEADCODE /* is %{ Perl code ... %} */                                                                                                          
\&  %token IDENT /* is [A\-Za\-z_][A\-Za\-z0\-9_]* */                                                                                                          
\&  %token LABEL /* is :[A\-Za\-z0\-9_]+ */                                                                                                                  
\&  %token LITERAL /* is a string literal like \*(Aqhello\*(Aq */                                                                                                 
\&  %token METATREE /* is %metatree */                                                                                                                    
\&  %token NAME /* is %name */                                                                                                                            
\&  %token NAMINGSCHEME /* is %namingscheme */                                                                                                            
\&  %token NOCOMPACT /* is %nocompact */                                                                                                                  
\&  %token NUMBER /* is \ed+ */                                                                                                                            
\&  %token OPTION /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e? */                                                                                                 
\&  %token PLUS /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+ */                                                                                                   
\&  %token PREC /* is %prec */                                                                                                                            
\&  %token PREFIX /* is %prefix\es+([A\-Za\-z_][A\-Za\-z0\-9_:]*::) */                                                                                          
\&  %token SEMANTIC /* is %semantic\es+token */                                                                                                            
\&  %token STAR /* is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e* */                                                                                                   
\&  %token START /* is %start */                                                                                                                          
\&  %token STRICT /* is %strict */                                                                                                                        
\&  %token SYNTACTIC /* is %syntactic\es+token */                                                                                                          
\&  %token TAILCODE /* is { Perl code ... } */                                                                                                            
\&  %token TOKEN /* is %token */                                                                                                                          
\&  %token TREE /* is %tree */                                                                                                                            
\&  %token TYPE /* is %type */                                                                                                                            
\&  %token UNION /* is %union */                                                                                                                          
\&  %start eyapp                                                                                                                                          
\&
\&  %%
\&
\&  # Main rule
\&  eyapp:     
\&        head body tail 
\&  ;                    
\&  #Common rules:       
\&  symbol:              
\&        LITERAL        
\&      | ident #default action
\&  ;                          
\&  ident:                     
\&        IDENT                
\&  ;                          
\&  # Head section:            
\&  head:                      
\&        headsec \*(Aq%%\*(Aq         
\&  ;                          
\&  headsec:                   
\&        #empty  #default action
\&      | decls #default action  
\&  ;                            
\&  decls:                       
\&        decls decl #default action
\&      | decl #default action      
\&  ;                               
\&  decl:                           
\&        \*(Aq\en\*(Aq #default action      
\&      | SEMANTIC typedecl symlist \*(Aq\en\*(Aq
\&      | SYNTACTIC typedecl symlist \*(Aq\en\*(Aq
\&      | TOKEN typedecl toklist \*(Aq\en\*(Aq    
\&      | ASSOC typedecl symlist \*(Aq\en\*(Aq    
\&      | START ident \*(Aq\en\*(Aq               
\&      | PREFIX \*(Aq\en\*(Aq                    
\&      | WHITES CODE \*(Aq\en\*(Aq               
\&      | WHITES REGEXP \*(Aq\en\*(Aq             
\&      | WHITES \*(Aq=\*(Aq CODE \*(Aq\en\*(Aq           
\&      | WHITES \*(Aq=\*(Aq REGEXP \*(Aq\en\*(Aq         
\&      | NAMINGSCHEME CODE \*(Aq\en\*(Aq         
\&      | HEADCODE \*(Aq\en\*(Aq                  
\&      | UNION CODE \*(Aq\en\*(Aq  #ignore       
\&      | DEFAULTACTION CODE \*(Aq\en\*(Aq        
\&      | LEXER CODE \*(Aq\en\*(Aq                
\&      | TREE \*(Aq\en\*(Aq                      
\&      | METATREE \*(Aq\en\*(Aq                  
\&      | STRICT \*(Aq\en\*(Aq                    
\&      | NOCOMPACT \*(Aq\en\*(Aq                 
\&      | TYPE typedecl identlist \*(Aq\en\*(Aq   
\&      | CONFLICT ident CODE \*(Aq\en\*(Aq       
\&      | EXPECT NUMBER \*(Aq\en\*(Aq             
\&      | EXPECT NUMBER NUMBER \*(Aq\en\*(Aq      
\&      | EXPECTRR NUMBER \*(Aq\en\*(Aq           
\&      | error \*(Aq\en\*(Aq                     
\&  ;                                    
\&  typedecl:                            
\&        #empty                         
\&      | \*(Aq<\*(Aq IDENT \*(Aq>\*(Aq                  
\&  ;                                    
\&  symlist:                             
\&        symlist symbol                 
\&      | symbol                         
\&  ;                                    
\&  toklist:                             
\&        toklist tokendef               
\&      | tokendef                       
\&  ;                                    
\&  tokendef:                            
\&        symbol \*(Aq=\*(Aq REGEXP              
\&      | symbol \*(Aq=\*(Aq CODE                
\&      | symbol                         
\&  ;                                    
\&  identlist:                           
\&        identlist ident                
\&      | ident                          
\&  ;                                    
\&  # Rule section                       
\&  body:                                
\&        rulesec \*(Aq%%\*(Aq                   
\&      | \*(Aq%%\*(Aq                           
\&  ;                                    
\&  rulesec:                             
\&        rulesec rules #default action  
\&      | startrules #default action     
\&  ;                                    
\&  startrules:                          
\&        IDENT \*(Aq:\*(Aq  rhss \*(Aq;\*(Aq            
\&      | error \*(Aq;\*(Aq                      
\&  ;                                    
\&  rules:                               
\&        IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq             
\&      | error \*(Aq;\*(Aq                      
\&  ;                                    
\&  rhss:                                
\&        rhss \*(Aq|\*(Aq rule                  
\&      | rule                           
\&  ;                                    
\&  rule:                                
\&        optname rhs prec epscode       
\&      | optname rhs                    
\&  ;                                    
\&  rhs:                                 
\&        #empty      #default action (will return undef)
\&      | rhselts #default action                        
\&  ;                                                    
\&  rhselts:                                             
\&        rhselts rhseltwithid                           
\&      | rhseltwithid                                   
\&  ;                                                    
\&  rhseltwithid:                                        
\&        rhselt \*(Aq.\*(Aq IDENT
\&      | \*(Aq$\*(Aq rhselt
\&      | \*(Aq$\*(Aq error
\&      | rhselt
\&  ;
\&  rhselt:
\&        symbol
\&      | code
\&      | DPREC ident
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq
\&      | rhselt STAR
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq
\&      | rhselt OPTION
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS
\&  ;
\&  optname:
\&        /* empty */
\&      | NAME IDENT
\&      | NAME IDENT LABEL
\&      | NAME LABEL
\&  ;
\&  prec:
\&        PREC symbol
\&  ;
\&  epscode:
\&      | code
\&  ;
\&  code:
\&        CODE
\&      | BEGINCODE
\&  ;
\&  # Tail section:
\&  tail:
\&        /*empty*/
\&      | TAILCODE
\&  ;
\&
\&  %%
.Ve
.PP
The semantic of \f(CW\*(C`Eyapp\*(C'\fR agrees with the semantic of \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`yapp\*(C'\fR for
all the common constructions.
.SS "Comments"
.IX Subsection "Comments"
Comments are either Perl style, from \f(CW\*(C`#\*(C'\fR
up to the end of line, or C style, enclosed between  \f(CW\*(C`/*\*(C'\fR and \f(CW\*(C`*/\*(C'\fR.
.SS "Syntactic Variables, Symbolic Tokens and String Literals"
.IX Subsection "Syntactic Variables, Symbolic Tokens and String Literals"
Two kind of symbols may appear inside a Parse::Eyapp program:
\&\fINon-terminal\fR symbols or \fIsyntactic variables\fR, 
called also \fIleft-hand-side\fR symbols
and \fITerminal\fR symbols, called
also \fITokens\fR.
.PP
Tokens are the symbols the lexical analyzer function returns to the parser.
There are two kinds of tokens: \fIsymbolic tokens\fR and \fIstring
literals\fR.
.PP
\&\fISyntactic variables\fR and \fIsymbolic tokens\fR identifiers must conform
to the regular expression \f(CW\*(C`[A\-Za\-z][A\-Za\-z0\-9_]*\*(C'\fR.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIsymbolic tokens\fR will be considered \fIsemantic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R"). \fISymbolic tokens\fR yield nodes
in the Abstract Syntax Tree.
.PP
String literals are enclosed in single quotes and can contain almost
anything. They will be received by the parser as double-quoted strings. 
Any special character as \f(CW\*(Aq"\*(Aq\fR, \f(CW\*(Aq$\*(Aq\fR and \f(CW\*(Aq@\*(Aq\fR is escaped.
To have a single quote inside a literal, escape it with '\e'.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIstring literals\fR will be considered \fIsyntactic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R"). \fISyntactic tokens\fR do not produce
nodes in the Abstract Syntax Tree.
.PP
The examples used along this document can be found in the directory 
\&\f(CW\*(C`examples/eyapplanguageref\*(C'\fR accompanying this distribution.
.ie n .SS "Parts of an ""eyapp"" Program"
.el .SS "Parts of an \f(CWeyapp\fP Program"
.IX Subsection "Parts of an eyapp Program"
An Eyapp program has three parts called head, body and tail:
.PP
.Vb 1
\&                                 eyapp: head body tail ;
.Ve
.PP
Each part is separated from the former by the symbol \f(CW\*(C`%%\*(C'\fR:
.PP
.Vb 2
\&                                 head: headsec \*(Aq%%\*(Aq
\&                                 body: rulesec \*(Aq%%\*(Aq
.Ve
.SH "THE HEAD SECTION"
.IX Header "THE HEAD SECTION"
The head section contains a list of declarations
.PP
.Vb 1
\&                                 headsec:  decl *
.Ve
.PP
There are different kinds of declarations.
.PP
This reference does not 
fully describes all the declarations that are shared with \f(CW\*(C`yacc\*(C'\fR and 
yapp.
.SS "Example of Head Section"
.IX Subsection "Example of Head Section"
In this and the next sections we will describe the basics
of the Eyapp language using the file \f(CW\*(C`examples/eyapplanguageref/Calc.eyp\*(C'\fR 
that accompanies this distribution. This file implements a trivial 
calculator. Here is the header section:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,/%%/p\*(Aq Calc.eyp | cat \-n
\&     1  # examples/eyapplanguageref/Calc.eyp
\&     2  %whites    =  /([ \et]*(?:#.*)?)/
\&     3  %token NUM =  /([0\-9]+(?:\e.[0\-9]+)?)/
\&     4  %token VAR =  /([A\-Za\-z][A\-Za\-z0\-9_]*)/
\&     5
\&     6  %right  \*(Aq=\*(Aq
\&     7  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     8  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     9  %left   NEG
\&    10  %right  \*(Aq^\*(Aq
\&    11
\&    12  %{
\&    13  my %s; # symbol table
\&    14  %}
\&    15
\&    16  %%
.Ve
.PP
Eyapp produces a lexical generator from the descriptions given
by the \f(CW%token\fR and \f(CW%whites\fR directives plus the tokens used 
inside the body section.
.PP
.Vb 3
\&       %whites    =  /([ \et]*(?:#.*)?)/
\&       %token NUM =  /([0\-9]+(?:\e.[0\-9]+)?)/
\&       %token VAR =  /([A\-Za\-z][A\-Za\-z0\-9_]*)/
.Ve
.PP
See section \*(L"Automatic Generation of Lexical Analyzers\*(R" for more details.
.SS "Declarations and Precedence"
.IX Subsection "Declarations and Precedence"
Lines 2\-5 declare several tokens. The usual way to declare
tokens is through the \f(CW%token\fR directive. The declarations 
\&\f(CW%nonassoc\fR, \f(CW%left\fR and \f(CW%right\fR 
not only declare the tokens but also associate a \fIpriority\fR with them.  
Tokens declared in the same line have the same precedence. 
Tokens declared with these directives in lines below have more
precedence than those declared above. Thus, in the example
above
we are saying that \f(CW"+"\fR and \f(CW"\-"\fR have the same precedence
but higher precedence than =. The final effect of \f(CW"\-"\fR
having greater precedence than = will be that an
expression like:
.PP
.Vb 1
\&                        a = 4 \- 5
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                        a = (4 \- 5)
.Ve
.PP
and not as
.PP
.Vb 1
\&                        (a = 4) \- 5
.Ve
.PP
The use of the \f(CW%left\fR indicates that \- in case of ambiguity 
and a match between precedences \- the parser must build the tree corresponding
to a left parenthesizing. Thus, the expression
.PP
.Vb 1
\&                         4 \- 5 \- 9
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                         (4 \- 5) \- 9
.Ve
.PP
You can refer to the token end-of-input in the header section using the string \f(CW\*(Aq\*(Aq\fR (for example
to give it some priority, see the example in \f(CW\*(C`examples/debuggingtut/typicalrrwithprec.eyp\*(C'\fR).
.SS "Header Code"
.IX Subsection "Header Code"
Perl code surrounded by \f(CW\*(C`%{\*(C'\fR and \f(CW\*(C`%}\*(C'\fR
can be inserted in the head section. Such code will be inserted in the module
generated by \f(CW\*(C`eyapp\*(C'\fR near the beginning. Therefore, declarations like the
one of the calculator symbol table \f(CW%s\fR
.PP
.Vb 3
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
.Ve
.PP
will be visible from almost any point in the file.
.SS "The Start Symbol of the Grammar"
.IX Subsection "The Start Symbol of the Grammar"
\&\f(CW\*(C`%start program\*(C'\fR declares \f(CW\*(C`program\*(C'\fR as the start symbol of 
the grammar. When \f(CW%start\fR is not
used, the first rule in the body section will be used.
.SS "Expect"
.IX Subsection "Expect"
The \f(CW\*(C`%expect #NUMBER\*(C'\fR directive works as in \f(CW\*(C`bison\*(C'\fR 
and  suppress warnings when the number of Shift/Reduce
conflicts is exactly \f(CW\*(C`#NUMBER\*(C'\fR.
.PP
The directive has been extended to be called with two numbers:
.PP
.Vb 1
\&  %expect NUMSHIFTRED NUMREDRED
.Ve
.PP
no warnings will be emitted if the number of shift-reduce 
conflicts is exactly \f(CW\*(C`NUMSHIFTRED\*(C'\fR and the number of reduce-reduce
conflicts is \f(CW\*(C`NUMREDRED\*(C'\fR.
.SS "Type and Union"
.IX Subsection "Type and Union"
C oriented declarations like \f(CW%type\fR and \f(CW%union\fR are
parsed but ignored.
.ie n .SS "The %strict Directive"
.el .SS "The \f(CW%strict\fP Directive"
.IX Subsection "The %strict Directive"
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ls \-ltr | tail \-1
\&  \-rw\-r\-\-r\-\- 1 pl users 2395 2008\-10\-02 09:41 bugyapp3.pm
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.ie n .SS "The %prefix Directive"
.el .SS "The \f(CW%prefix\fP Directive"
.IX Subsection "The %prefix Directive"
The \f(CW%prefix\fR directive 
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix
.PP
.Vb 1
\&  %prefix Some::Prefix::
.Ve
.PP
See the example in \f(CW\*(C`examples/eyapplanguageref/alias_and_yyprefix.pl\*(C'\fR.
See also section \*(L"Grammar Reuse\*(R" in Parse::Eyapp::defaultactionsintro
for an example that does not involve the \f(CW%tree\fR directive.
.SS "Default Action Directive"
.IX Subsection "Default Action Directive"
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify the default action 
using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. See section \*(L"\s-1DEFAULT ACTIONS\*(R"\s0.
The examples \f(CW\*(C`examples/eyapplanguageref/Postfix.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/eyapplanguageref/Lhs.eyp\*(C'\fR illustrate the use of the directive.
.SS "Tree Construction Directives"
.IX Subsection "Tree Construction Directives"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
and \f(CW%metatree\fR directives. See sections
\&\*(L"\s-1ABSTRACT SYNTAX TREES:\s0 \f(CW%tree\fR \s-1AND\s0 \f(CW%name\fR\*(R"
and
Parse::Eyapp::translationschemestut.
.SS "Tokens and the Abstract Syntax Tree"
.IX Subsection "Tokens and the Abstract Syntax Tree"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the way \f(CW\*(C`eyapp\*(C'\fR builds the abstract syntax tree.
See section \*(L"Syntactic and Semantic tokens\*(R".
.ie n .SS "The %nocompact directive"
.el .SS "The \f(CW%nocompact\fP directive"
.IX Subsection "The %nocompact directive"
This directive influences the generation of the \s-1LALR\s0 tables.
They will not be compacted and the tokens
for the \f(CW\*(C`DEFAULT\*(C'\fR reduction will be explicitly set.
It can be used to produce an \f(CW\*(C`.output\*(C'\fR file (option \f(CW\*(C`\-v\*(C'\fR)
with more information.
.SH "THE BODY"
.IX Header "THE BODY"
The body section contains the rules describing the grammar:
.PP
.Vb 3
\&                       body:   rules * \*(Aq%%\*(Aq
\&                       rules:  IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&                       rhss:   (optname rhs (prec epscode)?) <+ \*(Aq|\*(Aq>
.Ve
.SS "Rules"
.IX Subsection "Rules"
A rule is made of a left-hand-side symbol (the \fIsyntactic variable\fR), 
followed by a \f(CW\*(Aq:\*(Aq\fR and one
or more \fIright-hand-sides\fR (or \fIproductions\fR)
 separated by \f(CW\*(Aq|\*(Aq\fR and terminated by a \f(CW\*(Aq;\*(Aq\fR
like in:
.PP
.Vb 5
\&                          exp: 
\&                               exp \*(Aq+\*(Aq exp
\&                            |  exp \*(Aq\-\*(Aq exp
\&                            |  NUM
\&                          ;
.Ve
.PP
A \fIproduction\fR (\fIright hand side\fR) may be empty:
.PP
.Vb 4
\&                          input:   
\&                               /* empty */
\&                            |  input line
\&                          ;
.Ve
.PP
The former two productions can be abbreviated as
.PP
.Vb 3
\&                          input: 
\&                               line *
\&                          ;
.Ve
.PP
The operators \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`?\*(C'\fR are presented in section
\&\*(L"\s-1LISTS AND OPTIONALS\*(R"\s0.
.PP
A \fIsyntactic variable cannot appear more than once as
a rule name\fR (This differs from \f(CW\*(C`yacc\*(C'\fR).  So you can't 
write
.PP
.Vb 2
\&    thing: foo bar ;
\&    thing: foo baz ;
.Ve
.PP
instead, write:
.PP
.Vb 4
\&    thing: 
\&           foo bar 
\&         | foo baz 
\&    ;
.Ve
.SS "Semantic Values and Semantic Actions"
.IX Subsection "Semantic Values and Semantic Actions"
In \f(CW\*(C`Parse::Eyapp\*(C'\fR 
a production rule
.PP
.Vb 1
\&                          A \-> X_1 X_2 ... X_n
.Ve
.PP
can be followed by a 
\&\fIsemantic action\fR:
.PP
.Vb 1
\&                    A \-> X_1 X_2 ... X_n { Perl Code }
.Ve
.PP
Such
semantic action is nothing but Perl code that will be treated 
as an anonymous subroutine.  The semantic action associated 
with production rule \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR  is executed
after any actions associated with the subtrees of \f(CW\*(C`X_1\*(C'\fR,
\&\f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR.
\&\f(CW\*(C`Eyapp\*(C'\fR parsers build the syntax tree using a left-right
bottom-up traverse of the syntax tree. Each times
the Parser visits the node associated with the 
production \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR
the associated semantic action is called. 
Associated with each symbol
of a Parse::Eyapp grammar there is a scalar \fISemantic Value\fR
or \fIAttribute\fR. The semantic values of terminals are provided
by the lexical analyzer. In the calculator example
(see file \f(CW\*(C`examples/eyapplanguageref/Calc.yp\*(C'\fR in the distribution),
the semantic value associated with an expression
is its numeric value. Thus in the rule:
.PP
.Vb 1
\&                       exp \*(Aq+\*(Aq exp { $_[1] + $_[3] }
.Ve
.PP
\&\f(CW$_[1]\fR refers to the attribute of the first \f(CW\*(C`exp\*(C'\fR, \f(CW$_[2]\fR 
is the attribute associated with \f(CW\*(Aq+\*(Aq\fR, which is the second component of the 
pair provided by the lexical analyzer and \f(CW$_[3]\fR refers to the attribute of 
the second \f(CW\*(C`exp\*(C'\fR.
.PP
When the semantic action/anonymous subroutine is called,
the arguments are as follows:
.IP "\(bu" 4
\&\f(CW$_[1]\fR to \f(CW$_[n]\fR are the attributes of
the symbols \f(CW\*(C`X_1\*(C'\fR, \f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR. 
Just as \f(CW$1\fR to \f(CW$n\fR in \f(CW\*(C`yacc\*(C'\fR,
.IP "\(bu" 4
\&\f(CW$_[0]\fR is the parser object itself.
Having \f(CW$_[0]\fR being the parser object itself allows you to call
parser methods. Most \f(CW\*(C`yacc\*(C'\fR macros have been converted into
parser methods. See section \*(L"\s-1METHODS AVAILABLE IN THE GENERATED CLASS\*(R"\s0 in Parse::Eyapp.
.PP
The returned value will be the attribute associated 
with the left hand side of the production.
.PP
Names can be given to the attributes using the dot notation
(see file \f(CW\*(C`examples/eyapplanguageref/CalcSimple.eyp\*(C'\fR):
.PP
.Vb 1
\&                     exp.left \*(Aq+\*(Aq exp.right { $left + $right }
.Ve
.PP
See section \*(L"\s-1NAMES FOR ATTRIBUTES\*(R"\s0 for more details about the \fIdot\fR and \fIdollar\fR 
notations.
.PP
If no action is specified and no \f(CW%defaultaction\fR is specified
the default action
.PP
.Vb 1
\&                               { $_[1] }
.Ve
.PP
will be executed instead. See section \*(L"\s-1DEFAULT ACTIONS\*(R"\s0 to know more.
.SS "Actions in Mid-Rule"
.IX Subsection "Actions in Mid-Rule"
Actions can be inserted in the middle of a production like in:
.PP
.Vb 1
\& block: \*(Aq{\*(Aq.bracket { $ids\->begin_scope(); } declaration*.decs statement*.sts \*(Aq}\*(Aq { ... }
.Ve
.PP
A middle production action is managed by inserting a new rule in the grammar and associating
the semantic action with it:
.PP
.Vb 1
\&                     Temp: /* empty */ { $ids\->begin_scope(); }
.Ve
.PP
Middle production actions can refer to the attributes on its left. They count
as one of the components of the production. Thus the program:
.PP
.Vb 5
\&  ~/LEyapp/examples/eyapplanguageref$ cat intermediateaction2.yp 
\&  %%
\&  S:  \*(Aqa\*(Aq { $_[1]x4 }.mid \*(Aqa\*(Aq { print "\en<<$_[2], $mid, $_[3]>>\en"; }
\&  ;
\&  %%
.Ve
.PP
The auxiliar syntactic variables are named \f(CW\*(C`@#position\-#order\*(C'\fR where \f(CW\*(C`#position\*(C'\fR
is the position of the action in the rhs and \f(CW\*(C`order\*(C'\fR is an ordinal number. See
the \f(CW\*(C`.output\*(C'\fR file for the former example:
.PP
.Vb 7
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-v intermediateaction2.yp
\&  ~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,5p\*(Aq intermediateaction2.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:  $start \-> S $end
\&  1:  S \-> \*(Aqa\*(Aq @1\-1 \*(Aqa\*(Aq
\&  2:  @1\-1 \-> /* empty */
.Ve
.PP
We can build an executable \f(CW\*(C`ia.pl\*(C'\fR from the former grammar using \f(CW\*(C`eyapp\*(C'\fR option \f(CW\*(C`\-C\*(C'\fR:
.PP
.Vb 1
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-C \-o ia.pl intermediateaction2.yp
.Ve
.PP
The \f(CW\*(C`main\*(C'\fR, error and lexer methods are provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR.
When given input \f(CW\*(C`aa\*(C'\fR the execution will produce as output \f(CW\*(C`aaaa, aaaa, a\*(C'\fR. The option
\&\f(CW\*(C`\-d\*(C'\fR activates the debug mode, the option \f(CW\*(C`\-c\*(C'\fR tells the program to get the input from the command line::
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ ./ia.pl \-d \-c \*(Aqaa\*(Aq
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:
\&  Stack: 0
\&  Need token. Got >a<
\&  Shift and go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack: 0\->\*(Aqa\*(Aq\->2
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (@1\-1 \-\-> /* empty */): Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack: 0\->\*(Aqa\*(Aq\->2\->\*(Aq@1\-1\*(Aq\->4
\&  Need token. Got >a<
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack: 0\->\*(Aqa\*(Aq\->2\->\*(Aq@1\-1\*(Aq\->4\->\*(Aqa\*(Aq\->5
\&  Don\*(Aqt need token.
\&  Reduce using rule 1 (S \-\-> a @1\-1 a): 
\&  <<aaaa, aaaa, a>>
\&  Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack: 0\->\*(AqS\*(Aq\->1
\&  Need token. Got ><
\&  Shift and go to state 3.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 3:
\&  Stack: 0\->\*(AqS\*(Aq\->1\->\*(Aq\*(Aq\->3
\&  Don\*(Aqt need token.
\&  Accept.
.Ve
.SS "Example of Body Section"
.IX Subsection "Example of Body Section"
Following with the calculator example, the body is:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq17,/%%/p\*(Aq Calc.eyp | cat \-n 
\&     1  start:                                                                              
\&     2      input { \e%s }                                                                   
\&     3  ;
\&     4
\&     5  input: line *
\&     6  ;
\&     7
\&     8  line:
\&     9      \*(Aq\en\*(Aq       { undef }
\&    10    | exp \*(Aq\en\*(Aq   {
\&    11                    print "$_[1]\en" if defined($_[1]);
\&    12                    $_[1]
\&    13                 }
\&    14    | error  \*(Aq\en\*(Aq
\&    15        {
\&    16          $_[0]\->YYErrok;
\&    17          undef
\&    18        }
\&    19  ;
\&    20
\&    21  exp:
\&    22      NUM
\&    23    | $VAR                   { $s{$VAR} }
\&    24    | $VAR \*(Aq=\*(Aq $exp          { $s{$VAR} = $exp }
\&    25    | exp.left \*(Aq+\*(Aq exp.right { $left + $right }
\&    26    | exp.left \*(Aq\-\*(Aq exp.right { $left \- $right }
\&    27    | exp.left \*(Aq*\*(Aq exp.right { $left * $right }
\&    28    | exp.left \*(Aq/\*(Aq exp.right
\&    29      {
\&    30         $_[3] and return($_[1] / $_[3]);
\&    31         $_[0]\->YYData\->{ERRMSG} = "Illegal division by zero.\en";
\&    32         $_[0]\->YYError;
\&    33         undef
\&    34      }
\&    35    | \*(Aq\-\*(Aq $exp %prec NEG     { \-$exp }
\&    36    | exp.left \*(Aq^\*(Aq exp.right { $left ** $right }
\&    37    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq           { $exp }
\&    38  ;
\&    39
\&    40  %%
.Ve
.PP
This body does not uses any of the Eyapp extensions (with the exception of the 
\&\f(CW\*(C`*\*(C'\fR operator at line 5) and the dot and dollar notations.
.SS "Solving Ambiguities and Conflicts"
.IX Subsection "Solving Ambiguities and Conflicts"
When Eyapp analyzes a grammar like:
.PP
.Vb 7
\&  examples/eyapplanguageref$ cat \-n ambiguities.eyp
\&     1  %%
\&     2  exp:
\&     3      NUM
\&     4    | exp \*(Aq\-\*(Aq exp
\&     5  ;
\&     6  %%
.Ve
.PP
it will produce a warning announcing the existence of 
\&\fIshift-reduce\fR conflicts:
.PP
.Vb 5
\&  examples/eyapplanguageref$ eyapp ambiguities.eyp
\&  1 shift/reduce conflict (see .output file)
\&  State 5: reduce by rule 2: exp \-> exp \*(Aq\-\*(Aq exp (default action)
\&  State 5: shifts:
\&    to state    3 with \*(Aq\-\*(Aq
.Ve
.PP
when \f(CW\*(C`eyapp\*(C'\fR finds warnings automatically produces a \f(CW\*(C`.output\*(C'\fR file
describing the conflict.
.PP
What the warning is saying is that an expression like \f(CW\*(C`exp \*(Aq\-\*(Aq exp\*(C'\fR (rule 2) followed by a
minus \f(CW\*(Aq\-\*(Aq\fR can be parsed in more than one way. If we
have an input like \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR the activity of a \s-1\fILALR\s0\fR\|(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of \fIshift and reduce actions\fR. A \fIshift action\fR
has as consequence the reading of the next token. A \fIreduce action\fR
is finding a production rule that matches and substituting 
the rhs of the production by the lhs.  For input \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR
the activity will be as follows (the dot is used to indicate where the next 
input token is):
.PP
.Vb 6
\&                           .NUM \- NUM \- NUM # shift
\&                            NUM.\- NUM \- NUM # reduce exp: NUM 
\&                            exp.\- NUM \- NUM # shift
\&                            exp \-.NUM \- NUM # shift
\&                            exp \- NUM.\- NUM # reduce exp: NUM
\&                            exp \- exp.\- NUM # shift/reduce conflict
.Ve
.PP
up this point two different decisions can be taken: the next description can be
.PP
.Vb 1
\&                                  exp.\- NUM # reduce by exp: exp \*(Aq\-\*(Aq exp (rule 2)
.Ve
.PP
or:
.PP
.Vb 1
\&                            exp \- exp \-.NUM # shift \*(Aq\-\*(Aq (to state 3)
.Ve
.PP
that is why it is called a \fIshift-reduce conflict\fR.
.PP
That is also the reason for the precedence declarations in the 
head section. Another kind of conflicts are \fIreduce-reduce conflicts\fR.
They arise when more that rhs can be applied for a reduction
action.
.PP
Eyapp solves the conflicts applying the following rules:
.IP "\(bu" 4
In a shift/reduce conflict, the default is the shift.
.IP "\(bu" 4
In a reduce/reduce conflict, the default is to reduce by the
earlier grammar production (in the input sequence).
.IP "\(bu" 4
Precedences and associativities can be given to tokens in
the declarations section. This is made by a sequence of lines beginning
with one of the directives: \f(CW%left\fR, \f(CW%right\fR, or \f(CW%nonassoc\fR, 
followed by a list of
tokens. All the tokens on the same line
have the same precedence and associativity; 
the lines are listed in order of increasing precedence.
.IP "\(bu" 4
A precedence and associativity is associated with each grammar
production; it is the precedence and associativity of the \fIlast token\fR 
or \fIliteral\fR in the right hand side of the production.
.IP "\(bu" 4
The \f(CW%prec\fR directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional \f(CW\*(C`%prec token\*(C'\fR directive
giving the production the precedence of the \f(CW\*(C`token\*(C'\fR
.Sp
.Vb 1
\&                          exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
.Ve
.IP "\(bu" 4
If there is a shift/reduce conflict, and both the grammar production
and the input token have precedence and associativity associated
with them, then the conflict is solved in favor of the action (shift or
reduce) associated with the higher precedence. If the precedences are the
same, then the associativity is used; left associative implies reduce,
right associative implies shift, and non associative implies error.
The last is used to describe operators, like the operator \f(CW\*(C`.LT.\*(C'\fR in \s-1FORTRAN, \s0
that may not associate with themselves. That is, because
.Sp
.Vb 1
\&                             A .LT. B .LT. C
.Ve
.Sp
is invalid in \s-1FORTRAN, \s0\f(CW\*(C`.LT.\*(C'\fR would be described with the keyword \f(CW%nonassoc\fR in eyapp.
.PP
To solve a shift-reduce conflict between a production \f(CW\*(C`A \-\-> SOMETHING\*(C'\fR
and a token \f(CW\*(Aqa\*(Aq\fR you can follow this procedure:
.ie n .IP "1. Edit the "".output"" file" 4
.el .IP "1. Edit the \f(CW.output\fR file" 4
.IX Item "1. Edit the .output file"
.PD 0
.IP "2. Search for the state where the conflict between the production and the token is. In our example it looks like:" 4
.IX Item "2. Search for the state where the conflict between the production and the token is. In our example it looks like:"
.PD
.Vb 2
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq56,65p\*(Aq ambiguities.output
\& State 5:
\&
\&        exp \-> exp . \*(Aq\-\*(Aq exp    (Rule 2)
\&        exp \-> exp \*(Aq\-\*(Aq exp .    (Rule 2)
\&
\&        \*(Aq\-\*(Aq     shift, and go to state 3
\&
\&        \*(Aq\-\*(Aq     [reduce using rule 2 (exp)]
\&        $default        reduce using rule 2 (exp)
.Ve
.ie n .IP "3. Inside the state there has to be a production of the type ""A \-\-> SOMETHING."" (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form ""A \-\-> prefix . suffix"", where suffix can \fIstart\fR with the involved token \*(Aqa\*(Aq." 4
.el .IP "3. Inside the state there has to be a production of the type \f(CWA \-\-> SOMETHING.\fR (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form \f(CWA \-\-> prefix . suffix\fR, where suffix can \fIstart\fR with the involved token \f(CW\*(Aqa\*(Aq\fR." 4
.IX Item "3. Inside the state there has to be a production of the type A --> SOMETHING. (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form A --> prefix . suffix, where suffix can start with the involved token a."
.PD 0
.ie n .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want ""NUM \- NUM \- NUM"" to produce a tree like ""MINUS(MINUS(NUM, NUM), NUM)"" and not ""MINUS(NUM, MINUS(NUM, NUM))"". We want the conflict in ""exp \- exp.\- NUM"" to be solved in favor of the reduction by ""exp: exp \*(Aq\-\*(Aq exp"". This is achieved by declaring ""%left \*(Aq\-\*(Aq""." 4
.el .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want \f(CWNUM \- NUM \- NUM\fR to produce a tree like \f(CWMINUS(MINUS(NUM, NUM), NUM)\fR and not \f(CWMINUS(NUM, MINUS(NUM, NUM))\fR. We want the conflict in \f(CWexp \- exp.\- NUM\fR to be solved in favor of the reduction by \f(CWexp: exp \*(Aq\-\*(Aq exp\fR. This is achieved by declaring \f(CW%left \*(Aq\-\*(Aq\fR." 4
.IX Item "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want NUM - NUM - NUM to produce a tree like MINUS(MINUS(NUM, NUM), NUM) and not MINUS(NUM, MINUS(NUM, NUM)). We want the conflict in exp - exp.- NUM to be solved in favor of the reduction by exp: exp - exp. This is achieved by declaring %left -."
.PD
.SS "Error Recovery"
.IX Subsection "Error Recovery"
The token name \f(CW\*(C`error\*(C'\fR is reserved for error handling. This name can
be used in grammar productions; it suggests places where errors are
expected, and recovery can take place:
.PP
.Vb 8
\&     line:
\&       \*(Aq\en\*(Aq         { undef }
\&       | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\&       | error  \*(Aq\en\*(Aq
\&           {
\&             $_[0]\->YYErrok;
\&             undef
\&           }
.Ve
.PP
The parser pops its stack until
it enters a state where the token \f(CW\*(C`error\*(C'\fR is legal. It then shifts
the token \f(CW\*(C`error\*(C'\fR and proceeds to discard tokens until finding 
one that is acceptable. In the example
all the tokens until finding a \f(CW\*(Aq\en\*(Aq\fR will be skipped. 
If no special error productions have been specified,
the processing will halt.
.PP
In order to prevent a cascade of error messages, the parser, after
detecting an error, remains in error state until three tokens have been
successfully read and shifted. If an error is detected when the parser
is already in error state, no message is given, and the input token is
quietly deleted. The method \f(CW\*(C`YYErrok\*(C'\fR used in the example 
communicates to the parser
that a satisfactory recovery has been reached 
and that it can safely emit new error
messages.
.PP
You cannot have a literal \fI'error'\fR in your grammar as it would
confuse the driver with the \fIerror\fR token. Use a symbolic token instead.
.SH "THE TAIL"
.IX Header "THE TAIL"
The tail section contains Perl code. Usually it is empty, but you
can if you want put here your own lexical analyzer and 
error management subroutines.
An example of this is in
files \f(CW\*(C`examples/eyapplanguageref/List3_tree_d_sem.yp\*(C'\fR (the grammar)
and \f(CW\*(C`use_list3_tree_d_dem.pl\*(C'\fR (the client).
.SH "THE LEXICAL ANALYZER"
.IX Header "THE LEXICAL ANALYZER"
The Lexical Analyzer 
is called each time the parser needs a new token.
It is called with only one argument (the parser object)
and returns a pair 
containing the next token and its associated attribute.
.PP
The fact that is a method of the parser object means that the parser
methods are accessible inside the lexical analyzer.
.PP
When the lexical analyzer reaches the end of input, it must return the
pair \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
.SS "Automatic Generation of Lexical Analyzers"
.IX Subsection "Automatic Generation of Lexical Analyzers"
By default a lexical analyzer is built.
The \f(CW\*(C`eyapp\*(C'\fR option \f(CW\*(C`\-l\*(C'\fR
can be used to inhibit the generation of 
the default lexical analyzer. In such case,
one must be explictly provided.
.PP
\fINo token Definitions\fR
.IX Subsection "No token Definitions"
.PP
When no token definitions are given in the head section, 
the default lexical analyzer simply assumes
that the token is the string literal. See this example in 
file \f(CW\*(C`examples/lexergeneration/simple.yp\*(C'\fR:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat simple.yp
\&  %%
\&  A:    a
\&      | A d
\&  ;
\&  %%
.Ve
.PP
The grammar does not describes the lexical analyzer nor the error default subroutine.
Eyapp will generate default lexical and error subroutines:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-o simple.pl \-TC simple.yp
\&
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ls \-ltr | tail \-2
\&  \-rw\-r\-\-r\-\- 1 pl pl   27 2010\-06\-29 10:28 simple.yp
\&  \-rwxr\-xr\-x 1 pl pl 3245 2010\-06\-29 10:35 simple.pl
.Ve
.PP
The option \f(CW\*(C`\-T\*(C'\fR is equivalent to insert the \f(CW%tree\fR directive in the head section.
Since no names were explicitly given to the productions, the names of the productions are built using
the pattern \f(CW\*(C`Lhs_is_RHS\*(C'\fR.
.PP
Option \f(CW\*(C`\-C\*(C'\fR instructs the \f(CW\*(C`eyapp\*(C'\fR compiler to produce an executable by setting the execution permits
(see \f(CW\*(C`simple.pl\*(C'\fR permits above), inserting the appropriate she bang directive:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ head simple.pl | head \-1
\&  #!/usr/bin/perl
.Ve
.PP
and inserting a call to the package \f(CW\*(C`main\*(C'\fR subroutine at the end of the generated parser:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ tail \-6 simple.pl
\&  unless (caller) {
\&    exit !_\|_PACKAGE_\|_\->main(\*(Aq\*(Aq);
\&  }
.Ve
.PP
If no \f(CW\*(C`main\*(C'\fR was provided, \f(CW\*(C`eyapp\*(C'\fR will provide one.
.PP
Tokens \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`d\*(C'\fR are assumed to represent strings \f(CW\*(Aqa\*(Aq\fR
and \f(CW\*(Aqd\*(Aq\fR respectively.
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-i \-t \-c \*(Aqa d d\*(Aq
\&  A_is_A_d(A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d]),TERMINAL[d])
.Ve
.PP
The \f(CW\*(C`main\*(C'\fR method provided by \f(CW\*(C`eyapp\*(C'\fR accepts several options in the command line:
.IP "\(bu" 2
\&\f(CW\*(C`\-t\*(C'\fR Prints the abstract syntax tree
.IP "\(bu" 2
\&\f(CW\*(C`\-i\*(C'\fR Shows the semantic value associated with each terminal
.IP "\(bu" 2
\&\f(CW\*(C`\-c string\*(C'\fR Indicates that the input is given by the \f(CW\*(C`string\*(C'\fR that follows the option
.PP
You can get the set of available options using \f(CW\*(C`\-\-help\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-h
\&  Available options:
\&    \-\-debug                    sets yydebug on
\&    \-\-nodebug                  sets yydebug off
\&    \-\-file filepath            read input from filepath
\&    \-\-commandinput string      read input from string
\&    \-\-tree                     prints $tree\->str
\&    \-\-notree                   does not print $tree\->str
\&    \-\-info                     When printing $tree\->str shows the value of TERMINALs
\&    \-\-help                     shows this help
\&    \-\-slurp                    read until EOF reached
\&    \-\-noslurp                  read until CR is reached
\&    \-\-argfile                  main() will take the input string from its @_
\&    \-\-noargfile                main() will not take the input string from its @_
\&    \-\-yaml                     dumps YAML for $tree: YAML module must be installed
\&    \-\-margin=i                 controls the indentation of $tree\->str (i.e. $Parse::Eyapp::Node::INDENT)
.Ve
.PP
If we try to feed it with an illegal input, an error message is emitted:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl \-i \-t \-c \*(Aqa e d\*(Aq
\&  Error inside the lexical analyzer near \*(Aqe\*(Aq. Line: 1. File: \*(Aqsimple.yp\*(Aq. No match found.
.Ve
.PP
In the example above we have taken advantage of the \f(CW\*(C`main\*(C'\fR method provided by Eyapp.
If we want to keep in control of the parsing process, we can write a client program that 
makes use of the generated modulino:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n usesimple.pl
\&     1  #!/usr/bin/env perl
\&     2  use warnings;
\&     3  use strict;
\&     4
\&     5  use simple;
\&     6
\&     7  # build a parser object
\&     8  my $parser = simple\->new();
\&     9
\&    10  # take the input from the command line arguments
\&    11  # or from STDIN
\&    12  my $input = join \*(Aq \*(Aq,@ARGV;
\&    13  $input = <> unless $input;
\&    14
\&    15  # set the input
\&    16  $parser\->input($input);
\&    17
\&    18  # parse the input and get the AST
\&    19  my $tree = $parser\->YYParse();
\&    20
\&    21  print $tree\->str()."\en";
.Ve
.PP
Here is an example of execution:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-T simple.yp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimple.pl a d d
\&  A_is_A_d(A_is_A_d(A_is_a(TERMINAL),TERMINAL),TERMINAL)
.Ve
.PP
\fIToken Definitions: Regular Expressions\fR
.IX Subsection "Token Definitions: Regular Expressions"
.PP
Eyapp extends the \f(CW%token\fR directive with the syntax:
.PP
.Vb 1
\&     %token TOKENID = /regexp/
.Ve
.PP
If such definition is used, an entry with the shape:
.PP
.Vb 1
\&   /\eG$regexp/gc and return (\*(AqTOKENID\*(Aq, $1);
.Ve
.PP
will be added to the generated lexical analyzer.
Therefore the string associated with the first parenthesis in \f(CW\*(C`/regexp/\*(C'\fR
will be used as semantic value for \f(CW\*(C`TOKENID\*(C'\fR. If \f(CW\*(C`/regexp/\*(C'\fR has no
parenthesis \f(CW\*(C`undef\*(C'\fR will be the semantic value.
See this example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n numlist.eyp
\&     1  %token NUM = /(\ed+)/
\&     2  %token ID  = /(\ew+)/
\&     3
\&     4  %%
\&     5  A:
\&     6        B
\&     7      | A B
\&     8  ;
\&     9
\&    10  B:
\&    11        ID
\&    12      | a
\&    13      | NUM
\&    14  ;
\&    15  %%
.Ve
.PP
The order of the \f(CW%token\fR declarations is important. 
In the example the token \f(CW\*(C`NUM\*(C'\fR is a subset of the token \f(CW\*(C`ID\*(C'\fR.
Since it appears first, it will be tried first:
.PP
.Vb 2
\&     /\eG(\ed+)/gc and return (\*(AqNUM\*(Aq, $1);
\&     /\eG(\ew+)/gc and return (\*(AqID\*(Aq, $1);
.Ve
.PP
Also observe that token \f(CW\*(Aqa\*(Aq\fR (line 12) is contained
in token \f(CW\*(C`ID\*(C'\fR. However, any implicit token like this that appears in the
body section and was not 
declared using an explicit \f(CW%token\fR directive in the
head section takes priority over the ones declared.
See the behavior of the former program:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC numlist
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./numlist.pm \-t \-i \-c \*(Aq4 a b\*(Aq
\&  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
.Ve
.PP
The lexical analyzer returned \f(CW\*(C`NUM\*(C'\fR and not \f(CW\*(C`ID\*(C'\fR when \f(CW4\fR was processed,
also it returned \f(CW\*(C`a\*(C'\fR and not \f(CW\*(C`ID\*(C'\fR when \f(CW\*(Aqa\*(Aq\fR was 
processed.
.PP
A \f(CW%token\fR declaration without assignment like in:
.PP
.Vb 1
\&   %token A B
.Ve
.PP
is equivalent to
.PP
.Vb 2
\&  %token A   = /(A)/
\&  %token B   = /(B)/
.Ve
.PP
(in that order).
.PP
\fIToken Definitions via Code\fR
.IX Subsection "Token Definitions via Code"
.PP
An alternative way to define a token is via Perl code:
.PP
.Vb 1
\&      %token TOKENID = { ... }
.Ve
.PP
in such case the code defining \f(CW\*(C`TOKENID\*(C'\fR will be inserted
verbatim in the corresponding place of the generated lexical 
analyzer. When the code \f(CW\*(C`{ ... }\*(C'\fR
is executed, the variable \f(CW$_\fR 
contains the input being parsed and
the special variable \f(CW$self\fR refers to the parser object.
The following example is equivalent to the one used in the previous
section:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n tokensemdef.eyp
\&     1  %token NUM = /(\ed+)/
\&     2  %token ID  = { /\eG(\ew+)/gc and return (\*(AqID\*(Aq, $1); }
\&     3
\&     4  %%
\&     5  A:
\&     6        B
\&     7      | A B
\&     8  ;
\&     9
\&    10  B:
\&    11        ID
\&    12      | a
\&    13      | NUM
\&    14  ;
\&    15  %%
.Ve
.PP
Follows an example of compilation and execution:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC tokensemdef.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./tokensemdef.pm \-t \-i \-nos
\&  4 a b
\&  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
.Ve
.PP
\fIToken Definitions: Controling whites\fR
.IX Subsection "Token Definitions: Controling whites"
.PP
By default, the generated lexical analyzer skips 
white spaces, defined as \f(CW\*(C`/\es*/\*(C'\fR. The programmer
can change this behavior using the \f(CW%whites\fR directive.
The following example permits Perl-like comments 
in the input:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n simplewithwhites.eyp
\&     1  %whites  /(\es*(?:#.*)?\es*)/
\&     2  %%
\&     3  A:    a
\&     4      | A d
\&     5  ;
\&     6  %%
.Ve
.PP
Follows an example of execution:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-nA input
\&       1  a # 1$
\&       2  $
\&       3  d ^I#2$
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-TC simplewithwhites.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simplewithwhites.pm \-t \-i \-f input
\&  A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d])
.Ve
.PP
The \f(CW%white\fR directive can be followed by some Perl
code defining the white spaces:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n simplewithwhitescode.eyp
\&     1  %whites  { /\eG(\es*(?:#.*)?\es*)/gc and $self\->tokenline($1 =~ tr{\en}{}) }
\&     2  %%
\&     3  A:    a
\&     4      | A d
\&     5  ;
\&     6  %%
.Ve
.SS "Reading Input from File"
.IX Subsection "Reading Input from File"
You can use the method \f(CW\*(C`YYSlurpFile\*(C'\fR to read the input from a file
and set the input for the parser to its contents.
Yo can also use the \f(CW\*(C`YYInput\*(C'\fR method to set the input.
.PP
See the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n usesimplefromfile.pl
\&     1  #!/usr/bin/env perl
\&     2  use warnings;
\&     3  use strict;
\&     4
\&     5  use simplewithwhites;
\&     6
\&     7  my $parser = simplewithwhites\->new();
\&     8
\&     9  # take the input from the specified file
\&    10  my $fn = shift;
\&    11
\&    12  $parser\->YYSlurpFile($fn);
\&    13
\&    14  # parse the input and get the AST
\&    15  my $tree = $parser\->YYParse();
\&    16
\&    17  print $tree\->str()."\en";
.Ve
.PP
First, compile the grammar \f(CW\*(C`simplewithwhites.eyp\*(C'\fR presented above:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-T simplewithwhites
.Ve
.PP
And then run it:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n  input
\&     1  a # 1
\&     2
\&     3  d       #2
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimplefromfile.pl input
\&  A_is_A_d(A_is_a(TERMINAL),TERMINAL)
.Ve
.SS "Huge input and Incremental Lexical Analyzers"
.IX Subsection "Huge input and Incremental Lexical Analyzers"
If your input is huge, try to make use of an incremental
lexical analyzer. In an incremental lexer the input
is read and parsed in chunks. Read up to a 
point where  it is safe to parse.
In the example below, the lexer reads a new line
each time we reach the end of the input string \f(CW\*(C`${$parser\->YYInput}\*(C'\fR.
In the case of the arithmetic expressions grammar below,
by reading up to \f(CW\*(Aq\en\*(Aq\fR, we are sure that the input is not
broken in the middle of a token.
Instead of having the whole huge input in memory,
we only keep a small substring.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat \-n Incremental.eyp                    
\&     1  %right  \*(Aq=\*(Aq                                                                     
\&     2  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq                                                                 
\&     3  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq                                                                 
\&     4  %left   NEG                                                                     
\&     5                                                                                  
\&     6  %tree                                                                           
\&     7                                                                                  
\&     8  %%                                                                              
\&     9  input:                                                                          
\&    10          |   input $line  { print $line\->str."\en" }                              
\&    11  ;                                                                               
\&    12                                                                                  
\&    13  line:     \*(Aq\en\*(Aq                                                                  
\&    14          | exp \*(Aq\en\*(Aq
\&    15          | error \*(Aq\en\*(Aq
\&    16  ;
\&    17
\&    18  exp:        NUM
\&    19          |   VAR
\&    20          |   VAR \*(Aq=\*(Aq exp
\&    21          |   exp \*(Aq+\*(Aq exp
\&    22          |   exp \*(Aq\-\*(Aq exp
\&    23          |   exp \*(Aq*\*(Aq exp
\&    24          |   exp \*(Aq/\*(Aq exp
\&    25          |   \*(Aq\-\*(Aq exp %prec NEG
\&    26          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    27  ;
\&    28
\&    29  %%
\&    30
\&    31  sub _Lexer {
\&    32      my($parser)=shift;
\&    33
\&    34      if ($parser\->YYEndOfInput) {
\&    35        my $input = <STDIN>;
\&    36        return(\*(Aq\*(Aq, undef) unless $input;
\&    37        $parser\->input($input);
\&    38      };
\&    39
\&    40      for (${$parser\->YYInput}) {
\&    41          m/\eG[ \et]*/gc;
\&    42          m/\eG([0\-9]+(?:\e.[0\-9]+)?)/gc and return(\*(AqNUM\*(Aq,$1);
\&    43          m/\eG([A\-Za\-z][A\-Za\-z0\-9_]*)/gc and return(\*(AqVAR\*(Aq,$1);
\&    44          m/\eG(.)/gcs and return($1,$1);
\&    45          return(\*(Aq\*(Aq, undef);
\&    46      }
\&    47  }
\&    48
\&    49  _\|_PACKAGE_\|_\->lexer(\e&_Lexer);
.Ve
.PP
This approach has limitations. The code will get more tangled if some token
can take more than one line. For example, if we extend this language to accept 
C\-like comments \f(CW\*(C`/* ... */\*(C'\fR which expands over several lines.
.PP
Here follows an example of execution. 
This is the client program:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat useincremental.pl
\&  #!/usr/bin/perl \-w
\&  use Incremental;
\&
\&  Incremental\->new\->YYParse;
.Ve
.PP
This is a small test input file:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ cat inputforincremental
\&  a = 2
\&  a+3
\&  b=4
\&  b*2+a
.Ve
.PP
Finally, see the results of the execution:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ ./useincremental.pl < inputforincremental
\&  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
\&  line_4(exp_9(exp_7(TERMINAL),exp_6(TERMINAL)))
\&  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
\&  line_4(exp_9(exp_11(exp_7(TERMINAL),exp_6(TERMINAL)),exp_7(TERMINAL)))
.Ve
.PP
The numbers in the output refer to the production number:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp \-v Incremental.eyp
\&  pl@nereida:~/LEyapp/examples/lexergeneration$ sed \-ne \*(Aq/Rules:/,/^$/p\*(Aq Incremental.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> input $end
\&  1:      input \-> /* empty */
\&  2:      input \-> input line
\&  3:      line \-> \*(Aq\en\*(Aq
\&  4:      line \-> exp \*(Aq\en\*(Aq
\&  5:      line \-> error \*(Aq\en\*(Aq
\&  6:      exp \-> NUM
\&  7:      exp \-> VAR
\&  8:      exp \-> VAR \*(Aq=\*(Aq exp
\&  9:      exp \-> exp \*(Aq+\*(Aq exp
\&  10:     exp \-> exp \*(Aq\-\*(Aq exp
\&  11:     exp \-> exp \*(Aq*\*(Aq exp
\&  12:     exp \-> exp \*(Aq/\*(Aq exp
\&  13:     exp \-> \*(Aq\-\*(Aq exp
\&  14:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.SS "Using Several Lexical Analyzers for the Same Parser"
.IX Subsection "Using Several Lexical Analyzers for the Same Parser"
At any time during the parsing you can use the method
\&\f(CW\*(C`$parser\->YYLexer\*(C'\fR to set a new lexical analyzer.
.PP
The following grammar starts setting the lexer
to  sub \f(CW\*(C`Lexer1\*(C'\fR (line 44). It later changes
the lexer to \f(CW\*(C`Lexer2\*(C'\fR (ine 24)
after the token \f(CW\*(Aq%%\*(Aq\fR is seen. 
Inside \f(CW\*(C`Lexer2\*(C'\fR the token \f(CW\*(C`A\*(C'\fR represents a \f(CW\*(AqB\*(Aq\fR.
This capability
allows the parsing of languages where different sections 
require different lexical analysis. For example, in \f(CW\*(C`yacc\*(C'\fR,
carriage returns separates declarations in the header 
section but is considered a white space inside the
body and tail sections. This feature has 
similar power to the \fIstate\fR concept of the
lexical analyzer generator \f(CW\*(C`flex\*(C'\fR.
.PP
.Vb 10
\&  $ cat \-n twolexers.eyp 
\&     1  %%
\&     2  s:  first \*(Aq%%\*(Aq second
\&     3  ;
\&     4  
\&     5  first:
\&     6      A first
\&     7    | A
\&     8  ;
\&     9  
\&    10  second:
\&    11      A second
\&    12    | A
\&    13  ;
\&    14  
\&    15  %%
\&    16  
\&    17  sub Lexer1 {
\&    18      my($parser)=shift;
\&    19  
\&    20      print "In Lexer 1 \en";
\&    21      for (${$parser\->YYInput}) {
\&    22          m/\eG\es*/gc;
\&    23          m/\eG(%%)/gc and do {
\&    24            $parser\->YYLexer(\e&Lexer2);
\&    25            return ($1, undef);
\&    26          };
\&    27          m/\eG(.)/gcs and return($1,$1);
\&    28          return(\*(Aq\*(Aq, undef);
\&    29      }
\&    30  }
\&    31  
\&    32  sub Lexer2 {
\&    33      my($parser)=shift;
\&    34  
\&    35      print "In Lexer 2 \en";
\&    36      for (${$parser\->YYInput}) {
\&    37          m/\eG\es*/gc;
\&    38          m/\eGB/gc    and return(\*(AqA\*(Aq,\*(AqB\*(Aq);
\&    39          m/\eG(.)/gcs and die "Error. Expected \*(AqB\*(Aq, found $1\en";
\&    40      }
\&    41          return(\*(Aq\*(Aq, undef);
\&    42  }
\&    43  
\&    44  _\|_PACKAGE_\|_\->lexer(\e&Lexer1);
.Ve
.PP
When executed, it behaves like this:
.PP
.Vb 7
\&        $ ./twolexers.pm \-t \-i \-m 1 \-c \*(AqA A %% B B\*(Aq
\&        In Lexer 1 
\&        In Lexer 1 
\&        In Lexer 1 
\&        In Lexer 2 
\&        In Lexer 2 
\&        In Lexer 2 
\&
\&        s_is_first_second(
\&          first_is_A_first(
\&            TERMINAL[A],
\&            first_is_A(
\&              TERMINAL[A]
\&            )
\&          ),
\&          second_is_A_second(
\&            TERMINAL[B],
\&            second_is_A(
\&              TERMINAL[B]
\&            )
\&          )
\&        )
.Ve
.PP
The lexer can bechanged at any time. The following example
starts using the default lexer generated by \f(CW\*(C`eyapp\*(C'\fR.
It changes the lexer to \f(CW\*(C`Lexer2\*(C'\fRinside an intermediate semantic action (line 7).
Inside \f(CW\*(C`Lexer2\*(C'\fR  the token \f(CW\*(C`A\*(C'\fR is interpreted as a word \f(CW\*(C`\ew+\*(C'\fR.
.PP
.Vb 10
\&   $ cat \-n twolexers2.eyp 
\&     1  # Compile it with:
\&     2  # $ eyapp \-TC twolexers2.eyp 
\&     3  # Run it with:
\&     4  # $ ./twolexers2.pm \-t \-i \-c \*(AqA A %% d3 c2\*(Aq
\&     5  
\&     6  %%
\&     7  s:  first \*(Aq%%\*(Aq { $_[0]\->YYLexer(\e&Lexer2) } second
\&     8  ;
\&     9  
\&    10  first:
\&    11      A first
\&    12    | A
\&    13  ;
\&    14  
\&    15  second:
\&    16      A second
\&    17    | A
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Lexer2 {
\&    23      my($parser)=shift;
\&    24  
\&    25      print "In Lexer 2 \en";
\&    26      for (${$parser\->YYInput}) {
\&    27          m/\eG\es*/gc;
\&    28          m/\eG(\ew+)/gc    and return(\*(AqA\*(Aq,$1);
\&    29          m/\eG(.)/gcs and die "Error. Expected a word,Found $1\en";
\&    30      }
\&    31      return(\*(Aq\*(Aq, undef);
\&    32  }
.Ve
.SH "THE ERROR REPORT SUBROUTINE"
.IX Header "THE ERROR REPORT SUBROUTINE"
The Error Report subroutine is also a parser attribute, 
and must be defined. By default \f(CW\*(C`Parse::Eyapp\*(C'\fR
provides a convenient error handler.
.PP
See the Parse::Yapp pages and elsewhere documentation
on \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`bison\*(C'\fR for more information.
.SH "USING AN EYAPP GRAMMAR"
.IX Header "USING AN EYAPP GRAMMAR"
The following is an example of a program that uses the calculator explained 
in the two previous sections:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n usecalc.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Calc;
\&     4
\&     5  my $parser = Calc\->new();
\&     6  $parser\->input(\e<<\*(AqEOI\*(Aq
\&     7  a = 2*3       # 1: 6
\&     8  d = 5/(a\-6)   # 2: division by zero
\&     9  b = (a+1)/7   # 3: 1
\&    10  c=a*3+4)\-5    # 4: syntax error
\&    11  a = a+1       # 5: 7
\&    12  EOI
\&    13  );
\&    14  my $t = $parser\->Run();
\&    15  print "========= Symbol Table ==============\en";
\&    16  print "$_ = $t\->{$_}\en" for sort keys %$t;
.Ve
.PP
The output for this program is (the input for each output
appear as a Perl comment on the right):
.PP
.Vb 1
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
\&
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./usecalc.pl
\&  6
\&  Illegal division by zero.
\&  1
\&
\&  Syntax error near \*(Aq)\*(Aq (line number 4).
\&  Expected one of these terminals: \*(Aq\-\*(Aq \*(Aq/\*(Aq \*(Aq^\*(Aq \*(Aq*\*(Aq \*(Aq+\*(Aq \*(Aq
\&  \*(Aq
\&  7
\&  ========= Symbol Table ==============
\&  a = 7
\&  b = 1
\&  c = 22
.Ve
.SH "LISTS AND OPTIONALS"
.IX Header "LISTS AND OPTIONALS"
The elements of the right hand side of a production (abbreviated \fIrhs\fR) can be one of these:
.PP
.Vb 9
\&  rhselt:     
\&        symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
.Ve
.PP
The \f(CW\*(C`STAR\*(C'\fR, \f(CW\*(C`OPTION\*(C'\fR and \f(CW\*(C`PLUS\*(C'\fR operators provide a simple mechanism
to express lists:
.IP "\(bu" 4
In Eyapp the \f(CW\*(C`+\*(C'\fR operator indicates one or more repetitions of the element
to the left of \f(CW\*(C`+\*(C'\fR, thus a rule like:
.Sp
.Vb 1
\&                        decls:  decl +
.Ve
.Sp
is the same as:
.Sp
.Vb 2
\&                        decls:  decls decl 
\&                             |  decl
.Ve
.Sp
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
.Sp
.Vb 1
\&                       rhss: rule <+ \*(Aq|\*(Aq>
.Ve
.Sp
is equivalent to:
.Sp
.Vb 2
\&                       rhss: rhss \*(Aq|\*(Aq rule 
\&                           | rule
.Ve
.IP "\(bu" 4
The operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR have their usual meaning: 0 or more for
\&\f(CW\*(C`*\*(C'\fR and optionality for \f(CW\*(C`?\*(C'\fR. Is legal to parenthesize 
a \f(CW\*(C`rhs\*(C'\fR expression as in:
.Sp
.Vb 1
\&                       optname: (NAME IDENT)?
.Ve
.ie n .SS "The ""+"" operator"
.el .SS "The \f(CW+\fP operator"
.IX Subsection "The + operator"
The grammar:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat List3.yp 
\&  %semantic token \*(Aqc\*(Aq 
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  \*(Aqd\*(Aq+ 
\&             { 
\&                print Dumper($_[1]);
\&                print Dumper($_[2]);
\&             } 
\&  ;
\&  %%
.Ve
.PP
Is equivalent to:
.PP
.Vb 9
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-v List3.yp; head \-9 List3.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:  $start \-> S $end
\&  1:  PLUS\-1 \-> PLUS\-1 \*(Aqc\*(Aq
\&  2:  PLUS\-1 \-> \*(Aqc\*(Aq
\&  3:  PLUS\-2 \-> PLUS\-2 \*(Aqd\*(Aq
\&  4:  PLUS\-2 \-> \*(Aqd\*(Aq
\&  5:  S \-> PLUS\-1 PLUS\-2
.Ve
.PP
By default, the semantic action associated with a \f(CW\*(C`+\*(C'\fR returns the lists of attributes
to which the \f(CW\*(C`+\*(C'\fR applies:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = [ \*(Aqc\*(Aq, \*(Aqc\*(Aq ];
\&  $VAR1 = [ \*(Aqd\*(Aq, \*(Aqd\*(Aq ];
.Ve
.PP
Observe that, in spite of \f(CW\*(Aqd\*(Aq\fR being a syntactic token
the actions related with the \f(CW\*(C`d+\*(C'\fR element (i.e. the actions associated
with the \f(CW\*(C`PLUS\-2\*(C'\fR productions) create the list of \f(CW\*(C`d\*(C'\fRs.
.PP
The semantic associated with a \f(CW\*(C`+\*(C'\fR changes 
when one of the tree creation directives is active (for instance \f(CW%tree\fR or \f(CW%metatree\fR)
or it has been explicitly requested with a call to the \f(CW\*(C`YYBuildingTree\*(C'\fR method:
.PP
.Vb 1
\&                            $self\->YYBuildingTree(1);
.Ve
.PP
Other ways to change the associated semantic are to use the 
\&\f(CW\*(C`yybuildingtree\*(C'\fR option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 4
\&         $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&                           yybuildingtree => 1,
\&                         # yydebug => 0x1F
\&         );
.Ve
.PP
In such case the associated semantic action creates a node labelled
.PP
.Vb 1
\&                     _PLUS_LIST
.Ve
.PP
whose children are the attributes associated with the items in the plus list. 
As it happens when using the \f(CW%tree\fR directive, \fIsyntactic tokens\fR are skipped.
.PP
When executing the example above but under the \f(CW%tree\fR directive
the output changes. The \f(CW\*(C`\-T\*(C'\fR option tells the \f(CW\*(C`eyapp\*(C'\fR compiler
to introduce an implicit \f(CW%tree\fR directive>:
.PP
.Vb 1
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp \-T List3.yp
.Ve
.PP
If we now run the client program with input \f(CW\*(C`ccdd\*(C'\fR we get
a couple of syntax trees:
.PP
.Vb 9
\&  ~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.PP
The node associated with the list of \f(CW\*(C`d\*(C'\fRs is empty since
terminal \f(CW\*(C`d\*(C'\fR wasn't declared semantic.
.SS "When Nodes Disappear from Lists"
.IX Subsection "When Nodes Disappear from Lists"
When under the influence of the \f(CW%tree\fR directive
the action associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes don't show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat ListWithRefs1.eyp 
\&  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  D+ 
\&             { 
\&                print Dumper($_[1]);
\&                print $_[1]\->str."\en";
\&                print Dumper($_[2]);
\&                print $_[2]\->str."\en";
\&             } 
\&  ;
\&
\&  D: \*(Aqd\*(Aq
\&  ;
\&
\&  %%
\&
\&  sub Run {
\&    my ($self) = shift;
\&    return $self\->YYParse( yybuildingtree => 1 );
\&  }
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR (line 26).
.PP
The execution gives an output like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs1.eyp; ./use_listwithrefs1.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  _PLUS_LIST(TERMINAL,TERMINAL)
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq ); _PLUS_LIST
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
associated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.SS "Recovering the Missing Nodes"
.IX Subsection "Recovering the Missing Nodes"
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs.eyp
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:  \*(Aqc\*(Aq+  D+ 
\&     8        { 
\&     9           print Dumper($_[1]);
\&    10           print Dumper($_[2]);
\&    11        } 
\&    12  ;
\&    13  
\&    14  D: \*(Aqd\*(Aq
\&    15       {
\&    16         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&    17       }
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Run {
\&    23    my ($self) = shift;
\&    24    return $self\->YYParse( yybuildingtree => 1 );
\&    25  }
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs.eyp; ./use_listwithrefs.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.ie n .SS "Building a Tree with ""Parse::Eyapp::Node\->new"""
.el .SS "Building a Tree with \f(CWParse::Eyapp::Node\->new\fP"
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
The following execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the just created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  ~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explicitly constructed:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs2.eyp 
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:      \*(Aqc\*(Aq+  D+ 
\&     8             { 
\&     9                print Dumper($_[1]);
\&    10                print $_[1]\->str."\en";
\&    11                print Dumper($_[2]);
\&    12                print $_[2]\->str."\en";
\&    13             } 
\&    14  ;
\&    15  
\&    16  D: \*(Aqd\*(Aq.d
\&    17       {
\&    18         Parse::Eyapp::Node\->new(
\&    19           \*(AqDES(TERMINAL)\*(Aq, 
\&    20            sub { 
\&    21              my ($DES, $TERMINAL) = @_;
\&    22              $TERMINAL\->{attr} = $d;
\&    23            }
\&    24         );
\&    25       }
\&    26  ;
\&    27  
\&    28  %%
\&    29  
\&    30  sub Run {
\&    31    my ($self) = shift;
\&    32    return $self\->YYParse( yybuildingtree => 1 );
\&    33  }
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the section for \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  $ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.ie n .SS "The ""*"" operator"
.el .SS "The \f(CW*\fP operator"
.IX Subsection "The * operator"
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obviated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been suppressed.
.SS "Giving Names to Lists"
.IX Subsection "Giving Names to Lists"
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The grammar describes the language of sequences
.PP
.Vb 1
\&                  c,...,cd c,...,cd c,...,cd ....
.Ve
.PP
The right hand side of the production has only one term which is a list, 
but the factor to which the star applies is itself a list. 
We are naming the term with the name \f(CW\*(C`Cs_and_d\*(C'\fR and the factor with 
the name \f(CW\*(C`Cs\*(C'\fR.
.PP
The execution shows the renamed nodes:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ use_csbetweencommansanddwithnames.pl
\&  c,c,c,cd
\&
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.SS "Optionals"
.IX Subsection "Optionals"
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an \f(CW\*(C`_OPTIONAL\*(C'\fR
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.SS "Parenthesis"
.IX Subsection "Parenthesis"
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the \f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explicitly created
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or reverse derivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.SS "Actions Inside Parenthesis"
.IX Subsection "Actions Inside Parenthesis"
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SH "NAMES FOR ATTRIBUTES"
.IX Header "NAMES FOR ATTRIBUTES"
Attributes can be referenced by meaningful names using the \fIdot notation\fR
instead of using the classic error-prone positional approach:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdollar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SH "DEFAULT ACTIONS"
.IX Header "DEFAULT ACTIONS"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.SS "An Example of Default Action: Translator from Infix to Postfix"
.IX Subsection "An Example of Default Action: Translator from Infix to Postfix"
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.ie n .SS "Default Actions, %name and ""YYName"""
.el .SS "Default Actions, \f(CW%name\fP and \f(CWYYName\fP"
.IX Subsection "Default Actions, %name and YYName"
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  $ sed \-n \*(Aq29,50p\*(Aq YYNameDynamic.eyp | cat \-n
\&     1  exp:
\&     2              NUM   { $_[1] }
\&     3          |   VAR   { $_[1] }
\&     4          |   %name ASSIGN
\&     5              VAR \*(Aq=\*(Aq exp
\&     6          |   %name PLUS
\&     7              exp \*(Aq+\*(Aq exp
\&     8          |   %name MINUS
\&     9              exp \*(Aq\-\*(Aq exp
\&    10                {
\&    11                  my $self = shift;
\&    12                  $self\->YYName(\*(AqSUBTRACT\*(Aq); # rename it
\&    13                  $self\->YYBuildAST(@_); # build the node
\&    14                }
\&    15          |   %name TIMES
\&    16              exp \*(Aq*\*(Aq exp
\&    17          |   %name DIV
\&    18              exp \*(Aq/\*(Aq exp
\&    19          |   %name UMINUS
\&    20              \*(Aq\-\*(Aq exp %prec NEG
\&    21          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    22  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBTRACT\*(Aq )
\&  ];
.Ve
.SH "GRAMMAR REUSE"
.IX Header "GRAMMAR REUSE"
.SS "Reusing Grammars Using Inheritance"
.IX Subsection "Reusing Grammars Using Inheritance"
An method to reuse a grammar is via inheritance. 
The client inherits the generated parser module and expands it 
with methods that inherit or overwrite the actions.
Here is an example. Initially we have this Eyapp grammar:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n NoacInh.eyp
\&     1  %left   \*(Aq+\*(Aq
\&     2  %left   \*(Aq*\*(Aq
\&     3
\&     4  %defaultaction {
\&     5    my $self = shift;
\&     6
\&     7    my $action = $self\->YYName;
\&     8
\&     9    $self\->$action(@_);
\&    10  }
\&    11
\&    12  %%
\&    13  exp:        %name NUM
\&    14                NUM
\&    15          |   %name PLUS
\&    16                exp \*(Aq+\*(Aq exp
\&    17          |   %name TIMES
\&    18                exp \*(Aq*\*(Aq exp
\&    19          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    20                { $_[2] }
\&    21  ;
\&    22
\&    23  %%
\&    24
\&    25  sub _Error {
\&    26    my($token)=$_[0]\->YYCurval;
\&    27    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    28    my @expected = $_[0]\->YYExpect();
\&    29
\&    30    local $" = \*(Aq, \*(Aq;
\&    31    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    32  }
\&    33
\&    34
\&    35  my $x = \*(Aq\*(Aq;
\&    36
\&    37  sub _Lexer {
\&    38    my($parser)=shift;
\&    39
\&    40    for ($x) {
\&    41      s/^\es+//;
\&    42      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    43
\&    44      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    45      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    46      s/^(.)//s                    and return($1,$1);
\&    47    }
\&    48  }
\&    49
\&    50  sub Run {
\&    51    my($self)=shift;
\&    52    $x = shift;
\&    53    my $debug = shift;
\&    54
\&    55    $self\->YYParse(
\&    56      yylex => \e&_Lexer,
\&    57      yyerror => \e&_Error,
\&    58      yydebug => $debug,
\&    59    );
\&    60  }
.Ve
.PP
The following program defines two classes: \f(CW\*(C`CalcActions\*(C'\fR
that implements the actions for the calculator
and package \f(CW\*(C`PostActions\*(C'\fR that implements the actions
for the infix to postfix translation. This way we have an 
example that reuses the former grammar twice:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n icalcu_and_ipost.pl
\&     1  #!/usr/bin/perl \-w
\&     2  package CalcActions;
\&     3  use strict;
\&     4  use base qw{NoacInh};
\&     5
\&     6  sub NUM {
\&     7    return $_[1];
\&     8  }
\&     9
\&    10  sub PLUS {
\&    11    $_[1]+$_[3];
\&    12  }
\&    13
\&    14  sub TIMES {
\&    15    $_[1]*$_[3];
\&    16  }
\&    17
\&    18  package PostActions;
\&    19  use strict;
\&    20  use base qw{NoacInh};
\&    21
\&    22  sub NUM {
\&    23    return $_[1];
\&    24  }
\&    25
\&    26  sub PLUS {
\&    27    "$_[1] $_[3] +";
\&    28  }
\&    29
\&    30  sub TIMES {
\&    31    "$_[1] $_[3] *";
\&    32  }
\&    33
\&    34  package main;
\&    35  use strict;
\&    36
\&    37  my $calcparser = CalcActions\->new();
\&    38  print "Write an expression: ";
\&    39  my $x = <STDIN>;
\&    40  my $e = $calcparser\->Run($x);
\&    41
\&    42  print "$e\en";
\&    43
\&    44  my $postparser = PostActions\->new();
\&    45  my $p = $postparser\->Run($x);
\&    46
\&    47  print "$p\en";
.Ve
.PP
The subroutine used as default action in \f(CW\*(C`NoacInh.eyp\*(C'\fR is so useful 
that is packed as the Parse::Eyapp::Driver method 
\&\f(CW\*(C`YYDelegateaction\*(C'\fR.
.PP
See files \f(CW\*(C`examples/recycle/NoacYYDelegateaction.eyp\*(C'\fR
and \f(CW\*(C`examples/recycle/icalcu_and_ipost_yydel.pl\*(C'\fR
for an example of use of \f(CW\*(C`YYDelegateaction\*(C'\fR.
.SS "Reusing Grammars by Dynamic Substitution of Semantic Actions"
.IX Subsection "Reusing Grammars by Dynamic Substitution of Semantic Actions"
The methods \f(CW\*(C`YYSetaction\*(C'\fR and \f(CW\*(C`YYAction\*(C'\fR of the parser object provide a way
to selectively substitute some actions of a given grammar.
Let us consider once more a postfix to infix translator:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n PostfixWithActions.eyp
\&     1  # File PostfixWithActions.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6
\&     7  %%
\&     8  line: $exp  { print "$exp\en" }
\&     9  ;
\&    10
\&    11  exp:        $NUM
\&    12                  { $NUM }
\&    13          |   $VAR
\&    14                  { $VAR }
\&    15          |   %name ASSIGN
\&    16                VAR.left \*(Aq=\*(Aqexp.right
\&    17                  { "$_[3] &$_[1] ASSIGN"; }
\&    18          |   %name PLUS
\&    19                exp.left \*(Aq+\*(Aqexp.right
\&    20                  { "$_[1] $_[3] PLUS"; }
\&    21          |   %name MINUS
\&    22                exp.left \*(Aq\-\*(Aqexp.right
\&    23                  { "$_[1] $_[3] MINUS"; }
\&    24          |   %name TIMES
\&    25                exp.left \*(Aq*\*(Aqexp.right
\&    26                  { "$_[1] $_[3] TIMES"; }
\&    27          |   %name DIV
\&    28                exp.left \*(Aq/\*(Aqexp.right
\&    29                  { "$_[1] $_[3] DIV"; }
\&    30          |   %name NEG \*(Aq\-\*(Aq $exp %prec NEG
\&    31                  { "$exp NEG" }
\&    32          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq
\&    33                  { $exp }
\&    34  ;
\&    35
\&    36  %%
\&    37
\&    38  sub _Error {
\&    39    my($token)=$_[0]\->YYCurval;
\&    40    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    41    my @expected = $_[0]\->YYExpect();
\&    42
\&    43    local $" = \*(Aq, \*(Aq;
\&    44    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    45  }
\&    46
\&    47  my $x;
\&    48
\&    49  sub _Lexer {
\&    50    my($parser)=shift;
\&    51
\&    52    for ($x) {
\&    53      s/^\es+//;
\&    54      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    55
\&    56      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    57      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    58      s/^(.)//s                    and return($1,$1);
\&    59    }
\&    60  }
\&    61
\&    62  sub Run {
\&    63    my($self)=shift;
\&    64    $x = shift;
\&    65    $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    66      #yydebug => 0xFF
\&    67    );
\&    68  }
.Ve
.PP
The program \f(CW\*(C`rewritepostfixwithactions.pl\*(C'\fR uses the former grammar
to translate infix expressions to postfix expressions.
It also implements a calculator reusing the grammar in
\&\f(CW\*(C`PostfixWithActions.eyp\*(C'\fR. It does so using
the \f(CW\*(C`YYSetaction\*(C'\fR method.
The semantic actions for the productions named
.IP "\(bu" 2
\&\s-1ASSIGN\s0
.IP "\(bu" 2
\&\s-1PLUS\s0
.IP "\(bu" 2
\&\s-1TIMES\s0
.IP "\(bu" 2
\&\s-1DIV\s0
.IP "\(bu" 2
\&\s-1NEG\s0
.PP
are selectively substituted by the appropriate actions, while the other
semantic actions remain unchanged:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n rewritepostfixwithactions.pl
\&     1  #!/usr/bin/perl
\&     2  use warnings;
\&     3  use PostfixWithActions;
\&     4
\&     5  my $debug = shift || 0;
\&     6  my $pparser = PostfixWithActions\->new();
\&     7  print "Write an expression: ";
\&     8  my $x = <STDIN>;
\&     9
\&    10  # First, trasnlate to postfix ...
\&    11  $pparser\->Run($x, $debug);
\&    12
\&    13  # And then selectively substitute
\&    14  # some semantic actions
\&    15  # to obtain an infix calculator ...
\&    16  my %s;            # symbol table
\&    17  $pparser\->YYSetaction(
\&    18    ASSIGN => sub { $s{$_[1]} = $_[3] },
\&    19    PLUS   => sub { $_[1] + $_[3] },
\&    20    TIMES  => sub { $_[1] * $_[3] },
\&    21    DIV    => sub { $_[1] / $_[3] },
\&    22    NEG    => sub { \-$_[2] },
\&    23  );
\&    24
\&    25  $pparser\->Run($x, $debug);
.Ve
.PP
When running this program the output is:
.PP
.Vb 8
\&  examples/recycle$ ./rewritepostfixwithactions.pl
\&  Write an expression: 2*3+4
\&  2 3 TIMES 4 PLUS
\&  10
\&  examples/recycle$ rewritepostfixwithactions.pl
\&  Write an expression: a = 2*(b = 3+5)
\&  2 3 5 PLUS &b ASSIGN TIMES &a ASSIGN
\&  16
.Ve
.ie n .SH "ABSTRACT SYNTAX TREES: %tree AND %name"
.el .SH "ABSTRACT SYNTAX TREES: \f(CW%tree\fP AND \f(CW%name\fP"
.IX Header "ABSTRACT SYNTAX TREES: %tree AND %name"
.ie n .SS "%tree Default Names"
.el .SS "\f(CW%tree\fP Default Names"
.IX Subsection "%tree Default Names"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. Actually, the \f(CW%tree\fR directive is equivalent to a call
to the \f(CW\*(C`YYBuildAST\*(C'\fR method of the parser object.
.PP
Any production production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
can be named using a directive \f(CW\*(C`%name someclass\*(C'\fR.
.PP
When reducing by a production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
the \f(CW%tree\fR directive (i.e., the \f(CW\*(C`YYBuildAST\*(C'\fR method) 
builds an anonymous hash blessed in \f(CW\*(C`someclass\*(C'\fR.
The hash has an attribute \f(CW\*(C`children\*(C'\fR containing the references
to the \s-1AST\s0 trees associated with the symbols in the right hand
side \f(CW\*(C`X\*(C'\fR, C>Y>, etc.
.PP
If no explicit name was given to the production rule,
\&\f(CW\*(C`YYBuildAST\*(C'\fR blesses the node in the class name resulting 
from the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,27p\*(Aq treewithoutnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&         NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&      | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
\&
\&    %%
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ ./treewithoutnames.pl
\&
\&  ************
\&  _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
\&  ************
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR setting the \f(CW\*(C`outputfile\*(C'\fR
of \f(CW\*(C`Parse::Eyapp\*(C'\fR:
.PP
.Vb 6
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>9,      # String $grammar starts at line 9 (for error diagnostics)
\&    outputfile=>\*(Aqtreewithoutnames\*(Aq
\&  );
.Ve
.PP
The grammar with the expanded rules appears in the \f(CW\*(C`.output\*(C'\fR file:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> line $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&  2:      PLUS\-1 \-> exp
\&  3:      line \-> PLUS\-1
\&  4:      exp \-> NUM
\&  5:      exp \-> VAR
\&  6:      exp \-> VAR \*(Aq=\*(Aq exp
\&  7:      exp \-> exp \*(Aq+\*(Aq exp
\&  8:      exp \-> exp \*(Aq\-\*(Aq exp
\&  9:      exp \-> exp \*(Aq*\*(Aq exp
\&  10:     exp \-> exp \*(Aq/\*(Aq exp
\&  11:     exp \-> \*(Aq\-\*(Aq exp
\&  12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.ie n .SS "%tree Giving Explicit Names"
.el .SS "\f(CW%tree\fP Giving Explicit Names"
.IX Subsection "%tree Giving Explicit Names"
A production rule can be \fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive.  For
each production rule a namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR 
\&\fIis the name of the associated package\fR.  Therefore, by modifying the former
grammar with additional \f(CW%name\fR directives:
.PP
.Vb 7
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&        %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&      | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&      | %name DIV    exp \*(Aq/\*(Aq exp
\&      | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
.Ve
.PP
we are explicitly naming the productions. Thus, all the node instances 
corresponding to the production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. 
Now the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ ./treewithnames.pl
\&
\&  ************
\&  EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
\&  ************
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.SS "\s-1TERMINAL\s0 Nodes"
.IX Subsection "TERMINAL Nodes"
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the tokens provided by the lexical
analyzer.  \f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol than Parse::Yapp for
communication between the parser and the lexical analyzer: A couple \f(CW\*(C`($token,
$attribute)\*(C'\fR is returned by the lexical analyzer.  These values are stored
under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.  \f(CW\*(C`TERMINAL\*(C'\fR nodes as all
\&\f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost
always \- empty.
.ie n .SS "Explicit Actions Inside %tree"
.el .SS "Explicit Actions Inside \f(CW%tree\fP"
.IX Subsection "Explicit Actions Inside %tree"
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.ie n .SS "Explicitly Building Nodes With ""YYBuildAST"""
.el .SS "Explicitly Building Nodes With \f(CWYYBuildAST\fP"
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation (see
file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
inside \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-n \*(Aq397,408p\*(Aq lib/Simple/Types.eyp
\&  Variable:
\&      %name VAR
\&      ID
\&    | %name  VARARRAY
\&      $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&        {
\&          my $self = shift;
\&          my $node =  $self\->YYBuildAST(@_);
\&          $node\->{line} = $ID\->[1];# $_[1]\->[1]
\&          return $node;
\&        }
\&  ;
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.ie n .SS "Returning non References Under %tree"
.el .SS "Returning non References Under \f(CW%tree\fP"
.IX Subsection "Returning non References Under %tree"
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to suppress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,17p\*(Aq returnnonode.yp | cat \-n
\&     1  %tree
\&     2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     3  %%
\&     4  S:    %name EMPTY
\&     5          /* empty */
\&     6      | %name AES
\&     7          S A
\&     8      | %name BES
\&     9          S B
\&    10  ;
\&    11  A : %name A
\&    12        \*(Aqa\*(Aq
\&    13  ;
\&    14  B : %name B
\&    15        \*(Aqb\*(Aq { }
\&    16  ;
\&    17  %%
.Ve
.PP
since the action at line 15 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\&  $ usereturnnonode.pl
\&  ababa
\&  AES(BES(AES(BES(AES(EMPTY,A(TERMINAL[a]))),A(TERMINAL[a]))),A(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.ie n .SS "Intermediate actions and %tree"
.el .SS "Intermediate actions and \f(CW%tree\fP"
.IX Subsection "Intermediate actions and %tree"
Intermediate actions can be used to change the shape of the \s-1AST \s0(prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,15p\*(Aq intermediateactiontree.yp | cat \-n
\&     1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     2  %tree bypass
\&     3  %%
\&     4  S:    %name EMPTY
\&     5         /* empty */
\&     6      | %name SA
\&     7         S A.f { $f\->{attr} = "A"; $f; } A
\&     8      | %name SB
\&     9         S B.f { $f\->{attr} = "B"; $f; } B
\&    10  ;
\&    11  A : %name A \*(Aqa\*(Aq
\&    12  ;
\&    13  B : %name B \*(Aqb\*(Aq
\&    14  ;
\&    15  %%
.Ve
.PP
See the client program:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
.Ve
.PP
When it runs produces this output:
.PP
.Vb 3
\&  $ useintermediateactiontree.pl
\&  aabbaa
\&  SA(SB(SA(EMPTY,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.SS "Syntactic and Semantic tokens"
.IX Subsection "Syntactic and Semantic tokens"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR differences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the section Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 10
\&  $ cat \-n synopsis.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Parse::Eyapp::Treeregexp;
\&     5
\&     6  sub TERMINAL::info {
\&     7    $_[0]{attr}
\&     8  }
\&     9
\&    10  my $grammar = q{
\&    11    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    12    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    13    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    14    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    15    %tree           # Let us build an abstract syntax tree ...
\&    16
\&    17    %%
\&    18    line:
\&    19        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&    20          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    21    ;
\&    22
\&    23    /* The %name directive defines the name of the class */
\&    24    exp:
\&    25        %name NUM
\&    26        NUM
\&    27      | %name VAR
\&    28        VAR
\&    29      | %name ASSIGN
\&    30        VAR \*(Aq=\*(Aq exp
\&    31      | %name PLUS
\&    32        exp \*(Aq+\*(Aq exp
\&    33      | %name MINUS
\&    34        exp \*(Aq\-\*(Aq exp
\&    35      | %name TIMES
\&    36        exp \*(Aq*\*(Aq exp
\&    37      | %name DIV
\&    38        exp \*(Aq/\*(Aq exp
\&    39      | %name UMINUS
\&    40        \*(Aq\-\*(Aq exp %prec NEG
\&    41      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    42          { $_[2] }  /* Let us simplify a bit the tree */
\&    43    ;
\&    44
\&    45    %%
\&    46    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&    47
\&    48    sub _Lexer {
\&    49      my($parser)=shift; # The parser object
\&    50
\&    51      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&    52        m{\eG\es+}gc;
\&    53        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    54        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&    55        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&    56        m{\eG(.)}gcs and return($1,$1);
\&    57      }
\&    58      return(\*(Aq\*(Aq,undef);
\&    59    }
\&    60
\&    61    sub Run {
\&    62        my($self)=shift;
\&    63        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    64    }
\&    65  }; # end grammar
\&    66
\&    67  our (@all, $uminus);
\&    68
\&    69  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    70    input=>$grammar,
\&    71    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    72    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&    73  );
\&    74  my $parser = Calc\->new();                # Create a parser
\&    75  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&    76  my $t = $parser\->Run;                    # Parse it!
\&    77  local $Parse::Eyapp::Node::INDENT=2;
\&    78  print "Syntax Tree:",$t\->str;
\&    79
\&    80  # Let us transform the tree. Define the tree\-regular expressions ..
\&    81  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    82      { #  Example of support code
\&    83        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&    84      }
\&    85      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&    86        => {
\&    87          my $op = $Op{ref($bin)};
\&    88          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&    89          $_[0] = $NUM[0];
\&    90        }
\&    91      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&    92      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    93      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    94    },
\&    95    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&    96  );
\&    97  $p\->generate(); # Create the tranformations
\&    98
\&    99  $t\->s($uminus); # Transform UMINUS nodes
\&   100  $t\->s(@all);    # constant folding and mult. by zero
\&   101
\&   102  local $Parse::Eyapp::Node::INDENT=0;
\&   103  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESSION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESSION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifier, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST.\s0
.SS "Changing the Status of a Token"
.IX Subsection "Changing the Status of a Token"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.SS "Saving the Information of Syntactic Tokens in their Father"
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR
in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.ie n .SS "The  ""bypass"" clause and the ""%no bypass"" directive"
.el .SS "The  \f(CWbypass\fP clause and the \f(CW%no bypass\fP directive"
.IX Subsection "The bypass clause and the %no bypass directive"
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \s-1SYNOPSIS\s0 example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.ie n .SS "The ""alias"" clause of the %tree directive"
.el .SS "The \f(CWalias\fP clause of the \f(CW%tree\fP directive"
.IX Subsection "The alias clause of the %tree directive"
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dollar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods will provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
The \f(CW%prefix\fR directive used in line 7 of the following example
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix: \f(CW\*(C`R::S::\*(C'\fR in this example.
.PP
.Vb 10
\& cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    ..    ....
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
The tree \f(CW$t\fR for the expression \f(CW"a = \-(2*3+5\-1)\en"\fR is:
.PP
.Vb 9
\&  R::S::ASSIGN(
\&     R::S::TERMINAL,
\&     R::S::UMINUS(
\&       R::S::MINUS(
\&         R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM),
\&         R::S::NUM
\&       )
\&     )
\&  )
.Ve
.PP
The \f(CW\*(C`R::S::ASSIGN\*(C'\fR class has methods \f(CW\*(C`VAR\*(C'\fR (see line 89 above)
and \f(CW\*(C`exp\*(C'\fR (see lines 91 and 93) to refer to its two children. 
The result of the execution is:
.PP
.Vb 6
\&  $ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.PP
As a second example of the use of \f(CW%alias\fR, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST.\s0
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
\&
\& CalcwithAttributeGrammar.pl
.Ve
.PP
The program computes the tree for expression for expression
\&\f(CW\*(C`a = \-(2*3+5\-1)\*(C'\fR which is:
.PP
.Vb 1
\&  ASSIGN(TERMINAL,UMINUS(MINUS(PLUS(TIMES(NUM,NUM),NUM),NUM)))
.Ve
.PP
The children of the binary nodes can be accessed through the \f(CW\*(C`left\*(C'\fR
and \f(CW\*(C`right\*(C'\fR methods.
.SS "About the Encapsulation of Nodes"
.IX Subsection "About the Encapsulation of Nodes"
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
.SH "SOLVING CONFLICTS WITH THE \fIPOSTPONED CONFLICT\fP STRATEGY"
.IX Header "SOLVING CONFLICTS WITH THE POSTPONED CONFLICT STRATEGY"
Yacc-like parser generators provide ways to solve shift-reduce mechanims
based on token precedence. No mechanisms are provided for the resolution
of reduce-reduce conflicts. The solution for such kind of conflicts is to modify
the grammar. The strategy We present here provides a way to broach conflicts
that can't be solved using static precedences.
.SS "The \fIPostponed Conflict Resolution\fP Strategy"
.IX Subsection "The Postponed Conflict Resolution Strategy"
The \fIpostponed conflict strategy\fR presented here can be used whenever there 
is a shift-reduce or reduce-reduce conflict that can not be solved using static 
precedences.
.SS "\fIPostponed Conflict Resolution\fP: Reduce-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Reduce-Reduce Conflicts"
Let us assume we have a reduce-reduce conflict between to productions
.PP
.Vb 2
\&                      A \-> alpha .
\&                      B \-> beta .
.Ve
.PP
for some token \f(CW\*(C`@\*(C'\fR. Let also assume that production
.PP
.Vb 1
\&                      A \-> alpha
.Ve
.PP
has name \f(CW\*(C`ruleA\*(C'\fR and production
.PP
.Vb 1
\&                      B \-> beta
.Ve
.PP
has name \f(CW\*(C`ruleB\*(C'\fR.
.PP
The postponed conflict resolution strategy consists
in modifying the conflictive grammar by marking the points where the  conflict occurs
with the new \f(CW%PREC\fR directive. In this case at then end of the involved productions:
.PP
.Vb 2
\&                      A \-> alpha %PREC IsAorB 
\&                      B \-> beta  $PREC IsAorB
.Ve
.PP
The \f(CW\*(C`IsAorB\*(C'\fR identifier is called the \fIconflict name\fR.
.PP
Inside the head section, the programmer associates with the 
conflict name a code
whose mission is to solve the conflict by dynamically changing the
parsing table like this:
.PP
.Vb 2
\&                     %conflict IsAorB {
\&                          my $self = shift;
\&
\&                          if (looks_like_A($self)) {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleA\*(Aq );
\&                          }
\&                          else {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleB\*(Aq );
\&                          }
\&                       }
.Ve
.PP
The code associated with the \fIconflict name\fR
receives the name of \fI conflict handler\fR.
The code of \f(CW\*(C`looks_like_A\*(C'\fR stands for some form of nested parsing
which will decide which production applies.
.SS "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
.IX Subsection "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
In file \f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR we apply the postponed conflict resolution strategy
to the reduce reduce conflict that arises in Extended Pascal between the declaration of ranges and
the declaration of enumerated types (see section \*(L"Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal\*(R").
Here is the solution:
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ cat \-n pascalenumeratedvsrangesolvedviadyn.eyp
\&     1  %{
\&     2  =head1 SYNOPSIS
\&     3  
\&     4  See 
\&     5  
\&     6  =over 2
\&     7  
\&     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
\&     9  
\&    10  =item * The Bison manual L<http://www.gnu.org/software/bison/manual/html_mono/bison.html>
\&    11  
\&    12  =back
\&    13  
\&    14  Compile it with:
\&    15  
\&    16              eyapp \-b \*(Aq\*(Aq pascalenumeratedvsrangesolvedviadyn.eyp
\&    17  
\&    18  run it with this options:
\&    19  
\&    20              ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&    21  
\&    22  Try these inputs:
\&    23  
\&    24                  type r = (x) ..  y ;
\&    25                  type r = (x+2)*3 ..  y/2 ;
\&    26                  type e = (x, y, z);
\&    27                  type e = (x);
\&    28  
\&    29  =cut
\&    30  
\&    31  use base q{DebugTail}; 
\&    32  
\&    33  my $ID = qr{[A\-Za\-z][A\-Za\-z0\-9_]*};
\&    34               # Identifiers separated by commas
\&    35  my $IDLIST = qr{ \es*(?:\es*,\es* $ID)* \es* }x;
\&    36               # list followed by a closing par and a semicolon 
\&    37  my $RESTOFLIST = qr{$IDLIST \e) \es* ; }x;
\&    38  %}
\&    39  
\&    40  %namingscheme {
\&    41    #Receives a Parse::Eyapp object describing the grammar
\&    42    my $self = shift;
\&    43  
\&    44    $self\->tokennames(
\&    45      \*(Aq(\*(Aq => \*(AqLP\*(Aq,
\&    46      \*(Aq..\*(Aq => \*(AqDOTDOT\*(Aq,
\&    47      \*(Aq,\*(Aq => \*(AqCOMMA\*(Aq,
\&    48      \*(Aq)\*(Aq => \*(AqRP\*(Aq,
\&    49      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    50      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    51      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    52      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    53    );
\&    54  
\&    55    # returns the handler that will give names
\&    56    # to the right hand sides
\&    57    \e&give_rhs_name;
\&    58  }
\&    59  
\&    60  %strict
\&    61  
\&    62  %token ID NUM DOTDOT TYPE
\&    63  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    64  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    65  
\&    66  %tree
\&    67  
\&    68  %%
\&    69  
\&    70  type_decl : TYPE ID \*(Aq=\*(Aq type \*(Aq;\*(Aq
\&    71  ;
\&    72  
\&    73  type : 
\&    74        %name ENUM
\&    75        \*(Aq(\*(Aq id_list \*(Aq)\*(Aq
\&    76      | %name RANGE
\&    77        expr DOTDOT expr
\&    78  ;
\&    79  
\&    80  id_list : 
\&    81        %name EnumID
\&    82        ID rangeORenum
\&    83      | id_list \*(Aq,\*(Aq ID
\&    84  ;
\&    85  
\&    86  expr : \*(Aq(\*(Aq expr \*(Aq)\*(Aq
\&    87      | expr \*(Aq+\*(Aq expr
\&    88      | expr \*(Aq\-\*(Aq expr
\&    89      | expr \*(Aq*\*(Aq expr
\&    90      | expr \*(Aq/\*(Aq expr
\&    91      | %name RangeID
\&    92        ID rangeORenum
\&    93      | NUM
\&    94  ;
\&    95  
\&    96  rangeORenum: /* empty: postponed conflict resolution */
\&    97        {
\&    98            my $parser = shift;
\&    99            if (${$parser\->input()} =~ m{\eG(?= $RESTOFLIST)}gcx) {
\&   100                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqEnumID\*(Aq );
\&   101              }
\&   102              else {
\&   103                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqRangeID\*(Aq );
\&   104              }
\&   105        }
\&   106  ;
\&   107  
\&   108  %%
\&   109  
\&   110  _\|_PACKAGE_\|_\->lexer(
\&   111    sub {
\&   112      my $parser = shift;
\&   113  
\&   114      for (${$parser\->input()}) {    # contextualize
\&   115        m{\eG(\es*)}gc;
\&   116        $parser\->tokenline($1 =~ tr{\en}{});
\&   117  
\&   118        m{\eGtype\eb}gic                 and return (\*(AqTYPE\*(Aq, \*(AqTYPE\*(Aq);
\&   119  
\&   120        m{\eG($ID)}gc                   and return (\*(AqID\*(Aq,  $1);
\&   121  
\&   122        m{\eG([0\-9]+)}gc                and return (\*(AqNUM\*(Aq, $1);
\&   123  
\&   124        m{\eG\e.\e.}gc                    and return (\*(AqDOTDOT\*(Aq,  \*(Aq..\*(Aq);
\&   125  
\&   126        m{\eG(.)}gc                     and return ($1,    $1);
\&   127  
\&   128        return(\*(Aq\*(Aq,undef);
\&   129      }
\&   130    }
\&   131  );
\&   132  
\&   133  unless (caller()) {
\&   134    $Parse::Eyapp::Node::INDENT = 1;
\&   135    my $prompt = << \*(AqEOP\*(Aq;
\&   136  Try this input:
\&   137      type 
\&   138      r
\&   139      =
\&   140      (x)
\&   141      ..
\&   142      y
\&   143      ;
\&   144  
\&   145  Here other inputs you can try:
\&   146  
\&   147      type r = (x+2)*3 ..  y/2 ;
\&   148      type e = (x, y, z);
\&   149      type e = (x);
\&   150  
\&   151  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&   152  EOP
\&   153    _\|_PACKAGE_\|_\->main($prompt); 
\&   154  }
.Ve
.PP
This example also illustrates how to modify the default production
naming schema. Follows the result of several executions:
.PP
.Vb 9
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type r = (x+2)*3 ..  y/2 ;
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[r],
\&    RANGE(
\&      expr_is_expr_TIMES_expr(
\&        expr_is_LP_expr_RP(
\&          expr_is_expr_PLUS_expr(
\&            RangeID(
\&              TERMINAL[x]
\&            ),
\&            expr_is_NUM(
\&              TERMINAL[2]
\&            )
\&          )
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[3]
\&        )
\&      ),
\&      TERMINAL[..],
\&      expr_is_expr_DIV_expr(
\&        RangeID(
\&          TERMINAL[y]
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[2]
\&        )
\&      )
\&    )
\&  )
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type e = (x);
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[e],
\&    ENUM(
\&      EnumID(
\&        TERMINAL[x]
\&      )
\&    )
\&  )
.Ve
.SS "\fIPostponed Conflict Resolution\fP: Shift-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Shift-Reduce Conflicts"
The program in \f(CW\*(C`examples/debuggingtut/DynamicallyChangingTheParser2.eyp\*(C'\fR illustrates how the postponed
conflict strategy is used for shift-reduce conflicts.
This is an extension of the grammar in \f(CW\*(C`examples/debuggingtut/Debug.eyp\*(C'\fR.
The generated language is constituted by sequences like:
.PP
.Vb 1
\&    { D; D; S; S; S; } {D; S} { S }
.Ve
.PP
As you remember the conflict was:
.PP
.Vb 2
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/^St.*13:/,/^St.*14/p\*(Aq DynamicallyChangingTheParser.output  
\&  State 13:
\&
\&      ds \-> D conflict . \*(Aq;\*(Aq ds   (Rule 6)
\&      ds \-> D conflict .  (Rule 7)
\&
\&      \*(Aq;\*(Aq shift, and go to state 16
\&
\&      \*(Aq;\*(Aq [reduce using rule 7 (ds)]
\&
\&  State 14:
.Ve
.PP
The \f(CW\*(C`conflict\*(C'\fR handler below sets the \s-1LR\s0 action
to reduce by the production with name \f(CW\*(C`D1\*(C'\fR
.PP
.Vb 1
\&                 ds \-> D
.Ve
.PP
in the presence of token \f(CW\*(Aq;\*(Aq\fR if indeed is the last \f(CW\*(AqD\*(Aq\fR, that is, if:
.PP
.Vb 1
\&       ${$self\->input()} =~ m{^\es*;\es*S}
.Ve
.PP
Otherwise we set the \f(CW\*(C`shift\*(C'\fR action via a call to the 
\&\f(CW\*(C`YYSetShift\*(C'\fR method.
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq30,$p\*(Aq DynamicallyChangingTheParser.eyp | cat \-n
\&     1  %token D S
\&     2  
\&     3  %tree bypass
\&     4  
\&     5  # Expect just 1 shift\-reduce conflict
\&     6  %expect 1 
\&     7  
\&     8  %%
\&     9  p: %name PROG
\&    10      block +
\&    11  ;
\&    12  
\&    13  block:
\&    14      %name BLOCK_DS
\&    15      \*(Aq{\*(Aq ds \*(Aq;\*(Aq ss \*(Aq}\*(Aq 
\&    16    | %name BLOCK_S
\&    17      \*(Aq{\*(Aq ss \*(Aq}\*(Aq
\&    18  ;
\&    19  
\&    20  ds:
\&    21      %name D2
\&    22      D conflict \*(Aq;\*(Aq ds    
\&    23    | %name D1
\&    24      D conflict        
\&    25  ;
\&    26  
\&    27  ss:
\&    28      %name S2
\&    29      S \*(Aq;\*(Aq ss      
\&    30    | %name S1
\&    31      S       
\&    32  ;
\&    33  
\&    34  conflict:
\&    35        /* empty. This action solves the conflict using dynamic precedence */
\&    36        {
\&    37          my $self = shift;
\&    38  
\&    39          if (${$self\->input()} =~ m{^\es*;\es*S}) {
\&    40            $self\->YYSetReduce(\*(Aq;\*(Aq, \*(AqD1\*(Aq )
\&    41          }
\&    42          else {
\&    43            $self\->YYSetShift(\*(Aq;\*(Aq)
\&    44          }
\&    45  
\&    46          undef; # skip this node in the AST
\&    47        }
\&    48  ;
\&    49  
\&    50  %%
\&    51  
\&    52  my $prompt = \*(AqProvide a statement like "{D; S} {D; D; S}" and press <CR><CTRL\-D>: \*(Aq;
\&    53  _\|_PACKAGE_\|_\->main($prompt) unless caller;
.Ve
.SH "NAMING SCHEMES"
.IX Header "NAMING SCHEMES"
Explicit names can be given to grammar productions
via the \f(CW%name\fR directive. An alternative to explicitly gave 
names to rules is to define a \fInaming scheme\fR via the Eyapp directive
\&\f(CW%namingscheme\fR. This can be helpful when you inherit a large grammar
and want to quickly build a parser. The \s-1ANSI C\s0 parser in 
\&\f(CW\*(C`examples/languages/C/ansic.eyp\*(C'\fR is a good example. Another
example is the Pascal parser in \f(CW\*(C`examples/languages/pascal/pascal.eyp\*(C'\fR.
.PP
The Eyapp directive \f(CW%namingscheme\fR is followed by some Perl code. Such Perl
code must return a reference to a subroutine that will be called each time a new
production right hand side is parsed. The subroutine returns the name for the production.
.PP
The Perl code defining the handler receives a \f(CW\*(C`Parse::Eyapp\*(C'\fR object
that describes the grammar. The code after the \f(CW%namingscheme\fR
directive is evaluated during the early phases of the compilation of the input 
grammar. As an example of how to set a naming scheme, 
see lines 22\-38 below (you can find this example and others in the directory
\&\f(CW\*(C`examples/naming\*(C'\fR of the accompanying distribution):
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ cat \-n GiveNamesToCalc.eyp
\&     1  # GiveNamesToCalc.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6  %right  \*(Aq^\*(Aq
\&     7
\&     8  %tree bypass
\&     9
\&    10  %{
\&    11  use base q{Tail};
\&    12
\&    13  sub exp_is_NUM::info {
\&    14    my $self = shift;
\&    15
\&    16    $self\->{attr}[0];
\&    17  }
\&    18
\&    19  *exp_is_VAR::info = *var_is_VAR::info = \e&exp_is_NUM::info;
\&    20  %}
\&    21
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
\&    39  %%
\&    40
\&    41  line:
\&    42      exp
\&    43  ;
\&    44
\&    45  exp:
\&    46      NUM
\&    47    | VAR
\&    48    | var \*(Aq=\*(Aq exp
\&    49    | exp \*(Aq+\*(Aq exp
\&    50    | exp \*(Aq\-\*(Aq exp
\&    51    | exp \*(Aq*\*(Aq exp
\&    52    | exp \*(Aq/\*(Aq exp
\&    53    | %no bypass exp_is_NEG
\&    54       \*(Aq\-\*(Aq exp %prec NEG
\&    55    | exp \*(Aq^\*(Aq exp
\&    56    | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    57  ;
\&    58
\&    59  var:
\&    60      VAR
\&    61  ;
\&    62  %%
\&    63
\&    64  unless (caller) {
\&    65    my $t = _\|_PACKAGE_\|_\->main(@ARGV);
\&    66    print $t\->str."\en";
\&    67  }
.Ve
.PP
The example uses a naming scheme that is provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR: \f(CW\*(C`Parse::Eyapp::Grammar::give_token_name\*(C'\fR.
The current provided naming schemes handlers are:
.IP "\(bu" 2
\&\f(CW\*(C`give_default_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule
concatenated with an underscore and the index of the production
.IP "\(bu" 2
\&\f(CW\*(C`give_lhs_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule (this
is the naming scheme used by the \f(CW%tree\fR directive when no explicit name was given)
.IP "\(bu" 2
\&\f(CW\*(C`give_token_name\*(C'\fR: The name of the production is the Left Hand Side of the Production Rule followed by the 
word \f(CW\*(C`_is_\*(C'\fR followed by the concatenation of the names of the tokens in the right and side (separated by underscores).
.PP
All of these handlers are implemented inside the class \f(CW\*(C`Parse::Eyapp::Grammar\*(C'\fR. There is no need at line 
37 to explicit the class name prefix since the naming scheme code is evaluated inside such class:
.PP
.Vb 10
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
.Ve
.PP
As it is illustrated in this example, the method \f(CW\*(C`tokennames\*(C'\fR of \f(CW\*(C`Parse::Eyapp\*(C'\fR
objects provide a way to give identifier names to tokens that are defined by strings.
When we execute the former module/program (modulino) with input \f(CW\*(C`a=2*\-3\*(C'\fR we got the following
output:
.PP
.Vb 5
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ eyapp \-b \*(Aq\*(Aq GiveNamesToCalc.eyp
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ ./GiveNamesToCalc.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a=2*\-3
\&  line_is_exp(var_is_VAR[a],exp_is_TIMES(exp_is_NUM[2],exp_is_NEG(exp_is_NUM[3])))
.Ve
.PP
For each production rule the handler is called with arguments:
.IP "\(bu" 2
the \f(CW\*(C`Parse::Eyapp\*(C'\fR object,
.IP "\(bu" 2
the production index (inside the grammar),
.IP "\(bu" 2
the left hand side
symbol and a reference to a list with the symbols in the right hand side.
.PP
The following code of some version of \f(CW\*(C`give_token_name\*(C'\fR exemplifies how a
naming scheme handler can be written:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp$ sed \-ne \*(Aq101,132p\*(Aq lib/Parse/Eyapp/Grammar.pm | cat \-n
\&     1  sub give_token_name {
\&     2    my ($self, $index, $lhs, $rhs) = @_;
\&     3
\&     4    my @rhs = @$rhs;
\&     5    $rhs = \*(Aq\*(Aq;
\&     6
\&     7    unless (@rhs) { # Empty RHS
\&     8      return $lhs.\*(Aq_is_empty\*(Aq;
\&     9    }
\&    10
\&    11    my $names = $self\->{GRAMMAR}{TOKENNAMES} || {};
\&    12    for (@rhs) {
\&    13      if ($self\->is_token($_)) {
\&    14        s/^\*(Aq(.*)\*(Aq$/$1/;
\&    15        my $name = $names\->{$_} || \*(Aq\*(Aq;
\&    16        unless ($name) {
\&    17          $name = $_ if /^\ew+$/;
\&    18        }
\&    19        $rhs .= "_$name" if $name;
\&    20      }
\&    21    }
\&    22
\&    23    unless ($rhs) { # no \*(Aqword\*(Aq tokens in the RHS
\&    24      for (@rhs) {
\&    25        $rhs .= "_$_" if /^\ew+$/;
\&    26      }
\&    27    }
\&    28
\&    29    # check if another production with such name exists?
\&    30    my $name = $lhs.\*(Aq_is\*(Aq.$rhs;
\&    31    return $name;
\&    32  }
.Ve
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 2546:" 4
.IX Item "Around line 2546:"
Non-ASCII character seen before =encoding in 'va\*'lida\en";'. Assuming \s-1ISO8859\-1\s0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Scope.3pm                      0100644 0001750 0001750 00000062066 12566242263 024726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Scope 3"
.TH Parse::Eyapp::Scope 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Scope \- Support for Scope Analysis
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  # Fragment of the grammar lib/Simple/Types.eyp
\&  # in examples/typechecking/Simple\-Types\-XXX.tar.gz 
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         my $st = $block\->{symboltable}; 
\&         my @decs = $params\->children(); 
\&         $block\->{parameters} = [];
\&         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
\&             $bt = ref($bt); # The string \*(AqINT\*(Aq, \*(AqCHAR\*(Aq, etc.
\&             my $name = $id\->{attr}[0];
\&             my $type = build_type($bt, $arrspec);
\&             $type{$type} = Parse::Eyapp::Node\->hnew($type); 
\&
\&             # control duplicated declarations
\&               die "Duplicated declaration of $name at line $id\->{attr}[1]\en" 
\&             if exists($st\->{$name});
\&
\&             $st\->{$name}\->{type} = $type;
\&             $st\->{$name}\->{param} = 1;
\&             $st\->{$name}\->{line} = $id\->{attr}[1];
\&             push @{$block\->{parameters}}, $name;
\&         }
\&         $block\->{function_name} = $ID;
\&         $block\->type("FUNCTION");
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
\& 
\&  ...
\&
\&  Primary:
\&      %name INUM
\&      INUM 
\&    | %name CHARCONSTANT
\&      CHARCONSTANT
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | \*(Aq(\*(Aq expression \*(Aq)\*(Aq { $_[2] }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The examples used in this document can be found in the
file \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR.
This distribution contains the front-end of a compiler
(lexical analysis, syntax analysis, scope analysis and type checking) for
a small subset of the C language.
The language has characters, integers, arrays and functions.
Here is a small example:
.PP
.Vb 2
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ cat prueba03.c
\&  int a,b,e[10];
\&
\&  g() {}
\&
\&  int f(char c) {
\&  char d;
\&   c = \*(AqX\*(Aq;
\&   e[d] = \*(AqA\*(Aq+c;
\&   {
\&     int d;
\&     d = a + b;
\&   }
\&   a = b * 2;
\&   return c;
\&  }
.Ve
.PP
You can find more examples in the \f(CW\*(C`script/\*(C'\fR directory.
The front-end provided analyzes the input program
.PP
.Vb 1
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ usetypes.pl prueba03.c
.Ve
.PP
and produces the decorated abstract tree, i.e. s.t. like:
.PP
.Vb 10
\&  PROGRAM^{0}(
\&    FUNCTION[g]^{1},
\&    FUNCTION[f]^{2}(
\&      ASSIGNCHAR(
\&        VAR( TERMINAL[c:7]),
\&        CHARCONSTANT( TERMINAL[\*(AqX\*(Aq:7])
\&      ),
\&      ASSIGNINT(
\&        VARARRAY( TERMINAL[e:8], INDEXSPEC(CHAR2INT(VAR(TERMINAL[d:8])))),
\&        PLUS(
\&          CHAR2INT(CHARCONSTANT(TERMINAL[\*(AqA\*(Aq:8])),
\&          CHAR2INT(VAR(TERMINAL[c:8]))
\&        )
\&      ),
\&      BLOCK[9:3:f]^{3}(
\&        ASSIGNINT(
\&          VAR(TERMINAL[d:11]),
\&          PLUS(VAR(TERMINAL[a:11]),VAR( TERMINAL[b:11])))
\&      ),
\&      ASSIGNINT(
\&        VAR(TERMINAL[a:13]),
\&        TIMES(VAR(TERMINAL[b:13]),INUM(TERMINAL[2:13]))),
\&      RETURNINT(CHAR2INT(VAR(TERMINAL[c:14])))
\&    )
\&  )
\&  ...... # More descriptions
.Ve
.PP
A scope manager helps to compute the mapping function
that maps the uses (instances) of 
source objects to their definitions. 
For instance,
.IP "\(bu" 2
When dealing with \fIidentifier scope analysis\fR the problem is to associate
each occurrence of an identifier with the declaration
that applies to it.
.IP "\(bu" 2
Another example is \fIloop scope analysis\fR
where the problem is to associate each occurrence
of a \f(CW\*(C`CONTINUE\*(C'\fR or \f(CW\*(C`BREAK\*(C'\fR node with the 
shallowest \f(CW\*(C`LOOP\*(C'\fR that encloses it.
.IP "\(bu" 2
Or \fIlabel scope analysis\fR, the problem to associate a \f(CW\*(C`GOTO\*(C'\fR
node with the node to jump to, that is,
the one with the \f(CW\*(C`STATEMENT\*(C'\fR associated with the label.
.PP
The scope analysis start by creating the \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR objects:
.PP
.Vb 9
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          ..........  # Semantic actions 
\&        }
\&  ;
.Ve
.PP
Before the analysis of the whole program we call \f(CW\*(C`reset_file_scope_vars\*(C'\fR
which is in charge to create the scope analyzers for
\&\fIidentifier scope analysis\fR and \fIloop scope analysis\fR:
.PP
.Vb 10
\&  sub reset_file_scope_vars {
\&    %st = (); # reset symbol table
\&    ($tokenbegin, $tokenend) = (1, 1);
\&    %type = ( INT  => Parse::Eyapp::Node\->hnew(\*(AqINT\*(Aq),
\&              CHAR => Parse::Eyapp::Node\->hnew(\*(AqCHAR\*(Aq),
\&              VOID => Parse::Eyapp::Node\->hnew(\*(AqVOID\*(Aq),
\&            );
\&    $depth = 0;
\&    $ids = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqblock\*(Aq,
\&             ENTRY_NAME => \*(Aqinfo\*(Aq,
\&             SCOPE_DEPTH => \*(Aqdepth\*(Aq,
\&    );
\&    $loops = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqexits\*(Aq,
\&    );
\&    $ids\->begin_scope();
\&    $loops\->begin_scope(); # just for checking
\&  }
.Ve
.PP
To take advantage of \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR, 
the compiler writer must mark at the appropriate time 
(for example a new block or new subroutine for \fIidentifier scope analysis\fR,
a new loop for \fIloop scope analysis\fR, etc.) the \fIbeginning of a new scope\fR
calling the method \f(CW\*(C`begin_scope\*(C'\fR.
For example, the following code deals with the declaration of functions
.PP
.Vb 11
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ........ # semantic action code
\&      }
\&  ;
.Ve
.PP
The call
.PP
.Vb 1
\&            $ids\->begin_scope
.Ve
.PP
marks the beginning of a new identifier scope.
.PP
From that point on, any \fIocurring instance\fR of an object 
(for example,
variables in expressions for \fIidentifier scope analysis\fR, breaks and continues
for \fIloop scope analysis\fR, etc.) must be declared 
calling the method \f(CW\*(C`scope_instance\*(C'\fR.
For example, the following rules deal with the use of 
of variables and functions inside expressions:
.PP
.Vb 10
\&  Primary:
\&      ........... # Other production rules
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.PP
The programmer must also mark the \fIend of the current scope\fR 
at the appropriate time. After the processing of the \f(CW\*(C`block\*(C'\fR 
following a function declaration an \fIidentifier scope\fR
has finished and we call \f(CW\*(C`end_scope\*(C'\fR:
.PP
.Vb 9
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ............................... 
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
.Ve
.PP
This call is made after each end of scope, including the end of the program:
.PP
.Vb 11
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          $program\->{symboltable} = { %st };  # creates a copy of the s.t.
\&          $program\->{depth} = 0;
\&          $program\->{line}  = 1;
\&          $program\->{types} = { %type };
\&          $program\->{lines} = $tokenend;
\&
\&          my ($nondec, $declared) = $ids\->end_scope($program\->{symboltable}, $program, \*(Aqtype\*(Aq);
\&
\&          if (@$nondec) {
\&            warn "Identifier ".$_\->key." not declared at line ".$_\->line."\en" for @$nondec;
\&            die "\en";
\&          }
\&
\&          # Type checking: add a direct pointer to the data\-structure
\&          # describing the type
\&          $_\->{t} = $type{$_\->{type}} for @$declared;
\&
\&          my $out_of_loops = $loops\->end_scope($program);
\&          if (@$out_of_loops) {
\&            warn "Error: ".ref($_)." outside of loop at line $_\->{line}\en" for @$out_of_loops;
\&            die "\en";
\&          }
\&
\&          # Check that are not dangling breaks
\&          reset_file_scope_vars();
\&
\&          $program;
\&        }
\&  ;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "The ""end_scope"" method"
.el .SS "The \f(CWend_scope\fP method"
.IX Subsection "The end_scope method"
There are three ways of calling \f(CW\*(C`$scope\->end_scope\*(C'\fR.
The first one is for Scope Analysis Problems where
a symbol table is needed (for example in \fIidentifier scope analysis\fR
and \fIlabel scope analysis\fR and there is a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR node 
that owns the scope.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI with first Argument a Symbol Table and Second Argument a Node\fR
.IX Subsection "The end_scope with first Argument a Symbol Table and Second Argument a Node"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, $definition_node, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{SCOPE_NAME}\*(C'\fR is built that will reference \f(CW$definition_node\fR.
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table:
.Sp
.Vb 3
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq651,657p\*(Aq Types.eyp
\&  sub VAR::key {
\&    my $self = shift;
\&
\&    return $self\->child(0)\->{attr}[0];
\&  }
\&
\&  *VARARRAY::key = *FUNCTIONCALL::key = \e&VAR::key;
.Ve
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
In a list context \f(CW\*(C`$scope>end_scope\*(C'\fR returns
two references. The first one
is a reference to a list of node instantiated
that weren't defined in the current scope.
The second is a reference to a list of nodes
that were defined in this scope. 
In a scalar context returns the first of these two.
An instance \f(CW$x\fR is \fIdefined\fR if, and only if, 
\&\f(CW\*(C`exists $symboltable{$_\->key}\*(C'\fR.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI Method with first Argument a Symbol Table and Remaining Arguments strings\fR
.IX Subsection "The end_scope Method with first Argument a Symbol Table and Remaining Arguments strings"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to  \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table.
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI method for Simple Scope Analysis\fR
.IX Subsection "The end_scope method for Simple Scope Analysis"
.PP
Some scope analysis problems do not require the existence
of a symbol table (for instance, the problem of associating
a \f(CW\*(C`RETURN\*(C'\fR node with the \f(CW\*(C`FUNCTION\*(C'\fR that encloses it). 
For such kind of problems \f(CW\*(C`$scope>end_scope\*(C'\fR provides
a second form of call.
.PP
The second way to call \f(CW\*(C`$scope>end_scope\*(C'\fR is
.PP
.Vb 1
\&                 $declared = $scopemanager\->end_scope($definition_node);
.Ve
.PP
The only argument is the reference to the node that controls/defines
the scope. The method returns a reference to the declared
nodes. Any node instanced with \f(CW\*(C`scope_instance\*(C'\fR
since the last call to \f(CW\*(C`begin_scope\*(C'\fR is considered \fIdeclared\fR.
.PP
The scope node \f(CW$definition_node\fR is decorated with an attribute with
name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager
\&\f(CW$scopemanager\fR. The value of the attribute is the anonymous list of references to the instances
declared in the scope of \f(CW$definition_node\fR 
(i.e. the same list referenced by \f(CW$declared\fR).
.PP
The scope instances in \f(CW@$declared\fR are decorated with
an attribute with name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager.
The value is a reference to the scope node \f(CW$definition_node\fR.
.ie n .SS "The ""begin_scope"" method"
.el .SS "The \f(CWbegin_scope\fP method"
.IX Subsection "The begin_scope method"
Marks the beginning of an scope.
Example (file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 7
\&   loopPrefix:
\&       $WHILE \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&         {
\&           $loops\->begin_scope;
\&           $_[3]\->{line} = $WHILE\->[1]; # Save the line for error diagostic
\&           $_[3]
\&         }
.Ve
.ie n .SS "The ""scope_instance"" method"
.el .SS "The \f(CWscope_instance\fP method"
.IX Subsection "The scope_instance method"
Declares the node argument to be an occurring instance of the scope:
.PP
.Vb 8
\&   nereida:~/doc/casiano/PLBOOK/PLBOOK/code> \e
\&       sed \-ne \*(Aq375,380p\*(Aq Simple6.eyp | cat \-n
\&    1      $Variable \*(Aq=\*(Aq binary
\&    2        {
\&    3          my $parser = shift;
\&    4          $ids\->scope_instance($Variable);
\&    5          $parser\->YYBuildAST(@_); # "Manually" build the node
\&    6        }
.Ve
.ie n .SS "The constructor ""new"""
.el .SS "The constructor \f(CWnew\fP"
.IX Subsection "The constructor new"
\&\f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR returns a scope management object. 
The scope mapping function is implemented 
by \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR through a set of attributes
that are added to the nodes involved in the scope analysis.
The names of these attributes can be specified 
using the parameters of \f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR.
The arguments of \f(CW\*(C`new\*(C'\fR are:
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_NAME\*(C'\fR 
is the name chosen for the attribute of the 
\&\fInode instance\fR  which will held
the reference to the \fIdefinition node\fR.
If not specified it will take the value \f(CW"scope"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ENTRY_NAME\*(C'\fR is the name of the attribute of the
\&\fInode instance\fR  which will held
the reference to the symbol table entry.
By default takes the value \f(CW"entry"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_DEPTH\*(C'\fR is the name for an attribute of the 
\&\fIdefinition node\fR. Optional. If not specified it will not be
defined.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Scope5.16.3pm                  0100644 0001750 0001750 00000062013 12566242264 025231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Scope 3"
.TH Parse::Eyapp::Scope 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Scope \- Support for Scope Analysis
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  # Fragment of the grammar lib/Simple/Types.eyp
\&  # in examples/typechecking/Simple\-Types\-XXX.tar.gz 
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         my $st = $block\->{symboltable}; 
\&         my @decs = $params\->children(); 
\&         $block\->{parameters} = [];
\&         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
\&             $bt = ref($bt); # The string \*(AqINT\*(Aq, \*(AqCHAR\*(Aq, etc.
\&             my $name = $id\->{attr}[0];
\&             my $type = build_type($bt, $arrspec);
\&             $type{$type} = Parse::Eyapp::Node\->hnew($type); 
\&
\&             # control duplicated declarations
\&               die "Duplicated declaration of $name at line $id\->{attr}[1]\en" 
\&             if exists($st\->{$name});
\&
\&             $st\->{$name}\->{type} = $type;
\&             $st\->{$name}\->{param} = 1;
\&             $st\->{$name}\->{line} = $id\->{attr}[1];
\&             push @{$block\->{parameters}}, $name;
\&         }
\&         $block\->{function_name} = $ID;
\&         $block\->type("FUNCTION");
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
\& 
\&  ...
\&
\&  Primary:
\&      %name INUM
\&      INUM 
\&    | %name CHARCONSTANT
\&      CHARCONSTANT
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | \*(Aq(\*(Aq expression \*(Aq)\*(Aq { $_[2] }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The examples used in this document can be found in the
file \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR.
This distribution contains the front-end of a compiler
(lexical analysis, syntax analysis, scope analysis and type checking) for
a small subset of the C language.
The language has characters, integers, arrays and functions.
Here is a small example:
.PP
.Vb 2
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ cat prueba03.c
\&  int a,b,e[10];
\&
\&  g() {}
\&
\&  int f(char c) {
\&  char d;
\&   c = \*(AqX\*(Aq;
\&   e[d] = \*(AqA\*(Aq+c;
\&   {
\&     int d;
\&     d = a + b;
\&   }
\&   a = b * 2;
\&   return c;
\&  }
.Ve
.PP
You can find more examples in the \f(CW\*(C`script/\*(C'\fR directory.
The front-end provided analyzes the input program
.PP
.Vb 1
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ usetypes.pl prueba03.c
.Ve
.PP
and produces the decorated abstract tree, i.e. s.t. like:
.PP
.Vb 10
\&  PROGRAM^{0}(
\&    FUNCTION[g]^{1},
\&    FUNCTION[f]^{2}(
\&      ASSIGNCHAR(
\&        VAR( TERMINAL[c:7]),
\&        CHARCONSTANT( TERMINAL[\*(AqX\*(Aq:7])
\&      ),
\&      ASSIGNINT(
\&        VARARRAY( TERMINAL[e:8], INDEXSPEC(CHAR2INT(VAR(TERMINAL[d:8])))),
\&        PLUS(
\&          CHAR2INT(CHARCONSTANT(TERMINAL[\*(AqA\*(Aq:8])),
\&          CHAR2INT(VAR(TERMINAL[c:8]))
\&        )
\&      ),
\&      BLOCK[9:3:f]^{3}(
\&        ASSIGNINT(
\&          VAR(TERMINAL[d:11]),
\&          PLUS(VAR(TERMINAL[a:11]),VAR( TERMINAL[b:11])))
\&      ),
\&      ASSIGNINT(
\&        VAR(TERMINAL[a:13]),
\&        TIMES(VAR(TERMINAL[b:13]),INUM(TERMINAL[2:13]))),
\&      RETURNINT(CHAR2INT(VAR(TERMINAL[c:14])))
\&    )
\&  )
\&  ...... # More descriptions
.Ve
.PP
A scope manager helps to compute the mapping function
that maps the uses (instances) of 
source objects to their definitions. 
For instance,
.IP "\(bu" 2
When dealing with \fIidentifier scope analysis\fR the problem is to associate
each occurrence of an identifier with the declaration
that applies to it.
.IP "\(bu" 2
Another example is \fIloop scope analysis\fR
where the problem is to associate each occurrence
of a \f(CW\*(C`CONTINUE\*(C'\fR or \f(CW\*(C`BREAK\*(C'\fR node with the 
shallowest \f(CW\*(C`LOOP\*(C'\fR that encloses it.
.IP "\(bu" 2
Or \fIlabel scope analysis\fR, the problem to associate a \f(CW\*(C`GOTO\*(C'\fR
node with the node to jump to, that is,
the one with the \f(CW\*(C`STATEMENT\*(C'\fR associated with the label.
.PP
The scope analysis start by creating the \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR objects:
.PP
.Vb 9
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          ..........  # Semantic actions 
\&        }
\&  ;
.Ve
.PP
Before the analysis of the whole program we call \f(CW\*(C`reset_file_scope_vars\*(C'\fR
which is in charge to create the scope analyzers for
\&\fIidentifier scope analysis\fR and \fIloop scope analysis\fR:
.PP
.Vb 10
\&  sub reset_file_scope_vars {
\&    %st = (); # reset symbol table
\&    ($tokenbegin, $tokenend) = (1, 1);
\&    %type = ( INT  => Parse::Eyapp::Node\->hnew(\*(AqINT\*(Aq),
\&              CHAR => Parse::Eyapp::Node\->hnew(\*(AqCHAR\*(Aq),
\&              VOID => Parse::Eyapp::Node\->hnew(\*(AqVOID\*(Aq),
\&            );
\&    $depth = 0;
\&    $ids = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqblock\*(Aq,
\&             ENTRY_NAME => \*(Aqinfo\*(Aq,
\&             SCOPE_DEPTH => \*(Aqdepth\*(Aq,
\&    );
\&    $loops = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqexits\*(Aq,
\&    );
\&    $ids\->begin_scope();
\&    $loops\->begin_scope(); # just for checking
\&  }
.Ve
.PP
To take advantage of \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR, 
the compiler writer must mark at the appropriate time 
(for example a new block or new subroutine for \fIidentifier scope analysis\fR,
a new loop for \fIloop scope analysis\fR, etc.) the \fIbeginning of a new scope\fR
calling the method \f(CW\*(C`begin_scope\*(C'\fR.
For example, the following code deals with the declaration of functions
.PP
.Vb 11
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ........ # semantic action code
\&      }
\&  ;
.Ve
.PP
The call
.PP
.Vb 1
\&            $ids\->begin_scope
.Ve
.PP
marks the beginning of a new identifier scope.
.PP
From that point on, any \fIocurring instance\fR of an object 
(for example,
variables in expressions for \fIidentifier scope analysis\fR, breaks and continues
for \fIloop scope analysis\fR, etc.) must be declared 
calling the method \f(CW\*(C`scope_instance\*(C'\fR.
For example, the following rules deal with the use of 
of variables and functions inside expressions:
.PP
.Vb 10
\&  Primary:
\&      ........... # Other production rules
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.PP
The programmer must also mark the \fIend of the current scope\fR 
at the appropriate time. After the processing of the \f(CW\*(C`block\*(C'\fR 
following a function declaration an \fIidentifier scope\fR
has finished and we call \f(CW\*(C`end_scope\*(C'\fR:
.PP
.Vb 9
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ............................... 
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
.Ve
.PP
This call is made after each end of scope, including the end of the program:
.PP
.Vb 11
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          $program\->{symboltable} = { %st };  # creates a copy of the s.t.
\&          $program\->{depth} = 0;
\&          $program\->{line}  = 1;
\&          $program\->{types} = { %type };
\&          $program\->{lines} = $tokenend;
\&
\&          my ($nondec, $declared) = $ids\->end_scope($program\->{symboltable}, $program, \*(Aqtype\*(Aq);
\&
\&          if (@$nondec) {
\&            warn "Identifier ".$_\->key." not declared at line ".$_\->line."\en" for @$nondec;
\&            die "\en";
\&          }
\&
\&          # Type checking: add a direct pointer to the data\-structure
\&          # describing the type
\&          $_\->{t} = $type{$_\->{type}} for @$declared;
\&
\&          my $out_of_loops = $loops\->end_scope($program);
\&          if (@$out_of_loops) {
\&            warn "Error: ".ref($_)." outside of loop at line $_\->{line}\en" for @$out_of_loops;
\&            die "\en";
\&          }
\&
\&          # Check that are not dangling breaks
\&          reset_file_scope_vars();
\&
\&          $program;
\&        }
\&  ;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "The ""end_scope"" method"
.el .SS "The \f(CWend_scope\fP method"
.IX Subsection "The end_scope method"
There are three ways of calling \f(CW\*(C`$scope\->end_scope\*(C'\fR.
The first one is for Scope Analysis Problems where
a symbol table is needed (for example in \fIidentifier scope analysis\fR
and \fIlabel scope analysis\fR and there is a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR node 
that owns the scope.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI with first Argument a Symbol Table and Second Argument a Node\fR
.IX Subsection "The end_scope with first Argument a Symbol Table and Second Argument a Node"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, $definition_node, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{SCOPE_NAME}\*(C'\fR is built that will reference \f(CW$definition_node\fR.
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table:
.Sp
.Vb 3
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq651,657p\*(Aq Types.eyp
\&  sub VAR::key {
\&    my $self = shift;
\&
\&    return $self\->child(0)\->{attr}[0];
\&  }
\&
\&  *VARARRAY::key = *FUNCTIONCALL::key = \e&VAR::key;
.Ve
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
In a list context \f(CW\*(C`$scope>end_scope\*(C'\fR returns
two references. The first one
is a reference to a list of node instantiated
that weren't defined in the current scope.
The second is a reference to a list of nodes
that were defined in this scope. 
In a scalar context returns the first of these two.
An instance \f(CW$x\fR is \fIdefined\fR if, and only if, 
\&\f(CW\*(C`exists $symboltable{$_\->key}\*(C'\fR.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI Method with first Argument a Symbol Table and Remaining Arguments strings\fR
.IX Subsection "The end_scope Method with first Argument a Symbol Table and Remaining Arguments strings"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to  \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table.
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI method for Simple Scope Analysis\fR
.IX Subsection "The end_scope method for Simple Scope Analysis"
.PP
Some scope analysis problems do not require the existence
of a symbol table (for instance, the problem of associating
a \f(CW\*(C`RETURN\*(C'\fR node with the \f(CW\*(C`FUNCTION\*(C'\fR that encloses it). 
For such kind of problems \f(CW\*(C`$scope>end_scope\*(C'\fR provides
a second form of call.
.PP
The second way to call \f(CW\*(C`$scope>end_scope\*(C'\fR is
.PP
.Vb 1
\&                 $declared = $scopemanager\->end_scope($definition_node);
.Ve
.PP
The only argument is the reference to the node that controls/defines
the scope. The method returns a reference to the declared
nodes. Any node instanced with \f(CW\*(C`scope_instance\*(C'\fR
since the last call to \f(CW\*(C`begin_scope\*(C'\fR is considered \fIdeclared\fR.
.PP
The scope node \f(CW$definition_node\fR is decorated with an attribute with
name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager
\&\f(CW$scopemanager\fR. The value of the attribute is the anonymous list of references to the instances
declared in the scope of \f(CW$definition_node\fR 
(i.e. the same list referenced by \f(CW$declared\fR).
.PP
The scope instances in \f(CW@$declared\fR are decorated with
an attribute with name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager.
The value is a reference to the scope node \f(CW$definition_node\fR.
.ie n .SS "The ""begin_scope"" method"
.el .SS "The \f(CWbegin_scope\fP method"
.IX Subsection "The begin_scope method"
Marks the beginning of an scope.
Example (file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 7
\&   loopPrefix:
\&       $WHILE \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&         {
\&           $loops\->begin_scope;
\&           $_[3]\->{line} = $WHILE\->[1]; # Save the line for error diagostic
\&           $_[3]
\&         }
.Ve
.ie n .SS "The ""scope_instance"" method"
.el .SS "The \f(CWscope_instance\fP method"
.IX Subsection "The scope_instance method"
Declares the node argument to be an occurring instance of the scope:
.PP
.Vb 8
\&   nereida:~/doc/casiano/PLBOOK/PLBOOK/code> \e
\&       sed \-ne \*(Aq375,380p\*(Aq Simple6.eyp | cat \-n
\&    1      $Variable \*(Aq=\*(Aq binary
\&    2        {
\&    3          my $parser = shift;
\&    4          $ids\->scope_instance($Variable);
\&    5          $parser\->YYBuildAST(@_); # "Manually" build the node
\&    6        }
.Ve
.ie n .SS "The constructor ""new"""
.el .SS "The constructor \f(CWnew\fP"
.IX Subsection "The constructor new"
\&\f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR returns a scope management object. 
The scope mapping function is implemented 
by \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR through a set of attributes
that are added to the nodes involved in the scope analysis.
The names of these attributes can be specified 
using the parameters of \f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR.
The arguments of \f(CW\*(C`new\*(C'\fR are:
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_NAME\*(C'\fR 
is the name chosen for the attribute of the 
\&\fInode instance\fR  which will held
the reference to the \fIdefinition node\fR.
If not specified it will take the value \f(CW"scope"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ENTRY_NAME\*(C'\fR is the name of the attribute of the
\&\fInode instance\fR  which will held
the reference to the symbol table entry.
By default takes the value \f(CW"entry"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_DEPTH\*(C'\fR is the name for an attribute of the 
\&\fIdefinition node\fR. Optional. If not specified it will not be
defined.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at http://code.google.com/p/parse\-eyapp/ <http://code.google.com/p/parse-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Scope5.18.3pm                  0100644 0001750 0001750 00000062066 12566242263 025242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Scope 3"
.TH Parse::Eyapp::Scope 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Scope \- Support for Scope Analysis
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  # Fragment of the grammar lib/Simple/Types.eyp
\&  # in examples/typechecking/Simple\-Types\-XXX.tar.gz 
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         my $st = $block\->{symboltable}; 
\&         my @decs = $params\->children(); 
\&         $block\->{parameters} = [];
\&         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
\&             $bt = ref($bt); # The string \*(AqINT\*(Aq, \*(AqCHAR\*(Aq, etc.
\&             my $name = $id\->{attr}[0];
\&             my $type = build_type($bt, $arrspec);
\&             $type{$type} = Parse::Eyapp::Node\->hnew($type); 
\&
\&             # control duplicated declarations
\&               die "Duplicated declaration of $name at line $id\->{attr}[1]\en" 
\&             if exists($st\->{$name});
\&
\&             $st\->{$name}\->{type} = $type;
\&             $st\->{$name}\->{param} = 1;
\&             $st\->{$name}\->{line} = $id\->{attr}[1];
\&             push @{$block\->{parameters}}, $name;
\&         }
\&         $block\->{function_name} = $ID;
\&         $block\->type("FUNCTION");
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
\& 
\&  ...
\&
\&  Primary:
\&      %name INUM
\&      INUM 
\&    | %name CHARCONSTANT
\&      CHARCONSTANT
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | \*(Aq(\*(Aq expression \*(Aq)\*(Aq { $_[2] }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The examples used in this document can be found in the
file \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR.
This distribution contains the front-end of a compiler
(lexical analysis, syntax analysis, scope analysis and type checking) for
a small subset of the C language.
The language has characters, integers, arrays and functions.
Here is a small example:
.PP
.Vb 2
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ cat prueba03.c
\&  int a,b,e[10];
\&
\&  g() {}
\&
\&  int f(char c) {
\&  char d;
\&   c = \*(AqX\*(Aq;
\&   e[d] = \*(AqA\*(Aq+c;
\&   {
\&     int d;
\&     d = a + b;
\&   }
\&   a = b * 2;
\&   return c;
\&  }
.Ve
.PP
You can find more examples in the \f(CW\*(C`script/\*(C'\fR directory.
The front-end provided analyzes the input program
.PP
.Vb 1
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ usetypes.pl prueba03.c
.Ve
.PP
and produces the decorated abstract tree, i.e. s.t. like:
.PP
.Vb 10
\&  PROGRAM^{0}(
\&    FUNCTION[g]^{1},
\&    FUNCTION[f]^{2}(
\&      ASSIGNCHAR(
\&        VAR( TERMINAL[c:7]),
\&        CHARCONSTANT( TERMINAL[\*(AqX\*(Aq:7])
\&      ),
\&      ASSIGNINT(
\&        VARARRAY( TERMINAL[e:8], INDEXSPEC(CHAR2INT(VAR(TERMINAL[d:8])))),
\&        PLUS(
\&          CHAR2INT(CHARCONSTANT(TERMINAL[\*(AqA\*(Aq:8])),
\&          CHAR2INT(VAR(TERMINAL[c:8]))
\&        )
\&      ),
\&      BLOCK[9:3:f]^{3}(
\&        ASSIGNINT(
\&          VAR(TERMINAL[d:11]),
\&          PLUS(VAR(TERMINAL[a:11]),VAR( TERMINAL[b:11])))
\&      ),
\&      ASSIGNINT(
\&        VAR(TERMINAL[a:13]),
\&        TIMES(VAR(TERMINAL[b:13]),INUM(TERMINAL[2:13]))),
\&      RETURNINT(CHAR2INT(VAR(TERMINAL[c:14])))
\&    )
\&  )
\&  ...... # More descriptions
.Ve
.PP
A scope manager helps to compute the mapping function
that maps the uses (instances) of 
source objects to their definitions. 
For instance,
.IP "\(bu" 2
When dealing with \fIidentifier scope analysis\fR the problem is to associate
each occurrence of an identifier with the declaration
that applies to it.
.IP "\(bu" 2
Another example is \fIloop scope analysis\fR
where the problem is to associate each occurrence
of a \f(CW\*(C`CONTINUE\*(C'\fR or \f(CW\*(C`BREAK\*(C'\fR node with the 
shallowest \f(CW\*(C`LOOP\*(C'\fR that encloses it.
.IP "\(bu" 2
Or \fIlabel scope analysis\fR, the problem to associate a \f(CW\*(C`GOTO\*(C'\fR
node with the node to jump to, that is,
the one with the \f(CW\*(C`STATEMENT\*(C'\fR associated with the label.
.PP
The scope analysis start by creating the \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR objects:
.PP
.Vb 9
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          ..........  # Semantic actions 
\&        }
\&  ;
.Ve
.PP
Before the analysis of the whole program we call \f(CW\*(C`reset_file_scope_vars\*(C'\fR
which is in charge to create the scope analyzers for
\&\fIidentifier scope analysis\fR and \fIloop scope analysis\fR:
.PP
.Vb 10
\&  sub reset_file_scope_vars {
\&    %st = (); # reset symbol table
\&    ($tokenbegin, $tokenend) = (1, 1);
\&    %type = ( INT  => Parse::Eyapp::Node\->hnew(\*(AqINT\*(Aq),
\&              CHAR => Parse::Eyapp::Node\->hnew(\*(AqCHAR\*(Aq),
\&              VOID => Parse::Eyapp::Node\->hnew(\*(AqVOID\*(Aq),
\&            );
\&    $depth = 0;
\&    $ids = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqblock\*(Aq,
\&             ENTRY_NAME => \*(Aqinfo\*(Aq,
\&             SCOPE_DEPTH => \*(Aqdepth\*(Aq,
\&    );
\&    $loops = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqexits\*(Aq,
\&    );
\&    $ids\->begin_scope();
\&    $loops\->begin_scope(); # just for checking
\&  }
.Ve
.PP
To take advantage of \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR, 
the compiler writer must mark at the appropriate time 
(for example a new block or new subroutine for \fIidentifier scope analysis\fR,
a new loop for \fIloop scope analysis\fR, etc.) the \fIbeginning of a new scope\fR
calling the method \f(CW\*(C`begin_scope\*(C'\fR.
For example, the following code deals with the declaration of functions
.PP
.Vb 11
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ........ # semantic action code
\&      }
\&  ;
.Ve
.PP
The call
.PP
.Vb 1
\&            $ids\->begin_scope
.Ve
.PP
marks the beginning of a new identifier scope.
.PP
From that point on, any \fIocurring instance\fR of an object 
(for example,
variables in expressions for \fIidentifier scope analysis\fR, breaks and continues
for \fIloop scope analysis\fR, etc.) must be declared 
calling the method \f(CW\*(C`scope_instance\*(C'\fR.
For example, the following rules deal with the use of 
of variables and functions inside expressions:
.PP
.Vb 10
\&  Primary:
\&      ........... # Other production rules
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.PP
The programmer must also mark the \fIend of the current scope\fR 
at the appropriate time. After the processing of the \f(CW\*(C`block\*(C'\fR 
following a function declaration an \fIidentifier scope\fR
has finished and we call \f(CW\*(C`end_scope\*(C'\fR:
.PP
.Vb 9
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ............................... 
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
.Ve
.PP
This call is made after each end of scope, including the end of the program:
.PP
.Vb 11
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          $program\->{symboltable} = { %st };  # creates a copy of the s.t.
\&          $program\->{depth} = 0;
\&          $program\->{line}  = 1;
\&          $program\->{types} = { %type };
\&          $program\->{lines} = $tokenend;
\&
\&          my ($nondec, $declared) = $ids\->end_scope($program\->{symboltable}, $program, \*(Aqtype\*(Aq);
\&
\&          if (@$nondec) {
\&            warn "Identifier ".$_\->key." not declared at line ".$_\->line."\en" for @$nondec;
\&            die "\en";
\&          }
\&
\&          # Type checking: add a direct pointer to the data\-structure
\&          # describing the type
\&          $_\->{t} = $type{$_\->{type}} for @$declared;
\&
\&          my $out_of_loops = $loops\->end_scope($program);
\&          if (@$out_of_loops) {
\&            warn "Error: ".ref($_)." outside of loop at line $_\->{line}\en" for @$out_of_loops;
\&            die "\en";
\&          }
\&
\&          # Check that are not dangling breaks
\&          reset_file_scope_vars();
\&
\&          $program;
\&        }
\&  ;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "The ""end_scope"" method"
.el .SS "The \f(CWend_scope\fP method"
.IX Subsection "The end_scope method"
There are three ways of calling \f(CW\*(C`$scope\->end_scope\*(C'\fR.
The first one is for Scope Analysis Problems where
a symbol table is needed (for example in \fIidentifier scope analysis\fR
and \fIlabel scope analysis\fR and there is a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR node 
that owns the scope.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI with first Argument a Symbol Table and Second Argument a Node\fR
.IX Subsection "The end_scope with first Argument a Symbol Table and Second Argument a Node"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, $definition_node, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{SCOPE_NAME}\*(C'\fR is built that will reference \f(CW$definition_node\fR.
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table:
.Sp
.Vb 3
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq651,657p\*(Aq Types.eyp
\&  sub VAR::key {
\&    my $self = shift;
\&
\&    return $self\->child(0)\->{attr}[0];
\&  }
\&
\&  *VARARRAY::key = *FUNCTIONCALL::key = \e&VAR::key;
.Ve
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
In a list context \f(CW\*(C`$scope>end_scope\*(C'\fR returns
two references. The first one
is a reference to a list of node instantiated
that weren't defined in the current scope.
The second is a reference to a list of nodes
that were defined in this scope. 
In a scalar context returns the first of these two.
An instance \f(CW$x\fR is \fIdefined\fR if, and only if, 
\&\f(CW\*(C`exists $symboltable{$_\->key}\*(C'\fR.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI Method with first Argument a Symbol Table and Remaining Arguments strings\fR
.IX Subsection "The end_scope Method with first Argument a Symbol Table and Remaining Arguments strings"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to  \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table.
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI method for Simple Scope Analysis\fR
.IX Subsection "The end_scope method for Simple Scope Analysis"
.PP
Some scope analysis problems do not require the existence
of a symbol table (for instance, the problem of associating
a \f(CW\*(C`RETURN\*(C'\fR node with the \f(CW\*(C`FUNCTION\*(C'\fR that encloses it). 
For such kind of problems \f(CW\*(C`$scope>end_scope\*(C'\fR provides
a second form of call.
.PP
The second way to call \f(CW\*(C`$scope>end_scope\*(C'\fR is
.PP
.Vb 1
\&                 $declared = $scopemanager\->end_scope($definition_node);
.Ve
.PP
The only argument is the reference to the node that controls/defines
the scope. The method returns a reference to the declared
nodes. Any node instanced with \f(CW\*(C`scope_instance\*(C'\fR
since the last call to \f(CW\*(C`begin_scope\*(C'\fR is considered \fIdeclared\fR.
.PP
The scope node \f(CW$definition_node\fR is decorated with an attribute with
name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager
\&\f(CW$scopemanager\fR. The value of the attribute is the anonymous list of references to the instances
declared in the scope of \f(CW$definition_node\fR 
(i.e. the same list referenced by \f(CW$declared\fR).
.PP
The scope instances in \f(CW@$declared\fR are decorated with
an attribute with name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager.
The value is a reference to the scope node \f(CW$definition_node\fR.
.ie n .SS "The ""begin_scope"" method"
.el .SS "The \f(CWbegin_scope\fP method"
.IX Subsection "The begin_scope method"
Marks the beginning of an scope.
Example (file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 7
\&   loopPrefix:
\&       $WHILE \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&         {
\&           $loops\->begin_scope;
\&           $_[3]\->{line} = $WHILE\->[1]; # Save the line for error diagostic
\&           $_[3]
\&         }
.Ve
.ie n .SS "The ""scope_instance"" method"
.el .SS "The \f(CWscope_instance\fP method"
.IX Subsection "The scope_instance method"
Declares the node argument to be an occurring instance of the scope:
.PP
.Vb 8
\&   nereida:~/doc/casiano/PLBOOK/PLBOOK/code> \e
\&       sed \-ne \*(Aq375,380p\*(Aq Simple6.eyp | cat \-n
\&    1      $Variable \*(Aq=\*(Aq binary
\&    2        {
\&    3          my $parser = shift;
\&    4          $ids\->scope_instance($Variable);
\&    5          $parser\->YYBuildAST(@_); # "Manually" build the node
\&    6        }
.Ve
.ie n .SS "The constructor ""new"""
.el .SS "The constructor \f(CWnew\fP"
.IX Subsection "The constructor new"
\&\f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR returns a scope management object. 
The scope mapping function is implemented 
by \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR through a set of attributes
that are added to the nodes involved in the scope analysis.
The names of these attributes can be specified 
using the parameters of \f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR.
The arguments of \f(CW\*(C`new\*(C'\fR are:
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_NAME\*(C'\fR 
is the name chosen for the attribute of the 
\&\fInode instance\fR  which will held
the reference to the \fIdefinition node\fR.
If not specified it will take the value \f(CW"scope"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ENTRY_NAME\*(C'\fR is the name of the attribute of the
\&\fInode instance\fR  which will held
the reference to the symbol table entry.
By default takes the value \f(CW"entry"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_DEPTH\*(C'\fR is the name for an attribute of the 
\&\fIdefinition node\fR. Optional. If not specified it will not be
defined.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::TokenGen.3pm                   0100644 0001750 0001750 00000023420 12566242262 025355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::TokenGen 3"
.TH Parse::Eyapp::TokenGen 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::TokenGen \- Support for Using Parse::Eyapp as a Data Generator
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
For a introduction to data generation using Parse::Eyapp see
Parse::Eyapp::datagenerationtut.
.SH "METHODS"
.IX Header "METHODS"
.SS "set_tokengens"
.IX Subsection "set_tokengens"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => generator
.Ve
.PP
Sets the generator attribute of the tokens.
Though not strictly necessary, the generator is
a Test::LectroTest::Generator object.
.SS "set_weights"
.IX Subsection "set_weights"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => weight
.Ve
.PP
Sets the weight attribute of the tokens.
The weight is a floating number.
.SS "set_tokenweightsandgenerators"
.IX Subsection "set_tokenweightsandgenerators"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => [weight, generator]
.Ve
.PP
or
.PP
.Vb 1
\&    token => weight
.Ve
.PP
and sets the weight and generator attributes of the tokens.
An example can be found in \f(CW\*(C`examples/generator/GenSupport.pm\*(C'\fR:
.PP
.Vb 10
\&  $parser\->set_tokenweightsandgenerators(
\&    NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&    VAR => [
\&              0,  # At the beginning, no variables are defined
\&              Gen {
\&                return  Elements(keys %st)\->generate if keys %st;
\&                return Int(range=>[0, 9], sized=>0)\->generate;
\&              },
\&            ],
\&    VARDEF => [ 
\&                2,  
\&                String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&              ],
\&    \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2, 
\&    \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5, 
\&    \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2, 
\&    \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&  );
.Ve
.SS "token_weight"
.IX Subsection "token_weight"
Receives the parser object and the token and returns the weight.
If an additional weight is provided the weight for the token is set.
.SS "token_generator"
.IX Subsection "token_generator"
Receives the parser object and the token and returns the generator.
If an additional generator is provided the generator for the token is set.
.SS "deltaweight"
.IX Subsection "deltaweight"
Has the syntax:
.PP
.Vb 1
\&  $parser\->deltaweight(TOKEN1 => deltaweight1, TOKEN2 => deltaweight2, ...)
.Ve
.PP
increases the weight of the respective token by the associated amount.
.SS "pushdeltaweight"
.IX Subsection "pushdeltaweight"
As \f(CW\*(C`deltaweight\*(C'\fR but the current weights of the involved tokens
are saved in a stack
.SS "popweight"
.IX Subsection "popweight"
Restores the weights of the tokens that were previously saved
with \f(CW\*(C`pushdeltaweight\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
Test::LectroTest::Generator by Tom Moertel
.IP "\(bu" 4
The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
<http://www.cs.ubc.ca/local/reading/proceedings/spe91\-95/spe/./vol22/issue3/spe756pm.pdf>
.IP "\(bu" 4
yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
\&\s-1ASE \s0'05: Proceedings of the 20th \s-1IEEE/ACM\s0 international Conference on Automated software engineering.
2005, pages 356\-359.
.RS 4
.IP "\(bu" 2
<http://search.cpan.org/perldoc?yagg::Tutorial>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/4/4e/yagg_short.pdf>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/6/69/wm\-cs\-2005\-13.pdf>
.RE
.RS 4
.RE
.IP "\(bu" 4
Writing Randomly by Randall Schwartz. 
Linux Magazine Column 04 (Sep 1999). 
<http://www.stonehenge.com/merlyn/LinuxMag/col04.html>
.IP "\(bu" 4
Generating Test Data with Enhanced Context Free Grammars by Peter M. Maurer
<http://cs.baylor.edu/~maurer/aida/dgl\-source/documentation/gen_tst.pdf>
.IP "\(bu" 4
Modules as Programs by Brian d Foy 
<http://www252.pair.com/comdog/mastering_perl/Chapters/18.modulinos.html>
.IP "\(bu" 4
How a Script Becomes a Module by Brian d Foy. On Perlmonks: 
<http://www.perlmonks.org/index.pl?node_id=396759>.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::TokenGen5.16.3pm               0100644 0001750 0001750 00000023474 12566242265 025703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::TokenGen 3"
.TH Parse::Eyapp::TokenGen 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::TokenGen \- Support for Using Parse::Eyapp as a Data Generator
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
For a introduction to data generation using Parse::Eyapp see
Parse::Eyapp::datagenerationtut.
.SH "METHODS"
.IX Header "METHODS"
.SS "set_tokengens"
.IX Subsection "set_tokengens"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => generator
.Ve
.PP
Sets the generator attribute of the tokens.
Though not strictly necessary, the generator is
a Test::LectroTest::Generator object.
.SS "set_weights"
.IX Subsection "set_weights"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => weight
.Ve
.PP
Sets the weight attribute of the tokens.
The weight is a floating number.
.SS "set_tokenweightsandgenerators"
.IX Subsection "set_tokenweightsandgenerators"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => [weight, generator]
.Ve
.PP
or
.PP
.Vb 1
\&    token => weight
.Ve
.PP
and sets the weight and generator attributes of the tokens.
An example can be found in \f(CW\*(C`examples/generator/GenSupport.pm\*(C'\fR:
.PP
.Vb 10
\&  $parser\->set_tokenweightsandgenerators(
\&    NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&    VAR => [
\&              0,  # At the beginning, no variables are defined
\&              Gen {
\&                return  Elements(keys %st)\->generate if keys %st;
\&                return Int(range=>[0, 9], sized=>0)\->generate;
\&              },
\&            ],
\&    VARDEF => [ 
\&                2,  
\&                String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&              ],
\&    \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2, 
\&    \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5, 
\&    \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2, 
\&    \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&  );
.Ve
.SS "token_weight"
.IX Subsection "token_weight"
Receives the parser object and the token and returns the weight.
If an additional weight is provided the weight for the token is set.
.SS "token_generator"
.IX Subsection "token_generator"
Receives the parser object and the token and returns the generator.
If an additional generator is provided the generator for the token is set.
.SS "deltaweight"
.IX Subsection "deltaweight"
Has the syntax:
.PP
.Vb 1
\&  $parser\->deltaweight(TOKEN1 => deltaweight1, TOKEN2 => deltaweight2, ...)
.Ve
.PP
increases the weight of the respective token by the associated amount.
.SS "pushdeltaweight"
.IX Subsection "pushdeltaweight"
As \f(CW\*(C`deltaweight\*(C'\fR but the current weights of the involved tokens
are saved in a stack
.SS "popweight"
.IX Subsection "popweight"
Restores the weights of the tokens that were previously saved
with \f(CW\*(C`pushdeltaweight\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
Test::LectroTest::Generator by Tom Moertel
.IP "\(bu" 4
The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
http://www.cs.ubc.ca/local/reading/proceedings/spe91\-95/spe/./vol22/issue3/spe756pm.pdf <http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/./vol22/issue3/spe756pm.pdf>
.IP "\(bu" 4
yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
\&\s-1ASE\s0 '05: Proceedings of the 20th \s-1IEEE/ACM\s0 international Conference on Automated software engineering.
2005, pages 356\-359.
.RS 4
.IP "\(bu" 2
<http://search.cpan.org/perldoc?yagg::Tutorial>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/4/4e/yagg_short.pdf>,
.IP "\(bu" 2
http://www.cs.wm.edu/~coppit/wiki/images/6/69/wm\-cs\-2005\-13.pdf <http://www.cs.wm.edu/~coppit/wiki/images/6/69/wm-cs-2005-13.pdf>
.RE
.RS 4
.RE
.IP "\(bu" 4
Writing Randomly by Randall Schwartz. 
Linux Magazine Column 04 (Sep 1999). 
<http://www.stonehenge.com/merlyn/LinuxMag/col04.html>
.IP "\(bu" 4
Generating Test Data with Enhanced Context Free Grammars by Peter M. Maurer
http://cs.baylor.edu/~maurer/aida/dgl\-source/documentation/gen_tst.pdf <http://cs.baylor.edu/~maurer/aida/dgl-source/documentation/gen_tst.pdf>
.IP "\(bu" 4
Modules as Programs by Brian d Foy 
<http://www252.pair.com/comdog/mastering_perl/Chapters/18.modulinos.html>
.IP "\(bu" 4
How a Script Becomes a Module by Brian d Foy. On Perlmonks: 
<http://www.perlmonks.org/index.pl?node_id=396759>.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::TokenGen5.18.3pm               0100644 0001750 0001750 00000023420 12566242262 025671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::TokenGen 3"
.TH Parse::Eyapp::TokenGen 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::TokenGen \- Support for Using Parse::Eyapp as a Data Generator
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
For a introduction to data generation using Parse::Eyapp see
Parse::Eyapp::datagenerationtut.
.SH "METHODS"
.IX Header "METHODS"
.SS "set_tokengens"
.IX Subsection "set_tokengens"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => generator
.Ve
.PP
Sets the generator attribute of the tokens.
Though not strictly necessary, the generator is
a Test::LectroTest::Generator object.
.SS "set_weights"
.IX Subsection "set_weights"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => weight
.Ve
.PP
Sets the weight attribute of the tokens.
The weight is a floating number.
.SS "set_tokenweightsandgenerators"
.IX Subsection "set_tokenweightsandgenerators"
Receives the parser object and the pairs
.PP
.Vb 1
\&    token => [weight, generator]
.Ve
.PP
or
.PP
.Vb 1
\&    token => weight
.Ve
.PP
and sets the weight and generator attributes of the tokens.
An example can be found in \f(CW\*(C`examples/generator/GenSupport.pm\*(C'\fR:
.PP
.Vb 10
\&  $parser\->set_tokenweightsandgenerators(
\&    NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&    VAR => [
\&              0,  # At the beginning, no variables are defined
\&              Gen {
\&                return  Elements(keys %st)\->generate if keys %st;
\&                return Int(range=>[0, 9], sized=>0)\->generate;
\&              },
\&            ],
\&    VARDEF => [ 
\&                2,  
\&                String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&              ],
\&    \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2, 
\&    \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5, 
\&    \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2, 
\&    \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&  );
.Ve
.SS "token_weight"
.IX Subsection "token_weight"
Receives the parser object and the token and returns the weight.
If an additional weight is provided the weight for the token is set.
.SS "token_generator"
.IX Subsection "token_generator"
Receives the parser object and the token and returns the generator.
If an additional generator is provided the generator for the token is set.
.SS "deltaweight"
.IX Subsection "deltaweight"
Has the syntax:
.PP
.Vb 1
\&  $parser\->deltaweight(TOKEN1 => deltaweight1, TOKEN2 => deltaweight2, ...)
.Ve
.PP
increases the weight of the respective token by the associated amount.
.SS "pushdeltaweight"
.IX Subsection "pushdeltaweight"
As \f(CW\*(C`deltaweight\*(C'\fR but the current weights of the involved tokens
are saved in a stack
.SS "popweight"
.IX Subsection "popweight"
Restores the weights of the tokens that were previously saved
with \f(CW\*(C`pushdeltaweight\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
Test::LectroTest::Generator by Tom Moertel
.IP "\(bu" 4
The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
<http://www.cs.ubc.ca/local/reading/proceedings/spe91\-95/spe/./vol22/issue3/spe756pm.pdf>
.IP "\(bu" 4
yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
\&\s-1ASE \s0'05: Proceedings of the 20th \s-1IEEE/ACM\s0 international Conference on Automated software engineering.
2005, pages 356\-359.
.RS 4
.IP "\(bu" 2
<http://search.cpan.org/perldoc?yagg::Tutorial>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/4/4e/yagg_short.pdf>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/6/69/wm\-cs\-2005\-13.pdf>
.RE
.RS 4
.RE
.IP "\(bu" 4
Writing Randomly by Randall Schwartz. 
Linux Magazine Column 04 (Sep 1999). 
<http://www.stonehenge.com/merlyn/LinuxMag/col04.html>
.IP "\(bu" 4
Generating Test Data with Enhanced Context Free Grammars by Peter M. Maurer
<http://cs.baylor.edu/~maurer/aida/dgl\-source/documentation/gen_tst.pdf>
.IP "\(bu" 4
Modules as Programs by Brian d Foy 
<http://www252.pair.com/comdog/mastering_perl/Chapters/18.modulinos.html>
.IP "\(bu" 4
How a Script Becomes a Module by Brian d Foy. On Perlmonks: 
<http://www.perlmonks.org/index.pl?node_id=396759>.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Treeregexp.3pm                 0100644 0001750 0001750 00000064666 12566242263 025777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Treeregexp 3"
.TH Parse::Eyapp::Treeregexp 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Treeregexp \- Tree transformations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use strict;
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    %left   NEG
\&    %tree
\&    %{
\&    use Tail2;  # See file examples/Tail2.pm in the distribution
\&    %}
\&
\&    %%
\&    block:  exp <%name BLOCK + \*(Aq;\*(Aq> { $_[1] }
\&    ;
\&
\&    exp:      %name NUM
\&                NUM
\&            | %name WHILE
\&                \*(Aqwhile\*(Aq   exp  \*(Aq{\*(Aq block \*(Aq}\*(Aq
\&            | %name VAR
\&                VAR
\&            | %name ASSIGN
\&                VAR \*(Aq=\*(Aq exp
\&            | %name PLUS
\&                exp \*(Aq+\*(Aq exp
\&            | %name MINUS
\&                exp \*(Aq\-\*(Aq exp
\&            | %name TIMES
\&                exp \*(Aq*\*(Aq exp
\&            | %name DIV
\&                exp \*(Aq/\*(Aq exp
\&            | %name UMINUS
\&                \*(Aq\-\*(Aq exp %prec NEG
\&            |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&  }; # end grammar
\&
\&  sub TERMINAL::info { $_[0]{attr} }
\&  $Parse::Eyapp::Node::INDENT = 2;
\&
\&  our (@all,$moveinvariant, $condition, $assign, $before, $after);
\&
\&  Parse::Eyapp\->new_grammar(
\&    input=>$grammar,
\&    classname=>\*(AqRule6\*(Aq,
\&    firstline=>7,
\&  );
\&  my $parser = Rule6\->new();
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  my $t = $parser\->Run(\e$program);
\&  my @output = split /\en/, $t\->str;
\&
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
\&  my @output2 = split /\en/, $t\->str;
\&
\&  my ($node1, $node2);
\&  format STDOUT_TOP =
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  @||||||||||||||||||||||||||||||||||||||||||||||||||||||
\&  $program
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  .
\&
\&  format STDOUT =
\&  @<<<<<<<<<<<<<<<<<<<<<<<<<<@|@<<<<<<<<<<<<<<<<<<<<<<<<<
\&  $node1,                    \*(Aq|\*(Aq,$node2
\&  .
\&
\&  for (1..$#output) {
\&    $node1 = $output[$_];
\&    $node2 = $output2[$_];
\&    write;
\&  }
.Ve
.SH "Introduction"
.IX Header "Introduction"
The example in the \s-1SYNOPSIS\s0 
section uses \f(CW\*(C`Parse::Eyapp\*(C'\fR to build an abstract
syntax tree for the program
.PP
.Vb 1
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
.Ve
.PP
The tree is transformed 
using the transformation \f(CW\*(C`moveinvariant\*(C'\fR:
.PP
.Vb 10
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
.Ve
.PP
The output shows the original tree versus the transformed
tree:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ moveinvariantoutofloopcomplexformula.pl
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  BLOCK(                     | BLOCK(
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[a],           |     TERMINAL[a],
\&      NUM(                   |     NUM(
\&        TERMINAL[1000]       |       TERMINAL[1000]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[c],           |     TERMINAL[c],
\&      NUM(                   |     NUM(
\&        TERMINAL[1]          |       TERMINAL[1]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    WHILE(                   |   ASSIGN(
\&      VAR(                   |     TERMINAL[b],
\&        TERMINAL[a]          |     NUM(
\&      ),                     |       TERMINAL[5]
\&      BLOCK(                 |     )
\&        ASSIGN(              |   ) # ASSIGN,
\&          TERMINAL[c],       |   WHILE(
\&          TIMES(             |     VAR(
\&            VAR(             |       TERMINAL[a]
\&              TERMINAL[c]    |     ),
\&            ),               |     BLOCK(
\&            VAR(             |       ASSIGN(
\&              TERMINAL[a]    |         TERMINAL[c],
\&            )                |         TIMES(
\&          ) # TIMES          |           VAR(
\&        ) # ASSIGN,          |             TERMINAL[c]
\&        ASSIGN(              |           ),
\&          TERMINAL[b],       |           VAR(
\&          NUM(               |             TERMINAL[a]
\&            TERMINAL[5]      |           )
\&          )                  |         ) # TIMES
\&        ) # ASSIGN,          |       ) # ASSIGN,
\&        ASSIGN(              |       ASSIGN(
\&          TERMINAL[a],       |         TERMINAL[a],
\&          MINUS(             |         MINUS(
\&            VAR(             |           VAR(
\&              TERMINAL[a]    |             TERMINAL[a]
\&            ),               |           ),
\&            NUM(             |           NUM(
\&              TERMINAL[1]    |             TERMINAL[1]
\&            )                |           )
\&          ) # MINUS          |         ) # MINUS
\&        ) # ASSIGN           |       ) # ASSIGN
\&      ) # BLOCK              |     ) # BLOCK
\&    ) # WHILE                |   ) # WHILE
\&  ) # BLOCK                  | ) # BLOCK
.Ve
.SH "The Treeregexp Language"
.IX Header "The Treeregexp Language"
A Treeregexp program is made of the repetition of three kind of 
primitives: The treeregexp transformations, supporting Perl code 
and Transformation Families.
.PP
.Vb 1
\&  treeregexplist:  treeregexp* 
\&
\&  treeregexp: 
\&      IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?  # Treeregexp 
\&    | CODE                            # Auxiliar code
\&    | IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq           # Transformation families
.Ve
.PP
Treeregexp themselves follow the rule:
.PP
.Vb 1
\&                  IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?
.Ve
.PP
Several instances of this rule can be seen in the example in
the \*(L"\s-1SYNOPSIS\*(R"\s0 section.
The identifier \f(CW\*(C`IDENT\*(C'\fR gives the name to the rule.
At the time of this writing (2006) there are the following kinds
of treeregexes:
.PP
.Vb 10
\&  treereg: 
\&        /* tree patterns with children */
\&      IDENT \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?  
\&    | \*(Aq.\*(Aq \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&          /* leaf tree patterns */
\&    | IDENT (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? (\*(Aqand\*(Aq CODE)? 
\&    | \*(Aq.\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR (\*(Aqand\*(Aq CODE)? 
\&    | ARRAY 
\&    | \*(Aq*\*(Aq
.Ve
.SS "Treeregexp rules"
.IX Subsection "Treeregexp rules"
When seen a rule like
.PP
.Vb 1
\&    zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
The Treeregexp translator creates a \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR object
that can be later referenced in the user code by the package variable
\&\f(CW$zero_times\fR.
.PP
\fIThe treeregexp\fR
.IX Subsection "The treeregexp"
.PP
The first part of the rule \f(CW\*(C`TIMES(NUM($x), ., .)\*(C'\fR
indicates that for a matching to succeed the node being
visited must be of \f(CW\*(C`type\*(C'\fR \f(CW\*(C`TIMES\*(C'\fR, have a left child
of  \f(CW\*(C`type\*(C'\fR \f(CW\*(C`NUM\*(C'\fR and two more children.
.PP
If the first part succeeded then the following part 
takes the control to see if the \fIsemantic conditions\fR
are satisfied.
.PP
\fISemantic condition\fR
.IX Subsection "Semantic condition"
.PP
The second part is optional and must be prefixed by the reserved word \f(CW\*(C`and\*(C'\fR
followed by a Perl code manifesting the semantic conditions that must be hold
by the node to succeed. Thus, in the example:
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the semantic condition \f(CW\*(C`$x\->{attr} == 0\*(C'\fR states that the
value of the number stored in the \f(CW\*(C`TERMINAL\*(C'\fR node referenced
by \f(CW$x\fR must be zero.
.PP
\fIReferencing the matching nodes\fR
.IX Subsection "Referencing the matching nodes"
.PP
The node  being visited can be referenced/modified
inside the semantic actions using \f(CW$_[0]\fR.
.PP
The Treeregexp
translator automatically creates a set of lexical variables
for us. The scope of these variables is limited to the
semantic condition and the transformation code.
.PP
Thus, in the example
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the node being visited \f(CW$_[0]\fR
can be also referenced using the lexical variable
\&\f(CW$TIMES\fR which is created by he Treeregexp compiler.
In the same way a reference to the left child \f(CW\*(C`NUM\*(C'\fR will be stored
in the lexical variable \f(CW$NUM\fR and a
reference to the child of \f(CW$NUM\fR will be stored in \f(CW$x\fR.
The semantic condition states that the attribute
of the node associated with \f(CW$x\fR must be zero.
.PP
When the same type of node appears several times inside 
the treeregexp part the associated lexical variable is 
declared by the Treeregexp compiler as an array.
This is the case in the \f(CW\*(C`constantfold\*(C'\fR transformation
in the \*(L"\s-1SYNOPSIS\*(R"\s0 example, where there are two nodes of type \f(CW\*(C`NUM\*(C'\fR:
.PP
.Vb 5
\&  constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
\&     => {
\&    $x\->{attr} = eval  "$x\->{attr} $W\->{attr} $y\->{attr}";
\&    $_[0] = $NUM[0];
\&  }
.Ve
.PP
Thus variable  \f(CW$NUM[0]\fR references the node that matches the 
first \f(CW\*(C`NUM\*(C'\fR term in the formula and \f(CW$NUM[1]\fR the one
that matches the second.
.PP
\fITransformation code\fR
.IX Subsection "Transformation code"
.PP
The third part of the rule is also optional and comes prefixed by
the big arrow \f(CW\*(C`=>\*(C'\fR. The Perl code in this section usually 
transforms the matching tree.
To achieve the modification of the tree, the Treeregexp programmer
\&\fBmust use \f(CB$_[0]\fB\fR and not the lexical variables provided by the translator.
Remember that in Perl \f(CW$_[0]\fR is an alias of the actual parameter.
The \f(CW\*(C`constantfold\*(C'\fR example above \fBwill not work\fR if we rewrite the code \f(CW$_[0] = $NUM[0]\fR as
.PP
.Vb 1
\&                            { $TIMES = $NUM }
.Ve
.SS "Regexp Treeregexes"
.IX Subsection "Regexp Treeregexes"
The previous \f(CW\*(C`constantfold\*(C'\fR example used a classic Perl linear regexp
to explicit that the root node of the matching subtree must match the Perl regexp.
The general syntax for \f(CW\*(C`REGEXP\*(C'\fR treeregexes patterns is:
.PP
.Vb 1
\&      treereg: REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?
.Ve
.PP
The \f(CW\*(C`REGEXP\*(C'\fR must be specified between slashes (other delimiters
as \f(CW\*(C`{}\*(C'\fR are not accepted).
It is legal to specify options after the second slash (like \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, etc.).
.PP
The operation of string oriented regexps is slightly modified
when they are used inside a treeregexp:
\&\fBby default the option\fR 
\&\f(CW\*(C`x\*(C'\fR 
\&\fBwill be assumed\fR.
The treeregexp compiler will automatically insert it.
Use the new option \f(CW\*(C`X\*(C'\fR (upper case X) if you want to suppress such behavior.
\&\fBThere is no need also to insert\fR \f(CW\*(C`\eb\*(C'\fR 
\&\fBword anchors\fR to delimit identifiers:
all the identifiers in a regexp treeregexp are automatically
surrounded by \f(CW\*(C`\eb\*(C'\fR. Use the option \f(CW\*(C`B\*(C'\fR (upper case B)
to suppress this behavior.
.PP
The optional identifier after the \f(CW\*(C`REGEXP\*(C'\fR indicates the name of the lexical variable
that will be held a reference to the node whose type matches \f(CW\*(C`REGEXP\*(C'\fR.
Variable \f(CW$W\fR (or \f(CW@W\fR if there are more than one \s-1REGEXP\s0 and or dot treeregexes)
will be used instead if no identifier is specified.
.SS "Scalar Treeregexes"
.IX Subsection "Scalar Treeregexes"
A scalar treeregxp is defined writing a Perl scalar inside the treeregexp, like \f(CW$x\fR
in \f(CW\*(C`NUM($x)\*(C'\fR. A scalar treeregxp immediately matches any node that exists
and stores a reference to such node inside the Perl lexical scalar variable.
The scope of the variable is limited to the semantic parts of the Treeregexp.
Is illegal to use \f(CW$W\fR or \f(CW\*(C`$W_#num\*(C'\fR as variable names for scalar treeregexes.
.SS "Dot Treeregexes"
.IX Subsection "Dot Treeregexes"
A dot matches any node. It can be seen as an abbreviation for
scalar treeregexes. The reference to the matching node
is stored in the lexical variable \f(CW$W\fR. 
The variable \f(CW@W\fR will be used instead
if there are more than one \s-1REGEXP\s0 and or dot treeregexes
.SS "Array Treeregexp Expressions"
.IX Subsection "Array Treeregexp Expressions"
The Treeregexp language permits expressions like:
.PP
.Vb 1
\&                   A(@a,B($x),@c)
.Ve
.PP
After the matching variable \f(CW@A\fR contains the shortest prefix
of \f(CW\*(C`$A\->children\*(C'\fR that does not match \f(CW\*(C`B($x)\*(C'\fR.
The variable \f(CW@c\fR contains the remaining suffix of
 \f(CW\*(C`$A\->children\*(C'\fR.
.PP
The following example uses 
array treereg expressions to move the assignment \f(CW\*(C`b = 5\*(C'\fR
out of the \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 10
\&  ..  ......................................................................
\&  93  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  94  $parser\->YYData\->{INPUT} = $program;
\&  95  my $t = $parser\->Run;
\&  96  my @output = split /\en/, $t\->str;
\&  97
\&  98  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  99    moveinvariant: BLOCK(
\& 100                     @prests,
\& 101                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\& 102                     @possts
\& 103                   )
\& 104      => {
\& 105           my $assign = $ASSIGN;
\& 106           $BLOCK[1]\->delete($ASSIGN);
\& 107           $BLOCK[0]\->insert_before($WHILE, $assign);
\& 108         }
\& 109    },
\& 110    FIRSTLINE => 99,
\& 111  );
\& 112  $p\->generate();
.Ve
.SS "Star Treeregexp"
.IX Subsection "Star Treeregexp"
Deprecated. Don't use it. Is still there but not to endure.
.SS "Transformation Families"
.IX Subsection "Transformation Families"
Transformations created by \f(CW\*(C`Parse::Eyapp::Treeregexp\*(C'\fR can be grouped in 
families. That is the function of the rule:
.PP
.Vb 1
\&                    treeregexp: IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq
.Ve
.PP
The next example (file \f(CW\*(C`examples/TSwithtreetransformations3.eyp\*(C'\fR)
defines the family
.PP
.Vb 1
\&     algebraic_transformations = constantfold zero_times times_zero comasocfold;
.Ve
.PP
Follows the code:
.PP
.Vb 1
\&     my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&
\&      uminus: UMINUS(., NUM($x), .) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($z), ., NUM($y))
\&         => {
\&        $z\->{attr} = eval  "$z\->{attr} $W\->{attr} $y\->{attr}";
\&        $_[0] = $NUM[0];
\&      }
\&      commutative_add: PLUS($x, ., $y, .)
\&        => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&      comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
\&         => {
\&        $x\->{attr} = $x\->{attr} * $y\->{attr};
\&        $_[0] = $DIV;
\&      }
\&      zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      times_zero: TIMES(., ., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      algebraic_transformations = constantfold zero_times times_zero comasocfold;
\&    },
\&    );
\&
\&    $transform\->generate();
\&    our ($uminus);
\&    $uminus\->s($tree);
.Ve
.PP
The transformations belonging to a family are usually applied 
together:
.PP
.Vb 1
\&                $tree\->s(@algebraic_transformations);
.Ve
.SS "Code Support"
.IX Subsection "Code Support"
In between Treeregexp rules and family assignments the programmer can insert 
Perl code between curly brackets. That code usually gives support to
the semantic conditions and transformations inside the rules.
See for example test 14 in the \f(CW\*(C`t/\*(C'\fR directory of the Parse::Eyapp distribution.
.PP
.Vb 7
\&  {
\&    sub not_semantic {
\&      my $self = shift;
\&      return  1 if $self\->{token} eq $self\->{attr};
\&      return 0;
\&    }
\&  }
\&
\&  delete_tokens : TERMINAL and { not_semantic($TERMINAL) } 
\&                           => { $delete_tokens\->delete() }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Treeregexp5.16.3pm             0100644 0001750 0001750 00000064613 12566242264 026302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Treeregexp 3"
.TH Parse::Eyapp::Treeregexp 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Treeregexp \- Tree transformations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use strict;
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    %left   NEG
\&    %tree
\&    %{
\&    use Tail2;  # See file examples/Tail2.pm in the distribution
\&    %}
\&
\&    %%
\&    block:  exp <%name BLOCK + \*(Aq;\*(Aq> { $_[1] }
\&    ;
\&
\&    exp:      %name NUM
\&                NUM
\&            | %name WHILE
\&                \*(Aqwhile\*(Aq   exp  \*(Aq{\*(Aq block \*(Aq}\*(Aq
\&            | %name VAR
\&                VAR
\&            | %name ASSIGN
\&                VAR \*(Aq=\*(Aq exp
\&            | %name PLUS
\&                exp \*(Aq+\*(Aq exp
\&            | %name MINUS
\&                exp \*(Aq\-\*(Aq exp
\&            | %name TIMES
\&                exp \*(Aq*\*(Aq exp
\&            | %name DIV
\&                exp \*(Aq/\*(Aq exp
\&            | %name UMINUS
\&                \*(Aq\-\*(Aq exp %prec NEG
\&            |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&  }; # end grammar
\&
\&  sub TERMINAL::info { $_[0]{attr} }
\&  $Parse::Eyapp::Node::INDENT = 2;
\&
\&  our (@all,$moveinvariant, $condition, $assign, $before, $after);
\&
\&  Parse::Eyapp\->new_grammar(
\&    input=>$grammar,
\&    classname=>\*(AqRule6\*(Aq,
\&    firstline=>7,
\&  );
\&  my $parser = Rule6\->new();
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  my $t = $parser\->Run(\e$program);
\&  my @output = split /\en/, $t\->str;
\&
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
\&  my @output2 = split /\en/, $t\->str;
\&
\&  my ($node1, $node2);
\&  format STDOUT_TOP =
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  @||||||||||||||||||||||||||||||||||||||||||||||||||||||
\&  $program
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  .
\&
\&  format STDOUT =
\&  @<<<<<<<<<<<<<<<<<<<<<<<<<<@|@<<<<<<<<<<<<<<<<<<<<<<<<<
\&  $node1,                    \*(Aq|\*(Aq,$node2
\&  .
\&
\&  for (1..$#output) {
\&    $node1 = $output[$_];
\&    $node2 = $output2[$_];
\&    write;
\&  }
.Ve
.SH "Introduction"
.IX Header "Introduction"
The example in the \s-1SYNOPSIS\s0 
section uses \f(CW\*(C`Parse::Eyapp\*(C'\fR to build an abstract
syntax tree for the program
.PP
.Vb 1
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
.Ve
.PP
The tree is transformed 
using the transformation \f(CW\*(C`moveinvariant\*(C'\fR:
.PP
.Vb 10
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
.Ve
.PP
The output shows the original tree versus the transformed
tree:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ moveinvariantoutofloopcomplexformula.pl
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  BLOCK(                     | BLOCK(
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[a],           |     TERMINAL[a],
\&      NUM(                   |     NUM(
\&        TERMINAL[1000]       |       TERMINAL[1000]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[c],           |     TERMINAL[c],
\&      NUM(                   |     NUM(
\&        TERMINAL[1]          |       TERMINAL[1]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    WHILE(                   |   ASSIGN(
\&      VAR(                   |     TERMINAL[b],
\&        TERMINAL[a]          |     NUM(
\&      ),                     |       TERMINAL[5]
\&      BLOCK(                 |     )
\&        ASSIGN(              |   ) # ASSIGN,
\&          TERMINAL[c],       |   WHILE(
\&          TIMES(             |     VAR(
\&            VAR(             |       TERMINAL[a]
\&              TERMINAL[c]    |     ),
\&            ),               |     BLOCK(
\&            VAR(             |       ASSIGN(
\&              TERMINAL[a]    |         TERMINAL[c],
\&            )                |         TIMES(
\&          ) # TIMES          |           VAR(
\&        ) # ASSIGN,          |             TERMINAL[c]
\&        ASSIGN(              |           ),
\&          TERMINAL[b],       |           VAR(
\&          NUM(               |             TERMINAL[a]
\&            TERMINAL[5]      |           )
\&          )                  |         ) # TIMES
\&        ) # ASSIGN,          |       ) # ASSIGN,
\&        ASSIGN(              |       ASSIGN(
\&          TERMINAL[a],       |         TERMINAL[a],
\&          MINUS(             |         MINUS(
\&            VAR(             |           VAR(
\&              TERMINAL[a]    |             TERMINAL[a]
\&            ),               |           ),
\&            NUM(             |           NUM(
\&              TERMINAL[1]    |             TERMINAL[1]
\&            )                |           )
\&          ) # MINUS          |         ) # MINUS
\&        ) # ASSIGN           |       ) # ASSIGN
\&      ) # BLOCK              |     ) # BLOCK
\&    ) # WHILE                |   ) # WHILE
\&  ) # BLOCK                  | ) # BLOCK
.Ve
.SH "The Treeregexp Language"
.IX Header "The Treeregexp Language"
A Treeregexp program is made of the repetition of three kind of 
primitives: The treeregexp transformations, supporting Perl code 
and Transformation Families.
.PP
.Vb 1
\&  treeregexplist:  treeregexp* 
\&
\&  treeregexp: 
\&      IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?  # Treeregexp 
\&    | CODE                            # Auxiliar code
\&    | IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq           # Transformation families
.Ve
.PP
Treeregexp themselves follow the rule:
.PP
.Vb 1
\&                  IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?
.Ve
.PP
Several instances of this rule can be seen in the example in
the \*(L"\s-1SYNOPSIS\s0\*(R" section.
The identifier \f(CW\*(C`IDENT\*(C'\fR gives the name to the rule.
At the time of this writing (2006) there are the following kinds
of treeregexes:
.PP
.Vb 10
\&  treereg: 
\&        /* tree patterns with children */
\&      IDENT \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?  
\&    | \*(Aq.\*(Aq \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&          /* leaf tree patterns */
\&    | IDENT (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? (\*(Aqand\*(Aq CODE)? 
\&    | \*(Aq.\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR (\*(Aqand\*(Aq CODE)? 
\&    | ARRAY 
\&    | \*(Aq*\*(Aq
.Ve
.SS "Treeregexp rules"
.IX Subsection "Treeregexp rules"
When seen a rule like
.PP
.Vb 1
\&    zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
The Treeregexp translator creates a \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR object
that can be later referenced in the user code by the package variable
\&\f(CW$zero_times\fR.
.PP
\fIThe treeregexp\fR
.IX Subsection "The treeregexp"
.PP
The first part of the rule \f(CW\*(C`TIMES(NUM($x), ., .)\*(C'\fR
indicates that for a matching to succeed the node being
visited must be of \f(CW\*(C`type\*(C'\fR \f(CW\*(C`TIMES\*(C'\fR, have a left child
of  \f(CW\*(C`type\*(C'\fR \f(CW\*(C`NUM\*(C'\fR and two more children.
.PP
If the first part succeeded then the following part 
takes the control to see if the \fIsemantic conditions\fR
are satisfied.
.PP
\fISemantic condition\fR
.IX Subsection "Semantic condition"
.PP
The second part is optional and must be prefixed by the reserved word \f(CW\*(C`and\*(C'\fR
followed by a Perl code manifesting the semantic conditions that must be hold
by the node to succeed. Thus, in the example:
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the semantic condition \f(CW\*(C`$x\->{attr} == 0\*(C'\fR states that the
value of the number stored in the \f(CW\*(C`TERMINAL\*(C'\fR node referenced
by \f(CW$x\fR must be zero.
.PP
\fIReferencing the matching nodes\fR
.IX Subsection "Referencing the matching nodes"
.PP
The node  being visited can be referenced/modified
inside the semantic actions using \f(CW$_[0]\fR.
.PP
The Treeregexp
translator automatically creates a set of lexical variables
for us. The scope of these variables is limited to the
semantic condition and the transformation code.
.PP
Thus, in the example
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the node being visited \f(CW$_[0]\fR
can be also referenced using the lexical variable
\&\f(CW$TIMES\fR which is created by he Treeregexp compiler.
In the same way a reference to the left child \f(CW\*(C`NUM\*(C'\fR will be stored
in the lexical variable \f(CW$NUM\fR and a
reference to the child of \f(CW$NUM\fR will be stored in \f(CW$x\fR.
The semantic condition states that the attribute
of the node associated with \f(CW$x\fR must be zero.
.PP
When the same type of node appears several times inside 
the treeregexp part the associated lexical variable is 
declared by the Treeregexp compiler as an array.
This is the case in the \f(CW\*(C`constantfold\*(C'\fR transformation
in the \*(L"\s-1SYNOPSIS\s0\*(R" example, where there are two nodes of type \f(CW\*(C`NUM\*(C'\fR:
.PP
.Vb 5
\&  constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
\&     => {
\&    $x\->{attr} = eval  "$x\->{attr} $W\->{attr} $y\->{attr}";
\&    $_[0] = $NUM[0];
\&  }
.Ve
.PP
Thus variable  \f(CW$NUM[0]\fR references the node that matches the 
first \f(CW\*(C`NUM\*(C'\fR term in the formula and \f(CW$NUM[1]\fR the one
that matches the second.
.PP
\fITransformation code\fR
.IX Subsection "Transformation code"
.PP
The third part of the rule is also optional and comes prefixed by
the big arrow \f(CW\*(C`=>\*(C'\fR. The Perl code in this section usually 
transforms the matching tree.
To achieve the modification of the tree, the Treeregexp programmer
\&\fBmust use \f(CB$_[0]\fB\fR and not the lexical variables provided by the translator.
Remember that in Perl \f(CW$_[0]\fR is an alias of the actual parameter.
The \f(CW\*(C`constantfold\*(C'\fR example above \fBwill not work\fR if we rewrite the code \f(CW$_[0] = $NUM[0]\fR as
.PP
.Vb 1
\&                            { $TIMES = $NUM }
.Ve
.SS "Regexp Treeregexes"
.IX Subsection "Regexp Treeregexes"
The previous \f(CW\*(C`constantfold\*(C'\fR example used a classic Perl linear regexp
to explicit that the root node of the matching subtree must match the Perl regexp.
The general syntax for \f(CW\*(C`REGEXP\*(C'\fR treeregexes patterns is:
.PP
.Vb 1
\&      treereg: REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?
.Ve
.PP
The \f(CW\*(C`REGEXP\*(C'\fR must be specified between slashes (other delimiters
as \f(CW\*(C`{}\*(C'\fR are not accepted).
It is legal to specify options after the second slash (like \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, etc.).
.PP
The operation of string oriented regexps is slightly modified
when they are used inside a treeregexp:
\&\fBby default the option\fR 
\&\f(CW\*(C`x\*(C'\fR 
\&\fBwill be assumed\fR.
The treeregexp compiler will automatically insert it.
Use the new option \f(CW\*(C`X\*(C'\fR (upper case X) if you want to suppress such behavior.
\&\fBThere is no need also to insert\fR \f(CW\*(C`\eb\*(C'\fR 
\&\fBword anchors\fR to delimit identifiers:
all the identifiers in a regexp treeregexp are automatically
surrounded by \f(CW\*(C`\eb\*(C'\fR. Use the option \f(CW\*(C`B\*(C'\fR (upper case B)
to suppress this behavior.
.PP
The optional identifier after the \f(CW\*(C`REGEXP\*(C'\fR indicates the name of the lexical variable
that will be held a reference to the node whose type matches \f(CW\*(C`REGEXP\*(C'\fR.
Variable \f(CW$W\fR (or \f(CW@W\fR if there are more than one \s-1REGEXP\s0 and or dot treeregexes)
will be used instead if no identifier is specified.
.SS "Scalar Treeregexes"
.IX Subsection "Scalar Treeregexes"
A scalar treeregxp is defined writing a Perl scalar inside the treeregexp, like \f(CW$x\fR
in \f(CW\*(C`NUM($x)\*(C'\fR. A scalar treeregxp immediately matches any node that exists
and stores a reference to such node inside the Perl lexical scalar variable.
The scope of the variable is limited to the semantic parts of the Treeregexp.
Is illegal to use \f(CW$W\fR or \f(CW\*(C`$W_#num\*(C'\fR as variable names for scalar treeregexes.
.SS "Dot Treeregexes"
.IX Subsection "Dot Treeregexes"
A dot matches any node. It can be seen as an abbreviation for
scalar treeregexes. The reference to the matching node
is stored in the lexical variable \f(CW$W\fR. 
The variable \f(CW@W\fR will be used instead
if there are more than one \s-1REGEXP\s0 and or dot treeregexes
.SS "Array Treeregexp Expressions"
.IX Subsection "Array Treeregexp Expressions"
The Treeregexp language permits expressions like:
.PP
.Vb 1
\&                   A(@a,B($x),@c)
.Ve
.PP
After the matching variable \f(CW@A\fR contains the shortest prefix
of \f(CW\*(C`$A\->children\*(C'\fR that does not match \f(CW\*(C`B($x)\*(C'\fR.
The variable \f(CW@c\fR contains the remaining suffix of
 \f(CW\*(C`$A\->children\*(C'\fR.
.PP
The following example uses 
array treereg expressions to move the assignment \f(CW\*(C`b = 5\*(C'\fR
out of the \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 10
\&  ..  ......................................................................
\&  93  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  94  $parser\->YYData\->{INPUT} = $program;
\&  95  my $t = $parser\->Run;
\&  96  my @output = split /\en/, $t\->str;
\&  97
\&  98  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  99    moveinvariant: BLOCK(
\& 100                     @prests,
\& 101                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\& 102                     @possts
\& 103                   )
\& 104      => {
\& 105           my $assign = $ASSIGN;
\& 106           $BLOCK[1]\->delete($ASSIGN);
\& 107           $BLOCK[0]\->insert_before($WHILE, $assign);
\& 108         }
\& 109    },
\& 110    FIRSTLINE => 99,
\& 111  );
\& 112  $p\->generate();
.Ve
.SS "Star Treeregexp"
.IX Subsection "Star Treeregexp"
Deprecated. Don't use it. Is still there but not to endure.
.SS "Transformation Families"
.IX Subsection "Transformation Families"
Transformations created by \f(CW\*(C`Parse::Eyapp::Treeregexp\*(C'\fR can be grouped in 
families. That is the function of the rule:
.PP
.Vb 1
\&                    treeregexp: IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq
.Ve
.PP
The next example (file \f(CW\*(C`examples/TSwithtreetransformations3.eyp\*(C'\fR)
defines the family
.PP
.Vb 1
\&     algebraic_transformations = constantfold zero_times times_zero comasocfold;
.Ve
.PP
Follows the code:
.PP
.Vb 1
\&     my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&
\&      uminus: UMINUS(., NUM($x), .) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($z), ., NUM($y))
\&         => {
\&        $z\->{attr} = eval  "$z\->{attr} $W\->{attr} $y\->{attr}";
\&        $_[0] = $NUM[0];
\&      }
\&      commutative_add: PLUS($x, ., $y, .)
\&        => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&      comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
\&         => {
\&        $x\->{attr} = $x\->{attr} * $y\->{attr};
\&        $_[0] = $DIV;
\&      }
\&      zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      times_zero: TIMES(., ., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      algebraic_transformations = constantfold zero_times times_zero comasocfold;
\&    },
\&    );
\&
\&    $transform\->generate();
\&    our ($uminus);
\&    $uminus\->s($tree);
.Ve
.PP
The transformations belonging to a family are usually applied 
together:
.PP
.Vb 1
\&                $tree\->s(@algebraic_transformations);
.Ve
.SS "Code Support"
.IX Subsection "Code Support"
In between Treeregexp rules and family assignments the programmer can insert 
Perl code between curly brackets. That code usually gives support to
the semantic conditions and transformations inside the rules.
See for example test 14 in the \f(CW\*(C`t/\*(C'\fR directory of the Parse::Eyapp distribution.
.PP
.Vb 7
\&  {
\&    sub not_semantic {
\&      my $self = shift;
\&      return  1 if $self\->{token} eq $self\->{attr};
\&      return 0;
\&    }
\&  }
\&
\&  delete_tokens : TERMINAL and { not_semantic($TERMINAL) } 
\&                           => { $delete_tokens\->delete() }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at http://code.google.com/p/parse\-eyapp/ <http://code.google.com/p/parse-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::Treeregexp5.18.3pm             0100644 0001750 0001750 00000064666 12566242263 026313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Treeregexp 3"
.TH Parse::Eyapp::Treeregexp 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Treeregexp \- Tree transformations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use strict;
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    %left   NEG
\&    %tree
\&    %{
\&    use Tail2;  # See file examples/Tail2.pm in the distribution
\&    %}
\&
\&    %%
\&    block:  exp <%name BLOCK + \*(Aq;\*(Aq> { $_[1] }
\&    ;
\&
\&    exp:      %name NUM
\&                NUM
\&            | %name WHILE
\&                \*(Aqwhile\*(Aq   exp  \*(Aq{\*(Aq block \*(Aq}\*(Aq
\&            | %name VAR
\&                VAR
\&            | %name ASSIGN
\&                VAR \*(Aq=\*(Aq exp
\&            | %name PLUS
\&                exp \*(Aq+\*(Aq exp
\&            | %name MINUS
\&                exp \*(Aq\-\*(Aq exp
\&            | %name TIMES
\&                exp \*(Aq*\*(Aq exp
\&            | %name DIV
\&                exp \*(Aq/\*(Aq exp
\&            | %name UMINUS
\&                \*(Aq\-\*(Aq exp %prec NEG
\&            |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&  }; # end grammar
\&
\&  sub TERMINAL::info { $_[0]{attr} }
\&  $Parse::Eyapp::Node::INDENT = 2;
\&
\&  our (@all,$moveinvariant, $condition, $assign, $before, $after);
\&
\&  Parse::Eyapp\->new_grammar(
\&    input=>$grammar,
\&    classname=>\*(AqRule6\*(Aq,
\&    firstline=>7,
\&  );
\&  my $parser = Rule6\->new();
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  my $t = $parser\->Run(\e$program);
\&  my @output = split /\en/, $t\->str;
\&
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
\&  my @output2 = split /\en/, $t\->str;
\&
\&  my ($node1, $node2);
\&  format STDOUT_TOP =
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  @||||||||||||||||||||||||||||||||||||||||||||||||||||||
\&  $program
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  .
\&
\&  format STDOUT =
\&  @<<<<<<<<<<<<<<<<<<<<<<<<<<@|@<<<<<<<<<<<<<<<<<<<<<<<<<
\&  $node1,                    \*(Aq|\*(Aq,$node2
\&  .
\&
\&  for (1..$#output) {
\&    $node1 = $output[$_];
\&    $node2 = $output2[$_];
\&    write;
\&  }
.Ve
.SH "Introduction"
.IX Header "Introduction"
The example in the \s-1SYNOPSIS\s0 
section uses \f(CW\*(C`Parse::Eyapp\*(C'\fR to build an abstract
syntax tree for the program
.PP
.Vb 1
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
.Ve
.PP
The tree is transformed 
using the transformation \f(CW\*(C`moveinvariant\*(C'\fR:
.PP
.Vb 10
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
.Ve
.PP
The output shows the original tree versus the transformed
tree:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ moveinvariantoutofloopcomplexformula.pl
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  BLOCK(                     | BLOCK(
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[a],           |     TERMINAL[a],
\&      NUM(                   |     NUM(
\&        TERMINAL[1000]       |       TERMINAL[1000]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[c],           |     TERMINAL[c],
\&      NUM(                   |     NUM(
\&        TERMINAL[1]          |       TERMINAL[1]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    WHILE(                   |   ASSIGN(
\&      VAR(                   |     TERMINAL[b],
\&        TERMINAL[a]          |     NUM(
\&      ),                     |       TERMINAL[5]
\&      BLOCK(                 |     )
\&        ASSIGN(              |   ) # ASSIGN,
\&          TERMINAL[c],       |   WHILE(
\&          TIMES(             |     VAR(
\&            VAR(             |       TERMINAL[a]
\&              TERMINAL[c]    |     ),
\&            ),               |     BLOCK(
\&            VAR(             |       ASSIGN(
\&              TERMINAL[a]    |         TERMINAL[c],
\&            )                |         TIMES(
\&          ) # TIMES          |           VAR(
\&        ) # ASSIGN,          |             TERMINAL[c]
\&        ASSIGN(              |           ),
\&          TERMINAL[b],       |           VAR(
\&          NUM(               |             TERMINAL[a]
\&            TERMINAL[5]      |           )
\&          )                  |         ) # TIMES
\&        ) # ASSIGN,          |       ) # ASSIGN,
\&        ASSIGN(              |       ASSIGN(
\&          TERMINAL[a],       |         TERMINAL[a],
\&          MINUS(             |         MINUS(
\&            VAR(             |           VAR(
\&              TERMINAL[a]    |             TERMINAL[a]
\&            ),               |           ),
\&            NUM(             |           NUM(
\&              TERMINAL[1]    |             TERMINAL[1]
\&            )                |           )
\&          ) # MINUS          |         ) # MINUS
\&        ) # ASSIGN           |       ) # ASSIGN
\&      ) # BLOCK              |     ) # BLOCK
\&    ) # WHILE                |   ) # WHILE
\&  ) # BLOCK                  | ) # BLOCK
.Ve
.SH "The Treeregexp Language"
.IX Header "The Treeregexp Language"
A Treeregexp program is made of the repetition of three kind of 
primitives: The treeregexp transformations, supporting Perl code 
and Transformation Families.
.PP
.Vb 1
\&  treeregexplist:  treeregexp* 
\&
\&  treeregexp: 
\&      IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?  # Treeregexp 
\&    | CODE                            # Auxiliar code
\&    | IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq           # Transformation families
.Ve
.PP
Treeregexp themselves follow the rule:
.PP
.Vb 1
\&                  IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?
.Ve
.PP
Several instances of this rule can be seen in the example in
the \*(L"\s-1SYNOPSIS\*(R"\s0 section.
The identifier \f(CW\*(C`IDENT\*(C'\fR gives the name to the rule.
At the time of this writing (2006) there are the following kinds
of treeregexes:
.PP
.Vb 10
\&  treereg: 
\&        /* tree patterns with children */
\&      IDENT \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?  
\&    | \*(Aq.\*(Aq \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&          /* leaf tree patterns */
\&    | IDENT (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? (\*(Aqand\*(Aq CODE)? 
\&    | \*(Aq.\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR (\*(Aqand\*(Aq CODE)? 
\&    | ARRAY 
\&    | \*(Aq*\*(Aq
.Ve
.SS "Treeregexp rules"
.IX Subsection "Treeregexp rules"
When seen a rule like
.PP
.Vb 1
\&    zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
The Treeregexp translator creates a \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR object
that can be later referenced in the user code by the package variable
\&\f(CW$zero_times\fR.
.PP
\fIThe treeregexp\fR
.IX Subsection "The treeregexp"
.PP
The first part of the rule \f(CW\*(C`TIMES(NUM($x), ., .)\*(C'\fR
indicates that for a matching to succeed the node being
visited must be of \f(CW\*(C`type\*(C'\fR \f(CW\*(C`TIMES\*(C'\fR, have a left child
of  \f(CW\*(C`type\*(C'\fR \f(CW\*(C`NUM\*(C'\fR and two more children.
.PP
If the first part succeeded then the following part 
takes the control to see if the \fIsemantic conditions\fR
are satisfied.
.PP
\fISemantic condition\fR
.IX Subsection "Semantic condition"
.PP
The second part is optional and must be prefixed by the reserved word \f(CW\*(C`and\*(C'\fR
followed by a Perl code manifesting the semantic conditions that must be hold
by the node to succeed. Thus, in the example:
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the semantic condition \f(CW\*(C`$x\->{attr} == 0\*(C'\fR states that the
value of the number stored in the \f(CW\*(C`TERMINAL\*(C'\fR node referenced
by \f(CW$x\fR must be zero.
.PP
\fIReferencing the matching nodes\fR
.IX Subsection "Referencing the matching nodes"
.PP
The node  being visited can be referenced/modified
inside the semantic actions using \f(CW$_[0]\fR.
.PP
The Treeregexp
translator automatically creates a set of lexical variables
for us. The scope of these variables is limited to the
semantic condition and the transformation code.
.PP
Thus, in the example
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the node being visited \f(CW$_[0]\fR
can be also referenced using the lexical variable
\&\f(CW$TIMES\fR which is created by he Treeregexp compiler.
In the same way a reference to the left child \f(CW\*(C`NUM\*(C'\fR will be stored
in the lexical variable \f(CW$NUM\fR and a
reference to the child of \f(CW$NUM\fR will be stored in \f(CW$x\fR.
The semantic condition states that the attribute
of the node associated with \f(CW$x\fR must be zero.
.PP
When the same type of node appears several times inside 
the treeregexp part the associated lexical variable is 
declared by the Treeregexp compiler as an array.
This is the case in the \f(CW\*(C`constantfold\*(C'\fR transformation
in the \*(L"\s-1SYNOPSIS\*(R"\s0 example, where there are two nodes of type \f(CW\*(C`NUM\*(C'\fR:
.PP
.Vb 5
\&  constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
\&     => {
\&    $x\->{attr} = eval  "$x\->{attr} $W\->{attr} $y\->{attr}";
\&    $_[0] = $NUM[0];
\&  }
.Ve
.PP
Thus variable  \f(CW$NUM[0]\fR references the node that matches the 
first \f(CW\*(C`NUM\*(C'\fR term in the formula and \f(CW$NUM[1]\fR the one
that matches the second.
.PP
\fITransformation code\fR
.IX Subsection "Transformation code"
.PP
The third part of the rule is also optional and comes prefixed by
the big arrow \f(CW\*(C`=>\*(C'\fR. The Perl code in this section usually 
transforms the matching tree.
To achieve the modification of the tree, the Treeregexp programmer
\&\fBmust use \f(CB$_[0]\fB\fR and not the lexical variables provided by the translator.
Remember that in Perl \f(CW$_[0]\fR is an alias of the actual parameter.
The \f(CW\*(C`constantfold\*(C'\fR example above \fBwill not work\fR if we rewrite the code \f(CW$_[0] = $NUM[0]\fR as
.PP
.Vb 1
\&                            { $TIMES = $NUM }
.Ve
.SS "Regexp Treeregexes"
.IX Subsection "Regexp Treeregexes"
The previous \f(CW\*(C`constantfold\*(C'\fR example used a classic Perl linear regexp
to explicit that the root node of the matching subtree must match the Perl regexp.
The general syntax for \f(CW\*(C`REGEXP\*(C'\fR treeregexes patterns is:
.PP
.Vb 1
\&      treereg: REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?
.Ve
.PP
The \f(CW\*(C`REGEXP\*(C'\fR must be specified between slashes (other delimiters
as \f(CW\*(C`{}\*(C'\fR are not accepted).
It is legal to specify options after the second slash (like \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, etc.).
.PP
The operation of string oriented regexps is slightly modified
when they are used inside a treeregexp:
\&\fBby default the option\fR 
\&\f(CW\*(C`x\*(C'\fR 
\&\fBwill be assumed\fR.
The treeregexp compiler will automatically insert it.
Use the new option \f(CW\*(C`X\*(C'\fR (upper case X) if you want to suppress such behavior.
\&\fBThere is no need also to insert\fR \f(CW\*(C`\eb\*(C'\fR 
\&\fBword anchors\fR to delimit identifiers:
all the identifiers in a regexp treeregexp are automatically
surrounded by \f(CW\*(C`\eb\*(C'\fR. Use the option \f(CW\*(C`B\*(C'\fR (upper case B)
to suppress this behavior.
.PP
The optional identifier after the \f(CW\*(C`REGEXP\*(C'\fR indicates the name of the lexical variable
that will be held a reference to the node whose type matches \f(CW\*(C`REGEXP\*(C'\fR.
Variable \f(CW$W\fR (or \f(CW@W\fR if there are more than one \s-1REGEXP\s0 and or dot treeregexes)
will be used instead if no identifier is specified.
.SS "Scalar Treeregexes"
.IX Subsection "Scalar Treeregexes"
A scalar treeregxp is defined writing a Perl scalar inside the treeregexp, like \f(CW$x\fR
in \f(CW\*(C`NUM($x)\*(C'\fR. A scalar treeregxp immediately matches any node that exists
and stores a reference to such node inside the Perl lexical scalar variable.
The scope of the variable is limited to the semantic parts of the Treeregexp.
Is illegal to use \f(CW$W\fR or \f(CW\*(C`$W_#num\*(C'\fR as variable names for scalar treeregexes.
.SS "Dot Treeregexes"
.IX Subsection "Dot Treeregexes"
A dot matches any node. It can be seen as an abbreviation for
scalar treeregexes. The reference to the matching node
is stored in the lexical variable \f(CW$W\fR. 
The variable \f(CW@W\fR will be used instead
if there are more than one \s-1REGEXP\s0 and or dot treeregexes
.SS "Array Treeregexp Expressions"
.IX Subsection "Array Treeregexp Expressions"
The Treeregexp language permits expressions like:
.PP
.Vb 1
\&                   A(@a,B($x),@c)
.Ve
.PP
After the matching variable \f(CW@A\fR contains the shortest prefix
of \f(CW\*(C`$A\->children\*(C'\fR that does not match \f(CW\*(C`B($x)\*(C'\fR.
The variable \f(CW@c\fR contains the remaining suffix of
 \f(CW\*(C`$A\->children\*(C'\fR.
.PP
The following example uses 
array treereg expressions to move the assignment \f(CW\*(C`b = 5\*(C'\fR
out of the \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 10
\&  ..  ......................................................................
\&  93  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  94  $parser\->YYData\->{INPUT} = $program;
\&  95  my $t = $parser\->Run;
\&  96  my @output = split /\en/, $t\->str;
\&  97
\&  98  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  99    moveinvariant: BLOCK(
\& 100                     @prests,
\& 101                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\& 102                     @possts
\& 103                   )
\& 104      => {
\& 105           my $assign = $ASSIGN;
\& 106           $BLOCK[1]\->delete($ASSIGN);
\& 107           $BLOCK[0]\->insert_before($WHILE, $assign);
\& 108         }
\& 109    },
\& 110    FIRSTLINE => 99,
\& 111  );
\& 112  $p\->generate();
.Ve
.SS "Star Treeregexp"
.IX Subsection "Star Treeregexp"
Deprecated. Don't use it. Is still there but not to endure.
.SS "Transformation Families"
.IX Subsection "Transformation Families"
Transformations created by \f(CW\*(C`Parse::Eyapp::Treeregexp\*(C'\fR can be grouped in 
families. That is the function of the rule:
.PP
.Vb 1
\&                    treeregexp: IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq
.Ve
.PP
The next example (file \f(CW\*(C`examples/TSwithtreetransformations3.eyp\*(C'\fR)
defines the family
.PP
.Vb 1
\&     algebraic_transformations = constantfold zero_times times_zero comasocfold;
.Ve
.PP
Follows the code:
.PP
.Vb 1
\&     my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&
\&      uminus: UMINUS(., NUM($x), .) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($z), ., NUM($y))
\&         => {
\&        $z\->{attr} = eval  "$z\->{attr} $W\->{attr} $y\->{attr}";
\&        $_[0] = $NUM[0];
\&      }
\&      commutative_add: PLUS($x, ., $y, .)
\&        => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&      comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
\&         => {
\&        $x\->{attr} = $x\->{attr} * $y\->{attr};
\&        $_[0] = $DIV;
\&      }
\&      zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      times_zero: TIMES(., ., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      algebraic_transformations = constantfold zero_times times_zero comasocfold;
\&    },
\&    );
\&
\&    $transform\->generate();
\&    our ($uminus);
\&    $uminus\->s($tree);
.Ve
.PP
The transformations belonging to a family are usually applied 
together:
.PP
.Vb 1
\&                $tree\->s(@algebraic_transformations);
.Ve
.SS "Code Support"
.IX Subsection "Code Support"
In between Treeregexp rules and family assignments the programmer can insert 
Perl code between curly brackets. That code usually gives support to
the semantic conditions and transformations inside the rules.
See for example test 14 in the \f(CW\*(C`t/\*(C'\fR directory of the Parse::Eyapp distribution.
.PP
.Vb 7
\&  {
\&    sub not_semantic {
\&      my $self = shift;
\&      return  1 if $self\->{token} eq $self\->{attr};
\&      return 0;
\&    }
\&  }
\&
\&  delete_tokens : TERMINAL and { not_semantic($TERMINAL) } 
\&                           => { $delete_tokens\->delete() }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::YATW.3pm                       0100644 0001750 0001750 00000061555 12566242262 024442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::YATW 3"
.TH Parse::Eyapp::YATW 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::YATW \- Tree transformation objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  #!/usr/bin/perl \-w
\&  use strict;
\&  use Rule6;
\&  use Parse::Eyapp::YATW;
\&
\&  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&
\&  sub set_terminfo {
\&    no warnings;
\&    *TERMINAL::info = sub { $_[0]{attr} };
\&  }
\&  sub is_foldable {
\&    my ($op, $left, $right);
\&    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&
\&    my $leftnum = $left\->child(0)\->{attr};
\&    my $rightnum = $right\->child(0)\->{attr};
\&    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    $_[0] = $left;
\&  }
\&
\&  my $parser = new Rule6();
\&  my $input = "2*3";
\&  my $t = $parser\->Run(\e$input);
\&  &set_terminfo;
\&  print "\en***** Before ******\en";
\&  print $t\->str;
\&  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  $p\->s($t);
\&  print "\en***** After ******\en";
\&  print $t\->str."\en";
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects implement tree transformations.
They have two attributes \f(CW\*(C`PATTERN\*(C'\fR and \f(CW\*(C`NAME\*(C'\fR.
\&\f(CW\*(C`PATTERN\*(C'\fR is a reference to the code implementing the transformation.
\&\f(CW\*(C`NAME\*(C'\fR is the name of the transformation.
.PP
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method \f(CW\*(C`new\*(C'\fR to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
.PP
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutine \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The function \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section
(file \f(CW\*(C`examples/YATW/foldrule6.pl\*(C'\fR)
holds the properties to be a \s-1YATW\s0 tree transformation
.PP
.Vb 12
\&     1    sub is_foldable {
\&     2      my ($op, $left, $right);
\&     3  
\&     4      return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&     5      return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&     6      return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&     7  
\&     8      my $leftnum = $left\->child(0)\->{attr};
\&     9      my $rightnum = $right\->child(0)\->{attr};
\&    10      $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    11      $_[0] = $left;
\&    12    }
.Ve
.PP
First, checks that the current node is one of \f(CW\*(C`PLUS\*(C'\fR, \f(CW\*(C`MINUS\*(C'\fR, \f(CW\*(C`TIMES\*(C'\fR or
\&\f(CW\*(C`DIV\*(C'\fR (line 4). Then checks that both children are \f(CW\*(C`NUM\*(C'\fRbers (lines 5 and 6).
In such case proceeds to modify its left child with the result of operating
both children (line 10). The matching tree is finally substituted by its left child
(line 11).
.PP
This is the output of the program in the \s-1SYNOPSIS\s0 section:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ eyapp Rule6.yp; foldrule6.pl
\&
\&  ***** Before ******
\&  TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\&  ***** After ******
\&  NUM(TERMINAL[6])
.Ve
.PP
Follows the grammar description file in \f(CW\*(C`Rule6.yp\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Rule6.yp
\&     1  %{
\&     2  use Data::Dumper;
\&     3  %}
\&     4  %right  \*(Aq=\*(Aq
\&     5  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     6  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     7  %left   NEG
\&     8  %tree
\&     9
\&    10  %%
\&    11  line: exp  { $_[1] }
\&    12  ;
\&    13
\&    14  exp:      %name NUM
\&    15              NUM
\&    16          | %name VAR
\&    17            VAR
\&    18          | %name ASSIGN
\&    19            VAR \*(Aq=\*(Aq exp
\&    20          | %name PLUS
\&    21            exp \*(Aq+\*(Aq exp
\&    22          | %name MINUS
\&    23            exp \*(Aq\-\*(Aq exp
\&    24          | %name TIMES
\&    25            exp \*(Aq*\*(Aq exp
\&    26          | %name DIV
\&    27            exp \*(Aq/\*(Aq exp
\&    28          | %name UMINUS
\&    29            \*(Aq\-\*(Aq exp %prec NEG
\&    30          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    31  ;
\&    32
\&    33  %%
\&    34
\&    35  use Tail2;
.Ve
.PP
The module \f(CW\*(C`Tail2\*(C'\fR in file \f(CW\*(C`examples/Tail2.pm\*(C'\fR  implements the lexical 
analyzer plus the \f(CW\*(C`error\*(C'\fR and \f(CW\*(C`run\*(C'\fR methods.
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::YATW5.16.3pm                   0100644 0001750 0001750 00000061503 12566242265 024750  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::YATW 3"
.TH Parse::Eyapp::YATW 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::YATW \- Tree transformation objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  #!/usr/bin/perl \-w
\&  use strict;
\&  use Rule6;
\&  use Parse::Eyapp::YATW;
\&
\&  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&
\&  sub set_terminfo {
\&    no warnings;
\&    *TERMINAL::info = sub { $_[0]{attr} };
\&  }
\&  sub is_foldable {
\&    my ($op, $left, $right);
\&    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&
\&    my $leftnum = $left\->child(0)\->{attr};
\&    my $rightnum = $right\->child(0)\->{attr};
\&    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    $_[0] = $left;
\&  }
\&
\&  my $parser = new Rule6();
\&  my $input = "2*3";
\&  my $t = $parser\->Run(\e$input);
\&  &set_terminfo;
\&  print "\en***** Before ******\en";
\&  print $t\->str;
\&  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  $p\->s($t);
\&  print "\en***** After ******\en";
\&  print $t\->str."\en";
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects implement tree transformations.
They have two attributes \f(CW\*(C`PATTERN\*(C'\fR and \f(CW\*(C`NAME\*(C'\fR.
\&\f(CW\*(C`PATTERN\*(C'\fR is a reference to the code implementing the transformation.
\&\f(CW\*(C`NAME\*(C'\fR is the name of the transformation.
.PP
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method \f(CW\*(C`new\*(C'\fR to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
.PP
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutine \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The function \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section
(file \f(CW\*(C`examples/YATW/foldrule6.pl\*(C'\fR)
holds the properties to be a \s-1YATW\s0 tree transformation
.PP
.Vb 12
\&     1    sub is_foldable {
\&     2      my ($op, $left, $right);
\&     3  
\&     4      return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&     5      return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&     6      return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&     7  
\&     8      my $leftnum = $left\->child(0)\->{attr};
\&     9      my $rightnum = $right\->child(0)\->{attr};
\&    10      $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    11      $_[0] = $left;
\&    12    }
.Ve
.PP
First, checks that the current node is one of \f(CW\*(C`PLUS\*(C'\fR, \f(CW\*(C`MINUS\*(C'\fR, \f(CW\*(C`TIMES\*(C'\fR or
\&\f(CW\*(C`DIV\*(C'\fR (line 4). Then checks that both children are \f(CW\*(C`NUM\*(C'\fRbers (lines 5 and 6).
In such case proceeds to modify its left child with the result of operating
both children (line 10). The matching tree is finally substituted by its left child
(line 11).
.PP
This is the output of the program in the \s-1SYNOPSIS\s0 section:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ eyapp Rule6.yp; foldrule6.pl
\&
\&  ***** Before ******
\&  TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\&  ***** After ******
\&  NUM(TERMINAL[6])
.Ve
.PP
Follows the grammar description file in \f(CW\*(C`Rule6.yp\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Rule6.yp
\&     1  %{
\&     2  use Data::Dumper;
\&     3  %}
\&     4  %right  \*(Aq=\*(Aq
\&     5  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     6  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     7  %left   NEG
\&     8  %tree
\&     9
\&    10  %%
\&    11  line: exp  { $_[1] }
\&    12  ;
\&    13
\&    14  exp:      %name NUM
\&    15              NUM
\&    16          | %name VAR
\&    17            VAR
\&    18          | %name ASSIGN
\&    19            VAR \*(Aq=\*(Aq exp
\&    20          | %name PLUS
\&    21            exp \*(Aq+\*(Aq exp
\&    22          | %name MINUS
\&    23            exp \*(Aq\-\*(Aq exp
\&    24          | %name TIMES
\&    25            exp \*(Aq*\*(Aq exp
\&    26          | %name DIV
\&    27            exp \*(Aq/\*(Aq exp
\&    28          | %name UMINUS
\&    29            \*(Aq\-\*(Aq exp %prec NEG
\&    30          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    31  ;
\&    32
\&    33  %%
\&    34
\&    35  use Tail2;
.Ve
.PP
The module \f(CW\*(C`Tail2\*(C'\fR in file \f(CW\*(C`examples/Tail2.pm\*(C'\fR  implements the lexical 
analyzer plus the \f(CW\*(C`error\*(C'\fR and \f(CW\*(C`run\*(C'\fR methods.
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW  Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at http://code.google.com/p/parse\-eyapp/ <http://code.google.com/p/parse-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::YATW5.18.3pm                   0100644 0001750 0001750 00000061555 12566242262 024756  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::YATW 3"
.TH Parse::Eyapp::YATW 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::YATW \- Tree transformation objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  #!/usr/bin/perl \-w
\&  use strict;
\&  use Rule6;
\&  use Parse::Eyapp::YATW;
\&
\&  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&
\&  sub set_terminfo {
\&    no warnings;
\&    *TERMINAL::info = sub { $_[0]{attr} };
\&  }
\&  sub is_foldable {
\&    my ($op, $left, $right);
\&    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&
\&    my $leftnum = $left\->child(0)\->{attr};
\&    my $rightnum = $right\->child(0)\->{attr};
\&    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    $_[0] = $left;
\&  }
\&
\&  my $parser = new Rule6();
\&  my $input = "2*3";
\&  my $t = $parser\->Run(\e$input);
\&  &set_terminfo;
\&  print "\en***** Before ******\en";
\&  print $t\->str;
\&  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  $p\->s($t);
\&  print "\en***** After ******\en";
\&  print $t\->str."\en";
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects implement tree transformations.
They have two attributes \f(CW\*(C`PATTERN\*(C'\fR and \f(CW\*(C`NAME\*(C'\fR.
\&\f(CW\*(C`PATTERN\*(C'\fR is a reference to the code implementing the transformation.
\&\f(CW\*(C`NAME\*(C'\fR is the name of the transformation.
.PP
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method \f(CW\*(C`new\*(C'\fR to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
.PP
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutine \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The function \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section
(file \f(CW\*(C`examples/YATW/foldrule6.pl\*(C'\fR)
holds the properties to be a \s-1YATW\s0 tree transformation
.PP
.Vb 12
\&     1    sub is_foldable {
\&     2      my ($op, $left, $right);
\&     3  
\&     4      return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&     5      return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&     6      return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&     7  
\&     8      my $leftnum = $left\->child(0)\->{attr};
\&     9      my $rightnum = $right\->child(0)\->{attr};
\&    10      $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    11      $_[0] = $left;
\&    12    }
.Ve
.PP
First, checks that the current node is one of \f(CW\*(C`PLUS\*(C'\fR, \f(CW\*(C`MINUS\*(C'\fR, \f(CW\*(C`TIMES\*(C'\fR or
\&\f(CW\*(C`DIV\*(C'\fR (line 4). Then checks that both children are \f(CW\*(C`NUM\*(C'\fRbers (lines 5 and 6).
In such case proceeds to modify its left child with the result of operating
both children (line 10). The matching tree is finally substituted by its left child
(line 11).
.PP
This is the output of the program in the \s-1SYNOPSIS\s0 section:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ eyapp Rule6.yp; foldrule6.pl
\&
\&  ***** Before ******
\&  TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\&  ***** After ******
\&  NUM(TERMINAL[6])
.Ve
.PP
Follows the grammar description file in \f(CW\*(C`Rule6.yp\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Rule6.yp
\&     1  %{
\&     2  use Data::Dumper;
\&     3  %}
\&     4  %right  \*(Aq=\*(Aq
\&     5  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     6  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     7  %left   NEG
\&     8  %tree
\&     9
\&    10  %%
\&    11  line: exp  { $_[1] }
\&    12  ;
\&    13
\&    14  exp:      %name NUM
\&    15              NUM
\&    16          | %name VAR
\&    17            VAR
\&    18          | %name ASSIGN
\&    19            VAR \*(Aq=\*(Aq exp
\&    20          | %name PLUS
\&    21            exp \*(Aq+\*(Aq exp
\&    22          | %name MINUS
\&    23            exp \*(Aq\-\*(Aq exp
\&    24          | %name TIMES
\&    25            exp \*(Aq*\*(Aq exp
\&    26          | %name DIV
\&    27            exp \*(Aq/\*(Aq exp
\&    28          | %name UMINUS
\&    29            \*(Aq\-\*(Aq exp %prec NEG
\&    30          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    31  ;
\&    32
\&    33  %%
\&    34
\&    35  use Tail2;
.Ve
.PP
The module \f(CW\*(C`Tail2\*(C'\fR in file \f(CW\*(C`examples/Tail2.pm\*(C'\fR  implements the lexical 
analyzer plus the \f(CW\*(C`error\*(C'\fR and \f(CW\*(C`run\*(C'\fR methods.
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::datagenerationtut.3pm          0100644 0001750 0001750 00000102160 12566242263 027365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::datagenerationtut 3"
.TH Parse::Eyapp::datagenerationtut 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::datagenerationtut \- Tutorial on Using Parse::Eyapp as a Data Generator for Testing
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The examples for this tutorial can be found in the directory 
\&\f(CW\*(C`examples/generator\*(C'\fR in the distribution of \f(CW\*(C`Parse::Eyapp\*(C'\fR.
.PP
To understand the code you will need some familiarity with Test::LectroTest::Generator,
however, we will make an attempt to introduce the basics of Test::LectroTest::Generator
needed.
.PP
While parsing is the process of determining the membership of a string to a language, 
generation is the reverse problem. Using a context free grammar it is possible to generate 
strings belonging to the language described by that grammar.
.PP
Context free grammars can be used to generate tests. The programmer designs a grammar that
defines a set of inputs that will be able to find some set of bugs.
.PP
This tutorial shows how to use Parse::Eyapp to generate phrases belonging to the language
defined by a given grammar. We will generate inputs to test a simple calculator.
.SS "Compiling and Running the Example"
.IX Subsection "Compiling and Running the Example"
The grammar describing the language is in the file \f(CW\*(C`Generator.eyp\*(C'\fR.
Calling eyapp with option \f(CW\*(C`\-c\*(C'\fR will show the contents of the file 
without the semantic actions:
.PP
.Vb 11
\&  Parse\-Eyapp/examples/generator$ eyapp \-c Generator.eyp
\&  # file: Generator.eyp
\&  # compile with: eyapp \-b \*(Aq\*(Aq Generator.eyp
\&  # then run: ./Generator.pm
\&  %strict
\&  %token NUM VARDEF VAR
\&  %right \*(Aq=\*(Aq
\&  %left \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  %left NEG
\&  %right \*(Aq^\*(Aq
\&
\&  %%
\&
\&  stmts:
\&        stmt
\&      | stmts \*(Aq;\*(Aq  stmt
\&  ;
\&  stmt:
\&        VARDEF \*(Aq=\*(Aq exp
\&  ;
\&  exp:
\&        NUM
\&      | VAR
\&      | exp \*(Aq+\*(Aq exp
\&      | exp \*(Aq\-\*(Aq exp
\&      | exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq  exp %prec NEG
\&      | exp \*(Aq^\*(Aq exp
\&      | \*(Aq(\*(Aq  exp \*(Aq)\*(Aq
\&  ;
\&
\&  %%
.Ve
.PP
This grammar defines  a language of sequences of semicolon separated assignments.
The right hand side of an assignment can be any valid arithmetic
expression including numbers and variables.
.PP
First we compile the grammar with option \f(CW\*(C`\-b \*(Aq\*(Aq\*(C'\fR to produce a \fImodulino\fR:
.PP
.Vb 1
\&  Parse\-Eyapp/examples/generator$ eyapp \-b \*(Aq\*(Aq Generator.eyp
.Ve
.PP
Now, the module has execution permits and its first line contains the \f(CW\*(C`#!\*(C'\fR header:
.PP
.Vb 4
\&  Parse\-Eyapp/examples/generator$ ls \-ltr | tail \-1
\&  \-rwxr\-xr\-x 1 lusasoft lusasoft 7844 2009\-01\-12 08:30 Generator.pm
\&  Parse\-Eyapp/examples/generator$ head \-1 Generator.pm
\&  #!/usr/bin/perl
.Ve
.PP
The use of option \f(CW\*(C`\-b \*(Aq\*(Aq\*(C'\fR combined with the fact that we have added these lines
.PP
.Vb 3
\&    67  unless (caller) {
\&    68    _\|_PACKAGE_\|_\->main(@ARGV);
\&    69  }
.Ve
.PP
at the end of the grammar file \f(CW\*(C`Generator.eyp\*(C'\fR provide the generated file
with a dual nature: it is a module and an executable at the same time. This is
what is know as a modulino (term coined by Brian d Foy).
.PP
Here follows the results of several executions. Each run produces
a set of assignments. The first output line reports the result 
of the randomly generated program.
.PP
.Vb 3
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&  # result: \-3
\&  SC=\-3
\&
\&  # result: error. Division by zero.
\&  M=(\-4/6+4)+9+2*8*9+4;
\&  XQ=8/3;
\&  EI=XQ*2/0/0;
\&  BL=5+EI+4/5/XQ
.Ve
.PP
As you can see in the former run, only variables that were defined
in previous assignments are used in later assignments. However, the 
generated source may produce run-time errors and exceptions (which
is good thing when testing a calculator).
.PP
.Vb 1
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&
\&  # result: 6
\&  CF=(6)
\&
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&
\&  # result: \-710.2
\&  I=(3*\-8+7/5);
\&  R=2+8*I*4+5*2+I/I
\&
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&
\&  # result: Calculator syntax differs from Perl... 
\&  RY=2\-\-2+(3+6)+(7*7*4^1+2*0/8*5/3)
.Ve
.SH "GENERATING PHRASES FROM A CONTEXT FREE GRAMMAR"
.IX Header "GENERATING PHRASES FROM A CONTEXT FREE GRAMMAR"
.ie n .SS "Using ""YYExpect"" and Test::LectroTest::Generator to generate tokens"
.el .SS "Using \f(CWYYExpect\fP and Test::LectroTest::Generator to generate tokens"
.IX Subsection "Using YYExpect and Test::LectroTest::Generator to generate tokens"
The basic idea of using Parse::Eyapp to generate phrases for the language
defined by a given context free grammar is simple: \fIchange the lexer by a token generator\fR. 
Instead of reading from some input, randomly generate one of the \fIvalid tokens\fR.
.PP
We can use the method \f(CW\*(C`YYExpect\*(C'\fR to know what tokens are valid. 
For versions 1.137 and later of Parse::Eyapp, the method \f(CW\*(C`YYExpect\*(C'\fR returns
the set of valid tokens at the time it is called.
For previous versions (and this is also true for Parse::Yapp), \f(CW\*(C`YYExpect\*(C'\fR only returns
a subset of the whole set of valid tokens.
.PP
In this example, the token
generator has been isolated in the sub \f(CW\*(C`gen_lexer\*(C'\fR in the file \f(CW\*(C`GenSupport.pm\*(C'\fR:
.PP
.Vb 9
\&    47  sub gen_lexer {
\&    48    my $parser = shift;
\&    49
\&    50    my $token = $parser\->generate_token;
\&    51    my $attr = $parser\->generate_attribute($token);
\&    52    #$attr = $WHITESPACES\->generate.$attr;
\&    53
\&    54    return ($token, $attr);
\&    55  }
.Ve
.PP
The token and its attribute are generated in lines 50 and 51.
The methods \f(CW\*(C`generate_token\*(C'\fR and \f(CW\*(C`generate_attribute\*(C'\fR are also
in the module \f(CW\*(C`GenSupport.pm\*(C'\fR. They are methods of the 
parser object since the grammar \f(CW\*(C`Generator.eyp\*(C'\fR not only uses but inherits
this module. See line 3 of \f(CW\*(C`Generator.eyp\*(C'\fR:
.PP
.Vb 7
\&  Parse\-Eyapp/examples/generator$ sed \-ne \*(Aq19,24p\*(Aq Generator.eyp | cat \-n
\&     1  %{
\&     2  use base q{Parse::Eyapp::TokenGen};
\&     3  use base q{GenSupport};
\&     4  %}
\&     5
\&     6  %%
.Ve
.PP
The method \f(CW\*(C`generate_token\*(C'\fR obtains the set of valid tokens using \f(CW\*(C`YYExpect\*(C'\fR (line 29).
Then uses the \f(CW\*(C`Frequency\*(C'\fR function in Test::LectroTest::Generator to produce 
a \f(CW\*(C`Test::LectroTest::Generator\*(C'\fR object (line 31). The method \f(CW\*(C`generate\*(C'\fR of such object
is used to generate the actual token (line 33).
.PP
.Vb 9
\&    26  sub generate_token {
\&    27    my $parser = shift;
\&    28
\&    29    my @token = $parser\->YYExpect;
\&    30
\&    31    my $tokengen = Frequency( map { [$parser\->token_weight($_), Unit($_)] } @token);
\&    32
\&    33    return $tokengen\->generate;
\&    34  }
.Ve
.PP
The Parse::Eyapp::TokenGen method \f(CW\*(C`token_weight\*(C'\fR returns the weight 
associated with a token, assuming it was previously set using one of
the Parse::Eyapp::TokenGen methods like \f(CW\*(C`set_tokenweightsandgenerators\*(C'\fR
or \f(CW\*(C`set_tokenweights\*(C'\fR. See the code of method \f(CW\*(C`main\*(C'\fR in \f(CW\*(C`GenSupport.pm\*(C'\fR:
.PP
.Vb 10
\&  examples/generator$ sed \-ne \*(Aq98,/^ *)/p\*(Aq GenSupport.pm | cat \-n
\&     1    my $parser = $package\->new();
\&     2
\&     3    $parser\->set_tokenweightsandgenerators(
\&     4      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&     5      VAR => [
\&     6                0,  # At the beginning, no variables are defined
\&     7                Gen {
\&     8                  return  Elements(keys %st)\->generate if keys %st;
\&     9                  return Int(range=>[0, 9], sized=>0)\->generate;
\&    10                },
\&    11              ],
\&    12      VARDEF => [
\&    13                  2,
\&    14                  String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&    15                ],
\&    16      \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2,
\&    17      \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5,
\&    18      \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2,
\&    19      \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&    20    );
.Ve
.SS "A Brief Introduction to Test::LectroTest::Generator"
.IX Subsection "A Brief Introduction to Test::LectroTest::Generator"
The module \f(CW\*(C`GenSupport.pm\*(C'\fR uses Test::LectroTest::Generator to build generators
for the required tokens. Thus the call to
.PP
.Vb 1
\&                   Int(range=>[0, 9], sized=>0)
.Ve
.PP
builds a Test::LectroTest::Generator object that produces integers in the range 
[0,9]. Such objects have a method \f(CW\*(C`generate\*(C'\fR that produces the 
actual item. The following debugger session illustrates the way to use Test::LectroTest::Generator:
.PP
.Vb 8
\&  pl@europa:~/LEyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Test::LectroTest::Generator qw{:all}
\&    DB<2> $i = Int(range=>[0, 9], sized=>0)
\&    DB<3> p $i\->generate
\&  6
\&    DB<4> p $i\->generate
\&  9
.Ve
.PP
The \f(CW\*(C`String\*(C'\fR method builds a Test::LectroTest::Generator object that produces
strings:
.PP
.Vb 7
\&    DB<5> $v = String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&    DB<6> p $v\->generate
\&  HM
\&    DB<7> p $v\->generate
\&  Y
\&    DB<8> p $v\->generate
\&  KE
.Ve
.PP
The \f(CW\*(C`Elements\*(C'\fR method builds a Test::LectroTest::Generator object that produces
one of a given list of elements:
.PP
.Vb 10
\&    DB<9> @a = map { $v\->generate } 1..10
\&    DB<10> x @a
\&  0  \*(AqUC\*(Aq
\&  1  \*(AqP\*(Aq
\&  2  \*(AqIF\*(Aq
\&  3  \*(AqEJ\*(Aq
\&  4  \*(AqH\*(Aq
\&  5  \*(AqVC\*(Aq
\&  6  \*(AqCF\*(Aq
\&  7  \*(AqK\*(Aq
\&  8  \*(AqT\*(Aq
\&  9  \*(AqIG\*(Aq
\&    DB<11> $x = Elements(@a)
\&    DB<12> p $x\->generate
\&  P
\&    DB<13> p $x\->generate
\&  P
\&    DB<14> p $x\->generate
\&  EJ
\&    DB<15> p $x\->generate
\&  VC
.Ve
.PP
Even more interesting for our purpose is the \f(CW\*(C`Frequency\*(C'\fR method, 
which produces one of a given list of elements with a given 
probability distribution.
.PP
The following example illustrates its use.
First we build a weight list where the odd elements
have weight 2 and the even elements have weight 1:
.PP
.Vb 10
\&  DB<16> @w = map { $_ % 2 ? 2 : 1 } 0..9
\&  DB<21> @w{@a} = @w
\&  DB<24>  x \e%w
\&    0  HASH(0xd3cc80)
\&       \*(AqCF\*(Aq => 1
\&       \*(AqEJ\*(Aq => 2
\&       \*(AqH\*(Aq => 1
\&       \*(AqIF\*(Aq => 1
\&       \*(AqIG\*(Aq => 2
\&       \*(AqK\*(Aq => 2
\&       \*(AqP\*(Aq => 2
\&       \*(AqT\*(Aq => 1
\&       \*(AqUC\*(Aq => 1
\&       \*(AqVC\*(Aq => 2
.Ve
.PP
We now use \f(CW\*(C`Frequency\*(C'\fR to build a  Test::LectroTest::Generator object that produces
one of the given list of elements \f(CW@a\fR according to the specified probability:
.PP
.Vb 1
\&  DB<29> $f = Frequency( map { [$w{$_}, Unit($_)] } @a)
.Ve
.PP
Let us generate 10 items. We see that odd elements appear more frequently than
even elements:
.PP
.Vb 3
\&  DB<30> @r = map { $f\->generate } 1..10
\&  DB<31> p "@r"
\&    VC UC K UC VC VC K EJ P P
.Ve
.SS "Generating Token Attributes"
.IX Subsection "Generating Token Attributes"
Once the token was generated through the call to \f(CW\*(C`generate_token\*(C'\fR
at line 50:
.PP
.Vb 11
\&    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \et\en", size => 100 );
\&    46
\&    47  sub gen_lexer {
\&    48    my $parser = shift;
\&    49
\&    50    my $token = $parser\->generate_token;
\&    51    my $attr = $parser\->generate_attribute($token);
\&    52    #$attr = $WHITESPACES\->generate.$attr;
\&    53
\&    54    return ($token, $attr);
\&    55  }
.Ve
.PP
the associated attributed is generated via the \f(CW\*(C`generate_attribute\*(C'\fR
method in \f(CW\*(C`GenSupport.pm\*(C'\fR.  If needed, random combination of
white spaces can be added to the generated attribute
via an appropriate generator (line 52).
.PP
The \f(CW\*(C`generate_attribute\*(C'\fR method uses the method \f(CW\*(C`generate\*(C'\fR
of the generator associated with such token.
If no  generator object was set, the 
attribute returned is the token itself (line 42):
.PP
.Vb 8
\&    36  sub generate_attribute {
\&    37    my $parser = shift;
\&    38    my $token = shift;
\&    39
\&    40    my $gen = $parser\->token_generator($token);
\&    41    return $gen\->generate  if defined($gen);
\&    42    return $token;
\&    43  }
.Ve
.SS "Holding Semantic Constraints"
.IX Subsection "Holding Semantic Constraints"
The attribute generator associated with the token \f(CW\*(C`VAR\*(C'\fR is more complex
than the others. It was defined in the call to \f(CW\*(C`set_tokenweightsandgenerators\*(C'\fR:
.PP
.Vb 10
\&  examples/generator$ sed \-ne \*(Aq98,/^ *)/p\*(Aq GenSupport.pm | cat \-n
\&     1    my $parser = $package\->new();
\&     2
\&     3    $parser\->set_tokenweightsandgenerators(
\&     4      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&     5      VAR => [
\&     6                0,  # At the beginning, no variables are defined
\&     7                Gen {
\&     8                  return  Elements(keys %st)\->generate if keys %st;
\&     9                  return Int(range=>[0, 9], sized=>0)\->generate;
\&    10                },
\&    11              ],
\&    12      VARDEF => [
\&    13                  2,
\&    14                  String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&    15                ],
\&    16      \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2,
\&    17      \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5,
\&    18      \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2,
\&    19      \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&    20    );
.Ve
.PP
The \f(CW\*(C`Gen\*(C'\fR function of Test::LectroTest::Generator creates a new generator 
from a given code. Since a variable can't be used unless it is defined,
we use a symbol table \f(CW%st\fR to keep record of the variables that were defined 
in previous assignments. If no defined variables exists, the defined generator 
returns a digit between 0 and 9.
.PP
Each time a new assignment to a variable occurs, such 
variable is added to the symbol table. This is achieved
through the semantic action associated with the assignment
production rule:
.PP
.Vb 8
\&  examples/generator$ sed \-ne \*(Aq35,41p\*(Aq Generator.eyp | cat \-n
\&     1  stmt:
\&     2      VARDEF \*(Aq=\*(Aq exp
\&     3        {
\&     4          my $parser = shift;
\&     5          $parser\->defined_variable($_[0]);
\&     6          "$_[0]=$_[2]";
\&     7        }
.Ve
.PP
The \f(CW\*(C`defined_variable\*(C'\fR method in \f(CW\*(C`GenSupport.pm\*(C'\fR simply sets the corresponding
entry in the symbol table:
.PP
.Vb 7
\&  examples/generator$ sed \-ne \*(Aq19,24p\*(Aq GenSupport.pm | cat \-n
\&     1  my %st; # Symbol Table
\&     2  sub defined_variable {
\&     3    my ($parser, $var) = @_;
\&     4
\&     5    $st{$var} = 1;
\&     6  }
.Ve
.PP
The semantic action associated with \f(CW\*(C`VARDEF \*(Aq=\*(Aq exp\*(C'\fR returns the string 
\&\f(CW "$_[0]=$_[2]"\fR containing the actual phrase. Since this  
is the semantic action required for most productions we make it
our default action:
.PP
.Vb 6
\&  examples/generator$ sed \-ne \*(Aq13,17p\*(Aq Generator.eyp | cat \-n
\&     1  %defaultaction {
\&     2    my $parser = shift;
\&     3
\&     4    return join \*(Aq\*(Aq, @_;
\&     5  }
.Ve
.PP
The syntactic variable \f(CW\*(C`stmts\*(C'\fR generates sequences of \f(CW\*(C`stmt\*(C'\fR separated by 
semicolons:
.PP
.Vb 9
\&  examples/generator$ sed \-ne \*(Aq26,33p\*(Aq Generator.eyp | cat \-n
\&     1  stmts:
\&     2      stmt
\&     3        {
\&     4          $_[0]\->deltaweight(VAR => +1); # At least one variable is defined now
\&     5          $_[1];
\&     6        }
\&     7    | stmts \*(Aq;\*(Aq { "\en" } stmt
\&     8  ;
.Ve
.PP
The second production is left recursive. As a consequence, the \f(CW\*(C`stmt\*(C'\fR in the first
production (line 2) is the first statement of the sequence. A small derivation can convince
you of this property:
.PP
.Vb 3
\&                                               stmts\-> stmt
\&   stmts => stmts\*(Aq;\*(Aq stmt => stmts\*(Aq;\*(Aq stmt \*(Aq;\*(Aq stmt => stmt \*(Aq;\*(Aq stmt \*(Aq;\*(Aq stmt 
\&                                                       \-\-\-\-
.Ve
.PP
Thus, when the reduction by the production \f(CW\*(C`stmts \-> stmt\*(C'\fR occurs, we are sure 
that the first statement has been processed. In such case we increase the weight
of token \f(CW\*(C`VAR\*(C'\fR one unit (which was initially zero, see the call 
to \f(CW\*(C`set_tokenweightsandgenerators\*(C'\fR),
.PP
.Vb 1
\&           $_[0]\->deltaweight(VAR => +1);
.Ve
.PP
The weight of \f(CW\*(C`VAR\*(C'\fR is now 1, giving chances for variables to appear
in the right hand side of an assignment. 
The Parse::Eyapp::Tokengen method \f(CW\*(C`deltaweight\*(C'\fR increases (decreases
if negative) the weight of the given tokens using the associated values.
.SS "Dynamically Changing the Probability Distribution"
.IX Subsection "Dynamically Changing the Probability Distribution"
The semantic actions for the productions
.PP
.Vb 1
\&               exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
and
.PP
.Vb 1
\&               exp \-> \*(Aq\-\*(Aq exp
.Ve
.PP
show a way to modify the weights associated with some tokens:
.PP
.Vb 10
\& 43 exp:
\& 44     NUM
\& 45   | VAR
\& 46   | exp \*(Aq+\*(Aq exp
\& 47   | exp \*(Aq\-\*(Aq exp
\& 48   | exp \*(Aq*\*(Aq exp
\& 49   | exp \*(Aq/\*(Aq exp
\& 50   | \*(Aq\-\*(Aq { $_[0]\->pushdeltaweight(\*(Aq\-\*(Aq => \-1) } exp %prec NEG
\& 51       {
\& 52         $_[0]\->popweight();
\& 53         "\-$_[3]"
\& 54       }
\& 55   | exp \*(Aq^\*(Aq exp
\& 56   | \*(Aq(\*(Aq   { $_[0]\->pushdeltaweight(\*(Aq(\*(Aq => \-1, \*(Aq)\*(Aq => +1, \*(Aq+\*(Aq => +1, ); }
\& 57       exp
\& 58     \*(Aq)\*(Aq
\& 59       {
\& 60          $_[0]\->popweight;
\& 61          "($_[3])"
\& 62       }
\& 63 ;
.Ve
.PP
After seeing a \f(CW\*(Aq(\*(Aq\fR we decrease by one the weight of \f(CW\*(Aq(\*(Aq\fR to avoid
expressions with nested parenthesis. We also increase the weight of token \f(CW\*(Aq+\*(Aq\fR,
since parenthesis are often used to give more priority to a sum over a multiplication
or division. This is achieved via the \f(CW\*(C`pushdeltaweight\*(C'\fR method. The old 
weight is recovered after the closing parenthesis is seen using the
\&\f(CW\*(C`popweight\*(C'\fR method.
.SS "Computing the Expected Result"
.IX Subsection "Computing the Expected Result"
Function \f(CW\*(C`evaluate_using_perl\*(C'\fR in \f(CW\*(C`GenSupport.pm\*(C'\fR
finds the expected value for the generated
expression. The calculator expression is roughly translated
to a Perl expression and evaluated using the Perl interpreter:
.PP
.Vb 10
\& 57 sub evaluate_using_perl { # if possible
\& 58   my $perlexp = shift;
\& 59
\& 60   $perlexp =~ s/\eb([a\-zA\-Z])/\e$$1/g; # substitute A by $A everywhere
\& 61   $perlexp =~ s/\e^/**/g;             # substitute power operator: ^ by **
\& 62
\& 63   my $res = eval "no warnings; no strict;$perlexp";
\& 64   if ($@ =~ /Illegal division/) {
\& 65     $res = "error. Division by zero.";
\& 66   }
\& 67   elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
\& 68     # Perl interprets \-\- in a different way
\& 69     $@ =~ m{(.*)}; # Show only the first line of error message
\& 70     $res = "Calculator syntax differs from Perl. Can\*(Aqt compute the result: $1";
\& 71   }
\& 72
\& 73   $res;
\& 74 }
.Ve
.PP
The calculator language differs from Perl. In the calculator, two consecutive minus 
like in \f(CW\*(C`2\-\-3\*(C'\fR are interpreted as \f(CW\*(C`2+3\*(C'\fR while for Perl the former expression is an error.
This limitation is here to illustrate a limitation of the approach: it gives 
a way to generate complex structured inputs but the programmer must find a 
way to compute what the expected value is.
.SH "APPENDIX: FILES"
.IX Header "APPENDIX: FILES"
.ie n .SS "File ""GenSupport.pm"""
.el .SS "File \f(CWGenSupport.pm\fP"
.IX Subsection "File GenSupport.pm"
.Vb 10
\&  Parse\-Eyapp/examples/generator$ cat \-n GenSupport.pm
\&     1  package GenSupport;
\&     2  use strict;
\&     3  use warnings;
\&     4
\&     5  use Getopt::Long;
\&     6  use Test::LectroTest::Generator qw(:all);
\&     7  use Parse::Eyapp::TokenGen;
\&     8
\&     9  sub _Error {
\&    10    my $parser = shift;
\&    11
\&    12    my $t = $parser\->YYCurval;
\&    13    my @e = $parser\->YYExpect();
\&    14    my $attr = $parser\->YYSemval(0);
\&    15    local $" = " ";
\&    16    warn "Error:\enCurrent attribute: <$attr>\enCurrent token: <$t>\enExpected: <@e>\en";
\&    17  }
\&    18
\&    19  my %st; # Symbol Table
\&    20  sub defined_variable {
\&    21    my ($parser, $var) = @_;
\&    22
\&    23    $st{$var} = 1;
\&    24  }
\&    25
\&    26  sub generate_token {
\&    27    my $parser = shift;
\&    28
\&    29    my @token = $parser\->YYExpect;
\&    30
\&    31    my $tokengen = Frequency( map { [$parser\->token_weight($_), Unit($_)] } @token);
\&    32
\&    33    return $tokengen\->generate;
\&    34  }
\&    35
\&    36  sub generate_attribute {
\&    37    my $parser = shift;
\&    38    my $token = shift;
\&    39
\&    40    my $gen = $parser\->token_generator($token);
\&    41    return $gen\->generate  if defined($gen);
\&    42    return $token;
\&    43  }
\&    44
\&    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \et\en", size => 100 );
\&    46
\&    47  sub gen_lexer {
\&    48    my $parser = shift;
\&    49
\&    50    my $token = $parser\->generate_token;
\&    51    my $attr = $parser\->generate_attribute($token);
\&    52    #$attr = $WHITESPACES\->generate.$attr;
\&    53
\&    54    return ($token, $attr);
\&    55  }
\&    56
\&    57  sub evaluate_using_perl { # if possible
\&    58    my $perlexp = shift;
\&    59
\&    60    $perlexp =~ s/\eb([a\-zA\-Z])/\e$$1/g; # substitute A by $A everywhere
\&    61    $perlexp =~ s/\e^/**/g;             # substitute power operator: ^ by **
\&    62
\&    63    my $res = eval "no warnings; no strict;$perlexp";
\&    64    if ($@ =~ /Illegal division/) {
\&    65      $res = "error. Division by zero.";
\&    66    }
\&    67    elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
\&    68      # Perl interprets \-\- in a different way
\&    69      $@ =~ m{(.*)}; # Show only the first line of error message
\&    70      $res = "Calculator syntax differs from Perl. Can\*(Aqt compute the result: $1";
\&    71    }
\&    72
\&    73    $res;
\&    74  }
\&    75
\&    76
\&    77  sub Run {
\&    78      my($self)=shift;
\&    79      my $yydebug = shift || 0;
\&    80
\&    81      return $self\->YYParse(
\&    82        yylex => \e&gen_lexer,
\&    83        yyerror => \e&_Error,
\&    84        yydebug => $yydebug, # 0x1F
\&    85      );
\&    86  }
\&    87
\&    88  sub main {
\&    89    my $package = shift;
\&    90
\&    91    my $debug = shift || 0;
\&    92    my $result = GetOptions (
\&    93      "debug!" => \e$debug,
\&    94    );
\&    95
\&    96    $debug = 0x1F if $debug;
\&    97
\&    98    my $parser = $package\->new();
\&    99
\&   100    $parser\->set_tokenweightsandgenerators(
\&   101      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&   102      VAR => [
\&   103                0,  # At the beginning, no variables are defined
\&   104                Gen {
\&   105                  return  Elements(keys %st)\->generate if keys %st;
\&   106                  return Int(range=>[0, 9], sized=>0)\->generate;
\&   107                },
\&   108              ],
\&   109      VARDEF => [
\&   110                  2,
\&   111                  String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&   112                ],
\&   113      \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2,
\&   114      \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5,
\&   115      \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2,
\&   116      \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&   117    );
\&   118
\&   119    my $exp = $parser\->Run( $debug );
\&   120
\&   121    my $res = evaluate_using_perl($exp);
\&   122
\&   123    print "\en# result: $res\en$exp\en";
\&   124  }
\&   125
\&   126  1;
.Ve
.ie n .SS "File ""Generator.eyp"""
.el .SS "File \f(CWGenerator.eyp\fP"
.IX Subsection "File Generator.eyp"
.Vb 10
\&  Parse\-Eyapp/examples/generator$ cat \-n Generator.eyp
\&     1  # file: Generator.eyp
\&     2  # compile with: eyapp \-b \*(Aq\*(Aq Generator.eyp
\&     3  # then run: ./Generator.pm
\&     4  %strict
\&     5  %token NUM VARDEF VAR
\&     6
\&     7  %right  \*(Aq=\*(Aq
\&     8  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     9  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    10  %left   NEG
\&    11  %right  \*(Aq^\*(Aq
\&    12
\&    13  %defaultaction {
\&    14    my $parser = shift;
\&    15
\&    16    return join \*(Aq\*(Aq, @_;
\&    17  }
\&    18
\&    19  %{
\&    20  use base q{Parse::Eyapp::TokenGen};
\&    21  use base q{GenSupport};
\&    22  %}
\&    23
\&    24  %%
\&    25
\&    26  stmts:
\&    27      stmt
\&    28        {
\&    29          $_[0]\->deltaweight(VAR => +1); # At least one variable is defined now
\&    30          $_[1];
\&    31        }
\&    32    | stmts \*(Aq;\*(Aq { "\en" } stmt
\&    33  ;
\&    34
\&    35  stmt:
\&    36      VARDEF \*(Aq=\*(Aq exp
\&    37        {
\&    38          my $parser = shift;
\&    39          $parser\->defined_variable($_[0]);
\&    40          "$_[0]=$_[2]";
\&    41        }
\&    42  ;
\&    43  exp:
\&    44      NUM
\&    45    | VAR
\&    46    | exp \*(Aq+\*(Aq exp
\&    47    | exp \*(Aq\-\*(Aq exp
\&    48    | exp \*(Aq*\*(Aq exp
\&    49    | exp \*(Aq/\*(Aq exp
\&    50    | \*(Aq\-\*(Aq { $_[0]\->pushdeltaweight(\*(Aq\-\*(Aq => \-1) } exp %prec NEG
\&    51        {
\&    52          $_[0]\->popweight();
\&    53          "\-$_[3]"
\&    54        }
\&    55    | exp \*(Aq^\*(Aq exp
\&    56    | \*(Aq(\*(Aq   { $_[0]\->pushdeltaweight(\*(Aq(\*(Aq => \-1, \*(Aq)\*(Aq => +1, \*(Aq+\*(Aq => +1, ); }
\&    57        exp
\&    58      \*(Aq)\*(Aq
\&    59        {
\&    60           $_[0]\->popweight;
\&    61           "($_[3])"
\&    62        }
\&    63  ;
\&    64
\&    65  %%
\&    66
\&    67  unless (caller) {
\&    68    _\|_PACKAGE_\|_\->main(@ARGV);
\&    69  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp::TokenGen
.IP "\(bu" 4
Test::LectroTest::Generator by Tom Moertel
.IP "\(bu" 4
The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
<http://www.cs.ubc.ca/local/reading/proceedings/spe91\-95/spe/./vol22/issue3/spe756pm.pdf>
.IP "\(bu" 4
yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
\&\s-1ASE \s0'05: Proceedings of the 20th \s-1IEEE/ACM\s0 internati