, 1},
	},
	R32: []Range32{
		{0x10137, 0x1013f, 1},
		{0x10179, 0x10189, 1},
		{0x1018c, 0x10190, 4},
		{0x10191, 0x1019b, 1},
		{0x101a0, 0x101d0, 48},
		{0x101d1, 0x101fc, 1},
		{0x10877, 0x10878, 1},
		{0x10ac8, 0x1173f, 3191},
		{0x16b3c, 0x16b3f, 1},
		{0x16b45, 0x1bc9c, 20823},
		{0x1d000, 0x1d0f5, 1},
		{0x1d100, 0x1d126, 1},
		{0x1d129, 0x1d164, 1},
		{0x1d16a, 0x1d16c, 1},
		{0x1d183, 0x1d184, 1},
		{0x1d18c, 0x1d1a9, 1},
		{0x1d1ae, 0x1d1e8, 1},
		{0x1d200, 0x1d241, 1},
		{0x1d245, 0x1d300, 187},
		{0x1d301, 0x1d356, 1},
		{0x1d6c1, 0x1d6db, 26},
		{0x1d6fb, 0x1d715, 26},
		{0x1d735, 0x1d74f, 26},
		{0x1d76f, 0x1d789, 26},
		{0x1d7a9, 0x1d7c3, 26},
		{0x1d800, 0x1d9ff, 1},
		{0x1da37, 0x1da3a, 1},
		{0x1da6d, 0x1da74, 1},
		{0x1da76, 0x1da83, 1},
		{0x1da85, 0x1da86, 1},
		{0x1eef0, 0x1eef1, 1},
		{0x1f000, 0x1f02b, 1},
		{0x1f030, 0x1f093, 1},
		{0x1f0a0, 0x1f0ae, 1},
		{0x1f0b1, 0x1f0bf, 1},
		{0x1f0c1, 0x1f0cf, 1},
		{0x1f0d1, 0x1f0f5, 1},
		{0x1f110, 0x1f12e, 1},
		{0x1f130, 0x1f16b, 1},
		{0x1f170, 0x1f19a, 1},
		{0x1f1e6, 0x1f202, 1},
		{0x1f210, 0x1f23a, 1},
		{0x1f240, 0x1f248, 1},
		{0x1f250, 0x1f251, 1},
		{0x1f300, 0x1f579, 1},
		{0x1f57b, 0x1f5a3, 1},
		{0x1f5a5, 0x1f6d0, 1},
		{0x1f6e0, 0x1f6ec, 1},
		{0x1f6f0, 0x1f6f3, 1},
		{0x1f700, 0x1f773, 1},
		{0x1f780, 0x1f7d4, 1},
		{0x1f800, 0x1f80b, 1},
		{0x1f810, 0x1f847, 1},
		{0x1f850, 0x1f859, 1},
		{0x1f860, 0x1f887, 1},
		{0x1f890, 0x1f8ad, 1},
		{0x1f910, 0x1f918, 1},
		{0x1f980, 0x1f984, 1},
		{0x1f9c0, 0x1f9c0, 1},
	},
	LatinOffset: 10,
}

var _Sc = &RangeTable{
	R16: []Range16{
		{0x0024, 0x00a2, 126},
		{0x00a3, 0x00a5, 1},
		{0x058f, 0x060b, 124},
		{0x09f2, 0x09f3, 1},
		{0x09fb, 0x0af1, 246},
		{0x0bf9, 0x0e3f, 582},
		{0x17db, 0x20a0, 2245},
		{0x20a1, 0x20be, 1},
		{0xa838, 0xfdfc, 21956},
		{0xfe69, 0xff04, 155},
		{0xffe0, 0xffe1, 1},
		{0xffe5, 0xffe6, 1},
	},
	LatinOffset: 2,
}

var _Sk = &RangeTable{
	R16: []Range16{
		{0x005e, 0x0060, 2},
		{0x00a8, 0x00af, 7},
		{0x00b4, 0x00b8, 4},
		{0x02c2, 0x02c5, 1},
		{0x02d2, 0x02df, 1},
		{0x02e5, 0x02eb, 1},
		{0x02ed, 0x02ef, 2},
		{0x02f0, 0x02ff, 1},
		{0x0375, 0x0384, 15},
		{0x0385, 0x1fbd, 7224},
		{0x1fbf, 0x1fc1, 1},
		{0x1fcd, 0x1fcf, 1},
		{0x1fdd, 0x1fdf, 1},
		{0x1fed, 0x1fef, 1},
		{0x1ffd, 0x1ffe, 1},
		{0x309b, 0x309c, 1},
		{0xa700, 0xa716, 1},
		{0xa720, 0xa721, 1},
		{0xa789, 0xa78a, 1},
		{0xab5b, 0xfbb2, 20567},
		{0xfbb3, 0xfbc1, 1},
		{0xff3e, 0xff40, 2},
		{0xffe3, 0xffe3, 1},
	},
	R32: []Range32{
		{0x1f3fb, 0x1f3fb, 1},
		{0x1f3fc, 0x1f3ff, 1},
	},
	LatinOffset: 3,
}

var _Sm = &RangeTable{
	R16: []Range16{
		{0x002b, 0x003c, 17},
		{0x003d, 0x003e, 1},
		{0x007c, 0x007e, 2},
		{0x00ac, 0x00b1, 5},
		{0x00d7, 0x00f7, 32},
		{0x03f6, 0x0606, 528},
		{0x0607, 0x0608, 1},
		{0x2044, 0x2052, 14},
		{0x207a, 0x207c, 1},
		{0x208a, 0x208c, 1},
		{0x2118, 0x2140, 40},
		{0x2141, 0x2144, 1},
		{0x214b, 0x2190, 69},
		{0x2191, 0x2194, 1},
		{0x219a, 0x219b, 1},
		{0x21a0, 0x21a6, 3},
		{0x21ae, 0x21ce, 32},
		{0x21cf, 0x21d2, 3},
		{0x21d4, 0x21f4, 32},
		{0x21f5, 0x22ff, 1},
		{0x2320, 0x2321, 1},
		{0x237c, 0x239b, 31},
		{0x239c, 0x23b3, 1},
		{0x23dc, 0x23e1, 1},
		{0x25b7, 0x25c1, 10},
		{0x25f8, 0x25ff, 1},
		{0x266f, 0x27c0, 337},
		{0x27c1, 0x27c4, 1},
		{0x27c7, 0x27e5, 1},
		{0x27f0, 0x27ff, 1},
		{0x2900, 0x2982, 1},
		{0x2999, 0x29d7, 1},
		{0x29dc, 0x29fb, 1},
		{0x29fe, 0x2aff, 1},
		{0x2b30, 0x2b44, 1},
		{0x2b47, 0x2b4c, 1},
		{0xfb29, 0xfe62, 825},
		{0xfe64, 0xfe66, 1},
		{0xff0b, 0xff1c, 17},
		{0xff1d, 0xff1e, 1},
		{0xff5c, 0xff5e, 2},
		{0xffe2, 0xffe9, 7},
		{0xffea, 0xffec, 1},
	},
	R32: []Range32{
		{0x1d6c1, 0x1d6db, 26},
		{0x1d6fb, 0x1d715, 26},
		{0x1d735, 0x1d74f, 26},
		{0x1d76f, 0x1d789, 26},
		{0x1d7a9, 0x1d7c3, 26},
		{0x1eef0, 0x1eef1, 1},
	},
	LatinOffset: 5,
}

var _So = &RangeTable{
	R16: []Range16{
		{0x00a6, 0x00a9, 3},
		{0x00ae, 0x00b0, 2},
		{0x0482, 0x058d, 267},
		{0x058e, 0x060e, 128},
		{0x060f, 0x06de, 207},
		{0x06e9, 0x06fd, 20},
		{0x06fe, 0x07f6, 248},
		{0x09fa, 0x0b70, 374},
		{0x0bf3, 0x0bf8, 1},
		{0x0bfa, 0x0c7f, 133},
		{0x0d79, 0x0f01, 392},
		{0x0f02, 0x0f03, 1},
		{0x0f13, 0x0f15, 2},
		{0x0f16, 0x0f17, 1},
		{0x0f1a, 0x0f1f, 1},
		{0x0f34, 0x0f38, 2},
		{0x0fbe, 0x0fc5, 1},
		{0x0fc7, 0x0fcc, 1},
		{0x0fce, 0x0fcf, 1},
		{0x0fd5, 0x0fd8, 1},
		{0x109e, 0x109f, 1},
		{0x1390, 0x1399, 1},
		{0x1940, 0x19de, 158},
		{0x19df, 0x19ff, 1},
		{0x1b61, 0x1b6a, 1},
		{0x1b74, 0x1b7c, 1},
		{0x2100, 0x2101, 1},
		{0x2103, 0x2106, 1},
		{0x2108, 0x2109, 1},
		{0x2114, 0x2116, 2},
		{0x2117, 0x211e, 7},
		{0x211f, 0x2123, 1},
		{0x2125, 0x2129, 2},
		{0x212e, 0x213a, 12},
		{0x213b, 0x214a, 15},
		{0x214c, 0x214d, 1},
		{0x214f, 0x218a, 59},
		{0x218b, 0x2195, 10},
		{0x2196, 0x2199, 1},
		{0x219c, 0x219f, 1},
		{0x21a1, 0x21a2, 1},
		{0x21a4, 0x21a5, 1},
		{0x21a7, 0x21ad, 1},
		{0x21af, 0x21cd, 1},
		{0x21d0, 0x21d1, 1},
		{0x21d3, 0x21d5, 2},
		{0x21d6, 0x21f3, 1},
		{0x2300, 0x2307, 1},
		{0x230c, 0x231f, 1},
		{0x2322, 0x2328, 1},
		{0x232b, 0x237b, 1},
		{0x237d, 0x239a, 1},
		{0x23b4, 0x23db, 1},
		{0x23e2, 0x23fa, 1},
		{0x2400, 0x2426, 1},
		{0x2440, 0x244a, 1},
		{0x249c, 0x24e9, 1},
		{0x2500, 0x25b6, 1},
		{0x25b8, 0x25c0, 1},
		{0x25c2, 0x25f7, 1},
		{0x2600, 0x266e, 1},
		{0x2670, 0x2767, 1},
		{0x2794, 0x27bf, 1},
		{0x2800, 0x28ff, 1},
		{0x2b00, 0x2b2f, 1},
		{0x2b45, 0x2b46, 1},
		{0x2b4d, 0x2b73, 1},
		{0x2b76, 0x2b95, 1},
		{0x2b98, 0x2bb9, 1},
		{0x2bbd, 0x2bc8, 1},
		{0x2bca, 0x2bd1, 1},
		{0x2bec, 0x2bef, 1},
		{0x2ce5, 0x2cea, 1},
		{0x2e80, 0x2e99, 1},
		{0x2e9b, 0x2ef3, 1},
		{0x2f00, 0x2fd5, 1},
		{0x2ff0, 0x2ffb, 1},
		{0x3004, 0x3012, 14},
		{0x3013, 0x3020, 13},
		{0x3036, 0x3037, 1},
		{0x303e, 0x303f, 1},
		{0x3190, 0x3191, 1},
		{0x3196, 0x319f, 1},
		{0x31c0, 0x31e3, 1},
		{0x3200, 0x321e, 1},
		{0x322a, 0x3247, 1},
		{0x3250, 0x3260, 16},
		{0x3261, 0x327f, 1},
		{0x328a, 0x32b0, 1},
		{0x32c0, 0x32fe, 1},
		{0x3300, 0x33ff, 1},
		{0x4dc0, 0x4dff, 1},
		{0xa490, 0xa4c6, 1},
		{0xa828, 0xa82b, 1},
		{0xa836, 0xa837, 1},
		{0xa839, 0xaa77, 574},
		{0xaa78, 0xaa79, 1},
		{0xfdfd, 0xffe4, 487},
		{0xffe8, 0xffed, 5},
		{0xffee, 0xfffc, 14},
		{0xfffd, 0xfffd, 1},
	},
	R32: []Range32{
		{0x10137, 0x10137, 1},
		{0x10138, 0x1013f, 1},
		{0x10179, 0x10189, 1},
		{0x1018c, 0x10190, 4},
		{0x10191, 0x1019b, 1},
		{0x101a0, 0x101d0, 48},
		{0x101d1, 0x101fc, 1},
		{0x10877, 0x10878, 1},
		{0x10ac8, 0x1173f, 3191},
		{0x16b3c, 0x16b3f, 1},
		{0x16b45, 0x1bc9c, 20823},
		{0x1d000, 0x1d0f5, 1},
		{0x1d100, 0x1d126, 1},
		{0x1d129, 0x1d164, 1},
		{0x1d16a, 0x1d16c, 1},
		{0x1d183, 0x1d184, 1},
		{0x1d18c, 0x1d1a9, 1},
		{0x1d1ae, 0x1d1e8, 1},
		{0x1d200, 0x1d241, 1},
		{0x1d245, 0x1d300, 187},
		{0x1d301, 0x1d356, 1},
		{0x1d800, 0x1d9ff, 1},
		{0x1da37, 0x1da3a, 1},
		{0x1da6d, 0x1da74, 1},
		{0x1da76, 0x1da83, 1},
		{0x1da85, 0x1da86, 1},
		{0x1f000, 0x1f02b, 1},
		{0x1f030, 0x1f093, 1},
		{0x1f0a0, 0x1f0ae, 1},
		{0x1f0b1, 0x1f0bf, 1},
		{0x1f0c1, 0x1f0cf, 1},
		{0x1f0d1, 0x1f0f5, 1},
		{0x1f110, 0x1f12e, 1},
		{0x1f130, 0x1f16b, 1},
		{0x1f170, 0x1f19a, 1},
		{0x1f1e6, 0x1f202, 1},
		{0x1f210, 0x1f23a, 1},
		{0x1f240, 0x1f248, 1},
		{0x1f250, 0x1f251, 1},
		{0x1f300, 0x1f3fa, 1},
		{0x1f400, 0x1f579, 1},
		{0x1f57b, 0x1f5a3, 1},
		{0x1f5a5, 0x1f6d0, 1},
		{0x1f6e0, 0x1f6ec, 1},
		{0x1f6f0, 0x1f6f3, 1},
		{0x1f700, 0x1f773, 1},
		{0x1f780, 0x1f7d4, 1},
		{0x1f800, 0x1f80b, 1},
		{0x1f810, 0x1f847, 1},
		{0x1f850, 0x1f859, 1},
		{0x1f860, 0x1f887, 1},
		{0x1f890, 0x1f8ad, 1},
		{0x1f910, 0x1f918, 1},
		{0x1f980, 0x1f984, 1},
		{0x1f9c0, 0x1f9c0, 1},
	},
	LatinOffset: 2,
}

var _Z = &RangeTable{
	R16: []Range16{
		{0x0020, 0x00a0, 128},
		{0x1680, 0x2000, 2432},
		{0x2001, 0x200a, 1},
		{0x2028, 0x2029, 1},
		{0x202f, 0x205f, 48},
		{0x3000, 0x3000, 1},
	},
	LatinOffset: 1,
}

var _Zl = &RangeTable{
	R16: []Range16{
		{0x2028, 0x2028, 1},
	},
}

var _Zp = &RangeTable{
	R16: []Range16{
		{0x2029, 0x2029, 1},
	},
}

var _Zs = &RangeTable{
	R16: []Range16{
		{0x0020, 0x00a0, 128},
		{0x1680, 0x2000, 2432},
		{0x2001, 0x200a, 1},
		{0x202f, 0x205f, 48},
		{0x3000, 0x3000, 1},
	},
	LatinOffset: 1,
}

// These variables have type *RangeTable.
var (
	Cc     = _Cc // Cc is the set of Unicode characters in category Cc.
	Cf     = _Cf // Cf is the set of Unicode characters in category Cf.
	Co     = _Co // Co is the set of Unicode characters in category Co.
	Cs     = _Cs // Cs is the set of Unicode characters in category Cs.
	Digit  = _Nd // Digit is the set of Unicode characters with the "decimal digit" property.
	Nd     = _Nd // Nd is the set of Unicode characters in category Nd.
	Letter = _L  // Letter/L is the set of Unicode letters, category L.
	L      = _L
	Lm     = _Lm // Lm is the set of Unicode characters in category Lm.
	Lo     = _Lo // Lo is the set of Unicode characters in category Lo.
	Lower  = _Ll // Lower is the set of Unicode lower case letters.
	Ll     = _Ll // Ll is the set of Unicode characters in category Ll.
	Mark   = _M  // Mark/M is the set of Unicode mark characters, category M.
	M      = _M
	Mc     = _Mc // Mc is the set of Unicode characters in category Mc.
	Me     = _Me // Me is the set of Unicode characters in category Me.
	Mn     = _Mn // Mn is the set of Unicode characters in category Mn.
	Nl     = _Nl // Nl is the set of Unicode characters in category Nl.
	No     = _No // No is the set of Unicode characters in category No.
	Number = _N  // Number/N is the set of Unicode number characters, category N.
	N      = _N
	Other  = _C // Other/C is the set of Unicode control and special characters, category C.
	C      = _C
	Pc     = _Pc // Pc is the set of Unicode characters in category Pc.
	Pd     = _Pd // Pd is the set of Unicode characters in category Pd.
	Pe     = _Pe // Pe is the set of Unicode characters in category Pe.
	Pf     = _Pf // Pf is the set of Unicode characters in category Pf.
	Pi     = _Pi // Pi is the set of Unicode characters in category Pi.
	Po     = _Po // Po is the set of Unicode characters in category Po.
	Ps     = _Ps // Ps is the set of Unicode characters in category Ps.
	Punct  = _P  // Punct/P is the set of Unicode punctuation characters, category P.
	P      = _P
	Sc     = _Sc // Sc is the set of Unicode characters in category Sc.
	Sk     = _Sk // Sk is the set of Unicode characters in category Sk.
	Sm     = _Sm // Sm is the set of Unicode characters in category Sm.
	So     = _So // So is the set of Unicode characters in category So.
	Space  = _Z  // Space/Z is the set of Unicode space characters, category Z.
	Z      = _Z
	Symbol = _S // Symbol/S is the set of Unicode symbol characters, category S.
	S      = _S
	Title  = _Lt // Title is the set of Unicode title case letters.
	Lt     = _Lt // Lt is the set of Unicode characters in category Lt.
	Upper  = _Lu // Upper is the set of Unicode upper case letters.
	Lu     = _Lu // Lu is the set of Unicode characters in category Lu.
	Zl     = _Zl // Zl is the set of Unicode characters in category Zl.
	Zp     = _Zp // Zp is the set of Unicode characters in category Zp.
	Zs     = _Zs // Zs is the set of Unicode characters in category Zs.
)

// Generated by running
//	maketables --scripts=all --url=http://www.unicode.org/Public/8.0.0/ucd/
// DO NOT EDIT

// Scripts is the set of Unicode script tables.
var Scripts = map[string]*RangeTable{
	"Ahom":                   Ahom,
	"Anatolian_Hieroglyphs":  Anatolian_Hieroglyphs,
	"Arabic":                 Arabic,
	"Armenian":               Armenian,
	"Avestan":                Avestan,
	"Balinese":               Balinese,
	"Bamum":                  Bamum,
	"Bassa_Vah":              Bassa_Vah,
	"Batak":                  Batak,
	"Bengali":                Bengali,
	"Bopomofo":               Bopomofo,
	"Brahmi":                 Brahmi,
	"Braille":                Braille,
	"Buginese":               Buginese,
	"Buhid":                  Buhid,
	"Canadian_Aboriginal":    Canadian_Aboriginal,
	"Carian":                 Carian,
	"Caucasian_Albanian":     Caucasian_Albanian,
	"Chakma":                 Chakma,
	"Cham":                   Cham,
	"Cherokee":               Cherokee,
	"Common":                 Common,
	"Coptic":                 Coptic,
	"Cuneiform":              Cuneiform,
	"Cypriot":                Cypriot,
	"Cyrillic":               Cyrillic,
	"Deseret":                Deseret,
	"Devanagari":             Devanagari,
	"Duployan":               Duployan,
	"Egyptian_Hieroglyphs":   Egyptian_Hieroglyphs,
	"Elbasan":                Elbasan,
	"Ethiopic":               Ethiopic,
	"Georgian":               Georgian,
	"Glagolitic":             Glagolitic,
	"Gothic":                 Gothic,
	"Grantha":                Grantha,
	"Greek":                  Greek,
	"Gujarati":               Gujarati,
	"Gurmukhi":               Gurmukhi,
	"Han":                    Han,
	"Hangul":                 Hangul,
	"Hanunoo":                Hanunoo,
	"Hatran":                 Hatran,
	"Hebrew":                 Hebrew,
	"Hiragana":               Hiragana,
	"Imperial_Aramaic":       Imperial_Aramaic,
	"Inherited":              Inherited,
	"Inscriptional_Pahlavi":  Inscriptional_Pahlavi,
	"Inscriptional_Parthian": Inscriptional_Parthian,
	"Javanese":               Javanese,
	"Kaithi":                 Kaithi,
	"Kannada":                Kannada,
	"Katakana":               Katakana,
	"Kayah_Li":               Kayah_Li,
	"Kharoshthi":             Kharoshthi,
	"Khmer":                  Khmer,
	"Khojki":                 Khojki,
	"Khudawadi":              Khudawadi,
	"Lao":                    Lao,
	"Latin":                  Latin,
	"Lepcha":                 Lepcha,
	"Limbu":                  Limbu,
	"Linear_A":               Linear_A,
	"Linear_B":               Linear_B,
	"Lisu":                   Lisu,
	"Lycian":                 Lycian,
	"Lydian":                 Lydian,
	"Mahajani":               Mahajani,
	"Malayalam":              Malayalam,
	"Mandaic":                Mandaic,
	"Manichaean":             Manichaean,
	"Meetei_Mayek":           Meetei_Mayek,
	"Mende_Kikakui":          Mende_Kikakui,
	"Meroitic_Cursive":       Meroitic_Cursive,
	"Meroitic_Hieroglyphs":   Meroitic_Hieroglyphs,
	"Miao":                   Miao,
	"Modi":                   Modi,
	"Mongolian":              Mongolian,
	"Mro":                    Mro,
	"Multani":                Multani,
	"Myanmar":                Myanmar,
	"Nabataean":              Nabataean,
	"New_Tai_Lue":            New_Tai_Lue,
	"Nko":                    Nko,
	"Ogham":                  Ogham,
	"Ol_Chiki":               Ol_Chiki,
	"Old_Hungarian":          Old_Hungarian,
	"Old_Italic":             Old_Italic,
	"Old_North_Arabian":      Old_North_Arabian,
	"Old_Permic":             Old_Permic,
	"Old_Persian":            Old_Persian,
	"Old_South_Arabian":      Old_South_Arabian,
	"Old_Turkic":             Old_Turkic,
	"Oriya":                  Oriya,
	"Osmanya":                Osmanya,
	"Pahawh_Hmong":           Pahawh_Hmong,
	"Palmyrene":              Palmyrene,
	"Pau_Cin_Hau":            Pau_Cin_Hau,
	"Phags_Pa":               Phags_Pa,
	"Phoenician":             Phoenician,
	"Psalter_Pahlavi":        Psalter_Pahlavi,
	"Rejang":                 Rejang,
	"Runic":                  Runic,
	"Samaritan":              Samaritan,
	"Saurashtra":             Saurashtra,
	"Sharada":                Sharada,
	"Shavian":                Shavian,
	"Siddham":                Siddham,
	"SignWriting":            SignWriting,
	"Sinhala":                Sinhala,
	"Sora_Sompeng":           Sora_Sompeng,
	"Sundanese":              Sundanese,
	"Syloti_Nagri":           Syloti_Nagri,
	"Syriac":                 Syriac,
	"Tagalog":                Tagalog,
	"Tagbanwa":               Tagbanwa,
	"Tai_Le":                 Tai_Le,
	"Tai_Tham":               Tai_Tham,
	"Tai_Viet":               Tai_Viet,
	"Takri":                  Takri,
	"Tamil":                  Tamil,
	"Telugu":                 Telugu,
	"Thaana":                 Thaana,
	"Thai":                   Thai,
	"Tibetan":                Tibetan,
	"Tifinagh":               Tifinagh,
	"Tirhuta":                Tirhuta,
	"Ugaritic":               Ugaritic,
	"Vai":                    Vai,
	"Warang_Citi":            Warang_Citi,
	"Yi":                     Yi,
}

var _Ahom = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11700, 0x11719, 1},
		{0x1171d, 0x1172b, 1},
		{0x11730, 0x1173f, 1},
	},
}

var _Anatolian_Hieroglyphs = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x14400, 0x14646, 1},
	},
}

var _Arabic = &RangeTable{
	R16: []Range16{
		{0x0600, 0x0604, 1},
		{0x0606, 0x060b, 1},
		{0x060d, 0x061a, 1},
		{0x061e, 0x061e, 1},
		{0x0620, 0x063f, 1},
		{0x0641, 0x064a, 1},
		{0x0656, 0x066f, 1},
		{0x0671, 0x06dc, 1},
		{0x06de, 0x06ff, 1},
		{0x0750, 0x077f, 1},
		{0x08a0, 0x08b4, 1},
		{0x08e3, 0x08ff, 1},
		{0xfb50, 0xfbc1, 1},
		{0xfbd3, 0xfd3d, 1},
		{0xfd50, 0xfd8f, 1},
		{0xfd92, 0xfdc7, 1},
		{0xfdf0, 0xfdfd, 1},
		{0xfe70, 0xfe74, 1},
		{0xfe76, 0xfefc, 1},
	},
	R32: []Range32{
		{0x10e60, 0x10e7e, 1},
		{0x1ee00, 0x1ee03, 1},
		{0x1ee05, 0x1ee1f, 1},
		{0x1ee21, 0x1ee22, 1},
		{0x1ee24, 0x1ee24, 1},
		{0x1ee27, 0x1ee27, 1},
		{0x1ee29, 0x1ee32, 1},
		{0x1ee34, 0x1ee37, 1},
		{0x1ee39, 0x1ee39, 1},
		{0x1ee3b, 0x1ee3b, 1},
		{0x1ee42, 0x1ee42, 1},
		{0x1ee47, 0x1ee47, 1},
		{0x1ee49, 0x1ee49, 1},
		{0x1ee4b, 0x1ee4b, 1},
		{0x1ee4d, 0x1ee4f, 1},
		{0x1ee51, 0x1ee52, 1},
		{0x1ee54, 0x1ee54, 1},
		{0x1ee57, 0x1ee57, 1},
		{0x1ee59, 0x1ee59, 1},
		{0x1ee5b, 0x1ee5b, 1},
		{0x1ee5d, 0x1ee5d, 1},
		{0x1ee5f, 0x1ee5f, 1},
		{0x1ee61, 0x1ee62, 1},
		{0x1ee64, 0x1ee64, 1},
		{0x1ee67, 0x1ee6a, 1},
		{0x1ee6c, 0x1ee72, 1},
		{0x1ee74, 0x1ee77, 1},
		{0x1ee79, 0x1ee7c, 1},
		{0x1ee7e, 0x1ee7e, 1},
		{0x1ee80, 0x1ee89, 1},
		{0x1ee8b, 0x1ee9b, 1},
		{0x1eea1, 0x1eea3, 1},
		{0x1eea5, 0x1eea9, 1},
		{0x1eeab, 0x1eebb, 1},
		{0x1eef0, 0x1eef1, 1},
	},
}

var _Armenian = &RangeTable{
	R16: []Range16{
		{0x0531, 0x0556, 1},
		{0x0559, 0x055f, 1},
		{0x0561, 0x0587, 1},
		{0x058a, 0x058a, 1},
		{0x058d, 0x058f, 1},
		{0xfb13, 0xfb17, 1},
	},
}

var _Avestan = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10b00, 0x10b35, 1},
		{0x10b39, 0x10b3f, 1},
	},
}

var _Balinese = &RangeTable{
	R16: []Range16{
		{0x1b00, 0x1b4b, 1},
		{0x1b50, 0x1b7c, 1},
	},
}

var _Bamum = &RangeTable{
	R16: []Range16{
		{0xa6a0, 0xa6f7, 1},
	},
	R32: []Range32{
		{0x16800, 0x16a38, 1},
	},
}

var _Bassa_Vah = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x16ad0, 0x16aed, 1},
		{0x16af0, 0x16af5, 1},
	},
}

var _Batak = &RangeTable{
	R16: []Range16{
		{0x1bc0, 0x1bf3, 1},
		{0x1bfc, 0x1bff, 1},
	},
}

var _Bengali = &RangeTable{
	R16: []Range16{
		{0x0980, 0x0983, 1},
		{0x0985, 0x098c, 1},
		{0x098f, 0x0990, 1},
		{0x0993, 0x09a8, 1},
		{0x09aa, 0x09b0, 1},
		{0x09b2, 0x09b2, 1},
		{0x09b6, 0x09b9, 1},
		{0x09bc, 0x09c4, 1},
		{0x09c7, 0x09c8, 1},
		{0x09cb, 0x09ce, 1},
		{0x09d7, 0x09d7, 1},
		{0x09dc, 0x09dd, 1},
		{0x09df, 0x09e3, 1},
		{0x09e6, 0x09fb, 1},
	},
}

var _Bopomofo = &RangeTable{
	R16: []Range16{
		{0x02ea, 0x02eb, 1},
		{0x3105, 0x312d, 1},
		{0x31a0, 0x31ba, 1},
	},
}

var _Brahmi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11000, 0x1104d, 1},
		{0x11052, 0x1106f, 1},
		{0x1107f, 0x1107f, 1},
	},
}

var _Braille = &RangeTable{
	R16: []Range16{
		{0x2800, 0x28ff, 1},
	},
}

var _Buginese = &RangeTable{
	R16: []Range16{
		{0x1a00, 0x1a1b, 1},
		{0x1a1e, 0x1a1f, 1},
	},
}

var _Buhid = &RangeTable{
	R16: []Range16{
		{0x1740, 0x1753, 1},
	},
}

var _Canadian_Aboriginal = &RangeTable{
	R16: []Range16{
		{0x1400, 0x167f, 1},
		{0x18b0, 0x18f5, 1},
	},
}

var _Carian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x102a0, 0x102d0, 1},
	},
}

var _Caucasian_Albanian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10530, 0x10563, 1},
		{0x1056f, 0x1056f, 1},
	},
}

var _Chakma = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11100, 0x11134, 1},
		{0x11136, 0x11143, 1},
	},
}

var _Cham = &RangeTable{
	R16: []Range16{
		{0xaa00, 0xaa36, 1},
		{0xaa40, 0xaa4d, 1},
		{0xaa50, 0xaa59, 1},
		{0xaa5c, 0xaa5f, 1},
	},
}

var _Cherokee = &RangeTable{
	R16: []Range16{
		{0x13a0, 0x13f5, 1},
		{0x13f8, 0x13fd, 1},
		{0xab70, 0xabbf, 1},
	},
}

var _Common = &RangeTable{
	R16: []Range16{
		{0x0000, 0x0040, 1},
		{0x005b, 0x0060, 1},
		{0x007b, 0x00a9, 1},
		{0x00ab, 0x00b9, 1},
		{0x00bb, 0x00bf, 1},
		{0x00d7, 0x00d7, 1},
		{0x00f7, 0x00f7, 1},
		{0x02b9, 0x02df, 1},
		{0x02e5, 0x02e9, 1},
		{0x02ec, 0x02ff, 1},
		{0x0374, 0x0374, 1},
		{0x037e, 0x037e, 1},
		{0x0385, 0x0385, 1},
		{0x0387, 0x0387, 1},
		{0x0589, 0x0589, 1},
		{0x0605, 0x0605, 1},
		{0x060c, 0x060c, 1},
		{0x061b, 0x061c, 1},
		{0x061f, 0x061f, 1},
		{0x0640, 0x0640, 1},
		{0x06dd, 0x06dd, 1},
		{0x0964, 0x0965, 1},
		{0x0e3f, 0x0e3f, 1},
		{0x0fd5, 0x0fd8, 1},
		{0x10fb, 0x10fb, 1},
		{0x16eb, 0x16ed, 1},
		{0x1735, 0x1736, 1},
		{0x1802, 0x1803, 1},
		{0x1805, 0x1805, 1},
		{0x1cd3, 0x1cd3, 1},
		{0x1ce1, 0x1ce1, 1},
		{0x1ce9, 0x1cec, 1},
		{0x1cee, 0x1cf3, 1},
		{0x1cf5, 0x1cf6, 1},
		{0x2000, 0x200b, 1},
		{0x200e, 0x2064, 1},
		{0x2066, 0x2070, 1},
		{0x2074, 0x207e, 1},
		{0x2080, 0x208e, 1},
		{0x20a0, 0x20be, 1},
		{0x2100, 0x2125, 1},
		{0x2127, 0x2129, 1},
		{0x212c, 0x2131, 1},
		{0x2133, 0x214d, 1},
		{0x214f, 0x215f, 1},
		{0x2189, 0x218b, 1},
		{0x2190, 0x23fa, 1},
		{0x2400, 0x2426, 1},
		{0x2440, 0x244a, 1},
		{0x2460, 0x27ff, 1},
		{0x2900, 0x2b73, 1},
		{0x2b76, 0x2b95, 1},
		{0x2b98, 0x2bb9, 1},
		{0x2bbd, 0x2bc8, 1},
		{0x2bca, 0x2bd1, 1},
		{0x2bec, 0x2bef, 1},
		{0x2e00, 0x2e42, 1},
		{0x2ff0, 0x2ffb, 1},
		{0x3000, 0x3004, 1},
		{0x3006, 0x3006, 1},
		{0x3008, 0x3020, 1},
		{0x3030, 0x3037, 1},
		{0x303c, 0x303f, 1},
		{0x309b, 0x309c, 1},
		{0x30a0, 0x30a0, 1},
		{0x30fb, 0x30fc, 1},
		{0x3190, 0x319f, 1},
		{0x31c0, 0x31e3, 1},
		{0x3220, 0x325f, 1},
		{0x327f, 0x32cf, 1},
		{0x3358, 0x33ff, 1},
		{0x4dc0, 0x4dff, 1},
		{0xa700, 0xa721, 1},
		{0xa788, 0xa78a, 1},
		{0xa830, 0xa839, 1},
		{0xa92e, 0xa92e, 1},
		{0xa9cf, 0xa9cf, 1},
		{0xab5b, 0xab5b, 1},
		{0xfd3e, 0xfd3f, 1},
		{0xfe10, 0xfe19, 1},
		{0xfe30, 0xfe52, 1},
		{0xfe54, 0xfe66, 1},
		{0xfe68, 0xfe6b, 1},
		{0xfeff, 0xfeff, 1},
		{0xff01, 0xff20, 1},
		{0xff3b, 0xff40, 1},
		{0xff5b, 0xff65, 1},
		{0xff70, 0xff70, 1},
		{0xff9e, 0xff9f, 1},
		{0xffe0, 0xffe6, 1},
		{0xffe8, 0xffee, 1},
		{0xfff9, 0xfffd, 1},
	},
	R32: []Range32{
		{0x10100, 0x10102, 1},
		{0x10107, 0x10133, 1},
		{0x10137, 0x1013f, 1},
		{0x10190, 0x1019b, 1},
		{0x101d0, 0x101fc, 1},
		{0x102e1, 0x102fb, 1},
		{0x1bca0, 0x1bca3, 1},
		{0x1d000, 0x1d0f5, 1},
		{0x1d100, 0x1d126, 1},
		{0x1d129, 0x1d166, 1},
		{0x1d16a, 0x1d17a, 1},
		{0x1d183, 0x1d184, 1},
		{0x1d18c, 0x1d1a9, 1},
		{0x1d1ae, 0x1d1e8, 1},
		{0x1d300, 0x1d356, 1},
		{0x1d360, 0x1d371, 1},
		{0x1d400, 0x1d454, 1},
		{0x1d456, 0x1d49c, 1},
		{0x1d49e, 0x1d49f, 1},
		{0x1d4a2, 0x1d4a2, 1},
		{0x1d4a5, 0x1d4a6, 1},
		{0x1d4a9, 0x1d4ac, 1},
		{0x1d4ae, 0x1d4b9, 1},
		{0x1d4bb, 0x1d4bb, 1},
		{0x1d4bd, 0x1d4c3, 1},
		{0x1d4c5, 0x1d505, 1},
		{0x1d507, 0x1d50a, 1},
		{0x1d50d, 0x1d514, 1},
		{0x1d516, 0x1d51c, 1},
		{0x1d51e, 0x1d539, 1},
		{0x1d53b, 0x1d53e, 1},
		{0x1d540, 0x1d544, 1},
		{0x1d546, 0x1d546, 1},
		{0x1d54a, 0x1d550, 1},
		{0x1d552, 0x1d6a5, 1},
		{0x1d6a8, 0x1d7cb, 1},
		{0x1d7ce, 0x1d7ff, 1},
		{0x1f000, 0x1f02b, 1},
		{0x1f030, 0x1f093, 1},
		{0x1f0a0, 0x1f0ae, 1},
		{0x1f0b1, 0x1f0bf, 1},
		{0x1f0c1, 0x1f0cf, 1},
		{0x1f0d1, 0x1f0f5, 1},
		{0x1f100, 0x1f10c, 1},
		{0x1f110, 0x1f12e, 1},
		{0x1f130, 0x1f16b, 1},
		{0x1f170, 0x1f19a, 1},
		{0x1f1e6, 0x1f1ff, 1},
		{0x1f201, 0x1f202, 1},
		{0x1f210, 0x1f23a, 1},
		{0x1f240, 0x1f248, 1},
		{0x1f250, 0x1f251, 1},
		{0x1f300, 0x1f579, 1},
		{0x1f57b, 0x1f5a3, 1},
		{0x1f5a5, 0x1f6d0, 1},
		{0x1f6e0, 0x1f6ec, 1},
		{0x1f6f0, 0x1f6f3, 1},
		{0x1f700, 0x1f773, 1},
		{0x1f780, 0x1f7d4, 1},
		{0x1f800, 0x1f80b, 1},
		{0x1f810, 0x1f847, 1},
		{0x1f850, 0x1f859, 1},
		{0x1f860, 0x1f887, 1},
		{0x1f890, 0x1f8ad, 1},
		{0x1f910, 0x1f918, 1},
		{0x1f980, 0x1f984, 1},
		{0x1f9c0, 0x1f9c0, 1},
		{0xe0001, 0xe0001, 1},
		{0xe0020, 0xe007f, 1},
	},
	LatinOffset: 7,
}

var _Coptic = &RangeTable{
	R16: []Range16{
		{0x03e2, 0x03ef, 1},
		{0x2c80, 0x2cf3, 1},
		{0x2cf9, 0x2cff, 1},
	},
}

var _Cuneiform = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x12000, 0x12399, 1},
		{0x12400, 0x1246e, 1},
		{0x12470, 0x12474, 1},
		{0x12480, 0x12543, 1},
	},
}

var _Cypriot = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10800, 0x10805, 1},
		{0x10808, 0x10808, 1},
		{0x1080a, 0x10835, 1},
		{0x10837, 0x10838, 1},
		{0x1083c, 0x1083c, 1},
		{0x1083f, 0x1083f, 1},
	},
}

var _Cyrillic = &RangeTable{
	R16: []Range16{
		{0x0400, 0x0484, 1},
		{0x0487, 0x052f, 1},
		{0x1d2b, 0x1d2b, 1},
		{0x1d78, 0x1d78, 1},
		{0x2de0, 0x2dff, 1},
		{0xa640, 0xa69f, 1},
		{0xfe2e, 0xfe2f, 1},
	},
}

var _Deseret = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10400, 0x1044f, 1},
	},
}

var _Devanagari = &RangeTable{
	R16: []Range16{
		{0x0900, 0x0950, 1},
		{0x0953, 0x0963, 1},
		{0x0966, 0x097f, 1},
		{0xa8e0, 0xa8fd, 1},
	},
}

var _Duployan = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x1bc00, 0x1bc6a, 1},
		{0x1bc70, 0x1bc7c, 1},
		{0x1bc80, 0x1bc88, 1},
		{0x1bc90, 0x1bc99, 1},
		{0x1bc9c, 0x1bc9f, 1},
	},
}

var _Egyptian_Hieroglyphs = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x13000, 0x1342e, 1},
	},
}

var _Elbasan = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10500, 0x10527, 1},
	},
}

var _Ethiopic = &RangeTable{
	R16: []Range16{
		{0x1200, 0x1248, 1},
		{0x124a, 0x124d, 1},
		{0x1250, 0x1256, 1},
		{0x1258, 0x1258, 1},
		{0x125a, 0x125d, 1},
		{0x1260, 0x1288, 1},
		{0x128a, 0x128d, 1},
		{0x1290, 0x12b0, 1},
		{0x12b2, 0x12b5, 1},
		{0x12b8, 0x12be, 1},
		{0x12c0, 0x12c0, 1},
		{0x12c2, 0x12c5, 1},
		{0x12c8, 0x12d6, 1},
		{0x12d8, 0x1310, 1},
		{0x1312, 0x1315, 1},
		{0x1318, 0x135a, 1},
		{0x135d, 0x137c, 1},
		{0x1380, 0x1399, 1},
		{0x2d80, 0x2d96, 1},
		{0x2da0, 0x2da6, 1},
		{0x2da8, 0x2dae, 1},
		{0x2db0, 0x2db6, 1},
		{0x2db8, 0x2dbe, 1},
		{0x2dc0, 0x2dc6, 1},
		{0x2dc8, 0x2dce, 1},
		{0x2dd0, 0x2dd6, 1},
		{0x2dd8, 0x2dde, 1},
		{0xab01, 0xab06, 1},
		{0xab09, 0xab0e, 1},
		{0xab11, 0xab16, 1},
		{0xab20, 0xab26, 1},
		{0xab28, 0xab2e, 1},
	},
}

var _Georgian = &RangeTable{
	R16: []Range16{
		{0x10a0, 0x10c5, 1},
		{0x10c7, 0x10c7, 1},
		{0x10cd, 0x10cd, 1},
		{0x10d0, 0x10fa, 1},
		{0x10fc, 0x10ff, 1},
		{0x2d00, 0x2d25, 1},
		{0x2d27, 0x2d27, 1},
		{0x2d2d, 0x2d2d, 1},
	},
}

var _Glagolitic = &RangeTable{
	R16: []Range16{
		{0x2c00, 0x2c2e, 1},
		{0x2c30, 0x2c5e, 1},
	},
}

var _Gothic = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10330, 0x1034a, 1},
	},
}

var _Grantha = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11300, 0x11303, 1},
		{0x11305, 0x1130c, 1},
		{0x1130f, 0x11310, 1},
		{0x11313, 0x11328, 1},
		{0x1132a, 0x11330, 1},
		{0x11332, 0x11333, 1},
		{0x11335, 0x11339, 1},
		{0x1133c, 0x11344, 1},
		{0x11347, 0x11348, 1},
		{0x1134b, 0x1134d, 1},
		{0x11350, 0x11350, 1},
		{0x11357, 0x11357, 1},
		{0x1135d, 0x11363, 1},
		{0x11366, 0x1136c, 1},
		{0x11370, 0x11374, 1},
	},
}

var _Greek = &RangeTable{
	R16: []Range16{
		{0x0370, 0x0373, 1},
		{0x0375, 0x0377, 1},
		{0x037a, 0x037d, 1},
		{0x037f, 0x037f, 1},
		{0x0384, 0x0384, 1},
		{0x0386, 0x0386, 1},
		{0x0388, 0x038a, 1},
		{0x038c, 0x038c, 1},
		{0x038e, 0x03a1, 1},
		{0x03a3, 0x03e1, 1},
		{0x03f0, 0x03ff, 1},
		{0x1d26, 0x1d2a, 1},
		{0x1d5d, 0x1d61, 1},
		{0x1d66, 0x1d6a, 1},
		{0x1dbf, 0x1dbf, 1},
		{0x1f00, 0x1f15, 1},
		{0x1f18, 0x1f1d, 1},
		{0x1f20, 0x1f45, 1},
		{0x1f48, 0x1f4d, 1},
		{0x1f50, 0x1f57, 1},
		{0x1f59, 0x1f59, 1},
		{0x1f5b, 0x1f5b, 1},
		{0x1f5d, 0x1f5d, 1},
		{0x1f5f, 0x1f7d, 1},
		{0x1f80, 0x1fb4, 1},
		{0x1fb6, 0x1fc4, 1},
		{0x1fc6, 0x1fd3, 1},
		{0x1fd6, 0x1fdb, 1},
		{0x1fdd, 0x1fef, 1},
		{0x1ff2, 0x1ff4, 1},
		{0x1ff6, 0x1ffe, 1},
		{0x2126, 0x2126, 1},
		{0xab65, 0xab65, 1},
	},
	R32: []Range32{
		{0x10140, 0x1018c, 1},
		{0x101a0, 0x101a0, 1},
		{0x1d200, 0x1d245, 1},
	},
}

var _Gujarati = &RangeTable{
	R16: []Range16{
		{0x0a81, 0x0a83, 1},
		{0x0a85, 0x0a8d, 1},
		{0x0a8f, 0x0a91, 1},
		{0x0a93, 0x0aa8, 1},
		{0x0aaa, 0x0ab0, 1},
		{0x0ab2, 0x0ab3, 1},
		{0x0ab5, 0x0ab9, 1},
		{0x0abc, 0x0ac5, 1},
		{0x0ac7, 0x0ac9, 1},
		{0x0acb, 0x0acd, 1},
		{0x0ad0, 0x0ad0, 1},
		{0x0ae0, 0x0ae3, 1},
		{0x0ae6, 0x0af1, 1},
		{0x0af9, 0x0af9, 1},
	},
}

var _Gurmukhi = &RangeTable{
	R16: []Range16{
		{0x0a01, 0x0a03, 1},
		{0x0a05, 0x0a0a, 1},
		{0x0a0f, 0x0a10, 1},
		{0x0a13, 0x0a28, 1},
		{0x0a2a, 0x0a30, 1},
		{0x0a32, 0x0a33, 1},
		{0x0a35, 0x0a36, 1},
		{0x0a38, 0x0a39, 1},
		{0x0a3c, 0x0a3c, 1},
		{0x0a3e, 0x0a42, 1},
		{0x0a47, 0x0a48, 1},
		{0x0a4b, 0x0a4d, 1},
		{0x0a51, 0x0a51, 1},
		{0x0a59, 0x0a5c, 1},
		{0x0a5e, 0x0a5e, 1},
		{0x0a66, 0x0a75, 1},
	},
}

var _Han = &RangeTable{
	R16: []Range16{
		{0x2e80, 0x2e99, 1},
		{0x2e9b, 0x2ef3, 1},
		{0x2f00, 0x2fd5, 1},
		{0x3005, 0x3005, 1},
		{0x3007, 0x3007, 1},
		{0x3021, 0x3029, 1},
		{0x3038, 0x303b, 1},
		{0x3400, 0x4db5, 1},
		{0x4e00, 0x9fd5, 1},
		{0xf900, 0xfa6d, 1},
		{0xfa70, 0xfad9, 1},
	},
	R32: []Range32{
		{0x20000, 0x2a6d6, 1},
		{0x2a700, 0x2b734, 1},
		{0x2b740, 0x2b81d, 1},
		{0x2b820, 0x2cea1, 1},
		{0x2f800, 0x2fa1d, 1},
	},
}

var _Hangul = &RangeTable{
	R16: []Range16{
		{0x1100, 0x11ff, 1},
		{0x302e, 0x302f, 1},
		{0x3131, 0x318e, 1},
		{0x3200, 0x321e, 1},
		{0x3260, 0x327e, 1},
		{0xa960, 0xa97c, 1},
		{0xac00, 0xd7a3, 1},
		{0xd7b0, 0xd7c6, 1},
		{0xd7cb, 0xd7fb, 1},
		{0xffa0, 0xffbe, 1},
		{0xffc2, 0xffc7, 1},
		{0xffca, 0xffcf, 1},
		{0xffd2, 0xffd7, 1},
		{0xffda, 0xffdc, 1},
	},
}

var _Hanunoo = &RangeTable{
	R16: []Range16{
		{0x1720, 0x1734, 1},
	},
}

var _Hatran = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x108e0, 0x108f2, 1},
		{0x108f4, 0x108f5, 1},
		{0x108fb, 0x108ff, 1},
	},
}

var _Hebrew = &RangeTable{
	R16: []Range16{
		{0x0591, 0x05c7, 1},
		{0x05d0, 0x05ea, 1},
		{0x05f0, 0x05f4, 1},
		{0xfb1d, 0xfb36, 1},
		{0xfb38, 0xfb3c, 1},
		{0xfb3e, 0xfb3e, 1},
		{0xfb40, 0xfb41, 1},
		{0xfb43, 0xfb44, 1},
		{0xfb46, 0xfb4f, 1},
	},
}

var _Hiragana = &RangeTable{
	R16: []Range16{
		{0x3041, 0x3096, 1},
		{0x309d, 0x309f, 1},
	},
	R32: []Range32{
		{0x1b001, 0x1b001, 1},
		{0x1f200, 0x1f200, 1},
	},
}

var _Imperial_Aramaic = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10840, 0x10855, 1},
		{0x10857, 0x1085f, 1},
	},
}

var _Inherited = &RangeTable{
	R16: []Range16{
		{0x0300, 0x036f, 1},
		{0x0485, 0x0486, 1},
		{0x064b, 0x0655, 1},
		{0x0670, 0x0670, 1},
		{0x0951, 0x0952, 1},
		{0x1ab0, 0x1abe, 1},
		{0x1cd0, 0x1cd2, 1},
		{0x1cd4, 0x1ce0, 1},
		{0x1ce2, 0x1ce8, 1},
		{0x1ced, 0x1ced, 1},
		{0x1cf4, 0x1cf4, 1},
		{0x1cf8, 0x1cf9, 1},
		{0x1dc0, 0x1df5, 1},
		{0x1dfc, 0x1dff, 1},
		{0x200c, 0x200d, 1},
		{0x20d0, 0x20f0, 1},
		{0x302a, 0x302d, 1},
		{0x3099, 0x309a, 1},
		{0xfe00, 0xfe0f, 1},
		{0xfe20, 0xfe2d, 1},
	},
	R32: []Range32{
		{0x101fd, 0x101fd, 1},
		{0x102e0, 0x102e0, 1},
		{0x1d167, 0x1d169, 1},
		{0x1d17b, 0x1d182, 1},
		{0x1d185, 0x1d18b, 1},
		{0x1d1aa, 0x1d1ad, 1},
		{0xe0100, 0xe01ef, 1},
	},
}

var _Inscriptional_Pahlavi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10b60, 0x10b72, 1},
		{0x10b78, 0x10b7f, 1},
	},
}

var _Inscriptional_Parthian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10b40, 0x10b55, 1},
		{0x10b58, 0x10b5f, 1},
	},
}

var _Javanese = &RangeTable{
	R16: []Range16{
		{0xa980, 0xa9cd, 1},
		{0xa9d0, 0xa9d9, 1},
		{0xa9de, 0xa9df, 1},
	},
}

var _Kaithi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11080, 0x110c1, 1},
	},
}

var _Kannada = &RangeTable{
	R16: []Range16{
		{0x0c81, 0x0c83, 1},
		{0x0c85, 0x0c8c, 1},
		{0x0c8e, 0x0c90, 1},
		{0x0c92, 0x0ca8, 1},
		{0x0caa, 0x0cb3, 1},
		{0x0cb5, 0x0cb9, 1},
		{0x0cbc, 0x0cc4, 1},
		{0x0cc6, 0x0cc8, 1},
		{0x0cca, 0x0ccd, 1},
		{0x0cd5, 0x0cd6, 1},
		{0x0cde, 0x0cde, 1},
		{0x0ce0, 0x0ce3, 1},
		{0x0ce6, 0x0cef, 1},
		{0x0cf1, 0x0cf2, 1},
	},
}

var _Katakana = &RangeTable{
	R16: []Range16{
		{0x30a1, 0x30fa, 1},
		{0x30fd, 0x30ff, 1},
		{0x31f0, 0x31ff, 1},
		{0x32d0, 0x32fe, 1},
		{0x3300, 0x3357, 1},
		{0xff66, 0xff6f, 1},
		{0xff71, 0xff9d, 1},
	},
	R32: []Range32{
		{0x1b000, 0x1b000, 1},
	},
}

var _Kayah_Li = &RangeTable{
	R16: []Range16{
		{0xa900, 0xa92d, 1},
		{0xa92f, 0xa92f, 1},
	},
}

var _Kharoshthi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10a00, 0x10a03, 1},
		{0x10a05, 0x10a06, 1},
		{0x10a0c, 0x10a13, 1},
		{0x10a15, 0x10a17, 1},
		{0x10a19, 0x10a33, 1},
		{0x10a38, 0x10a3a, 1},
		{0x10a3f, 0x10a47, 1},
		{0x10a50, 0x10a58, 1},
	},
}

var _Khmer = &RangeTable{
	R16: []Range16{
		{0x1780, 0x17dd, 1},
		{0x17e0, 0x17e9, 1},
		{0x17f0, 0x17f9, 1},
		{0x19e0, 0x19ff, 1},
	},
}

var _Khojki = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11200, 0x11211, 1},
		{0x11213, 0x1123d, 1},
	},
}

var _Khudawadi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x112b0, 0x112ea, 1},
		{0x112f0, 0x112f9, 1},
	},
}

var _Lao = &RangeTable{
	R16: []Range16{
		{0x0e81, 0x0e82, 1},
		{0x0e84, 0x0e84, 1},
		{0x0e87, 0x0e88, 1},
		{0x0e8a, 0x0e8a, 1},
		{0x0e8d, 0x0e8d, 1},
		{0x0e94, 0x0e97, 1},
		{0x0e99, 0x0e9f, 1},
		{0x0ea1, 0x0ea3, 1},
		{0x0ea5, 0x0ea5, 1},
		{0x0ea7, 0x0ea7, 1},
		{0x0eaa, 0x0eab, 1},
		{0x0ead, 0x0eb9, 1},
		{0x0ebb, 0x0ebd, 1},
		{0x0ec0, 0x0ec4, 1},
		{0x0ec6, 0x0ec6, 1},
		{0x0ec8, 0x0ecd, 1},
		{0x0ed0, 0x0ed9, 1},
		{0x0edc, 0x0edf, 1},
	},
}

var _Latin = &RangeTable{
	R16: []Range16{
		{0x0041, 0x005a, 1},
		{0x0061, 0x007a, 1},
		{0x00aa, 0x00aa, 1},
		{0x00ba, 0x00ba, 1},
		{0x00c0, 0x00d6, 1},
		{0x00d8, 0x00f6, 1},
		{0x00f8, 0x02b8, 1},
		{0x02e0, 0x02e4, 1},
		{0x1d00, 0x1d25, 1},
		{0x1d2c, 0x1d5c, 1},
		{0x1d62, 0x1d65, 1},
		{0x1d6b, 0x1d77, 1},
		{0x1d79, 0x1dbe, 1},
		{0x1e00, 0x1eff, 1},
		{0x2071, 0x2071, 1},
		{0x207f, 0x207f, 1},
		{0x2090, 0x209c, 1},
		{0x212a, 0x212b, 1},
		{0x2132, 0x2132, 1},
		{0x214e, 0x214e, 1},
		{0x2160, 0x2188, 1},
		{0x2c60, 0x2c7f, 1},
		{0xa722, 0xa787, 1},
		{0xa78b, 0xa7ad, 1},
		{0xa7b0, 0xa7b7, 1},
		{0xa7f7, 0xa7ff, 1},
		{0xab30, 0xab5a, 1},
		{0xab5c, 0xab64, 1},
		{0xfb00, 0xfb06, 1},
		{0xff21, 0xff3a, 1},
		{0xff41, 0xff5a, 1},
	},
	LatinOffset: 6,
}

var _Lepcha = &RangeTable{
	R16: []Range16{
		{0x1c00, 0x1c37, 1},
		{0x1c3b, 0x1c49, 1},
		{0x1c4d, 0x1c4f, 1},
	},
}

var _Limbu = &RangeTable{
	R16: []Range16{
		{0x1900, 0x191e, 1},
		{0x1920, 0x192b, 1},
		{0x1930, 0x193b, 1},
		{0x1940, 0x1940, 1},
		{0x1944, 0x194f, 1},
	},
}

var _Linear_A = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10600, 0x10736, 1},
		{0x10740, 0x10755, 1},
		{0x10760, 0x10767, 1},
	},
}

var _Linear_B = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10000, 0x1000b, 1},
		{0x1000d, 0x10026, 1},
		{0x10028, 0x1003a, 1},
		{0x1003c, 0x1003d, 1},
		{0x1003f, 0x1004d, 1},
		{0x10050, 0x1005d, 1},
		{0x10080, 0x100fa, 1},
	},
}

var _Lisu = &RangeTable{
	R16: []Range16{
		{0xa4d0, 0xa4ff, 1},
	},
}

var _Lycian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10280, 0x1029c, 1},
	},
}

var _Lydian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10920, 0x10939, 1},
		{0x1093f, 0x1093f, 1},
	},
}

var _Mahajani = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11150, 0x11176, 1},
	},
}

var _Malayalam = &RangeTable{
	R16: []Range16{
		{0x0d01, 0x0d03, 1},
		{0x0d05, 0x0d0c, 1},
		{0x0d0e, 0x0d10, 1},
		{0x0d12, 0x0d3a, 1},
		{0x0d3d, 0x0d44, 1},
		{0x0d46, 0x0d48, 1},
		{0x0d4a, 0x0d4e, 1},
		{0x0d57, 0x0d57, 1},
		{0x0d5f, 0x0d63, 1},
		{0x0d66, 0x0d75, 1},
		{0x0d79, 0x0d7f, 1},
	},
}

var _Mandaic = &RangeTable{
	R16: []Range16{
		{0x0840, 0x085b, 1},
		{0x085e, 0x085e, 1},
	},
}

var _Manichaean = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10ac0, 0x10ae6, 1},
		{0x10aeb, 0x10af6, 1},
	},
}

var _Meetei_Mayek = &RangeTable{
	R16: []Range16{
		{0xaae0, 0xaaf6, 1},
		{0xabc0, 0xabed, 1},
		{0xabf0, 0xabf9, 1},
	},
}

var _Mende_Kikakui = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x1e800, 0x1e8c4, 1},
		{0x1e8c7, 0x1e8d6, 1},
	},
}

var _Meroitic_Cursive = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x109a0, 0x109b7, 1},
		{0x109bc, 0x109cf, 1},
		{0x109d2, 0x109ff, 1},
	},
}

var _Meroitic_Hieroglyphs = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10980, 0x1099f, 1},
	},
}

var _Miao = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x16f00, 0x16f44, 1},
		{0x16f50, 0x16f7e, 1},
		{0x16f8f, 0x16f9f, 1},
	},
}

var _Modi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11600, 0x11644, 1},
		{0x11650, 0x11659, 1},
	},
}

var _Mongolian = &RangeTable{
	R16: []Range16{
		{0x1800, 0x1801, 1},
		{0x1804, 0x1804, 1},
		{0x1806, 0x180e, 1},
		{0x1810, 0x1819, 1},
		{0x1820, 0x1877, 1},
		{0x1880, 0x18aa, 1},
	},
}

var _Mro = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x16a40, 0x16a5e, 1},
		{0x16a60, 0x16a69, 1},
		{0x16a6e, 0x16a6f, 1},
	},
}

var _Multani = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11280, 0x11286, 1},
		{0x11288, 0x11288, 1},
		{0x1128a, 0x1128d, 1},
		{0x1128f, 0x1129d, 1},
		{0x1129f, 0x112a9, 1},
	},
}

var _Myanmar = &RangeTable{
	R16: []Range16{
		{0x1000, 0x109f, 1},
		{0xa9e0, 0xa9fe, 1},
		{0xaa60, 0xaa7f, 1},
	},
}

var _Nabataean = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10880, 0x1089e, 1},
		{0x108a7, 0x108af, 1},
	},
}

var _New_Tai_Lue = &RangeTable{
	R16: []Range16{
		{0x1980, 0x19ab, 1},
		{0x19b0, 0x19c9, 1},
		{0x19d0, 0x19da, 1},
		{0x19de, 0x19df, 1},
	},
}

var _Nko = &RangeTable{
	R16: []Range16{
		{0x07c0, 0x07fa, 1},
	},
}

var _Ogham = &RangeTable{
	R16: []Range16{
		{0x1680, 0x169c, 1},
	},
}

var _Ol_Chiki = &RangeTable{
	R16: []Range16{
		{0x1c50, 0x1c7f, 1},
	},
}

var _Old_Hungarian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10c80, 0x10cb2, 1},
		{0x10cc0, 0x10cf2, 1},
		{0x10cfa, 0x10cff, 1},
	},
}

var _Old_Italic = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10300, 0x10323, 1},
	},
}

var _Old_North_Arabian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10a80, 0x10a9f, 1},
	},
}

var _Old_Permic = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10350, 0x1037a, 1},
	},
}

var _Old_Persian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x103a0, 0x103c3, 1},
		{0x103c8, 0x103d5, 1},
	},
}

var _Old_South_Arabian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10a60, 0x10a7f, 1},
	},
}

var _Old_Turkic = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10c00, 0x10c48, 1},
	},
}

var _Oriya = &RangeTable{
	R16: []Range16{
		{0x0b01, 0x0b03, 1},
		{0x0b05, 0x0b0c, 1},
		{0x0b0f, 0x0b10, 1},
		{0x0b13, 0x0b28, 1},
		{0x0b2a, 0x0b30, 1},
		{0x0b32, 0x0b33, 1},
		{0x0b35, 0x0b39, 1},
		{0x0b3c, 0x0b44, 1},
		{0x0b47, 0x0b48, 1},
		{0x0b4b, 0x0b4d, 1},
		{0x0b56, 0x0b57, 1},
		{0x0b5c, 0x0b5d, 1},
		{0x0b5f, 0x0b63, 1},
		{0x0b66, 0x0b77, 1},
	},
}

var _Osmanya = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10480, 0x1049d, 1},
		{0x104a0, 0x104a9, 1},
	},
}

var _Pahawh_Hmong = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x16b00, 0x16b45, 1},
		{0x16b50, 0x16b59, 1},
		{0x16b5b, 0x16b61, 1},
		{0x16b63, 0x16b77, 1},
		{0x16b7d, 0x16b8f, 1},
	},
}

var _Palmyrene = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10860, 0x1087f, 1},
	},
}

var _Pau_Cin_Hau = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11ac0, 0x11af8, 1},
	},
}

var _Phags_Pa = &RangeTable{
	R16: []Range16{
		{0xa840, 0xa877, 1},
	},
}

var _Phoenician = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10900, 0x1091b, 1},
		{0x1091f, 0x1091f, 1},
	},
}

var _Psalter_Pahlavi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10b80, 0x10b91, 1},
		{0x10b99, 0x10b9c, 1},
		{0x10ba9, 0x10baf, 1},
	},
}

var _Rejang = &RangeTable{
	R16: []Range16{
		{0xa930, 0xa953, 1},
		{0xa95f, 0xa95f, 1},
	},
}

var _Runic = &RangeTable{
	R16: []Range16{
		{0x16a0, 0x16ea, 1},
		{0x16ee, 0x16f8, 1},
	},
}

var _Samaritan = &RangeTable{
	R16: []Range16{
		{0x0800, 0x082d, 1},
		{0x0830, 0x083e, 1},
	},
}

var _Saurashtra = &RangeTable{
	R16: []Range16{
		{0xa880, 0xa8c4, 1},
		{0xa8ce, 0xa8d9, 1},
	},
}

var _Sharada = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11180, 0x111cd, 1},
		{0x111d0, 0x111df, 1},
	},
}

var _Shavian = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10450, 0x1047f, 1},
	},
}

var _Siddham = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11580, 0x115b5, 1},
		{0x115b8, 0x115dd, 1},
	},
}

var _SignWriting = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x1d800, 0x1da8b, 1},
		{0x1da9b, 0x1da9f, 1},
		{0x1daa1, 0x1daaf, 1},
	},
}

var _Sinhala = &RangeTable{
	R16: []Range16{
		{0x0d82, 0x0d83, 1},
		{0x0d85, 0x0d96, 1},
		{0x0d9a, 0x0db1, 1},
		{0x0db3, 0x0dbb, 1},
		{0x0dbd, 0x0dbd, 1},
		{0x0dc0, 0x0dc6, 1},
		{0x0dca, 0x0dca, 1},
		{0x0dcf, 0x0dd4, 1},
		{0x0dd6, 0x0dd6, 1},
		{0x0dd8, 0x0ddf, 1},
		{0x0de6, 0x0def, 1},
		{0x0df2, 0x0df4, 1},
	},
	R32: []Range32{
		{0x111e1, 0x111f4, 1},
	},
}

var _Sora_Sompeng = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x110d0, 0x110e8, 1},
		{0x110f0, 0x110f9, 1},
	},
}

var _Sundanese = &RangeTable{
	R16: []Range16{
		{0x1b80, 0x1bbf, 1},
		{0x1cc0, 0x1cc7, 1},
	},
}

var _Syloti_Nagri = &RangeTable{
	R16: []Range16{
		{0xa800, 0xa82b, 1},
	},
}

var _Syriac = &RangeTable{
	R16: []Range16{
		{0x0700, 0x070d, 1},
		{0x070f, 0x074a, 1},
		{0x074d, 0x074f, 1},
	},
}

var _Tagalog = &RangeTable{
	R16: []Range16{
		{0x1700, 0x170c, 1},
		{0x170e, 0x1714, 1},
	},
}

var _Tagbanwa = &RangeTable{
	R16: []Range16{
		{0x1760, 0x176c, 1},
		{0x176e, 0x1770, 1},
		{0x1772, 0x1773, 1},
	},
}

var _Tai_Le = &RangeTable{
	R16: []Range16{
		{0x1950, 0x196d, 1},
		{0x1970, 0x1974, 1},
	},
}

var _Tai_Tham = &RangeTable{
	R16: []Range16{
		{0x1a20, 0x1a5e, 1},
		{0x1a60, 0x1a7c, 1},
		{0x1a7f, 0x1a89, 1},
		{0x1a90, 0x1a99, 1},
		{0x1aa0, 0x1aad, 1},
	},
}

var _Tai_Viet = &RangeTable{
	R16: []Range16{
		{0xaa80, 0xaac2, 1},
		{0xaadb, 0xaadf, 1},
	},
}

var _Takri = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11680, 0x116b7, 1},
		{0x116c0, 0x116c9, 1},
	},
}

var _Tamil = &RangeTable{
	R16: []Range16{
		{0x0b82, 0x0b83, 1},
		{0x0b85, 0x0b8a, 1},
		{0x0b8e, 0x0b90, 1},
		{0x0b92, 0x0b95, 1},
		{0x0b99, 0x0b9a, 1},
		{0x0b9c, 0x0b9c, 1},
		{0x0b9e, 0x0b9f, 1},
		{0x0ba3, 0x0ba4, 1},
		{0x0ba8, 0x0baa, 1},
		{0x0bae, 0x0bb9, 1},
		{0x0bbe, 0x0bc2, 1},
		{0x0bc6, 0x0bc8, 1},
		{0x0bca, 0x0bcd, 1},
		{0x0bd0, 0x0bd0, 1},
		{0x0bd7, 0x0bd7, 1},
		{0x0be6, 0x0bfa, 1},
	},
}

var _Telugu = &RangeTable{
	R16: []Range16{
		{0x0c00, 0x0c03, 1},
		{0x0c05, 0x0c0c, 1},
		{0x0c0e, 0x0c10, 1},
		{0x0c12, 0x0c28, 1},
		{0x0c2a, 0x0c39, 1},
		{0x0c3d, 0x0c44, 1},
		{0x0c46, 0x0c48, 1},
		{0x0c4a, 0x0c4d, 1},
		{0x0c55, 0x0c56, 1},
		{0x0c58, 0x0c5a, 1},
		{0x0c60, 0x0c63, 1},
		{0x0c66, 0x0c6f, 1},
		{0x0c78, 0x0c7f, 1},
	},
}

var _Thaana = &RangeTable{
	R16: []Range16{
		{0x0780, 0x07b1, 1},
	},
}

var _Thai = &RangeTable{
	R16: []Range16{
		{0x0e01, 0x0e3a, 1},
		{0x0e40, 0x0e5b, 1},
	},
}

var _Tibetan = &RangeTable{
	R16: []Range16{
		{0x0f00, 0x0f47, 1},
		{0x0f49, 0x0f6c, 1},
		{0x0f71, 0x0f97, 1},
		{0x0f99, 0x0fbc, 1},
		{0x0fbe, 0x0fcc, 1},
		{0x0fce, 0x0fd4, 1},
		{0x0fd9, 0x0fda, 1},
	},
}

var _Tifinagh = &RangeTable{
	R16: []Range16{
		{0x2d30, 0x2d67, 1},
		{0x2d6f, 0x2d70, 1},
		{0x2d7f, 0x2d7f, 1},
	},
}

var _Tirhuta = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x11480, 0x114c7, 1},
		{0x114d0, 0x114d9, 1},
	},
}

var _Ugaritic = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x10380, 0x1039d, 1},
		{0x1039f, 0x1039f, 1},
	},
}

var _Vai = &RangeTable{
	R16: []Range16{
		{0xa500, 0xa62b, 1},
	},
}

var _Warang_Citi = &RangeTable{
	R16: []Range16{},
	R32: []Range32{
		{0x118a0, 0x118f2, 1},
		{0x118ff, 0x118ff, 1},
	},
}

var _Yi = &RangeTable{
	R16: []Range16{
		{0xa000, 0xa48c, 1},
		{0xa490, 0xa4c6, 1},
	},
}

// These variables have type *RangeTable.
var (
	Ahom                   = _Ahom                   // Ahom is the set of Unicode characters in script Ahom.
	Anatolian_Hieroglyphs  = _Anatolian_Hieroglyphs  // Anatolian_Hieroglyphs is the set of Unicode characters in script Anatolian_Hieroglyphs.
	Arabic                 = _Arabic                 // Arabic is the set of Unicode characters in script Arabic.
	Armenian               = _Armenian               // Armenian is the set of Unicode characters in script Armenian.
	Avestan                = _Avestan                // Avestan is the set of Unicode characters in script Avestan.
	Balinese               = _Balinese               // Balinese is the set of Unicode characters in script Balinese.
	Bamum                  = _Bamum                  // Bamum is the set of Unicode characters in script Bamum.
	Bassa_Vah              = _Bassa_Vah              // Bassa_Vah is the set of Unicode characters in script Bassa_Vah.
	Batak                  = _Batak                  // Batak is the set of Unicode characters in script Batak.
	Bengali                = _Bengali                // Bengali is the set of Unicode characters in script Bengali.
	Bopomofo               = _Bopomofo               // Bopomofo is the set of Unicode characters in script Bopomofo.
	Brahmi                 = _Brahmi                 // Brahmi is the set of Unicode characters in script Brahmi.
	Braille                = _Braille                // Braille is the set of Unicode characters in script Braille.
	Buginese               = _Buginese               // Buginese is the set of Unicode characters in script Buginese.
	Buhid                  = _Buhid                  // Buhid is the set of Unicode characters in script Buhid.
	Canadian_Aboriginal    = _Canadian_Aboriginal    // Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.
	Carian                 = _Carian                 // Carian is the set of Unicode characters in script Carian.
	Caucasian_Albanian     = _Caucasian_Albanian     // Caucasian_Albanian is the set of Unicode characters in script Caucasian_Albanian.
	Chakma                 = _Chakma                 // Chakma is the set of Unicode characters in script Chakma.
	Cham                   = _Cham                   // Cham is the set of Unicode characters in script Cham.
	Cherokee               = _Cherokee               // Cherokee is the set of Unicode characters in script Cherokee.
	Common                 = _Common                 // Common is the set of Unicode characters in script Common.
	Coptic                 = _Coptic                 // Coptic is the set of Unicode characters in script Coptic.
	Cuneiform              = _Cuneiform              // Cuneiform is the set of Unicode characters in script Cuneiform.
	Cypriot                = _Cypriot                // Cypriot is the set of Unicode characters in script Cypriot.
	Cyrillic               = _Cyrillic               // Cyrillic is the set of Unicode characters in script Cyrillic.
	Deseret                = _Deseret                // Deseret is the set of Unicode characters in script Deseret.
	Devanagari             = _Devanagari             // Devanagari is the set of Unicode characters in script Devanagari.
	Duployan               = _Duployan               // Duployan is the set of Unicode characters in script Duployan.
	Egyptian_Hieroglyphs   = _Egyptian_Hieroglyphs   // Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.
	Elbasan                = _Elbasan                // Elbasan is the set of Unicode characters in script Elbasan.
	Ethiopic               = _Ethiopic               // Ethiopic is the set of Unicode characters in script Ethiopic.
	Georgian               = _Georgian               // Georgian is the set of Unicode characters in script Georgian.
	Glagolitic             = _Glagolitic             // Glagolitic is the set of Unicode characters in script Glagolitic.
	Gothic                 = _Gothic                 // Gothic is the set of Unicode characters in script Gothic.
	Grantha                = _Grantha                // Grantha is the set of Unicode characters in script Grantha.
	Greek                  = _Greek                  // Greek is the set of Unicode characters in script Greek.
	Gujarati               = _Gujarati               // Gujarati is the set of Unicode characters in script Gujarati.
	Gurmukhi               = _Gurmukhi               // Gurmukhi is the set of Unicode characters in script Gurmukhi.
	Han                    = _Han                    // Han is the set of Unicode characters in script Han.
	Hangul                 = _Hangul                 // Hangul is the set of Unicode characters in script Hangul.
	Hanunoo                = _Hanunoo                // Hanunoo is the set of Unicode characters in script Hanunoo.
	Hatran                 = _Hatran                 // Hatran is the set of Unicode characters in script Hatran.
	Hebrew                 = _Hebrew                 // Hebrew is the set of Unicode characters in script Hebrew.
	Hiragana               = _Hiragana               // Hiragana is the set of Unicode characters in script Hiragana.
	Imperial_Aramaic       = _Imperial_Aramaic       // Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.
	Inherited              = _Inherited              // Inherited is the set of Unicode characters in script Inherited.
	Inscriptional_Pahlavi  = _Inscriptional_Pahlavi  // Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.
	Inscriptional_Parthian = _Inscriptional_Parthian // Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.
	Javanese               = _Javanese               // Javanese is the set of Unicode characters in script Javanese.
	Kaithi                 = _Kaithi                 // Kaithi is the set of Unicode characters in script Kaithi.
	Kannada                = _Kannada                // Kannada is the set of Unicode characters in script Kannada.
	Katakana               = _Katakana               // Katakana is the set of Unicode characters in script Katakana.
	Kayah_Li               = _Kayah_Li               // Kayah_Li is the set of Unicode characters in script Kayah_Li.
	Kharoshthi             = _Kharoshthi             // Kharoshthi is the set of Unicode characters in script Kharoshthi.
	Khmer                  = _Khmer                  // Khmer is the set of Unicode characters in script Khmer.
	Khojki                 = _Khojki                 // Khojki is the set of Unicode characters in script Khojki.
	Khudawadi              = _Khudawadi              // Khudawadi is the set of Unicode characters in script Khudawadi.
	Lao                    = _Lao                    // Lao is the set of Unicode characters in script Lao.
	Latin                  = _Latin                  // Latin is the set of Unicode characters in script Latin.
	Lepcha                 = _Lepcha                 // Lepcha is the set of Unicode characters in script Lepcha.
	Limbu                  = _Limbu                  // Limbu is the set of Unicode characters in script Limbu.
	Linear_A               = _Linear_A               // Linear_A is the set of Unicode characters in script Linear_A.
	Linear_B               = _Linear_B               // Linear_B is the set of Unicode characters in script Linear_B.
	Lisu                   = _Lisu                   // Lisu is the set of Unicode characters in script Lisu.
	Lycian                 = _Lycian                 // Lycian is the set of Unicode characters in script Lycian.
	Lydian                 = _Lydian                 // Lydian is the set of Unicode characters in script Lydian.
	Mahajani               = _Mahajani               // Mahajani is the set of Unicode characters in script Mahajani.
	Malayalam              = _Malayalam              // Malayalam is the set of Unicode characters in script Malayalam.
	Mandaic                = _Mandaic                // Mandaic is the set of Unicode characters in script Mandaic.
	Manichaean             = _Manichaean             // Manichaean is the set of Unicode characters in script Manichaean.
	Meetei_Mayek           = _Meetei_Mayek           // Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.
	Mende_Kikakui          = _Mende_Kikakui          // Mende_Kikakui is the set of Unicode characters in script Mende_Kikakui.
	Meroitic_Cursive       = _Meroitic_Cursive       // Meroitic_Cursive is the set of Unicode characters in script Meroitic_Cursive.
	Meroitic_Hieroglyphs   = _Meroitic_Hieroglyphs   // Meroitic_Hieroglyphs is the set of Unicode characters in script Meroitic_Hieroglyphs.
	Miao                   = _Miao                   // Miao is the set of Unicode characters in script Miao.
	Modi                   = _Modi                   // Modi is the set of Unicode characters in script Modi.
	Mongolian              = _Mongolian              // Mongolian is the set of Unicode characters in script Mongolian.
	Mro                    = _Mro                    // Mro is the set of Unicode characters in script Mro.
	Multani                = _Multani                // Multani is the set of Unicode characters in script Multani.
	Myanmar                = _Myanmar                // Myanmar is the set of Unicode characters in script Myanmar.
	Nabataean              = _Nabataean              // Nabataean is the set of Unicode characters in script Nabataean.
	New_Tai_Lue            = _New_Tai_Lue            // New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.
	Nko                    = _Nko                    // Nko is the set of Unicode characters in script Nko.
	Ogham                  = _Ogham                  // Ogham is the set of Unicode characters in script Ogham.
	Ol_Chiki               = _Ol_Chiki               // Ol_Chiki is the set of Unicode characters in script Ol_Chiki.
	Old_Hungarian          = _Old_Hungarian          // Old_Hungarian is the set of Unicode characters in script Old_Hungarian.
	Old_Italic             = _Old_Italic             // Old_Italic is the set of Unicode characters in script Old_Italic.
	Old_North_Arabian      = _Old_North_Arabian      // Old_North_Arabian is the set of Unicode characters in script Old_North_Arabian.
	Old_Permic             = _Old_Permic             // Old_Permic is the set of Unicode characters in script Old_Permic.
	Old_Persian            = _Old_Persian            // Old_Persian is the set of Unicode characters in script Old_Persian.
	Old_South_Arabian      = _Old_South_Arabian      // Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.
	Old_Turkic             = _Old_Turkic             // Old_Turkic is the set of Unicode characters in script Old_Turkic.
	Oriya                  = _Oriya                  // Oriya is the set of Unicode characters in script Oriya.
	Osmanya                = _Osmanya                // Osmanya is the set of Unicode characters in script Osmanya.
	Pahawh_Hmong           = _Pahawh_Hmong           // Pahawh_Hmong is the set of Unicode characters in script Pahawh_Hmong.
	Palmyrene              = _Palmyrene              // Palmyrene is the set of Unicode characters in script Palmyrene.
	Pau_Cin_Hau            = _Pau_Cin_Hau            // Pau_Cin_Hau is the set of Unicode characters in script Pau_Cin_Hau.
	Phags_Pa               = _Phags_Pa               // Phags_Pa is the set of Unicode characters in script Phags_Pa.
	Phoenician             = _Phoenician             // Phoenician is the set of Unicode characters in script Phoenician.
	Psalter_Pahlavi        = _Psalter_Pahlavi        // Psalter_Pahlavi is the set of Unicode characters in script Psalter_Pahlavi.
	Rejang                 = _Rejang                 // Rejang is the set of Unicode characters in script Rejang.
	Runic                  = _Runic                  // Runic is the set of Unicode characters in script Runic.
	Samaritan              = _Samaritan              // Samaritan is the set of Unicode characters in script Samaritan.
	Saurashtra             = _Saurashtra             // Saurashtra is the set of Unicode characters in script Saurashtra.
	Sharada                = _Sharada                // Sharada is the set of Unicode characters in script Sharada.
	Shavian                = _Shavian                // Shavian is the set of Unicode characters in script Shavian.
	Siddham                = _Siddham                // Siddham is the set of Unicode characters in script Siddham.
	SignWriting            = _SignWriting            // SignWriting is the set of Unicode characters in script SignWriting.
	Sinhala                = _Sinhala                // Sinhala is the set of Unicode characters in script Sinhala.
	Sora_Sompeng           = _Sora_Sompeng           // Sora_Sompeng is the set of Unicode characters in script Sora_Sompeng.
	Sundanese              = _Sundanese              // Sundanese is the set of Unicode characters in script Sundanese.
	Syloti_Nagri           = _Syloti_Nagri           // Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.
	Syriac                 = _Syriac                 // Syriac is the set of Unicode characters in script Syriac.
	Tagalog                = _Tagalog                // Tagalog is the set of Unicode characters in script Tagalog.
	Tagbanwa               = _Tagbanwa               // Tagbanwa is the set of Unicode characters in script Tagbanwa.
	Tai_Le                 = _Tai_Le                 // Tai_Le is the set of Unicode characters in script Tai_Le.
	Tai_Tham               = _Tai_Tham               // Tai_Tham is the set of Unicode characters in script Tai_Tham.
	Tai_Viet               = _Tai_Viet               // Tai_Viet is the set of Unicode characters in script Tai_Viet.
	Takri                  = _Takri                  // Takri is the set of Unicode characters in script Takri.
	Tamil                  = _Tamil                  // Tamil is the set of Unicode characters in script Tamil.
	Telugu                 = _Telugu                 // Telugu is the set of Unicode characters in script Telugu.
	Thaana                 = _Thaana                 // Thaana is the set of Unicode characters in script Thaana.
	Thai                   = _Thai                   // Thai is the set of Unicode characters in script Thai.
	Tibetan                = _Tibetan                // Tibetan is the set of Unicode characters in script Tibetan.
	Tifinagh               = _Tifinagh               // Tifinagh is the set of Unicode characters in script Tifinagh.
	Tirhuta                = _Tirhuta                // Tirhuta is the set of Unicode characters in script Tirhuta.
	Ugaritic               = _Ugaritic               // Ugaritic is the set of Unicode characters in script Ugaritic.
	Vai                    = _Vai                    // Vai is the set of Unicode characters in script Vai.
	Warang_Citi            = _Warang_Citi            // Warang_Citi is the set of Unicode characters in script Warang_Citi.
	Yi                     = _Yi                     // Yi is the set of Unicode characters in script Yi.
)

// Generated by running
//	maketables --props=all --url=http://www.unicode.org/Public/8.0.0/ucd/
// DO NOT EDIT

// Properties is the set of Unicode property tables.
var Properties = map[string]*RangeTable{
	"ASCII_Hex_Digit":                    ASCII_Hex_Digit,
	"Bidi_Control":                       Bidi_Control,
	"Dash":                               Dash,
	"Deprecated":                         Deprecated,
	"Diacritic":                          Diacritic,
	"Extender":                           Extender,
	"Hex_Digit":                          Hex_Digit,
	"Hyphen":                             Hyphen,
	"IDS_Binary_Operator":                IDS_Binary_Operator,
	"IDS_Trinary_Operator":               IDS_Trinary_Operator,
	"Ideographic":                        Ideographic,
	"Join_Control":                       Join_Control,
	"Logical_Order_Exception":            Logical_Order_Exception,
	"Noncharacter_Code_Point":            Noncharacter_Code_Point,
	"Other_Alphabetic":                   Other_Alphabetic,
	"Other_Default_Ignorable_Code_Point": Other_Default_Ignorable_Code_Point,
	"Other_Grapheme_Extend":              Other_Grapheme_Extend,
	"Other_ID_Continue":                  Other_ID_Continue,
	"Other_ID_Start":                     Other_ID_Start,
	"Other_Lowercase":                    Other_Lowercase,
	"Other_Math":                         Other_Math,
	"Other_Uppercase":                    Other_Uppercase,
	"Pattern_Syntax":                     Pattern_Syntax,
	"Pattern_White_Space":                Pattern_White_Space,
	"Quotation_Mark":                     Quotation_Mark,
	"Radical":                            Radical,
	"STerm":                              STerm,
	"Soft_Dotted":                        Soft_Dotted,
	"Terminal_Punctuation":               Terminal_Punctuation,
	"Unified_Ideograph":                  Unified_Ideograph,
	"Variation_Selector":                 Variation_Selector,
	"White_Space":                        White_Space,
}

var _ASCII_Hex_Digit = &RangeTable{
	R16: []Range16{
		{0x0030, 0x0039, 1},
		{0x0041, 0x0046, 1},
		{0x0061, 0x0066, 1},
	},
	LatinOffset: 3,
}

var _Bidi_Control = &RangeTable{
	R16: []Range16{
		{0x061c, 0x061c, 1},
		{0x200e, 0x200f, 1},
		{0x202a, 0x202e, 1},
		{0x2066, 0x2069, 1},
	},
}

var _Dash = &RangeTable{
	R16: []Range16{
		{0x002d, 0x002d, 1},
		{0x058a, 0x058a, 1},
		{0x05be, 0x05be, 1},
		{0x1400, 0x1400, 1},
		{0x1806, 0x1806, 1},
		{0x2010, 0x2015, 1},
		{0x2053, 0x2053, 1},
		{0x207b, 0x207b, 1},
		{0x208b, 0x208b, 1},
		{0x2212, 0x2212, 1},
		{0x2e17, 0x2e17, 1},
		{0x2e1a, 0x2e1a, 1},
		{0x2e3a, 0x2e3b, 1},
		{0x2e40, 0x2e40, 1},
		{0x301c, 0x301c, 1},
		{0x3030, 0x3030, 1},
		{0x30a0, 0x30a0, 1},
		{0xfe31, 0xfe32, 1},
		{0xfe58, 0xfe58, 1},
		{0xfe63, 0xfe63, 1},
		{0xff0d, 0xff0d, 1},
	},
	LatinOffset: 1,
}

var _Deprecated = &RangeTable{
	R16: []Range16{
		{0x0149, 0x0149, 1},
		{0x0673, 0x0673, 1},
		{0x0f77, 0x0f77, 1},
		{0x0f79, 0x0f79, 1},
		{0x17a3, 0x17a4, 1},
		{0x206a, 0x206f, 1},
		{0x2329, 0x232a, 1},
	},
	R32: []Range32{
		{0xe0001, 0xe0001, 1},
		{0xe007f, 0xe007f, 1},
	},
}

var _Diacritic = &RangeTable{
	R16: []Range16{
		{0x005e, 0x005e, 1},
		{0x0060, 0x0060, 1},
		{0x00a8, 0x00a8, 1},
		{0x00af, 0x00af, 1},
		{0x00b4, 0x00b4, 1},
		{0x00b7, 0x00b8, 1},
		{0x02b0, 0x034e, 1},
		{0x0350, 0x0357, 1},
		{0x035d, 0x0362, 1},
		{0x0374, 0x0375, 1},
		{0x037a, 0x037a, 1},
		{0x0384, 0x0385, 1},
		{0x0483, 0x0487, 1},
		{0x0559, 0x0559, 1},
		{0x0591, 0x05a1, 1},
		{0x05a3, 0x05bd, 1},
		{0x05bf, 0x05bf, 1},
		{0x05c1, 0x05c2, 1},
		{0x05c4, 0x05c4, 1},
		{0x064b, 0x0652, 1},
		{0x0657, 0x0658, 1},
		{0x06df, 0x06e0, 1},
		{0x06e5, 0x06e6, 1},
		{0x06ea, 0x06ec, 1},
		{0x0730, 0x074a, 1},
		{0x07a6, 0x07b0, 1},
		{0x07eb, 0x07f5, 1},
		{0x0818, 0x0819, 1},
		{0x08e3, 0x08fe, 1},
		{0x093c, 0x093c, 1},
		{0x094d, 0x094d, 1},
		{0x0951, 0x0954, 1},
		{0x0971, 0x0971, 1},
		{0x09bc, 0x09bc, 1},
		{0x09cd, 0x09cd, 1},
		{0x0a3c, 0x0a3c, 1},
		{0x0a4d, 0x0a4d, 1},
		{0x0abc, 0x0abc, 1},
		{0x0acd, 0x0acd, 1},
		{0x0b3c, 0x0b3c, 1},
		{0x0b4d, 0x0b4d, 1},
		{0x0bcd, 0x0bcd, 1},
		{0x0c4d, 0x0c4d, 1},
		{0x0cbc, 0x0cbc, 1},
		{0x0ccd, 0x0ccd, 1},
		{0x0d4d, 0x0d4d, 1},
		{0x0dca, 0x0dca, 1},
		{0x0e47, 0x0e4c, 1},
		{0x0e4e, 0x0e4e, 1},
		{0x0ec8, 0x0ecc, 1},
		{0x0f18, 0x0f19, 1},
		{0x0f35, 0x0f35, 1},
		{0x0f37, 0x0f37, 1},
		{0x0f39, 0x0f39, 1},
		{0x0f3e, 0x0f3f, 1},
		{0x0f82, 0x0f84, 1},
		{0x0f86, 0x0f87, 1},
		{0x0fc6, 0x0fc6, 1},
		{0x1037, 0x1037, 1},
		{0x1039, 0x103a, 1},
		{0x1087, 0x108d, 1},
		{0x108f, 0x108f, 1},
		{0x109a, 0x109b, 1},
		{0x17c9, 0x17d3, 1},
		{0x17dd, 0x17dd, 1},
		{0x1939, 0x193b, 1},
		{0x1a75, 0x1a7c, 1},
		{0x1a7f, 0x1a7f, 1},
		{0x1ab0, 0x1abd, 1},
		{0x1b34, 0x1b34, 1},
		{0x1b44, 0x1b44, 1},
		{0x1b6b, 0x1b73, 1},
		{0x1baa, 0x1bab, 1},
		{0x1c36, 0x1c37, 1},
		{0x1c78, 0x1c7d, 1},
		{0x1cd0, 0x1ce8, 1},
		{0x1ced, 0x1ced, 1},
		{0x1cf4, 0x1cf4, 1},
		{0x1cf8, 0x1cf9, 1},
		{0x1d2c, 0x1d6a, 1},
		{0x1dc4, 0x1dcf, 1},
		{0x1df5, 0x1df5, 1},
		{0x1dfd, 0x1dff, 1},
		{0x1fbd, 0x1fbd, 1},
		{0x1fbf, 0x1fc1, 1},
		{0x1fcd, 0x1fcf, 1},
		{0x1fdd, 0x1fdf, 1},
		{0x1fed, 0x1fef, 1},
		{0x1ffd, 0x1ffe, 1},
		{0x2cef, 0x2cf1, 1},
		{0x2e2f, 0x2e2f, 1},
		{0x302a, 0x302f, 1},
		{0x3099, 0x309c, 1},
		{0x30fc, 0x30fc, 1},
		{0xa66f, 0xa66f, 1},
		{0xa67c, 0xa67d, 1},
		{0xa67f, 0xa67f, 1},
		{0xa69c, 0xa69d, 1},
		{0xa6f0, 0xa6f1, 1},
		{0xa717, 0xa721, 1},
		{0xa788, 0xa788, 1},
		{0xa7f8, 0xa7f9, 1},
		{0xa8c4, 0xa8c4, 1},
		{0xa8e0, 0xa8f1, 1},
		{0xa92b, 0xa92e, 1},
		{0xa953, 0xa953, 1},
		{0xa9b3, 0xa9b3, 1},
		{0xa9c0, 0xa9c0, 1},
		{0xa9e5, 0xa9e5, 1},
		{0xaa7b, 0xaa7d, 1},
		{0xaabf, 0xaac2, 1},
		{0xaaf6, 0xaaf6, 1},
		{0xab5b, 0xab5f, 1},
		{0xabec, 0xabed, 1},
		{0xfb1e, 0xfb1e, 1},
		{0xfe20, 0xfe2f, 1},
		{0xff3e, 0xff3e, 1},
		{0xff40, 0xff40, 1},
		{0xff70, 0xff70, 1},
		{0xff9e, 0xff9f, 1},
		{0xffe3, 0xffe3, 1},
	},
	R32: []Range32{
		{0x102e0, 0x102e0, 1},
		{0x10ae5, 0x10ae6, 1},
		{0x110b9, 0x110ba, 1},
		{0x11133, 0x11134, 1},
		{0x11173, 0x11173, 1},
		{0x111c0, 0x111c0, 1},
		{0x111ca, 0x111cc, 1},
		{0x11235, 0x11236, 1},
		{0x112e9, 0x112ea, 1},
		{0x1133c, 0x1133c, 1},
		{0x1134d, 0x1134d, 1},
		{0x11366, 0x1136c, 1},
		{0x11370, 0x11374, 1},
		{0x114c2, 0x114c3, 1},
		{0x115bf, 0x115c0, 1},
		{0x1163f, 0x1163f, 1},
		{0x116b6, 0x116b7, 1},
		{0x1172b, 0x1172b, 1},
		{0x16af0, 0x16af4, 1},
		{0x16f8f, 0x16f9f, 1},
		{0x1d167, 0x1d169, 1},
		{0x1d16d, 0x1d172, 1},
		{0x1d17b, 0x1d182, 1},
		{0x1d185, 0x1d18b, 1},
		{0x1d1aa, 0x1d1ad, 1},
		{0x1e8d0, 0x1e8d6, 1},
	},
	LatinOffset: 6,
}

var _Extender = &RangeTable{
	R16: []Range16{
		{0x00b7, 0x00b7, 1},
		{0x02d0, 0x02d1, 1},
		{0x0640, 0x0640, 1},
		{0x07fa, 0x07fa, 1},
		{0x0e46, 0x0e46, 1},
		{0x0ec6, 0x0ec6, 1},
		{0x180a, 0x180a, 1},
		{0x1843, 0x1843, 1},
		{0x1aa7, 0x1aa7, 1},
		{0x1c36, 0x1c36, 1},
		{0x1c7b, 0x1c7b, 1},
		{0x3005, 0x3005, 1},
		{0x3031, 0x3035, 1},
		{0x309d, 0x309e, 1},
		{0x30fc, 0x30fe, 1},
		{0xa015, 0xa015, 1},
		{0xa60c, 0xa60c, 1},
		{0xa9cf, 0xa9cf, 1},
		{0xa9e6, 0xa9e6, 1},
		{0xaa70, 0xaa70, 1},
		{0xaadd, 0xaadd, 1},
		{0xaaf3, 0xaaf4, 1},
		{0xff70, 0xff70, 1},
	},
	R32: []Range32{
		{0x1135d, 0x1135d, 1},
		{0x115c6, 0x115c8, 1},
		{0x16b42, 0x16b43, 1},
	},
	LatinOffset: 1,
}

var _Hex_Digit = &RangeTable{
	R16: []Range16{
		{0x0030, 0x0039, 1},
		{0x0041, 0x0046, 1},
		{0x0061, 0x0066, 1},
		{0xff10, 0xff19, 1},
		{0xff21, 0xff26, 1},
		{0xff41, 0xff46, 1},
	},
	LatinOffset: 3,
}

var _Hyphen = &RangeTable{
	R16: []Range16{
		{0x002d, 0x002d, 1},
		{0x00ad, 0x00ad, 1},
		{0x058a, 0x058a, 1},
		{0x1806, 0x1806, 1},
		{0x2010, 0x2011, 1},
		{0x2e17, 0x2e17, 1},
		{0x30fb, 0x30fb, 1},
		{0xfe63, 0xfe63, 1},
		{0xff0d, 0xff0d, 1},
		{0xff65, 0xff65, 1},
	},
	LatinOffset: 2,
}

var _IDS_Binary_Operator = &RangeTable{
	R16: []Range16{
		{0x2ff0, 0x2ff1, 1},
		{0x2ff4, 0x2ffb, 1},
	},
}

var _IDS_Trinary_Operator = &RangeTable{
	R16: []Range16{
		{0x2ff2, 0x2ff3, 1},
	},
}

var _Ideographic = &RangeTable{
	R16: []Range16{
		{0x3006, 0x3007, 1},
		{0x3021, 0x3029, 1},
		{0x3038, 0x303a, 1},
		{0x3400, 0x4db5, 1},
		{0x4e00, 0x9fd5, 1},
		{0xf900, 0xfa6d, 1},
		{0xfa70, 0xfad9, 1},
	},
	R32: []Range32{
		{0x20000, 0x2a6d6, 1},
		{0x2a700, 0x2b734, 1},
		{0x2b740, 0x2b81d, 1},
		{0x2b820, 0x2cea1, 1},
		{0x2f800, 0x2fa1d, 1},
	},
}

var _Join_Control = &RangeTable{
	R16: []Range16{
		{0x200c, 0x200d, 1},
	},
}

var _Logical_Order_Exception = &RangeTable{
	R16: []Range16{
		{0x0e40, 0x0e44, 1},
		{0x0ec0, 0x0ec4, 1},
		{0x19b5, 0x19b7, 1},
		{0x19ba, 0x19ba, 1},
		{0xaab5, 0xaab6, 1},
		{0xaab9, 0xaab9, 1},
		{0xaabb, 0xaabc, 1},
	},
}

var _Noncharacter_Code_Point = &RangeTable{
	R16: []Range16{
		{0xfdd0, 0xfdef, 1},
		{0xfffe, 0xffff, 1},
	},
	R32: []Range32{
		{0x1fffe, 0x1ffff, 1},
		{0x2fffe, 0x2ffff, 1},
		{0x3fffe, 0x3ffff, 1},
		{0x4fffe, 0x4ffff, 1},
		{0x5fffe, 0x5ffff, 1},
		{0x6fffe, 0x6ffff, 1},
		{0x7fffe, 0x7ffff, 1},
		{0x8fffe, 0x8ffff, 1},
		{0x9fffe, 0x9ffff, 1},
		{0xafffe, 0xaffff, 1},
		{0xbfffe, 0xbffff, 1},
		{0xcfffe, 0xcffff, 1},
		{0xdfffe, 0xdffff, 1},
		{0xefffe, 0xeffff, 1},
		{0xffffe, 0xfffff, 1},
		{0x10fffe, 0x10ffff, 1},
	},
}

var _Other_Alphabetic = &RangeTable{
	R16: []Range16{
		{0x0345, 0x0345, 1},
		{0x05b0, 0x05bd, 1},
		{0x05bf, 0x05bf, 1},
		{0x05c1, 0x05c2, 1},
		{0x05c4, 0x05c5, 1},
		{0x05c7, 0x05c7, 1},
		{0x0610, 0x061a, 1},
		{0x064b, 0x0657, 1},
		{0x0659, 0x065f, 1},
		{0x0670, 0x0670, 1},
		{0x06d6, 0x06dc, 1},
		{0x06e1, 0x06e4, 1},
		{0x06e7, 0x06e8, 1},
		{0x06ed, 0x06ed, 1},
		{0x0711, 0x0711, 1},
		{0x0730, 0x073f, 1},
		{0x07a6, 0x07b0, 1},
		{0x0816, 0x0817, 1},
		{0x081b, 0x0823, 1},
		{0x0825, 0x0827, 1},
		{0x0829, 0x082c, 1},
		{0x08e3, 0x08e9, 1},
		{0x08f0, 0x0903, 1},
		{0x093a, 0x093b, 1},
		{0x093e, 0x094c, 1},
		{0x094e, 0x094f, 1},
		{0x0955, 0x0957, 1},
		{0x0962, 0x0963, 1},
		{0x0981, 0x0983, 1},
		{0x09be, 0x09c4, 1},
		{0x09c7, 0x09c8, 1},
		{0x09cb, 0x09cc, 1},
		{0x09d7, 0x09d7, 1},
		{0x09e2, 0x09e3, 1},
		{0x0a01, 0x0a03, 1},
		{0x0a3e, 0x0a42, 1},
		{0x0a47, 0x0a48, 1},
		{0x0a4b, 0x0a4c, 1},
		{0x0a51, 0x0a51, 1},
		{0x0a70, 0x0a71, 1},
		{0x0a75, 0x0a75, 1},
		{0x0a81, 0x0a83, 1},
		{0x0abe, 0x0ac5, 1},
		{0x0ac7, 0x0ac9, 1},
		{0x0acb, 0x0acc, 1},
		{0x0ae2, 0x0ae3, 1},
		{0x0b01, 0x0b03, 1},
		{0x0b3e, 0x0b44, 1},
		{0x0b47, 0x0b48, 1},
		{0x0b4b, 0x0b4c, 1},
		{0x0b56, 0x0b57, 1},
		{0x0b62, 0x0b63, 1},
		{0x0b82, 0x0b82, 1},
		{0x0bbe, 0x0bc2, 1},
		{0x0bc6, 0x0bc8, 1},
		{0x0bca, 0x0bcc, 1},
		{0x0bd7, 0x0bd7, 1},
		{0x0c00, 0x0c03, 1},
		{0x0c3e, 0x0c44, 1},
		{0x0c46, 0x0c48, 1},
		{0x0c4a, 0x0c4c, 1},
		{0x0c55, 0x0c56, 1},
		{0x0c62, 0x0c63, 1},
		{0x0c81, 0x0c83, 1},
		{0x0cbe, 0x0cc4, 1},
		{0x0cc6, 0x0cc8, 1},
		{0x0cca, 0x0ccc, 1},
		{0x0cd5, 0x0cd6, 1},
		{0x0ce2, 0x0ce3, 1},
		{0x0d01, 0x0d03, 1},
		{0x0d3e, 0x0d44, 1},
		{0x0d46, 0x0d48, 1},
		{0x0d4a, 0x0d4c, 1},
		{0x0d57, 0x0d57, 1},
		{0x0d62, 0x0d63, 1},
		{0x0d82, 0x0d83, 1},
		{0x0dcf, 0x0dd4, 1},
		{0x0dd6, 0x0dd6, 1},
		{0x0dd8, 0x0ddf, 1},
		{0x0df2, 0x0df3, 1},
		{0x0e31, 0x0e31, 1},
		{0x0e34, 0x0e3a, 1},
		{0x0e4d, 0x0e4d, 1},
		{0x0eb1, 0x0eb1, 1},
		{0x0eb4, 0x0eb9, 1},
		{0x0ebb, 0x0ebc, 1},
		{0x0ecd, 0x0ecd, 1},
		{0x0f71, 0x0f81, 1},
		{0x0f8d, 0x0f97, 1},
		{0x0f99, 0x0fbc, 1},
		{0x102b, 0x1036, 1},
		{0x1038, 0x1038, 1},
		{0x103b, 0x103e, 1},
		{0x1056, 0x1059, 1},
		{0x105e, 0x1060, 1},
		{0x1062, 0x1062, 1},
		{0x1067, 0x1068, 1},
		{0x1071, 0x1074, 1},
		{0x1082, 0x1086, 1},
		{0x109c, 0x109d, 1},
		{0x135f, 0x135f, 1},
		{0x1712, 0x1713, 1},
		{0x1732, 0x1733, 1},
		{0x1752, 0x1753, 1},
		{0x1772, 0x1773, 1},
		{0x17b6, 0x17c8, 1},
		{0x18a9, 0x18a9, 1},
		{0x1920, 0x192b, 1},
		{0x1930, 0x1938, 1},
		{0x1a17, 0x1a1b, 1},
		{0x1a55, 0x1a5e, 1},
		{0x1a61, 0x1a74, 1},
		{0x1b00, 0x1b04, 1},
		{0x1b35, 0x1b43, 1},
		{0x1b80, 0x1b82, 1},
		{0x1ba1, 0x1ba9, 1},
		{0x1bac, 0x1bad, 1},
		{0x1be7, 0x1bf1, 1},
		{0x1c24, 0x1c35, 1},
		{0x1cf2, 0x1cf3, 1},
		{0x1de7, 0x1df4, 1},
		{0x24b6, 0x24e9, 1},
		{0x2de0, 0x2dff, 1},
		{0xa674, 0xa67b, 1},
		{0xa69e, 0xa69f, 1},
		{0xa823, 0xa827, 1},
		{0xa880, 0xa881, 1},
		{0xa8b4, 0xa8c3, 1},
		{0xa926, 0xa92a, 1},
		{0xa947, 0xa952, 1},
		{0xa980, 0xa983, 1},
		{0xa9b4, 0xa9bf, 1},
		{0xaa29, 0xaa36, 1},
		{0xaa43, 0xaa43, 1},
		{0xaa4c, 0xaa4d, 1},
		{0xaab0, 0xaab0, 1},
		{0xaab2, 0xaab4, 1},
		{0xaab7, 0xaab8, 1},
		{0xaabe, 0xaabe, 1},
		{0xaaeb, 0xaaef, 1},
		{0xaaf5, 0xaaf5, 1},
		{0xabe3, 0xabea, 1},
		{0xfb1e, 0xfb1e, 1},
	},
	R32: []Range32{
		{0x10376, 0x1037a, 1},
		{0x10a01, 0x10a03, 1},
		{0x10a05, 0x10a06, 1},
		{0x10a0c, 0x10a0f, 1},
		{0x11000, 0x11002, 1},
		{0x11038, 0x11045, 1},
		{0x11082, 0x11082, 1},
		{0x110b0, 0x110b8, 1},
		{0x11100, 0x11102, 1},
		{0x11127, 0x11132, 1},
		{0x11180, 0x11182, 1},
		{0x111b3, 0x111bf, 1},
		{0x1122c, 0x11234, 1},
		{0x11237, 0x11237, 1},
		{0x112df, 0x112e8, 1},
		{0x11300, 0x11303, 1},
		{0x1133e, 0x11344, 1},
		{0x11347, 0x11348, 1},
		{0x1134b, 0x1134c, 1},
		{0x11357, 0x11357, 1},
		{0x11362, 0x11363, 1},
		{0x114b0, 0x114c1, 1},
		{0x115af, 0x115b5, 1},
		{0x115b8, 0x115be, 1},
		{0x115dc, 0x115dd, 1},
		{0x11630, 0x1163e, 1},
		{0x11640, 0x11640, 1},
		{0x116ab, 0x116b5, 1},
		{0x1171d, 0x1172a, 1},
		{0x16b30, 0x16b36, 1},
		{0x16f51, 0x16f7e, 1},
		{0x1bc9e, 0x1bc9e, 1},
		{0x1f130, 0x1f149, 1},
		{0x1f150, 0x1f169, 1},
		{0x1f170, 0x1f189, 1},
	},
}

var _Other_Default_Ignorable_Code_Point = &RangeTable{
	R16: []Range16{
		{0x034f, 0x034f, 1},
		{0x115f, 0x1160, 1},
		{0x17b4, 0x17b5, 1},
		{0x2065, 0x2065, 1},
		{0x3164, 0x3164, 1},
		{0xffa0, 0xffa0, 1},
		{0xfff0, 0xfff8, 1},
	},
	R32: []Range32{
		{0xe0000, 0xe0000, 1},
		{0xe0002, 0xe001f, 1},
		{0xe0080, 0xe00ff, 1},
		{0xe01f0, 0xe0fff, 1},
	},
}

var _Other_Grapheme_Extend = &RangeTable{
	R16: []Range16{
		{0x09be, 0x09be, 1},
		{0x09d7, 0x09d7, 1},
		{0x0b3e, 0x0b3e, 1},
		{0x0b57, 0x0b57, 1},
		{0x0bbe, 0x0bbe, 1},
		{0x0bd7, 0x0bd7, 1},
		{0x0cc2, 0x0cc2, 1},
		{0x0cd5, 0x0cd6, 1},
		{0x0d3e, 0x0d3e, 1},
		{0x0d57, 0x0d57, 1},
		{0x0dcf, 0x0dcf, 1},
		{0x0ddf, 0x0ddf, 1},
		{0x200c, 0x200d, 1},
		{0x302e, 0x302f, 1},
		{0xff9e, 0xff9f, 1},
	},
	R32: []Range32{
		{0x1133e, 0x1133e, 1},
		{0x11357, 0x11357, 1},
		{0x114b0, 0x114b0, 1},
		{0x114bd, 0x114bd, 1},
		{0x115af, 0x115af, 1},
		{0x1d165, 0x1d165, 1},
		{0x1d16e, 0x1d172, 1},
	},
}

var _Other_ID_Continue = &RangeTable{
	R16: []Range16{
		{0x00b7, 0x00b7, 1},
		{0x0387, 0x0387, 1},
		{0x1369, 0x1371, 1},
		{0x19da, 0x19da, 1},
	},
	LatinOffset: 1,
}

var _Other_ID_Start = &RangeTable{
	R16: []Range16{
		{0x2118, 0x2118, 1},
		{0x212e, 0x212e, 1},
		{0x309b, 0x309c, 1},
	},
}

var _Other_Lowercase = &RangeTable{
	R16: []Range16{
		{0x00aa, 0x00aa, 1},
		{0x00ba, 0x00ba, 1},
		{0x02b0, 0x02b8, 1},
		{0x02c0, 0x02c1, 1},
		{0x02e0, 0x02e4, 1},
		{0x0345, 0x0345, 1},
		{0x037a, 0x037a, 1},
		{0x1d2c, 0x1d6a, 1},
		{0x1d78, 0x1d78, 1},
		{0x1d9b, 0x1dbf, 1},
		{0x2071, 0x2071, 1},
		{0x207f, 0x207f, 1},
		{0x2090, 0x209c, 1},
		{0x2170, 0x217f, 1},
		{0x24d0, 0x24e9, 1},
		{0x2c7c, 0x2c7d, 1},
		{0xa69c, 0xa69d, 1},
		{0xa770, 0xa770, 1},
		{0xa7f8, 0xa7f9, 1},
		{0xab5c, 0xab5f, 1},
	},
	LatinOffset: 2,
}

var _Other_Math = &RangeTable{
	R16: []Range16{
		{0x005e, 0x005e, 1},
		{0x03d0, 0x03d2, 1},
		{0x03d5, 0x03d5, 1},
		{0x03f0, 0x03f1, 1},
		{0x03f4, 0x03f5, 1},
		{0x2016, 0x2016, 1},
		{0x2032, 0x2034, 1},
		{0x2040, 0x2040, 1},
		{0x2061, 0x2064, 1},
		{0x207d, 0x207e, 1},
		{0x208d, 0x208e, 1},
		{0x20d0, 0x20dc, 1},
		{0x20e1, 0x20e1, 1},
		{0x20e5, 0x20e6, 1},
		{0x20eb, 0x20ef, 1},
		{0x2102, 0x2102, 1},
		{0x2107, 0x2107, 1},
		{0x210a, 0x2113, 1},
		{0x2115, 0x2115, 1},
		{0x2119, 0x211d, 1},
		{0x2124, 0x2124, 1},
		{0x2128, 0x2129, 1},
		{0x212c, 0x212d, 1},
		{0x212f, 0x2131, 1},
		{0x2133, 0x2138, 1},
		{0x213c, 0x213f, 1},
		{0x2145, 0x2149, 1},
		{0x2195, 0x2199, 1},
		{0x219c, 0x219f, 1},
		{0x21a1, 0x21a2, 1},
		{0x21a4, 0x21a5, 1},
		{0x21a7, 0x21a7, 1},
		{0x21a9, 0x21ad, 1},
		{0x21b0, 0x21b1, 1},
		{0x21b6, 0x21b7, 1},
		{0x21bc, 0x21cd, 1},
		{0x21d0, 0x21d1, 1},
		{0x21d3, 0x21d3, 1},
		{0x21d5, 0x21db, 1},
		{0x21dd, 0x21dd, 1},
		{0x21e4, 0x21e5, 1},
		{0x2308, 0x230b, 1},
		{0x23b4, 0x23b5, 1},
		{0x23b7, 0x23b7, 1},
		{0x23d0, 0x23d0, 1},
		{0x23e2, 0x23e2, 1},
		{0x25a0, 0x25a1, 1},
		{0x25ae, 0x25b6, 1},
		{0x25bc, 0x25c0, 1},
		{0x25c6, 0x25c7, 1},
		{0x25ca, 0x25cb, 1},
		{0x25cf, 0x25d3, 1},
		{0x25e2, 0x25e2, 1},
		{0x25e4, 0x25e4, 1},
		{0x25e7, 0x25ec, 1},
		{0x2605, 0x2606, 1},
		{0x2640, 0x2640, 1},
		{0x2642, 0x2642, 1},
		{0x2660, 0x2663, 1},
		{0x266d, 0x266e, 1},
		{0x27c5, 0x27c6, 1},
		{0x27e6, 0x27ef, 1},
		{0x2983, 0x2998, 1},
		{0x29d8, 0x29db, 1},
		{0x29fc, 0x29fd, 1},
		{0xfe61, 0xfe61, 1},
		{0xfe63, 0xfe63, 1},
		{0xfe68, 0xfe68, 1},
		{0xff3c, 0xff3c, 1},
		{0xff3e, 0xff3e, 1},
	},
	R32: []Range32{
		{0x1d400, 0x1d454, 1},
		{0x1d456, 0x1d49c, 1},
		{0x1d49e, 0x1d49f, 1},
		{0x1d4a2, 0x1d4a2, 1},
		{0x1d4a5, 0x1d4a6, 1},
		{0x1d4a9, 0x1d4ac, 1},
		{0x1d4ae, 0x1d4b9, 1},
		{0x1d4bb, 0x1d4bb, 1},
		{0x1d4bd, 0x1d4c3, 1},
		{0x1d4c5, 0x1d505, 1},
		{0x1d507, 0x1d50a, 1},
		{0x1d50d, 0x1d514, 1},
		{0x1d516, 0x1d51c, 1},
		{0x1d51e, 0x1d539, 1},
		{0x1d53b, 0x1d53e, 1},
		{0x1d540, 0x1d544, 1},
		{0x1d546, 0x1d546, 1},
		{0x1d54a, 0x1d550, 1},
		{0x1d552, 0x1d6a5, 1},
		{0x1d6a8, 0x1d6c0, 1},
		{0x1d6c2, 0x1d6da, 1},
		{0x1d6dc, 0x1d6fa, 1},
		{0x1d6fc, 0x1d714, 1},
		{0x1d716, 0x1d734, 1},
		{0x1d736, 0x1d74e, 1},
		{0x1d750, 0x1d76e, 1},
		{0x1d770, 0x1d788, 1},
		{0x1d78a, 0x1d7a8, 1},
		{0x1d7aa, 0x1d7c2, 1},
		{0x1d7c4, 0x1d7cb, 1},
		{0x1d7ce, 0x1d7ff, 1},
		{0x1ee00, 0x1ee03, 1},
		{0x1ee05, 0x1ee1f, 1},
		{0x1ee21, 0x1ee22, 1},
		{0x1ee24, 0x1ee24, 1},
		{0x1ee27, 0x1ee27, 1},
		{0x1ee29, 0x1ee32, 1},
		{0x1ee34, 0x1ee37, 1},
		{0x1ee39, 0x1ee39, 1},
		{0x1ee3b, 0x1ee3b, 1},
		{0x1ee42, 0x1ee42, 1},
		{0x1ee47, 0x1ee47, 1},
		{0x1ee49, 0x1ee49, 1},
		{0x1ee4b, 0x1ee4b, 1},
		{0x1ee4d, 0x1ee4f, 1},
		{0x1ee51, 0x1ee52, 1},
		{0x1ee54, 0x1ee54, 1},
		{0x1ee57, 0x1ee57, 1},
		{0x1ee59, 0x1ee59, 1},
		{0x1ee5b, 0x1ee5b, 1},
		{0x1ee5d, 0x1ee5d, 1},
		{0x1ee5f, 0x1ee5f, 1},
		{0x1ee61, 0x1ee62, 1},
		{0x1ee64, 0x1ee64, 1},
		{0x1ee67, 0x1ee6a, 1},
		{0x1ee6c, 0x1ee72, 1},
		{0x1ee74, 0x1ee77, 1},
		{0x1ee79, 0x1ee7c, 1},
		{0x1ee7e, 0x1ee7e, 1},
		{0x1ee80, 0x1ee89, 1},
		{0x1ee8b, 0x1ee9b, 1},
		{0x1eea1, 0x1eea3, 1},
		{0x1eea5, 0x1eea9, 1},
		{0x1eeab, 0x1eebb, 1},
	},
	LatinOffset: 1,
}

var _Other_Uppercase = &RangeTable{
	R16: []Range16{
		{0x2160, 0x216f, 1},
		{0x24b6, 0x24cf, 1},
	},
	R32: []Range32{
		{0x1f130, 0x1f149, 1},
		{0x1f150, 0x1f169, 1},
		{0x1f170, 0x1f189, 1},
	},
}

var _Pattern_Syntax = &RangeTable{
	R16: []Range16{
		{0x0021, 0x002f, 1},
		{0x003a, 0x0040, 1},
		{0x005b, 0x005e, 1},
		{0x0060, 0x0060, 1},
		{0x007b, 0x007e, 1},
		{0x00a1, 0x00a7, 1},
		{0x00a9, 0x00a9, 1},
		{0x00ab, 0x00ac, 1},
		{0x00ae, 0x00ae, 1},
		{0x00b0, 0x00b1, 1},
		{0x00b6, 0x00b6, 1},
		{0x00bb, 0x00bb, 1},
		{0x00bf, 0x00bf, 1},
		{0x00d7, 0x00d7, 1},
		{0x00f7, 0x00f7, 1},
		{0x2010, 0x2027, 1},
		{0x2030, 0x203e, 1},
		{0x2041, 0x2053, 1},
		{0x2055, 0x205e, 1},
		{0x2190, 0x245f, 1},
		{0x2500, 0x2775, 1},
		{0x2794, 0x2bff, 1},
		{0x2e00, 0x2e7f, 1},
		{0x3001, 0x3003, 1},
		{0x3008, 0x3020, 1},
		{0x3030, 0x3030, 1},
		{0xfd3e, 0xfd3f, 1},
		{0xfe45, 0xfe46, 1},
	},
	LatinOffset: 15,
}

var _Pattern_White_Space = &RangeTable{
	R16: []Range16{
		{0x0009, 0x000d, 1},
		{0x0020, 0x0020, 1},
		{0x0085, 0x0085, 1},
		{0x200e, 0x200f, 1},
		{0x2028, 0x2029, 1},
	},
	LatinOffset: 3,
}

var _Quotation_Mark = &RangeTable{
	R16: []Range16{
		{0x0022, 0x0022, 1},
		{0x0027, 0x0027, 1},
		{0x00ab, 0x00ab, 1},
		{0x00bb, 0x00bb, 1},
		{0x2018, 0x201f, 1},
		{0x2039, 0x203a, 1},
		{0x2e42, 0x2e42, 1},
		{0x300c, 0x300f, 1},
		{0x301d, 0x301f, 1},
		{0xfe41, 0xfe44, 1},
		{0xff02, 0xff02, 1},
		{0xff07, 0xff07, 1},
		{0xff62, 0xff63, 1},
	},
	LatinOffset: 4,
}

var _Radical = &RangeTable{
	R16: []Range16{
		{0x2e80, 0x2e99, 1},
		{0x2e9b, 0x2ef3, 1},
		{0x2f00, 0x2fd5, 1},
	},
}

var _STerm = &RangeTable{
	R16: []Range16{
		{0x0021, 0x0021, 1},
		{0x002e, 0x002e, 1},
		{0x003f, 0x003f, 1},
		{0x0589, 0x0589, 1},
		{0x061f, 0x061f, 1},
		{0x06d4, 0x06d4, 1},
		{0x0700, 0x0702, 1},
		{0x07f9, 0x07f9, 1},
		{0x0964, 0x0965, 1},
		{0x104a, 0x104b, 1},
		{0x1362, 0x1362, 1},
		{0x1367, 0x1368, 1},
		{0x166e, 0x166e, 1},
		{0x1735, 0x1736, 1},
		{0x1803, 0x1803, 1},
		{0x1809, 0x1809, 1},
		{0x1944, 0x1945, 1},
		{0x1aa8, 0x1aab, 1},
		{0x1b5a, 0x1b5b, 1},
		{0x1b5e, 0x1b5f, 1},
		{0x1c3b, 0x1c3c, 1},
		{0x1c7e, 0x1c7f, 1},
		{0x203c, 0x203d, 1},
		{0x2047, 0x2049, 1},
		{0x2e2e, 0x2e2e, 1},
		{0x2e3c, 0x2e3c, 1},
		{0x3002, 0x3002, 1},
		{0xa4ff, 0xa4ff, 1},
		{0xa60e, 0xa60f, 1},
		{0xa6f3, 0xa6f3, 1},
		{0xa6f7, 0xa6f7, 1},
		{0xa876, 0xa877, 1},
		{0xa8ce, 0xa8cf, 1},
		{0xa92f, 0xa92f, 1},
		{0xa9c8, 0xa9c9, 1},
		{0xaa5d, 0xaa5f, 1},
		{0xaaf0, 0xaaf1, 1},
		{0xabeb, 0xabeb, 1},
		{0xfe52, 0xfe52, 1},
		{0xfe56, 0xfe57, 1},
		{0xff01, 0xff01, 1},
		{0xff0e, 0xff0e, 1},
		{0xff1f, 0xff1f, 1},
		{0xff61, 0xff61, 1},
	},
	R32: []Range32{
		{0x10a56, 0x10a57, 1},
		{0x11047, 0x11048, 1},
		{0x110be, 0x110c1, 1},
		{0x11141, 0x11143, 1},
		{0x111c5, 0x111c6, 1},
		{0x111cd, 0x111cd, 1},
		{0x111de, 0x111df, 1},
		{0x11238, 0x11239, 1},
		{0x1123b, 0x1123c, 1},
		{0x112a9, 0x112a9, 1},
		{0x115c2, 0x115c3, 1},
		{0x115c9, 0x115d7, 1},
		{0x11641, 0x11642, 1},
		{0x1173c, 0x1173e, 1},
		{0x16a6e, 0x16a6f, 1},
		{0x16af5, 0x16af5, 1},
		{0x16b37, 0x16b38, 1},
		{0x16b44, 0x16b44, 1},
		{0x1bc9f, 0x1bc9f, 1},
		{0x1da88, 0x1da88, 1},
	},
	LatinOffset: 3,
}

var _Soft_Dotted = &RangeTable{
	R16: []Range16{
		{0x0069, 0x006a, 1},
		{0x012f, 0x012f, 1},
		{0x0249, 0x0249, 1},
		{0x0268, 0x0268, 1},
		{0x029d, 0x029d, 1},
		{0x02b2, 0x02b2, 1},
		{0x03f3, 0x03f3, 1},
		{0x0456, 0x0456, 1},
		{0x0458, 0x0458, 1},
		{0x1d62, 0x1d62, 1},
		{0x1d96, 0x1d96, 1},
		{0x1da4, 0x1da4, 1},
		{0x1da8, 0x1da8, 1},
		{0x1e2d, 0x1e2d, 1},
		{0x1ecb, 0x1ecb, 1},
		{0x2071, 0x2071, 1},
		{0x2148, 0x2149, 1},
		{0x2c7c, 0x2c7c, 1},
	},
	R32: []Range32{
		{0x1d422, 0x1d423, 1},
		{0x1d456, 0x1d457, 1},
		{0x1d48a, 0x1d48b, 1},
		{0x1d4be, 0x1d4bf, 1},
		{0x1d4f2, 0x1d4f3, 1},
		{0x1d526, 0x1d527, 1},
		{0x1d55a, 0x1d55b, 1},
		{0x1d58e, 0x1d58f, 1},
		{0x1d5c2, 0x1d5c3, 1},
		{0x1d5f6, 0x1d5f7, 1},
		{0x1d62a, 0x1d62b, 1},
		{0x1d65e, 0x1d65f, 1},
		{0x1d692, 0x1d693, 1},
	},
	LatinOffset: 1,
}

var _Terminal_Punctuation = &RangeTable{
	R16: []Range16{
		{0x0021, 0x0021, 1},
		{0x002c, 0x002c, 1},
		{0x002e, 0x002e, 1},
		{0x003a, 0x003b, 1},
		{0x003f, 0x003f, 1},
		{0x037e, 0x037e, 1},
		{0x0387, 0x0387, 1},
		{0x0589, 0x0589, 1},
		{0x05c3, 0x05c3, 1},
		{0x060c, 0x060c, 1},
		{0x061b, 0x061b, 1},
		{0x061f, 0x061f, 1},
		{0x06d4, 0x06d4, 1},
		{0x0700, 0x070a, 1},
		{0x070c, 0x070c, 1},
		{0x07f8, 0x07f9, 1},
		{0x0830, 0x083e, 1},
		{0x085e, 0x085e, 1},
		{0x0964, 0x0965, 1},
		{0x0e5a, 0x0e5b, 1},
		{0x0f08, 0x0f08, 1},
		{0x0f0d, 0x0f12, 1},
		{0x104a, 0x104b, 1},
		{0x1361, 0x1368, 1},
		{0x166d, 0x166e, 1},
		{0x16eb, 0x16ed, 1},
		{0x1735, 0x1736, 1},
		{0x17d4, 0x17d6, 1},
		{0x17da, 0x17da, 1},
		{0x1802, 0x1805, 1},
		{0x1808, 0x1809, 1},
		{0x1944, 0x1945, 1},
		{0x1aa8, 0x1aab, 1},
		{0x1b5a, 0x1b5b, 1},
		{0x1b5d, 0x1b5f, 1},
		{0x1c3b, 0x1c3f, 1},
		{0x1c7e, 0x1c7f, 1},
		{0x203c, 0x203d, 1},
		{0x2047, 0x2049, 1},
		{0x2e2e, 0x2e2e, 1},
		{0x2e3c, 0x2e3c, 1},
		{0x2e41, 0x2e41, 1},
		{0x3001, 0x3002, 1},
		{0xa4fe, 0xa4ff, 1},
		{0xa60d, 0xa60f, 1},
		{0xa6f3, 0xa6f7, 1},
		{0xa876, 0xa877, 1},
		{0xa8ce, 0xa8cf, 1},
		{0xa92f, 0xa92f, 1},
		{0xa9c7, 0xa9c9, 1},
		{0xaa5d, 0xaa5f, 1},
		{0xaadf, 0xaadf, 1},
		{0xaaf0, 0xaaf1, 1},
		{0xabeb, 0xabeb, 1},
		{0xfe50, 0xfe52, 1},
		{0xfe54, 0xfe57, 1},
		{0xff01, 0xff01, 1},
		{0xff0c, 0xff0c, 1},
		{0xff0e, 0xff0e, 1},
		{0xff1a, 0xff1b, 1},
		{0xff1f, 0xff1f, 1},
		{0xff61, 0xff61, 1},
		{0xff64, 0xff64, 1},
	},
	R32: []Range32{
		{0x1039f, 0x1039f, 1},
		{0x103d0, 0x103d0, 1},
		{0x10857, 0x10857, 1},
		{0x1091f, 0x1091f, 1},
		{0x10a56, 0x10a57, 1},
		{0x10af0, 0x10af5, 1},
		{0x10b3a, 0x10b3f, 1},
		{0x10b99, 0x10b9c, 1},
		{0x11047, 0x1104d, 1},
		{0x110be, 0x110c1, 1},
		{0x11141, 0x11143, 1},
		{0x111c5, 0x111c6, 1},
		{0x111cd, 0x111cd, 1},
		{0x111de, 0x111df, 1},
		{0x11238, 0x1123c, 1},
		{0x112a9, 0x112a9, 1},
		{0x115c2, 0x115c5, 1},
		{0x115c9, 0x115d7, 1},
		{0x11641, 0x11642, 1},
		{0x1173c, 0x1173e, 1},
		{0x12470, 0x12474, 1},
		{0x16a6e, 0x16a6f, 1},
		{0x16af5, 0x16af5, 1},
		{0x16b37, 0x16b39, 1},
		{0x16b44, 0x16b44, 1},
		{0x1bc9f, 0x1bc9f, 1},
		{0x1da87, 0x1da8a, 1},
	},
	LatinOffset: 5,
}

var _Unified_Ideograph = &RangeTable{
	R16: []Range16{
		{0x3400, 0x4db5, 1},
		{0x4e00, 0x9fd5, 1},
		{0xfa0e, 0xfa0f, 1},
		{0xfa11, 0xfa11, 1},
		{0xfa13, 0xfa14, 1},
		{0xfa1f, 0xfa1f, 1},
		{0xfa21, 0xfa21, 1},
		{0xfa23, 0xfa24, 1},
		{0xfa27, 0xfa29, 1},
	},
	R32: []Range32{
		{0x20000, 0x2a6d6, 1},
		{0x2a700, 0x2b734, 1},
		{0x2b740, 0x2b81d, 1},
		{0x2b820, 0x2cea1, 1},
	},
}

var _Variation_Selector = &RangeTable{
	R16: []Range16{
		{0x180b, 0x180d, 1},
		{0xfe00, 0xfe0f, 1},
	},
	R32: []Range32{
		{0xe0100, 0xe01ef, 1},
	},
}

var _White_Space = &RangeTable{
	R16: []Range16{
		{0x0009, 0x000d, 1},
		{0x0020, 0x0020, 1},
		{0x0085, 0x0085, 1},
		{0x00a0, 0x00a0, 1},
		{0x1680, 0x1680, 1},
		{0x2000, 0x200a, 1},
		{0x2028, 0x2029, 1},
		{0x202f, 0x202f, 1},
		{0x205f, 0x205f, 1},
		{0x3000, 0x3000, 1},
	},
	LatinOffset: 4,
}

// These variables have type *RangeTable.
var (
	ASCII_Hex_Digit                    = _ASCII_Hex_Digit                    // ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.
	Bidi_Control                       = _Bidi_Control                       // Bidi_Control is the set of Unicode characters with property Bidi_Control.
	Dash                               = _Dash                               // Dash is the set of Unicode characters with property Dash.
	Deprecated                         = _Deprecated                         // Deprecated is the set of Unicode characters with property Deprecated.
	Diacritic                          = _Diacritic                          // Diacritic is the set of Unicode characters with property Diacritic.
	Extender                           = _Extender                           // Extender is the set of Unicode characters with property Extender.
	Hex_Digit                          = _Hex_Digit                          // Hex_Digit is the set of Unicode characters with property Hex_Digit.
	Hyphen                             = _Hyphen                             // Hyphen is the set of Unicode characters with property Hyphen.
	IDS_Binary_Operator                = _IDS_Binary_Operator                // IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.
	IDS_Trinary_Operator               = _IDS_Trinary_Operator               // IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.
	Ideographic                        = _Ideographic                        // Ideographic is the set of Unicode characters with property Ideographic.
	Join_Control                       = _Join_Control                       // Join_Control is the set of Unicode characters with property Join_Control.
	Logical_Order_Exception            = _Logical_Order_Exception            // Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.
	Noncharacter_Code_Point            = _Noncharacter_Code_Point            // Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.
	Other_Alphabetic                   = _Other_Alphabetic                   // Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.
	Other_Default_Ignorable_Code_Point = _Other_Default_Ignorable_Code_Point // Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.
	Other_Grapheme_Extend              = _Other_Grapheme_Extend              // Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.
	Other_ID_Continue                  = _Other_ID_Continue                  // Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.
	Other_ID_Start                     = _Other_ID_Start                     // Other_ID_Start is the set of Unicode characters with property Other_ID_Start.
	Other_Lowercase                    = _Other_Lowercase                    // Other_Lowercase is the set of Unicode characters with property Other_Lowercase.
	Other_Math                         = _Other_Math                         // Other_Math is the set of Unicode characters with property Other_Math.
	Other_Uppercase                    = _Other_Uppercase                    // Other_Uppercase is the set of Unicode characters with property Other_Uppercase.
	Pattern_Syntax                     = _Pattern_Syntax                     // Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.
	Pattern_White_Space                = _Pattern_White_Space                // Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.
	Quotation_Mark                     = _Quotation_Mark                     // Quotation_Mark is the set of Unicode characters with property Quotation_Mark.
	Radical                            = _Radical                            // Radical is the set of Unicode characters with property Radical.
	STerm                              = _STerm                              // STerm is the set of Unicode characters with property STerm.
	Soft_Dotted                        = _Soft_Dotted                        // Soft_Dotted is the set of Unicode characters with property Soft_Dotted.
	Terminal_Punctuation               = _Terminal_Punctuation               // Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.
	Unified_Ideograph                  = _Unified_Ideograph                  // Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.
	Variation_Selector                 = _Variation_Selector                 // Variation_Selector is the set of Unicode characters with property Variation_Selector.
	White_Space                        = _White_Space                        // White_Space is the set of Unicode characters with property White_Space.
)

// Generated by running
//	maketables --data=http://www.unicode.org/Public/8.0.0/ucd/UnicodeData.txt --casefolding=http://www.unicode.org/Public/8.0.0/ucd/CaseFolding.txt
// DO NOT EDIT

// CaseRanges is the table describing case mappings for all letters with
// non-self mappings.
var CaseRanges = _CaseRanges
var _CaseRanges = []CaseRange{
	{0x0041, 0x005A, d{0, 32, 0}},
	{0x0061, 0x007A, d{-32, 0, -32}},
	{0x00B5, 0x00B5, d{743, 0, 743}},
	{0x00C0, 0x00D6, d{0, 32, 0}},
	{0x00D8, 0x00DE, d{0, 32, 0}},
	{0x00E0, 0x00F6, d{-32, 0, -32}},
	{0x00F8, 0x00FE, d{-32, 0, -32}},
	{0x00FF, 0x00FF, d{121, 0, 121}},
	{0x0100, 0x012F, d{UpperLower, UpperLower, UpperLower}},
	{0x0130, 0x0130, d{0, -199, 0}},
	{0x0131, 0x0131, d{-232, 0, -232}},
	{0x0132, 0x0137, d{UpperLower, UpperLower, UpperLower}},
	{0x0139, 0x0148, d{UpperLower, UpperLower, UpperLower}},
	{0x014A, 0x0177, d{UpperLower, UpperLower, UpperLower}},
	{0x0178, 0x0178, d{0, -121, 0}},
	{0x0179, 0x017E, d{UpperLower, UpperLower, UpperLower}},
	{0x017F, 0x017F, d{-300, 0, -300}},
	{0x0180, 0x0180, d{195, 0, 195}},
	{0x0181, 0x0181, d{0, 210, 0}},
	{0x0182, 0x0185, d{UpperLower, UpperLower, UpperLower}},
	{0x0186, 0x0186, d{0, 206, 0}},
	{0x0187, 0x0188, d{UpperLower, UpperLower, UpperLower}},
	{0x0189, 0x018A, d{0, 205, 0}},
	{0x018B, 0x018C, d{UpperLower, UpperLower, UpperLower}},
	{0x018E, 0x018E, d{0, 79, 0}},
	{0x018F, 0x018F, d{0, 202, 0}},
	{0x0190, 0x0190, d{0, 203, 0}},
	{0x0191, 0x0192, d{UpperLower, UpperLower, UpperLower}},
	{0x0193, 0x0193, d{0, 205, 0}},
	{0x0194, 0x0194, d{0, 207, 0}},
	{0x0195, 0x0195, d{97, 0, 97}},
	{0x0196, 0x0196, d{0, 211, 0}},
	{0x0197, 0x0197, d{0, 209, 0}},
	{0x0198, 0x0199, d{UpperLower, UpperLower, UpperLower}},
	{0x019A, 0x019A, d{163, 0, 163}},
	{0x019C, 0x019C, d{0, 211, 0}},
	{0x019D, 0x019D, d{0, 213, 0}},
	{0x019E, 0x019E, d{130, 0, 130}},
	{0x019F, 0x019F, d{0, 214, 0}},
	{0x01A0, 0x01A5, d{UpperLower, UpperLower, UpperLower}},
	{0x01A6, 0x01A6, d{0, 218, 0}},
	{0x01A7, 0x01A8, d{UpperLower, UpperLower, UpperLower}},
	{0x01A9, 0x01A9, d{0, 218, 0}},
	{0x01AC, 0x01AD, d{UpperLower, UpperLower, UpperLower}},
	{0x01AE, 0x01AE, d{0, 218, 0}},
	{0x01AF, 0x01B0, d{UpperLower, UpperLower, UpperLower}},
	{0x01B1, 0x01B2, d{0, 217, 0}},
	{0x01B3, 0x01B6, d{UpperLower, UpperLower, UpperLower}},
	{0x01B7, 0x01B7, d{0, 219, 0}},
	{0x01B8, 0x01B9, d{UpperLower, UpperLower, UpperLower}},
	{0x01BC, 0x01BD, d{UpperLower, UpperLower, UpperLower}},
	{0x01BF, 0x01BF, d{56, 0, 56}},
	{0x01C4, 0x01C4, d{0, 2, 1}},
	{0x01C5, 0x01C5, d{-1, 1, 0}},
	{0x01C6, 0x01C6, d{-2, 0, -1}},
	{0x01C7, 0x01C7, d{0, 2, 1}},
	{0x01C8, 0x01C8, d{-1, 1, 0}},
	{0x01C9, 0x01C9, d{-2, 0, -1}},
	{0x01CA, 0x01CA, d{0, 2, 1}},
	{0x01CB, 0x01CB, d{-1, 1, 0}},
	{0x01CC, 0x01CC, d{-2, 0, -1}},
	{0x01CD, 0x01DC, d{UpperLower, UpperLower, UpperLower}},
	{0x01DD, 0x01DD, d{-79, 0, -79}},
	{0x01DE, 0x01EF, d{UpperLower, UpperLower, UpperLower}},
	{0x01F1, 0x01F1, d{0, 2, 1}},
	{0x01F2, 0x01F2, d{-1, 1, 0}},
	{0x01F3, 0x01F3, d{-2, 0, -1}},
	{0x01F4, 0x01F5, d{UpperLower, UpperLower, UpperLower}},
	{0x01F6, 0x01F6, d{0, -97, 0}},
	{0x01F7, 0x01F7, d{0, -56, 0}},
	{0x01F8, 0x021F, d{UpperLower, UpperLower, UpperLower}},
	{0x0220, 0x0220, d{0, -130, 0}},
	{0x0222, 0x0233, d{UpperLower, UpperLower, UpperLower}},
	{0x023A, 0x023A, d{0, 10795, 0}},
	{0x023B, 0x023C, d{UpperLower, UpperLower, UpperLower}},
	{0x023D, 0x023D, d{0, -163, 0}},
	{0x023E, 0x023E, d{0, 10792, 0}},
	{0x023F, 0x0240, d{10815, 0, 10815}},
	{0x0241, 0x0242, d{UpperLower, UpperLower, UpperLower}},
	{0x0243, 0x0243, d{0, -195, 0}},
	{0x0244, 0x0244, d{0, 69, 0}},
	{0x0245, 0x0245, d{0, 71, 0}},
	{0x0246, 0x024F, d{UpperLower, UpperLower, UpperLower}},
	{0x0250, 0x0250, d{10783, 0, 10783}},
	{0x0251, 0x0251, d{10780, 0, 10780}},
	{0x0252, 0x0252, d{10782, 0, 10782}},
	{0x0253, 0x0253, d{-210, 0, -210}},
	{0x0254, 0x0254, d{-206, 0, -206}},
	{0x0256, 0x0257, d{-205, 0, -205}},
	{0x0259, 0x0259, d{-202, 0, -202}},
	{0x025B, 0x025B, d{-203, 0, -203}},
	{0x025C, 0x025C, d{42319, 0, 42319}},
	{0x0260, 0x0260, d{-205, 0, -205}},
	{0x0261, 0x0261, d{42315, 0, 42315}},
	{0x0263, 0x0263, d{-207, 0, -207}},
	{0x0265, 0x0265, d{42280, 0, 42280}},
	{0x0266, 0x0266, d{42308, 0, 42308}},
	{0x0268, 0x0268, d{-209, 0, -209}},
	{0x0269, 0x0269, d{-211, 0, -211}},
	{0x026B, 0x026B, d{10743, 0, 10743}},
	{0x026C, 0x026C, d{42305, 0, 42305}},
	{0x026F, 0x026F, d{-211, 0, -211}},
	{0x0271, 0x0271, d{10749, 0, 10749}},
	{0x0272, 0x0272, d{-213, 0, -213}},
	{0x0275, 0x0275, d{-214, 0, -214}},
	{0x027D, 0x027D, d{10727, 0, 10727}},
	{0x0280, 0x0280, d{-218, 0, -218}},
	{0x0283, 0x0283, d{-218, 0, -218}},
	{0x0287, 0x0287, d{42282, 0, 42282}},
	{0x0288, 0x0288, d{-218, 0, -218}},
	{0x0289, 0x0289, d{-69, 0, -69}},
	{0x028A, 0x028B, d{-217, 0, -217}},
	{0x028C, 0x028C, d{-71, 0, -71}},
	{0x0292, 0x0292, d{-219, 0, -219}},
	{0x029D, 0x029D, d{42261, 0, 42261}},
	{0x029E, 0x029E, d{42258, 0, 42258}},
	{0x0345, 0x0345, d{84, 0, 84}},
	{0x0370, 0x0373, d{UpperLower, UpperLower, UpperLower}},
	{0x0376, 0x0377, d{UpperLower, UpperLower, UpperLower}},
	{0x037B, 0x037D, d{130, 0, 130}},
	{0x037F, 0x037F, d{0, 116, 0}},
	{0x0386, 0x0386, d{0, 38, 0}},
	{0x0388, 0x038A, d{0, 37, 0}},
	{0x038C, 0x038C, d{0, 64, 0}},
	{0x038E, 0x038F, d{0, 63, 0}},
	{0x0391, 0x03A1, d{0, 32, 0}},
	{0x03A3, 0x03AB, d{0, 32, 0}},
	{0x03AC, 0x03AC, d{-38, 0, -38}},
	{0x03AD, 0x03AF, d{-37, 0, -37}},
	{0x03B1, 0x03C1, d{-32, 0, -32}},
	{0x03C2, 0x03C2, d{-31, 0, -31}},
	{0x03C3, 0x03CB, d{-32, 0, -32}},
	{0x03CC, 0x03CC, d{-64, 0, -64}},
	{0x03CD, 0x03CE, d{-63, 0, -63}},
	{0x03CF, 0x03CF, d{0, 8, 0}},
	{0x03D0, 0x03D0, d{-62, 0, -62}},
	{0x03D1, 0x03D1, d{-57, 0, -57}},
	{0x03D5, 0x03D5, d{-47, 0, -47}},
	{0x03D6, 0x03D6, d{-54, 0, -54}},
	{0x03D7, 0x03D7, d{-8, 0, -8}},
	{0x03D8, 0x03EF, d{UpperLower, UpperLower, UpperLower}},
	{0x03F0, 0x03F0, d{-86, 0, -86}},
	{0x03F1, 0x03F1, d{-80, 0, -80}},
	{0x03F2, 0x03F2, d{7, 0, 7}},
	{0x03F3, 0x03F3, d{-116, 0, -116}},
	{0x03F4, 0x03F4, d{0, -60, 0}},
	{0x03F5, 0x03F5, d{-96, 0, -96}},
	{0x03F7, 0x03F8, d{UpperLower, UpperLower, UpperLower}},
	{0x03F9, 0x03F9, d{0, -7, 0}},
	{0x03FA, 0x03FB, d{UpperLower, UpperLower, UpperLower}},
	{0x03FD, 0x03FF, d{0, -130, 0}},
	{0x0400, 0x040F, d{0, 80, 0}},
	{0x0410, 0x042F, d{0, 32, 0}},
	{0x0430, 0x044F, d{-32, 0, -32}},
	{0x0450, 0x045F, d{-80, 0, -80}},
	{0x0460, 0x0481, d{UpperLower, UpperLower, UpperLower}},
	{0x048A, 0x04BF, d{UpperLower, UpperLower, UpperLower}},
	{0x04C0, 0x04C0, d{0, 15, 0}},
	{0x04C1, 0x04CE, d{UpperLower, UpperLower, UpperLower}},
	{0x04CF, 0x04CF, d{-15, 0, -15}},
	{0x04D0, 0x052F, d{UpperLower, UpperLower, UpperLower}},
	{0x0531, 0x0556, d{0, 48, 0}},
	{0x0561, 0x0586, d{-48, 0, -48}},
	{0x10A0, 0x10C5, d{0, 7264, 0}},
	{0x10C7, 0x10C7, d{0, 7264, 0}},
	{0x10CD, 0x10CD, d{0, 7264, 0}},
	{0x13A0, 0x13EF, d{0, 38864, 0}},
	{0x13F0, 0x13F5, d{0, 8, 0}},
	{0x13F8, 0x13FD, d{-8, 0, -8}},
	{0x1D79, 0x1D79, d{35332, 0, 35332}},
	{0x1D7D, 0x1D7D, d{3814, 0, 3814}},
	{0x1E00, 0x1E95, d{UpperLower, UpperLower, UpperLower}},
	{0x1E9B, 0x1E9B, d{-59, 0, -59}},
	{0x1E9E, 0x1E9E, d{0, -7615, 0}},
	{0x1EA0, 0x1EFF, d{UpperLower, UpperLower, UpperLower}},
	{0x1F00, 0x1F07, d{8, 0, 8}},
	{0x1F08, 0x1F0F, d{0, -8, 0}},
	{0x1F10, 0x1F15, d{8, 0, 8}},
	{0x1F18, 0x1F1D, d{0, -8, 0}},
	{0x1F20, 0x1F27, d{8, 0, 8}},
	{0x1F28, 0x1F2F, d{0, -8, 0}},
	{0x1F30, 0x1F37, d{8, 0, 8}},
	{0x1F38, 0x1F3F, d{0, -8, 0}},
	{0x1F40, 0x1F45, d{8, 0, 8}},
	{0x1F48, 0x1F4D, d{0, -8, 0}},
	{0x1F51, 0x1F51, d{8, 0, 8}},
	{0x1F53, 0x1F53, d{8, 0, 8}},
	{0x1F55, 0x1F55, d{8, 0, 8}},
	{0x1F57, 0x1F57, d{8, 0, 8}},
	{0x1F59, 0x1F59, d{0, -8, 0}},
	{0x1F5B, 0x1F5B, d{0, -8, 0}},
	{0x1F5D, 0x1F5D, d{0, -8, 0}},
	{0x1F5F, 0x1F5F, d{0, -8, 0}},
	{0x1F60, 0x1F67, d{8, 0, 8}},
	{0x1F68, 0x1F6F, d{0, -8, 0}},
	{0x1F70, 0x1F71, d{74, 0, 74}},
	{0x1F72, 0x1F75, d{86, 0, 86}},
	{0x1F76, 0x1F77, d{100, 0, 100}},
	{0x1F78, 0x1F79, d{128, 0, 128}},
	{0x1F7A, 0x1F7B, d{112, 0, 112}},
	{0x1F7C, 0x1F7D, d{126, 0, 126}},
	{0x1F80, 0x1F87, d{8, 0, 8}},
	{0x1F88, 0x1F8F, d{0, -8, 0}},
	{0x1F90, 0x1F97, d{8, 0, 8}},
	{0x1F98, 0x1F9F, d{0, -8, 0}},
	{0x1FA0, 0x1FA7, d{8, 0, 8}},
	{0x1FA8, 0x1FAF, d{0, -8, 0}},
	{0x1FB0, 0x1FB1, d{8, 0, 8}},
	{0x1FB3, 0x1FB3, d{9, 0, 9}},
	{0x1FB8, 0x1FB9, d{0, -8, 0}},
	{0x1FBA, 0x1FBB, d{0, -74, 0}},
	{0x1FBC, 0x1FBC, d{0, -9, 0}},
	{0x1FBE, 0x1FBE, d{-7205, 0, -7205}},
	{0x1FC3, 0x1FC3, d{9, 0, 9}},
	{0x1FC8, 0x1FCB, d{0, -86, 0}},
	{0x1FCC, 0x1FCC, d{0, -9, 0}},
	{0x1FD0, 0x1FD1, d{8, 0, 8}},
	{0x1FD8, 0x1FD9, d{0, -8, 0}},
	{0x1FDA, 0x1FDB, d{0, -100, 0}},
	{0x1FE0, 0x1FE1, d{8, 0, 8}},
	{0x1FE5, 0x1FE5, d{7, 0, 7}},
	{0x1FE8, 0x1FE9, d{0, -8, 0}},
	{0x1FEA, 0x1FEB, d{0, -112, 0}},
	{0x1FEC, 0x1FEC, d{0, -7, 0}},
	{0x1FF3, 0x1FF3, d{9, 0, 9}},
	{0x1FF8, 0x1FF9, d{0, -128, 0}},
	{0x1FFA, 0x1FFB, d{0, -126, 0}},
	{0x1FFC, 0x1FFC, d{0, -9, 0}},
	{0x2126, 0x2126, d{0, -7517, 0}},
	{0x212A, 0x212A, d{0, -8383, 0}},
	{0x212B, 0x212B, d{0, -8262, 0}},
	{0x2132, 0x2132, d{0, 28, 0}},
	{0x214E, 0x214E, d{-28, 0, -28}},
	{0x2160, 0x216F, d{0, 16, 0}},
	{0x2170, 0x217F, d{-16, 0, -16}},
	{0x2183, 0x2184, d{UpperLower, UpperLower, UpperLower}},
	{0x24B6, 0x24CF, d{0, 26, 0}},
	{0x24D0, 0x24E9, d{-26, 0, -26}},
	{0x2C00, 0x2C2E, d{0, 48, 0}},
	{0x2C30, 0x2C5E, d{-48, 0, -48}},
	{0x2C60, 0x2C61, d{UpperLower, UpperLower, UpperLower}},
	{0x2C62, 0x2C62, d{0, -10743, 0}},
	{0x2C63, 0x2C63, d{0, -3814, 0}},
	{0x2C64, 0x2C64, d{0, -10727, 0}},
	{0x2C65, 0x2C65, d{-10795, 0, -10795}},
	{0x2C66, 0x2C66, d{-10792, 0, -10792}},
	{0x2C67, 0x2C6C, d{UpperLower, UpperLower, UpperLower}},
	{0x2C6D, 0x2C6D, d{0, -10780, 0}},
	{0x2C6E, 0x2C6E, d{0, -10749, 0}},
	{0x2C6F, 0x2C6F, d{0, -10783, 0}},
	{0x2C70, 0x2C70, d{0, -10782, 0}},
	{0x2C72, 0x2C73, d{UpperLower, UpperLower, UpperLower}},
	{0x2C75, 0x2C76, d{UpperLower, UpperLower, UpperLower}},
	{0x2C7E, 0x2C7F, d{0, -10815, 0}},
	{0x2C80, 0x2CE3, d{UpperLower, UpperLower, UpperLower}},
	{0x2CEB, 0x2CEE, d{UpperLower, UpperLower, UpperLower}},
	{0x2CF2, 0x2CF3, d{UpperLower, UpperLower, UpperLower}},
	{0x2D00, 0x2D25, d{-7264, 0, -7264}},
	{0x2D27, 0x2D27, d{-7264, 0, -7264}},
	{0x2D2D, 0x2D2D, d{-7264, 0, -7264}},
	{0xA640, 0xA66D, d{UpperLower, UpperLower, UpperLower}},
	{0xA680, 0xA69B, d{UpperLower, UpperLower, UpperLower}},
	{0xA722, 0xA72F, d{UpperLower, UpperLower, UpperLower}},
	{0xA732, 0xA76F, d{UpperLower, UpperLower, UpperLower}},
	{0xA779, 0xA77C, d{UpperLower, UpperLower, UpperLower}},
	{0xA77D, 0xA77D, d{0, -35332, 0}},
	{0xA77E, 0xA787, d{UpperLower, UpperLower, UpperLower}},
	{0xA78B, 0xA78C, d{UpperLower, UpperLower, UpperLower}},
	{0xA78D, 0xA78D, d{0, -42280, 0}},
	{0xA790, 0xA793, d{UpperLower, UpperLower, UpperLower}},
	{0xA796, 0xA7A9, d{UpperLower, UpperLower, UpperLower}},
	{0xA7AA, 0xA7AA, d{0, -42308, 0}},
	{0xA7AB, 0xA7AB, d{0, -42319, 0}},
	{0xA7AC, 0xA7AC, d{0, -42315, 0}},
	{0xA7AD, 0xA7AD, d{0, -42305, 0}},
	{0xA7B0, 0xA7B0, d{0, -42258, 0}},
	{0xA7B1, 0xA7B1, d{0, -42282, 0}},
	{0xA7B2, 0xA7B2, d{0, -42261, 0}},
	{0xA7B3, 0xA7B3, d{0, 928, 0}},
	{0xA7B4, 0xA7B7, d{UpperLower, UpperLower, UpperLower}},
	{0xAB53, 0xAB53, d{-928, 0, -928}},
	{0xAB70, 0xABBF, d{-38864, 0, -38864}},
	{0xFF21, 0xFF3A, d{0, 32, 0}},
	{0xFF41, 0xFF5A, d{-32, 0, -32}},
	{0x10400, 0x10427, d{0, 40, 0}},
	{0x10428, 0x1044F, d{-40, 0, -40}},
	{0x10C80, 0x10CB2, d{0, 64, 0}},
	{0x10CC0, 0x10CF2, d{-64, 0, -64}},
	{0x118A0, 0x118BF, d{0, 32, 0}},
	{0x118C0, 0x118DF, d{-32, 0, -32}},
}
var properties = [MaxLatin1 + 1]uint8{
	0x00: pC,       // '\x00'
	0x01: pC,       // '\x01'
	0x02: pC,       // '\x02'
	0x03: pC,       // '\x03'
	0x04: pC,       // '\x04'
	0x05: pC,       // '\x05'
	0x06: pC,       // '\x06'
	0x07: pC,       // '\a'
	0x08: pC,       // '\b'
	0x09: pC,       // '\t'
	0x0A: pC,       // '\n'
	0x0B: pC,       // '\v'
	0x0C: pC,       // '\f'
	0x0D: pC,       // '\r'
	0x0E: pC,       // '\x0e'
	0x0F: pC,       // '\x0f'
	0x10: pC,       // '\x10'
	0x11: pC,       // '\x11'
	0x12: pC,       // '\x12'
	0x13: pC,       // '\x13'
	0x14: pC,       // '\x14'
	0x15: pC,       // '\x15'
	0x16: pC,       // '\x16'
	0x17: pC,       // '\x17'
	0x18: pC,       // '\x18'
	0x19: pC,       // '\x19'
	0x1A: pC,       // '\x1a'
	0x1B: pC,       // '\x1b'
	0x1C: pC,       // '\x1c'
	0x1D: pC,       // '\x1d'
	0x1E: pC,       // '\x1e'
	0x1F: pC,       // '\x1f'
	0x20: pZ | pp,  // ' '
	0x21: pP | pp,  // '!'
	0x22: pP | pp,  // '"'
	0x23: pP | pp,  // '#'
	0x24: pS | pp,  // '$'
	0x25: pP | pp,  // '%'
	0x26: pP | pp,  // '&'
	0x27: pP | pp,  // '\''
	0x28: pP | pp,  // '('
	0x29: pP | pp,  // ')'
	0x2A: pP | pp,  // '*'
	0x2B: pS | pp,  // '+'
	0x2C: pP | pp,  // ','
	0x2D: pP | pp,  // '-'
	0x2E: pP | pp,  // '.'
	0x2F: pP | pp,  // '/'
	0x30: pN | pp,  // '0'
	0x31: pN | pp,  // '1'
	0x32: pN | pp,  // '2'
	0x33: pN | pp,  // '3'
	0x34: pN | pp,  // '4'
	0x35: pN | pp,  // '5'
	0x36: pN | pp,  // '6'
	0x37: pN | pp,  // '7'
	0x38: pN | pp,  // '8'
	0x39: pN | pp,  // '9'
	0x3A: pP | pp,  // ':'
	0x3B: pP | pp,  // ';'
	0x3C: pS | pp,  // '<'
	0x3D: pS | pp,  // '='
	0x3E: pS | pp,  // '>'
	0x3F: pP | pp,  // '?'
	0x40: pP | pp,  // '@'
	0x41: pLu | pp, // 'A'
	0x42: pLu | pp, // 'B'
	0x43: pLu | pp, // 'C'
	0x44: pLu | pp, // 'D'
	0x45: pLu | pp, // 'E'
	0x46: pLu | pp, // 'F'
	0x47: pLu | pp, // 'G'
	0x48: pLu | pp, // 'H'
	0x49: pLu | pp, // 'I'
	0x4A: pLu | pp, // 'J'
	0x4B: pLu | pp, // 'K'
	0x4C: pLu | pp, // 'L'
	0x4D: pLu | pp, // 'M'
	0x4E: pLu | pp, // 'N'
	0x4F: pLu | pp, // 'O'
	0x50: pLu | pp, // 'P'
	0x51: pLu | pp, // 'Q'
	0x52: pLu | pp, // 'R'
	0x53: pLu | pp, // 'S'
	0x54: pLu | pp, // 'T'
	0x55: pLu | pp, // 'U'
	0x56: pLu | pp, // 'V'
	0x57: pLu | pp, // 'W'
	0x58: pLu | pp, // 'X'
	0x59: pLu | pp, // 'Y'
	0x5A: pLu | pp, // 'Z'
	0x5B: pP | pp,  // '['
	0x5C: pP | pp,  // '\\'
	0x5D: pP | pp,  // ']'
	0x5E: pS | pp,  // '^'
	0x5F: pP | pp,  // '_'
	0x60: pS | pp,  // '`'
	0x61: pLl | pp, // 'a'
	0x62: pLl | pp, // 'b'
	0x63: pLl | pp, // 'c'
	0x64: pLl | pp, // 'd'
	0x65: pLl | pp, // 'e'
	0x66: pLl | pp, // 'f'
	0x67: pLl | pp, // 'g'
	0x68: pLl | pp, // 'h'
	0x69: pLl | pp, // 'i'
	0x6A: pLl | pp, // 'j'
	0x6B: pLl | pp, // 'k'
	0x6C: pLl | pp, // 'l'
	0x6D: pLl | pp, // 'm'
	0x6E: pLl | pp, // 'n'
	0x6F: pLl | pp, // 'o'
	0x70: pLl | pp, // 'p'
	0x71: pLl | pp, // 'q'
	0x72: pLl | pp, // 'r'
	0x73: pLl | pp, // 's'
	0x74: pLl | pp, // 't'
	0x75: pLl | pp, // 'u'
	0x76: pLl | pp, // 'v'
	0x77: pLl | pp, // 'w'
	0x78: pLl | pp, // 'x'
	0x79: pLl | pp, // 'y'
	0x7A: pLl | pp, // 'z'
	0x7B: pP | pp,  // '{'
	0x7C: pS | pp,  // '|'
	0x7D: pP | pp,  // '}'
	0x7E: pS | pp,  // '~'
	0x7F: pC,       // '\u007f'
	0x80: pC,       // '\u0080'
	0x81: pC,       // '\u0081'
	0x82: pC,       // '\u0082'
	0x83: pC,       // '\u0083'
	0x84: pC,       // '\u0084'
	0x85: pC,       // '\u0085'
	0x86: pC,       // '\u0086'
	0x87: pC,       // '\u0087'
	0x88: pC,       // '\u0088'
	0x89: pC,       // '\u0089'
	0x8A: pC,       // '\u008a'
	0x8B: pC,       // '\u008b'
	0x8C: pC,       // '\u008c'
	0x8D: pC,       // '\u008d'
	0x8E: pC,       // '\u008e'
	0x8F: pC,       // '\u008f'
	0x90: pC,       // '\u0090'
	0x91: pC,       // '\u0091'
	0x92: pC,       // '\u0092'
	0x93: pC,       // '\u0093'
	0x94: pC,       // '\u0094'
	0x95: pC,       // '\u0095'
	0x96: pC,       // '\u0096'
	0x97: pC,       // '\u0097'
	0x98: pC,       // '\u0098'
	0x99: pC,       // '\u0099'
	0x9A: pC,       // '\u009a'
	0x9B: pC,       // '\u009b'
	0x9C: pC,       // '\u009c'
	0x9D: pC,       // '\u009d'
	0x9E: pC,       // '\u009e'
	0x9F: pC,       // '\u009f'
	0xA0: pZ,       // '\u00a0'
	0xA1: pP | pp,  // '¡'
	0xA2: pS | pp,  // '¢'
	0xA3: pS | pp,  // '£'
	0xA4: pS | pp,  // '¤'
	0xA5: pS | pp,  // '¥'
	0xA6: pS | pp,  // '¦'
	0xA7: pP | pp,  // '§'
	0xA8: pS | pp,  // '¨'
	0xA9: pS | pp,  // '©'
	0xAA: pLo | pp, // 'ª'
	0xAB: pP | pp,  // '«'
	0xAC: pS | pp,  // '¬'
	0xAD: 0,        // '\u00ad'
	0xAE: pS | pp,  // '®'
	0xAF: pS | pp,  // '¯'
	0xB0: pS | pp,  // '°'
	0xB1: pS | pp,  // '±'
	0xB2: pN | pp,  // '²'
	0xB3: pN | pp,  // '³'
	0xB4: pS | pp,  // '´'
	0xB5: pLl | pp, // 'µ'
	0xB6: pP | pp,  // '¶'
	0xB7: pP | pp,  // '·'
	0xB8: pS | pp,  // '¸'
	0xB9: pN | pp,  // '¹'
	0xBA: pLo | pp, // 'º'
	0xBB: pP | pp,  // '»'
	0xBC: pN | pp,  // '¼'
	0xBD: pN | pp,  // '½'
	0xBE: pN | pp,  // '¾'
	0xBF: pP | pp,  // '¿'
	0xC0: pLu | pp, // 'À'
	0xC1: pLu | pp, // 'Á'
	0xC2: pLu | pp, // 'Â'
	0xC3: pLu | pp, // 'Ã'
	0xC4: pLu | pp, // 'Ä'
	0xC5: pLu | pp, // 'Å'
	0xC6: pLu | pp, // 'Æ'
	0xC7: pLu | pp, // 'Ç'
	0xC8: pLu | pp, // 'È'
	0xC9: pLu | pp, // 'É'
	0xCA: pLu | pp, // 'Ê'
	0xCB: pLu | pp, // 'Ë'
	0xCC: pLu | pp, // 'Ì'
	0xCD: pLu | pp, // 'Í'
	0xCE: pLu | pp, // 'Î'
	0xCF: pLu | pp, // 'Ï'
	0xD0: pLu | pp, // 'Ð'
	0xD1: pLu | pp, // 'Ñ'
	0xD2: pLu | pp, // 'Ò'
	0xD3: pLu | pp, // 'Ó'
	0xD4: pLu | pp, // 'Ô'
	0xD5: pLu | pp, // 'Õ'
	0xD6: pLu | pp, // 'Ö'
	0xD7: pS | pp,  // '×'
	0xD8: pLu | pp, // 'Ø'
	0xD9: pLu | pp, // 'Ù'
	0xDA: pLu | pp, // 'Ú'
	0xDB: pLu | pp, // 'Û'
	0xDC: pLu | pp, // 'Ü'
	0xDD: pLu | pp, // 'Ý'
	0xDE: pLu | pp, // 'Þ'
	0xDF: pLl | pp, // 'ß'
	0xE0: pLl | pp, // 'à'
	0xE1: pLl | pp, // 'á'
	0xE2: pLl | pp, // 'â'
	0xE3: pLl | pp, // 'ã'
	0xE4: pLl | pp, // 'ä'
	0xE5: pLl | pp, // 'å'
	0xE6: pLl | pp, // 'æ'
	0xE7: pLl | pp, // 'ç'
	0xE8: pLl | pp, // 'è'
	0xE9: pLl | pp, // 'é'
	0xEA: pLl | pp, // 'ê'
	0xEB: pLl | pp, // 'ë'
	0xEC: pLl | pp, // 'ì'
	0xED: pLl | pp, // 'í'
	0xEE: pLl | pp, // 'î'
	0xEF: pLl | pp, // 'ï'
	0xF0: pLl | pp, // 'ð'
	0xF1: pLl | pp, // 'ñ'
	0xF2: pLl | pp, // 'ò'
	0xF3: pLl | pp, // 'ó'
	0xF4: pLl | pp, // 'ô'
	0xF5: pLl | pp, // 'õ'
	0xF6: pLl | pp, // 'ö'
	0xF7: pS | pp,  // '÷'
	0xF8: pLl | pp, // 'ø'
	0xF9: pLl | pp, // 'ù'
	0xFA: pLl | pp, // 'ú'
	0xFB: pLl | pp, // 'û'
	0xFC: pLl | pp, // 'ü'
	0xFD: pLl | pp, // 'ý'
	0xFE: pLl | pp, // 'þ'
	0xFF: pLl | pp, // 'ÿ'
}

var caseOrbit = []foldPair{
	{0x004B, 0x006B},
	{0x0053, 0x0073},
	{0x006B, 0x212A},
	{0x0073, 0x017F},
	{0x00B5, 0x039C},
	{0x00C5, 0x00E5},
	{0x00DF, 0x1E9E},
	{0x00E5, 0x212B},
	{0x0130, 0x0130},
	{0x0131, 0x0131},
	{0x017F, 0x0053},
	{0x01C4, 0x01C5},
	{0x01C5, 0x01C6},
	{0x01C6, 0x01C4},
	{0x01C7, 0x01C8},
	{0x01C8, 0x01C9},
	{0x01C9, 0x01C7},
	{0x01CA, 0x01CB},
	{0x01CB, 0x01CC},
	{0x01CC, 0x01CA},
	{0x01F1, 0x01F2},
	{0x01F2, 0x01F3},
	{0x01F3, 0x01F1},
	{0x0345, 0x0399},
	{0x0392, 0x03B2},
	{0x0395, 0x03B5},
	{0x0398, 0x03B8},
	{0x0399, 0x03B9},
	{0x039A, 0x03BA},
	{0x039C, 0x03BC},
	{0x03A0, 0x03C0},
	{0x03A1, 0x03C1},
	{0x03A3, 0x03C2},
	{0x03A6, 0x03C6},
	{0x03A9, 0x03C9},
	{0x03B2, 0x03D0},
	{0x03B5, 0x03F5},
	{0x03B8, 0x03D1},
	{0x03B9, 0x1FBE},
	{0x03BA, 0x03F0},
	{0x03BC, 0x00B5},
	{0x03C0, 0x03D6},
	{0x03C1, 0x03F1},
	{0x03C2, 0x03C3},
	{0x03C3, 0x03A3},
	{0x03C6, 0x03D5},
	{0x03C9, 0x2126},
	{0x03D0, 0x0392},
	{0x03D1, 0x03F4},
	{0x03D5, 0x03A6},
	{0x03D6, 0x03A0},
	{0x03F0, 0x039A},
	{0x03F1, 0x03A1},
	{0x03F4, 0x0398},
	{0x03F5, 0x0395},
	{0x1E60, 0x1E61},
	{0x1E61, 0x1E9B},
	{0x1E9B, 0x1E60},
	{0x1E9E, 0x00DF},
	{0x1FBE, 0x0345},
	{0x2126, 0x03A9},
	{0x212A, 0x004B},
	{0x212B, 0x00C5},
}

// FoldCategory maps a category name to a table of
// code points outside the category that are equivalent under
// simple case folding to code points inside the category.
// If there is no entry for a category name, there are no such points.
var FoldCategory = map[string]*RangeTable{
	"Common":    foldCommon,
	"Greek":     foldGreek,
	"Inherited": foldInherited,
	"L":         foldL,
	"Ll":        foldLl,
	"Lt":        foldLt,
	"Lu":        foldLu,
	"M":         foldM,
	"Mn":        foldMn,
}

var foldCommon = &RangeTable{
	R16: []Range16{
		{0x039c, 0x03bc, 32},
	},
}

var foldGreek = &RangeTable{
	R16: []Range16{
		{0x00b5, 0x0345, 656},
	},
}

var foldInherited = &RangeTable{
	R16: []Range16{
		{0x0399, 0x03b9, 32},
		{0x1fbe, 0x1fbe, 1},
	},
}

var foldL = &RangeTable{
	R16: []Range16{
		{0x0345, 0x0345, 1},
	},
}

var foldLl = &RangeTable{
	R16: []Range16{
		{0x0041, 0x005a, 1},
		{0x00c0, 0x00d6, 1},
		{0x00d8, 0x00de, 1},
		{0x0100, 0x012e, 2},
		{0x0132, 0x0136, 2},
		{0x0139, 0x0147, 2},
		{0x014a, 0x0178, 2},
		{0x0179, 0x017d, 2},
		{0x0181, 0x0182, 1},
		{0x0184, 0x0186, 2},
		{0x0187, 0x0189, 2},
		{0x018a, 0x018b, 1},
		{0x018e, 0x0191, 1},
		{0x0193, 0x0194, 1},
		{0x0196, 0x0198, 1},
		{0x019c, 0x019d, 1},
		{0x019f, 0x01a0, 1},
		{0x01a2, 0x01a6, 2},
		{0x01a7, 0x01a9, 2},
		{0x01ac, 0x01ae, 2},
		{0x01af, 0x01b1, 2},
		{0x01b2, 0x01b3, 1},
		{0x01b5, 0x01b7, 2},
		{0x01b8, 0x01bc, 4},
		{0x01c4, 0x01c5, 1},
		{0x01c7, 0x01c8, 1},
		{0x01ca, 0x01cb, 1},
		{0x01cd, 0x01db, 2},
		{0x01de, 0x01ee, 2},
		{0x01f1, 0x01f2, 1},
		{0x01f4, 0x01f6, 2},
		{0x01f7, 0x01f8, 1},
		{0x01fa, 0x0232, 2},
		{0x023a, 0x023b, 1},
		{0x023d, 0x023e, 1},
		{0x0241, 0x0243, 2},
		{0x0244, 0x0246, 1},
		{0x0248, 0x024e, 2},
		{0x0345, 0x0370, 43},
		{0x0372, 0x0376, 4},
		{0x037f, 0x0386, 7},
		{0x0388, 0x038a, 1},
		{0x038c, 0x038e, 2},
		{0x038f, 0x0391, 2},
		{0x0392, 0x03a1, 1},
		{0x03a3, 0x03ab, 1},
		{0x03cf, 0x03d8, 9},
		{0x03da, 0x03ee, 2},
		{0x03f4, 0x03f7, 3},
		{0x03f9, 0x03fa, 1},
		{0x03fd, 0x042f, 1},
		{0x0460, 0x0480, 2},
		{0x048a, 0x04c0, 2},
		{0x04c1, 0x04cd, 2},
		{0x04d0, 0x052e, 2},
		{0x0531, 0x0556, 1},
		{0x10a0, 0x10c5, 1},
		{0x10c7, 0x10cd, 6},
		{0x13a0, 0x13f5, 1},
		{0x1e00, 0x1e94, 2},
		{0x1e9e, 0x1efe, 2},
		{0x1f08, 0x1f0f, 1},
		{0x1f18, 0x1f1d, 1},
		{0x1f28, 0x1f2f, 1},
		{0x1f38, 0x1f3f, 1},
		{0x1f48, 0x1f4d, 1},
		{0x1f59, 0x1f5f, 2},
		{0x1f68, 0x1f6f, 1},
		{0x1f88, 0x1f8f, 1},
		{0x1f98, 0x1f9f, 1},
		{0x1fa8, 0x1faf, 1},
		{0x1fb8, 0x1fbc, 1},
		{0x1fc8, 0x1fcc, 1},
		{0x1fd8, 0x1fdb, 1},
		{0x1fe8, 0x1fec, 1},
		{0x1ff8, 0x1ffc, 1},
		{0x2126, 0x212a, 4},
		{0x212b, 0x2132, 7},
		{0x2183, 0x2c00, 2685},
		{0x2c01, 0x2c2e, 1},
		{0x2c60, 0x2c62, 2},
		{0x2c63, 0x2c64, 1},
		{0x2c67, 0x2c6d, 2},
		{0x2c6e, 0x2c70, 1},
		{0x2c72, 0x2c75, 3},
		{0x2c7e, 0x2c80, 1},
		{0x2c82, 0x2ce2, 2},
		{0x2ceb, 0x2ced, 2},
		{0x2cf2, 0xa640, 31054},
		{0xa642, 0xa66c, 2},
		{0xa680, 0xa69a, 2},
		{0xa722, 0xa72e, 2},
		{0xa732, 0xa76e, 2},
		{0xa779, 0xa77d, 2},
		{0xa77e, 0xa786, 2},
		{0xa78b, 0xa78d, 2},
		{0xa790, 0xa792, 2},
		{0xa796, 0xa7aa, 2},
		{0xa7ab, 0xa7ad, 1},
		{0xa7b0, 0xa7b4, 1},
		{0xa7b6, 0xff21, 22379},
		{0xff22, 0xff3a, 1},
	},
	R32: []Range32{
		{0x10400, 0x10427, 1},
		{0x10c80, 0x10cb2, 1},
		{0x118a0, 0x118bf, 1},
	},
	LatinOffset: 3,
}

var foldLt = &RangeTable{
	R16: []Range16{
		{0x01c4, 0x01c6, 2},
		{0x01c7, 0x01c9, 2},
		{0x01ca, 0x01cc, 2},
		{0x01f1, 0x01f3, 2},
		{0x1f80, 0x1f87, 1},
		{0x1f90, 0x1f97, 1},
		{0x1fa0, 0x1fa7, 1},
		{0x1fb3, 0x1fc3, 16},
		{0x1ff3, 0x1ff3, 1},
	},
}

var foldLu = &RangeTable{
	R16: []Range16{
		{0x0061, 0x007a, 1},
		{0x00b5, 0x00df, 42},
		{0x00e0, 0x00f6, 1},
		{0x00f8, 0x00ff, 1},
		{0x0101, 0x012f, 2},
		{0x0133, 0x0137, 2},
		{0x013a, 0x0148, 2},
		{0x014b, 0x0177, 2},
		{0x017a, 0x017e, 2},
		{0x017f, 0x0180, 1},
		{0x0183, 0x0185, 2},
		{0x0188, 0x018c, 4},
		{0x0192, 0x0195, 3},
		{0x0199, 0x019a, 1},
		{0x019e, 0x01a1, 3},
		{0x01a3, 0x01a5, 2},
		{0x01a8, 0x01ad, 5},
		{0x01b0, 0x01b4, 4},
		{0x01b6, 0x01b9, 3},
		{0x01bd, 0x01bf, 2},
		{0x01c5, 0x01c6, 1},
		{0x01c8, 0x01c9, 1},
		{0x01cb, 0x01cc, 1},
		{0x01ce, 0x01dc, 2},
		{0x01dd, 0x01ef, 2},
		{0x01f2, 0x01f3, 1},
		{0x01f5, 0x01f9, 4},
		{0x01fb, 0x021f, 2},
		{0x0223, 0x0233, 2},
		{0x023c, 0x023f, 3},
		{0x0240, 0x0242, 2},
		{0x0247, 0x024f, 2},
		{0x0250, 0x0254, 1},
		{0x0256, 0x0257, 1},
		{0x0259, 0x025b, 2},
		{0x025c, 0x0260, 4},
		{0x0261, 0x0265, 2},
		{0x0266, 0x0268, 2},
		{0x0269, 0x026b, 2},
		{0x026c, 0x026f, 3},
		{0x0271, 0x0272, 1},
		{0x0275, 0x027d, 8},
		{0x0280, 0x0283, 3},
		{0x0287, 0x028c, 1},
		{0x0292, 0x029d, 11},
		{0x029e, 0x0345, 167},
		{0x0371, 0x0373, 2},
		{0x0377, 0x037b, 4},
		{0x037c, 0x037d, 1},
		{0x03ac, 0x03af, 1},
		{0x03b1, 0x03ce, 1},
		{0x03d0, 0x03d1, 1},
		{0x03d5, 0x03d7, 1},
		{0x03d9, 0x03ef, 2},
		{0x03f0, 0x03f3, 1},
		{0x03f5, 0x03fb, 3},
		{0x0430, 0x045f, 1},
		{0x0461, 0x0481, 2},
		{0x048b, 0x04bf, 2},
		{0x04c2, 0x04ce, 2},
		{0x04cf, 0x052f, 2},
		{0x0561, 0x0586, 1},
		{0x13f8, 0x13fd, 1},
		{0x1d79, 0x1d7d, 4},
		{0x1e01, 0x1e95, 2},
		{0x1e9b, 0x1ea1, 6},
		{0x1ea3, 0x1eff, 2},
		{0x1f00, 0x1f07, 1},
		{0x1f10, 0x1f15, 1},
		{0x1f20, 0x1f27, 1},
		{0x1f30, 0x1f37, 1},
		{0x1f40, 0x1f45, 1},
		{0x1f51, 0x1f57, 2},
		{0x1f60, 0x1f67, 1},
		{0x1f70, 0x1f7d, 1},
		{0x1fb0, 0x1fb1, 1},
		{0x1fbe, 0x1fd0, 18},
		{0x1fd1, 0x1fe0, 15},
		{0x1fe1, 0x1fe5, 4},
		{0x214e, 0x2184, 54},
		{0x2c30, 0x2c5e, 1},
		{0x2c61, 0x2c65, 4},
		{0x2c66, 0x2c6c, 2},
		{0x2c73, 0x2c76, 3},
		{0x2c81, 0x2ce3, 2},
		{0x2cec, 0x2cee, 2},
		{0x2cf3, 0x2d00, 13},
		{0x2d01, 0x2d25, 1},
		{0x2d27, 0x2d2d, 6},
		{0xa641, 0xa66d, 2},
		{0xa681, 0xa69b, 2},
		{0xa723, 0xa72f, 2},
		{0xa733, 0xa76f, 2},
		{0xa77a, 0xa77c, 2},
		{0xa77f, 0xa787, 2},
		{0xa78c, 0xa791, 5},
		{0xa793, 0xa797, 4},
		{0xa799, 0xa7a9, 2},
		{0xa7b5, 0xa7b7, 2},
		{0xab53, 0xab70, 29},
		{0xab71, 0xabbf, 1},
		{0xff41, 0xff5a, 1},
	},
	R32: []Range32{
		{0x10428, 0x1044f, 1},
		{0x10cc0, 0x10cf2, 1},
		{0x118c0, 0x118df, 1},
	},
	LatinOffset: 4,
}

var foldM = &RangeTable{
	R16: []Range16{
		{0x0399, 0x03b9, 32},
		{0x1fbe, 0x1fbe, 1},
	},
}

var foldMn = &RangeTable{
	R16: []Range16{
		{0x0399, 0x03b9, 32},
		{0x1fbe, 0x1fbe, 1},
	},
}

// FoldScript maps a script name to a table of
// code points outside the script that are equivalent under
// simple case folding to code points inside the script.
// If there is no entry for a script name, there are no such points.
var FoldScript = map[string]*RangeTable{}

// Range entries: 3546 16-bit, 1306 32-bit, 4852 total.
// Range bytes: 21276 16-bit, 15672 32-bit, 36948 total.

// Fold orbit bytes: 63 pairs, 252 bytes
                                                                                                        usr/local/go/src/unicode/utf16/                                                                     0040755 0000000 0000000 00000000000 13020111414 014725  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/unicode/utf16/export_test.go                                                       0100644 0000000 0000000 00000000475 13020111414 017637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package utf16

// Extra names for constants so we can validate them during testing.
const (
	MaxRune         = maxRune
	ReplacementChar = replacementChar
)
                                                                                                                                                                                                   usr/local/go/src/unicode/utf16/utf16.go                                                             0100644 0000000 0000000 00000005356 13020111414 016227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package utf16 implements encoding and decoding of UTF-16 sequences.
package utf16

// The conditions replacementChar==unicode.ReplacementChar and
// maxRune==unicode.MaxRune are verified in the tests.
// Defining them locally avoids this package depending on package unicode.

const (
	replacementChar = '\uFFFD'     // Unicode replacement character
	maxRune         = '\U0010FFFF' // Maximum valid Unicode code point.
)

const (
	// 0xd800-0xdc00 encodes the high 10 bits of a pair.
	// 0xdc00-0xe000 encodes the low 10 bits of a pair.
	// the value is those 20 bits plus 0x10000.
	surr1 = 0xd800
	surr2 = 0xdc00
	surr3 = 0xe000

	surrSelf = 0x10000
)

// IsSurrogate reports whether the specified Unicode code point
// can appear in a surrogate pair.
func IsSurrogate(r rune) bool {
	return surr1 <= r && r < surr3
}

// DecodeRune returns the UTF-16 decoding of a surrogate pair.
// If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns
// the Unicode replacement code point U+FFFD.
func DecodeRune(r1, r2 rune) rune {
	if surr1 <= r1 && r1 < surr2 && surr2 <= r2 && r2 < surr3 {
		return (r1-surr1)<<10 | (r2 - surr2) + 0x10000
	}
	return replacementChar
}

// EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.
// If the rune is not a valid Unicode code point or does not need encoding,
// EncodeRune returns U+FFFD, U+FFFD.
func EncodeRune(r rune) (r1, r2 rune) {
	if r < surrSelf || r > maxRune || IsSurrogate(r) {
		return replacementChar, replacementChar
	}
	r -= surrSelf
	return surr1 + (r>>10)&0x3ff, surr2 + r&0x3ff
}

// Encode returns the UTF-16 encoding of the Unicode code point sequence s.
func Encode(s []rune) []uint16 {
	n := len(s)
	for _, v := range s {
		if v >= surrSelf {
			n++
		}
	}

	a := make([]uint16, n)
	n = 0
	for _, v := range s {
		switch {
		case v < 0, surr1 <= v && v < surr3, v > maxRune:
			v = replacementChar
			fallthrough
		case v < surrSelf:
			a[n] = uint16(v)
			n++
		default:
			r1, r2 := EncodeRune(v)
			a[n] = uint16(r1)
			a[n+1] = uint16(r2)
			n += 2
		}
	}
	return a[0:n]
}

// Decode returns the Unicode code point sequence represented
// by the UTF-16 encoding s.
func Decode(s []uint16) []rune {
	a := make([]rune, len(s))
	n := 0
	for i := 0; i < len(s); i++ {
		switch r := s[i]; {
		case surr1 <= r && r < surr2 && i+1 < len(s) &&
			surr2 <= s[i+1] && s[i+1] < surr3:
			// valid surrogate sequence
			a[n] = DecodeRune(rune(r), rune(s[i+1]))
			i++
			n++
		case surr1 <= r && r < surr3:
			// invalid surrogate sequence
			a[n] = replacementChar
			n++
		default:
			// normal rune
			a[n] = rune(r)
			n++
		}
	}
	return a[0:n]
}
                                                                                                                                                                                                                                                                                  usr/local/go/src/unicode/utf16/utf16_test.go                                                        0100644 0000000 0000000 00000007643 13020111414 017267  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package utf16_test

import (
	"reflect"
	"testing"
	"unicode"
	. "unicode/utf16"
)

// Validate the constants redefined from unicode.
func TestConstants(t *testing.T) {
	if MaxRune != unicode.MaxRune {
		t.Errorf("utf16.maxRune is wrong: %x should be %x", MaxRune, unicode.MaxRune)
	}
	if ReplacementChar != unicode.ReplacementChar {
		t.Errorf("utf16.replacementChar is wrong: %x should be %x", ReplacementChar, unicode.ReplacementChar)
	}
}

type encodeTest struct {
	in  []rune
	out []uint16
}

var encodeTests = []encodeTest{
	{[]rune{1, 2, 3, 4}, []uint16{1, 2, 3, 4}},
	{[]rune{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff},
		[]uint16{0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff}},
	{[]rune{'a', 'b', 0xd7ff, 0xd800, 0xdfff, 0xe000, 0x110000, -1},
		[]uint16{'a', 'b', 0xd7ff, 0xfffd, 0xfffd, 0xe000, 0xfffd, 0xfffd}},
}

func TestEncode(t *testing.T) {
	for _, tt := range encodeTests {
		out := Encode(tt.in)
		if !reflect.DeepEqual(out, tt.out) {
			t.Errorf("Encode(%x) = %x; want %x", tt.in, out, tt.out)
		}
	}
}

func TestEncodeRune(t *testing.T) {
	for i, tt := range encodeTests {
		j := 0
		for _, r := range tt.in {
			r1, r2 := EncodeRune(r)
			if r < 0x10000 || r > unicode.MaxRune {
				if j >= len(tt.out) {
					t.Errorf("#%d: ran out of tt.out", i)
					break
				}
				if r1 != unicode.ReplacementChar || r2 != unicode.ReplacementChar {
					t.Errorf("EncodeRune(%#x) = %#x, %#x; want 0xfffd, 0xfffd", r, r1, r2)
				}
				j++
			} else {
				if j+1 >= len(tt.out) {
					t.Errorf("#%d: ran out of tt.out", i)
					break
				}
				if r1 != rune(tt.out[j]) || r2 != rune(tt.out[j+1]) {
					t.Errorf("EncodeRune(%#x) = %#x, %#x; want %#x, %#x", r, r1, r2, tt.out[j], tt.out[j+1])
				}
				j += 2
				dec := DecodeRune(r1, r2)
				if dec != r {
					t.Errorf("DecodeRune(%#x, %#x) = %#x; want %#x", r1, r2, dec, r)
				}
			}
		}
		if j != len(tt.out) {
			t.Errorf("#%d: EncodeRune didn't generate enough output", i)
		}
	}
}

type decodeTest struct {
	in  []uint16
	out []rune
}

var decodeTests = []decodeTest{
	{[]uint16{1, 2, 3, 4}, []rune{1, 2, 3, 4}},
	{[]uint16{0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff},
		[]rune{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff}},
	{[]uint16{0xd800, 'a'}, []rune{0xfffd, 'a'}},
	{[]uint16{0xdfff}, []rune{0xfffd}},
}

func TestDecode(t *testing.T) {
	for _, tt := range decodeTests {
		out := Decode(tt.in)
		if !reflect.DeepEqual(out, tt.out) {
			t.Errorf("Decode(%x) = %x; want %x", tt.in, out, tt.out)
		}
	}
}

var decodeRuneTests = []struct {
	r1, r2 rune
	want   rune
}{
	{0xd800, 0xdc00, 0x10000},
	{0xd800, 0xdc01, 0x10001},
	{0xd808, 0xdf45, 0x12345},
	{0xdbff, 0xdfff, 0x10ffff},
	{0xd800, 'a', 0xfffd}, // illegal, replacement rune substituted
}

func TestDecodeRune(t *testing.T) {
	for i, tt := range decodeRuneTests {
		got := DecodeRune(tt.r1, tt.r2)
		if got != tt.want {
			t.Errorf("%d: DecodeRune(%q, %q) = %v; want %v", i, tt.r1, tt.r2, got, tt.want)
		}
	}
}

var surrogateTests = []struct {
	r    rune
	want bool
}{
	// from http://en.wikipedia.org/wiki/UTF-16
	{'\u007A', false},     // LATIN SMALL LETTER Z
	{'\u6C34', false},     // CJK UNIFIED IDEOGRAPH-6C34 (water)
	{'\uFEFF', false},     // Byte Order Mark
	{'\U00010000', false}, // LINEAR B SYLLABLE B008 A (first non-BMP code point)
	{'\U0001D11E', false}, // MUSICAL SYMBOL G CLEF
	{'\U0010FFFD', false}, // PRIVATE USE CHARACTER-10FFFD (last Unicode code point)

	{rune(0xd7ff), false}, // surr1-1
	{rune(0xd800), true},  // surr1
	{rune(0xdc00), true},  // surr2
	{rune(0xe000), false}, // surr3
	{rune(0xdfff), true},  // surr3-1
}

func TestIsSurrogate(t *testing.T) {
	for i, tt := range surrogateTests {
		got := IsSurrogate(tt.r)
		if got != tt.want {
			t.Errorf("%d: IsSurrogate(%q) = %v; want %v", i, tt.r, got, tt.want)
		}
	}
}
                                                                                             usr/local/go/src/unicode/utf8/                                                                      0040755 0000000 0000000 00000000000 13020111414 014646  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/unicode/utf8/example_test.go                                                       0100644 0000000 0000000 00000005764 13020111414 017700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package utf8_test

import (
	"fmt"
	"unicode/utf8"
)

func ExampleDecodeLastRune() {
	b := []byte("Hello, 世界")

	for len(b) > 0 {
		r, size := utf8.DecodeLastRune(b)
		fmt.Printf("%c %v\n", r, size)

		b = b[:len(b)-size]
	}
	// Output:
	// 界 3
	// 世 3
	//   1
	// , 1
	// o 1
	// l 1
	// l 1
	// e 1
	// H 1
}

func ExampleDecodeLastRuneInString() {
	str := "Hello, 世界"

	for len(str) > 0 {
		r, size := utf8.DecodeLastRuneInString(str)
		fmt.Printf("%c %v\n", r, size)

		str = str[:len(str)-size]
	}
	// Output:
	// 界 3
	// 世 3
	//   1
	// , 1
	// o 1
	// l 1
	// l 1
	// e 1
	// H 1

}

func ExampleDecodeRune() {
	b := []byte("Hello, 世界")

	for len(b) > 0 {
		r, size := utf8.DecodeRune(b)
		fmt.Printf("%c %v\n", r, size)

		b = b[size:]
	}
	// Output:
	// H 1
	// e 1
	// l 1
	// l 1
	// o 1
	// , 1
	//   1
	// 世 3
	// 界 3
}

func ExampleDecodeRuneInString() {
	str := "Hello, 世界"

	for len(str) > 0 {
		r, size := utf8.DecodeRuneInString(str)
		fmt.Printf("%c %v\n", r, size)

		str = str[size:]
	}
	// Output:
	// H 1
	// e 1
	// l 1
	// l 1
	// o 1
	// , 1
	//   1
	// 世 3
	// 界 3
}

func ExampleEncodeRune() {
	r := '世'
	buf := make([]byte, 3)

	n := utf8.EncodeRune(buf, r)

	fmt.Println(buf)
	fmt.Println(n)
	// Output:
	// [228 184 150]
	// 3
}

func ExampleFullRune() {
	buf := []byte{228, 184, 150} // 世
	fmt.Println(utf8.FullRune(buf))
	fmt.Println(utf8.FullRune(buf[:2]))
	// Output:
	// true
	// false
}

func ExampleFullRuneInString() {
	str := "世"
	fmt.Println(utf8.FullRuneInString(str))
	fmt.Println(utf8.FullRuneInString(str[:2]))
	// Output:
	// true
	// false
}

func ExampleRuneCount() {
	buf := []byte("Hello, 世界")
	fmt.Println("bytes =", len(buf))
	fmt.Println("runes =", utf8.RuneCount(buf))
	// Output:
	// bytes = 13
	// runes = 9
}

func ExampleRuneCountInString() {
	str := "Hello, 世界"
	fmt.Println("bytes =", len(str))
	fmt.Println("runes =", utf8.RuneCountInString(str))
	// Output:
	// bytes = 13
	// runes = 9
}

func ExampleRuneLen() {
	fmt.Println(utf8.RuneLen('a'))
	fmt.Println(utf8.RuneLen('界'))
	// Output:
	// 1
	// 3
}

func ExampleRuneStart() {
	buf := []byte("a界")
	fmt.Println(utf8.RuneStart(buf[0]))
	fmt.Println(utf8.RuneStart(buf[1]))
	fmt.Println(utf8.RuneStart(buf[2]))
	// Output:
	// true
	// true
	// false
}

func ExampleValid() {
	valid := []byte("Hello, 世界")
	invalid := []byte{0xff, 0xfe, 0xfd}

	fmt.Println(utf8.Valid(valid))
	fmt.Println(utf8.Valid(invalid))
	// Output:
	// true
	// false
}

func ExampleValidRune() {
	valid := 'a'
	invalid := rune(0xfffffff)

	fmt.Println(utf8.ValidRune(valid))
	fmt.Println(utf8.ValidRune(invalid))
	// Output:
	// true
	// false
}

func ExampleValidString() {
	valid := "Hello, 世界"
	invalid := string([]byte{0xff, 0xfe, 0xfd})

	fmt.Println(utf8.ValidString(valid))
	fmt.Println(utf8.ValidString(invalid))
	// Output:
	// true
	// false
}
            usr/local/go/src/unicode/utf8/utf8.go                                                               0100644 0000000 0000000 00000033555 13020111414 016073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package utf8 implements functions and constants to support text encoded in
// UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.
package utf8

// The conditions RuneError==unicode.ReplacementChar and
// MaxRune==unicode.MaxRune are verified in the tests.
// Defining them locally avoids this package depending on package unicode.

// Numbers fundamental to the encoding.
const (
	RuneError = '\uFFFD'     // the "error" Rune or "Unicode replacement character"
	RuneSelf  = 0x80         // characters below Runeself are represented as themselves in a single byte.
	MaxRune   = '\U0010FFFF' // Maximum valid Unicode code point.
	UTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.
)

// Code points in the surrogate range are not valid for UTF-8.
const (
	surrogateMin = 0xD800
	surrogateMax = 0xDFFF
)

const (
	t1 = 0x00 // 0000 0000
	tx = 0x80 // 1000 0000
	t2 = 0xC0 // 1100 0000
	t3 = 0xE0 // 1110 0000
	t4 = 0xF0 // 1111 0000
	t5 = 0xF8 // 1111 1000

	maskx = 0x3F // 0011 1111
	mask2 = 0x1F // 0001 1111
	mask3 = 0x0F // 0000 1111
	mask4 = 0x07 // 0000 0111

	rune1Max = 1<<7 - 1
	rune2Max = 1<<11 - 1
	rune3Max = 1<<16 - 1

	// The default lowest and highest continuation byte.
	locb = 0x80 // 1000 0000
	hicb = 0xBF // 1011 1111

	// These names of these constants are chosen to give nice alignment in the
	// table below. The first nibble is an index into acceptRanges or F for
	// special one-byte cases. The second nibble is the Rune length or the
	// Status for the special one-byte case.
	xx = 0xF1 // invalid: size 1
	as = 0xF0 // ASCII: size 1
	s1 = 0x02 // accept 0, size 2
	s2 = 0x13 // accept 1, size 3
	s3 = 0x03 // accept 0, size 3
	s4 = 0x23 // accept 2, size 3
	s5 = 0x34 // accept 3, size 4
	s6 = 0x04 // accept 0, size 4
	s7 = 0x44 // accept 4, size 4
)

// first is information about the first byte in a UTF-8 sequence.
var first = [256]uint8{
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
	xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
	s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
	s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
	s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
}

// acceptRange gives the range of valid values for the second byte in a UTF-8
// sequence.
type acceptRange struct {
	lo uint8 // lowest value for second byte.
	hi uint8 // highest value for second byte.
}

var acceptRanges = [...]acceptRange{
	0: {locb, hicb},
	1: {0xA0, hicb},
	2: {locb, 0x9F},
	3: {0x90, hicb},
	4: {locb, 0x8F},
}

// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
func FullRune(p []byte) bool {
	n := len(p)
	if n == 0 {
		return false
	}
	x := first[p[0]]
	if n >= int(x&7) {
		return true // ASCII, invalid or valid.
	}
	// Must be short or invalid.
	accept := acceptRanges[x>>4]
	if n > 1 {
		if c := p[1]; c < accept.lo || accept.hi < c {
			return true
		} else if n > 2 && (p[2] < locb || hicb < p[2]) {
			return true
		}
	}
	return false
}

// FullRuneInString is like FullRune but its input is a string.
func FullRuneInString(s string) bool {
	n := len(s)
	if n == 0 {
		return false
	}
	x := first[s[0]]
	if n >= int(x&7) {
		return true // ASCII, invalid, or valid.
	}
	// Must be short or invalid.
	accept := acceptRanges[x>>4]
	if n > 1 {
		if c := s[1]; c < accept.lo || accept.hi < c {
			return true
		} else if n > 2 && (s[2] < locb || hicb < s[2]) {
			return true
		}
	}
	return false
}

// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
// the encoding is invalid, it returns (RuneError, 1). Both are impossible
// results for correct, non-empty UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeRune(p []byte) (r rune, size int) {
	n := len(p)
	if n < 1 {
		return RuneError, 0
	}
	p0 := p[0]
	x := first[p0]
	if x >= as {
		// The following code simulates an additional check for x == xx and
		// handling the ASCII and invalid cases accordingly. This mask-and-or
		// approach prevents an additional branch.
		mask := rune(x) << 31 >> 31 // Create 0x0000 or 0xFFFF.
		return rune(p[0])&^mask | RuneError&mask, 1
	}
	sz := x & 7
	accept := acceptRanges[x>>4]
	if n < int(sz) {
		return RuneError, 1
	}
	b1 := p[1]
	if b1 < accept.lo || accept.hi < b1 {
		return RuneError, 1
	}
	if sz == 2 {
		return rune(p0&mask2)<<6 | rune(b1&maskx), 2
	}
	b2 := p[2]
	if b2 < locb || hicb < b2 {
		return RuneError, 1
	}
	if sz == 3 {
		return rune(p0&mask3)<<12 | rune(b1&maskx)<<6 | rune(b2&maskx), 3
	}
	b3 := p[3]
	if b3 < locb || hicb < b3 {
		return RuneError, 1
	}
	return rune(p0&mask4)<<18 | rune(b1&maskx)<<12 | rune(b2&maskx)<<6 | rune(b3&maskx), 4
}

// DecodeRuneInString is like DecodeRune but its input is a string. If s is
// empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it
// returns (RuneError, 1). Both are impossible results for correct, non-empty
// UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeRuneInString(s string) (r rune, size int) {
	n := len(s)
	if n < 1 {
		return RuneError, 0
	}
	s0 := s[0]
	x := first[s0]
	if x >= as {
		// The following code simulates an additional check for x == xx and
		// handling the ASCII and invalid cases accordingly. This mask-and-or
		// approach prevents an additional branch.
		mask := rune(x) << 31 >> 31 // Create 0x0000 or 0xFFFF.
		return rune(s[0])&^mask | RuneError&mask, 1
	}
	sz := x & 7
	accept := acceptRanges[x>>4]
	if n < int(sz) {
		return RuneError, 1
	}
	s1 := s[1]
	if s1 < accept.lo || accept.hi < s1 {
		return RuneError, 1
	}
	if sz == 2 {
		return rune(s0&mask2)<<6 | rune(s1&maskx), 2
	}
	s2 := s[2]
	if s2 < locb || hicb < s2 {
		return RuneError, 1
	}
	if sz == 3 {
		return rune(s0&mask3)<<12 | rune(s1&maskx)<<6 | rune(s2&maskx), 3
	}
	s3 := s[3]
	if s3 < locb || hicb < s3 {
		return RuneError, 1
	}
	return rune(s0&mask4)<<18 | rune(s1&maskx)<<12 | rune(s2&maskx)<<6 | rune(s3&maskx), 4
}

// DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and
// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
// the encoding is invalid, it returns (RuneError, 1). Both are impossible
// results for correct, non-empty UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeLastRune(p []byte) (r rune, size int) {
	end := len(p)
	if end == 0 {
		return RuneError, 0
	}
	start := end - 1
	r = rune(p[start])
	if r < RuneSelf {
		return r, 1
	}
	// guard against O(n^2) behavior when traversing
	// backwards through strings with long sequences of
	// invalid UTF-8.
	lim := end - UTFMax
	if lim < 0 {
		lim = 0
	}
	for start--; start >= lim; start-- {
		if RuneStart(p[start]) {
			break
		}
	}
	if start < 0 {
		start = 0
	}
	r, size = DecodeRune(p[start:end])
	if start+size != end {
		return RuneError, 1
	}
	return r, size
}

// DecodeLastRuneInString is like DecodeLastRune but its input is a string. If
// s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,
// it returns (RuneError, 1). Both are impossible results for correct,
// non-empty UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeLastRuneInString(s string) (r rune, size int) {
	end := len(s)
	if end == 0 {
		return RuneError, 0
	}
	start := end - 1
	r = rune(s[start])
	if r < RuneSelf {
		return r, 1
	}
	// guard against O(n^2) behavior when traversing
	// backwards through strings with long sequences of
	// invalid UTF-8.
	lim := end - UTFMax
	if lim < 0 {
		lim = 0
	}
	for start--; start >= lim; start-- {
		if RuneStart(s[start]) {
			break
		}
	}
	if start < 0 {
		start = 0
	}
	r, size = DecodeRuneInString(s[start:end])
	if start+size != end {
		return RuneError, 1
	}
	return r, size
}

// RuneLen returns the number of bytes required to encode the rune.
// It returns -1 if the rune is not a valid value to encode in UTF-8.
func RuneLen(r rune) int {
	switch {
	case r < 0:
		return -1
	case r <= rune1Max:
		return 1
	case r <= rune2Max:
		return 2
	case surrogateMin <= r && r <= surrogateMax:
		return -1
	case r <= rune3Max:
		return 3
	case r <= MaxRune:
		return 4
	}
	return -1
}

// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.
// It returns the number of bytes written.
func EncodeRune(p []byte, r rune) int {
	// Negative values are erroneous.  Making it unsigned addresses the problem.
	switch i := uint32(r); {
	case i <= rune1Max:
		p[0] = byte(r)
		return 1
	case i <= rune2Max:
		p[0] = t2 | byte(r>>6)
		p[1] = tx | byte(r)&maskx
		return 2
	case i > MaxRune, surrogateMin <= i && i <= surrogateMax:
		r = RuneError
		fallthrough
	case i <= rune3Max:
		p[0] = t3 | byte(r>>12)
		p[1] = tx | byte(r>>6)&maskx
		p[2] = tx | byte(r)&maskx
		return 3
	default:
		p[0] = t4 | byte(r>>18)
		p[1] = tx | byte(r>>12)&maskx
		p[2] = tx | byte(r>>6)&maskx
		p[3] = tx | byte(r)&maskx
		return 4
	}
}

// RuneCount returns the number of runes in p.  Erroneous and short
// encodings are treated as single runes of width 1 byte.
func RuneCount(p []byte) int {
	np := len(p)
	var n int
	for i := 0; i < np; {
		n++
		c := p[i]
		if c < RuneSelf {
			// ASCII fast path
			i++
			continue
		}
		x := first[c]
		if x == xx {
			i++ // invalid.
			continue
		}
		size := int(x & 7)
		if i+size > np {
			i++ // Short or invalid.
			continue
		}
		accept := acceptRanges[x>>4]
		if c := p[i+1]; c < accept.lo || accept.hi < c {
			size = 1
		} else if size == 2 {
		} else if c := p[i+2]; c < locb || hicb < c {
			size = 1
		} else if size == 3 {
		} else if c := p[i+3]; c < locb || hicb < c {
			size = 1
		}
		i += size
	}
	return n
}

// RuneCountInString is like RuneCount but its input is a string.
func RuneCountInString(s string) (n int) {
	ns := len(s)
	for i := 0; i < ns; n++ {
		c := s[i]
		if c < RuneSelf {
			// ASCII fast path
			i++
			continue
		}
		x := first[c]
		if x == xx {
			i++ // invalid.
			continue
		}
		size := int(x & 7)
		if i+size > ns {
			i++ // Short or invalid.
			continue
		}
		accept := acceptRanges[x>>4]
		if c := s[i+1]; c < accept.lo || accept.hi < c {
			size = 1
		} else if size == 2 {
		} else if c := s[i+2]; c < locb || hicb < c {
			size = 1
		} else if size == 3 {
		} else if c := s[i+3]; c < locb || hicb < c {
			size = 1
		}
		i += size
	}
	return n
}

// RuneStart reports whether the byte could be the first byte of an encoded,
// possibly invalid rune.  Second and subsequent bytes always have the top two
// bits set to 10.
func RuneStart(b byte) bool { return b&0xC0 != 0x80 }

// Valid reports whether p consists entirely of valid UTF-8-encoded runes.
func Valid(p []byte) bool {
	n := len(p)
	for i := 0; i < n; {
		pi := p[i]
		if pi < RuneSelf {
			i++
			continue
		}
		x := first[pi]
		if x == xx {
			return false // Illegal starter byte.
		}
		size := int(x & 7)
		if i+size > n {
			return false // Short or invalid.
		}
		accept := acceptRanges[x>>4]
		if c := p[i+1]; c < accept.lo || accept.hi < c {
			return false
		} else if size == 2 {
		} else if c := p[i+2]; c < locb || hicb < c {
			return false
		} else if size == 3 {
		} else if c := p[i+3]; c < locb || hicb < c {
			return false
		}
		i += size
	}
	return true
}

// ValidString reports whether s consists entirely of valid UTF-8-encoded runes.
func ValidString(s string) bool {
	n := len(s)
	for i := 0; i < n; {
		si := s[i]
		if si < RuneSelf {
			i++
			continue
		}
		x := first[si]
		if x == xx {
			return false // Illegal starter byte.
		}
		size := int(x & 7)
		if i+size > n {
			return false // Short or invalid.
		}
		accept := acceptRanges[x>>4]
		if c := s[i+1]; c < accept.lo || accept.hi < c {
			return false
		} else if size == 2 {
		} else if c := s[i+2]; c < locb || hicb < c {
			return false
		} else if size == 3 {
		} else if c := s[i+3]; c < locb || hicb < c {
			return false
		}
		i += size
	}
	return true
}

// ValidRune reports whether r can be legally encoded as UTF-8.
// Code points that are out of range or a surrogate half are illegal.
func ValidRune(r rune) bool {
	switch {
	case r < 0:
		return false
	case surrogateMin <= r && r <= surrogateMax:
		return false
	case r > MaxRune:
		return false
	}
	return true
}
                                                                                                                                                   usr/local/go/src/unicode/utf8/utf8_test.go                                                          0100644 0000000 0000000 00000027753 13020111414 017135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package utf8_test

import (
	"bytes"
	"testing"
	"unicode"
	. "unicode/utf8"
)

// Validate the constants redefined from unicode.
func init() {
	if MaxRune != unicode.MaxRune {
		panic("utf8.MaxRune is wrong")
	}
	if RuneError != unicode.ReplacementChar {
		panic("utf8.RuneError is wrong")
	}
}

// Validate the constants redefined from unicode.
func TestConstants(t *testing.T) {
	if MaxRune != unicode.MaxRune {
		t.Errorf("utf8.MaxRune is wrong: %x should be %x", MaxRune, unicode.MaxRune)
	}
	if RuneError != unicode.ReplacementChar {
		t.Errorf("utf8.RuneError is wrong: %x should be %x", RuneError, unicode.ReplacementChar)
	}
}

type Utf8Map struct {
	r   rune
	str string
}

var utf8map = []Utf8Map{
	{0x0000, "\x00"},
	{0x0001, "\x01"},
	{0x007e, "\x7e"},
	{0x007f, "\x7f"},
	{0x0080, "\xc2\x80"},
	{0x0081, "\xc2\x81"},
	{0x00bf, "\xc2\xbf"},
	{0x00c0, "\xc3\x80"},
	{0x00c1, "\xc3\x81"},
	{0x00c8, "\xc3\x88"},
	{0x00d0, "\xc3\x90"},
	{0x00e0, "\xc3\xa0"},
	{0x00f0, "\xc3\xb0"},
	{0x00f8, "\xc3\xb8"},
	{0x00ff, "\xc3\xbf"},
	{0x0100, "\xc4\x80"},
	{0x07ff, "\xdf\xbf"},
	{0x0800, "\xe0\xa0\x80"},
	{0x0801, "\xe0\xa0\x81"},
	{0xd7ff, "\xed\x9f\xbf"}, // last code point before surrogate half.
	{0xe000, "\xee\x80\x80"}, // first code point after surrogate half.
	{0xfffe, "\xef\xbf\xbe"},
	{0xffff, "\xef\xbf\xbf"},
	{0x10000, "\xf0\x90\x80\x80"},
	{0x10001, "\xf0\x90\x80\x81"},
	{0x10fffe, "\xf4\x8f\xbf\xbe"},
	{0x10ffff, "\xf4\x8f\xbf\xbf"},
	{0xFFFD, "\xef\xbf\xbd"},
}

var surrogateMap = []Utf8Map{
	{0xd800, "\xed\xa0\x80"}, // surrogate min decodes to (RuneError, 1)
	{0xdfff, "\xed\xbf\xbf"}, // surrogate max decodes to (RuneError, 1)
}

var testStrings = []string{
	"",
	"abcd",
	"☺☻☹",
	"日a本b語ç日ð本Ê語þ日¥本¼語i日©",
	"日a本b語ç日ð本Ê語þ日¥本¼語i日©日a本b語ç日ð本Ê語þ日¥本¼語i日©日a本b語ç日ð本Ê語þ日¥本¼語i日©",
	"\x80\x80\x80\x80",
}

func TestFullRune(t *testing.T) {
	for _, m := range utf8map {
		b := []byte(m.str)
		if !FullRune(b) {
			t.Errorf("FullRune(%q) (%U) = false, want true", b, m.r)
		}
		s := m.str
		if !FullRuneInString(s) {
			t.Errorf("FullRuneInString(%q) (%U) = false, want true", s, m.r)
		}
		b1 := b[0 : len(b)-1]
		if FullRune(b1) {
			t.Errorf("FullRune(%q) = true, want false", b1)
		}
		s1 := string(b1)
		if FullRuneInString(s1) {
			t.Errorf("FullRune(%q) = true, want false", s1)
		}
	}
	for _, s := range []string{"\xc0", "\xc1"} {
		b := []byte(s)
		if !FullRune(b) {
			t.Errorf("FullRune(%q) = false, want true", s)
		}
		if !FullRuneInString(s) {
			t.Errorf("FullRuneInString(%q) = false, want true", s)
		}
	}
}

func TestEncodeRune(t *testing.T) {
	for _, m := range utf8map {
		b := []byte(m.str)
		var buf [10]byte
		n := EncodeRune(buf[0:], m.r)
		b1 := buf[0:n]
		if !bytes.Equal(b, b1) {
			t.Errorf("EncodeRune(%#04x) = %q want %q", m.r, b1, b)
		}
	}
}

func TestDecodeRune(t *testing.T) {
	for _, m := range utf8map {
		b := []byte(m.str)
		r, size := DecodeRune(b)
		if r != m.r || size != len(b) {
			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b, r, size, m.r, len(b))
		}
		s := m.str
		r, size = DecodeRuneInString(s)
		if r != m.r || size != len(b) {
			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, r, size, m.r, len(b))
		}

		// there's an extra byte that bytes left behind - make sure trailing byte works
		r, size = DecodeRune(b[0:cap(b)])
		if r != m.r || size != len(b) {
			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b, r, size, m.r, len(b))
		}
		s = m.str + "\x00"
		r, size = DecodeRuneInString(s)
		if r != m.r || size != len(b) {
			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, r, size, m.r, len(b))
		}

		// make sure missing bytes fail
		wantsize := 1
		if wantsize >= len(b) {
			wantsize = 0
		}
		r, size = DecodeRune(b[0 : len(b)-1])
		if r != RuneError || size != wantsize {
			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b[0:len(b)-1], r, size, RuneError, wantsize)
		}
		s = m.str[0 : len(m.str)-1]
		r, size = DecodeRuneInString(s)
		if r != RuneError || size != wantsize {
			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, r, size, RuneError, wantsize)
		}

		// make sure bad sequences fail
		if len(b) == 1 {
			b[0] = 0x80
		} else {
			b[len(b)-1] = 0x7F
		}
		r, size = DecodeRune(b)
		if r != RuneError || size != 1 {
			t.Errorf("DecodeRune(%q) = %#04x, %d want %#04x, %d", b, r, size, RuneError, 1)
		}
		s = string(b)
		r, size = DecodeRuneInString(s)
		if r != RuneError || size != 1 {
			t.Errorf("DecodeRuneInString(%q) = %#04x, %d want %#04x, %d", s, r, size, RuneError, 1)
		}

	}
}

func TestDecodeSurrogateRune(t *testing.T) {
	for _, m := range surrogateMap {
		b := []byte(m.str)
		r, size := DecodeRune(b)
		if r != RuneError || size != 1 {
			t.Errorf("DecodeRune(%q) = %x, %d want %x, %d", b, r, size, RuneError, 1)
		}
		s := m.str
		r, size = DecodeRuneInString(s)
		if r != RuneError || size != 1 {
			t.Errorf("DecodeRuneInString(%q) = %x, %d want %x, %d", b, r, size, RuneError, 1)
		}
	}
}

// Check that DecodeRune and DecodeLastRune correspond to
// the equivalent range loop.
func TestSequencing(t *testing.T) {
	for _, ts := range testStrings {
		for _, m := range utf8map {
			for _, s := range []string{ts + m.str, m.str + ts, ts + m.str + ts} {
				testSequence(t, s)
			}
		}
	}
}

// Check that a range loop and a []int conversion visit the same runes.
// Not really a test of this package, but the assumption is used here and
// it's good to verify
func TestIntConversion(t *testing.T) {
	for _, ts := range testStrings {
		runes := []rune(ts)
		if RuneCountInString(ts) != len(runes) {
			t.Errorf("%q: expected %d runes; got %d", ts, len(runes), RuneCountInString(ts))
			break
		}
		i := 0
		for _, r := range ts {
			if r != runes[i] {
				t.Errorf("%q[%d]: expected %c (%U); got %c (%U)", ts, i, runes[i], runes[i], r, r)
			}
			i++
		}
	}
}

func testSequence(t *testing.T, s string) {
	type info struct {
		index int
		r     rune
	}
	index := make([]info, len(s))
	b := []byte(s)
	si := 0
	j := 0
	for i, r := range s {
		if si != i {
			t.Errorf("Sequence(%q) mismatched index %d, want %d", s, si, i)
			return
		}
		index[j] = info{i, r}
		j++
		r1, size1 := DecodeRune(b[i:])
		if r != r1 {
			t.Errorf("DecodeRune(%q) = %#04x, want %#04x", s[i:], r1, r)
			return
		}
		r2, size2 := DecodeRuneInString(s[i:])
		if r != r2 {
			t.Errorf("DecodeRuneInString(%q) = %#04x, want %#04x", s[i:], r2, r)
			return
		}
		if size1 != size2 {
			t.Errorf("DecodeRune/DecodeRuneInString(%q) size mismatch %d/%d", s[i:], size1, size2)
			return
		}
		si += size1
	}
	j--
	for si = len(s); si > 0; {
		r1, size1 := DecodeLastRune(b[0:si])
		r2, size2 := DecodeLastRuneInString(s[0:si])
		if size1 != size2 {
			t.Errorf("DecodeLastRune/DecodeLastRuneInString(%q, %d) size mismatch %d/%d", s, si, size1, size2)
			return
		}
		if r1 != index[j].r {
			t.Errorf("DecodeLastRune(%q, %d) = %#04x, want %#04x", s, si, r1, index[j].r)
			return
		}
		if r2 != index[j].r {
			t.Errorf("DecodeLastRuneInString(%q, %d) = %#04x, want %#04x", s, si, r2, index[j].r)
			return
		}
		si -= size1
		if si != index[j].index {
			t.Errorf("DecodeLastRune(%q) index mismatch at %d, want %d", s, si, index[j].index)
			return
		}
		j--
	}
	if si != 0 {
		t.Errorf("DecodeLastRune(%q) finished at %d, not 0", s, si)
	}
}

// Check that negative runes encode as U+FFFD.
func TestNegativeRune(t *testing.T) {
	errorbuf := make([]byte, UTFMax)
	errorbuf = errorbuf[0:EncodeRune(errorbuf, RuneError)]
	buf := make([]byte, UTFMax)
	buf = buf[0:EncodeRune(buf, -1)]
	if !bytes.Equal(buf, errorbuf) {
		t.Errorf("incorrect encoding [% x] for -1; expected [% x]", buf, errorbuf)
	}
}

type RuneCountTest struct {
	in  string
	out int
}

var runecounttests = []RuneCountTest{
	{"abcd", 4},
	{"☺☻☹", 3},
	{"1,2,3,4", 7},
	{"\xe2\x00", 2},
	{"\xe2\x80", 2},
	{"a\xe2\x80", 3},
}

func TestRuneCount(t *testing.T) {
	for _, tt := range runecounttests {
		if out := RuneCountInString(tt.in); out != tt.out {
			t.Errorf("RuneCountInString(%q) = %d, want %d", tt.in, out, tt.out)
		}
		if out := RuneCount([]byte(tt.in)); out != tt.out {
			t.Errorf("RuneCount(%q) = %d, want %d", tt.in, out, tt.out)
		}
	}
}

type RuneLenTest struct {
	r    rune
	size int
}

var runelentests = []RuneLenTest{
	{0, 1},
	{'e', 1},
	{'é', 2},
	{'☺', 3},
	{RuneError, 3},
	{MaxRune, 4},
	{0xD800, -1},
	{0xDFFF, -1},
	{MaxRune + 1, -1},
	{-1, -1},
}

func TestRuneLen(t *testing.T) {
	for _, tt := range runelentests {
		if size := RuneLen(tt.r); size != tt.size {
			t.Errorf("RuneLen(%#U) = %d, want %d", tt.r, size, tt.size)
		}
	}
}

type ValidTest struct {
	in  string
	out bool
}

var validTests = []ValidTest{
	{"", true},
	{"a", true},
	{"abc", true},
	{"Ж", true},
	{"ЖЖ", true},
	{"брэд-ЛГТМ", true},
	{"☺☻☹", true},
	{"aa\xe2", false},
	{string([]byte{66, 250}), false},
	{string([]byte{66, 250, 67}), false},
	{"a\uFFFDb", true},
	{string("\xF4\x8F\xBF\xBF"), true},      // U+10FFFF
	{string("\xF4\x90\x80\x80"), false},     // U+10FFFF+1; out of range
	{string("\xF7\xBF\xBF\xBF"), false},     // 0x1FFFFF; out of range
	{string("\xFB\xBF\xBF\xBF\xBF"), false}, // 0x3FFFFFF; out of range
	{string("\xc0\x80"), false},             // U+0000 encoded in two bytes: incorrect
	{string("\xed\xa0\x80"), false},         // U+D800 high surrogate (sic)
	{string("\xed\xbf\xbf"), false},         // U+DFFF low surrogate (sic)
}

func TestValid(t *testing.T) {
	for _, tt := range validTests {
		if Valid([]byte(tt.in)) != tt.out {
			t.Errorf("Valid(%q) = %v; want %v", tt.in, !tt.out, tt.out)
		}
		if ValidString(tt.in) != tt.out {
			t.Errorf("ValidString(%q) = %v; want %v", tt.in, !tt.out, tt.out)
		}
	}
}

type ValidRuneTest struct {
	r  rune
	ok bool
}

var validrunetests = []ValidRuneTest{
	{0, true},
	{'e', true},
	{'é', true},
	{'☺', true},
	{RuneError, true},
	{MaxRune, true},
	{0xD7FF, true},
	{0xD800, false},
	{0xDFFF, false},
	{0xE000, true},
	{MaxRune + 1, false},
	{-1, false},
}

func TestValidRune(t *testing.T) {
	for _, tt := range validrunetests {
		if ok := ValidRune(tt.r); ok != tt.ok {
			t.Errorf("ValidRune(%#U) = %t, want %t", tt.r, ok, tt.ok)
		}
	}
}

func BenchmarkRuneCountTenASCIIChars(b *testing.B) {
	s := []byte("0123456789")
	for i := 0; i < b.N; i++ {
		RuneCount(s)
	}
}

func BenchmarkRuneCountTenJapaneseChars(b *testing.B) {
	s := []byte("日本語日本語日本語日")
	for i := 0; i < b.N; i++ {
		RuneCount(s)
	}
}

func BenchmarkRuneCountInStringTenASCIIChars(b *testing.B) {
	for i := 0; i < b.N; i++ {
		RuneCountInString("0123456789")
	}
}

func BenchmarkRuneCountInStringTenJapaneseChars(b *testing.B) {
	for i := 0; i < b.N; i++ {
		RuneCountInString("日本語日本語日本語日")
	}
}

func BenchmarkValidTenASCIIChars(b *testing.B) {
	s := []byte("0123456789")
	for i := 0; i < b.N; i++ {
		Valid(s)
	}
}

func BenchmarkValidTenJapaneseChars(b *testing.B) {
	s := []byte("日本語日本語日本語日")
	for i := 0; i < b.N; i++ {
		Valid(s)
	}
}

func BenchmarkValidStringTenASCIIChars(b *testing.B) {
	for i := 0; i < b.N; i++ {
		ValidString("0123456789")
	}
}

func BenchmarkValidStringTenJapaneseChars(b *testing.B) {
	for i := 0; i < b.N; i++ {
		ValidString("日本語日本語日本語日")
	}
}

func BenchmarkEncodeASCIIRune(b *testing.B) {
	buf := make([]byte, UTFMax)
	for i := 0; i < b.N; i++ {
		EncodeRune(buf, 'a')
	}
}

func BenchmarkEncodeJapaneseRune(b *testing.B) {
	buf := make([]byte, UTFMax)
	for i := 0; i < b.N; i++ {
		EncodeRune(buf, '本')
	}
}

func BenchmarkDecodeASCIIRune(b *testing.B) {
	a := []byte{'a'}
	for i := 0; i < b.N; i++ {
		DecodeRune(a)
	}
}

func BenchmarkDecodeJapaneseRune(b *testing.B) {
	nihon := []byte("本")
	for i := 0; i < b.N; i++ {
		DecodeRune(nihon)
	}
}

func BenchmarkFullASCIIRune(b *testing.B) {
	a := []byte{'a'}
	for i := 0; i < b.N; i++ {
		FullRune(a)
	}
}

func BenchmarkFullJapaneseRune(b *testing.B) {
	nihon := []byte("本")
	for i := 0; i < b.N; i++ {
		FullRune(nihon)
	}
}
                     usr/local/go/src/unsafe/                                                                            0040755 0000000 0000000 00000000000 13020111414 013613  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/unsafe/unsafe.go                                                                   0100644 0000000 0000000 00000021142 13020111414 015420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
	Package unsafe contains operations that step around the type safety of Go programs.

	Packages that import unsafe may be non-portable and are not protected by the
	Go 1 compatibility guidelines.
*/
package unsafe

// ArbitraryType is here for the purposes of documentation only and is not actually
// part of the unsafe package.  It represents the type of an arbitrary Go expression.
type ArbitraryType int

// Pointer represents a pointer to an arbitrary type.  There are four special operations
// available for type Pointer that are not available for other types:
//	- A pointer value of any type can be converted to a Pointer.
//	- A Pointer can be converted to a pointer value of any type.
//	- A uintptr can be converted to a Pointer.
//	- A Pointer can be converted to a uintptr.
// Pointer therefore allows a program to defeat the type system and read and write
// arbitrary memory. It should be used with extreme care.
//
// The following patterns involving Pointer are valid.
// Code not using these patterns is likely to be invalid today
// or to become invalid in the future.
// Even the valid patterns below come with important caveats.
//
// Running "go vet" can help find uses of Pointer that do not conform to these patterns,
// but silence from "go vet" is not a guarantee that the code is valid.
//
// (1) Conversion of a *T1 to Pointer to *T2.
//
// Provided that T2 is no larger than T1 and that the two share an equivalent
// memory layout, this conversion allows reinterpreting data of one type as
// data of another type. An example is the implementation of
// math.Float64bits:
//
//	func Float64bits(f float64) uint64 {
//		return *(*uint64)(unsafe.Pointer(&f))
//	}
//
// (2) Conversion of a Pointer to a uintptr (but not back to Pointer).
//
// Converting a Pointer to a uintptr produces the memory address of the value
// pointed at, as an integer. The usual use for such a uintptr is to print it.
//
// Conversion of a uintptr back to Pointer is not valid in general.
//
// A uintptr is an integer, not a reference.
// Converting a Pointer to a uintptr creates an integer value
// with no pointer semantics.
// Even if a uintptr holds the address of some object,
// the garbage collector will not update that uintptr's value
// if the object moves, nor will that uintptr keep the object
// from being reclaimed.
//
// The remaining patterns enumerate the only valid conversions
// from uintptr to Pointer.
//
// (3) Conversion of a Pointer to a uintptr and back, with arithmetic.
//
// If p points into an allocated object, it can be advanced through the object
// by conversion to uintptr, addition of an offset, and conversion back to Pointer.
//
//	p = unsafe.Pointer(uintptr(p) + offset)
//
// The most common use of this pattern is to access fields in a struct
// or elements of an array:
//
//	// equivalent to f := unsafe.Pointer(&s.f)
//	f := unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f))
//
//	// equivalent to e := unsafe.Pointer(&x[i])
//	e := unsafe.Pointer(uintptr(unsafe.Pointer(&x[0])) + i*unsafe.Sizeof(x[0]))
//
// It is valid both to add and to subtract offsets from a pointer in this way,
// but the result must continue to point into the original allocated object.
// Unlike in C, it is not valid to advance a pointer just beyond the end of
// its original allocation:
//
//	// INVALID: end points outside allocated space.
//	var s thing
//	end = unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Sizeof(s))
//
//	// INVALID: end points outside allocated space.
//	b := make([]byte, n)
//	end = unsafe.Pointer(uintptr(unsafe.Pointer(&b[0])) + uintptr(n))
//
// Note that both conversions must appear in the same expression, with only
// the intervening arithmetic between them:
//
//	// INVALID: uintptr cannot be stored in variable
//	// before conversion back to Pointer.
//	u := uintptr(p)
//	p = unsafe.Pointer(u + offset)
//
// (4) Conversion of a Pointer to a uintptr when calling syscall.Syscall.
//
// The Syscall functions in package syscall pass their uintptr arguments directly
// to the operating system, which then may, depending on the details of the call,
// reinterpret some of them as pointers.
// That is, the system call implementation is implicitly converting certain arguments
// back from uintptr to pointer.
//
// If a pointer argument must be converted to uintptr for use as an argument,
// that conversion must appear in the call expression itself:
//
//	syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))
//
// The compiler handles a Pointer converted to a uintptr in the argument list of
// a call to a function implemented in assembly by arranging that the referenced
// allocated object, if any, is retained and not moved until the call completes,
// even though from the types alone it would appear that the object is no longer
// needed during the call.
//
// For the compiler to recognize this pattern,
// the conversion must appear in the argument list:
//
//	// INVALID: uintptr cannot be stored in variable
//	// before implicit conversion back to Pointer during system call.
//	u := uintptr(unsafe.Pointer(p))
//	syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))
//
// (5) Conversion of the result of reflect.Value.Pointer or reflect.Value.UnsafeAddr
// from uintptr to Pointer.
//
// Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr
// instead of unsafe.Pointer to keep callers from changing the result to an arbitrary
// type without first importing "unsafe". However, this means that the result is
// fragile and must be converted to Pointer immediately after making the call,
// in the same expression:
//
//	p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))
//
// As in the cases above, it is invalid to store the result before the conversion:
//
//	// INVALID: uintptr cannot be stored in variable
//	// before conversion back to Pointer.
//	u := reflect.ValueOf(new(int)).Pointer()
//	p := (*int)(unsafe.Pointer(u))
//
// (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field to or from Pointer.
//
// As in the previous case, the reflect data structures SliceHeader and StringHeader
// declare the field Data as a uintptr to keep callers from changing the result to
// an arbitrary type without first importing "unsafe". However, this means that
// SliceHeader and StringHeader are only valid when interpreting the content
// of an actual slice or string value.
//
//	var s string
//	hdr := (*reflect.StringHeader)(unsafe.Pointer(&s)) // case 1
//	hdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)
//	hdr.Len = uintptr(n)
//
// In this usage hdr.Data is really an alternate way to refer to the underlying
// pointer in the slice header, not a uintptr variable itself.
//
// In general, reflect.SliceHeader and reflect.StringHeader should be used
// only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual
// slices or strings, never as plain structs.
// A program should not declare or allocate variables of these struct types.
//
//	// INVALID: a directly-declared header will not hold Data as a reference.
//	var hdr reflect.StringHeader
//	hdr.Data = uintptr(unsafe.Pointer(p))
//	hdr.Len = uintptr(n)
//	s := *(*string)(unsafe.Pointer(&hdr)) // p possibly already lost
//
type Pointer *ArbitraryType

// Sizeof takes an expression x of any type and returns the size in bytes
// of a hypothetical variable v as if v was declared via var v = x.
// The size does not include any memory possibly referenced by x.
// For instance, if x is a slice,  Sizeof returns the size of the slice
// descriptor, not the size of the memory referenced by the slice.
func Sizeof(x ArbitraryType) uintptr

// Offsetof returns the offset within the struct of the field represented by x,
// which must be of the form structValue.field.  In other words, it returns the
// number of bytes between the start of the struct and the start of the field.
func Offsetof(x ArbitraryType) uintptr

// Alignof takes an expression x of any type and returns the required alignment
// of a hypothetical variable v as if v was declared via var v = x.
// It is the largest value m such that the address of v is always zero mod m.
// It is the same as the value returned by reflect.TypeOf(x).Align().
// As a special case, if a variable s is of struct type and f is a field
// within that struct, then Alignof(s.f) will return the required alignment
// of a field of that type within a struct.  This case is the same as the
// value returned by reflect.TypeOf(s.f).FieldAlign().
func Alignof(x ArbitraryType) uintptr
                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/go/src/vendor/                                                                            0040755 0000000 0000000 00000000000 13020111414 013627  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/vendor/README                                                                      0100644 0000000 0000000 00000000413 13020111414 014502  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        This file needs to exist because the vendor directory needs
to exist for some go/build tests to pass, and git can't track
empty directories.

In Go 1.7 we'll use this directory again. (In Go 1.6 we tried but
reverted).

See http://golang.org/issue/14047 for details.
                                                                                                                                                                                                                                                     usr/local/go/test/                                                                                  0040755 0000000 0000000 00000000000 13020111414 012522  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/235.go                                                                            0100644 0000000 0000000 00000003074 13020111414 013363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Solve the 2,3,5 problem (print all numbers with 2, 3, or 5 as factor) using channels.
// Test the solution, silently.

package main

type T chan uint64

func M(f uint64) (in, out T) {
	in = make(T, 100)
	out = make(T, 100)
	go func(in, out T, f uint64) {
		for {
			out <- f*<-in
		}
	}(in, out, f)
	return in, out
}


func min(xs []uint64) uint64 {
	m := xs[0]
	for i := 1; i < len(xs); i++ {
		if xs[i] < m {
			m = xs[i]
		}
	}
	return m
}


func main() {
	F := []uint64{2, 3, 5}
	var n = len(F)
	OUT := []uint64{
		2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36,
		40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125,
		128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250,
		256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480,
		486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768,
		800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215,
		1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600}

	x := uint64(1)
	ins := make([]T, n)
	outs := make([]T, n)
	xs := make([]uint64, n)
	for i := 0; i < n; i++ {
		ins[i], outs[i] = M(F[i])
		xs[i] = x
	}

	for i := 0; i < len(OUT); i++ {
		for i := 0; i < n; i++ {
			ins[i] <- x
		}

		for i := 0; i < n; i++ {
			if xs[i] == x {
				xs[i] = <-outs[i]
			}
		}

		x = min(xs)
		if x != OUT[i] {
			println("bad: ", x, " should be ", OUT[i])
			panic("235")
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/64bit.go                                                                          0100644 0000000 0000000 00000061521 13020111414 014003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // runoutput

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Generate test of 64-bit arithmetic.
// Most synthesized routines have different cases for
// constants vs variables and even the generated code has
// different cases for large and small constants,
// so try a good range of inputs.

package main

import (
	"bufio"
	"fmt"
	"os"
)

var bout *bufio.Writer

// 64-bit math without using 64-bit numbers,
// so that we can generate the test program even
// if the compiler has buggy or missing 64-bit support.

type Uint64 struct {
	hi	uint32
	lo	uint32
}

type Int64 struct {
	hi	int32
	lo	uint32
}

func (a Uint64) Int64() (c Int64) {
	c.hi = int32(a.hi)
	c.lo = a.lo
	return
}

func (a Uint64) Cmp(b Uint64) int {
	switch {
	case a.hi < b.hi:
		return -1
	case a.hi > b.hi:
		return 1
	case a.lo < b.lo:
		return -1
	case a.lo > b.lo:
		return 1
	}
	return 0
}

func (a Uint64) LeftShift(b uint) (c Uint64) {
	switch {
	case b >= 64:
		c.hi = 0
		c.lo = 0
	case b >= 32:
		c.hi = a.lo << (b - 32)
		c.lo = 0
	default:
		c.hi = a.hi<<b | a.lo>>(32-b)
		c.lo = a.lo << b
	}
	return
}

func (a Uint64) RightShift(b uint) (c Uint64) {
	switch {
	case b >= 64:
		c.hi = 0
		c.lo = a.hi
	case b >= 32:
		c.hi = 0
		c.lo = a.hi >> (b - 32)
	default:
		c.hi = a.hi >> b
		c.lo = a.hi<<(32-b) | a.lo>>b
	}
	return
}

func (a Uint64) LeftShift64(b Uint64) (c Uint64) {
	if b.hi != 0 || b.lo >= 64 {
		return
	}
	return a.LeftShift(uint(b.lo))
}

func (a Uint64) RightShift64(b Uint64) (c Uint64) {
	if b.hi != 0 || b.lo >= 64 {
		return
	}
	return a.RightShift(uint(b.lo))
}

func (a Uint64) Plus(b Uint64) (c Uint64) {
	var carry uint32
	if c.lo = a.lo + b.lo; c.lo < a.lo {
		carry = 1
	}
	c.hi = a.hi + b.hi + carry
	return
}

func (a Uint64) Minus(b Uint64) (c Uint64) {
	var borrow uint32
	if c.lo = a.lo - b.lo; c.lo > a.lo {
		borrow = 1
	}
	c.hi = a.hi - b.hi - borrow
	return
}

func (a Uint64) Neg() (c Uint64) {
	var zero Uint64
	return zero.Minus(a)
}

func (a Uint64) Com() (c Uint64) {
	c.hi = ^a.hi
	c.lo = ^a.lo
	return
}

func (a Uint64) Len() int {
	switch {
	case a.hi != 0:
		for i := 31; i >= 0; i-- {
			if a.hi&(1<<uint(i)) != 0 {
				return i + 1 + 32
			}
		}
	case a.lo != 0:
		for i := 31; i >= 0; i-- {
			if a.lo&(1<<uint(i)) != 0 {
				return i + 1
			}
		}
	}
	return 0
}

func (a Uint64) HasBit(b uint) bool {
	switch {
	case b >= 64:
		return false
	case b >= 32:
		return a.hi&(1<<(b-32)) != 0
	}
	return a.lo&(1<<b) != 0
}

func (a Uint64) Times(b Uint64) (c Uint64) {
	for i := uint(0); i < 64; i++ {
		if b.HasBit(i) {
			c = c.Plus(a.LeftShift(i))
		}
	}
	return
}

func (a Uint64) DivMod(b Uint64) (quo, rem Uint64) {
	n := a.Len() - b.Len()
	if n >= 0 {
		b = b.LeftShift(uint(n))
		for i := 0; i <= n; i++ {
			quo = quo.LeftShift(1)
			if b.Cmp(a) <= 0 {	// b <= a
				quo.lo |= 1
				a = a.Minus(b)
			}
			b = b.RightShift(1)
		}
	}
	rem = a
	return
}

func (a Uint64) And(b Uint64) (c Uint64) {
	c.hi = a.hi & b.hi
	c.lo = a.lo & b.lo
	return
}

func (a Uint64) AndNot(b Uint64) (c Uint64) {
	c.hi = a.hi &^ b.hi
	c.lo = a.lo &^ b.lo
	return
}

func (a Uint64) Or(b Uint64) (c Uint64) {
	c.hi = a.hi | b.hi
	c.lo = a.lo | b.lo
	return
}

func (a Uint64) Xor(b Uint64) (c Uint64) {
	c.hi = a.hi ^ b.hi
	c.lo = a.lo ^ b.lo
	return
}

func (a Uint64) String() string	{ return fmt.Sprintf("%#x%08x", a.hi, a.lo) }

func (a Int64) Uint64() (c Uint64) {
	c.hi = uint32(a.hi)
	c.lo = a.lo
	return
}

func (a Int64) Cmp(b Int64) int {
	// Same body as Uint64.Cmp,
	// but behaves differently
	// because hi is uint32 not int32.
	switch {
	case a.hi < b.hi:
		return -1
	case a.hi > b.hi:
		return 1
	case a.lo < b.lo:
		return -1
	case a.lo > b.lo:
		return 1
	}
	return 0
}

func (a Int64) LeftShift(b uint) (c Int64)	{ return a.Uint64().LeftShift(b).Int64() }

func (a Int64) RightShift(b uint) (c Int64) {
	switch {
	case b >= 64:
		c.hi = a.hi >> 31	// sign extend
		c.lo = uint32(c.hi)
	case b >= 32:
		c.hi = a.hi >> 31	// sign extend
		c.lo = uint32(a.hi >> (b - 32))
	default:
		c.hi = a.hi >> b
		c.lo = uint32(a.hi<<(32-b)) | a.lo>>b
	}
	return
}

func (a Int64) LeftShift64(b Uint64) (c Int64) {
	if b.hi != 0 || b.lo >= 64 {
		return
	}
	return a.LeftShift(uint(b.lo))
}

func (a Int64) RightShift64(b Uint64) (c Int64) {
	if b.hi != 0 || b.lo >= 64 {
		return a.RightShift(64)
	}
	return a.RightShift(uint(b.lo))
}

func (a Int64) Plus(b Int64) (c Int64)	{ return a.Uint64().Plus(b.Uint64()).Int64() }

func (a Int64) Minus(b Int64) (c Int64)	{ return a.Uint64().Minus(b.Uint64()).Int64() }

func (a Int64) Neg() (c Int64)	{ return a.Uint64().Neg().Int64() }

func (a Int64) Com() (c Int64)	{ return a.Uint64().Com().Int64() }

func (a Int64) Times(b Int64) (c Int64)	{ return a.Uint64().Times(b.Uint64()).Int64() }

func (a Int64) DivMod(b Int64) (quo Int64, rem Int64) {
	var zero Int64

	quoSign := +1
	remSign := +1
	if a.Cmp(zero) < 0 {
		quoSign = -1
		remSign = -1
		a = a.Neg()
	}
	if b.Cmp(zero) < 0 {
		quoSign = -quoSign
		b = b.Neg()
	}

	q, r := a.Uint64().DivMod(b.Uint64())
	quo = q.Int64()
	rem = r.Int64()

	if quoSign < 0 {
		quo = quo.Neg()
	}
	if remSign < 0 {
		rem = rem.Neg()
	}
	return
}

func (a Int64) And(b Int64) (c Int64)	{ return a.Uint64().And(b.Uint64()).Int64() }

func (a Int64) AndNot(b Int64) (c Int64)	{ return a.Uint64().AndNot(b.Uint64()).Int64() }

func (a Int64) Or(b Int64) (c Int64)	{ return a.Uint64().Or(b.Uint64()).Int64() }

func (a Int64) Xor(b Int64) (c Int64)	{ return a.Uint64().Xor(b.Uint64()).Int64() }

func (a Int64) String() string {
	if a.hi < 0 {
		return fmt.Sprintf("-%s", a.Neg().Uint64())
	}
	return a.Uint64().String()
}

var int64Values = []Int64{
	Int64{0, 0},
	Int64{0, 1},
	Int64{0, 2},
	Int64{0, 3},
	Int64{0, 100},
	Int64{0, 10001},
	Int64{0, 1<<31 - 1},
	Int64{0, 1 << 31},
	Int64{0, 1<<31 + 1},
	Int64{0, 1<<32 - 1<<30},
	Int64{0, 1<<32 - 1},
	Int64{1, 0},
	Int64{1, 1},
	Int64{2, 0},
	Int64{1<<31 - 1, 1<<32 - 10000},
	Int64{1<<31 - 1, 1<<32 - 1},
	Int64{0x789abcde, 0xf0123456},

	Int64{-1, 1<<32 - 1},
	Int64{-1, 1<<32 - 2},
	Int64{-1, 1<<32 - 3},
	Int64{-1, 1<<32 - 100},
	Int64{-1, 1<<32 - 10001},
	Int64{-1, 1<<32 - (1<<31 - 1)},
	Int64{-1, 1<<32 - 1<<31},
	Int64{-1, 1<<32 - (1<<31 + 1)},
	Int64{-1, 1<<32 - (1<<32 - 1<<30)},
	Int64{-1, 0},
	Int64{-1, 1},
	Int64{-2, 0},
	Int64{-(1 << 31), 10000},
	Int64{-(1 << 31), 1},
	Int64{-(1 << 31), 0},
	Int64{-0x789abcde, 0xf0123456},
}

var uint64Values = []Uint64{
	Uint64{0, 0},
	Uint64{0, 1},
	Uint64{0, 2},
	Uint64{0, 3},
	Uint64{0, 100},
	Uint64{0, 10001},
	Uint64{0, 1<<31 - 1},
	Uint64{0, 1 << 31},
	Uint64{0, 1<<31 + 1},
	Uint64{0, 1<<32 - 1<<30},
	Uint64{0, 1<<32 - 1},
	Uint64{1, 0},
	Uint64{1, 1},
	Uint64{2, 0},
	Uint64{1<<31 - 1, 1<<32 - 10000},
	Uint64{1<<31 - 1, 1<<32 - 1},
	Uint64{1<<32 - 1<<30, 0},
	Uint64{1<<32 - 1, 0},
	Uint64{1<<32 - 1, 1<<32 - 100},
	Uint64{1<<32 - 1, 1<<32 - 1},
	Uint64{0x789abcde, 0xf0123456},
	Uint64{0xfedcba98, 0x76543210},
}

var shiftValues = []Uint64{
	Uint64{0, 0},
	Uint64{0, 1},
	Uint64{0, 2},
	Uint64{0, 3},
	Uint64{0, 15},
	Uint64{0, 16},
	Uint64{0, 17},
	Uint64{0, 31},
	Uint64{0, 32},
	Uint64{0, 33},
	Uint64{0, 61},
	Uint64{0, 62},
	Uint64{0, 63},
	Uint64{0, 64},
	Uint64{0, 65},
	Uint64{0, 1<<32 - 1},
	Uint64{1, 0},
	Uint64{1, 1},
	Uint64{1 << 28, 0},
	Uint64{1 << 31, 0},
	Uint64{1<<32 - 1, 0},
	Uint64{1<<32 - 1, 1<<32 - 1},
}

var ntest = 0

// Part 1 is tests of variable operations; generic functions
// called by repetitive code.  Could make a table but not worth it.

const prolog = "\n" +
	"package main\n" +
	"\n" +
	"import \"os\"\n" +
	"\n" +
	"var ok = true\n" +
	"\n" +
	"func testInt64Unary(a, plus, xor, minus int64) {\n" +
	"	if n, op, want := +a, `+`, plus; n != want { ok=false; println(`int64`, op, a, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := ^a, `^`, xor; n != want { ok=false; println(`int64`, op, a, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := -a, `-`, minus; n != want { ok=false; println(`int64`, op, a, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n" +
	"func testInt64Binary(a, b, add, sub, mul, div, mod, and, or, xor, andnot int64, dodiv bool) {\n" +
	"	if n, op, want := a + b, `+`, add; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a - b, `-`, sub; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a * b, `*`, mul; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if dodiv {\n" +
	"		if n, op, want := a / b, `/`, div; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"		if n, op, want := a % b, `%`, mod; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if n, op, want := a & b, `&`, and; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a | b, `|`, or; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n" +
	"func testInt64Shift(a int64, b uint64, left, right int64) {\n" +
	"	if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\n" +
	"	if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\n" +
	"	if uint64(uint(b)) == b {\n" +
	"		b := uint(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if uint64(uint32(b)) == b {\n" +
	"		b := uint32(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if uint64(uint16(b)) == b {\n" +
	"		b := uint16(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if uint64(uint8(b)) == b {\n" +
	"		b := uint8(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"}\n" +
	"\n" +
	"func testUint64Unary(a, plus, xor, minus uint64) {\n" +
	"	if n, op, want := +a, `+`, plus; n != want { ok=false; println(`uint64`, op, a, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := ^a, `^`, xor; n != want { ok=false; println(`uint64`, op, a, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := -a, `-`, minus; n != want { ok=false; println(`uint64`, op, a, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n" +
	"func testUint64Binary(a, b, add, sub, mul, div, mod, and, or, xor, andnot uint64, dodiv bool) {\n" +
	"	if n, op, want := a + b, `+`, add; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a - b, `-`, sub; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a * b, `*`, mul; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if dodiv {\n" +
	"		if n, op, want := a / b, `/`, div; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"		if n, op, want := a % b, `%`, mod; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if n, op, want := a & b, `&`, and; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a | b, `|`, or; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n" +
	"func testUint64Shift(a, b, left, right uint64) {\n" +
	"	if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\n" +
	"	if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\n" +
	"	if uint64(uint(b)) == b {\n" +
	"		b := uint(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if uint64(uint32(b)) == b {\n" +
	"		b := uint32(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if uint64(uint16(b)) == b {\n" +
	"		b := uint16(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if uint64(uint8(b)) == b {\n" +
	"		b := uint8(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"}\n" +
	"\n"

func varTests() {
	fmt.Fprint(bout, prolog)
	for _, a := range int64Values {
		fmt.Fprintf(bout, "func test%v() {\n", ntest)
		ntest++
		fmt.Fprintf(bout, "\ttestInt64Unary(%v, %v, %v, %v);\n", a, a, a.Com(), a.Neg())
		for _, b := range int64Values {
			var div, mod Int64
			dodiv := false
			var zero Int64
			if b.Cmp(zero) != 0 {	// b != 0
				// Can't divide by zero but also can't divide -0x8000...000 by -1.
				var bigneg = Int64{-0x80000000, 0}
				var minus1 = Int64{-1, ^uint32(0)}
				if a.Cmp(bigneg) != 0 || b.Cmp(minus1) != 0 {	// a != -1<<63 || b != -1
					div, mod = a.DivMod(b)
					dodiv = true
				}
			}
			fmt.Fprintf(bout, "\ttestInt64Binary(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\n",
				a, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,
				a.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)
		}
		for _, b := range shiftValues {
			fmt.Fprintf(bout, "\ttestInt64Shift(%v, %v, %v, %v);\n",
				a, b, a.LeftShift64(b), a.RightShift64(b))
		}
		fmt.Fprintf(bout, "}\n")
	}

	for _, a := range uint64Values {
		fmt.Fprintf(bout, "func test%v() {\n", ntest)
		ntest++
		fmt.Fprintf(bout, "\ttestUint64Unary(%v, %v, %v, %v);\n", a, a, a.Com(), a.Neg())
		for _, b := range uint64Values {
			var div, mod Uint64
			dodiv := false
			var zero Uint64
			if b.Cmp(zero) != 0 {	// b != 0
				div, mod = a.DivMod(b)
				dodiv = true
			}
			fmt.Fprintf(bout, "\ttestUint64Binary(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\n",
				a, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,
				a.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)
		}
		for _, b := range shiftValues {
			fmt.Fprintf(bout, "\ttestUint64Shift(%v, %v, %v, %v);\n",
				a, b, a.LeftShift64(b), a.RightShift64(b))
		}
		fmt.Fprintf(bout, "}\n")
	}
}

// Part 2 is tests of operations involving one variable and one constant.

const binaryConstL = "func test%vBinaryL%v(b, add, sub, mul, div, mod, and, or, xor, andnot %v, dodiv bool) {\n" +
	"	const a %v = %v;\n" +
	"	const typ = `%s`;\n" +
	"	if n, op, want := a + b, `+`, add; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a - b, `-`, sub; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a * b, `*`, mul; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	if dodiv {\n" +
	"		if n, op, want := a / b, `/`, div; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"		if n, op, want := a %% b, `%%`, mod; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if n, op, want := a & b, `&`, and; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a | b, `|`, or; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n"

const binaryConstR = "func test%vBinaryR%v(a, add, sub, mul, div, mod, and, or, xor, andnot %v, dodiv bool) {\n" +
	"	const b %v = %v;\n" +
	"	const typ = `%s`;\n" +
	"	if n, op, want := a + b, `+`, add; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a - b, `-`, sub; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a * b, `*`, mul; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if dodiv {\n" +
	"		if n, op, want := a / b, `/`, div; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"		if n, op, want := a %% b, `%%`, mod; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"	if n, op, want := a & b, `&`, and; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a | b, `|`, or; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n"

const binaryConstR0 = "func test%vBinaryR%v(a, add, sub, mul, div, mod, and, or, xor, andnot %v, dodiv bool) {\n" +
	"	const b %v = %v;\n" +
	"	const typ = `%s`;\n" +
	"	if n, op, want := a + b, `+`, add; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a - b, `-`, sub; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a * b, `*`, mul; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a & b, `&`, and; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a | b, `|`, or; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"	if n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\n" +
	"}\n" +
	"\n"

const shiftConstL = "func test%vShiftL%v(b uint64, left, right %v) {\n" +
	"	const a %v = %v;\n" +
	"	const typ = `%s`;\n" +
	"	if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\n" +
	"	if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\n" +
	"	if uint64(uint32(b)) == b {\n" +
	"		b := uint32(b);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"}\n"

const shiftConstR = "func test%vShiftR%v(a, left, right %v) {\n" +
	"	const b uint64 = %v;\n" +
	"	const typ = `%s`;\n" +
	"	if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\n" +
	"	if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\n" +
	"	if b & 0xffffffff == b {\n" +
	"		const b = uint32(b & 0xffffffff);\n" +
	"		if n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\n" +
	"		if n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\n" +
	"	}\n" +
	"}\n"

func constTests() {
	for i, a := range int64Values {
		fmt.Fprintf(bout, binaryConstL, "Int64", i, "int64", "int64", a, "int64")
		if a.hi == 0 && a.lo == 0 {
			fmt.Fprintf(bout, binaryConstR0, "Int64", i, "int64", "int64", a, "int64")
		} else {
			fmt.Fprintf(bout, binaryConstR, "Int64", i, "int64", "int64", a, "int64")
		}
		fmt.Fprintf(bout, shiftConstL, "Int64", i, "int64", "int64", a, "int64")
	}
	for i, a := range uint64Values {
		fmt.Fprintf(bout, binaryConstL, "Uint64", i, "uint64", "uint64", a, "uint64")
		if a.hi == 0 && a.lo == 0 {
			fmt.Fprintf(bout, binaryConstR0, "Uint64", i, "uint64", "uint64", a, "uint64")
		} else {
			fmt.Fprintf(bout, binaryConstR, "Uint64", i, "uint64", "uint64", a, "uint64")
		}
		fmt.Fprintf(bout, shiftConstL, "Uint64", i, "uint64", "uint64", a, "uint64")
	}
	for i, a := range shiftValues {
		fmt.Fprintf(bout, shiftConstR, "Int64", i, "int64", a, "int64")
		fmt.Fprintf(bout, shiftConstR, "Uint64", i, "uint64", a, "uint64")
	}
	for i, a := range int64Values {
		fmt.Fprintf(bout, "func test%v() {\n", ntest)
		ntest++
		for j, b := range int64Values {
			var div, mod Int64
			dodiv := false
			var zero Int64
			if b.Cmp(zero) != 0 {	// b != 0
				// Can't divide by zero but also can't divide -0x8000...000 by -1.
				var bigneg = Int64{-0x80000000, 0}
				var minus1 = Int64{-1, ^uint32(0)}
				if a.Cmp(bigneg) != 0 || b.Cmp(minus1) != 0 {	// a != -1<<63 || b != -1
					div, mod = a.DivMod(b)
					dodiv = true
				}
			}
			fmt.Fprintf(bout, "\ttestInt64BinaryL%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\n",
				i, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,
				a.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)
			fmt.Fprintf(bout, "\ttestInt64BinaryR%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\n",
				j, a, a.Plus(b), a.Minus(b), a.Times(b), div, mod,
				a.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)
		}
		for j, b := range shiftValues {
			fmt.Fprintf(bout, "\ttestInt64ShiftL%v(%v, %v, %v);\n",
				i, b, a.LeftShift64(b), a.RightShift64(b))
			fmt.Fprintf(bout, "\ttestInt64ShiftR%v(%v, %v, %v);\n",
				j, a, a.LeftShift64(b), a.RightShift64(b))
		}
		fmt.Fprintf(bout, "}\n")
	}
	for i, a := range uint64Values {
		fmt.Fprintf(bout, "func test%v() {\n", ntest)
		ntest++
		for j, b := range uint64Values {
			var div, mod Uint64
			dodiv := false
			var zero Uint64
			if b.Cmp(zero) != 0 {	// b != 0
				div, mod = a.DivMod(b)
				dodiv = true
			}
			fmt.Fprintf(bout, "\ttestUint64BinaryL%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\n",
				i, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,
				a.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)
			fmt.Fprintf(bout, "\ttestUint64BinaryR%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\n",
				j, a, a.Plus(b), a.Minus(b), a.Times(b), div, mod,
				a.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)
		}
		for j, b := range shiftValues {
			fmt.Fprintf(bout, "\ttestUint64ShiftL%v(%v, %v, %v);\n",
				i, b, a.LeftShift64(b), a.RightShift64(b))
			fmt.Fprintf(bout, "\ttestUint64ShiftR%v(%v, %v, %v);\n",
				j, a, a.LeftShift64(b), a.RightShift64(b))
		}
		fmt.Fprintf(bout, "}\n")
	}
}

func main() {
	bout = bufio.NewWriter(os.Stdout)
	varTests()
	constTests()

	fmt.Fprintf(bout, "func main() {\n")
	for i := 0; i < ntest; i++ {
		fmt.Fprintf(bout, "\ttest%v();\n", i)
	}
	fmt.Fprintf(bout, "\tif !ok { os.Exit(1) }\n")
	fmt.Fprintf(bout, "}\n")
	bout.Flush()
}
                                                                                                                                                                               usr/local/go/test/alias.go                                                                          0100644 0000000 0000000 00000001115 13020111414 014135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that error messages say what the source file says
// (uint8 vs byte, int32 vs. rune).
// Does not compile.

package main

import (
	"fmt"
	"unicode/utf8"
)

func f(byte)  {}
func g(uint8) {}

func main() {
	var x float64
	f(x) // ERROR "byte"
	g(x) // ERROR "uint8"

	// Test across imports.

	var ff fmt.Formatter
	var fs fmt.State
	ff.Format(fs, x) // ERROR "rune"

	utf8.RuneStart(x) // ERROR "byte"
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/test/alias1.go                                                                         0100644 0000000 0000000 00000001444 13020111414 014223  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that dynamic interface checks treat byte=uint8
// and rune=int or rune=int32.

package main

func main() {
	var x interface{}

	x = byte(1)
	switch x.(type) {
	case uint8:
		// ok
	default:
		panic("byte != uint8")
	}

	x = uint8(2)
	switch x.(type) {
	case byte:
		// ok
	default:
		panic("uint8 != byte")
	}

	rune32 := false
	x = rune(3)
	switch x.(type) {
	case int:
		// ok
	case int32:
		// must be new code
		rune32 = true
	default:
		panic("rune != int and rune != int32")
	}

	if rune32 {
		x = int32(4)
	} else {
		x = int(5)
	}
	switch x.(type) {
	case rune:
		// ok
	default:
		panic("int (or int32) != rune")
	}
}
                                                                                                                                                                                                                            usr/local/go/test/append.go                                                                         0100644 0000000 0000000 00000020732 13020111414 014321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Semi-exhaustive test for the append predeclared function.

package main

import (
	"fmt"
	"reflect"
)


func verify(name string, result, expected interface{}) {
	if !reflect.DeepEqual(result, expected) {
		panic(name)
	}
}


func main() {
	for _, t := range tests {
		verify(t.name, t.result, t.expected)
	}
	verifyStruct()
	verifyInterface()
	verifyType()
}


var tests = []struct {
	name             string
	result, expected interface{}
}{
	{"bool a", append([]bool{}), []bool{}},
	{"bool b", append([]bool{}, true), []bool{true}},
	{"bool c", append([]bool{}, true, false, true, true), []bool{true, false, true, true}},

	{"bool d", append([]bool{true, false, true}), []bool{true, false, true}},
	{"bool e", append([]bool{true, false, true}, false), []bool{true, false, true, false}},
	{"bool f", append([]bool{true, false, true}, false, false, false), []bool{true, false, true, false, false, false}},

	{"bool g", append([]bool{}, []bool{true}...), []bool{true}},
	{"bool h", append([]bool{}, []bool{true, false, true, false}...), []bool{true, false, true, false}},

	{"bool i", append([]bool{true, false, true}, []bool{true}...), []bool{true, false, true, true}},
	{"bool j", append([]bool{true, false, true}, []bool{true, true, true}...), []bool{true, false, true, true, true, true}},


	{"byte a", append([]byte{}), []byte{}},
	{"byte b", append([]byte{}, 0), []byte{0}},
	{"byte c", append([]byte{}, 0, 1, 2, 3), []byte{0, 1, 2, 3}},

	{"byte d", append([]byte{0, 1, 2}), []byte{0, 1, 2}},
	{"byte e", append([]byte{0, 1, 2}, 3), []byte{0, 1, 2, 3}},
	{"byte f", append([]byte{0, 1, 2}, 3, 4, 5), []byte{0, 1, 2, 3, 4, 5}},

	{"byte g", append([]byte{}, []byte{0}...), []byte{0}},
	{"byte h", append([]byte{}, []byte{0, 1, 2, 3}...), []byte{0, 1, 2, 3}},

	{"byte i", append([]byte{0, 1, 2}, []byte{3}...), []byte{0, 1, 2, 3}},
	{"byte j", append([]byte{0, 1, 2}, []byte{3, 4, 5}...), []byte{0, 1, 2, 3, 4, 5}},

	{"bytestr a", append([]byte{}, "0"...), []byte("0")},
	{"bytestr b", append([]byte{}, "0123"...), []byte("0123")},

	{"bytestr c", append([]byte("012"), "3"...), []byte("0123")},
	{"bytestr d", append([]byte("012"), "345"...), []byte("012345")},

	{"int16 a", append([]int16{}), []int16{}},
	{"int16 b", append([]int16{}, 0), []int16{0}},
	{"int16 c", append([]int16{}, 0, 1, 2, 3), []int16{0, 1, 2, 3}},

	{"int16 d", append([]int16{0, 1, 2}), []int16{0, 1, 2}},
	{"int16 e", append([]int16{0, 1, 2}, 3), []int16{0, 1, 2, 3}},
	{"int16 f", append([]int16{0, 1, 2}, 3, 4, 5), []int16{0, 1, 2, 3, 4, 5}},

	{"int16 g", append([]int16{}, []int16{0}...), []int16{0}},
	{"int16 h", append([]int16{}, []int16{0, 1, 2, 3}...), []int16{0, 1, 2, 3}},

	{"int16 i", append([]int16{0, 1, 2}, []int16{3}...), []int16{0, 1, 2, 3}},
	{"int16 j", append([]int16{0, 1, 2}, []int16{3, 4, 5}...), []int16{0, 1, 2, 3, 4, 5}},


	{"uint32 a", append([]uint32{}), []uint32{}},
	{"uint32 b", append([]uint32{}, 0), []uint32{0}},
	{"uint32 c", append([]uint32{}, 0, 1, 2, 3), []uint32{0, 1, 2, 3}},

	{"uint32 d", append([]uint32{0, 1, 2}), []uint32{0, 1, 2}},
	{"uint32 e", append([]uint32{0, 1, 2}, 3), []uint32{0, 1, 2, 3}},
	{"uint32 f", append([]uint32{0, 1, 2}, 3, 4, 5), []uint32{0, 1, 2, 3, 4, 5}},

	{"uint32 g", append([]uint32{}, []uint32{0}...), []uint32{0}},
	{"uint32 h", append([]uint32{}, []uint32{0, 1, 2, 3}...), []uint32{0, 1, 2, 3}},

	{"uint32 i", append([]uint32{0, 1, 2}, []uint32{3}...), []uint32{0, 1, 2, 3}},
	{"uint32 j", append([]uint32{0, 1, 2}, []uint32{3, 4, 5}...), []uint32{0, 1, 2, 3, 4, 5}},


	{"float64 a", append([]float64{}), []float64{}},
	{"float64 b", append([]float64{}, 0), []float64{0}},
	{"float64 c", append([]float64{}, 0, 1, 2, 3), []float64{0, 1, 2, 3}},

	{"float64 d", append([]float64{0, 1, 2}), []float64{0, 1, 2}},
	{"float64 e", append([]float64{0, 1, 2}, 3), []float64{0, 1, 2, 3}},
	{"float64 f", append([]float64{0, 1, 2}, 3, 4, 5), []float64{0, 1, 2, 3, 4, 5}},

	{"float64 g", append([]float64{}, []float64{0}...), []float64{0}},
	{"float64 h", append([]float64{}, []float64{0, 1, 2, 3}...), []float64{0, 1, 2, 3}},

	{"float64 i", append([]float64{0, 1, 2}, []float64{3}...), []float64{0, 1, 2, 3}},
	{"float64 j", append([]float64{0, 1, 2}, []float64{3, 4, 5}...), []float64{0, 1, 2, 3, 4, 5}},


	{"complex128 a", append([]complex128{}), []complex128{}},
	{"complex128 b", append([]complex128{}, 0), []complex128{0}},
	{"complex128 c", append([]complex128{}, 0, 1, 2, 3), []complex128{0, 1, 2, 3}},

	{"complex128 d", append([]complex128{0, 1, 2}), []complex128{0, 1, 2}},
	{"complex128 e", append([]complex128{0, 1, 2}, 3), []complex128{0, 1, 2, 3}},
	{"complex128 f", append([]complex128{0, 1, 2}, 3, 4, 5), []complex128{0, 1, 2, 3, 4, 5}},

	{"complex128 g", append([]complex128{}, []complex128{0}...), []complex128{0}},
	{"complex128 h", append([]complex128{}, []complex128{0, 1, 2, 3}...), []complex128{0, 1, 2, 3}},

	{"complex128 i", append([]complex128{0, 1, 2}, []complex128{3}...), []complex128{0, 1, 2, 3}},
	{"complex128 j", append([]complex128{0, 1, 2}, []complex128{3, 4, 5}...), []complex128{0, 1, 2, 3, 4, 5}},


	{"string a", append([]string{}), []string{}},
	{"string b", append([]string{}, "0"), []string{"0"}},
	{"string c", append([]string{}, "0", "1", "2", "3"), []string{"0", "1", "2", "3"}},

	{"string d", append([]string{"0", "1", "2"}), []string{"0", "1", "2"}},
	{"string e", append([]string{"0", "1", "2"}, "3"), []string{"0", "1", "2", "3"}},
	{"string f", append([]string{"0", "1", "2"}, "3", "4", "5"), []string{"0", "1", "2", "3", "4", "5"}},

	{"string g", append([]string{}, []string{"0"}...), []string{"0"}},
	{"string h", append([]string{}, []string{"0", "1", "2", "3"}...), []string{"0", "1", "2", "3"}},

	{"string i", append([]string{"0", "1", "2"}, []string{"3"}...), []string{"0", "1", "2", "3"}},
	{"string j", append([]string{"0", "1", "2"}, []string{"3", "4", "5"}...), []string{"0", "1", "2", "3", "4", "5"}},
}


func verifyStruct() {
	type T struct {
		a, b, c string
	}
	type S []T
	e := make(S, 100)
	for i := range e {
		e[i] = T{"foo", fmt.Sprintf("%d", i), "bar"}
	}

	verify("struct a", append(S{}), S{})
	verify("struct b", append(S{}, e[0]), e[0:1])
	verify("struct c", append(S{}, e[0], e[1], e[2]), e[0:3])

	verify("struct d", append(e[0:1]), e[0:1])
	verify("struct e", append(e[0:1], e[1]), e[0:2])
	verify("struct f", append(e[0:1], e[1], e[2], e[3]), e[0:4])

	verify("struct g", append(e[0:3]), e[0:3])
	verify("struct h", append(e[0:3], e[3]), e[0:4])
	verify("struct i", append(e[0:3], e[3], e[4], e[5], e[6]), e[0:7])

	for i := range e {
		verify("struct j", append(S{}, e[0:i]...), e[0:i])
		input := make(S, i)
		copy(input, e[0:i])
		verify("struct k", append(input, e[i:]...), e)
		verify("struct k - input modified", input, e[0:i])
	}

	s := make(S, 10, 20)
	r := make(S, len(s)+len(e))
	for i, x := range e {
		r[len(s)+i] = x
	}
	verify("struct l", append(s), s)
	verify("struct m", append(s, e...), r)
}


func verifyInterface() {
	type T interface{}
	type S []T
	e := make(S, 100)
	for i := range e {
		switch i % 4 {
		case 0:
			e[i] = i
		case 1:
			e[i] = "foo"
		case 2:
			e[i] = fmt.Sprintf("%d", i)
		case 3:
			e[i] = float64(i)
		}
	}

	verify("interface a", append(S{}), S{})
	verify("interface b", append(S{}, e[0]), e[0:1])
	verify("interface c", append(S{}, e[0], e[1], e[2]), e[0:3])

	verify("interface d", append(e[0:1]), e[0:1])
	verify("interface e", append(e[0:1], e[1]), e[0:2])
	verify("interface f", append(e[0:1], e[1], e[2], e[3]), e[0:4])

	verify("interface g", append(e[0:3]), e[0:3])
	verify("interface h", append(e[0:3], e[3]), e[0:4])
	verify("interface i", append(e[0:3], e[3], e[4], e[5], e[6]), e[0:7])

	for i := range e {
		verify("interface j", append(S{}, e[0:i]...), e[0:i])
		input := make(S, i)
		copy(input, e[0:i])
		verify("interface k", append(input, e[i:]...), e)
		verify("interface k - input modified", input, e[0:i])
	}

	s := make(S, 10, 20)
	r := make(S, len(s)+len(e))
	for i, x := range e {
		r[len(s)+i] = x
	}
	verify("interface l", append(s), s)
	verify("interface m", append(s, e...), r)
}

type T1 []int
type T2 []int

func verifyType() {
	// The second argument to append has type []E where E is the
	// element type of the first argument.  Test that the compiler
	// accepts two slice types that meet that requirement but are
	// not assignment compatible.  The return type of append is
	// the type of the first argument.
	t1 := T1{1}
	t2 := T2{2}
	verify("T1", append(t1, t2...), T1{1, 2})
}
                                      usr/local/go/test/args.go                                                                           0100644 0000000 0000000 00000000566 13020111414 014011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run arg1 arg2

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test os.Args.

package main

import "os"

func main() {
	if len(os.Args) != 3 {
		panic("argc")
	}
	if os.Args[1] != "arg1" {
		panic("arg1")
	}
	if os.Args[2] != "arg2" {
		panic("arg2")
	}
}
                                                                                                                                          usr/local/go/test/assign.go                                                                         0100644 0000000 0000000 00000001717 13020111414 014340  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify simple assignment errors are caught by the compiler.
// Does not compile.

package main

import "sync"

type T struct {
	int
	sync.Mutex
}

func main() {
	{
		var x, y sync.Mutex
		x = y // ok
		_ = x
	}
	{
		var x, y T
		x = y // ok
		_ = x
	}
	{
		var x, y [2]sync.Mutex
		x = y // ok
		_ = x
	}
	{
		var x, y [2]T
		x = y // ok
		_ = x
	}
	{
		x := sync.Mutex{0, 0} // ERROR "assignment.*Mutex"
		_ = x
	}
	{
		x := sync.Mutex{key: 0} // ERROR "(unknown|assignment).*Mutex"
		_ = x
	}
	{
		x := &sync.Mutex{} // ok
		var y sync.Mutex   // ok
		y = *x             // ok
		*x = y             // ok
		_ = x
		_ = y
	}
	{
		var x = 1
		{
			x, x := 2, 3 // ERROR "x repeated on left side of :="
			_ = x
		}
		_ = x
	}
	{
		a, a := 1, 2 // ERROR "a repeated on left side of :="
		_ = a
	}
}
                                                 usr/local/go/test/assign1.go                                                                        0100644 0000000 0000000 00000013066 13020111414 014421  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify assignment rules are enforced by the compiler.
// Does not compile.

package main

type (
	A [10]int
	B []int
	C chan int
	F func() int
	I interface {
		m() int
	}
	M map[int]int
	P *int
	S struct {
		X int
	}

	A1 [10]int
	B1 []int
	C1 chan int
	F1 func() int
	I1 interface {
		m() int
	}
	M1 map[int]int
	P1 *int
	S1 struct {
		X int
	}
)

var (
	a0 [10]int
	b0 []int
	c0 chan int
	f0 func() int
	i0 interface {
		m() int
	}
	m0 map[int]int
	p0 *int
	s0 struct {
		X int
	}

	a A
	b B
	c C
	f F
	i I
	m M
	p P
	s S

	a1 A1
	b1 B1
	c1 C1
	f1 F1
	i1 I1
	m1 M1
	p1 P1
	s1 S1

	pa0 *[10]int
	pb0 *[]int
	pc0 *chan int
	pf0 *func() int
	pi0 *interface {
		m() int
	}
	pm0 *map[int]int
	pp0 **int
	ps0 *struct {
		X int
	}

	pa *A
	pb *B
	pc *C
	pf *F
	pi *I
	pm *M
	pp *P
	ps *S

	pa1 *A1
	pb1 *B1
	pc1 *C1
	pf1 *F1
	pi1 *I1
	pm1 *M1
	pp1 *P1
	ps1 *S1
)

func main() {
	a0 = a
	a0 = a1
	a = a0
	a = a1 // ERROR "cannot use"
	a1 = a0
	a1 = a // ERROR "cannot use"

	b0 = b
	b0 = b1
	b = b0
	b = b1 // ERROR "cannot use"
	b1 = b0
	b1 = b // ERROR "cannot use"

	c0 = c
	c0 = c1
	c = c0
	c = c1 // ERROR "cannot use"
	c1 = c0
	c1 = c // ERROR "cannot use"

	f0 = f
	f0 = f1
	f = f0
	f = f1 // ERROR "cannot use"
	f1 = f0
	f1 = f // ERROR "cannot use"

	i0 = i
	i0 = i1
	i = i0
	i = i1
	i1 = i0
	i1 = i

	m0 = m
	m0 = m1
	m = m0
	m = m1 // ERROR "cannot use"
	m1 = m0
	m1 = m // ERROR "cannot use"

	p0 = p
	p0 = p1
	p = p0
	p = p1 // ERROR "cannot use"
	p1 = p0
	p1 = p // ERROR "cannot use"

	s0 = s
	s0 = s1
	s = s0
	s = s1 // ERROR "cannot use"
	s1 = s0
	s1 = s // ERROR "cannot use"

	pa0 = pa  // ERROR "cannot use|incompatible"
	pa0 = pa1 // ERROR "cannot use|incompatible"
	pa = pa0  // ERROR "cannot use|incompatible"
	pa = pa1  // ERROR "cannot use|incompatible"
	pa1 = pa0 // ERROR "cannot use|incompatible"
	pa1 = pa  // ERROR "cannot use|incompatible"

	pb0 = pb  // ERROR "cannot use|incompatible"
	pb0 = pb1 // ERROR "cannot use|incompatible"
	pb = pb0  // ERROR "cannot use|incompatible"
	pb = pb1  // ERROR "cannot use|incompatible"
	pb1 = pb0 // ERROR "cannot use|incompatible"
	pb1 = pb  // ERROR "cannot use|incompatible"

	pc0 = pc  // ERROR "cannot use|incompatible"
	pc0 = pc1 // ERROR "cannot use|incompatible"
	pc = pc0  // ERROR "cannot use|incompatible"
	pc = pc1  // ERROR "cannot use|incompatible"
	pc1 = pc0 // ERROR "cannot use|incompatible"
	pc1 = pc  // ERROR "cannot use|incompatible"

	pf0 = pf  // ERROR "cannot use|incompatible"
	pf0 = pf1 // ERROR "cannot use|incompatible"
	pf = pf0  // ERROR "cannot use|incompatible"
	pf = pf1  // ERROR "cannot use|incompatible"
	pf1 = pf0 // ERROR "cannot use|incompatible"
	pf1 = pf  // ERROR "cannot use|incompatible"

	pi0 = pi  // ERROR "cannot use|incompatible"
	pi0 = pi1 // ERROR "cannot use|incompatible"
	pi = pi0  // ERROR "cannot use|incompatible"
	pi = pi1  // ERROR "cannot use|incompatible"
	pi1 = pi0 // ERROR "cannot use|incompatible"
	pi1 = pi  // ERROR "cannot use|incompatible"

	pm0 = pm  // ERROR "cannot use|incompatible"
	pm0 = pm1 // ERROR "cannot use|incompatible"
	pm = pm0  // ERROR "cannot use|incompatible"
	pm = pm1  // ERROR "cannot use|incompatible"
	pm1 = pm0 // ERROR "cannot use|incompatible"
	pm1 = pm  // ERROR "cannot use|incompatible"

	pp0 = pp  // ERROR "cannot use|incompatible"
	pp0 = pp1 // ERROR "cannot use|incompatible"
	pp = pp0  // ERROR "cannot use|incompatible"
	pp = pp1  // ERROR "cannot use|incompatible"
	pp1 = pp0 // ERROR "cannot use|incompatible"
	pp1 = pp  // ERROR "cannot use|incompatible"

	ps0 = ps  // ERROR "cannot use|incompatible"
	ps0 = ps1 // ERROR "cannot use|incompatible"
	ps = ps0  // ERROR "cannot use|incompatible"
	ps = ps1  // ERROR "cannot use|incompatible"
	ps1 = ps0 // ERROR "cannot use|incompatible"
	ps1 = ps  // ERROR "cannot use|incompatible"


	a0 = [10]int(a)
	a0 = [10]int(a1)
	a = A(a0)
	a = A(a1)
	a1 = A1(a0)
	a1 = A1(a)

	b0 = []int(b)
	b0 = []int(b1)
	b = B(b0)
	b = B(b1)
	b1 = B1(b0)
	b1 = B1(b)

	c0 = chan int(c)
	c0 = chan int(c1)
	c = C(c0)
	c = C(c1)
	c1 = C1(c0)
	c1 = C1(c)

	f0 = func() int(f)
	f0 = func() int(f1)
	f = F(f0)
	f = F(f1)
	f1 = F1(f0)
	f1 = F1(f)

	i0 = interface {
		m() int
	}(i)
	i0 = interface {
		m() int
	}(i1)
	i = I(i0)
	i = I(i1)
	i1 = I1(i0)
	i1 = I1(i)

	m0 = map[int]int(m)
	m0 = map[int]int(m1)
	m = M(m0)
	m = M(m1)
	m1 = M1(m0)
	m1 = M1(m)

	p0 = (*int)(p)
	p0 = (*int)(p1)
	p = P(p0)
	p = P(p1)
	p1 = P1(p0)
	p1 = P1(p)

	s0 = struct {
		X int
	}(s)
	s0 = struct {
		X int
	}(s1)
	s = S(s0)
	s = S(s1)
	s1 = S1(s0)
	s1 = S1(s)

	pa0 = (*[10]int)(pa)
	pa0 = (*[10]int)(pa1)
	pa = (*A)(pa0)
	pa = (*A)(pa1)
	pa1 = (*A1)(pa0)
	pa1 = (*A1)(pa)

	pb0 = (*[]int)(pb)
	pb0 = (*[]int)(pb1)
	pb = (*B)(pb0)
	pb = (*B)(pb1)
	pb1 = (*B1)(pb0)
	pb1 = (*B1)(pb)

	pc0 = (*chan int)(pc)
	pc0 = (*chan int)(pc1)
	pc = (*C)(pc0)
	pc = (*C)(pc1)
	pc1 = (*C1)(pc0)
	pc1 = (*C1)(pc)

	pf0 = (*func() int)(pf)
	pf0 = (*func() int)(pf1)
	pf = (*F)(pf0)
	pf = (*F)(pf1)
	pf1 = (*F1)(pf0)
	pf1 = (*F1)(pf)

	pi0 = (*interface {
		m() int
	})(pi)
	pi0 = (*interface {
		m() int
	})(pi1)
	pi = (*I)(pi0)
	pi = (*I)(pi1)
	pi1 = (*I1)(pi0)
	pi1 = (*I1)(pi)

	pm0 = (*map[int]int)(pm)
	pm0 = (*map[int]int)(pm1)
	pm = (*M)(pm0)
	pm = (*M)(pm1)
	pm1 = (*M1)(pm0)
	pm1 = (*M1)(pm)

	pp0 = (**int)(pp)
	pp0 = (**int)(pp1)
	pp = (*P)(pp0)
	pp = (*P)(pp1)
	pp1 = (*P1)(pp0)
	pp1 = (*P1)(pp)

	ps0 = (*struct {
		X int
	})(ps)
	ps0 = (*struct {
		X int
	})(ps1)
	ps = (*S)(ps0)
	ps = (*S)(ps1)
	ps1 = (*S1)(ps0)
	ps1 = (*S1)(ps)

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/go/test/bench/                                                                            0040755 0000000 0000000 00000000000 13020111414 013601  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/bench/garbage/                                                                    0040755 0000000 0000000 00000000000 13020111414 015171  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/bench/garbage/Makefile                                                            0100644 0000000 0000000 00000000505 13020111414 016626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2010 The Go Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

ALL=\
	parser\
	peano\
	tree\
	tree2\

all: $(ALL)

%: %.go
	go build $*.go stats.go

%.bench: %
	time ./$*

bench: $(addsuffix .bench, $(ALL))

clean:
	rm -f $(ALL)

                                                                                                                                                                                           usr/local/go/test/bench/garbage/parser.go                                                           0100644 0000000 0000000 00000013463 13020111414 017020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Garbage collection benchmark: parse Go packages repeatedly.

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"net/http"
	_ "net/http/pprof"
	"os"
	"path"
	"runtime"
	"strings"
	"time"
)

var serve = flag.String("serve", "", "serve http on this address at end")

func isGoFile(dir os.FileInfo) bool {
	return !dir.IsDir() &&
		!strings.HasPrefix(dir.Name(), ".") && // ignore .files
		path.Ext(dir.Name()) == ".go"
}

func isPkgFile(dir os.FileInfo) bool {
	return isGoFile(dir) &&
		!strings.HasSuffix(dir.Name(), "_test.go") // ignore test files
}

func pkgName(filename string) string {
	file, err := parser.ParseFile(token.NewFileSet(), filename, nil, parser.PackageClauseOnly)
	if err != nil || file == nil {
		return ""
	}
	return file.Name.Name
}

func parseDir(dirpath string) map[string]*ast.Package {
	// the package name is the directory name within its parent
	// (use dirname instead of path because dirname is clean; i.e. has no trailing '/')
	_, pkgname := path.Split(dirpath)

	// filter function to select the desired .go files
	filter := func(d os.FileInfo) bool {
		if isPkgFile(d) {
			// Some directories contain main packages: Only accept
			// files that belong to the expected package so that
			// parser.ParsePackage doesn't return "multiple packages
			// found" errors.
			// Additionally, accept the special package name
			// fakePkgName if we are looking at cmd documentation.
			name := pkgName(dirpath + "/" + d.Name())
			return name == pkgname
		}
		return false
	}

	// get package AST
	pkgs, err := parser.ParseDir(token.NewFileSet(), dirpath, filter, parser.ParseComments)
	if err != nil {
		println("parse", dirpath, err.Error())
		panic("fail")
	}
	return pkgs
}

func main() {
	st := new(runtime.MemStats)
	packages = append(packages, packages...)
	packages = append(packages, packages...)
	n := flag.Int("n", 4, "iterations")
	p := flag.Int("p", len(packages), "# of packages to keep in memory")
	flag.BoolVar(&st.DebugGC, "d", st.DebugGC, "print GC debugging info (pause times)")
	flag.Parse()

	var lastParsed []map[string]*ast.Package
	var t0 time.Time
	var numGC uint32
	var pauseTotalNs uint64
	pkgroot := runtime.GOROOT() + "/src/"
	for pass := 0; pass < 2; pass++ {
		// Once the heap is grown to full size, reset counters.
		// This hides the start-up pauses, which are much smaller
		// than the normal pauses and would otherwise make
		// the average look much better than it actually is.
		runtime.ReadMemStats(st)
		numGC = st.NumGC
		pauseTotalNs = st.PauseTotalNs
		t0 = time.Now()

		for i := 0; i < *n; i++ {
			parsed := make([]map[string]*ast.Package, *p)
			for j := range parsed {
				parsed[j] = parseDir(pkgroot + packages[j%len(packages)])
			}
			if i+1 == *n && *serve != "" {
				lastParsed = parsed
			}
		}
		runtime.GC()
		runtime.GC()
	}
	t1 := time.Now()

	runtime.ReadMemStats(st)
	st.NumGC -= numGC
	st.PauseTotalNs -= pauseTotalNs
	fmt.Printf("Alloc=%d/%d Heap=%d Mallocs=%d PauseTime=%.3f/%d = %.3f\n",
		st.Alloc, st.TotalAlloc,
		st.Sys,
		st.Mallocs, float64(st.PauseTotalNs)/1e9,
		st.NumGC, float64(st.PauseTotalNs)/1e9/float64(st.NumGC))

	/*
		fmt.Printf("%10s %10s %10s\n", "size", "#alloc", "#free")
		for _, s := range st.BySize {
			fmt.Printf("%10d %10d %10d\n", s.Size, s.Mallocs, s.Frees)
		}
	*/
	// Standard gotest benchmark output, collected by build dashboard.
	gcstats("BenchmarkParser", *n, t1.Sub(t0))

	if *serve != "" {
		log.Fatal(http.ListenAndServe(*serve, nil))
		println(lastParsed)
	}
}

// find . -type d -not -path "./exp" -not -path "./exp/*" -printf "\t\"%p\",\n" | sort | sed "s/\.\///" | grep -v testdata
var packages = []string{
	"archive",
	"archive/tar",
	"archive/zip",
	"bufio",
	"builtin",
	"bytes",
	"compress",
	"compress/bzip2",
	"compress/flate",
	"compress/gzip",
	"compress/lzw",
	"compress/zlib",
	"container",
	"container/heap",
	"container/list",
	"container/ring",
	"crypto",
	"crypto/aes",
	"crypto/cipher",
	"crypto/des",
	"crypto/dsa",
	"crypto/ecdsa",
	"crypto/elliptic",
	"crypto/hmac",
	"crypto/md5",
	"crypto/rand",
	"crypto/rc4",
	"crypto/rsa",
	"crypto/sha1",
	"crypto/sha256",
	"crypto/sha512",
	"crypto/subtle",
	"crypto/tls",
	"crypto/x509",
	"crypto/x509/pkix",
	"database",
	"database/sql",
	"database/sql/driver",
	"debug",
	"debug/dwarf",
	"debug/elf",
	"debug/gosym",
	"debug/macho",
	"debug/pe",
	"encoding",
	"encoding/ascii85",
	"encoding/asn1",
	"encoding/base32",
	"encoding/base64",
	"encoding/binary",
	"encoding/csv",
	"encoding/gob",
	"encoding/hex",
	"encoding/json",
	"encoding/pem",
	"encoding/xml",
	"errors",
	"expvar",
	"flag",
	"fmt",
	"go",
	"go/ast",
	"go/build",
	"go/doc",
	"go/format",
	"go/parser",
	"go/printer",
	"go/scanner",
	"go/token",
	"hash",
	"hash/adler32",
	"hash/crc32",
	"hash/crc64",
	"hash/fnv",
	"html",
	"html/template",
	"image",
	"image/color",
	"image/draw",
	"image/gif",
	"image/jpeg",
	"image/png",
	"index",
	"index/suffixarray",
	"io",
	"io/ioutil",
	"log",
	"log/syslog",
	"math",
	"math/big",
	"math/cmplx",
	"math/rand",
	"mime",
	"mime/multipart",
	"net",
	"net/http",
	"net/http/cgi",
	"net/http/cookiejar",
	"net/http/fcgi",
	"net/http/httptest",
	"net/http/httputil",
	"net/http/pprof",
	"net/mail",
	"net/rpc",
	"net/rpc/jsonrpc",
	"net/smtp",
	"net/textproto",
	"net/url",
	"os",
	"os/exec",
	"os/signal",
	"os/user",
	"path",
	"path/filepath",
	"reflect",
	"regexp",
	"regexp/syntax",
	"runtime",
	"runtime/cgo",
	"runtime/debug",
	"runtime/pprof",
	"runtime/race",
	"sort",
	"strconv",
	"strings",
	"sync",
	"sync/atomic",
	"syscall",
	"testing",
	"testing/iotest",
	"testing/quick",
	"text",
	"text/scanner",
	"text/tabwriter",
	"text/template",
	"text/template/parse",
	"time",
	"unicode",
	"unicode/utf16",
	"unicode/utf8",
	"unsafe",
}
                                                                                                                                                                                                             usr/local/go/test/bench/garbage/peano.go                                                            0100644 0000000 0000000 00000003766 13020111414 016633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"runtime"
	"time"
)

type Number struct {
	next *Number
}

// -------------------------------------
// Peano primitives

func zero() *Number { return nil }

func is_zero(x *Number) bool { return x == nil }

func add1(x *Number) *Number {
	e := new(Number)
	e.next = x
	return e
}

func sub1(x *Number) *Number { return x.next }

func add(x, y *Number) *Number {
	if is_zero(y) {
		return x
	}

	return add(add1(x), sub1(y))
}

func mul(x, y *Number) *Number {
	if is_zero(x) || is_zero(y) {
		return zero()
	}

	return add(mul(x, sub1(y)), x)
}

func fact(n *Number) *Number {
	if is_zero(n) {
		return add1(zero())
	}

	return mul(fact(sub1(n)), n)
}

// -------------------------------------
// Helpers to generate/count Peano integers

func gen(n int) *Number {
	if n > 0 {
		return add1(gen(n - 1))
	}

	return zero()
}

func count(x *Number) int {
	if is_zero(x) {
		return 0
	}

	return count(sub1(x)) + 1
}

func check(x *Number, expected int) {
	var c = count(x)
	if c != expected {
		panic(fmt.Sprintf("error: found %d; expected %d", c, expected))
	}
}

// -------------------------------------
// Test basic functionality

func verify() {
	check(zero(), 0)
	check(add1(zero()), 1)
	check(gen(10), 10)

	check(add(gen(3), zero()), 3)
	check(add(zero(), gen(4)), 4)
	check(add(gen(3), gen(4)), 7)

	check(mul(zero(), zero()), 0)
	check(mul(gen(3), zero()), 0)
	check(mul(zero(), gen(4)), 0)
	check(mul(gen(3), add1(zero())), 3)
	check(mul(add1(zero()), gen(4)), 4)
	check(mul(gen(3), gen(4)), 12)

	check(fact(zero()), 1)
	check(fact(add1(zero())), 1)
	check(fact(gen(5)), 120)
}

// -------------------------------------
// Factorial

func main() {
	t0 := time.Now()
	verify()
	for i := 0; i <= 9; i++ {
		print(i, "! = ", count(fact(gen(i))), "\n")
	}
	runtime.GC()
	t1 := time.Now()

	gcstats("BenchmarkPeano", 1, t1.Sub(t0))
}
          usr/local/go/test/bench/garbage/stats.go                                                            0100644 0000000 0000000 00000002774 13020111414 016665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"runtime"
	"sort"
	"time"
)

func gcstats(name string, n int, t time.Duration) {
	st := new(runtime.MemStats)
	runtime.ReadMemStats(st)
	nprocs := runtime.GOMAXPROCS(-1)
	cpus := ""
	if nprocs != 1 {
		cpus = fmt.Sprintf("-%d", nprocs)
	}
	fmt.Printf("garbage.%sMem%s Alloc=%d/%d Heap=%d NextGC=%d Mallocs=%d\n", name, cpus, st.Alloc, st.TotalAlloc, st.Sys, st.NextGC, st.Mallocs)
	fmt.Printf("garbage.%s%s %d %d ns/op\n", name, cpus, n, t.Nanoseconds()/int64(n))
	fmt.Printf("garbage.%sLastPause%s 1 %d ns/op\n", name, cpus, st.PauseNs[(st.NumGC-1)%uint32(len(st.PauseNs))])
	fmt.Printf("garbage.%sPause%s %d %d ns/op\n", name, cpus, st.NumGC, int64(st.PauseTotalNs)/int64(st.NumGC))
	nn := int(st.NumGC)
	if nn >= len(st.PauseNs) {
		nn = len(st.PauseNs)
	}
	t1, t2, t3, t4, t5 := tukey5(st.PauseNs[0:nn])
	fmt.Printf("garbage.%sPause5%s: %d %d %d %d %d\n", name, cpus, t1, t2, t3, t4, t5)

	//	fmt.Printf("garbage.%sScan: %v\n", name, st.ScanDist)
}

type T []uint64

func (t T) Len() int           { return len(t) }
func (t T) Swap(i, j int)      { t[i], t[j] = t[j], t[i] }
func (t T) Less(i, j int) bool { return t[i] < t[j] }

func tukey5(raw []uint64) (lo, q1, q2, q3, hi uint64) {
	x := make(T, len(raw))
	copy(x, raw)
	sort.Sort(T(x))
	lo = x[0]
	q1 = x[len(x)/4]
	q2 = x[len(x)/2]
	q3 = x[len(x)*3/4]
	hi = x[len(x)-1]
	return
}
    usr/local/go/test/bench/garbage/tree.go                                                             0100644 0000000 0000000 00000005770 13020111414 016465  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    * Neither the name of "The Computer Language Benchmarks Game" nor the
    name of "The Computer Language Shootout Benchmarks" nor the names of
    its contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
*/

/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by The Go Authors.
 * based on C program by Kevin Carson
 */

package main

import (
	"flag"
	"fmt"
	"time"
)

var n = flag.Int("n", 16, "depth")

type Node struct {
	item        int
	left, right *Node
}

func bottomUpTree(item, depth int) *Node {
	if depth <= 0 {
		return &Node{item: item}
	}
	return &Node{item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1)}
}

func (n *Node) itemCheck() int {
	if n.left == nil {
		return n.item
	}
	return n.item + n.left.itemCheck() - n.right.itemCheck()
}

const minDepth = 4

func main() {
	flag.Parse()

	t0 := time.Now()

	maxDepth := *n
	if minDepth+2 > *n {
		maxDepth = minDepth + 2
	}
	stretchDepth := maxDepth + 1

	check := bottomUpTree(0, stretchDepth).itemCheck()
	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check)

	longLivedTree := bottomUpTree(0, maxDepth)

	for depth := minDepth; depth <= maxDepth; depth += 2 {
		iterations := 1 << uint(maxDepth-depth+minDepth)
		check = 0

		for i := 1; i <= iterations; i++ {
			check += bottomUpTree(i, depth).itemCheck()
			check += bottomUpTree(-i, depth).itemCheck()
		}
		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check)
	}
	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck())

	t1 := time.Now()

	// Standard gotest benchmark output, collected by build dashboard.
	gcstats("BenchmarkTree", *n, t1.Sub(t0))
}
        usr/local/go/test/bench/garbage/tree2.go                                                            0100644 0000000 0000000 00000004243 13020111414 016541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"runtime"
	"runtime/pprof"
	"time"
	"unsafe"
)

const BranchingFactor = 4

type Object struct {
	child [BranchingFactor]*Object
}

var (
	cpus       = flag.Int("cpus", 1, "number of cpus to use")
	heapsize   = flag.Int64("heapsize", 100*1024*1024, "size of the heap in bytes")
	cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

	lastPauseNs uint64 = 0
	lastFree    uint64 = 0
	heap        *Object
	calls       [20]int
	numobjects  int64
	memstats    runtime.MemStats
)

func buildHeap() {
	objsize := int64(unsafe.Sizeof(Object{}))
	heap, _ = buildTree(float64(objsize), float64(*heapsize), 0)
	fmt.Printf("*** built heap: %.0f MB; (%d objects * %d bytes)\n",
		float64(*heapsize)/1048576, numobjects, objsize)
}

func buildTree(objsize, size float64, depth int) (*Object, float64) {
	calls[depth]++
	x := &Object{}
	numobjects++
	subtreeSize := (size - objsize) / BranchingFactor
	alloc := objsize
	for i := 0; i < BranchingFactor && alloc < size; i++ {
		c, n := buildTree(objsize, subtreeSize, depth+1)
		x.child[i] = c
		alloc += n
	}
	return x, alloc
}

func gc() {
	runtime.GC()
	runtime.ReadMemStats(&memstats)
	pause := memstats.PauseTotalNs
	inuse := memstats.Alloc
	free := memstats.TotalAlloc - inuse
	fmt.Printf("gc pause: %8.3f ms; collect: %8.0f MB; heapsize: %8.0f MB\n",
		float64(pause-lastPauseNs)/1e6,
		float64(free-lastFree)/1048576,
		float64(inuse)/1048576)
	lastPauseNs = pause
	lastFree = free
}

func main() {
	flag.Parse()
	buildHeap()
	runtime.GOMAXPROCS(*cpus)
	runtime.ReadMemStats(&memstats)
	lastPauseNs = memstats.PauseTotalNs
	lastFree = memstats.TotalAlloc - memstats.Alloc
	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}
	const N = 10
	var t0 time.Time
	for i := 0; i < N; i++ {
		t0 = time.Now()
		gc()
	}
	// Standard gotest benchmark output, collected by build dashboard.
	gcstats("BenchmarkTree2", N, time.Now().Sub(t0))
}
                                                                                                                                                                                                                                                                                                                                                             usr/local/go/test/bench/go1/                                                                        0040755 0000000 0000000 00000000000 13020111414 014267  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/bench/go1/binarytree_test.go                                                      0100644 0000000 0000000 00000003106 13020111414 020016  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark, taken from the shootout, tests garbage collector
// performance by generating and discarding large binary trees.

package go1

import "testing"

type binaryNode struct {
	item        int
	left, right *binaryNode
}

func bottomUpTree(item, depth int) *binaryNode {
	if depth <= 0 {
		return &binaryNode{item: item}
	}
	return &binaryNode{item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1)}
}

func (n *binaryNode) itemCheck() int {
	if n.left == nil {
		return n.item
	}
	return n.item + n.left.itemCheck() - n.right.itemCheck()
}

const minDepth = 4

func binarytree(n int) {
	maxDepth := n
	if minDepth+2 > n {
		maxDepth = minDepth + 2
	}
	stretchDepth := maxDepth + 1

	check := bottomUpTree(0, stretchDepth).itemCheck()
	//fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check)

	longLivedTree := bottomUpTree(0, maxDepth)

	for depth := minDepth; depth <= maxDepth; depth += 2 {
		iterations := 1 << uint(maxDepth-depth+minDepth)
		check = 0

		for i := 1; i <= iterations; i++ {
			check += bottomUpTree(i, depth).itemCheck()
			check += bottomUpTree(-i, depth).itemCheck()
		}
		//fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check)
	}
	longLivedTree.itemCheck()
	//fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck())
}

func BenchmarkBinaryTree17(b *testing.B) {
	for i := 0; i < b.N; i++ {
		binarytree(17)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/go/test/bench/go1/fannkuch_test.go                                                        0100644 0000000 0000000 00000002741 13020111414 017453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark, taken from the shootout, tests array indexing
// and array bounds elimination performance.

package go1

import "testing"

func fannkuch(n int) int {
	if n < 1 {
		return 0
	}

	n1 := n - 1
	perm := make([]int, n)
	perm1 := make([]int, n)
	count := make([]int, n)

	for i := 0; i < n; i++ {
		perm1[i] = i // initial (trivial) permutation
	}

	r := n
	didpr := 0
	flipsMax := 0
	for {
		if didpr < 30 {
			didpr++
		}
		for ; r != 1; r-- {
			count[r-1] = r
		}

		if perm1[0] != 0 && perm1[n1] != n1 {
			flips := 0
			for i := 1; i < n; i++ { // perm = perm1
				perm[i] = perm1[i]
			}
			k := perm1[0] // cache perm[0] in k
			for {         // k!=0 ==> k>0
				for i, j := 1, k-1; i < j; i, j = i+1, j-1 {
					perm[i], perm[j] = perm[j], perm[i]
				}
				flips++
				// Now exchange k (caching perm[0]) and perm[k]... with care!
				j := perm[k]
				perm[k] = k
				k = j
				if k == 0 {
					break
				}
			}
			if flipsMax < flips {
				flipsMax = flips
			}
		}

		for ; r < n; r++ {
			// rotate down perm[0..r] by one
			perm0 := perm1[0]
			for i := 0; i < r; i++ {
				perm1[i] = perm1[i+1]
			}
			perm1[r] = perm0
			count[r]--
			if count[r] > 0 {
				break
			}
		}
		if r == n {
			return flipsMax
		}
	}
	return 0
}

func BenchmarkFannkuch11(b *testing.B) {
	for i := 0; i < b.N; i++ {
		fannkuch(11)
	}
}
                               usr/local/go/test/bench/go1/fasta_test.go                                                           0100644 0000000 0000000 00000007227 13020111414 016760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package go1

import "runtime"

// Not a benchmark; input for revcomp.

var fastabytes = makefasta()

func makefasta() []byte {
	var n int = 25e6
	if runtime.GOARCH == "arm" {
		// TODO(dfc) remove this limitation after precise gc.
		// A value of 25e6 consumes 465mb of heap on 32bit 
		// platforms, which is too much for most ARM systems. 
		// A value of 25e5 produces a memory layout that 
		// confuses the gc on 32bit platforms. So 25e4 it is.
		n = 25e4
	}
	return fasta(n)
}

func fasta(n int) []byte {
	out := make(fastaBuffer, 0, 11*n)

	iub := []fastaAcid{
		{prob: 0.27, sym: 'a'},
		{prob: 0.12, sym: 'c'},
		{prob: 0.12, sym: 'g'},
		{prob: 0.27, sym: 't'},
		{prob: 0.02, sym: 'B'},
		{prob: 0.02, sym: 'D'},
		{prob: 0.02, sym: 'H'},
		{prob: 0.02, sym: 'K'},
		{prob: 0.02, sym: 'M'},
		{prob: 0.02, sym: 'N'},
		{prob: 0.02, sym: 'R'},
		{prob: 0.02, sym: 'S'},
		{prob: 0.02, sym: 'V'},
		{prob: 0.02, sym: 'W'},
		{prob: 0.02, sym: 'Y'},
	}

	homosapiens := []fastaAcid{
		{prob: 0.3029549426680, sym: 'a'},
		{prob: 0.1979883004921, sym: 'c'},
		{prob: 0.1975473066391, sym: 'g'},
		{prob: 0.3015094502008, sym: 't'},
	}

	alu := []byte(
		"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" +
			"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" +
			"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" +
			"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" +
			"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" +
			"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" +
			"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA")

	out.WriteString(">ONE Homo sapiens alu\n")
	fastaRepeat(&out, alu, 2*n)
	out.WriteString(">TWO IUB ambiguity codes\n")
	fastaRandom(&out, iub, 3*n)
	out.WriteString(">THREE Homo sapiens frequency\n")
	fastaRandom(&out, homosapiens, 5*n)
	return out
}

type fastaBuffer []byte

func (b *fastaBuffer) Flush() {
	panic("flush")
}

func (b *fastaBuffer) WriteString(s string) {
	p := b.NextWrite(len(s))
	copy(p, s)
}

func (b *fastaBuffer) NextWrite(n int) []byte {
	p := *b
	if len(p)+n > cap(p) {
		b.Flush()
		p = *b
	}
	out := p[len(p) : len(p)+n]
	*b = p[:len(p)+n]
	return out
}

const fastaLine = 60

func fastaRepeat(out *fastaBuffer, alu []byte, n int) {
	buf := append(alu, alu...)
	off := 0
	for n > 0 {
		m := n
		if m > fastaLine {
			m = fastaLine
		}
		buf1 := out.NextWrite(m + 1)
		copy(buf1, buf[off:])
		buf1[m] = '\n'
		if off += m; off >= len(alu) {
			off -= len(alu)
		}
		n -= m
	}
}

const (
	fastaLookupSize          = 4096
	fastaLookupScale float64 = fastaLookupSize - 1
)

var fastaRand uint32 = 42

type fastaAcid struct {
	sym   byte
	prob  float64
	cprob float64
	next  *fastaAcid
}

func fastaComputeLookup(acid []fastaAcid) *[fastaLookupSize]*fastaAcid {
	var lookup [fastaLookupSize]*fastaAcid
	var p float64
	for i := range acid {
		p += acid[i].prob
		acid[i].cprob = p * fastaLookupScale
		if i > 0 {
			acid[i-1].next = &acid[i]
		}
	}
	acid[len(acid)-1].cprob = 1.0 * fastaLookupScale

	j := 0
	for i := range lookup {
		for acid[j].cprob < float64(i) {
			j++
		}
		lookup[i] = &acid[j]
	}

	return &lookup
}

func fastaRandom(out *fastaBuffer, acid []fastaAcid, n int) {
	const (
		IM = 139968
		IA = 3877
		IC = 29573
	)
	lookup := fastaComputeLookup(acid)
	for n > 0 {
		m := n
		if m > fastaLine {
			m = fastaLine
		}
		buf := out.NextWrite(m + 1)
		f := fastaLookupScale / IM
		myrand := fastaRand
		for i := 0; i < m; i++ {
			myrand = (myrand*IA + IC) % IM
			r := float64(int(myrand)) * f
			a := lookup[int(r)]
			for a.cprob < r {
				a = a.next
			}
			buf[i] = a.sym
		}
		fastaRand = myrand
		buf[m] = '\n'
		n -= m
	}
}
                                                                                                                                                                                                                                                                                                                                                                         usr/local/go/test/bench/go1/fmt_test.go                                                             0100644 0000000 0000000 00000002556 13020111414 016450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package go1

// benchmark based on fmt/fmt_test.go

import (
	"bytes"
	"fmt"
	"testing"
)

func BenchmarkFmtFprintfEmpty(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		fmt.Fprintf(&buf, "")
	}
}

func BenchmarkFmtFprintfString(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		fmt.Fprintf(&buf, "%s", "hello")
	}
}

func BenchmarkFmtFprintfInt(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		fmt.Fprintf(&buf, "%d", 5)
	}
}

func BenchmarkFmtFprintfIntInt(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		fmt.Fprintf(&buf, "%d %d", 5, 6)
	}
}

func BenchmarkFmtFprintfPrefixedInt(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		fmt.Fprintf(&buf, "This is some meaningless prefix text that needs to be scanned %d", 6)
	}
}

func BenchmarkFmtFprintfFloat(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		fmt.Fprintf(&buf, "%g", 5.23184)
	}
}

func BenchmarkFmtManyArgs(b *testing.B) {
	var buf bytes.Buffer
	for i := 0; i < b.N; i++ {
		buf.Reset()
		fmt.Fprintf(&buf, "%2d/%2d/%2d %d:%d:%d %s %s\n", 3, 4, 5, 11, 12, 13, "hello", "world")
	}
}
                                                                                                                                                  usr/local/go/test/bench/go1/gob_test.go                                                             0100644 0000000 0000000 00000003416 13020111414 016425  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark tests gob encoding and decoding performance.

package go1

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"io/ioutil"
	"log"
	"reflect"
	"testing"
)

var (
	gobbytes []byte
	gobdata  *JSONResponse
)

func init() {
	gobdata = gobResponse(&jsondata)

	var buf bytes.Buffer
	if err := gob.NewEncoder(&buf).Encode(gobdata); err != nil {
		panic(err)
	}
	gobbytes = buf.Bytes()

	var r JSONResponse
	if err := gob.NewDecoder(bytes.NewBuffer(gobbytes)).Decode(&r); err != nil {
		panic(err)
	}
	if !reflect.DeepEqual(gobdata, &r) {
		log.Printf("%v\n%v", jsondata, r)
		b, _ := json.Marshal(&jsondata)
		br, _ := json.Marshal(&r)
		log.Printf("%s\n%s\n", b, br)
		panic("gob: encode+decode lost data")
	}
}

// gob turns [] into null, so make a copy of the data structure like that
func gobResponse(r *JSONResponse) *JSONResponse {
	return &JSONResponse{gobNode(r.Tree), r.Username}
}

func gobNode(n *JSONNode) *JSONNode {
	n1 := new(JSONNode)
	*n1 = *n
	if len(n1.Kids) == 0 {
		n1.Kids = nil
	} else {
		for i, k := range n1.Kids {
			n1.Kids[i] = gobNode(k)
		}
	}
	return n1
}

func gobdec() {
	if gobbytes == nil {
		panic("gobdata not initialized")
	}
	var r JSONResponse
	if err := gob.NewDecoder(bytes.NewBuffer(gobbytes)).Decode(&r); err != nil {
		panic(err)
	}
	_ = r
}

func gobenc() {
	if err := gob.NewEncoder(ioutil.Discard).Encode(&gobdata); err != nil {
		panic(err)
	}
}

func BenchmarkGobDecode(b *testing.B) {
	b.SetBytes(int64(len(gobbytes)))
	for i := 0; i < b.N; i++ {
		gobdec()
	}
}

func BenchmarkGobEncode(b *testing.B) {
	b.SetBytes(int64(len(gobbytes)))
	for i := 0; i < b.N; i++ {
		gobenc()
	}
}
                                                                                                                                                                                                                                                  usr/local/go/test/bench/go1/gzip_test.go                                                            0100644 0000000 0000000 00000002040 13020111414 016617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark tests gzip and gunzip performance.

package go1

import (
	"bytes"
	gz "compress/gzip"
	"io"
	"io/ioutil"
	"testing"
)

var (
	jsongunz = bytes.Repeat(jsonbytes, 10)
	jsongz   []byte
)

func init() {
	var buf bytes.Buffer
	c := gz.NewWriter(&buf)
	c.Write(jsongunz)
	c.Close()
	jsongz = buf.Bytes()
}

func gzip() {
	c := gz.NewWriter(ioutil.Discard)
	if _, err := c.Write(jsongunz); err != nil {
		panic(err)
	}
	if err := c.Close(); err != nil {
		panic(err)
	}
}

func gunzip() {
	r, err := gz.NewReader(bytes.NewBuffer(jsongz))
	if err != nil {
		panic(err)
	}
	if _, err := io.Copy(ioutil.Discard, r); err != nil {
		panic(err)
	}
	r.Close()
}

func BenchmarkGzip(b *testing.B) {
	b.SetBytes(int64(len(jsongunz)))
	for i := 0; i < b.N; i++ {
		gzip()
	}
}

func BenchmarkGunzip(b *testing.B) {
	b.SetBytes(int64(len(jsongunz)))
	for i := 0; i < b.N; i++ {
		gunzip()
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/local/go/test/bench/go1/http_test.go                                                            0100644 0000000 0000000 00000001701 13020111414 016630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package go1

import (
	"bytes"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

// BenchmarkHTTPClientServer benchmarks both the HTTP client and the HTTP server,
// on small requests.
func BenchmarkHTTPClientServer(b *testing.B) {
	msg := []byte("Hello world.\n")
	ts := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		rw.Write(msg)
	}))
	defer ts.Close()

	tr := &http.Transport{}
	defer tr.CloseIdleConnections()
	cl := &http.Client{
		Transport: tr,
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		res, err := cl.Get(ts.URL)
		if err != nil {
			b.Fatal("Get:", err)
		}
		all, err := ioutil.ReadAll(res.Body)
		if err != nil {
			b.Fatal("ReadAll:", err)
		}
		if !bytes.Equal(all, msg) {
			b.Fatalf("Got body %q; want %q", all, msg)
		}
	}
}
                                                               usr/local/go/test/bench/go1/json_test.go                                                            0100644 0000000 0000000 00000003204 13020111414 016622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark tests JSON encoding and decoding performance.

package go1

import (
	"bytes"
	"compress/bzip2"
	"encoding/base64"
	"encoding/json"
	"io"
	"io/ioutil"
	"testing"
)

var (
	jsonbytes = makeJsonBytes()
	jsondata  = makeJsonData()
)

func makeJsonBytes() []byte {
	var r io.Reader
	r = bytes.NewReader(bytes.Replace(jsonbz2_base64, []byte{'\n'}, nil, -1))
	r = base64.NewDecoder(base64.StdEncoding, r)
	r = bzip2.NewReader(r)
	b, err := ioutil.ReadAll(r)
	if err != nil {
		panic(err)
	}
	return b
}

func makeJsonData() JSONResponse {
	var v JSONResponse
	if err := json.Unmarshal(jsonbytes, &v); err != nil {
		panic(err)
	}
	return v
}

type JSONResponse struct {
	Tree     *JSONNode `json:"tree"`
	Username string    `json:"username"`
}

type JSONNode struct {
	Name     string      `json:"name"`
	Kids     []*JSONNode `json:"kids"`
	CLWeight float64     `json:"cl_weight"`
	Touches  int         `json:"touches"`
	MinT     int64       `json:"min_t"`
	MaxT     int64       `json:"max_t"`
	MeanT    int64       `json:"mean_t"`
}

func jsondec() {
	var r JSONResponse
	if err := json.Unmarshal(jsonbytes, &r); err != nil {
		panic(err)
	}
	_ = r
}

func jsonenc() {
	buf, err := json.Marshal(&jsondata)
	if err != nil {
		panic(err)
	}
	_ = buf
}

func BenchmarkJSONEncode(b *testing.B) {
	b.SetBytes(int64(len(jsonbytes)))
	for i := 0; i < b.N; i++ {
		jsonenc()
	}
}

func BenchmarkJSONDecode(b *testing.B) {
	b.SetBytes(int64(len(jsonbytes)))
	for i := 0; i < b.N; i++ {
		jsondec()
	}
}
                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/bench/go1/jsondata_test.go                                                        0100644 0000000 0000000 00000346144 13020111414 017471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Input for JSON and other benchmarks.
// This was generated by starting with a 2MB JSON file with actual data
// about open source revision history, then compressing with bzip2 -9,
// then encoding to base64 with openssl enc -e -base64.
// The result is 125kB of source instead of 2MB.
// We compile the data into the binary so that the benchmark is
// a stand-alone binary that can be copied easily from machine to
// machine.  json_test.go decodes this during init.

package go1

var jsonbz2_base64 = []byte(`
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
5dVzU58rFtJ4e3yv9l6buQsjiD1R2Np9hTyeTt6+038W47SRy6PY06E+P3JOgWaQ
hHAkkR/Xh/2ncXif2afyf4Svf5NvY3/UP3JXCqfaxkZRL/J3CPDzFxNGAzKcQTnd
cHPayzzbvLxDd1UnVvMbTw9BywcPDfsc2zm/nyMfDmf932T7p87KrxgyeFftQ+tf
Cfh7HZyeE2aj8Ld3bXw43xb83/u3I6WSftIeD/xbZE/8bwT5H1OjB9vDc2fr8Q+u
397X9Gf+PSdnVOzpP8PP+c7z52c3SP5Gtkn9kn/w7H1cp+5o+HrPZPv7uTykTn4t
qMW5ktlnN5X7r3/GJDMMmGVMJN7siu/yfnqffmvSXMu6ft6bOJlTaKqp/L3k/g2n
c/7fv5SH4e7wSNdHTnGSe7brKd9m2+rfs+75c1sWpbaXqOkkpTo6LvZVDoKaaPJd
rf6/wabfy//P+Ses/dNe1Wv4P05eaf0Xg/vluP7Okm/5eu4+LJMnvJ6vyfdiuNK0
Wbn2ZOW7k/O5dVV1S0twqcn6SMKzp/2y3c5D8U7EssiWcxtqybtlfi2p2J1xcn7G
nI/NwcrP+tfj8/scv7QZ8v3tjkfXsw7Hk28PhyNkcPY3e7To4dLZXs52SnOcp+0v
BzIaa0rMZV/r4j+X7dHd5OqeK/l2Ng6ZCf3R4MsiMaozClqv621/Cfwfp/G2c4GO
dLV9XSfLMq1YzWaxrDFXxLOJ3YfCa+Wpzeb8XWTm+JzP+IICf93/kNaqLaNrWSqi
ttajRqjbapmqtpS2qxVk1bUlWpNqLRWpZqtJNKo1U0ttRsy20zVJqrG2wBY1sVoL
FUWJs1ikLFTK0am2RVFYUrYNFpNtTCoNYjWpaFbG0TKLTDY1RrJSWwCVU1K0mkrG
yUpUbZDVikMW0bZkYotZMmZGLRsY0KIViLGjRsUWxtRUzFiTQaisJEzIaWTNYIjU
RhTZsyUWxsUUlY2oyRsm1G1k1MhLM2Q2gWRRMpDGE0zA0ktFBaZGyBETCCMgSEaj
EWjaJKU2NqZFooxiokSIyMMUIWEaiMhQoIiiqQmIYEkRhFpEhYqSGCLFCKEMEEGT
9mvzf2fuM6SFZC4Qd9fugRia8BBCIvlh/UPmUoYBieRgSMiPA/zM5kG80OwWXxVB
kDKCgX+vVRm/7UQIDInnOZ/vuDq/4D8+p51Kq1Jw/kWTzvI4d9a7SyLfWstuvCsR
8vO+Ve9WpNJv7s7+fuL8JV+dboUuDPzER7chJZ58smGb6bfHJ+/wytuIdr6d7a47
bq+tvU9ubKTxSujpWpbkOGArKSYHFiSSfHgG2RPcG5lSlkRGbrdlTVFVeA1pC41W
V8XE0QYWbMrorO7DWTBoBRpgyaqKdSFItuzQ+QpmRRpSUkgkAkgVhutQk5vCYVVC
2pCBtTYcnZA1HRmQ5KEKUJCjE441UykKrp04rW12EaksMjEqCmiOKKAiIoVAjHHG
4Oy2vMLFphr2skmltbAj2yHto+/C1qRSHQI0oYJy4xPAK0hBhkBkzKGIDKfqR5fu
9Rb6jriPwFfrT57/BORRUS2uxaWe/23vw/VDRJUNDKbcoql9hR1STaoUKFJAhAE0
AZZLjCTR5qxIgYLhyUQktqwQ0LakMUoDZaYvf1dL7/UTZGZSt/h0bF8bOrkShINm
UC5JVQoULQdWFmExZOwxx6b/nrJEIzcATXe9RX4uAjQuZbT7+8dvCcTe970nE51j
cmac2WktrRIBr8KKqmFiShChQWsTPnID4M0CSyZe7rltE0/bIvrM+YcPthAH85JJ
219mY5mjPQZhiZDYZA1DzBlAjUcjXvLL8BABMGVQh/A/vPwUfqX/5kl6UGGJn8FC
P2GG+QceVRTNvxzts75paBK7NzM7TzVVUzlIqqif8NJKRImR08cg2cHrQWxKYcNh
OjnHzz+YPyaL9PWNrPR37fFaHr23fpcy+YYGWlsuQf4q7bXFjzjZ66t5DEnZsqLU
ixYlKiy0ibZsjalZamaizKs1laSpmk2ratltZbWSta0bazUrFJs0ttalazaQUhKg
lSUAqyQoWSKtotVYtSmoyW220arUsoo1tpLaNtMsmtaaYsVTbS2UtJgram22rCkS
qQSxISyQS0FSSyM1KaS2laa0lhNFGhYWigRULZFiyykqoCxFBKRFSItCrIUWLKak
ppY2WbY2tps1pm2ymqbabbLNiZojaZkrFMKZrKzaWVptZtppijZNM2SzKmmxsRab
LZs2K1NVqWqEzMlJtmqVRjVNZWllSVLM0LNNZpalZokSlltLasJRUqopUpZIElIE
lkqrYjVi0aSNqWmLKpslJtFRBbSbbMy1KoplRspaNlNUrNUaaak2mpVFTZVGxk2a
GTSWmzaCpKbNJW2WqWqKMmNk1GkKUtk2ysrLNs2WwyrMqKpqZmmmKxtmqayKZlUk
qNltKlRSm2StUtbLWxTNUqlspo1ZtltNKRIqGm0tlRtNmmalNGZYybMozNNKkxpI
2i2ULJqUrGyyxJslNGpZmtNSsrNWZY222yttmrVNTbWZZMms2lllbKstpmrNMUmp
KqUtptKyaplKbRSbJbLNplZtqM1KKbabU1ZSUAmUaxpZjUkhUmyZmxbRSltNsrMq
qVbNtslSptEzVrMqaazNpmkqZsxExpJSk1itlWqay1KppYopMUkkkmbLNlMymsxS
0TKlNjKbA1TLLLU0lTWalTNMilKmys2ZY2mqViUVKSyksmapVNqSJRqxZSyylMlS
yLFSWRUliWKLJPR487tzxPbvpf6y887/zT6h9UmfSx2PLPXLE2t67TNb+d8616jt
tPkeNmjOnd2bULjnN/5x19I3dES+7KaAHB8sg9OaIHogcFmowcPkd56v4UKiqJhg
oAU9AHxYiJSboAuO2tYkauzYowUsXVGVlc0nYOpihEKtGCELstXcQR40ZwxcKms+
7pFjCoGnlWDFSsNDI2M37zbDfLv3avdlnZZ+BC52UzTjZKLth+XpejoaOcVlvLIp
Bt0bICZGx12W3MemDI+BEABpXP87P4rJiq/on3ucmKl3H2qkVoDOXeBVIHThRlRW
oIeneSsFb5P81QBgJOLBARAX3nH8/r/f8w3ilqIGYIs2ETpWjUrVBz3ap+abPKWH
pLM3ltPx/+N/Wbt1NbzHN6yn49NkVXLjHsi0YsxWYxt0mpP5liJ0D/BK861JPxVJ
KrrKd1DEsjkf2fd+E1sqc+0G02nKaZP3/wWYV/JKhVSKU/9f2kP+Es6z7k/gUksW
JYe1an/921pBsrUdXyfSH+6h3N4k/jE5ItS1VTkajSXnZgf5UtgpKk2jaxZibyd4
83LeR6x6+RPw/T0lWWVLOy4k54wllqVWtTTUvHd5G6VXZwcLVpZCyOySqT/VUqI2
a3OjB+BJ/c5vJ17xaYezrA2WTu8JipWJ34en5WSThOGGFkqslgxWw1Riyit2TjUk
4m2SJs+3WFSYNQcR9lN+j4j1noP93VyHCfI7cNMSZzH2ZNRThulseIk/yU5KdXt9
v7zmbk+gjtO690cSQSoFfmmeBxfI+vqGsirzNH5C+xTw2WGGHE0X+u176U0uLoPT
OEn+qsbDvaA4s+lX8EqpJzPrH0sloeXR1c9OiqmXer0zgSe5ZrT6ScTDZPxHCbPN
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
am6yrFq3COr+Gv1fkE1ZskzBUlfkrr8b8hzk8yxE2fNMfNrmi187J8z+Bmx2Wzuo
upumHT834f0K/hL3SkSzQ2U85TkrZYbKMVKVsprfbMMsmUWyWP1W3DVjWss1MNMa
H1WP6OTaGllrnZoiAS6ssfNp5sy3o6d+z1Phfsunc9WPbpmXPm3eqbeJ3nCllcoS
R9y0sQeiKPWxdMHSL5yAm6DOmnZx9/de80IwLgMAwP8AgoIErJWSGzBhMaRbyCyG
/KI3YnIr+zatN5zJm9iJx5FlEPllZszjniMMODP1NDhIdNGSUoDpyr2MFiNFAp7m
dhmsM3rn7xcKDPsQKdNOmEcqRWE10Vn0f5jdKeQdD+sX9BD/gPSY95PtG5r5T0HY
ruV86045uEMRVSihTsyZa8MesmkTJVlLKqkjBRhG+JG9NNZ4h9alqTnNfxllQNGA
0GINwKMDY0ZDqh5V+GFsqw2G6lfuxMZjyPPPVzVO+/y341ul3m+NvxltY2IqNsRY
1tTEiANRtZmKiypqJVJKtpSltTk/sPm7/O/dRNKm7YOQYxq6uWOcR7KE3fYnBOUc
rZ8tbxGpQnw+T1h+E9UnrJ+6E4e77/fdEqziI7b4QxqWvgPVY2JuUihvCTzqWzax
J8k0/ueZNn2cHv/723l7vkvl321HbIYegUM+f6eVz7iFR6+P17uMwF+AHuHwfOrG
7J7tnlJLoqxiJZp7OkanzOMm8/JPR9k3N9px0iV2kiN/2MZWOp+Dmehw93hD9FiR
9EvPnH5sfKX5VzOWREnZyUU+va6YuauVpl1jSzGGKqpqKIOVA2BEIIMpS3xoVbiJ
DZ+4+ep9reEaqbrqJ9X9jOrrvJSr+/C3LCqZIomMTTGl5droWwvUnqT7fVasJ7Q3
Vdshbp9jH8pBJ6bD2U+Cd/hZbX9ay6kU8KxTu8ttbZlm1Zpptjy1hjMVabYxkKUR
gyjKMrbFpVVpilVWFxd4lsXb8MOW7fVipDJxhwVyRmzTVLLxkzco2dz5NnmsjnxG
SQ0xLOUGItVGqYkjaPOd1ixXJ8pvAbHrxPhNAgJ168Kvepi5THZi1Orm5ld4ad8r
162e8Lnx2rLKuWUXYSACKn+0Q+UPkiWkUT/jy4+mbc//nw1tlzru26a16nw/ipmj
oukAwgMmggdSKdGbGU/Iprgvjn77Ct2WhTTOcy5KZMORZMZRWwQ6QquGZW1JTVlg
QmM8osKKGDGMJIGMIBsiwhShSkqxMPy+3NPLDrbgVBbDqzyCBgWZKJrEQiRzR54q
wia4gUepCJo2SzrcVXl3bH+sTOvr0qFHlmMYpGEQaiFZjEgQmdarIu7T2kdmRlAF
SkKsnConJTZVYwmzOAdnDjWUlQbpLqEmzOttyWq429ehDBlMRRpyaUji5o2uW/LZ
8wQgAFSMYB0Wdnuk9X8nH0naSH9JI+g9o2Gzu5nUVw9VrujeRN048OjNoP8LOjhS
uG/rTtFPk8g307qhpyc48W4wop6dLpbpG62VarE1XE8iOyVK9ztXvOYw0JoSwJZJ
Ftfft+V8JibSreNomUqaifeYC3fJ5fCnZQIMR8DDQUIxtbZGzGjKKNDyRspoqZqZ
ossZ6UUDMFZKUgwYwsMaaYqaYrCr66wtypjY2abpVSX/mXeSNkaJPqgQhw2mmMjH
EHymdzJLzYsvmuuvVbsqy6m7aYqyZnGoerqj3UePiyIVZIoqKthYOZ6vGFsYpWJz
5ns4SY/yi4BSSyktv0dXbf1b1fl9fp9+36YjGvdRRMDFkx6Pp9wzFt1H2f0Y5CMb
VjGyUszErxN3k9ks0S1Zk8IeitT1VrI3R37ye53Th502X+9254a+co8o7nMnWdCi
wosHYmvktSVSyC6P4FSTb4evj8e+aNQ/gr3by2tmlU3bI5CjjaesCuuOTInFMxR6
BGGiWW1NjQqsYxKUlU0qtak2QF9FdGkKOPTjiqoqd6H0PuA+KaOAwX65yfbt0Uu2
t+9+OvxwswtdK+Z6T46z9ur6JavYqrVySsYUxinbay2mTZRVK1bWMy8Hm/TRaetZ
W+L6HJ1GI7KbTEnokj3nzVNViyloqqryY4aU20msYtW5mTfBtWDH/fMFA6MUxGMR
NFAuSNrZk1GrtLMg2RpFCqVUaUsYRZMiN2Nim9bnyPI1L5d7amo7nk142ZMm73SJ
/eoPU902bpY5T5yQ6ffJkrLbKvs844reynK6fNsroOIGSOqTdhDZO0IlkpYiq6Oz
Fkc0U/fPTYvU9bxWXZeLi5F902sZZU2ysGSmlVu0qcXTGyX5KS21VKrYw87pVnOc
iN204sTwOM8R5cJLXpE8sT3gdCaTqejSJPFnanubqkqvQ5+EkEjrFki/syRPSKqx
ixHNf1x69+Xp6t6l5LGF8d0xI7umlRgxkIYgsKQGahBGMdwkbbIclCjg2oW00iZA
hDSVAoDGhqhIDTC4UGjDNVSwINaWT7/c+6B936RGV91beaH+tFpClUqVar6a57xS
1YsdOxwxj98iTq3teHw5yT2NnV6Ms+s+NR8b24bKw/NWKKqqZhiqnM8QftpfQb+C
Vs3lZLSSASqcfM7yVxGYledbnrN50XJBATYaCsBtFYJlZR2SKwb21+jqRiNFI0Sa
rSjgiATZnWelW7O0mbziCfju7ylzo7WSqylsYp0JpjJU0qaMlJUUVhGilWTZudCx
M+kc+l5uTSG84qLYv2ZJMli2qrILI2Tqln4cMqNhAj4gogAncslWOiwaV+BwnPnE
jdp7E6UlqPtYJYV9Tg3WI95FkO6beZO8nlbeyYVc7od2tLylZPKLTp1I35t2iLsk
ipSBQqtbUX19H2kWD8z2PyVPmh9rLUcrDSKQsTJIfukqY7Hl5DzdPLdUqq1+LJp5
emzvHWPLN9YtWeh+2WzylkbFNlTCyVWKZpKyQ4YwqnWq3kKzCwje4lWdzTuDbTZx
x4bJ8tzHGu7m3prWSakaVZncMwY02dcu7kznctvM5MknBXCmwVtKfU0xWphkowpi
VsxiVW7I2rWqtRhwpcXDoaZN1MN6tYlKrh3GpWUlJLvXd43OuslSWQ0fVcxqeL+B
Xv1rpQyBqdm7e1Ra8loulyubVzbXOGoNVpN1/mjcbxaAiUP6xnhT7z2IJaTCQVgt
DpQcGFJgWSBTA5batqKV5l3ruu7XC3NyZRFeT486vWm68lRqMyRNpSzSpsi1KyzL
GmTS2azSVMZqtq2bay1a0raVmmyq2yqikIVCwBSIqSpJJKsVBYgSKsBLSopRkS2t
tKmrVKmA1rSpZU2JTWWSGtUtmsrMWKVLLVRCkSkEqQS0GpKlKZllNtK0WFGTNpZY
2lmmZKZLbWbabW0ttZTSTFMklmzbbTaajUNZaVNKzWaipYqKmU2mMk2lilaVplhZ
MykpmlSwamzZsrUtUJCNs2xE2zWbLJpmmmlSyzaYzNqWpssspZTaqtm1VbJlmm01
kzUtDKks1LIK020pKUpNRlKTSlmUprKzRSmk1NTZZJrNhJIZMlSpNJDMktbNVDEs
mpKFKVJtllm0ps2WzabGsbM2aQtmsJaMkNaVJmssNbZtbMprNYqWVKlaTUapJmGz
RClCZhpmEmZpEympqWZmWbRs0SaY0lNTU2lqbLNtts1tsrNtKqSWmGWWW0tZrNiG
Uy2ylLU2jJWUySmlNmpspWFKJrTVkE1lJmakWTZmUtpS0rKyqpVsilmsNrWWbLMq
aVLFlNmazabZtNppoZJEkxlJIlplYbNUMaaVKhIUylmxaWkEslm2WoAZmYGmm02k
mZ9vNcym/zYZ1m/E+UySfg39LUVVWb+0CAnu+IVnzkTYexs7ufDm0VjDZ7mmLPDC
jvRkCK4NH4KYIPfTEsxAJVJTCY4MNNqKqTgrJkmjRkVkyN9MMuNskxW0mmjTSlSs
RiUzxDKZmvWVXm9Y8a6VLqbbWXtSMLsZGTNoSqYkyYjI2VEskoLRRUbRRsbWkqSt
Sau0WgopMsq6V0SZehQ82kyxbJsqq2k6xbaqqpy8chxElkKVybMPBqa1jIGLJqNa
WSNnw5w5rJRVJ8pXQahwWUzyp0wnz/U0hIEiEYfzEVFZGtr8GqLFqNUUa0pVZVFV
lLVsEy7VF1qILVeGEk2aS+WJki7F2pqD7InRyG/WjNbxTzY7E029eTdr/1ZJlhzx
xZEk7TYxZI2Vk4yI8WLZEUcfOpyzjm2I50sicpFjzHRZKelYLMxipnrpolbK2wP3
Gj5QrZ3mE7dW70dJN3aTWPvGzFnLOYscQkecNk/KdSbVattW/g8tatRJ9BbaVmTU
cNkbE5NiRgCjqJjBFYYMQEpXT39BIxlLWwvLhFGpGWUqKViqxkcZkznhqQLSNrGQ
hBUdGYxN2kbWNpAzdTVXSs46S3TNK5yd26mxXO7tXNdm0m6bRbSTJvK6rpKW2TFt
vPLvJbNaSixoxKyEmNk0kWK0SdjZs2NohYnAsejhFowruXCQlUVFqVGpE0UGZIZE
c3lktTo03a6N+EiflSdFScJJ0xKRxN5+ZDlCLZB9FWySZUtkhL9OWNS5Kx7HmGk3
Zm+vn/kuSquatyCwYtGGhIxpQKVBh9sws7qnJ2thu+NtlbJbljpdXFmFp6I0cN3V
hW7RqTNacWNJ80k/pbIVr82CR/iVzKp1fJPyjz7u0PGnOl53LbDvYakR0ZJD8qm5
9mWLpEWRzhu+1n9OUKT1kn8VOh3p4lv5ZjCqf3P82pWjKmxUzVvxpOH8eDZPhDwf
ii4JZZPcJ67Ts94+JJ8JN6n2RXJ/iPpDEN5uehqR3Yxju2bXbGDrRv6T0R5vdxJO
R2mD+4dUjVjZFQf6RFZJ8rFskqu7VMy3EjDuzE2K5wH1nnG971lZjE1GMMpMLzVo
tmMJoN2gv8yApnCpgihcVoiUFH+c9nnbz+momOTD2WTT5sRko0skZYttki1bLSVY
mmMY0wqhWnGhdSllSSW9z4amEW8VfPq+6qyaeu2jZNvXtEl6ptryvUoxwqtXN1Fm
Yqyc7Jqlsb2TXkulki/galjcAwqxIxJEkIZjxWvohjDLbjDg3VHCdKtlCUmTvHq1
g1bKsb1nufaqpD0uQWNon9Cdrrb3LTMlSbUTSbK0ohajIvgjH+99Bt8p3n6qleSV
ZE6o9h2eHZRzpwc3OYmK009E9R328jxMbJvFH6StQnM1NNmLDBWdD/DwdQc+bD7v
Uoz8D4pQaY3jgmo4UpCiqrGzZpNbC5h/TXGpNqn1Vaok4ZPk4KphiwyWJy5ZHRwf
oiZC34h6SrVlWif7FRHs1+Nuh+L5Hs6k7WWyNKyald2mpMaNp8+jr5z3H5HpDpU/
yqPXPAk91O6UFo2PK2u5jy7lWy35Kw+iPIqfOySOpNDJ1k4nqsilXhkeZbW8c56z
Rx1kbkR1nBpJ1VUPWotkR0rdsQsexSuL+5pk+Mk2l/i7Oi6XGwkvE5JyD6Ifc0l8
iIBO6c0DixXt8Wk0H6+6WxFliWWWhO5P1UUsfx/o/JZJ9iprtPkmjEsfWdqnbtat
q24OckqqqnQw+6k7EfBZHMentbUafUcOiqVVVYFUlFKKqejEY6Y+lfo+ubdLJdCu
RFXLgVQwrGW3GIYJWGCYwwtWWlUskYxZ+emKaZHyQfWMWTUkP9FV7wTx+WRVUrZI
0/KPlYWlUqaINRpIxmMlMfoeftr+7+JP2H69M/jD8xaKRKgSrdibLHI0VxjbdHGN
jQd0aMDA0QIQWEpTRDGZrq3R00OH8GFjuAD9iwhU2MP6wiGD+jp0Ymd06Ksv5piO
Uq1rMkwZkiw2SmZIUHD5pP5P1qcNmkgD9vum0hi+X4S/PJ3/mfi9rbspyye2Fk1Y
tSqo+5O33q0nAeTHbg7lc2zBxS2K2xjL/dLmkWZGHQNxp9NkyrGxuvp9akHp3+A3
ROSdXUb1air5yyvdI8km6PrIgEskaR1ceOmv5q4dpNp4dofKup3NzUTxsvxlZbZ/
V7KshwsVcSqwxapT6487uYnOE9IdPT5DshyR8GTg8yZIxO7D2Xoe8wbPD2vkrki1
J6oe6xXDYppjTbDezUkdjZXVjE75bVWXRUdldu05D4OvVbD8SxVZLZ009nJEkSTN
7Y8kpPWH5pUvT49iIMA9AfIDJEZQpYI0oY5HlZOHxMMSe9WuihVMpamSnEH4RE9Z
aWlkKsWrVSPdFT2zJGJOHBVlVUrpTJRywuMlV0T9myzARkClqiJX70kgpcYzsakR
kiRXw/k/H9sfrouz/j/oVDN7/u1hxCRIRZULOfq+KvHsxm1M2jkhY7WeUc1j/ARD
X9g55b0y0OAkCC5cP+IWkuBkJyInN3reK6uz5oJ3cmh5kk5SOROSWbV3cz6GtQbZ
KFKWuNFtiyrDpfLMzGSYWFVpVVZYebEEsBqBXBsjMbarG2x/fZQ+jLYbHHqNwzdK
EarMZjYxuuOPbI9sySN6HDIRKMbSRBlKUoJjSMbaV15eryvBqvJXDYi8l107GrKu
rrePql/G999PfuvQQNubc1orFGJnz9/3e/n38NvhXHdrlX0hVyULe2vF4tSELMby
nXaVdIyzVzptzbpG0kYyrYmUstRUilMV6qhiUaXUqU2t22sqVUgIrrtLQ1QdExSK
lSKNIKNDYBCEhONtcvec081daISsVrnNwhsmVFh9UnkeSpU/Ucu0cHJG1Tws6MbG
5/FVq2qhSlIpMbqkdPrfnJsRP5LJP3kl8j+YotqNDkj+2rYWxbJPER5OzzamSJYm
ofxdXtOqPt84dU9J+/4gPBe8BUHiJMP6uXrNpwqwttVSaxGF+jEifCpFfxSkr9mc
32c3S3Szbd2ZoiFIb5ZGYtnEkdJ+Try/CPL9Mi5mMdh+Ug/lZFsslk+ZJ6Es33Tm
ZHKzR+qo+jHqk0bPR7vVXJrn+XaeaslpRZLB6fWTy0fm4NJO9fzVkjpKW2+cmMea
KKivw3yNm0nsxo0qY/JPx9o926TeJg2Itr4mV3UibG6zyzGVVRZRZzUmJYrYjeJP
tG57vdmClZ7rv1y8228aKmVl6+qvZfKRcLOG6ldOqd/Vu6vnzdTvHSaWdJCUkjhk
kn7Gk+eiZHzRJjshqSwqyDyZ80X6SPqx722PQanWebyOhb9n7djstjZ4dY2OQxL8
hdS7hgfQ+5CDkj7o7K4g5yNpyOpPqRywlpQRSDKSubGQjFYyaHIAwiqRam0sMSLC
sJviL0yJ2OkeKEslhZYLLIdXuqTrJIqKaZP1acJCcH4eh1+kfB93b1WTnIpa+SDt
JnSUSfEhNliaKTnK6bk2NUtOpwxwxVUbNmx5x8lIqppySP7fkeJPkfA/GZNlaB85
U/xOGz7nG7VxLbFvOJRc267dY5TS32y82q967Sok5Aw3FStphVLMYoq5nJ05S7XG
3bTWXLtislaIjwcKpUlVZ5bNl3MjhW/1ibOUVX6bGO9ltr3qNM4ZOuTmdlJHaTrd
opbJmZI0WRqsr4Q/tfrZ3oi2RVBaIqi1MzEkmVJ0pnG2r43k6qGCL9Kkpczv4SeP
sFeTIEBc3DtAZcH6XxGW7Yaw+DznoSqyrouIMcMHbjD/FBny/X179rvtjikQCcgQ
E4HS222zVI+KD/aP1IS0pJSBYzn2USdPSTTu868arlGQodZ/tyxVyU5RrlBdEqjR
+4KCHQDi6aQjlScf+T5kjee1Xoxo/SOOyTCd1xDlX+YN/MVvtOj2tXZXckMqqZHZ
EKEQlkdnL7Jdydlgmev89uU78j5cSJ/l8dkmE7rhzD8qadHMH4jZj3nDGPdwajh7
sMdnVu5ujXXl+T1/u4LOHgw0+z8FGBY2M89iIokYQvh0gpDsMgXC5N6MMVWqIDKF
k7Bhi7LCa12ZnoYVi5gcGP9X5TyVn5jjpmK38e0H0yNy9sy6krJx2NyXEkufYjPY
35HJdzHaIWeWpGch1C2GpaeIIyAyJiVK/Gotmvs6vH4XixysdNfO67ZuafPse3Xt
czmeH1mHV6i2qvNHrsuyeFJj1OGjd4Zq4YLjGTExlUsVV/xcbG0nNuxlxTLllUUB
hE0vYrX0AxuvoyLWYktLUDBX8H5cYsLkOfeXyz9A4QbZ7J00FTnG94VNve5NkYen
LptnR61av5SHOPZVdEI2fk5/k3VxOX5PckzZv1ec8TchyRzOOqs5zOUkm0wWPJVW
TC1sxMVVTWOfpWxnsx/JmyBRsFWNsiIqoVUFReZrK80s5jqpOqvOS43zEuyOx1cp
0Y8OhOW7ME8lk6LCeFLjEsFSqpSyelXJhXAcdpsp0Y6/OqpWhUMVm2xjyTgU6nrw
6yszFUttktLZVtnXi3kuDRtDz/sJ5OxXV22LVZKMYxihA2Q/Dq/NjZ+535t7PF0a
3E6sM0t90PBzJHT5SRrz+MtSHquWXGSMc07ChTvJ7sjSm49U8JK0NlKrXIMbnnPC
0qUqjU5Jxyt7ynN5e/kM7y2YxjGrVeTE5xqbVT8LiY6bpo+ZdRG82/fr1m22xZSB
38PxIyNMShQiH6G9hXLOZK6w3N5+X72HFAxu5NSfRpW6afRXqo8VJGH9x5ObPuVJ
QLAiFlH6/u/FbMJ3EnnDq7T0En449m8JHNPxcyzXSV7BCP9JENSIjTahAiKfMpQX
fhvwg6xjTyfA09UakjGjZSMkcm0k69uDQkz5aTWCW2iz7hlcSciTjD3IoFZBYmNt
odoFMMIkDWQjASGk0NA76DcIySAGLYwAZPQkVbS9raOCXx0N4NPJAcpTE24YEIYy
g7CfLWmi2E1TDcjdkTMXE0qKsqvYI1Rc1zUWKjBt3dZMYLSc1V8teNrSwW867u67
u3XWz3uiTDJ7uup6aktGEa9d1hTNubvV2q883d3IoqVnZHRyRZT547K2nlbs57pm
7cLQoYwF2iZPBBH+5LQ7dYkkhI6u5sNK9nPxux2bnayrYrkTq+u7erJbBUNziMaP
rppVcY3SxyySyySfFXkjZSuA61FVMKi5jFHB+UxNKWOqcRzfOSQki42nkQs97JyK
5amm58SFk3LVSU0uj7SQfqwEfho1r92H6uG22K2lVz+Uf5sqP0dLN/GejmK0sxrP
xz1m2/05yx4ONjCbJH9A+8QkhIqoJKiRIQWkkRKAK20HGfR9lFGh2vmzMyyCig/w
mlAinByNccszHu826vNs08OjdXU3GzSpwG2/sZ6SHoyTSVw0slcGjSBnq4UMw08I
tvw4uHqDA/w6OSCRnyIh/MH46rxmTFxdHacVc+uD3HvflqHvL7RI7e5edJqb4ZU4
09uYztwe+W/IpAaOoyLcwQVPk3k69Fffn6zXZ3kION0cYOXDuS+3vzTOm/K7Mq6H
OlZUd7Pxxdl9t69NorsK6eU6442+am88vu73UsgRoV5Z211tTDr33RPyM6/XfL5U
EDhtlOMGIOhqVFDMLDExeDQGHON0fZdtpnTpZ6cD6JBkGJpUx0Y0WuppUjCvDGzH
Jsmjd0VyNNnRZ1Y1MNHaMbOGzcp3VttssZwsk0gsTGWj6gLXG8FJpoGGjp6NmZZI
mQYvcYoaIEFW2vkM2ui4SWaSMLtv6RnW2Q1A4FIHgMRpRK4eNjfwZ5oqGaaSMo5b
dknhw4SbOELPGyXLyqGoGSSqSomY1HBBVkQqys9MCWL1YjTEvrT/lW/HvnSpG2HG
W0YwPtoufZQEsPWkFdi4q6Bs3tkoppX5Eiaqo5JX1UtH2/gzrxnmXNzE5gfF8iGh
wMagId9OeGfjPxGKTtKHVVJ7vT6eMIaVB+wH3n3+jxV4Svh6l0hS2vo/Hxp46W8T
mStcsHMrio8lNypolKYqrT5AyFDChtZGHuINKBspBGKg7kJt6Bo8fNBswFHISJJt
PcLdHk1+NWshZCgqnMZITrDX2VnDFGhCe+9um2kaWy3BLFDrBte5ISqMa3whRNX2
hdsSnCgdmnJiwaaFmqxgEhoSkmS4W5nnc2pOkjMCi0Pn4WGjUumeTCfLJJ1jYrHx
jaFRrCj5qXWxkTinm7fk9Hu2JvELPk8MMVKpWKtKq1iVVKKUxXlx31G9Tw/vO6Mb
E80lYmSJp0FRrDJyLJ51U9ZI6GiLTUsTlnZqBqxHcOldSSip2iosJI2Ehx0kHxDZ
/AZNzYUGDTXrMplachkVuS1tsiYIYyt2mzZDErJJWTTEalrQplZC7YM+li2SUoxV
VZY0yZkycNIiDcCJMaGNe5kXBpN+8HIUgoKqYnY1JISR6tshCE6JhknVjg6cMhWn
JNlbSdppsotV9zG202HYjiEnmTz+E7xXhSrLv5ZtdazVbW2hjEYNKDGEBkJ9/vy+
vnrFURs1YvpvLuyE245w0VLL1kr7cOg/Ba/Qf0QM8JPxZLLOStL5KZ+faXr7LE9j
17oH4+OiR8orIu4h/RAagtxGICYpOWtBCN8eXMu7rl485VKQmKi+aU6rwbyfLXpr
161+qbettfqWN0pL88tJbgpKWur4a8ki2arIszGhZJVK03h6o84nieE+RSDA2EJn
ygppzrRHjjDHHjQ3oAGNIa0QIJjBiGd8s3glSnsMZSEY1I4BqCBOrFtgXZ7YoGff
5SOeYkWToVOR6a7/Dmyl7pPebOTUlLEYebR5Ikzr5O+azEJXRy731dGOXtcW5mTx
HG7GnHVxIbSbnuyUslYdMltVhpO7tytjo3Cx2IyGZDKmmWOxCaYRisSq0VhSVpit
JWkrS3VY0DcaigxKkRFVBNRkkg1UhOMurldw8knJjznZobpJOCnNMtmM9JI/gses
Dl0es/T0c4b+aSO5yy8it57PtER7yQ49svq6K2KoqVhjFUqmm02P9rP+enbyTaJy
k7zyB5VdEyRHyqE2jlT/N+4jPJHNVfOPajFtvo+bRIhxDIiAREIBEBHmAseJvCKp
aWSr3OREAnaST8LJp9TClbcGN022eOxs0mObY5x+f0+u0ck5RKKUopJrgB87bebv
yv5u7W3q/fvzQ+JGypskPUreRLIrmybatMsX0a/RksaxtIKIX8sn739qsebzOZiG
by7s3vdaJR6Dj2macG0WSRT7SDN9KC4xmGSRgRYwaf7MbwGIOPrP6Rb8N/DY1I1H
JIkrMaQbxJHdIbifDkh15l2d27BHRHVPKch+6RBzeUnBMtctc4pKUyuu2upJrlrq
667pW6+1t+6Vk20JkkpYV59A5unxbofu3vn21Ey/s+HYx9zasPu1JNm5an1x85Hp
GG1LFk0RAJ1kfSK+E9UPntJMsjrKWnc/YuFg5pe8Oyx5qIpZEbwKh7e7yTBhymws
JtGzb8PDzkfvPfLZJ5yR/o9pH2H9KqdtVVX7VbbWI2Nmr22lllliKehVTXVI09Cd
Z/Ou/e1aKs8lfvPiSD3/Bks8PeYcuVmGgTKW2WyVY/isZRxJN2T4vyfP0vRyfZZK
rbaZNZsTidKX8ofEcnunxzNEJWu9xbuQ3w1er3T4Y3g7/gteJ4WVbTtmn85O7lJ/
VEnkTJ9atqsYYYeujDUxIwoxR56sknNj7SbuGneRs8nq4fJO2cpuiWKioslVKlRS
pJZ/ULtdlKi0b+Z81+yixKtJIPDdvJ+LvDu0SyY/h7/w/FiNs+mias1cSpOznIPK
yrHt1CY942YTzH+yrZIoqhOEiZIT845d3T6Pps/6Ofl4bEm9vIZB/UJBbEtgRgyB
QrgTP96/o80lj8FrpZ3WuiX6brraSSqxRuxjTFUbWarrGGKMDbBcSioFSqf3ZLaC
XBlKqfB9CZLWcmutdlVXXxEzqHZVo2a5uZjrbE5X5CvSKi2WpbDaOR0OqaV2Vjxq
myEND13YGGgTBqRBqAkgipVktsk1bJm28lu2ll5dkUpklpVLKkqjThs7SaJqeWRG
VasWSxZLZu4aIgE5GtmzUkyWRexTG+WO1qi40I7X+GXLi6g1d5IU5Kydn5ZoeE4k
iNK7HJJHZ32hk/RzVTRzKwrOelrcXxZCb6V8ambb6i+3z7g8vV7o2qRK3bNfx+d9
az5ZypWyvNOJkq2zTDGW3I2kxsrRVg0qaU6NmxvJVssZPf5Ch3jJZiNskkJC5thW
jziKca5yYTlK0RAJy2l5f1mHrY2Dc6OkI2TTTy2TGVsRATPxGssjZRlnpIg3iSRi
xI5OR2SOZJPl5/ncvR8vln1Y/uaaeTGFSl5VO11Z1vnvja5W9Kw09ahkgtDDYyAY
Qw/WRKMp5aFVusKrZpjSKdZ3v58tazxmJb6NXQlD2AabBtG1MLD6P6xKQChW0XsB
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
Zs2RDWNrUlQ/P8x6SH7v7Pz/8fq/1tn9U3lWuTf1JnUUMBZ0zXwlfGtzjVdDGdNw
/Wb/TcYvZhOV0yvddt9942XK1inv3hKPY1yG22ftVJYGIHecMa1WHrVRdWNFu82a
cxAgPKsqap3SvCX1k9lfXPem9N6bX0uaUbPfM+K4StqpjulMkJsnYV74vTdMY1Ed
oFSIZ4/h6sOvXBROO5iA46Ydg4cPQkTnMmYnMTmTOZL0JQOVaKsWLsGxYqhdCCQM
UGxBBBEJ7+U3578j0euaooSZ6QPtSOwWKBXnFoZlecqTfq1/RtQ4OItiMpbHqNXS
LBpu9xQ9UiKIOt8lmoPPrrV81xoI5KWxvXhM3vY8pR7qqK4YLstYwxOVYstg0KRO
i1fLX6rgTrxlmqlbrkE9LEGeIed9k26rGnWed6Nh06p11O87aBEwmLoD3HcEEAkE
GRBBBBBEkFZVQUUkTHdrccRvm2/fthj1pS2KWAbKGFox0dOmXvOlr51nWKGJum43
BBBIJBq/KsYn0ippp9W01W5ZRjbTSfDNkM7isVOp5Wk82WrJNLTsbRZZzsMYDiQS
QQGRB573Pe988yZmZmaB0HgHcz7ZHJKFgkEgyIkiSS9eHnk2SvPDryK1aqqqmtW4
PSycD/w8sflE+v8v83/dyIplqpb1llszKa0Kl8tWXbMGzMy8XWnF0X937o/wO4fq
0+r7tk9qe2FJ6z3CkozLYqzEKiqUFDKGP7kqsHaWq1aDYcCQokp/eU+vt7uZp4fD
vw29FcKUSuratW2rX7I00/UcnqCIfPyP4ftqCVUyNaqZi2P7Lo2/nvtw1Ntxu2Ov
M1cLOMOjTdl/Jw/jqwjhrHX7ljvTS0Ng9YWklWliFUpZUiCjOKclNiKmjWdFMjuo
dSAo96JmslmGgyCeUmmjEtITqi4DqWXTg4318osVuX2Vfa63aYJNvvZpHIUVXXbr
pPMYqxKrXRvoXCGuFnXhSb4SVZtAm6ojtvuIBkdOcqdgEZ6lcZZFN1kPKhJJhRBr
WEQyIWkl1hnFU3uys63k4eJJlSIMlKqoErDI6G4EEUnpZfaOrlixLp9DvOUpB4Ta
n2/ZW/q+fvPhH07t9H4MT16XESiARMKUE/rVVU3KNwDooJ7dlAzgnD7EhScMIYxZ
/mOidHDestpVUIAEgC0t7/m9fLzzvPVb1fK+s+Y+f0Pon6xzJ9vzOD8R9GeLf1T5
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
KIZUKGEwHCFgyKwJcqXSyY9+KkWLMIVwWZW84+AK/Bz5wnaLI44LmU90x/EkyBYo
YS1EJA9jWfE+/5tRUV1ipCoof2zsjgKQ8vpHUIwQU4hNNSOW4tYulfaqfz6P4wYH
GDM4DID3+NqN1ONUA/PfuPMRXS88tk7zKq/wt5RmaVy9WAxsjPw3pHVUomq01Y27
q1V1m7Yd2KfWl+O5Zq7729d9zZ0l0p3fEcrJ5YgfbvWje7O3f3xZrowIWRkq4O+T
FRyxJpiWo4lFPH3WrGdl4cvrRgQWOs7e+Rm7Fg5SGPs7K8wII3++tGhUMYuglST7
5KtdoyntNOHVVlYkvFyJtG6k2rcPNYnRazDvM0jtv9e0GxHtPw9lbsVHo999iMnW
ySQyREBBJkSLp6BsnvG/p9faVUKlPzdQ/ZVIRVFqLwVZA3bCzzChJo/VG3vBX5SF
rWK1RZmzbONI5WDQJSoSvFrWQPYWLVWpk4wJi851alamk1f8QZvBepyqUITCUW1M
PO3E+bYpbGJWorqrG+spHFPy6ovW+piPxPDpvMK9cLBMXT02D897907tO7q6Tqpw
mu19VLVj5w68m9aLxrh5pRd60Z1Y7OPlnWyT67h8VWsGO4nUUKiC8Pu5yxhCT898
xuvPfY+fhoRK5T5qvf5+ore9q8fDLTyk2u/mia2vXGhbTXwjpwro94vOKUYpdrNK
/ilIKJN59XedxQPPGvYqUmlTpq88kgneW7DHmiG23HMo7Zsh04+H7xMdo7xOJJtY
eizcYZdt7XbKVK6OL4vQLe/M+3jq86SgU5889oFKfPVuxF3wlFrkIun9efjz79d+
wYeN/C+u3m1rd0jFGq9X89KmLLXN2C5Po/veZd64ndf3MKIxsceKwWTeL7MD3i1L
FVj6xz2pzr8QKCFNCFKpIp+xTH6JnyBsNsPitQloYgqd1l5g4jhq6cPDUvHlmwrI
oOhRQkOJcJfIaDs0KhNWaJJhi4g5WXdYcDKbkpiy7o20IRRpRFyOFooQ42GI3+Su
oMuUwozR5RSK47UcIoQsIwhhRiAXHRoVM/c+S9/l9R47JC+j+m/Feaff6jz8TUQc
fBu36cbfXyrsgqiUIyVfLNwCKvgnlBRwKKm+brfbFcOClV8LfTPJElZDw+Yw7n3R
/39I96pWacn74akmCfZk9N7Hnbmfnm+G9N9IIVf233Vjv2K+dmOqXTgm/cpSxjx5
NoTM+aO9xtTisCE1pRXSdT2doOxqKdUb7MQGth/hkgx+xCAlvCV3TRG0Ce6IyQW7
O5ROkRaOiwj2YN2coi/fFuizw675bLOfJnWg2VO7rRIEXexnFH3XUPPfxRcRGzXs
xpAtbS7eu63smcY2W+6RTU1psvDNdHE51pxd+N1FlWJbYbvu4qRoHx0s6pEIRV8N
xbCsclUVRe1t0Tr9/qt689+zMRbOMBXqvBVD8KyFEO9HimPzqLzwaL5e+3ZBPN5Y
7c/Kfp4kQCKdTjmOa/v154+n3TBe7/D3+v6r+/voinkqWoitVotACCo664ufF4Po
3J6cfruz8fcQTLL13Kd1yNXLle7zzhNiNjuuwY3dvT6en4e/3/ffT7fX3eKmQXX0
/wDQj59+yNfHDLb2ngE11HTs1D00z1Rmnx+dfhwbhbzuLp0qd0QHMBspKuzzC3ON
dfyL9+3rQfBoYPjz4zsDVN+WG7vLnXx9Tr2sSvtE8MUa1li7Bpqrgl9mbKWWkUrS
xt51NbR1yPPlQlNbX2vpMO6OipAZVCnOzMdCcdMd8ANNA3fU9nxFkfotXt+qp9oP
k+AQUQa8iUvJUoSVIGwuzKjMpmM+3+Z0JJ9oAjV234RfrNBxtZMos3vCkrhlcmZX
JZqK1aqYUg1pqK4fwfD1WX0eSASEKQ/xP5j5X1rQTbnv3OI8ip3bm/IdSENUwIVV
CBlkpUlnZ2REw9p9/blysnsiOzjy+3xKhFfg6Y9VKDt267q3dT8u8J9NhYJotAkH
UBPU1WdVV2dPq97X2saP9b/I78+d+hJa9dsO8Dq7uuiXBGuVPDdiDl5sgMgCCkTR
ucudbu90qcSryhxzaniH091sPgD3KHqWgJEDwpMCgIuFF5DDtnI77sGMf+eGrB8U
CUkTW1qLEWR7RSwstGmUIlsNwAQgEqgykQQLO1knr6u1ttq21Hb6I+XSd9/RPL0/
pE9I8J/gr8OkY248frxb8ffHG2a4zitLxY9lPyn2k/bD85+59xlp+/KfS6jzTDGV
KlCSXUKDuGBA2GxzjS7K6hA7uoAgSlLYS2qL/6jhPn+y2y2u3o2Tt0/s8v7+lrl/
tPT9O/Fvbfdk0V+HtoX6P4/h5fh/Zzr65P+z5dyH9HPb4K1fuqT5PuQMhcP2210T
TD6Tx8InpqHwj333mVmPK+Lfw/Zy/VOHTmPh/Y4e230Y6cunLw2flSdvb90NP4n7
P7x+yfRP3enyjwH7P7Pb7p+s+0w6WTLFVJtJ7fRw+3jh93hw0r/PVq20NKhwUT+m
nppNp/lXTSUy24lK/p9p+x+7bhT5Y/39es1H9J9h/LTt/Ha6djhODEY0qtFflRyn
0FY5fsE/Dp0+HL/Lb9lnh6YcP0Ym32Y/Rwp+H3k/Kf3z7vTy8I+K+yj22wqny+Ps
dv3/tbwj0m1dOmO2g8Kfo4emjSqXi3tw+KtNzhy7Y8PwY/U/sn9o/l8PSD+utZcW
37Ph7krkPur4qw0fu31nGszW2itKPy7n5Y+v8W+vzZf2Onp4K8qjB+bb8v8tOH1H
B8o/l+O9+G0tG1pa21taN/eU7knnyMCjBUlf4T4Nvg4a8W9DpG34af0dOXz/L8Bt
/Lo8d/GXPh9HDFcPhj+ngr92if2dHMPk+xw0x+XptPtbdPTbXxbFcOvGltuZktu3
B29JpHD9/l+75T24fcjp/93tG58fLFy/Nc1mOE2PTw+O7a/KsP1dPKz1Ielp65m3
Lly5mZmOW2qiqrJOg0SUOpO/Ym4AUdn91ovgujOz4FB0MBZWJO4mPoNtb+7266rf
z9zM1txqittGlEv4/jbbCTioBO/q3CKi49u7fnvTo05uxVVX8Y0CiogUNx5JLet3
YPFu7NOEC+62c7AwsFCz2reusG9vMFWax1VlAwU1dUyIEhit6aC7Du7M7VdNstC1
lXlm7XRkSLM0jajTZqNBA9IW4mqEa7U3XwsODHDZVYjuyTqypLVdoZbqcyjdlRjo
dkyjWpGBmkajVWlJ1DzMPPfJIIJJJJPAQDIGiiFDI221bW79r+Dx4685zOUWtrbb
fyOzogfCvL38Olr2TVKbaW0vvu6QF5fnnbMxw4f2Y/dynRyqptyw2Smnj++v21rW
uHL/Sh6afEfd+rg7tq21/aO38mnw4SfDyY9KYm/9rcSPu/X7Jy8DtpVNp/s39X6P
xVjyn28Mf2culqrID0/Z9WNK9+LbXseXB+yp9IezTttsnsw0m2J9HPXrTWa1mZcr
Y5Fj9fX8f16/rtx/W/7ccT29K9P8fS2fRp+r4CerERJEebBr/HVX8Y2yv6ZK4N87
Oc3/UFSf54kQJDPt4hEQISiNsJ19vv6d5ePOXnLnKlVRMqnKJRN8HOc4eHnBzoIH
MpAZ5mOq2Kzf1XTznObSPHfYLFdt2e53f+MGA8zED54z4hfEg7rRJfbXkeq33bpR
ebgJAwUvLQPVZKKFSSDRYI4wwgQCBcqqHmqrcrro/+ISKcn/1pVyxUc+791ve+Gi
7f91U5/UtURLrEFwxif/K7mLJLLBmTJklllMbAuMlEryqfWitYksSyFR0c9WGSW2
NMjKZLbGmSTzVb7Jbba9lttvnPje29ykZaxopllRLYrTpUlc4iY8qqyI5d705MZv
u1ZllGstGZYT7z6Z6plQwqduumGQywMcHwrK86pav3RTHhW18XfjLFYyWbjorjna
TttpVOBUpg27Ou7MrMMyszLdHBzymitUJ4Tz0dVMpiyXRJDbskep0BN7JGO8mdHV
Pd1TStUzfsg4eXuWE9PVt2juEFWDZr24eiXW5DE7KjZzEOuNZG7I2ocWRlLYLVvF
GIucZOLIbpOKjLLUtRat4sjIGnHJoJtX59aGaxoZtSn3kjr/BfvvEueqYoavHjKx
lfTkQc9PwqlPyjh+1Tjaztea0tZo/XVFD512U2EDj9tVTpSLeu7zGstZacdMaS3H
LvcS+9fHUcNsArlVO3L8To+YZW3QdvX46+4ZlyqnDs2vzrkqcOL7lnnrnu8/OY54
O1Vp+VBoMO5sxa7ODUmwnEJvqyTdRq22yZN7KutPTVelXigrJvTW7bYeEeJUxwNk
NlWq21IcSHn3w6MTx68cHTacUEfeN4zPFzT3uFY7X3XTNafe0tNeKqbVU8s+c5mt
7E7erU+HTx2Su+OmvhpwPmcIeHwW7qx29oNMLvh0fHz44pNODegO6ZMEIgYczrCT
WdKk8MDFGSiuOOdBzS1zZzVoqio5kOTtbKzi7aNMZgoHKdbV9Dlq7N0h523x9+6i
49cdHhy5L3Kdee8uTrlo5JI8MkRs0xx3Jy2Vtbxbho8Fzs+RYy555fVjxRvjk17q
u+TeMhUNSCJxOGSaXOJIampROLhmaO2zc6CyY2kbd7PgiY9Mkmm76s3Tx7yp8fnf
E1+NlrW6nhoz1fPXb3ymeTtuRGa89uIgybYSRnch0uU2n5K6nymfCrxsnUc7yc9N
gY+UCpqeMhw3YTjNExOOB6OpwmBt07D27E2yOkgo92SedsjGFb5T4cKHWuV2M8cF
8zMy4FsuJXHLaRIdimuHBprXH3TZTtjDi8eLZ0dKHf427eFdKGF72HenvID6MMOn
bCLWNsgpUEoZZG/vyoPxPnHd+D3Y+H3rpjqclZUisODjFbL69xIOG+QclTpogxxw
qNO9m2ni+V9vD2uz1tpoxtt5t1PjrlVPhy7WwKnZHuC3ruTKRLY2yUlqGlKqWkiW
y9iHnhPZO0rN94N2brW8hut0yR51BrPKXs7JGxb5AnRiZTl2Xq1hpiXy8iczq1p0
4OUvW9g8WPrtcenxbXL58ic8LgbnL1I0m4MeNSM4zVJrWW9uI3DW3tqHzluUwxR9
+s0Vc0hpweORY4VOtNXbALUCyXLqNFcCR7xxw8jTkStO873DPfY017vHfEhE5xAu
lh+U9Pt+W9++O/u05zeb4c7pzjRaWurtlU91y/Pj38bnSo+8PfvF8I5SNJ62aL20
QZtJUXrrTO3rYPXw+NeuFWmevi1C41Gt1m2DMqHmySGsXd4XEMFkBpCUlZSTWAUm
a5gWmZLEQcLCwtjR0rZplkWrZuMqsNpWrMyvBJ5/Gff5lT3FTnKql0x9H4PU/DTX
OxAXime7qULq7DqoaFW7tVaVWymOAghDdEltpIwwyIooHivfPjSHoqKy0NCBIRpB
IGQK8fXhPBpMTMhc4OCJWMuxlIYammJ2sgEEXEs8oDopthFpLOUlVTJVAqKGFoiu
fFmCKtsq1oM33uOW59vV16cDSvt7p7+u80IySXnVy5lF3Mz5ZLDu9ZrDzoUPrekc
9Ie3XnPlekWLviZo7sWzm9WT4r4vmvd4+Mn1zI9eadvv8/FYv0fllb9OdHfmF98c
xiihhSVRBRSemqq32pgz4bzMD6OjNYamHHHp0WsLbYyKxZ3mLD52kY91zW6fPB9d
GObcd2fPPjX0d4du7bA4tvfmSzb6t9NouC2GU+LHHGJNXK4s3xiY6MfbxT4Z83cZ
UuZDLGk0mY/Z/iHrRxSY3S1SG9mvzS+bvxc44Th6JqNHLLC4ZR+p+NfpU+sMTeHg
a67ZI7LO0gsjRa278NqHpyOH+PRsdMcqF5x65vjp0KeJjqR4dknzo+Zsle+oZmSN
f8ttztuTWnh+4V2fpXP02u7ttibExiUsNhbdfPzh1+rQ09U+enFtXS5qQkjjxMd8
MkkY56cYwqZcb6vi222vU9cyYersXMh7cOOI2Y7Viz6BNspac/J9fjp3RQw/gqpU
1kIPpx1mbn6DEJI5wLjKElOj3z3XAvFr+HD+fSn8rhs166dJp1CBw82PeVw26dIv
7MUi/KQbLXXHt4nPh0fSOYs35zI1WtZGrbfqaOvlNp6VywnitCl7G/RjngwTGOXw
v3ThnnFFDb8PHJ2lL1vMzxiXS7Hci9P169PULTtp8MorSZB25VNA4Pw6X609+3Vz
WTVcyRy2dbt8H177mEWSRvh8M+vSerjnx/SZfuZ0beIXSUuzna/Om+czLbbbVfTz
54naAdd+pE26qa+jh4iOkG3g+U1FmjxmGX6Gj40+jLEntyrIn7/D+T8fy1+Pjjup
Bc3CtbNuXO2tRdulIu21ItGsL9ccDt6aEtrxfwXjqcDx58HqqhesQkkFR5Hw5s+Y
95rjxZ49Zxzzzs55zny5Y/Trf42ninShp2tC5MykPXPDq/HSuOcy/Hrg+uXOZjhw
qpi7evQ+G3aueLbIW2pPLBOXPB2k0qeWcvH8dPX3537NGVVjFVhhjKxliVkqkjay
ptqZq2S1WktJVZNtVJa0VtCm2mzbZsiNNZVVSy2ti1tS2Sq3md9hy4638z5PHNMz
Ix3IfMkD8jgU/hevg0z6O9vrhfx2u0pdXi4ooddn1WwLTt3u0dtfx13/DwegMQYQ
wdp85zgwAfA3hJq69eh7Lu7zLGHl5V6eivCu1elHunTwnjRy61p714uThUcOOcz8
O1cqxabWOunLt5Rw9iSJHt3F3y3WWZdtujHhx50iRPHtKachw2vnz8eK369x98Ov
hw2vztQt4JRlnK9QFCycOHEpchMB0Ym5SeIlIUMnPFcafA3klDSwWSTX9VVFP3k/
KQ0+nzF4rj5wtvArh604+dqCN3Qjz0VcqypVmrlXVlSVcqyiSeckRld1JlJlRlJB
zmlk1LS0RqoTfWN3vzzprfXjY+ZUWT9c+ednqsvvSSJCkAXphQSFpCgXIwRJFQeP
HfxpU2Op7pg4ZhX80D8P0HcE+tvtafe0PslS2h6bEUphB+Trt9zcMySlFfrXx8s6
aKGUneDdfjQ99/yYfX7l9meCDI/bvJDJAQgdu6SzNW3eZlBQykZoKrwo37d0TaW2
0DnfHOPJfg278PvnXg+re/l0U+vfj83QmJIyIhDN53JH5Px9XhPr2/DXcY+NzGJO
6t1p8J77+GH2+xfbwXyN7S7ySU8e36ZcY2cmX9ZqJVTbyyJ9LNd2Hy9pFJjOJx48
YJh9fxDDVU7nuPtjdzVxq4025elJxy5kTGLIXu3JDla90qnLmi/u/hOXSqnQu+mf
lpHZt8sRqH7saHSSEQXU251XwY4dOFRt18lS6cUnTgWreu+m18JO/RkmYWb9Oofm
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
6L5BzgoCDQAx6HNqd9+Dyvbt27Lq3osAuFDt/Zv5zu78vxMXPz5rDDqp1z+Pi2nh
zxuQkFAnqvWm2HD09db9dvJvpZ775mY/Nd5n5du34vVU6F+N+jTb5SesToqJfaen
DXwdO+bu81I8knny2dLk+lPtFD493Hx70x8+ZnD/LrkygIFr4AcZGrTDQcMwVWSB
UIKC4cStoBZZEzt+9tptwYhbUixKXVLSo3XvhOmipnoTQ+XBJCdfHJ8r47yZmPlN
tp88W+HnzreZnj2dX2cPfT3zCQm3ifI8tvCeDfBNnl0nnzDynndrPNObjUhIM70k
+Phvzu5niebfbE8NY1HHuJBzqbt41px6TjT2wnuOfnskTlZwenlVTqj+HnLFtEu3
oQOnRi96VHqH1D1c+g/IZ9nQp1cZlfv1606UPjEUVw/C6dh+Pz4Dro+bIdOl2OTP
vLTZ5+7/XSX29Bv0PSCdHY28GJ5eY3ddXvTet3d8H187Yn31vrt8fNKu1D4+cOuX
InT13p65ql8fJv74217Pm/vXbqk3NtnkqrqnTkK7wpfdhA+r975xmcNIp7Twznji
evTlp74w9peduGxXiNdczaymNYnPSSSSFdH57db5cA+GzcQeEkOBjPVentzlrtHQ
fBtWJ18UIb3yjguww+BUcg8J5eHbljZU09Ja1euOjrmjp59ooZ2hzKN2Qay4mLA1
pTOLMipVkiB0k7w4rISoDm5vGxYTTI8ymFxmtm+OGuNY5ZPbcqyxJP8qLkqcrsuN
XvVCjgr1Q3zy6o5T0ZznGJlVeY1Td52qu2m5V2aq1GXbu10ddY3rOrpy0u3G0gaI
oCqoGaZwMADnKp1up7vrdzvSOe91CCUrW9pWJcngyfSVtIngw8zxCUFzpAJs+tb5
Zsn1j4Dp7628zYe6Rgm2wa9FYc1vkPNMB5NQ8Ic3l160dXv1c6zek8W9yRs1O1TS
z1rN1EhwklOMD2NGX6ryTXTqgq+B6Y+TGD0AgzsO3XvudNp0bcBy7fASeOUcunRo
167Ew2GNnFZG/O7eEsenI5SHrvvWZ2addPjD+TtfXdODuwvq5huPLaODCtE0ntOn
L4e8t7dJ5M07bNC1FSRtpsdzzppPfI7dxw1640x8bjJekxsa5Y8VNtjEcBtCWwcl
ZTbCJcD8HrfbHN5KHTo4Fp819fe92ONY4erddMSl2w76PG6tcHtZwrlPXKVGjFac
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
0xeOddrOpVXqcPaqqOW22WtV88c4xmZY7dL6ei956V67bbVtWu+nzM5fLQ6pS9sJ
RXrzSp0cNSpHqF1oswXg7xoeipTO2OO3gSMFkwqyWwWmzzmd5mSrkIb9W0R4V052
4SQ8m/L07yCFN+NEinDh32PHfHDzfDTYp2pF9vXXneZ84x6vcPRzRtDb1rS9KNoj
G3tt8trVSm4nKzy3R6xxhOMVR5krVhMyjGXOrVEkqjaow3ghlCSpZNWBcVaxL3Fc
Y9ZJpkrnJzlzh3m8wze+XP8uV2KlNuHovYPm99afPmu8VUqUJ47l3jmZl5eHCqbb
HO7xlEBFcBA5Jb3t32Zl9tPvd2smGycKE9uyfDQQPDS8Ltb4qBF9a8qnudmpDwX4
+wdtdWPrzp5ZJ51IafAcnZAsPkypcqpRFBAcxIYWs3vTR50fEtvnqdcUo/dUXwei
bTydGiJ4PFIOWjex8NM77ddunuIT3rfm5Wc23BHly1Kmmj152czh1j2qUpWYqJEq
vL10rcCedpLOreZEjlnPpzu3bt2Pe9pIbbhG5VdskX49R4c9PrbZr3tVMdOn17de
nw+aNedrTuVI+Pjo67O359n1jijiSSJ9jstJAwAWh6D6ObOekTEOeh3nAr2g7ynr
8xXTOMYFcwj5xiIpx8cwczh8LfyjzhSPBt74x6zvdzHlySLo8nCSRsk0eS6TRbxm
Z3wnmxmnHMkNhygxjtJKwkU83mOviqqNjty5d4e44KmUaw855t7i6cPI8nbp5Sqj
jbpFk2djdy3yk88pG+mJSHbOXfhw58IK24kkSC+DzcXXnNW612O4HXcPOwd+O0Fl
8PvuZjsCx5376uzwIG+WIPHLtDGueXTEg7dMzfR0JnnGHYm9idAqLLCyKsqxZVXx
lbdLKpppSUky2SmfGld42pFyh9d+861rCugePr6r6xOggdtdPr4hx457uTlQ/lju
vcrnltjnbtqu9rUk6cL7e+9cX1mt71d5mJrs2PD2zySR16d72kTx67dPB2rKOy76
78XpyWhUp8dXq0t/AX04768zWa18ejz5cuUnls27TZy4O2rxRtxcg11S6cfNoYO+
+madlcs6drb67VY8K3zSk4YqtLvupO/Da6JNXUsg3mJLapKtWFixTMIxiMYqYxW1
DMkpmVKMqXrbSzMt9/sqIqP+t/93+I/0n5Sn7T+QT8zf0X7f+TD+B4CttqUP4hlE
RRRTARIfupD+YUw/Q0KfxO/YVFVv5cOFw/8J24f+hMf6Mf+DF/3MXL//P7Nv+9/D
R8PD7NE/L5Y0/73/Q5TalV9v/fbLbfTY6Wd/hbKsn7vhvhcttfh9p/Rx9F7ThpoO
zo/of+imn7jnrLbavsef4r/UcA+RPuf3Q+f9UqkU/8ap/+MFIjMqlZkqslsVZsrV
JUlRZLa2yy2qaRaWWqRTKzaZooGCAwg+x/nV+FYg+fi2+gz8s/Z89W73ufUfZfMZ
rG5jSeX2+tXiLy5tM25ZFqjVUHVXHVO7t3Rjfk7WWV5Xd3zfCC7d74/Bsvzb8BBp
uu3U3zvXOnzxjyszB3F1Lpzy88Auvjt8OJfX88hg8tvPa23zrze8IBCEkACBACSe
svoy46IiKqqiKiKrmbpczNUAkJJCTVerLbqur773rXpy1c6c7tea+Z7XygAnXQEQ
RJmCo+i1VHsgGMnt6oTG4h52C6u8SvLrMP/waB4Bwc2A8sBaDwhBB/o7aeobMefe
uPi73vZt7rVet2rb0T0fQ/9rykNCbO/hd3LcnNv0nxbJpOOM9dbX3aauDKzP4RVk
8gGChiP3tin+2Ko0zGvv8rm997r3xV1pt67QJwiEFqEG2tbkdFH93DBwDjIPBfPi
1V5aFeIAHWiKoxX7fYcN7XsJzs2YByCqCB9JkFUVQVTA6PRvzz5effmf8/OC9PMp
C+ZtzACFV1K3GMDvG5p00Ri2rRwdRGfGJGZluZmRrhVWSvlPXhbVm0jUeerZfHWX
OyPb4dvG7fq7d2YuV64ePXrvx6mb41zvjnrfDiqrwFcQ9VbJCMKmIWYsyFKsKZAp
mGYZYsykKYZSrJYGZBVZVDChZKsAxJMKFRiFQZVKxBZKLJJhJTbbapSlmzRec3cV
XShD4BDzmq1wkRIYPpUFVy20DjqcYA1wAOHwq+O9r3vWre0sCbAG9xdKyeSrfivb
QO34ZArRrbCmGhJ6LPbla+t+POc5nw7qzbdSzdq7p0eJSUbVXZtq6NOrQouWy7TR
Es2HZNRu1Stu7Ysi26gMq7VS751zzvXPF5506HQJCRi6HLltz9uN8Xm7zDLmXMwz
p7a33LluY0zKuVZCe1T/O/Vl8LrrrqrrpOIUG2dJip/z1f+mv/K98HqwOlWunXPV
64nVSTpZbdoyVil8PHTcq/c4iSP+Kkth+WA/sxSm2JD/tMfEf8rSNT+n1kfxMmZY
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`)
                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/bench/go1/mandel_test.go                                                          0100644 0000000 0000000 00000001521 13020111414 017111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark, taken from the shootuot, tests floating point performance.

package go1

import "testing"

func mandelbrot(n int) int {
	const Iter = 50
	const Zero float64 = 0
	const Limit = 2.0
	ok := 0
	for y := 0; y < n; y++ {
		for x := 0; x < n; x++ {
			Zr, Zi, Tr, Ti := Zero, Zero, Zero, Zero
			Cr := (2*float64(x)/float64(n) - 1.5)
			Ci := (2*float64(y)/float64(n) - 1.0)

			for i := 0; i < Iter && (Tr+Ti <= Limit*Limit); i++ {
				Zi = 2*Zr*Zi + Ci
				Zr = Tr - Ti + Cr
				Tr = Zr * Zr
				Ti = Zi * Zi
			}

			if Tr+Ti <= Limit*Limit {
				ok++
			}
		}
	}
	return ok
}

func BenchmarkMandelbrot200(b *testing.B) {
	for i := 0; i < b.N; i++ {
		mandelbrot(200)
	}
}
                                                                                                                                                                               usr/local/go/test/bench/go1/parser_test.go                                                          0100644 0000000 0000000 00000001611 13020111414 017145  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package go1

// go parser benchmark based on go/parser/performance_test.go

import (
	"compress/bzip2"
	"encoding/base64"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"strings"
	"testing"
)

var (
	parserbytes = makeParserBytes()
)

func makeParserBytes() []byte {
	var r io.Reader
	r = strings.NewReader(parserbz2_base64)
	r = base64.NewDecoder(base64.StdEncoding, r)
	r = bzip2.NewReader(r)
	b, err := ioutil.ReadAll(r)
	if err != nil {
		panic(err)
	}
	return b
}

func BenchmarkGoParse(b *testing.B) {
	b.SetBytes(int64(len(parserbytes)))
	for i := 0; i < b.N; i++ {
		if _, err := parser.ParseFile(token.NewFileSet(), "", parserbytes, parser.ParseComments); err != nil {
			b.Fatalf("benchmark failed due to parse error: %s", err)
		}
	}
}
                                                                                                                       usr/local/go/test/bench/go1/parserdata_test.go                                                      0100644 0000000 0000000 00000046005 13020111414 020005  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Input for parser benchmark.
// This was generated by starting with a the contents of
// src/pkg/go/parser/parser.go at rev 9b455eb64690, then 
// compressing with bzip2 -9, then encoding to base64.
// We compile the data into the binary so that the benchmark is
// a stand-alone binary that can be copied easily from machine to
// machine. parser_test.go decodes this during init.

package go1

var parserbz2_base64 = "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" +
	"v9hdyRThQkN3QmOE"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/local/go/test/bench/go1/regexp_test.go                                                          0100644 0000000 0000000 00000003213 13020111414 017143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package go1

import (
	"math/rand"
	"regexp"
	"testing"
)

// benchmark based on regexp/exec_test.go

var regexpText []byte

func makeRegexpText(n int) []byte {
	rand.Seed(0) // For reproducibility.
	if len(regexpText) >= n {
		return regexpText[:n]
	}
	regexpText = make([]byte, n)
	for i := range regexpText {
		if rand.Intn(30) == 0 {
			regexpText[i] = '\n'
		} else {
			regexpText[i] = byte(rand.Intn(0x7E+1-0x20) + 0x20)
		}
	}
	return regexpText
}

func benchmark(b *testing.B, re string, n int) {
	r := regexp.MustCompile(re)
	t := makeRegexpText(n)
	b.ResetTimer()
	b.SetBytes(int64(n))
	for i := 0; i < b.N; i++ {
		if r.Match(t) {
			b.Fatal("match!")
		}
	}
}

const (
	easy0  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
	easy1  = "A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$"
	medium = "[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
	hard   = "[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
)

func BenchmarkRegexpMatchEasy0_32(b *testing.B)  { benchmark(b, easy0, 32<<0) }
func BenchmarkRegexpMatchEasy0_1K(b *testing.B)  { benchmark(b, easy0, 1<<10) }
func BenchmarkRegexpMatchEasy1_32(b *testing.B)  { benchmark(b, easy1, 32<<0) }
func BenchmarkRegexpMatchEasy1_1K(b *testing.B)  { benchmark(b, easy1, 1<<10) }
func BenchmarkRegexpMatchMedium_32(b *testing.B) { benchmark(b, medium, 1<<0) }
func BenchmarkRegexpMatchMedium_1K(b *testing.B) { benchmark(b, medium, 1<<10) }
func BenchmarkRegexpMatchHard_32(b *testing.B)   { benchmark(b, hard, 32<<0) }
func BenchmarkRegexpMatchHard_1K(b *testing.B)   { benchmark(b, hard, 1<<10) }
                                                                                                                                                                                                                                                                                                                                                                                     usr/local/go/test/bench/go1/revcomp_test.go                                                         0100644 0000000 0000000 00000003421 13020111414 017325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark, taken from the shootout, tests array indexing
// and array bounds elimination performance.

package go1

import (
	"bufio"
	"bytes"
	"io/ioutil"
	"testing"
)

var revCompTable = [256]uint8{
	'A': 'T', 'a': 'T',
	'C': 'G', 'c': 'G',
	'G': 'C', 'g': 'C',
	'T': 'A', 't': 'A',
	'U': 'A', 'u': 'A',
	'M': 'K', 'm': 'K',
	'R': 'Y', 'r': 'Y',
	'W': 'W', 'w': 'W',
	'S': 'S', 's': 'S',
	'Y': 'R', 'y': 'R',
	'K': 'M', 'k': 'M',
	'V': 'B', 'v': 'B',
	'H': 'D', 'h': 'D',
	'D': 'H', 'd': 'H',
	'B': 'V', 'b': 'V',
	'N': 'N', 'n': 'N',
}

func revcomp(data []byte) {
	in := bufio.NewReader(bytes.NewBuffer(data))
	out := ioutil.Discard
	buf := make([]byte, 1024*1024)
	line, err := in.ReadSlice('\n')
	for err == nil {
		out.Write(line)

		// Accumulate reversed complement in buf[w:]
		nchar := 0
		w := len(buf)
		for {
			line, err = in.ReadSlice('\n')
			if err != nil || line[0] == '>' {
				break
			}
			line = line[0 : len(line)-1]
			nchar += len(line)
			if len(line)+nchar/60+128 >= w {
				nbuf := make([]byte, len(buf)*5)
				copy(nbuf[len(nbuf)-len(buf):], buf)
				w += len(nbuf) - len(buf)
				buf = nbuf
			}

			// This loop is the bottleneck.
			for _, c := range line {
				w--
				buf[w] = revCompTable[c]
			}
		}

		// Copy down to beginning of buffer, inserting newlines.
		// The loop left room for the newlines and 128 bytes of padding.
		i := 0
		for j := w; j < len(buf); j += 60 {
			n := copy(buf[i:i+60], buf[j:])
			buf[i+n] = '\n'
			i += n + 1
		}
		out.Write(buf[0:i])
	}
}

func BenchmarkRevcomp(b *testing.B) {
	b.SetBytes(int64(len(fastabytes)))
	for i := 0; i < b.N; i++ {
		revcomp(fastabytes)
	}
}
                                                                                                                                                                                                                                               usr/local/go/test/bench/go1/template_test.go                                                        0100644 0000000 0000000 00000002653 13020111414 017473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This benchmark tests text/template throughput,
// converting a large data structure with a simple template.

package go1

import (
	"bytes"
	"io/ioutil"
	"strings"
	"testing"
	"text/template"
)

// After removing \t and \n this generates identical output to
// json.Marshal, making it easy to test for correctness.
const tmplText = `
{
	"tree":{{template "node" .Tree}},
	"username":"{{.Username}}"
}
{{define "node"}}
{
	"name":"{{.Name}}",
	"kids":[
	{{range $i, $k := .Kids}}
		{{if $i}}
			,
		{{end}}
		{{template "node" $k}}
	{{end}}
	],
	"cl_weight":{{.CLWeight}},
	"touches":{{.Touches}},
	"min_t":{{.MinT}},
	"max_t":{{.MaxT}},
	"mean_t":{{.MeanT}}
}
{{end}}
`

func stripTabNL(r rune) rune {
	if r == '\t' || r == '\n' {
		return -1
	}
	return r
}

var tmpl = template.Must(template.New("main").Parse(strings.Map(stripTabNL, tmplText)))

func init() {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, &jsondata); err != nil {
		panic(err)
	}
	if !bytes.Equal(buf.Bytes(), jsonbytes) {
		println(buf.Len(), len(jsonbytes))
		panic("wrong output")
	}
}

func tmplexec() {
	if err := tmpl.Execute(ioutil.Discard, &jsondata); err != nil {
		panic(err)
	}
}

func BenchmarkTemplate(b *testing.B) {
	b.SetBytes(int64(len(jsonbytes)))
	for i := 0; i < b.N; i++ {
		tmplexec()
	}
}
                                                                                     usr/local/go/test/bench/go1/time_test.go                                                            0100644 0000000 0000000 00000001004 13020111414 016603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package go1

// benchmark based on time/time_test.go

import (
	"testing"
	"time"
)

func BenchmarkTimeParse(b *testing.B) {
	for i := 0; i < b.N; i++ {
		time.Parse(time.ANSIC, "Mon Jan  2 15:04:05 2006")
	}
}

func BenchmarkTimeFormat(b *testing.B) {
	t := time.Unix(1265346057, 0)
	for i := 0; i < b.N; i++ {
		t.Format("Mon Jan  2 15:04:05 2006")
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/bigalg.go                                                                         0100644 0000000 0000000 00000004171 13020111414 014276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test the internal "algorithms" for objects larger than a word: hashing, equality etc.

package main

type T struct {
	a float64
	b int64
	c string
	d byte
}

var a = []int{1, 2, 3}
var NIL []int

func arraycmptest() {
	if NIL != nil {
		println("fail1:", NIL, "!= nil")
		panic("bigalg")
	}
	if nil != NIL {
		println("fail2: nil !=", NIL)
		panic("bigalg")
	}
	if a == nil || nil == a {
		println("fail3:", a, "== nil")
		panic("bigalg")
	}
}

func SameArray(a, b []int) bool {
	if len(a) != len(b) || cap(a) != cap(b) {
		return false
	}
	if len(a) > 0 && &a[0] != &b[0] {
		return false
	}
	return true
}

var t = T{1.5, 123, "hello", 255}
var mt = make(map[int]T)
var ma = make(map[int][]int)

func maptest() {
	mt[0] = t
	t1 := mt[0]
	if t1.a != t.a || t1.b != t.b || t1.c != t.c || t1.d != t.d {
		println("fail: map val struct", t1.a, t1.b, t1.c, t1.d)
		panic("bigalg")
	}

	ma[1] = a
	a1 := ma[1]
	if !SameArray(a, a1) {
		println("fail: map val array", a, a1)
		panic("bigalg")
	}
}

var ct = make(chan T)
var ca = make(chan []int)

func send() {
	ct <- t
	ca <- a
}

func chantest() {
	go send()

	t1 := <-ct
	if t1.a != t.a || t1.b != t.b || t1.c != t.c || t1.d != t.d {
		println("fail: map val struct", t1.a, t1.b, t1.c, t1.d)
		panic("bigalg")
	}

	a1 := <-ca
	if !SameArray(a, a1) {
		println("fail: map val array", a, a1)
		panic("bigalg")
	}
}

type E struct{}

var e E

func interfacetest() {
	var i interface{}

	i = a
	a1 := i.([]int)
	if !SameArray(a, a1) {
		println("interface <-> []int", a, a1)
		panic("bigalg")
	}
	pa := new([]int)
	*pa = a
	i = pa
	a1 = *i.(*[]int)
	if !SameArray(a, a1) {
		println("interface <-> *[]int", a, a1)
		panic("bigalg")
	}

	i = t
	t1 := i.(T)
	if t1.a != t.a || t1.b != t.b || t1.c != t.c || t1.d != t.d {
		println("interface <-> struct", t1.a, t1.b, t1.c, t1.d)
		panic("bigalg")
	}

	i = e
	e1 := i.(E)
	// nothing to check; just verify it doesn't crash
	_ = e1
}

func main() {
	arraycmptest()
	maptest()
	chantest()
	interfacetest()
}
                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/go/test/bigmap.go                                                                         0100644 0000000 0000000 00000004724 13020111414 014314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Internally a map holds elements in up to 255 bytes of key+value.
// When key or value or both are too large, it uses pointers to key+value
// instead.  Test all the combinations.

package main

func seq(x, y int) [1000]byte {
	var r [1000]byte
	for i := 0; i < len(r); i++ {
		r[i] = byte(x + i*y)
	}
	return r
}

func cmp(x, y [1000]byte) {
	for i := 0; i < len(x); i++ {
		if x[i] != y[i] {
			panic("BUG mismatch")
		}
	}
}

func main() {
	m := make(map[int][1000]byte)
	m[1] = seq(11, 13)
	m[2] = seq(2, 9)
	m[3] = seq(3, 17)

	cmp(m[1], seq(11, 13))
	cmp(m[2], seq(2, 9))
	cmp(m[3], seq(3, 17))
	

	{
		type T [1]byte
		type V [1]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
  	}
	{
		type T [100]byte
		type V [1]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [1]byte
		type V [100]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [1000]byte
		type V [1]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [1]byte
		type V [1000]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [1000]byte
		type V [1000]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [200]byte
		type V [1]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [1]byte
		type V [200]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
		}
	}
	{
		type T [200]byte
		type V [200]byte
		m := make(map[T]V)
		m[T{}] = V{1}
		m[T{1}] = V{2}
		if x, y := m[T{}][0], m[T{1}][0]; x != 1 || y != 2 {
			println(x, y)
			panic("bad map")
  		}
  	}
}
                                            usr/local/go/test/blank.go                                                                          0100644 0000000 0000000 00000004144 13020111414 014140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test behavior of the blank identifier (_).

package main

import (
	"os"
	"unsafe"
)

import _ "fmt"

var call string

type T struct {
	_, _, _ int
}

func (T) _() {
}

func (T) _() {
}

type U struct {
	_ struct{ a, b, c int }
}

const (
	c0 = iota
	_
	_
	_
	c4
)

var ints = []string{
	"1",
	"2",
	"3",
}

func f() (int, int) {
	call += "f"
	return 1, 2
}

func g() (float64, float64) {
	call += "g"
	return 3, 4
}

func h(_ int, _ float64) {
}

func i() int {
	call += "i"
	return 23
}

var _ = i()

func main() {
	if call != "i" {
		panic("init did not run")
	}
	call = ""
	_, _ = f()
	a, _ := f()
	if a != 1 {
		panic(a)
	}
	b, _ := g()
	if b != 3 {
		panic(b)
	}
	_, a = f()
	if a != 2 {
		panic(a)
	}
	_, b = g()
	if b != 4 {
		panic(b)
	}
	_ = i()
	if call != "ffgfgi" {
		panic(call)
	}
	if c4 != 4 {
		panic(c4)
	}

	out := ""
	for _, s := range ints {
		out += s
	}
	if out != "123" {
		panic(out)
	}

	sum := 0
	for s := range ints {
		sum += s
	}
	if sum != 3 {
		panic(sum)
	}

	// go.tools/ssa/interp cannot support unsafe.Pointer.
	if os.Getenv("GOSSAINTERP") == "" {
		type T1 struct{ x, y, z int }
		t1 := *(*T)(unsafe.Pointer(&T1{1, 2, 3}))
		t2 := *(*T)(unsafe.Pointer(&T1{4, 5, 6}))
		if t1 != t2 {
			panic("T{} != T{}")
		}

		var u1, u2 interface{}
		u1 = *(*U)(unsafe.Pointer(&T1{1, 2, 3}))
		u2 = *(*U)(unsafe.Pointer(&T1{4, 5, 6}))
		if u1 != u2 {
			panic("U{} != U{}")
		}
	}

	h(a, b)

	m()
}

type I interface {
	M(_ int, y int)
}

type TI struct{}

func (_ TI) M(x int, y int) {
	if x != y {
		println("invalid M call:", x, y)
		panic("bad M")
	}
}

var fp = func(_ int, y int) {}

func init() {
	fp = fp1
}

func fp1(x, y int) {
	if x != y {
		println("invalid fp1 call:", x, y)
		panic("bad fp1")
	}
}

func m() {
	var i I

	i = TI{}
	i.M(1, 1)
	i.M(2, 2)

	fp(1, 1)
	fp(2, 2)
}

// useless but legal
var _ int = 1
var _ = 2
var _, _ = 3, 4

const _ = 3
const _, _ = 4, 5

type _ int

func _() {
	panic("oops")
}

func ff() {
	var _ int = 1
}
                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/blank1.go                                                                         0100644 0000000 0000000 00000001277 13020111414 014225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that incorrect uses of the blank identifer are caught.
// Does not compile.

package _	// ERROR "invalid package name _"

var t struct {
	_ int
}

func (x int) _() { // ERROR "cannot define new methods on non-local type"
	println(x)
}

type T struct {
      _ []int
}

func main() {
	_()	// ERROR "cannot use _ as value"
	x := _+1	// ERROR "cannot use _ as value"
	_ = x
	_ = t._ // ERROR "cannot refer to blank field|invalid use of"

      var v1, v2 T
      _ = v1 == v2 // ERROR "cannot be compared|non-comparable"
}
                                                                                                                                                                                                                                                                                                                                 usr/local/go/test/bom.go                                                                            0100644 0000000 0000000 00000000626 13020111414 013627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // runoutput

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test source file beginning with a byte order mark.

package main

import (
	"fmt"
	"strings"
)

func main() {
	prog = strings.Replace(prog, "BOM", "\uFEFF", -1)
	fmt.Print(prog)
}

var prog = `BOM
package main

func main() {
}
`
                                                                                                          usr/local/go/test/bombad.go                                                                         0100644 0000000 0000000 00000000741 13020111414 014274  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Here for reference, but hard to test automatically
// because the BOM muddles the
// processing done by ../run.

package main

func main() {
	﻿// There's a bom here.	// ERROR "BOM"
	//﻿ And here.	// ERROR "BOM"
	/*﻿ And here.*/	// ERROR "BOM"
	println("hi﻿ there") // and here	// ERROR "BOM"
}
                               usr/local/go/test/bounds.go                                                                         0100644 0000000 0000000 00000013217 13020111414 014344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test, using compiler diagnostic flags, that bounds check elimination
// is eliminating the correct checks.

package foo

var (
	s []int

	a1 [1]int
	a1k [1000]int
	a100k [100000]int

	p1 *[1]int
	p1k *[1000]int
	p100k *[100000]int

	i int
	ui uint
	i8 int8
	ui8 uint8
	i16 int16
	ui16 uint16
	i32 int32
	ui32 uint32
	i64 int64
	ui64 uint64
)

func main() {
	// Most things need checks.
	use(s[i])
	use(a1[i])
	use(a1k[i])
	use(a100k[i])
	use(p1[i])
	use(p1k[i])
	use(p100k[i])

	use(s[ui])
	use(a1[ui])
	use(a1k[ui])
	use(a100k[ui])
	use(p1[ui])
	use(p1k[ui])
	use(p100k[ui])

	use(s[i8])
	use(a1[i8])
	use(a1k[i8])
	use(a100k[i8])
	use(p1[i8])
	use(p1k[i8])
	use(p100k[i8])

	// Unsigned 8-bit numbers don't need checks for len >= 2⁸.
	use(s[ui8])
	use(a1[ui8])
	use(a1k[ui8])  // ERROR "index bounds check elided"
	use(a100k[ui8])  // ERROR "index bounds check elided"
	use(p1[ui8])
	use(p1k[ui8])  // ERROR "index bounds check elided"
	use(p100k[ui8])  // ERROR "index bounds check elided"

	use(s[i16])
	use(a1[i16])
	use(a1k[i16])
	use(a100k[i16])
	use(p1[i16])
	use(p1k[i16])
	use(p100k[i16])

	// Unsigned 16-bit numbers don't need checks for len >= 2¹⁶.
	use(s[ui16])
	use(a1[ui16])
	use(a1k[ui16])
	use(a100k[ui16])  // ERROR "index bounds check elided"
	use(p1[ui16])
	use(p1k[ui16])
	use(p100k[ui16])  // ERROR "index bounds check elided"

	use(s[i32])
	use(a1[i32])
	use(a1k[i32])
	use(a100k[i32])
	use(p1[i32])
	use(p1k[i32])
	use(p100k[i32])

	use(s[ui32])
	use(a1[ui32])
	use(a1k[ui32])
	use(a100k[ui32])
	use(p1[ui32])
	use(p1k[ui32])
	use(p100k[ui32])

	use(s[i64])
	use(a1[i64])
	use(a1k[i64])
	use(a100k[i64])
	use(p1[i64])
	use(p1k[i64])
	use(p100k[i64])

	use(s[ui64])
	use(a1[ui64])
	use(a1k[ui64])
	use(a100k[ui64])
	use(p1[ui64])
	use(p1k[ui64])
	use(p100k[ui64])

	// Mod truncates the maximum value to one less than the argument,
	// but signed mod can be negative, so only unsigned mod counts.
	use(s[i%999])
	use(a1[i%999])
	use(a1k[i%999])
	use(a100k[i%999])
	use(p1[i%999])
	use(p1k[i%999])
	use(p100k[i%999])

	use(s[ui%999])
	use(a1[ui%999])
	use(a1k[ui%999])  // ERROR "index bounds check elided"
	use(a100k[ui%999])  // ERROR "index bounds check elided"
	use(p1[ui%999])
	use(p1k[ui%999])  // ERROR "index bounds check elided"
	use(p100k[ui%999])  // ERROR "index bounds check elided"

	use(s[i%1000])
	use(a1[i%1000])
	use(a1k[i%1000])
	use(a100k[i%1000])
	use(p1[i%1000])
	use(p1k[i%1000])
	use(p100k[i%1000])

	use(s[ui%1000])
	use(a1[ui%1000])
	use(a1k[ui%1000])  // ERROR "index bounds check elided"
	use(a100k[ui%1000])  // ERROR "index bounds check elided"
	use(p1[ui%1000])
	use(p1k[ui%1000])  // ERROR "index bounds check elided"
	use(p100k[ui%1000])  // ERROR "index bounds check elided"

	use(s[i%1001])
	use(a1[i%1001])
	use(a1k[i%1001])
	use(a100k[i%1001])
	use(p1[i%1001])
	use(p1k[i%1001])
	use(p100k[i%1001])

	use(s[ui%1001])
	use(a1[ui%1001])
	use(a1k[ui%1001])
	use(a100k[ui%1001])  // ERROR "index bounds check elided"
	use(p1[ui%1001])
	use(p1k[ui%1001])
	use(p100k[ui%1001])  // ERROR "index bounds check elided"

	// Bitwise and truncates the maximum value to the mask value.
	// The result (for a positive mask) cannot be negative, so elision
	// applies to both signed and unsigned indexes.
	use(s[i&999])
	use(a1[i&999])
	use(a1k[i&999])  // ERROR "index bounds check elided"
	use(a100k[i&999])  // ERROR "index bounds check elided"
	use(p1[i&999])
	use(p1k[i&999])  // ERROR "index bounds check elided"
	use(p100k[i&999])  // ERROR "index bounds check elided"

	use(s[ui&999])
	use(a1[ui&999])
	use(a1k[ui&999])  // ERROR "index bounds check elided"
	use(a100k[ui&999])  // ERROR "index bounds check elided"
	use(p1[ui&999])
	use(p1k[ui&999])  // ERROR "index bounds check elided"
	use(p100k[ui&999])  // ERROR "index bounds check elided"

	use(s[i&1000])
	use(a1[i&1000])
	use(a1k[i&1000])
	use(a100k[i&1000])  // ERROR "index bounds check elided"
	use(p1[i&1000])
	use(p1k[i&1000])
	use(p100k[i&1000])  // ERROR "index bounds check elided"

	use(s[ui&1000])
	use(a1[ui&1000])
	use(a1k[ui&1000])
	use(a100k[ui&1000])  // ERROR "index bounds check elided"
	use(p1[ui&1000])
	use(p1k[ui&1000])
	use(p100k[ui&1000])  // ERROR "index bounds check elided"

	// Right shift cuts the effective number of bits in the index,
	// but only for unsigned (signed stays negative).
	use(s[i32>>22])
	use(a1[i32>>22])
	use(a1k[i32>>22])
	use(a100k[i32>>22])
	use(p1[i32>>22])
	use(p1k[i32>>22])
	use(p100k[i32>>22])

	use(s[ui32>>22])
	use(a1[ui32>>22])
	use(a1k[ui32>>22])
	use(a100k[ui32>>22])  // ERROR "index bounds check elided"
	use(p1[ui32>>22])
	use(p1k[ui32>>22])
	use(p100k[ui32>>22])  // ERROR "index bounds check elided"

	use(s[i32>>23])
	use(a1[i32>>23])
	use(a1k[i32>>23])
	use(a100k[i32>>23])
	use(p1[i32>>23])
	use(p1k[i32>>23])
	use(p100k[i32>>23])

	use(s[ui32>>23])
	use(a1[ui32>>23])
	use(a1k[ui32>>23])  // ERROR "index bounds check elided"
	use(a100k[ui32>>23])  // ERROR "index bounds check elided"
	use(p1[ui32>>23])
	use(p1k[ui32>>23])  // ERROR "index bounds check elided"
	use(p100k[ui32>>23])  // ERROR "index bounds check elided"

	// Division cuts the range like right shift does.
	use(s[i/1e6])
	use(a1[i/1e6])
	use(a1k[i/1e6])
	use(a100k[i/1e6])
	use(p1[i/1e6])
	use(p1k[i/1e6])
	use(p100k[i/1e6])

	use(s[ui/1e6])
	use(a1[ui/1e6])
	use(a1k[ui/1e6])
	use(p1[ui/1e6])
	use(p1k[ui/1e6])

	use(s[i/1e7])
	use(a1[i/1e7])
	use(a1k[i/1e7])
	use(a100k[i/1e7])
	use(p1[i/1e7])
	use(p1k[i/1e7])
	use(p100k[i/1e7])

	use(s[ui/1e7])
	use(a1[ui/1e7])
	use(p1[ui/1e7])
}

var sum int 

func use(x int) {
	sum += x
}
                                                                                                                                                                                                                                                                                                                                                                                 usr/local/go/test/bugs/                                                                             0040755 0000000 0000000 00000000000 13020111414 013462  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/bugs/bug395.go                                                                    0100644 0000000 0000000 00000000676 13020111414 015035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // skip

// When issue 1909 is fixed, change from skip to compile.

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Issue 1909
// Would OOM due to exponential recursion on Foo's expanded methodset in nodefmt

package test

type Foo interface {
	Bar() interface {
		Foo
	}
	Baz() interface {
		Foo
	}
	Bug() interface {
		Foo
	}
}
                                                                  usr/local/go/test/bugs/placeholder                                                                  0100644 0000000 0000000 00000000124 13020111414 015661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        This file keeps Mercurial from deleting the directory
when there are no known bugs.
                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/chan/                                                                             0040755 0000000 0000000 00000000000 13020111414 013433  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/chan/doubleselect.go                                                              0100644 0000000 0000000 00000003714 13020111414 016436  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test the situation in which two cases of a select can
// both end up running. See http://codereview.appspot.com/180068.

package main

import (
	"flag"
	"runtime"
)

var iterations *int = flag.Int("n", 100000, "number of iterations")

// sender sends a counter to one of four different channels. If two
// cases both end up running in the same iteration, the same value will be sent
// to two different channels.
func sender(n int, c1, c2, c3, c4 chan<- int) {
	defer close(c1)
	defer close(c2)
	defer close(c3)
	defer close(c4)

	for i := 0; i < n; i++ {
		select {
		case c1 <- i:
		case c2 <- i:
		case c3 <- i:
		case c4 <- i:
		}
	}
}

// mux receives the values from sender and forwards them onto another channel.
// It would be simpler to just have sender's four cases all be the same
// channel, but this doesn't actually trigger the bug.
func mux(out chan<- int, in <-chan int, done chan<- bool) {
	for v := range in {
		out <- v
	}
	done <- true
}

// recver gets a steam of values from the four mux's and checks for duplicates.
func recver(in <-chan int) {
	seen := make(map[int]bool)

	for v := range in {
		if _, ok := seen[v]; ok {
			println("got duplicate value: ", v)
			panic("fail")
		}
		seen[v] = true
	}
}

func main() {
	runtime.GOMAXPROCS(2)

	c1 := make(chan int)
	c2 := make(chan int)
	c3 := make(chan int)
	c4 := make(chan int)
	done := make(chan bool)
	cmux := make(chan int)
	go sender(*iterations, c1, c2, c3, c4)
	go mux(cmux, c1, done)
	go mux(cmux, c2, done)
	go mux(cmux, c3, done)
	go mux(cmux, c4, done)
	go func() {
		<-done
		<-done
		<-done
		<-done
		close(cmux)
	}()
	// We keep the recver because it might catch more bugs in the future.
	// However, the result of the bug linked to at the top is that we'll
	// end up panicking with: "throw: bad g->status in ready".
	recver(cmux)
}
                                                    usr/local/go/test/chan/fifo.go                                                                      0100644 0000000 0000000 00000001601 13020111414 014700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that unbuffered channels act as pure fifos.

package main

import "os"

const N = 10

func AsynchFifo() {
	ch := make(chan int, N)
	for i := 0; i < N; i++ {
		ch <- i
	}
	for i := 0; i < N; i++ {
		if <-ch != i {
			print("bad receive\n")
			os.Exit(1)
		}
	}
}

func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
	<-in
	if <-ch != val {
		panic(val)
	}
	out <- 1
}

// thread together a daisy chain to read the elements in sequence
func SynchFifo() {
	ch := make(chan int)
	in := make(chan int)
	start := in
	for i := 0; i < N; i++ {
		out := make(chan int)
		go Chain(ch, i, in, out)
		in = out
	}
	start <- 0
	for i := 0; i < N; i++ {
		ch <- i
	}
	<-in
}

func main() {
	AsynchFifo()
	SynchFifo()
}

                                                                                                                               usr/local/go/test/chan/goroutines.go                                                                0100644 0000000 0000000 00000001347 13020111414 016162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Torture test for goroutines.
// Make a lot of goroutines, threaded together, and tear them down cleanly.

package main

import (
	"os"
	"strconv"
)

func f(left, right chan int) {
	left <- <-right
}

func main() {
	var n = 10000
	if len(os.Args) > 1 {
		var err error
		n, err = strconv.Atoi(os.Args[1])
		if err != nil {
			print("bad arg\n")
			os.Exit(1)
		}
	}
	leftmost := make(chan int)
	right := leftmost
	left := leftmost
	for i := 0; i < n; i++ {
		right = make(chan int)
		go f(left, right)
		left = right
	}
	go func(c chan int) { c <- 1 }(right)
	<-leftmost
}
                                                                                                                                                                                                                                                                                         usr/local/go/test/chan/nonblock.go                                                                  0100644 0000000 0000000 00000007674 13020111414 015602  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test channel operations that test for blocking.
// Use several sizes and types of operands.

package main

import "runtime"
import "time"

func i32receiver(c chan int32, strobe chan bool) {
	if <-c != 123 {
		panic("i32 value")
	}
	strobe <- true
}

func i32sender(c chan int32, strobe chan bool) {
	c <- 234
	strobe <- true
}

func i64receiver(c chan int64, strobe chan bool) {
	if <-c != 123456 {
		panic("i64 value")
	}
	strobe <- true
}

func i64sender(c chan int64, strobe chan bool) {
	c <- 234567
	strobe <- true
}

func breceiver(c chan bool, strobe chan bool) {
	if !<-c {
		panic("b value")
	}
	strobe <- true
}

func bsender(c chan bool, strobe chan bool) {
	c <- true
	strobe <- true
}

func sreceiver(c chan string, strobe chan bool) {
	if <-c != "hello" {
		panic("s value")
	}
	strobe <- true
}

func ssender(c chan string, strobe chan bool) {
	c <- "hello again"
	strobe <- true
}

var ticker = time.Tick(10 * 1000) // 10 us
func sleep() {
	<-ticker
	<-ticker
	runtime.Gosched()
	runtime.Gosched()
	runtime.Gosched()
}

const maxTries = 10000 // Up to 100ms per test.

func main() {
	var i32 int32
	var i64 int64
	var b bool
	var s string

	var sync = make(chan bool)

	for buffer := 0; buffer < 2; buffer++ {
		c32 := make(chan int32, buffer)
		c64 := make(chan int64, buffer)
		cb := make(chan bool, buffer)
		cs := make(chan string, buffer)

		select {
		case i32 = <-c32:
			panic("blocked i32sender")
		default:
		}

		select {
		case i64 = <-c64:
			panic("blocked i64sender")
		default:
		}

		select {
		case b = <-cb:
			panic("blocked bsender")
		default:
		}

		select {
		case s = <-cs:
			panic("blocked ssender")
		default:
		}

		go i32receiver(c32, sync)
		try := 0
	Send32:
		for {
			select {
			case c32 <- 123:
				break Send32
			default:
				try++
				if try > maxTries {
					println("i32receiver buffer=", buffer)
					panic("fail")
				}
				sleep()
			}
		}
		<-sync

		go i32sender(c32, sync)
		if buffer > 0 {
			<-sync
		}
		try = 0
	Recv32:
		for {
			select {
			case i32 = <-c32:
				break Recv32
			default:
				try++
				if try > maxTries {
					println("i32sender buffer=", buffer)
					panic("fail")
				}
				sleep()
			}
		}
		if i32 != 234 {
			panic("i32sender value")
		}
		if buffer == 0 {
			<-sync
		}

		go i64receiver(c64, sync)
		try = 0
	Send64:
		for {
			select {
			case c64 <- 123456:
				break Send64
			default:
				try++
				if try > maxTries {
					panic("i64receiver")
				}
				sleep()
			}
		}
		<-sync

		go i64sender(c64, sync)
		if buffer > 0 {
			<-sync
		}
		try = 0
	Recv64:
		for {
			select {
			case i64 = <-c64:
				break Recv64
			default:
				try++
				if try > maxTries {
					panic("i64sender")
				}
				sleep()
			}
		}
		if i64 != 234567 {
			panic("i64sender value")
		}
		if buffer == 0 {
			<-sync
		}

		go breceiver(cb, sync)
		try = 0
	SendBool:
		for {
			select {
			case cb <- true:
				break SendBool
			default:
				try++
				if try > maxTries {
					panic("breceiver")
				}
				sleep()
			}
		}
		<-sync

		go bsender(cb, sync)
		if buffer > 0 {
			<-sync
		}
		try = 0
	RecvBool:
		for {
			select {
			case b = <-cb:
				break RecvBool
			default:
				try++
				if try > maxTries {
					panic("bsender")
				}
				sleep()
			}
		}
		if !b {
			panic("bsender value")
		}
		if buffer == 0 {
			<-sync
		}

		go sreceiver(cs, sync)
		try = 0
	SendString:
		for {
			select {
			case cs <- "hello":
				break SendString
			default:
				try++
				if try > maxTries {
					panic("sreceiver")
				}
				sleep()
			}
		}
		<-sync

		go ssender(cs, sync)
		if buffer > 0 {
			<-sync
		}
		try = 0
	RecvString:
		for {
			select {
			case s = <-cs:
				break RecvString
			default:
				try++
				if try > maxTries {
					panic("ssender")
				}
				sleep()
			}
		}
		if s != "hello again" {
			panic("ssender value")
		}
		if buffer == 0 {
			<-sync
		}
	}
}
                                                                    usr/local/go/test/chan/perm.go                                                                      0100644 0000000 0000000 00000002246 13020111414 014726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test various correct and incorrect permutations of send-only,
// receive-only, and bidirectional channels.
// Does not compile.

package main

var (
	cr <-chan int
	cs chan<- int
	c  chan int
)

func main() {
	cr = c  // ok
	cs = c  // ok
	c = cr  // ERROR "illegal types|incompatible|cannot"
	c = cs  // ERROR "illegal types|incompatible|cannot"
	cr = cs // ERROR "illegal types|incompatible|cannot"
	cs = cr // ERROR "illegal types|incompatible|cannot"

	c <- 0 // ok
	<-c    // ok
	x, ok := <-c	// ok
	_, _ = x, ok

	cr <- 0 // ERROR "send"
	<-cr    // ok
	x, ok = <-cr	// ok
	_, _ = x, ok

	cs <- 0 // ok
	<-cs    // ERROR "receive"
	x, ok = <-cs	// ERROR "receive"
	_, _ = x, ok

	select {
	case c <- 0: // ok
	case x := <-c: // ok
		_ = x

	case cr <- 0: // ERROR "send"
	case x := <-cr: // ok
		_ = x

	case cs <- 0: // ok
	case x := <-cs: // ERROR "receive"
		_ = x
	}

	for _ = range cs {// ERROR "receive"
	}

	for range cs {// ERROR "receive"
	}

	close(c)
	close(cs)
	close(cr)  // ERROR "receive"
}
                                                                                                                                                                                                                                                                                                                                                          usr/local/go/test/chan/powser1.go                                                                   0100644 0000000 0000000 00000030701 13020111414 015360  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test concurrency primitives: power series.

// Power series package
// A power series is a channel, along which flow rational
// coefficients.  A denominator of zero signifies the end.
// Original code in Newsqueak by Doug McIlroy.
// See Squinting at Power Series by Doug McIlroy,
//   http://www.cs.bell-labs.com/who/rsc/thread/squint.pdf

package main

import "os"

type rat struct  {
	num, den  int64	// numerator, denominator
}

func (u rat) pr() {
	if u.den==1 {
		print(u.num)
	} else {
		print(u.num, "/", u.den)
	}
	print(" ")
}

func (u rat) eq(c rat) bool {
	return u.num == c.num && u.den == c.den
}

type dch struct {
	req chan  int
	dat chan  rat
	nam int
}

type dch2 [2] *dch

var chnames string
var chnameserial int
var seqno int

func mkdch() *dch {
	c := chnameserial % len(chnames)
	chnameserial++
	d := new(dch)
	d.req = make(chan int)
	d.dat = make(chan rat)
	d.nam = c
	return d
}

func mkdch2() *dch2 {
	d2 := new(dch2)
	d2[0] = mkdch()
	d2[1] = mkdch()
	return d2
}

// split reads a single demand channel and replicates its
// output onto two, which may be read at different rates.
// A process is created at first demand for a rat and dies
// after the rat has been sent to both outputs.

// When multiple generations of split exist, the newest
// will service requests on one channel, which is
// always renamed to be out[0]; the oldest will service
// requests on the other channel, out[1].  All generations but the
// newest hold queued data that has already been sent to
// out[0].  When data has finally been sent to out[1],
// a signal on the release-wait channel tells the next newer
// generation to begin servicing out[1].

func dosplit(in *dch, out *dch2, wait chan int ) {
	both := false	// do not service both channels

	select {
	case <-out[0].req:
		
	case <-wait:
		both = true
		select {
		case <-out[0].req:
			
		case <-out[1].req:
			out[0], out[1] = out[1], out[0]
		}
	}

	seqno++
	in.req <- seqno
	release := make(chan  int)
	go dosplit(in, out, release)
	dat := <-in.dat
	out[0].dat <- dat
	if !both {
		<-wait
	}
	<-out[1].req
	out[1].dat <- dat
	release <- 0
}

func split(in *dch, out *dch2) {
	release := make(chan int)
	go dosplit(in, out, release)
	release <- 0
}

func put(dat rat, out *dch) {
	<-out.req
	out.dat <- dat
}

func get(in *dch) rat {
	seqno++
	in.req <- seqno
	return <-in.dat
}

// Get one rat from each of n demand channels

func getn(in []*dch) []rat {
	n := len(in)
	if n != 2 { panic("bad n in getn") }
	req := new([2] chan int)
	dat := new([2] chan rat)
	out := make([]rat, 2)
	var i int
	var it rat
	for i=0; i<n; i++ {
		req[i] = in[i].req
		dat[i] = nil
	}
	for n=2*n; n>0; n-- {
		seqno++

		select {
		case req[0] <- seqno:
			dat[0] = in[0].dat
			req[0] = nil
		case req[1] <- seqno:
			dat[1] = in[1].dat
			req[1] = nil
		case it = <-dat[0]:
			out[0] = it
			dat[0] = nil
		case it = <-dat[1]:
			out[1] = it
			dat[1] = nil
		}
	}
	return out
}

// Get one rat from each of 2 demand channels

func get2(in0 *dch, in1 *dch) []rat {
	return getn([]*dch{in0, in1})
}

func copy(in *dch, out *dch) {
	for {
		<-out.req
		out.dat <- get(in)
	}
}

func repeat(dat rat, out *dch) {
	for {
		put(dat, out)
	}
}

type PS *dch	// power series
type PS2 *[2] PS // pair of power series

var Ones PS
var Twos PS

func mkPS() *dch {
	return mkdch()
}

func mkPS2() *dch2 {
	return mkdch2()
}

// Conventions
// Upper-case for power series.
// Lower-case for rationals.
// Input variables: U,V,...
// Output variables: ...,Y,Z

// Integer gcd; needed for rational arithmetic

func gcd (u, v int64) int64 {
	if u < 0 { return gcd(-u, v) }
	if u == 0 { return v }
	return gcd(v%u, u)
}

// Make a rational from two ints and from one int

func i2tor(u, v int64) rat {
	g := gcd(u,v)
	var r rat
	if v > 0 {
		r.num = u/g
		r.den = v/g
	} else {
		r.num = -u/g
		r.den = -v/g
	}
	return r
}

func itor(u int64) rat {
	return i2tor(u, 1)
}

var zero rat
var one rat


// End mark and end test

var finis rat

func end(u rat) int64 {
	if u.den==0 { return 1 }
	return 0
}

// Operations on rationals

func add(u, v rat) rat {
	g := gcd(u.den,v.den)
	return  i2tor(u.num*(v.den/g)+v.num*(u.den/g),u.den*(v.den/g))
}

func mul(u, v rat) rat {
	g1 := gcd(u.num,v.den)
	g2 := gcd(u.den,v.num)
	var r rat
	r.num = (u.num/g1)*(v.num/g2)
	r.den = (u.den/g2)*(v.den/g1)
	return r
}

func neg(u rat) rat {
	return i2tor(-u.num, u.den)
}

func sub(u, v rat) rat {
	return add(u, neg(v))
}

func inv(u rat) rat {	// invert a rat
	if u.num == 0 { panic("zero divide in inv") }
	return i2tor(u.den, u.num)
}

// print eval in floating point of PS at x=c to n terms
func evaln(c rat, U PS, n int) {
	xn := float64(1)
	x := float64(c.num)/float64(c.den)
	val := float64(0)
	for i:=0; i<n; i++ {
		u := get(U)
		if end(u) != 0 {
			break
		}
		val = val + x * float64(u.num)/float64(u.den)
		xn = xn*x
	}
	print(val, "\n")
}

// Print n terms of a power series
func printn(U PS, n int) {
	done := false
	for ; !done && n>0; n-- {
		u := get(U)
		if end(u) != 0 {
			done = true
		} else {
			u.pr()
		}
	}
	print(("\n"))
}

// Evaluate n terms of power series U at x=c
func eval(c rat, U PS, n int) rat {
	if n==0 { return zero }
	y := get(U)
	if end(y) != 0 { return zero }
	return add(y,mul(c,eval(c,U,n-1)))
}

// Power-series constructors return channels on which power
// series flow.  They start an encapsulated generator that
// puts the terms of the series on the channel.

// Make a pair of power series identical to a given power series

func Split(U PS) *dch2 {
	UU := mkdch2()
	go split(U,UU)
	return UU
}

// Add two power series
func Add(U, V PS) PS {
	Z := mkPS()
	go func() {
		var uv []rat
		for {
			<-Z.req
			uv = get2(U,V)
			switch end(uv[0])+2*end(uv[1]) {
			case 0:
				Z.dat <- add(uv[0], uv[1])
			case 1:
				Z.dat <- uv[1]
				copy(V,Z)
			case 2:
				Z.dat <- uv[0]
				copy(U,Z)
			case 3:
				Z.dat <- finis
			}
		}
	}()
	return Z
}

// Multiply a power series by a constant
func Cmul(c rat,U PS) PS {
	Z := mkPS()
	go func() {
		done := false
		for !done {
			<-Z.req
			u := get(U)
			if end(u) != 0 {
				done = true
			} else {
				Z.dat <- mul(c,u)
			}
		}
		Z.dat <- finis
	}()
	return Z
}

// Subtract

func Sub(U, V PS) PS {
	return Add(U, Cmul(neg(one), V))
}

// Multiply a power series by the monomial x^n

func Monmul(U PS, n int) PS {
	Z := mkPS()
	go func() {
		for ; n>0; n-- { put(zero,Z) }
		copy(U,Z)
	}()
	return Z
}

// Multiply by x

func Xmul(U PS) PS {
	return Monmul(U,1)
}

func Rep(c rat) PS {
	Z := mkPS()
	go repeat(c,Z)
	return Z
}

// Monomial c*x^n

func Mon(c rat, n int) PS {
	Z:=mkPS()
	go func() {
		if(c.num!=0) {
			for ; n>0; n=n-1 { put(zero,Z) }
			put(c,Z)
		}
		put(finis,Z)
	}()
	return Z
}

func Shift(c rat, U PS) PS {
	Z := mkPS()
	go func() {
		put(c,Z)
		copy(U,Z)
	}()
	return Z
}

// simple pole at 1: 1/(1-x) = 1 1 1 1 1 ...

// Convert array of coefficients, constant term first
// to a (finite) power series

/*
func Poly(a []rat) PS {
	Z:=mkPS()
	begin func(a []rat, Z PS) {
		j:=0
		done:=0
		for j=len(a); !done&&j>0; j=j-1)
			if(a[j-1].num!=0) done=1
		i:=0
		for(; i<j; i=i+1) put(a[i],Z)
		put(finis,Z)
	}()
	return Z
}
*/

// Multiply. The algorithm is
//	let U = u + x*UU
//	let V = v + x*VV
//	then UV = u*v + x*(u*VV+v*UU) + x*x*UU*VV

func Mul(U, V PS) PS {
	Z:=mkPS()
	go func() {
		<-Z.req
		uv := get2(U,V)
		if end(uv[0])!=0 || end(uv[1]) != 0 {
			Z.dat <- finis
		} else {
			Z.dat <- mul(uv[0],uv[1])
			UU := Split(U)
			VV := Split(V)
			W := Add(Cmul(uv[0],VV[0]),Cmul(uv[1],UU[0]))
			<-Z.req
			Z.dat <- get(W)
			copy(Add(W,Mul(UU[1],VV[1])),Z)
		}
	}()
	return Z
}

// Differentiate

func Diff(U PS) PS {
	Z:=mkPS()
	go func() {
		<-Z.req
		u := get(U)
		if end(u) == 0 {
			done:=false
			for i:=1; !done; i++ {
				u = get(U)
				if end(u) != 0 {
					done = true
				} else {
					Z.dat <- mul(itor(int64(i)),u)
					<-Z.req
				}
			}
		}
		Z.dat <- finis
	}()
	return Z
}

// Integrate, with const of integration
func Integ(c rat,U PS) PS {
	Z:=mkPS()
	go func() {
		put(c,Z)
		done:=false
		for i:=1; !done; i++ {
			<-Z.req
			u := get(U)
			if end(u) != 0 { done= true }
			Z.dat <- mul(i2tor(1,int64(i)),u)
		}
		Z.dat <- finis
	}()
	return Z
}

// Binomial theorem (1+x)^c

func Binom(c rat) PS {
	Z:=mkPS()
	go func() {
		n := 1
		t := itor(1)
		for c.num!=0 {
			put(t,Z)
			t = mul(mul(t,c),i2tor(1,int64(n)))
			c = sub(c,one)
			n++
		}
		put(finis,Z)
	}()
	return Z
}

// Reciprocal of a power series
//	let U = u + x*UU
//	let Z = z + x*ZZ
//	(u+x*UU)*(z+x*ZZ) = 1
//	z = 1/u
//	u*ZZ + z*UU +x*UU*ZZ = 0
//	ZZ = -UU*(z+x*ZZ)/u

func Recip(U PS) PS {
	Z:=mkPS()
	go func() {
		ZZ:=mkPS2()
		<-Z.req
		z := inv(get(U))
		Z.dat <- z
		split(Mul(Cmul(neg(z),U),Shift(z,ZZ[0])),ZZ)
		copy(ZZ[1],Z)
	}()
	return Z
}

// Exponential of a power series with constant term 0
// (nonzero constant term would make nonrational coefficients)
// bug: the constant term is simply ignored
//	Z = exp(U)
//	DZ = Z*DU
//	integrate to get Z

func Exp(U PS) PS {
	ZZ := mkPS2()
	split(Integ(one,Mul(ZZ[0],Diff(U))),ZZ)
	return ZZ[1]
}

// Substitute V for x in U, where the leading term of V is zero
//	let U = u + x*UU
//	let V = v + x*VV
//	then S(U,V) = u + VV*S(V,UU)
// bug: a nonzero constant term is ignored

func Subst(U, V PS) PS {
	Z:= mkPS()
	go func() {
		VV := Split(V)
		<-Z.req
		u := get(U)
		Z.dat <- u
		if end(u) == 0 {
			if end(get(VV[0])) != 0 {
				put(finis,Z)
			} else {
				copy(Mul(VV[0],Subst(U,VV[1])),Z)
			}
		}
	}()
	return Z
}

// Monomial Substition: U(c x^n)
// Each Ui is multiplied by c^i and followed by n-1 zeros

func MonSubst(U PS, c0 rat, n int) PS {
	Z:= mkPS()
	go func() {
		c := one
		for {
			<-Z.req
			u := get(U)
			Z.dat <- mul(u, c)
			c = mul(c, c0)
			if end(u) != 0 {
				Z.dat <- finis
				break
			}
			for i := 1; i < n; i++ {
				<-Z.req
				Z.dat <- zero
			}
		}
	}()
	return Z
}


func Init() {
	chnameserial = -1
	seqno = 0
	chnames = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	zero = itor(0)
	one = itor(1)
	finis = i2tor(1,0)
	Ones = Rep(one)
	Twos = Rep(itor(2))
}

func check(U PS, c rat, count int, str string) {
	for i := 0; i < count; i++ {
		r := get(U)
		if !r.eq(c) {
			print("got: ")
			r.pr()
			print("should get ")
			c.pr()
			print("\n")
			panic(str)
		}
	}
}

const N=10
func checka(U PS, a []rat, str string) {
	for i := 0; i < N; i++ {
		check(U, a[i], 1, str)
	}
}

func main() {
	Init()
	if len(os.Args) > 1 {  // print
		print("Ones: "); printn(Ones, 10)
		print("Twos: "); printn(Twos, 10)
		print("Add: "); printn(Add(Ones, Twos), 10)
		print("Diff: "); printn(Diff(Ones), 10)
		print("Integ: "); printn(Integ(zero, Ones), 10)
		print("CMul: "); printn(Cmul(neg(one), Ones), 10)
		print("Sub: "); printn(Sub(Ones, Twos), 10)
		print("Mul: "); printn(Mul(Ones, Ones), 10)
		print("Exp: "); printn(Exp(Ones), 15)
		print("MonSubst: "); printn(MonSubst(Ones, neg(one), 2), 10)
		print("ATan: "); printn(Integ(zero, MonSubst(Ones, neg(one), 2)), 10)
	} else {  // test
		check(Ones, one, 5, "Ones")
		check(Add(Ones, Ones), itor(2), 0, "Add Ones Ones")  // 1 1 1 1 1
		check(Add(Ones, Twos), itor(3), 0, "Add Ones Twos") // 3 3 3 3 3
		a := make([]rat, N)
		d := Diff(Ones)
		for i:=0; i < N; i++ {
			a[i] = itor(int64(i+1))
		}
		checka(d, a, "Diff")  // 1 2 3 4 5
		in := Integ(zero, Ones)
		a[0] = zero  // integration constant
		for i:=1; i < N; i++ {
			a[i] = i2tor(1, int64(i))
		}
		checka(in, a, "Integ")  // 0 1 1/2 1/3 1/4 1/5
		check(Cmul(neg(one), Twos), itor(-2), 10, "CMul")  // -1 -1 -1 -1 -1
		check(Sub(Ones, Twos), itor(-1), 0, "Sub Ones Twos")  // -1 -1 -1 -1 -1
		m := Mul(Ones, Ones)
		for i:=0; i < N; i++ {
			a[i] = itor(int64(i+1))
		}
		checka(m, a, "Mul")  // 1 2 3 4 5
		e := Exp(Ones)
		a[0] = itor(1)
		a[1] = itor(1)
		a[2] = i2tor(3,2)
		a[3] = i2tor(13,6)
		a[4] = i2tor(73,24)
		a[5] = i2tor(167,40)
		a[6] = i2tor(4051,720)
		a[7] = i2tor(37633,5040)
		a[8] = i2tor(43817,4480)
		a[9] = i2tor(4596553,362880)
		checka(e, a, "Exp")  // 1 1 3/2 13/6 73/24
		at := Integ(zero, MonSubst(Ones, neg(one), 2))
		for c, i := 1, 0; i < N; i++ {
			if i%2 == 0 {
				a[i] = zero
			} else {
				a[i] = i2tor(int64(c), int64(i))
				c *= -1
			}
		}
		checka(at, a, "ATan")  // 0 -1 0 -1/3 0 -1/5
/*
		t := Revert(Integ(zero, MonSubst(Ones, neg(one), 2)))
		a[0] = zero
		a[1] = itor(1)
		a[2] = zero
		a[3] = i2tor(1,3)
		a[4] = zero
		a[5] = i2tor(2,15)
		a[6] = zero
		a[7] = i2tor(17,315)
		a[8] = zero
		a[9] = i2tor(62,2835)
		checka(t, a, "Tan")  // 0 1 0 1/3 0 2/15
*/
	}
}
                                                               usr/local/go/test/chan/powser2.go                                                                   0100644 0000000 0000000 00000032036 13020111414 015364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test concurrency primitives: power series.

// Like powser1.go but uses channels of interfaces.
// Has not been cleaned up as much as powser1.go, to keep
// it distinct and therefore a different test.

// Power series package
// A power series is a channel, along which flow rational
// coefficients.  A denominator of zero signifies the end.
// Original code in Newsqueak by Doug McIlroy.
// See Squinting at Power Series by Doug McIlroy,
//   http://www.cs.bell-labs.com/who/rsc/thread/squint.pdf

package main

import "os"

type rat struct  {
	num, den  int64	// numerator, denominator
}

type item interface {
	pr()
	eq(c item) bool
}

func (u *rat) pr(){
	if u.den==1 {
		print(u.num)
	} else {
		print(u.num, "/", u.den)
	}
	print(" ")
}

func (u *rat) eq(c item) bool {
	c1 := c.(*rat)
	return u.num == c1.num && u.den == c1.den
}

type dch struct {
	req chan  int
	dat chan  item
	nam int
}

type dch2 [2] *dch

var chnames string
var chnameserial int
var seqno int

func mkdch() *dch {
	c := chnameserial % len(chnames)
	chnameserial++
	d := new(dch)
	d.req = make(chan int)
	d.dat = make(chan item)
	d.nam = c
	return d
}

func mkdch2() *dch2 {
	d2 := new(dch2)
	d2[0] = mkdch()
	d2[1] = mkdch()
	return d2
}

// split reads a single demand channel and replicates its
// output onto two, which may be read at different rates.
// A process is created at first demand for an item and dies
// after the item has been sent to both outputs.

// When multiple generations of split exist, the newest
// will service requests on one channel, which is
// always renamed to be out[0]; the oldest will service
// requests on the other channel, out[1].  All generations but the
// newest hold queued data that has already been sent to
// out[0].  When data has finally been sent to out[1],
// a signal on the release-wait channel tells the next newer
// generation to begin servicing out[1].

func dosplit(in *dch, out *dch2, wait chan int ){
	both := false	// do not service both channels

	select {
	case <-out[0].req:
		
	case <-wait:
		both = true
		select {
		case <-out[0].req:
			
		case <-out[1].req:
			out[0],out[1] = out[1], out[0]
		}
	}

	seqno++
	in.req <- seqno
	release := make(chan  int)
	go dosplit(in, out, release)
	dat := <-in.dat
	out[0].dat <- dat
	if !both {
		<-wait
	}
	<-out[1].req
	out[1].dat <- dat
	release <- 0
}

func split(in *dch, out *dch2){
	release := make(chan int)
	go dosplit(in, out, release)
	release <- 0
}

func put(dat item, out *dch){
	<-out.req
	out.dat <- dat
}

func get(in *dch) *rat {
	seqno++
	in.req <- seqno
	return (<-in.dat).(*rat)
}

// Get one item from each of n demand channels

func getn(in []*dch) []item {
	n:=len(in)
	if n != 2 { panic("bad n in getn") }
	req := make([] chan int, 2)
	dat := make([] chan item, 2)
	out := make([]item, 2)
	var i int
	var it item
	for i=0; i<n; i++ {
		req[i] = in[i].req
		dat[i] = nil
	}
	for n=2*n; n>0; n-- {
		seqno++

		select{
		case req[0] <- seqno:
			dat[0] = in[0].dat
			req[0] = nil
		case req[1] <- seqno:
			dat[1] = in[1].dat
			req[1] = nil
		case it = <-dat[0]:
			out[0] = it
			dat[0] = nil
		case it = <-dat[1]:
			out[1] = it
			dat[1] = nil
		}
	}
	return out
}

// Get one item from each of 2 demand channels

func get2(in0 *dch, in1 *dch)  []item {
	return getn([]*dch{in0, in1})
}

func copy(in *dch, out *dch){
	for {
		<-out.req
		out.dat <- get(in)
	}
}

func repeat(dat item, out *dch){
	for {
		put(dat, out)
	}
}

type PS *dch	// power series
type PS2 *[2] PS // pair of power series

var Ones PS
var Twos PS

func mkPS() *dch {
	return mkdch()
}

func mkPS2() *dch2 {
	return mkdch2()
}

// Conventions
// Upper-case for power series.
// Lower-case for rationals.
// Input variables: U,V,...
// Output variables: ...,Y,Z

// Integer gcd; needed for rational arithmetic

func gcd (u, v int64) int64{
	if u < 0 { return gcd(-u, v) }
	if u == 0 { return v }
	return gcd(v%u, u)
}

// Make a rational from two ints and from one int

func i2tor(u, v int64) *rat{
	g := gcd(u,v)
	r := new(rat)
	if v > 0 {
		r.num = u/g
		r.den = v/g
	} else {
		r.num = -u/g
		r.den = -v/g
	}
	return r
}

func itor(u int64) *rat{
	return i2tor(u, 1)
}

var zero *rat
var one *rat


// End mark and end test

var finis *rat

func end(u *rat) int64 {
	if u.den==0 { return 1 }
	return 0
}

// Operations on rationals

func add(u, v *rat) *rat {
	g := gcd(u.den,v.den)
	return  i2tor(u.num*(v.den/g)+v.num*(u.den/g),u.den*(v.den/g))
}

func mul(u, v *rat) *rat{
	g1 := gcd(u.num,v.den)
	g2 := gcd(u.den,v.num)
	r := new(rat)
	r.num =(u.num/g1)*(v.num/g2)
	r.den = (u.den/g2)*(v.den/g1)
	return r
}

func neg(u *rat) *rat{
	return i2tor(-u.num, u.den)
}

func sub(u, v *rat) *rat{
	return add(u, neg(v))
}

func inv(u *rat) *rat{	// invert a rat
	if u.num == 0 { panic("zero divide in inv") }
	return i2tor(u.den, u.num)
}

// print eval in floating point of PS at x=c to n terms
func Evaln(c *rat, U PS, n int) {
	xn := float64(1)
	x := float64(c.num)/float64(c.den)
	val := float64(0)
	for i:=0; i<n; i++ {
		u := get(U)
		if end(u) != 0 {
			break
		}
		val = val + x * float64(u.num)/float64(u.den)
		xn = xn*x
	}
	print(val, "\n")
}

// Print n terms of a power series
func Printn(U PS, n int){
	done := false
	for ; !done && n>0; n-- {
		u := get(U)
		if end(u) != 0 {
			done = true
		} else {
			u.pr()
		}
	}
	print(("\n"))
}

func Print(U PS){
	Printn(U,1000000000)
}

// Evaluate n terms of power series U at x=c
func eval(c *rat, U PS, n int) *rat{
	if n==0 { return zero }
	y := get(U)
	if end(y) != 0 { return zero }
	return add(y,mul(c,eval(c,U,n-1)))
}

// Power-series constructors return channels on which power
// series flow.  They start an encapsulated generator that
// puts the terms of the series on the channel.

// Make a pair of power series identical to a given power series

func Split(U PS) *dch2{
	UU := mkdch2()
	go split(U,UU)
	return UU
}

// Add two power series
func Add(U, V PS) PS{
	Z := mkPS()
	go func(U, V, Z PS){
		var uv [] item
		for {
			<-Z.req
			uv = get2(U,V)
			switch end(uv[0].(*rat))+2*end(uv[1].(*rat)) {
			case 0:
				Z.dat <- add(uv[0].(*rat), uv[1].(*rat))
			case 1:
				Z.dat <- uv[1]
				copy(V,Z)
			case 2:
				Z.dat <- uv[0]
				copy(U,Z)
			case 3:
				Z.dat <- finis
			}
		}
	}(U, V, Z)
	return Z
}

// Multiply a power series by a constant
func Cmul(c *rat,U PS) PS{
	Z := mkPS()
	go func(c *rat, U, Z PS){
		done := false
		for !done {
			<-Z.req
			u := get(U)
			if end(u) != 0 {
				done = true
			} else {
				Z.dat <- mul(c,u)
			}
		}
		Z.dat <- finis
	}(c, U, Z)
	return Z
}

// Subtract

func Sub(U, V PS) PS{
	return Add(U, Cmul(neg(one), V))
}

// Multiply a power series by the monomial x^n

func Monmul(U PS, n int) PS{
	Z := mkPS()
	go func(n int, U PS, Z PS){
		for ; n>0; n-- { put(zero,Z) }
		copy(U,Z)
	}(n, U, Z)
	return Z
}

// Multiply by x

func Xmul(U PS) PS{
	return Monmul(U,1)
}

func Rep(c *rat) PS{
	Z := mkPS()
	go repeat(c,Z)
	return Z
}

// Monomial c*x^n

func Mon(c *rat, n int) PS{
	Z:=mkPS()
	go func(c *rat, n int, Z PS){
		if(c.num!=0) {
			for ; n>0; n=n-1 { put(zero,Z) }
			put(c,Z)
		}
		put(finis,Z)
	}(c, n, Z)
	return Z
}

func Shift(c *rat, U PS) PS{
	Z := mkPS()
	go func(c *rat, U, Z PS){
		put(c,Z)
		copy(U,Z)
	}(c, U, Z)
	return Z
}

// simple pole at 1: 1/(1-x) = 1 1 1 1 1 ...

// Convert array of coefficients, constant term first
// to a (finite) power series

/*
func Poly(a [] *rat) PS{
	Z:=mkPS()
	begin func(a [] *rat, Z PS){
		j:=0
		done:=0
		for j=len(a); !done&&j>0; j=j-1)
			if(a[j-1].num!=0) done=1
		i:=0
		for(; i<j; i=i+1) put(a[i],Z)
		put(finis,Z)
	}()
	return Z
}
*/

// Multiply. The algorithm is
//	let U = u + x*UU
//	let V = v + x*VV
//	then UV = u*v + x*(u*VV+v*UU) + x*x*UU*VV

func Mul(U, V PS) PS{
	Z:=mkPS()
	go func(U, V, Z PS){
		<-Z.req
		uv := get2(U,V)
		if end(uv[0].(*rat))!=0 || end(uv[1].(*rat)) != 0 {
			Z.dat <- finis
		} else {
			Z.dat <- mul(uv[0].(*rat),uv[1].(*rat))
			UU := Split(U)
			VV := Split(V)
			W := Add(Cmul(uv[0].(*rat),VV[0]),Cmul(uv[1].(*rat),UU[0]))
			<-Z.req
			Z.dat <- get(W)
			copy(Add(W,Mul(UU[1],VV[1])),Z)
		}
	}(U, V, Z)
	return Z
}

// Differentiate

func Diff(U PS) PS{
	Z:=mkPS()
	go func(U, Z PS){
		<-Z.req
		u := get(U)
		if end(u) == 0 {
			done:=false
			for i:=1; !done; i++ {
				u = get(U)
				if end(u) != 0 {
					done=true
				} else {
					Z.dat <- mul(itor(int64(i)),u)
					<-Z.req
				}
			}
		}
		Z.dat <- finis
	}(U, Z)
	return Z
}

// Integrate, with const of integration
func Integ(c *rat,U PS) PS{
	Z:=mkPS()
	go func(c *rat, U, Z PS){
		put(c,Z)
		done:=false
		for i:=1; !done; i++ {
			<-Z.req
			u := get(U)
			if end(u) != 0 { done= true }
			Z.dat <- mul(i2tor(1,int64(i)),u)
		}
		Z.dat <- finis
	}(c, U, Z)
	return Z
}

// Binomial theorem (1+x)^c

func Binom(c *rat) PS{
	Z:=mkPS()
	go func(c *rat, Z PS){
		n := 1
		t := itor(1)
		for c.num!=0 {
			put(t,Z)
			t = mul(mul(t,c),i2tor(1,int64(n)))
			c = sub(c,one)
			n++
		}
		put(finis,Z)
	}(c, Z)
	return Z
}

// Reciprocal of a power series
//	let U = u + x*UU
//	let Z = z + x*ZZ
//	(u+x*UU)*(z+x*ZZ) = 1
//	z = 1/u
//	u*ZZ + z*UU +x*UU*ZZ = 0
//	ZZ = -UU*(z+x*ZZ)/u

func Recip(U PS) PS{
	Z:=mkPS()
	go func(U, Z PS){
		ZZ:=mkPS2()
		<-Z.req
		z := inv(get(U))
		Z.dat <- z
		split(Mul(Cmul(neg(z),U),Shift(z,ZZ[0])),ZZ)
		copy(ZZ[1],Z)
	}(U, Z)
	return Z
}

// Exponential of a power series with constant term 0
// (nonzero constant term would make nonrational coefficients)
// bug: the constant term is simply ignored
//	Z = exp(U)
//	DZ = Z*DU
//	integrate to get Z

func Exp(U PS) PS{
	ZZ := mkPS2()
	split(Integ(one,Mul(ZZ[0],Diff(U))),ZZ)
	return ZZ[1]
}

// Substitute V for x in U, where the leading term of V is zero
//	let U = u + x*UU
//	let V = v + x*VV
//	then S(U,V) = u + VV*S(V,UU)
// bug: a nonzero constant term is ignored

func Subst(U, V PS) PS {
	Z:= mkPS()
	go func(U, V, Z PS) {
		VV := Split(V)
		<-Z.req
		u := get(U)
		Z.dat <- u
		if end(u) == 0 {
			if end(get(VV[0])) != 0 {
				put(finis,Z)
			} else {
				copy(Mul(VV[0],Subst(U,VV[1])),Z)
			}
		}
	}(U, V, Z)
	return Z
}

// Monomial Substition: U(c x^n)
// Each Ui is multiplied by c^i and followed by n-1 zeros

func MonSubst(U PS, c0 *rat, n int) PS {
	Z:= mkPS()
	go func(U, Z PS, c0 *rat, n int) {
		c := one
		for {
			<-Z.req
			u := get(U)
			Z.dat <- mul(u, c)
			c = mul(c, c0)
			if end(u) != 0 {
				Z.dat <- finis
				break
			}
			for i := 1; i < n; i++ {
				<-Z.req
				Z.dat <- zero
			}
		}
	}(U, Z, c0, n)
	return Z
}


func Init() {
	chnameserial = -1
	seqno = 0
	chnames = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	zero = itor(0)
	one = itor(1)
	finis = i2tor(1,0)
	Ones = Rep(one)
	Twos = Rep(itor(2))
}

func check(U PS, c *rat, count int, str string) {
	for i := 0; i < count; i++ {
		r := get(U)
		if !r.eq(c) {
			print("got: ")
			r.pr()
			print("should get ")
			c.pr()
			print("\n")
			panic(str)
		}
	}
}

const N=10
func checka(U PS, a []*rat, str string) {
	for i := 0; i < N; i++ {
		check(U, a[i], 1, str)
	}
}

func main() {
	Init()
	if len(os.Args) > 1 {  // print
		print("Ones: "); Printn(Ones, 10)
		print("Twos: "); Printn(Twos, 10)
		print("Add: "); Printn(Add(Ones, Twos), 10)
		print("Diff: "); Printn(Diff(Ones), 10)
		print("Integ: "); Printn(Integ(zero, Ones), 10)
		print("CMul: "); Printn(Cmul(neg(one), Ones), 10)
		print("Sub: "); Printn(Sub(Ones, Twos), 10)
		print("Mul: "); Printn(Mul(Ones, Ones), 10)
		print("Exp: "); Printn(Exp(Ones), 15)
		print("MonSubst: "); Printn(MonSubst(Ones, neg(one), 2), 10)
		print("ATan: "); Printn(Integ(zero, MonSubst(Ones, neg(one), 2)), 10)
	} else {  // test
		check(Ones, one, 5, "Ones")
		check(Add(Ones, Ones), itor(2), 0, "Add Ones Ones")  // 1 1 1 1 1
		check(Add(Ones, Twos), itor(3), 0, "Add Ones Twos") // 3 3 3 3 3
		a := make([]*rat, N)
		d := Diff(Ones)
		for i:=0; i < N; i++ {
			a[i] = itor(int64(i+1))
		}
		checka(d, a, "Diff")  // 1 2 3 4 5
		in := Integ(zero, Ones)
		a[0] = zero  // integration constant
		for i:=1; i < N; i++ {
			a[i] = i2tor(1, int64(i))
		}
		checka(in, a, "Integ")  // 0 1 1/2 1/3 1/4 1/5
		check(Cmul(neg(one), Twos), itor(-2), 10, "CMul")  // -1 -1 -1 -1 -1
		check(Sub(Ones, Twos), itor(-1), 0, "Sub Ones Twos")  // -1 -1 -1 -1 -1
		m := Mul(Ones, Ones)
		for i:=0; i < N; i++ {
			a[i] = itor(int64(i+1))
		}
		checka(m, a, "Mul")  // 1 2 3 4 5
		e := Exp(Ones)
		a[0] = itor(1)
		a[1] = itor(1)
		a[2] = i2tor(3,2)
		a[3] = i2tor(13,6)
		a[4] = i2tor(73,24)
		a[5] = i2tor(167,40)
		a[6] = i2tor(4051,720)
		a[7] = i2tor(37633,5040)
		a[8] = i2tor(43817,4480)
		a[9] = i2tor(4596553,362880)
		checka(e, a, "Exp")  // 1 1 3/2 13/6 73/24
		at := Integ(zero, MonSubst(Ones, neg(one), 2))
		for c, i := 1, 0; i < N; i++ {
			if i%2 == 0 {
				a[i] = zero
			} else {
				a[i] = i2tor(int64(c), int64(i))
				c *= -1
			}
		}
		checka(at, a, "ATan");  // 0 -1 0 -1/3 0 -1/5
/*
		t := Revert(Integ(zero, MonSubst(Ones, neg(one), 2)))
		a[0] = zero
		a[1] = itor(1)
		a[2] = zero
		a[3] = i2tor(1,3)
		a[4] = zero
		a[5] = i2tor(2,15)
		a[6] = zero
		a[7] = i2tor(17,315)
		a[8] = zero
		a[9] = i2tor(62,2835)
		checka(t, a, "Tan")  // 0 1 0 1/3 0 2/15
*/
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/test/chan/select.go                                                                    0100644 0000000 0000000 00000001621 13020111414 015236  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test simple select.

package main

var counter uint
var shift uint

func GetValue() uint {
	counter++
	return 1 << shift
}

func Send(a, b chan uint) int {
	var i int

LOOP:
	for {
		select {
		case a <- GetValue():
			i++
			a = nil
		case b <- GetValue():
			i++
			b = nil
		default:
			break LOOP
		}
		shift++
	}
	return i
}

func main() {
	a := make(chan uint, 1)
	b := make(chan uint, 1)
	if v := Send(a, b); v != 2 {
		println("Send returned", v, "!= 2")
		panic("fail")
	}
	if av, bv := <-a, <-b; av|bv != 3 {
		println("bad values", av, bv)
		panic("fail")
	}
	if v := Send(a, nil); v != 1 {
		println("Send returned", v, "!= 1")
		panic("fail")
	}
	if counter != 10 {
		println("counter is", counter, "!= 10")
		panic("fail")
	}
}
                                                                                                               usr/local/go/test/chan/select2.go                                                                   0100644 0000000 0000000 00000002047 13020111414 015323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that selects do not consume undue memory.

package main

import "runtime"

func sender(c chan int, n int) {
	for i := 0; i < n; i++ {
		c <- 1
	}
}

func receiver(c, dummy chan int, n int) {
	for i := 0; i < n; i++ {
		select {
		case <-c:
			// nothing
		case <-dummy:
			panic("dummy")
		}
	}
}

func main() {
	runtime.MemProfileRate = 0

	c := make(chan int)
	dummy := make(chan int)

	// warm up
	go sender(c, 100000)
	receiver(c, dummy, 100000)
	runtime.GC()
	memstats := new(runtime.MemStats)
	runtime.ReadMemStats(memstats)
	alloc := memstats.Alloc

	// second time shouldn't increase footprint by much
	go sender(c, 100000)
	receiver(c, dummy, 100000)
	runtime.GC()
	runtime.ReadMemStats(memstats)

	// Be careful to avoid wraparound.
	if memstats.Alloc > alloc && memstats.Alloc-alloc > 1.1e5 {
		println("BUG: too much memory for 100,000 selects:", memstats.Alloc-alloc)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/local/go/test/chan/select3.go                                                                   0100644 0000000 0000000 00000007476 13020111414 015337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test the semantics of the select statement
// for basic empty/non-empty cases.

package main

import "time"

const always = "function did not"
const never = "function did"


func unreachable() {
	panic("control flow shouldn't reach here")
}


// Calls f and verifies that f always/never panics depending on signal.
func testPanic(signal string, f func()) {
	defer func() {
		s := never
		if recover() != nil {
			s = always // f panicked
		}
		if s != signal {
			panic(signal + " panic")
		}
	}()
	f()
}


// Calls f and empirically verifies that f always/never blocks depending on signal.
func testBlock(signal string, f func()) {
	c := make(chan string)
	go func() {
		f()
		c <- never // f didn't block
	}()
	go func() {
		time.Sleep(1e8) // 0.1s seems plenty long
		c <- always     // f blocked always
	}()
	if <-c != signal {
		panic(signal + " block")
	}
}


func main() {
	const async = 1 // asynchronous channels
	var nilch chan int
	closedch := make(chan int)
	close(closedch)

	// sending/receiving from a nil channel blocks
	testBlock(always, func() {
		nilch <- 7
	})
	testBlock(always, func() {
		<-nilch
	})

	// sending/receiving from a nil channel inside a select is never selected
	testPanic(never, func() {
		select {
		case nilch <- 7:
			unreachable()
		default:
		}
	})
	testPanic(never, func() {
		select {
		case <-nilch:
			unreachable()
		default:
		}
	})

	// sending to an async channel with free buffer space never blocks
	testBlock(never, func() {
		ch := make(chan int, async)
		ch <- 7
	})

	// receiving from a closed channel never blocks
	testBlock(never, func() {
		for i := 0; i < 10; i++ {
			if <-closedch != 0 {
				panic("expected zero value when reading from closed channel")
			}
			if x, ok := <-closedch; x != 0 || ok {
				println("closedch:", x, ok)
				panic("expected 0, false from closed channel")
			}
		}
	})

	// sending to a closed channel panics.
	testPanic(always, func() {
		closedch <- 7
	})

	// receiving from a non-ready channel always blocks
	testBlock(always, func() {
		ch := make(chan int)
		<-ch
	})

	// empty selects always block
	testBlock(always, func() {
		select {
		}
	})

	// selects with only nil channels always block
	testBlock(always, func() {
		select {
		case <-nilch:
			unreachable()
		}
	})
	testBlock(always, func() {
		select {
		case nilch <- 7:
			unreachable()
		}
	})
	testBlock(always, func() {
		select {
		case <-nilch:
			unreachable()
		case nilch <- 7:
			unreachable()
		}
	})

	// selects with non-ready non-nil channels always block
	testBlock(always, func() {
		ch := make(chan int)
		select {
		case <-ch:
			unreachable()
		}
	})

	// selects with default cases don't block
	testBlock(never, func() {
		select {
		default:
		}
	})
	testBlock(never, func() {
		select {
		case <-nilch:
			unreachable()
		default:
		}
	})
	testBlock(never, func() {
		select {
		case nilch <- 7:
			unreachable()
		default:
		}
	})

	// selects with ready channels don't block
	testBlock(never, func() {
		ch := make(chan int, async)
		select {
		case ch <- 7:
		default:
			unreachable()
		}
	})
	testBlock(never, func() {
		ch := make(chan int, async)
		ch <- 7
		select {
		case <-ch:
		default:
			unreachable()
		}
	})

	// selects with closed channels behave like ordinary operations
	testBlock(never, func() {
		select {
		case <-closedch:
		}
	})
	testBlock(never, func() {
		select {
		case x := (<-closedch):
			_ = x
		}
	})
	testBlock(never, func() {
		select {
		case x, ok := (<-closedch):
			_, _ = x, ok
		}
	})
	testPanic(always, func() {
		select {
		case closedch <- 7:
		}
	})

	// select should not get confused if it sees itself
	testBlock(always, func() {
		c := make(chan int)
		select {
		case c <- 1:
		case <-c:
		}
	})
}
                                                                                                                                                                                                  usr/local/go/test/chan/select4.go                                                                   0100644 0000000 0000000 00000001001 13020111414 015312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file

// Test that a select statement proceeds when a value is ready.

package main

func f() *int {
	println("BUG: called f")
	return new(int)
}

func main() {
	var x struct {
		a int
	}
	c := make(chan int, 1)
	c1 := make(chan int)
	c <- 42
	select {
	case *f() = <-c1:
		// nothing
	case x.a = <-c:
		if x.a != 42 {
			println("BUG:", x.a)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/go/test/chan/select5.go                                                                   0100644 0000000 0000000 00000023742 13020111414 015333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // runoutput

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Generate test of channel operations and simple selects.
// The output of this program is compiled and run to do the
// actual test.

// Each test does only one real send or receive at a time, but phrased
// in various ways that the compiler may or may not rewrite
// into simpler expressions.

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"text/template"
)

func main() {
	out := bufio.NewWriter(os.Stdout)
	fmt.Fprintln(out, header)
	a := new(arg)

	// Generate each test as a separate function to avoid
	// hitting the gc optimizer with one enormous function.
	// If we name all the functions init we don't have to
	// maintain a list of which ones to run.
	do := func(t *template.Template) {
		for ; next(); a.reset() {
			fmt.Fprintln(out, `func init() {`)
			run(t, a, out)
			fmt.Fprintln(out, `}`)
		}
	}

	do(recv)
	do(send)
	do(recvOrder)
	do(sendOrder)
	do(nonblock)

	fmt.Fprintln(out, "//", a.nreset, "cases")
	out.Flush()
}

func run(t *template.Template, a interface{}, out io.Writer) {
	if err := t.Execute(out, a); err != nil {
		panic(err)
	}
}

type arg struct {
	def    bool
	nreset int
}

func (a *arg) Maybe() bool {
	return maybe()
}

func (a *arg) MaybeDefault() bool {
	if a.def {
		return false
	}
	a.def = maybe()
	return a.def
}

func (a *arg) MustDefault() bool {
	return !a.def
}

func (a *arg) reset() {
	a.def = false
	a.nreset++
}

const header = `// GENERATED BY select5.go; DO NOT EDIT

package main

// channel is buffered so test is single-goroutine.
// we are not interested in the concurrency aspects
// of select, just testing that the right calls happen.
var c = make(chan int, 1)
var nilch chan int
var n = 1
var x int
var i interface{}
var dummy = make(chan int)
var m = make(map[int]int)
var order = 0

func f(p *int) *int {
	return p
}

// check order of operations by ensuring that
// successive calls to checkorder have increasing o values.
func checkorder(o int) {
	if o <= order {
		println("invalid order", o, "after", order)
		panic("order")
	}
	order = o
}

func fc(c chan int, o int) chan int {
	checkorder(o)
	return c
}

func fp(p *int, o int) *int {
	checkorder(o)
	return p
}

func fn(n, o int) int {
	checkorder(o)
	return n
}

func die(x int) {
	println("have", x, "want", n)
	panic("chan")
}

func main() {
	// everything happens in init funcs
}
`

func parse(name, s string) *template.Template {
	t, err := template.New(name).Parse(s)
	if err != nil {
		panic(fmt.Sprintf("%q: %s", name, err))
	}
	return t
}

var recv = parse("recv", `
	{{/*  Send n, receive it one way or another into x, check that they match. */}}
	c <- n
	{{if .Maybe}}
	x = <-c
	{{else}}
	select {
	{{/*  Blocking or non-blocking, before the receive. */}}
	{{/*  The compiler implements two-case select where one is default with custom code, */}}
	{{/*  so test the default branch both before and after the send. */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Receive from c.  Different cases are direct, indirect, :=, interface, and map assignment. */}}
	{{if .Maybe}}
	case x = <-c:
	{{else}}{{if .Maybe}}
	case *f(&x) = <-c:
	{{else}}{{if .Maybe}}
	case y := <-c:
		x = y
	{{else}}{{if .Maybe}}
	case i = <-c:
		x = i.(int)
	{{else}}
	case m[13] = <-c:
		x = m[13]
	{{end}}{{end}}{{end}}{{end}}
	{{/*  Blocking or non-blocking again, after the receive. */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Dummy send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case dummy <- 1:
		panic("dummy send")
	{{end}}
	{{if .Maybe}}
	case <-dummy:
		panic("dummy receive")
	{{end}}
	{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case nilch <- 1:
		panic("nilch send")
	{{end}}
	{{if .Maybe}}
	case <-nilch:
		panic("nilch recv")
	{{end}}
	}
	{{end}}
	if x != n {
		die(x)
	}
	n++
`)

var recvOrder = parse("recvOrder", `
	{{/*  Send n, receive it one way or another into x, check that they match. */}}
	{{/*  Check order of operations along the way by calling functions that check */}}
	{{/*  that the argument sequence is strictly increasing. */}}
	order = 0
	c <- n
	{{if .Maybe}}
	{{/*  Outside of select, left-to-right rule applies. */}}
	{{/*  (Inside select, assignment waits until case is chosen, */}}
	{{/*  so right hand side happens before anything on left hand side. */}}
	*fp(&x, 1) = <-fc(c, 2)
	{{else}}{{if .Maybe}}
	m[fn(13, 1)] = <-fc(c, 2)
	x = m[13]
	{{else}}
	select {
	{{/*  Blocking or non-blocking, before the receive. */}}
	{{/*  The compiler implements two-case select where one is default with custom code, */}}
	{{/*  so test the default branch both before and after the send. */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Receive from c.  Different cases are direct, indirect, :=, interface, and map assignment. */}}
	{{if .Maybe}}
	case *fp(&x, 100) = <-fc(c, 1):
	{{else}}{{if .Maybe}}
	case y := <-fc(c, 1):
		x = y
	{{else}}{{if .Maybe}}
	case i = <-fc(c, 1):
		x = i.(int)
	{{else}}
	case m[fn(13, 100)] = <-fc(c, 1):
		x = m[13]
	{{end}}{{end}}{{end}}
	{{/*  Blocking or non-blocking again, after the receive. */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Dummy send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case fc(dummy, 2) <- fn(1, 3):
		panic("dummy send")
	{{end}}
	{{if .Maybe}}
	case <-fc(dummy, 4):
		panic("dummy receive")
	{{end}}
	{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case fc(nilch, 5) <- fn(1, 6):
		panic("nilch send")
	{{end}}
	{{if .Maybe}}
	case <-fc(nilch, 7):
		panic("nilch recv")
	{{end}}
	}
	{{end}}{{end}}
	if x != n {
		die(x)
	}
	n++
`)

var send = parse("send", `
	{{/*  Send n one way or another, receive it into x, check that they match. */}}
	{{if .Maybe}}
	c <- n
	{{else}}
	select {
	{{/*  Blocking or non-blocking, before the receive (same reason as in recv). */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Send c <- n.  No real special cases here, because no values come back */}}
	{{/*  from the send operation. */}}
	case c <- n:
	{{/*  Blocking or non-blocking. */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Dummy send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case dummy <- 1:
		panic("dummy send")
	{{end}}
	{{if .Maybe}}
	case <-dummy:
		panic("dummy receive")
	{{end}}
	{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case nilch <- 1:
		panic("nilch send")
	{{end}}
	{{if .Maybe}}
	case <-nilch:
		panic("nilch recv")
	{{end}}
	}
	{{end}}
	x = <-c
	if x != n {
		die(x)
	}
	n++
`)

var sendOrder = parse("sendOrder", `
	{{/*  Send n one way or another, receive it into x, check that they match. */}}
	{{/*  Check order of operations along the way by calling functions that check */}}
	{{/*  that the argument sequence is strictly increasing. */}}
	order = 0
	{{if .Maybe}}
	fc(c, 1) <- fn(n, 2)
	{{else}}
	select {
	{{/*  Blocking or non-blocking, before the receive (same reason as in recv). */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Send c <- n.  No real special cases here, because no values come back */}}
	{{/*  from the send operation. */}}
	case fc(c, 1) <- fn(n, 2):
	{{/*  Blocking or non-blocking. */}}
	{{if .MaybeDefault}}
	default:
		panic("nonblock")
	{{end}}
	{{/*  Dummy send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case fc(dummy, 3) <- fn(1, 4):
		panic("dummy send")
	{{end}}
	{{if .Maybe}}
	case <-fc(dummy, 5):
		panic("dummy receive")
	{{end}}
	{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}
	{{if .Maybe}}
	case fc(nilch, 6) <- fn(1, 7):
		panic("nilch send")
	{{end}}
	{{if .Maybe}}
	case <-fc(nilch, 8):
		panic("nilch recv")
	{{end}}
	}
	{{end}}
	x = <-c
	if x != n {
		die(x)
	}
	n++
`)

var nonblock = parse("nonblock", `
	x = n
	{{/*  Test various combinations of non-blocking operations. */}}
	{{/*  Receive assignments must not edit or even attempt to compute the address of the lhs. */}}
	select {
	{{if .MaybeDefault}}
	default:
	{{end}}
	{{if .Maybe}}
	case dummy <- 1:
		panic("dummy <- 1")
	{{end}}
	{{if .Maybe}}
	case nilch <- 1:
		panic("nilch <- 1")
	{{end}}
	{{if .Maybe}}
	case <-dummy:
		panic("<-dummy")
	{{end}}
	{{if .Maybe}}
	case x = <-dummy:
		panic("<-dummy x")
	{{end}}
	{{if .Maybe}}
	case **(**int)(nil) = <-dummy:
		panic("<-dummy (and didn't crash saving result!)")
	{{end}}
	{{if .Maybe}}
	case <-nilch:
		panic("<-nilch")
	{{end}}
	{{if .Maybe}}
	case x = <-nilch:
		panic("<-nilch x")
	{{end}}
	{{if .Maybe}}
	case **(**int)(nil) = <-nilch:
		panic("<-nilch (and didn't crash saving result!)")
	{{end}}
	{{if .MustDefault}}
	default:
	{{end}}
	}
	if x != n {
		die(x)
	}
	n++
`)

// Code for enumerating all possible paths through
// some logic.  The logic should call choose(n) when
// it wants to choose between n possibilities.
// On successive runs through the logic, choose(n)
// will return 0, 1, ..., n-1.  The helper maybe() is
// similar but returns true and then false.
//
// Given a function gen that generates an output
// using choose and maybe, code can generate all
// possible outputs using
//
//	for next() {
//		gen()
//	}

type choice struct {
	i, n int
}

var choices []choice
var cp int = -1

func maybe() bool {
	return choose(2) == 0
}

func choose(n int) int {
	if cp >= len(choices) {
		// never asked this before: start with 0.
		choices = append(choices, choice{0, n})
		cp = len(choices)
		return 0
	}
	// otherwise give recorded answer
	if n != choices[cp].n {
		panic("inconsistent choices")
	}
	i := choices[cp].i
	cp++
	return i
}

func next() bool {
	if cp < 0 {
		// start a new round
		cp = 0
		return true
	}

	// increment last choice sequence
	cp = len(choices) - 1
	for cp >= 0 && choices[cp].i == choices[cp].n-1 {
		cp--
	}
	if cp < 0 {
		choices = choices[:0]
		return false
	}
	choices[cp].i++
	choices = choices[:cp+1]
	cp = 0
	return true
}
                              usr/local/go/test/chan/select6.go                                                                   0100644 0000000 0000000 00000001420 13020111414 015321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test for select: Issue 2075
// A bug in select corrupts channel queues of failed cases
// if there are multiple waiters on those channels and the
// select is the last in the queue. If further waits are made
// on the channel without draining it first then those waiters
// will never wake up. In the code below c1 is such a channel.

package main

func main() {
	c1 := make(chan bool)
	c2 := make(chan bool)
	c3 := make(chan bool)
	go func() { <-c1 }()
	go func() {
		select {
		case <-c1:
			panic("dummy")
		case <-c2:
			c3 <- true
		}
		<-c1
	}()
	go func() { c2 <- true }()
	<-c3
	c1 <- true
	c1 <- true
}
                                                                                                                                                                                                                                                usr/local/go/test/chan/select7.go                                                                   0100644 0000000 0000000 00000001645 13020111414 015333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test select when discarding a value.

package main

import "runtime"

func recv1(c <-chan int) {
	<-c
}

func recv2(c <-chan int) {
	select {
	case <-c:
	}
}

func recv3(c <-chan int) {
	c2 := make(chan int)
	select {
	case <-c:
	case <-c2:
	}
}

func send1(recv func(<-chan int)) {
	c := make(chan int)
	go recv(c)
	runtime.Gosched()
	c <- 1
}

func send2(recv func(<-chan int)) {
	c := make(chan int)
	go recv(c)
	runtime.Gosched()
	select {
	case c <- 1:
	}
}

func send3(recv func(<-chan int)) {
	c := make(chan int)
	go recv(c)
	runtime.Gosched()
	c2 := make(chan int)
	select {
	case c <- 1:
	case c2 <- 1:
	}
}

func main() {
	send1(recv1)
	send2(recv1)
	send3(recv1)
	send1(recv2)
	send2(recv2)
	send3(recv2)
	send1(recv3)
	send2(recv3)
	send3(recv3)
}
                                                                                           usr/local/go/test/chan/sendstmt.go                                                                  0100644 0000000 0000000 00000001240 13020111414 015615  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test various parsing cases that are a little
// different now that send is a statement, not a expression.

package main

func main() {
	chanchan()
	sendprec()
}

func chanchan() {
	cc := make(chan chan int, 1)
	c := make(chan int, 1)
	cc <- c
	select {
	case <-cc <- 2:
	default:
		panic("nonblock")
	}
	if <-c != 2 {
		panic("bad receive")
	}
}

func sendprec() {
	c := make(chan bool, 1)
	c <- false || true	// not a syntax error: same as c <- (false || true)
	if !<-c {
		panic("sent false")
	}
}
                                                                                                                                                                                                                                                                                                                                                                usr/local/go/test/chan/sieve1.go                                                                    0100644 0000000 0000000 00000002771 13020111414 015162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test concurrency primitives: classical inefficient concurrent prime sieve.

// Generate primes up to 100 using channels, checking the results.
// This sieve consists of a linear chain of divisibility filters,
// equivalent to trial-dividing each n by all primes p ≤ n.

package main

// Send the sequence 2, 3, 4, ... to channel 'ch'.
func Generate(ch chan<- int) {
	for i := 2; ; i++ {
		ch <- i // Send 'i' to channel 'ch'.
	}
}

// Copy the values from channel 'in' to channel 'out',
// removing those divisible by 'prime'.
func Filter(in <-chan int, out chan<- int, prime int) {
	for i := range in { // Loop over values received from 'in'.
		if i%prime != 0 {
			out <- i // Send 'i' to channel 'out'.
		}
	}
}

// The prime sieve: Daisy-chain Filter processes together.
func Sieve(primes chan<- int) {
	ch := make(chan int) // Create a new channel.
	go Generate(ch)      // Start Generate() as a subprocess.
	for {
		// Note that ch is different on each iteration.
		prime := <-ch
		primes <- prime
		ch1 := make(chan int)
		go Filter(ch, ch1, prime)
		ch = ch1
	}
}

func main() {
	primes := make(chan int)
	go Sieve(primes)
	a := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
	for i := 0; i < len(a); i++ {
		if x := <-primes; x != a[i] {
			println(x, " != ", a[i])
			panic("fail")
		}
	}
}
       usr/local/go/test/chan/sieve2.go                                                                    0100644 0000000 0000000 00000007612 13020111414 015162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test concurrency primitives: prime sieve of Eratosthenes.

// Generate primes up to 100 using channels, checking the results.
// This sieve is Eratosthenesque and only considers odd candidates.
// See discussion at <http://blog.onideas.ws/eratosthenes.go>.

package main

import (
	"container/heap"
	"container/ring"
)

// Return a chan of odd numbers, starting from 5.
func odds() chan int {
	out := make(chan int, 50)
	go func() {
		n := 5
		for {
			out <- n
			n += 2
		}
	}()
	return out
}

// Return a chan of odd multiples of the prime number p, starting from p*p.
func multiples(p int) chan int {
	out := make(chan int, 10)
	go func() {
		n := p * p
		for {
			out <- n
			n += 2 * p
		}
	}()
	return out
}

type PeekCh struct {
	head int
	ch   chan int
}

// Heap of PeekCh, sorting by head values, satisfies Heap interface.
type PeekChHeap []*PeekCh

func (h *PeekChHeap) Less(i, j int) bool {
	return (*h)[i].head < (*h)[j].head
}

func (h *PeekChHeap) Swap(i, j int) {
	(*h)[i], (*h)[j] = (*h)[j], (*h)[i]
}

func (h *PeekChHeap) Len() int {
	return len(*h)
}

func (h *PeekChHeap) Pop() (v interface{}) {
	*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]
	return
}

func (h *PeekChHeap) Push(v interface{}) {
	*h = append(*h, v.(*PeekCh))
}

// Return a channel to serve as a sending proxy to 'out'.
// Use a goroutine to receive values from 'out' and store them
// in an expanding buffer, so that sending to 'out' never blocks.
func sendproxy(out chan<- int) chan<- int {
	proxy := make(chan int, 10)
	go func() {
		n := 16 // the allocated size of the circular queue
		first := ring.New(n)
		last := first
		var c chan<- int
		var e int
		for {
			c = out
			if first == last {
				// buffer empty: disable output
				c = nil
			} else {
				e = first.Value.(int)
			}
			select {
			case e = <-proxy:
				last.Value = e
				if last.Next() == first {
					// buffer full: expand it
					last.Link(ring.New(n))
					n *= 2
				}
				last = last.Next()
			case c <- e:
				first = first.Next()
			}
		}
	}()
	return proxy
}

// Return a chan int of primes.
func Sieve() chan int {
	// The output values.
	out := make(chan int, 10)
	out <- 2
	out <- 3

	// The channel of all composites to be eliminated in increasing order.
	composites := make(chan int, 50)

	// The feedback loop.
	primes := make(chan int, 10)
	primes <- 3

	// Merge channels of multiples of 'primes' into 'composites'.
	go func() {
		var h PeekChHeap
		min := 15
		for {
			m := multiples(<-primes)
			head := <-m
			for min < head {
				composites <- min
				minchan := heap.Pop(&h).(*PeekCh)
				min = minchan.head
				minchan.head = <-minchan.ch
				heap.Push(&h, minchan)
			}
			for min == head {
				minchan := heap.Pop(&h).(*PeekCh)
				min = minchan.head
				minchan.head = <-minchan.ch
				heap.Push(&h, minchan)
			}
			composites <- head
			heap.Push(&h, &PeekCh{<-m, m})
		}
	}()

	// Sieve out 'composites' from 'candidates'.
	go func() {
		// In order to generate the nth prime we only need multiples of
		// primes ≤ sqrt(nth prime).  Thus, the merging goroutine will
		// receive from 'primes' much slower than this goroutine
		// will send to it, making the buffer accumulate and block this
		// goroutine from sending, causing a deadlock.  The solution is to
		// use a proxy goroutine to do automatic buffering.
		primes := sendproxy(primes)

		candidates := odds()
		p := <-candidates

		for {
			c := <-composites
			for p < c {
				primes <- p
				out <- p
				p = <-candidates
			}
			if p == c {
				p = <-candidates
			}
		}
	}()

	return out
}

func main() {
	primes := Sieve()
	a := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
	for i := 0; i < len(a); i++ {
		if x := <-primes; x != a[i] {
			println(x, " != ", a[i])
			panic("fail")
		}
	}
}
                                                                                                                      usr/local/go/test/chan/zerosize.go                                                                  0100644 0000000 0000000 00000000535 13020111414 015634  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test making channels of a zero-sized type.

package main

func main() {
	_ = make(chan [0]byte)
	_ = make(chan [0]byte, 1)
	_ = make(chan struct{})
	_ = make(chan struct{}, 1)
}
                                                                                                                                                                   usr/local/go/test/chancap.go                                                                        0100644 0000000 0000000 00000001236 13020111414 014445  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test the cap predeclared function applied to channels.

package main

func main() {
	c := make(chan int, 10)
	if len(c) != 0 || cap(c) != 10 {
		println("chan len/cap ", len(c), cap(c), " want 0 10")
		panic("fail")
	}

	for i := 0; i < 3; i++ {
		c <- i
	}
	if len(c) != 3 || cap(c) != 10 {
		println("chan len/cap ", len(c), cap(c), " want 3 10")
		panic("fail")
	}

	c = make(chan int)
	if len(c) != 0 || cap(c) != 0 {
		println("chan len/cap ", len(c), cap(c), " want 0 0")
		panic("fail")
	}
}
                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/test/chanlinear.go                                                                     0100644 0000000 0000000 00000004170 13020111414 015154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // +build darwin linux
// run

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that dequeueing from a pending channel doesn't
// take linear time.

package main

import (
	"fmt"
	"runtime"
	"time"
)

// checkLinear asserts that the running time of f(n) is in O(n).
// tries is the initial number of iterations.
func checkLinear(typ string, tries int, f func(n int)) {
	// Depending on the machine and OS, this test might be too fast
	// to measure with accurate enough granularity. On failure,
	// make it run longer, hoping that the timing granularity
	// is eventually sufficient.

	timeF := func(n int) time.Duration {
		t1 := time.Now()
		f(n)
		return time.Since(t1)
	}

	t0 := time.Now()

	n := tries
	fails := 0
	for {
		runtime.GC()
		t1 := timeF(n)
		runtime.GC()
		t2 := timeF(2 * n)

		// should be 2x (linear); allow up to 3x
		if t2 < 3*t1 {
			if false {
				fmt.Println(typ, "\t", time.Since(t0))
			}
			return
		}
		// If n ops run in under a second and the ratio
		// doesn't work out, make n bigger, trying to reduce
		// the effect that a constant amount of overhead has
		// on the computed ratio.
		if t1 < 1*time.Second {
			n *= 2
			continue
		}
		// Once the test runs long enough for n ops,
		// try to get the right ratio at least once.
		// If five in a row all fail, give up.
		if fails++; fails >= 5 {
			panic(fmt.Sprintf("%s: too slow: %d channels: %v; %d channels: %v\n",
				typ, n, t1, 2*n, t2))
		}
	}
}

func main() {
	checkLinear("chanSelect", 1000, func(n int) {
		const messages = 10
		c := make(chan bool) // global channel
		var a []chan bool    // local channels for each goroutine
		for i := 0; i < n; i++ {
			d := make(chan bool)
			a = append(a, d)
			go func() {
				for j := 0; j < messages; j++ {
					// queue ourselves on the global channel
					select {
					case <-c:
					case <-d:
					}
				}
			}()
		}
		for i := 0; i < messages; i++ {
			// wake each goroutine up, forcing it to dequeue and then enqueue
			// on the global channel.
			for _, d := range a {
				d <- true
			}
		}
	})
}
                                                                                                                                                                                                                                                                                                                                                                                                        usr/local/go/test/char_lit.go                                                                       0100644 0000000 0000000 00000001221 13020111414 014627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test character literal syntax.

package main

import "os"

func main() {
	var i uint64 =
		' ' +
		'a' +
		'ä' +
		'本' +
		'\a' +
		'\b' +
		'\f' +
		'\n' +
		'\r' +
		'\t' +
		'\v' +
		'\\' +
		'\'' +
		'\000' +
		'\123' +
		'\x00' +
		'\xca' +
		'\xFE' +
		'\u0123' +
		'\ubabe' +
		'\U0010FFFF' +
		'\U000ebabe'
	if '\U000ebabe' != 0x000ebabe {
		print("ebabe wrong\n")
		os.Exit(1)
	}
	if i != 0x20e213 {
		print("number is ", i, " should be ", 0x20e213, "\n")
		os.Exit(1)
	}
}
                                                                                                                                                                                                                                                                                                                                                                               usr/local/go/test/char_lit1.go                                                                      0100644 0000000 0000000 00000001455 13020111414 014721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that illegal character literals are detected.
// Does not compile.

package main

const (
	// check that surrogate pair elements are invalid
	// (d800-dbff, dc00-dfff).
	_ = '\ud7ff' // ok
	_ = '\ud800'  // ERROR "Unicode|unicode"
	_ = "\U0000D999"  // ERROR "Unicode|unicode"
	_ = '\udc01' // ERROR "Unicode|unicode"
	_ = '\U0000dddd'  // ERROR "Unicode|unicode"
	_ = '\udfff' // ERROR "Unicode|unicode"
	_ = '\ue000' // ok
	_ = '\U0010ffff'  // ok
	_ = '\U00110000'  // ERROR "Unicode|unicode"
	_ = "abc\U0010ffffdef"  // ok
	_ = "abc\U00110000def"  // ERROR "Unicode|unicode"
	_ = '\Uffffffff'  // ERROR "Unicode|unicode"
)

                                                                                                                                                                                                                   usr/local/go/test/clearfat.go                                                                       0100644 0000000 0000000 00000002231 13020111414 014625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // runoutput

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Check that {5,6,8,9}g/ggen.c:clearfat is zeroing the entire object.

package main

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"
)

const ntest = 1100

func main() {
	var decls, calls bytes.Buffer

	for i := 1; i <= ntest; i++ {
		s := strconv.Itoa(i)
		decls.WriteString(strings.Replace(decl, "$", s, -1))
		calls.WriteString(strings.Replace("poison$()\n\tclearfat$()\n\t", "$", s, -1))
	}

	program = strings.Replace(program, "$DECLS", decls.String(), 1)
	program = strings.Replace(program, "$CALLS", calls.String(), 1)
	fmt.Print(program)
}

var program = `package main

var count int

$DECLS

func main() {
	$CALLS
	if count != 0 {
		println("failed", count, "case(s)")
	}
}
`

const decl = `
func poison$() {
	// Grow and poison the stack space that will be used by clearfat$
	var t [2*$]byte
	for i := range t {
		t[i] = 0xff
	}
}

func clearfat$() {
	var t [$]byte

	for _, x := range t {
		if x != 0 {
//			println("clearfat$: index", i, "expected 0, got", x)
			count++
			break
		}
	}
}
`
                                                                                                                                                                                                                                                                                                                                                                       usr/local/go/test/closedchan.go                                                                     0100644 0000000 0000000 00000013455 13020111414 015161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test close(c), receive of closed channel.
//
// TODO(rsc): Doesn't check behavior of close(c) when there
// are blocked senders/receivers.

package main

import "os"

var failed bool

type Chan interface {
	Send(int)
	Nbsend(int) bool
	Recv() (int)
	Nbrecv() (int, bool)
	Recv2() (int, bool)
	Nbrecv2() (int, bool, bool)
	Close()
	Impl() string
}

// direct channel operations when possible
type XChan chan int

func (c XChan) Send(x int) {
	c <- x
}

func (c XChan) Nbsend(x int) bool {
	select {
	case c <- x:
		return true
	default:
		return false
	}
	panic("nbsend")
}

func (c XChan) Recv() int {
	return <-c
}

func (c XChan) Nbrecv() (int, bool) {
	select {
	case x := <-c:
		return x, true
	default:
		return 0, false
	}
	panic("nbrecv")
}

func (c XChan) Recv2() (int, bool) {
	x, ok := <-c
	return x, ok
}

func (c XChan) Nbrecv2() (int, bool, bool) {
	select {
	case x, ok := <-c:
		return x, ok, true
	default:
		return 0, false, false
	}
	panic("nbrecv2")
}

func (c XChan) Close() {
	close(c)
}

func (c XChan) Impl() string {
	return "(<- operator)"
}

// indirect operations via select
type SChan chan int

func (c SChan) Send(x int) {
	select {
	case c <- x:
	}
}

func (c SChan) Nbsend(x int) bool {
	select {
	default:
		return false
	case c <- x:
		return true
	}
	panic("nbsend")
}

func (c SChan) Recv() int {
	select {
	case x := <-c:
		return x
	}
	panic("recv")
}

func (c SChan) Nbrecv() (int, bool) {
	select {
	default:
		return 0, false
	case x := <-c:
		return x, true
	}
	panic("nbrecv")
}

func (c SChan) Recv2() (int, bool) {
	select {
	case x, ok := <-c:
		return x, ok
	}
	panic("recv")
}

func (c SChan) Nbrecv2() (int, bool, bool) {
	select {
	default:
		return 0, false, false
	case x, ok := <-c:
		return x, ok, true
	}
	panic("nbrecv")
}

func (c SChan) Close() {
	close(c)
}

func (c SChan) Impl() string {
	return "(select)"
}

// indirect operations via larger selects
var dummy = make(chan bool)

type SSChan chan int

func (c SSChan) Send(x int) {
	select {
	case c <- x:
	case <-dummy:
	}
}

func (c SSChan) Nbsend(x int) bool {
	select {
	default:
		return false
	case <-dummy:
	case c <- x:
		return true
	}
	panic("nbsend")
}

func (c SSChan) Recv() int {
	select {
	case <-dummy:
	case x := <-c:
		return x
	}
	panic("recv")
}

func (c SSChan) Nbrecv() (int, bool) {
	select {
	case <-dummy:
	default:
		return 0, false
	case x := <-c:
		return x, true
	}
	panic("nbrecv")
}

func (c SSChan) Recv2() (int, bool) {
	select {
	case <-dummy:
	case x, ok := <-c:
		return x, ok
	}
	panic("recv")
}

func (c SSChan) Nbrecv2() (int, bool, bool) {
	select {
	case <-dummy:
	default:
		return 0, false, false
	case x, ok := <-c:
		return x, ok, true
	}
	panic("nbrecv")
}

func (c SSChan) Close() {
	close(c)
}

func (c SSChan) Impl() string {
	return "(select)"
}


func shouldPanic(f func()) {
	defer func() {
		if recover() == nil {
			panic("did not panic")
		}
	}()
	f()
}

func test1(c Chan) {
	for i := 0; i < 3; i++ {
		// recv a close signal (a zero value)
		if x := c.Recv(); x != 0 {
			println("test1: recv on closed:", x, c.Impl())
			failed = true
		}
		if x, ok := c.Recv2(); x != 0 || ok {
			println("test1: recv2 on closed:", x, ok, c.Impl())
			failed = true
		}

		// should work with select: received a value without blocking, so selected == true.
		x, selected := c.Nbrecv()
		if x != 0 || !selected {
			println("test1: recv on closed nb:", x, selected, c.Impl())
			failed = true
		}
		x, ok, selected := c.Nbrecv2()
		if x != 0 || ok || !selected {
			println("test1: recv2 on closed nb:", x, ok, selected, c.Impl())
			failed = true
		}
	}

	// send should work with ,ok too: sent a value without blocking, so ok == true.
	shouldPanic(func() { c.Nbsend(1) })

	// the value should have been discarded.
	if x := c.Recv(); x != 0 {
		println("test1: recv on closed got non-zero after send on closed:", x, c.Impl())
		failed = true
	}

	// similarly Send.
	shouldPanic(func() { c.Send(2) })
	if x := c.Recv(); x != 0 {
		println("test1: recv on closed got non-zero after send on closed:", x, c.Impl())
		failed = true
	}
}

func testasync1(c Chan) {
	// should be able to get the last value via Recv
	if x := c.Recv(); x != 1 {
		println("testasync1: Recv did not get 1:", x, c.Impl())
		failed = true
	}

	test1(c)
}

func testasync2(c Chan) {
	// should be able to get the last value via Recv2
	if x, ok := c.Recv2(); x != 1 || !ok {
		println("testasync1: Recv did not get 1, true:", x, ok, c.Impl())
		failed = true
	}

	test1(c)
}

func testasync3(c Chan) {
	// should be able to get the last value via Nbrecv
	if x, selected := c.Nbrecv(); x != 1 || !selected {
		println("testasync2: Nbrecv did not get 1, true:", x, selected, c.Impl())
		failed = true
	}

	test1(c)
}

func testasync4(c Chan) {
	// should be able to get the last value via Nbrecv2
	if x, ok, selected := c.Nbrecv2(); x != 1 || !ok || !selected {
		println("testasync2: Nbrecv did not get 1, true, true:", x, ok, selected, c.Impl())
		failed = true
	}
	test1(c)
}

func closedsync() chan int {
	c := make(chan int)
	close(c)
	return c
}

func closedasync() chan int {
	c := make(chan int, 2)
	c <- 1
	close(c)
	return c
}

var mks = []func(chan int) Chan {
	func(c chan int) Chan { return XChan(c) },
	func(c chan int) Chan { return SChan(c) },
	func(c chan int) Chan { return SSChan(c) },
}

var testcloseds = []func(Chan) {
	testasync1,
	testasync2,
	testasync3,
	testasync4,
}

func main() {
	for _, mk := range mks {
		test1(mk(closedsync()))
	}
	
	for _, testclosed := range testcloseds {
		for _, mk := range mks {
			testclosed(mk(closedasync()))
		}
	}
	
	var ch chan int	
	shouldPanic(func() {
		close(ch)
	})
	
	ch = make(chan int)
	close(ch)
	shouldPanic(func() {
		close(ch)
	})

	if failed {
		os.Exit(1)
	}
}
                                                                                                                                                                                                                   usr/local/go/test/closure.go                                                                        0100644 0000000 0000000 00000003300 13020111414 014516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test the behavior of closures.

package main

import "runtime"

var c = make(chan int)

func check(a []int) {
	for i := 0; i < len(a); i++ {
		n := <-c
		if n != a[i] {
			println("want", a[i], "got", n, "at", i)
			panic("fail")
		}
	}
}

func f() {
	var i, j int

	i = 1
	j = 2
	f := func() {
		c <- i
		i = 4
		g := func() {
			c <- i
			c <- j
		}
		g()
		c <- i
	}
	j = 5
	f()
}

// Accumulator generator
func accum(n int) func(int) int {
	return func(i int) int {
		n += i
		return n
	}
}

func g(a, b func(int) int) {
	c <- a(2)
	c <- b(3)
	c <- a(4)
	c <- b(5)
}

func h() {
	var x8 byte = 100
	var x64 int64 = 200

	c <- int(x8)
	c <- int(x64)
	f := func(z int) {
		g := func() {
			c <- int(x8)
			c <- int(x64)
			c <- z
		}
		g()
		c <- int(x8)
		c <- int(x64)
		c <- int(z)
	}
	x8 = 101
	x64 = 201
	f(500)
}

func newfunc() func(int) int { return func(x int) int { return x } }

func main() {
	runtime.GOMAXPROCS(1)
	var fail bool

	go f()
	check([]int{1, 4, 5, 4})

	a := accum(0)
	b := accum(1)
	go g(a, b)
	check([]int{2, 4, 6, 9})

	go h()
	check([]int{100, 200, 101, 201, 500, 101, 201, 500})

	memstats := new(runtime.MemStats)
	runtime.ReadMemStats(memstats)
	n0 := memstats.Mallocs

	x, y := newfunc(), newfunc()
	if x(1) != 1 || y(2) != 2 {
		println("newfunc returned broken funcs")
		fail = true
	}

	runtime.ReadMemStats(memstats)
	if n0 != memstats.Mallocs {
		println("newfunc allocated unexpectedly")
		fail = true
	}

	ff(1)

	if fail {
		panic("fail")
	}
}

func ff(x int) {
	call(func() {
		_ = x
	})
}

func call(func()) {
}
                                                                                                                                                                                                                                                                                                                                usr/local/go/test/closure1.go                                                                       0100644 0000000 0000000 00000000430 13020111414 014600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	x := 0
	func() {
		x = 1
	}()
	func() {
		if x != 1 {
			panic("x != 1")
		}
	}()
}                                                                                                                                                                                                                                        usr/local/go/test/closure2.go                                                                       0100644 0000000 0000000 00000003303 13020111414 014603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Check that these do not use "by value" capturing,
// because changes are made to the value during the closure.

package main

func main() {
	{
		type X struct {
			v int
		}
		var x X
		func() {
			x.v++
		}()
		if x.v != 1 {
			panic("x.v != 1")
		}

		type Y struct {
			X
		}
		var y Y
		func() {
			y.v = 1
		}()
		if y.v != 1 {
			panic("y.v != 1")
		}
	}

	{
		type Z struct {
			a [3]byte
		}
		var z Z
		func() {
			i := 0
			for z.a[1] = 1; i < 10; i++ {
			}
		}()
		if z.a[1] != 1 {
			panic("z.a[1] != 1")
		}
	}

	{
		w := 0
		tmp := 0
		f := func() {
			if w != 1 {
				panic("w != 1")
			}
		}
		func() {
			tmp = w // force capture of w, but do not write to it yet
			_ = tmp
			func() {
				func() {
					w++ // write in a nested closure
				}()
			}()
		}()
		f()
	}

	{
		var g func() int
		for i := range [2]int{} {
			if i == 0 {
				g = func() int {
					return i // test that we capture by ref here, i is mutated on every interation
				}
			}
		}
		if g() != 1 {
			panic("g() != 1")
		}
	}

	{
		var g func() int
		q := 0
		for range [2]int{} {
			q++
			g = func() int {
				return q // test that we capture by ref here
					 // q++ must on a different decldepth than q declaration
			}
		}
		if g() != 2 {
			panic("g() != 2")
		}
	}

	{
		var g func() int
		var a [2]int
		q := 0
		for a[func() int {
			q++
			return 0
		}()] = range [2]int{} {
			g = func() int {
				return q // test that we capture by ref here
					 // q++ must on a different decldepth than q declaration
			}
		}
		if g() != 2 {
			panic("g() != 2")
		}
	}
}
                                                                                                                                                                                                                                                                                                                             usr/local/go/test/cmp.go                                                                            0100644 0000000 0000000 00000017200 13020111414 013625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test equality and inequality operations.

package main

import (
	"os"
	"unsafe"
)

var global bool

func use(b bool) { global = b }

func stringptr(s string) uintptr { return *(*uintptr)(unsafe.Pointer(&s)) }

func isfalse(b bool) {
	if b {
		// stack will explain where
		panic("wanted false, got true")
	}
}

func istrue(b bool) {
	if !b {
		// stack will explain where
		panic("wanted true, got false")
	}
}

type T *int

type X int

func (X) x() {}

func main() {
	var a []int
	var b map[string]int

	var c string = "hello"
	var d string = "hel" // try to get different pointer
	d = d + "lo"

	// go.tools/ssa/interp can't handle unsafe.Pointer.
	if os.Getenv("GOSSAINTERP") == "" {
		if stringptr(c) == stringptr(d) {
			panic("compiler too smart -- got same string")
		}
	}

	var e = make(chan int)

	var ia interface{} = a
	var ib interface{} = b
	var ic interface{} = c
	var id interface{} = d
	var ie interface{} = e

	// these comparisons are okay because
	// string compare is okay and the others
	// are comparisons where the types differ.
	isfalse(ia == ib)
	isfalse(ia == ic)
	isfalse(ia == id)
	isfalse(ib == ic)
	isfalse(ib == id)
	istrue(ic == id)
	istrue(ie == ie)

	istrue(ia != ib)
	istrue(ia != ic)
	istrue(ia != id)
	istrue(ib != ic)
	istrue(ib != id)
	isfalse(ic != id)
	isfalse(ie != ie)

	// these are not okay, because there is no comparison on slices or maps.
	//isfalse(a == ib)
	//isfalse(a == ic)
	//isfalse(a == id)
	//isfalse(b == ic)
	//isfalse(b == id)

	istrue(c == id)
	istrue(e == ie)

	//isfalse(ia == b)
	isfalse(ia == c)
	isfalse(ia == d)
	isfalse(ib == c)
	isfalse(ib == d)
	istrue(ic == d)
	istrue(ie == e)

	//istrue(a != ib)
	//istrue(a != ic)
	//istrue(a != id)
	//istrue(b != ic)
	//istrue(b != id)
	isfalse(c != id)
	isfalse(e != ie)

	//istrue(ia != b)
	istrue(ia != c)
	istrue(ia != d)
	istrue(ib != c)
	istrue(ib != d)
	isfalse(ic != d)
	isfalse(ie != e)

	// gc used to let this go through as true.
	var g uint64 = 123
	var h int64 = 123
	var ig interface{} = g
	var ih interface{} = h
	isfalse(ig == ih)
	istrue(ig != ih)

	// map of interface should use == on interface values,
	// not memory.
	var m = make(map[interface{}]int)
	m[ic] = 1
	m[id] = 2
	if m[c] != 2 {
		println("m[c] = ", m[c])
		panic("bad m[c]")
	}

	// interface comparisons (issue 7207)
	{
		type I1 interface {
			x()
		}
		type I2 interface {
			x()
		}
		a1 := I1(X(0))
		b1 := I1(X(1))
		a2 := I2(X(0))
		b2 := I2(X(1))
		a3 := I1(a2)
		a4 := I2(a1)
		var e interface{} = X(0)
		a5 := e.(I1)
		a6 := e.(I2)
		isfalse(a1 == b1)
		isfalse(a1 == b2)
		isfalse(a2 == b1)
		isfalse(a2 == b2)
		istrue(a1 == a2)
		istrue(a1 == a3)
		istrue(a1 == a4)
		istrue(a1 == a5)
		istrue(a1 == a6)
		istrue(a2 == a3)
		istrue(a2 == a4)
		istrue(a2 == a5)
		istrue(a2 == a6)
		istrue(a3 == a4)
		istrue(a3 == a5)
		istrue(a3 == a6)
		istrue(a4 == a5)
		istrue(a4 == a6)
		istrue(a5 == a6)
	}

	// non-interface comparisons
	{
		c := make(chan int)
		c1 := (<-chan int)(c)
		c2 := (chan<- int)(c)
		istrue(c == c1)
		istrue(c == c2)
		istrue(c1 == c)
		istrue(c2 == c)

		isfalse(c != c1)
		isfalse(c != c2)
		isfalse(c1 != c)
		isfalse(c2 != c)

		d := make(chan int)
		isfalse(c == d)
		isfalse(d == c)
		isfalse(d == c1)
		isfalse(d == c2)
		isfalse(c1 == d)
		isfalse(c2 == d)

		istrue(c != d)
		istrue(d != c)
		istrue(d != c1)
		istrue(d != c2)
		istrue(c1 != d)
		istrue(c2 != d)
	}

	// named types vs not
	{
		var x = new(int)
		var y T
		var z T = x

		isfalse(x == y)
		istrue(x == z)
		isfalse(y == z)

		isfalse(y == x)
		istrue(z == x)
		isfalse(z == y)

		istrue(x != y)
		isfalse(x != z)
		istrue(y != z)

		istrue(y != x)
		isfalse(z != x)
		istrue(z != y)
	}

	// structs
	{
		var x = struct {
			x int
			y string
		}{1, "hi"}
		var y = struct {
			x int
			y string
		}{2, "bye"}
		var z = struct {
			x int
			y string
		}{1, "hi"}

		isfalse(x == y)
		isfalse(y == x)
		isfalse(y == z)
		isfalse(z == y)
		istrue(x == z)
		istrue(z == x)

		istrue(x != y)
		istrue(y != x)
		istrue(y != z)
		istrue(z != y)
		isfalse(x != z)
		isfalse(z != x)

		var m = make(map[struct {
			x int
			y string
		}]int)
		m[x] = 10
		m[y] = 20
		m[z] = 30
		istrue(m[x] == 30)
		istrue(m[y] == 20)
		istrue(m[z] == 30)
		istrue(m[x] != 10)
		isfalse(m[x] != 30)
		isfalse(m[y] != 20)
		isfalse(m[z] != 30)
		isfalse(m[x] == 10)

		var m1 = make(map[struct {
			x int
			y string
		}]struct {
			x int
			y string
		})
		m1[x] = x
		m1[y] = y
		m1[z] = z
		istrue(m1[x] == z)
		istrue(m1[y] == y)
		istrue(m1[z] == z)
		istrue(m1[x] == x)
		isfalse(m1[x] != z)
		isfalse(m1[y] != y)
		isfalse(m1[z] != z)
		isfalse(m1[x] != x)

		var ix, iy, iz interface{} = x, y, z

		isfalse(ix == iy)
		isfalse(iy == ix)
		isfalse(iy == iz)
		isfalse(iz == iy)
		istrue(ix == iz)
		istrue(iz == ix)

		isfalse(x == iy)
		isfalse(y == ix)
		isfalse(y == iz)
		isfalse(z == iy)
		istrue(x == iz)
		istrue(z == ix)

		isfalse(ix == y)
		isfalse(iy == x)
		isfalse(iy == z)
		isfalse(iz == y)
		istrue(ix == z)
		istrue(iz == x)

		istrue(ix != iy)
		istrue(iy != ix)
		istrue(iy != iz)
		istrue(iz != iy)
		isfalse(ix != iz)
		isfalse(iz != ix)

		istrue(x != iy)
		istrue(y != ix)
		istrue(y != iz)
		istrue(z != iy)
		isfalse(x != iz)
		isfalse(z != ix)

		istrue(ix != y)
		istrue(iy != x)
		istrue(iy != z)
		istrue(iz != y)
		isfalse(ix != z)
		isfalse(iz != x)
	}

	// structs with _ fields
	{
		var x = struct {
			x int
			_ string
			y float64
			_ float64
			z int
		}{
			x: 1, y: 2, z: 3,
		}
		var ix interface{} = x

		istrue(x == x)
		istrue(x == ix)
		istrue(ix == x)
		istrue(ix == ix)
	}

	// arrays
	{
		var x = [2]string{"1", "hi"}
		var y = [2]string{"2", "bye"}
		var z = [2]string{"1", "hi"}

		isfalse(x == y)
		isfalse(y == x)
		isfalse(y == z)
		isfalse(z == y)
		istrue(x == z)
		istrue(z == x)

		istrue(x != y)
		istrue(y != x)
		istrue(y != z)
		istrue(z != y)
		isfalse(x != z)
		isfalse(z != x)

		var m = make(map[[2]string]int)
		m[x] = 10
		m[y] = 20
		m[z] = 30
		istrue(m[x] == 30)
		istrue(m[y] == 20)
		istrue(m[z] == 30)
		isfalse(m[x] != 30)
		isfalse(m[y] != 20)
		isfalse(m[z] != 30)

		var ix, iy, iz interface{} = x, y, z

		isfalse(ix == iy)
		isfalse(iy == ix)
		isfalse(iy == iz)
		isfalse(iz == iy)
		istrue(ix == iz)
		istrue(iz == ix)

		isfalse(x == iy)
		isfalse(y == ix)
		isfalse(y == iz)
		isfalse(z == iy)
		istrue(x == iz)
		istrue(z == ix)

		isfalse(ix == y)
		isfalse(iy == x)
		isfalse(iy == z)
		isfalse(iz == y)
		istrue(ix == z)
		istrue(iz == x)

		istrue(ix != iy)
		istrue(iy != ix)
		istrue(iy != iz)
		istrue(iz != iy)
		isfalse(ix != iz)
		isfalse(iz != ix)

		istrue(x != iy)
		istrue(y != ix)
		istrue(y != iz)
		istrue(z != iy)
		isfalse(x != iz)
		isfalse(z != ix)

		istrue(ix != y)
		istrue(iy != x)
		istrue(iy != z)
		istrue(iz != y)
		isfalse(ix != z)
		isfalse(iz != x)
	}

	// named booleans
	{
		type mybool bool
		var b mybool

		type T struct{ data [20]byte }
		var x, y T
		b = x == y
		istrue(x == y)
		istrue(bool(b))

		m := make(map[string][10]interface{})
		b = m["x"] == m["y"]
		istrue(m["x"] == m["y"])
		istrue(bool(b))
	}

	shouldPanic(p1)
	shouldPanic(p2)
	shouldPanic(p3)
	shouldPanic(p4)
}

func p1() {
	var a []int
	var ia interface{} = a
	use(ia == ia)
}

func p2() {
	var b []int
	var ib interface{} = b
	use(ib == ib)
}

func p3() {
	var a []int
	var ia interface{} = a
	var m = make(map[interface{}]int)
	m[ia] = 1
}

func p4() {
	var b []int
	var ib interface{} = b
	var m = make(map[interface{}]int)
	m[ib] = 1
}

func shouldPanic(f func()) {
	defer func() {
		if recover() == nil {
			panic("function should panic")
		}
	}()
	f()
}
                                                                                                                                                                                                                                                                                                                                                                                                usr/local/go/test/cmp6.go                                                                           0100644 0000000 0000000 00000004132 13020111414 013713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that incorrect comparisons are detected.
// Does not compile.

package main

func use(bool) {}

type T1 *int
type T2 *int

type T3 struct{ z []int }

var t3 T3

type T4 struct {
	_ []int
	a float64
}

var t4 T4

func main() {
	// Arguments to comparison must be
	// assignable one to the other (or vice versa)
	// so chan int can be compared against
	// directional channels but channel of different
	// direction cannot be compared against each other.
	var c1 chan<- int
	var c2 <-chan int
	var c3 chan int

	use(c1 == c2) // ERROR "invalid operation|incompatible"
	use(c2 == c1) // ERROR "invalid operation|incompatible"
	use(c1 == c3)
	use(c2 == c2)
	use(c3 == c1)
	use(c3 == c2)

	// Same applies to named types.
	var p1 T1
	var p2 T2
	var p3 *int

	use(p1 == p2) // ERROR "invalid operation|incompatible"
	use(p2 == p1) // ERROR "invalid operation|incompatible"
	use(p1 == p3)
	use(p2 == p2)
	use(p3 == p1)
	use(p3 == p2)

	// Arrays are comparable if and only if their element type is comparable.
	var a1 [1]int
	var a2 [1]func()
	var a3 [0]func()
	use(a1 == a1)
	use(a2 == a2) // ERROR "invalid operation|invalid comparison"
	use(a3 == a3) // ERROR "invalid operation|invalid comparison"

	// Comparison of structs should have a good message
	use(t3 == t3) // ERROR "struct|expected"
	use(t4 == t4) // ERROR "cannot be compared|non-comparable"

	// Slices, functions, and maps too.
	var x []int
	var f func()
	var m map[int]int
	use(x == x) // ERROR "slice can only be compared to nil"
	use(f == f) // ERROR "func can only be compared to nil"
	use(m == m) // ERROR "map can only be compared to nil"

	// Comparison with interface that cannot return true
	// (would panic).
	var i interface{}
	use(i == x) // ERROR "invalid operation"
	use(x == i) // ERROR "invalid operation"
	use(i == f) // ERROR "invalid operation"
	use(f == i) // ERROR "invalid operation"
	use(i == m) // ERROR "invalid operation"
	use(m == i) // ERROR "invalid operation"
}
                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/cmplx.go                                                                          0100644 0000000 0000000 00000002261 13020111414 014172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that incorrect invocations of the complex predeclared function are detected.
// Does not compile.

package main

type (
	Float32    float32
	Float64    float64
	Complex64  complex64
	Complex128 complex128
)

var (
	f32 float32
	f64 float64
	F32 Float32
	F64 Float64

	c64  complex64
	c128 complex128
	C64  Complex64
	C128 Complex128
)

func main() {
	// ok
	c64 = complex(f32, f32)
	c128 = complex(f64, f64)

	_ = complex128(0)     // ok
	_ = complex(f32, f64) // ERROR "complex"
	_ = complex(f64, f32) // ERROR "complex"
	_ = complex(f32, F32) // ERROR "complex"
	_ = complex(F32, f32) // ERROR "complex"
	_ = complex(f64, F64) // ERROR "complex"
	_ = complex(F64, f64) // ERROR "complex"

	c128 = complex(f32, f32) // ERROR "cannot use"
	c64 = complex(f64, f64)  // ERROR "cannot use"

	c64 = complex(1.0, 2.0) // ok, constant is untyped
	c128 = complex(1.0, 2.0)
	C64 = complex(1.0, 2.0)
	C128 = complex(1.0, 2.0)

	C64 = complex(f32, f32)  // ERROR "cannot use"
	C128 = complex(f64, f64) // ERROR "cannot use"
}
                                                                                                                                                                                                                                                                                                                                               usr/local/go/test/cmplxdivide.c                                                                     0100644 0000000 0000000 00000004406 13020111414 015177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This C program generates the file cmplxdivide1.go. It uses the
// output of the operations by C99 as the reference to check
// the implementation of complex numbers in Go.
// The generated file, cmplxdivide1.go, is compiled along
// with the driver cmplxdivide.go (the names are confusing
// and unimaginative) to run the actual test. This is done by
// the usual test runner.
//
// The file cmplxdivide1.go is checked in to the repository, but
// if it needs to be regenerated, compile and run this C program
// like this:
//	gcc '-std=c99' cmplxdivide.c && a.out >cmplxdivide1.go

#include <complex.h>
#include <math.h>
#include <stdio.h>
#include <string.h>

#define nelem(x) (sizeof(x)/sizeof((x)[0]))

double f[] = {
	0,
	1,
	-1,
	2,
	NAN,
	INFINITY,
	-INFINITY,
};

char*
fmt(double g)
{
	static char buf[10][30];
	static int n;
	char *p;
	
	p = buf[n++];
	if(n == 10)
		n = 0;
	sprintf(p, "%g", g);
	if(strcmp(p, "-0") == 0)
		strcpy(p, "negzero");
	return p;
}

int
iscnan(double complex d)
{
	return !isinf(creal(d)) && !isinf(cimag(d)) && (isnan(creal(d)) || isnan(cimag(d)));
}

double complex zero;	// attempt to hide zero division from gcc

int
main(void)
{
	int i, j, k, l;
	double complex n, d, q;
	
	printf("// skip\n");
	printf("// # generated by cmplxdivide.c\n");
	printf("\n");
	printf("package main\n");
	printf("var tests = []Test{\n");
	for(i=0; i<nelem(f); i++)
	for(j=0; j<nelem(f); j++)
	for(k=0; k<nelem(f); k++)
	for(l=0; l<nelem(f); l++) {
		n = f[i] + f[j]*I;
		d = f[k] + f[l]*I;
		q = n/d;
		
		// BUG FIX.
		// Gcc gets the wrong answer for NaN/0 unless both sides are NaN.
		// That is, it treats (NaN+NaN*I)/0 = NaN+NaN*I (a complex NaN)
		// but it then computes (1+NaN*I)/0 = Inf+NaN*I (a complex infinity).
		// Since both numerators are complex NaNs, it seems that the
		// results should agree in kind.  Override the gcc computation in this case.
		if(iscnan(n) && d == 0)
			q = (NAN+NAN*I) / zero;

		printf("\tTest{complex(%s, %s), complex(%s, %s), complex(%s, %s)},\n",
			fmt(creal(n)), fmt(cimag(n)),
			fmt(creal(d)), fmt(cimag(d)),
			fmt(creal(q)), fmt(cimag(q)));
	}
	printf("}\n");
	return 0;
}
                                                                                                                                                                                                                                                          usr/local/go/test/cmplxdivide.go                                                                    0100644 0000000 0000000 00000001676 13020111414 015370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run cmplxdivide1.go

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Driver for complex division table defined in cmplxdivide1.go
// For details, see the comment at the top of in cmplxdivide.c.

package main

import (
	"fmt"
	"math"
	"math/cmplx"
)

type Test struct {
	f, g complex128
	out  complex128
}

var nan = math.NaN()
var inf = math.Inf(1)
var negzero = math.Copysign(0, -1)

func calike(a, b complex128) bool {
	switch {
	case cmplx.IsInf(a) && cmplx.IsInf(b):
		return true
	case cmplx.IsNaN(a) && cmplx.IsNaN(b):
		return true
	}
	return a == b
}

func main() {
	bad := false
	for _, t := range tests {
		x := t.f / t.g
		if !calike(x, t.out) {
			if !bad {
				fmt.Printf("BUG\n")
				bad = true
			}
			fmt.Printf("%v/%v: expected %v error; got %v\n", t.f, t.g, t.out, x)
		}
	}
	if bad {
		panic("cmplxdivide failed.")
	}
}
                                                                  usr/local/go/test/cmplxdivide1.go                                                                   0100644 0000000 0000000 00000446164 13020111414 015456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // skip
// # generated by cmplxdivide.c

package main
var tests = []Test{
	Test{complex(0, 0), complex(0, 0), complex(-nan, -nan)},
	Test{complex(0, 0), complex(0, 1), complex(0, 0)},
	Test{complex(0, 0), complex(0, -1), complex(negzero, 0)},
	Test{complex(0, 0), complex(0, 2), complex(0, 0)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 0), complex(1, 0), complex(0, 0)},
	Test{complex(0, 0), complex(1, 1), complex(0, 0)},
	Test{complex(0, 0), complex(1, -1), complex(0, 0)},
	Test{complex(0, 0), complex(1, 2), complex(0, 0)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 0), complex(-1, 0), complex(negzero, negzero)},
	Test{complex(0, 0), complex(-1, 1), complex(negzero, negzero)},
	Test{complex(0, 0), complex(-1, -1), complex(negzero, negzero)},
	Test{complex(0, 0), complex(-1, 2), complex(0, negzero)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 0), complex(2, 0), complex(0, 0)},
	Test{complex(0, 0), complex(2, 1), complex(0, 0)},
	Test{complex(0, 0), complex(2, -1), complex(0, 0)},
	Test{complex(0, 0), complex(2, 2), complex(0, 0)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(0, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(0, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(0, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 0), complex(inf, 0), complex(0, 0)},
	Test{complex(0, 0), complex(inf, 1), complex(0, 0)},
	Test{complex(0, 0), complex(inf, -1), complex(0, 0)},
	Test{complex(0, 0), complex(inf, 2), complex(0, 0)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 0), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(0, 0), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(0, 0), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(0, 0), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(0, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(0, 0), complex(-nan, inf)},
	Test{complex(0, 1), complex(0, 1), complex(1, 0)},
	Test{complex(0, 1), complex(0, -1), complex(-1, 0)},
	Test{complex(0, 1), complex(0, 2), complex(0.5, 0)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(1, 0), complex(0, 1)},
	Test{complex(0, 1), complex(1, 1), complex(0.5, 0.5)},
	Test{complex(0, 1), complex(1, -1), complex(-0.5, 0.5)},
	Test{complex(0, 1), complex(1, 2), complex(0.4, 0.2)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(-1, 0), complex(negzero, -1)},
	Test{complex(0, 1), complex(-1, 1), complex(0.5, -0.5)},
	Test{complex(0, 1), complex(-1, -1), complex(-0.5, -0.5)},
	Test{complex(0, 1), complex(-1, 2), complex(0.4, -0.2)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(2, 0), complex(0, 0.5)},
	Test{complex(0, 1), complex(2, 1), complex(0.2, 0.4)},
	Test{complex(0, 1), complex(2, -1), complex(-0.2, 0.4)},
	Test{complex(0, 1), complex(2, 2), complex(0.25, 0.25)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(0, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(0, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(0, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(inf, 0), complex(0, 0)},
	Test{complex(0, 1), complex(inf, 1), complex(0, 0)},
	Test{complex(0, 1), complex(inf, -1), complex(0, 0)},
	Test{complex(0, 1), complex(inf, 2), complex(0, 0)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 1), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(0, 1), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(0, 1), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(0, 1), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(0, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(0, 0), complex(-nan, -inf)},
	Test{complex(0, -1), complex(0, 1), complex(-1, negzero)},
	Test{complex(0, -1), complex(0, -1), complex(1, negzero)},
	Test{complex(0, -1), complex(0, 2), complex(-0.5, negzero)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, -1), complex(1, 0), complex(0, -1)},
	Test{complex(0, -1), complex(1, 1), complex(-0.5, -0.5)},
	Test{complex(0, -1), complex(1, -1), complex(0.5, -0.5)},
	Test{complex(0, -1), complex(1, 2), complex(-0.4, -0.2)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, -1), complex(-1, 0), complex(negzero, 1)},
	Test{complex(0, -1), complex(-1, 1), complex(-0.5, 0.5)},
	Test{complex(0, -1), complex(-1, -1), complex(0.5, 0.5)},
	Test{complex(0, -1), complex(-1, 2), complex(-0.4, 0.2)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, -1), complex(2, 0), complex(0, -0.5)},
	Test{complex(0, -1), complex(2, 1), complex(-0.2, -0.4)},
	Test{complex(0, -1), complex(2, -1), complex(0.2, -0.4)},
	Test{complex(0, -1), complex(2, 2), complex(-0.25, -0.25)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(0, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(0, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(0, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, -1), complex(inf, 0), complex(0, negzero)},
	Test{complex(0, -1), complex(inf, 1), complex(0, negzero)},
	Test{complex(0, -1), complex(inf, -1), complex(0, negzero)},
	Test{complex(0, -1), complex(inf, 2), complex(0, negzero)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, -1), complex(-inf, 0), complex(negzero, 0)},
	Test{complex(0, -1), complex(-inf, 1), complex(negzero, 0)},
	Test{complex(0, -1), complex(-inf, -1), complex(negzero, 0)},
	Test{complex(0, -1), complex(-inf, 2), complex(negzero, 0)},
	Test{complex(0, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(0, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(0, 2), complex(0, 0), complex(-nan, inf)},
	Test{complex(0, 2), complex(0, 1), complex(2, 0)},
	Test{complex(0, 2), complex(0, -1), complex(-2, 0)},
	Test{complex(0, 2), complex(0, 2), complex(1, 0)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 2), complex(1, 0), complex(0, 2)},
	Test{complex(0, 2), complex(1, 1), complex(1, 1)},
	Test{complex(0, 2), complex(1, -1), complex(-1, 1)},
	Test{complex(0, 2), complex(1, 2), complex(0.8, 0.4)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 2), complex(-1, 0), complex(negzero, -2)},
	Test{complex(0, 2), complex(-1, 1), complex(1, -1)},
	Test{complex(0, 2), complex(-1, -1), complex(-1, -1)},
	Test{complex(0, 2), complex(-1, 2), complex(0.8, -0.4)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 2), complex(2, 0), complex(0, 1)},
	Test{complex(0, 2), complex(2, 1), complex(0.4, 0.8)},
	Test{complex(0, 2), complex(2, -1), complex(-0.4, 0.8)},
	Test{complex(0, 2), complex(2, 2), complex(0.5, 0.5)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(0, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(0, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(0, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 2), complex(inf, 0), complex(0, 0)},
	Test{complex(0, 2), complex(inf, 1), complex(0, 0)},
	Test{complex(0, 2), complex(inf, -1), complex(0, 0)},
	Test{complex(0, 2), complex(inf, 2), complex(0, 0)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(0, 2), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(0, 2), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(0, 2), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(0, 2), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(0, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(0, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(0, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(1, 0), complex(0, 0), complex(inf, -nan)},
	Test{complex(1, 0), complex(0, 1), complex(0, -1)},
	Test{complex(1, 0), complex(0, -1), complex(negzero, 1)},
	Test{complex(1, 0), complex(0, 2), complex(0, -0.5)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 0), complex(1, 0), complex(1, 0)},
	Test{complex(1, 0), complex(1, 1), complex(0.5, -0.5)},
	Test{complex(1, 0), complex(1, -1), complex(0.5, 0.5)},
	Test{complex(1, 0), complex(1, 2), complex(0.2, -0.4)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 0), complex(-1, 0), complex(-1, negzero)},
	Test{complex(1, 0), complex(-1, 1), complex(-0.5, -0.5)},
	Test{complex(1, 0), complex(-1, -1), complex(-0.5, 0.5)},
	Test{complex(1, 0), complex(-1, 2), complex(-0.2, -0.4)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 0), complex(2, 0), complex(0.5, 0)},
	Test{complex(1, 0), complex(2, 1), complex(0.4, -0.2)},
	Test{complex(1, 0), complex(2, -1), complex(0.4, 0.2)},
	Test{complex(1, 0), complex(2, 2), complex(0.25, -0.25)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(1, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(1, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(1, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 0), complex(inf, 0), complex(0, 0)},
	Test{complex(1, 0), complex(inf, 1), complex(0, 0)},
	Test{complex(1, 0), complex(inf, -1), complex(0, 0)},
	Test{complex(1, 0), complex(inf, 2), complex(0, 0)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 0), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(1, 0), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(1, 0), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(1, 0), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(0, 0), complex(inf, inf)},
	Test{complex(1, 1), complex(0, 1), complex(1, -1)},
	Test{complex(1, 1), complex(0, -1), complex(-1, 1)},
	Test{complex(1, 1), complex(0, 2), complex(0.5, -0.5)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(1, 0), complex(1, 1)},
	Test{complex(1, 1), complex(1, 1), complex(1, 0)},
	Test{complex(1, 1), complex(1, -1), complex(0, 1)},
	Test{complex(1, 1), complex(1, 2), complex(0.6, -0.2)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(-1, 0), complex(-1, -1)},
	Test{complex(1, 1), complex(-1, 1), complex(negzero, -1)},
	Test{complex(1, 1), complex(-1, -1), complex(-1, negzero)},
	Test{complex(1, 1), complex(-1, 2), complex(0.2, -0.6)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(2, 0), complex(0.5, 0.5)},
	Test{complex(1, 1), complex(2, 1), complex(0.6, 0.2)},
	Test{complex(1, 1), complex(2, -1), complex(0.2, 0.6)},
	Test{complex(1, 1), complex(2, 2), complex(0.5, 0)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(1, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(1, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(1, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(inf, 0), complex(0, 0)},
	Test{complex(1, 1), complex(inf, 1), complex(0, 0)},
	Test{complex(1, 1), complex(inf, -1), complex(0, 0)},
	Test{complex(1, 1), complex(inf, 2), complex(0, 0)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 1), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(1, 1), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(1, 1), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(1, 1), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, -1), complex(0, 0), complex(inf, -inf)},
	Test{complex(1, -1), complex(0, 1), complex(-1, -1)},
	Test{complex(1, -1), complex(0, -1), complex(1, 1)},
	Test{complex(1, -1), complex(0, 2), complex(-0.5, -0.5)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, -1), complex(1, 0), complex(1, -1)},
	Test{complex(1, -1), complex(1, 1), complex(0, -1)},
	Test{complex(1, -1), complex(1, -1), complex(1, 0)},
	Test{complex(1, -1), complex(1, 2), complex(-0.2, -0.6)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, -1), complex(-1, 0), complex(-1, 1)},
	Test{complex(1, -1), complex(-1, 1), complex(-1, negzero)},
	Test{complex(1, -1), complex(-1, -1), complex(negzero, 1)},
	Test{complex(1, -1), complex(-1, 2), complex(-0.6, -0.2)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, -1), complex(2, 0), complex(0.5, -0.5)},
	Test{complex(1, -1), complex(2, 1), complex(0.2, -0.6)},
	Test{complex(1, -1), complex(2, -1), complex(0.6, -0.2)},
	Test{complex(1, -1), complex(2, 2), complex(0, -0.5)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(1, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(1, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(1, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, -1), complex(inf, 0), complex(0, negzero)},
	Test{complex(1, -1), complex(inf, 1), complex(0, negzero)},
	Test{complex(1, -1), complex(inf, -1), complex(0, negzero)},
	Test{complex(1, -1), complex(inf, 2), complex(0, negzero)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, -1), complex(-inf, 0), complex(negzero, 0)},
	Test{complex(1, -1), complex(-inf, 1), complex(negzero, 0)},
	Test{complex(1, -1), complex(-inf, -1), complex(negzero, 0)},
	Test{complex(1, -1), complex(-inf, 2), complex(negzero, 0)},
	Test{complex(1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(1, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(1, 2), complex(0, 0), complex(inf, inf)},
	Test{complex(1, 2), complex(0, 1), complex(2, -1)},
	Test{complex(1, 2), complex(0, -1), complex(-2, 1)},
	Test{complex(1, 2), complex(0, 2), complex(1, -0.5)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 2), complex(1, 0), complex(1, 2)},
	Test{complex(1, 2), complex(1, 1), complex(1.5, 0.5)},
	Test{complex(1, 2), complex(1, -1), complex(-0.5, 1.5)},
	Test{complex(1, 2), complex(1, 2), complex(1, 0)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 2), complex(-1, 0), complex(-1, -2)},
	Test{complex(1, 2), complex(-1, 1), complex(0.5, -1.5)},
	Test{complex(1, 2), complex(-1, -1), complex(-1.5, -0.5)},
	Test{complex(1, 2), complex(-1, 2), complex(0.6, -0.8)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 2), complex(2, 0), complex(0.5, 1)},
	Test{complex(1, 2), complex(2, 1), complex(0.8, 0.6)},
	Test{complex(1, 2), complex(2, -1), complex(0, 1)},
	Test{complex(1, 2), complex(2, 2), complex(0.75, 0.25)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(1, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(1, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(1, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 2), complex(inf, 0), complex(0, 0)},
	Test{complex(1, 2), complex(inf, 1), complex(0, 0)},
	Test{complex(1, 2), complex(inf, -1), complex(0, 0)},
	Test{complex(1, 2), complex(inf, 2), complex(0, 0)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(1, 2), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(1, 2), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(1, 2), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(1, 2), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(1, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(1, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-1, 0), complex(0, 0), complex(-inf, -nan)},
	Test{complex(-1, 0), complex(0, 1), complex(0, 1)},
	Test{complex(-1, 0), complex(0, -1), complex(negzero, -1)},
	Test{complex(-1, 0), complex(0, 2), complex(0, 0.5)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 0), complex(1, 0), complex(-1, 0)},
	Test{complex(-1, 0), complex(1, 1), complex(-0.5, 0.5)},
	Test{complex(-1, 0), complex(1, -1), complex(-0.5, -0.5)},
	Test{complex(-1, 0), complex(1, 2), complex(-0.2, 0.4)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 0), complex(-1, 0), complex(1, negzero)},
	Test{complex(-1, 0), complex(-1, 1), complex(0.5, 0.5)},
	Test{complex(-1, 0), complex(-1, -1), complex(0.5, -0.5)},
	Test{complex(-1, 0), complex(-1, 2), complex(0.2, 0.4)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 0), complex(2, 0), complex(-0.5, 0)},
	Test{complex(-1, 0), complex(2, 1), complex(-0.4, 0.2)},
	Test{complex(-1, 0), complex(2, -1), complex(-0.4, -0.2)},
	Test{complex(-1, 0), complex(2, 2), complex(-0.25, 0.25)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(-1, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(-1, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(-1, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 0), complex(inf, 0), complex(negzero, 0)},
	Test{complex(-1, 0), complex(inf, 1), complex(negzero, 0)},
	Test{complex(-1, 0), complex(inf, -1), complex(negzero, 0)},
	Test{complex(-1, 0), complex(inf, 2), complex(negzero, 0)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 0), complex(-inf, 0), complex(0, negzero)},
	Test{complex(-1, 0), complex(-inf, 1), complex(0, negzero)},
	Test{complex(-1, 0), complex(-inf, -1), complex(0, negzero)},
	Test{complex(-1, 0), complex(-inf, 2), complex(0, negzero)},
	Test{complex(-1, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 0), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 0), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 1), complex(0, 0), complex(-inf, inf)},
	Test{complex(-1, 1), complex(0, 1), complex(1, 1)},
	Test{complex(-1, 1), complex(0, -1), complex(-1, -1)},
	Test{complex(-1, 1), complex(0, 2), complex(0.5, 0.5)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 1), complex(1, 0), complex(-1, 1)},
	Test{complex(-1, 1), complex(1, 1), complex(0, 1)},
	Test{complex(-1, 1), complex(1, -1), complex(-1, 0)},
	Test{complex(-1, 1), complex(1, 2), complex(0.2, 0.6)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 1), complex(-1, 0), complex(1, -1)},
	Test{complex(-1, 1), complex(-1, 1), complex(1, negzero)},
	Test{complex(-1, 1), complex(-1, -1), complex(negzero, -1)},
	Test{complex(-1, 1), complex(-1, 2), complex(0.6, 0.2)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 1), complex(2, 0), complex(-0.5, 0.5)},
	Test{complex(-1, 1), complex(2, 1), complex(-0.2, 0.6)},
	Test{complex(-1, 1), complex(2, -1), complex(-0.6, 0.2)},
	Test{complex(-1, 1), complex(2, 2), complex(0, 0.5)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(-1, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(-1, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(-1, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 1), complex(inf, 0), complex(negzero, 0)},
	Test{complex(-1, 1), complex(inf, 1), complex(negzero, 0)},
	Test{complex(-1, 1), complex(inf, -1), complex(negzero, 0)},
	Test{complex(-1, 1), complex(inf, 2), complex(negzero, 0)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 1), complex(-inf, 0), complex(0, negzero)},
	Test{complex(-1, 1), complex(-inf, 1), complex(0, negzero)},
	Test{complex(-1, 1), complex(-inf, -1), complex(0, negzero)},
	Test{complex(-1, 1), complex(-inf, 2), complex(0, negzero)},
	Test{complex(-1, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 1), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 1), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, -1), complex(0, 0), complex(-inf, -inf)},
	Test{complex(-1, -1), complex(0, 1), complex(-1, 1)},
	Test{complex(-1, -1), complex(0, -1), complex(1, -1)},
	Test{complex(-1, -1), complex(0, 2), complex(-0.5, 0.5)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, -1), complex(1, 0), complex(-1, -1)},
	Test{complex(-1, -1), complex(1, 1), complex(-1, 0)},
	Test{complex(-1, -1), complex(1, -1), complex(0, -1)},
	Test{complex(-1, -1), complex(1, 2), complex(-0.6, 0.2)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, -1), complex(-1, 0), complex(1, 1)},
	Test{complex(-1, -1), complex(-1, 1), complex(negzero, 1)},
	Test{complex(-1, -1), complex(-1, -1), complex(1, negzero)},
	Test{complex(-1, -1), complex(-1, 2), complex(-0.2, 0.6)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, -1), complex(2, 0), complex(-0.5, -0.5)},
	Test{complex(-1, -1), complex(2, 1), complex(-0.6, -0.2)},
	Test{complex(-1, -1), complex(2, -1), complex(-0.2, -0.6)},
	Test{complex(-1, -1), complex(2, 2), complex(-0.5, 0)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(-1, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(-1, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(-1, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, -1), complex(inf, 0), complex(negzero, negzero)},
	Test{complex(-1, -1), complex(inf, 1), complex(negzero, negzero)},
	Test{complex(-1, -1), complex(inf, -1), complex(negzero, negzero)},
	Test{complex(-1, -1), complex(inf, 2), complex(negzero, negzero)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, -1), complex(-inf, 0), complex(0, 0)},
	Test{complex(-1, -1), complex(-inf, 1), complex(0, 0)},
	Test{complex(-1, -1), complex(-inf, -1), complex(0, 0)},
	Test{complex(-1, -1), complex(-inf, 2), complex(0, 0)},
	Test{complex(-1, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, -1), complex(-nan, inf), complex(negzero, 0)},
	Test{complex(-1, -1), complex(-nan, -inf), complex(0, negzero)},
	Test{complex(-1, 2), complex(0, 0), complex(-inf, inf)},
	Test{complex(-1, 2), complex(0, 1), complex(2, 1)},
	Test{complex(-1, 2), complex(0, -1), complex(-2, -1)},
	Test{complex(-1, 2), complex(0, 2), complex(1, 0.5)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 2), complex(1, 0), complex(-1, 2)},
	Test{complex(-1, 2), complex(1, 1), complex(0.5, 1.5)},
	Test{complex(-1, 2), complex(1, -1), complex(-1.5, 0.5)},
	Test{complex(-1, 2), complex(1, 2), complex(0.6, 0.8)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 2), complex(-1, 0), complex(1, -2)},
	Test{complex(-1, 2), complex(-1, 1), complex(1.5, -0.5)},
	Test{complex(-1, 2), complex(-1, -1), complex(-0.5, -1.5)},
	Test{complex(-1, 2), complex(-1, 2), complex(1, 0)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 2), complex(2, 0), complex(-0.5, 1)},
	Test{complex(-1, 2), complex(2, 1), complex(0, 1)},
	Test{complex(-1, 2), complex(2, -1), complex(-0.8, 0.6)},
	Test{complex(-1, 2), complex(2, 2), complex(0.25, 0.75)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(-1, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(-1, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(-1, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 2), complex(inf, 0), complex(negzero, 0)},
	Test{complex(-1, 2), complex(inf, 1), complex(negzero, 0)},
	Test{complex(-1, 2), complex(inf, -1), complex(negzero, 0)},
	Test{complex(-1, 2), complex(inf, 2), complex(negzero, 0)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(-1, 2), complex(-inf, 0), complex(0, negzero)},
	Test{complex(-1, 2), complex(-inf, 1), complex(0, negzero)},
	Test{complex(-1, 2), complex(-inf, -1), complex(0, negzero)},
	Test{complex(-1, 2), complex(-inf, 2), complex(0, negzero)},
	Test{complex(-1, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-1, 2), complex(-nan, inf), complex(0, 0)},
	Test{complex(-1, 2), complex(-nan, -inf), complex(negzero, negzero)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(2, 0), complex(0, 0), complex(inf, -nan)},
	Test{complex(2, 0), complex(0, 1), complex(0, -2)},
	Test{complex(2, 0), complex(0, -1), complex(negzero, 2)},
	Test{complex(2, 0), complex(0, 2), complex(0, -1)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 0), complex(1, 0), complex(2, 0)},
	Test{complex(2, 0), complex(1, 1), complex(1, -1)},
	Test{complex(2, 0), complex(1, -1), complex(1, 1)},
	Test{complex(2, 0), complex(1, 2), complex(0.4, -0.8)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 0), complex(-1, 0), complex(-2, negzero)},
	Test{complex(2, 0), complex(-1, 1), complex(-1, -1)},
	Test{complex(2, 0), complex(-1, -1), complex(-1, 1)},
	Test{complex(2, 0), complex(-1, 2), complex(-0.4, -0.8)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 0), complex(2, 0), complex(1, 0)},
	Test{complex(2, 0), complex(2, 1), complex(0.8, -0.4)},
	Test{complex(2, 0), complex(2, -1), complex(0.8, 0.4)},
	Test{complex(2, 0), complex(2, 2), complex(0.5, -0.5)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(2, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(2, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(2, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 0), complex(inf, 0), complex(0, 0)},
	Test{complex(2, 0), complex(inf, 1), complex(0, 0)},
	Test{complex(2, 0), complex(inf, -1), complex(0, 0)},
	Test{complex(2, 0), complex(inf, 2), complex(0, 0)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 0), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(2, 0), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(2, 0), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(2, 0), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(2, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 0), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 0), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(0, 0), complex(inf, inf)},
	Test{complex(2, 1), complex(0, 1), complex(1, -2)},
	Test{complex(2, 1), complex(0, -1), complex(-1, 2)},
	Test{complex(2, 1), complex(0, 2), complex(0.5, -1)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(1, 0), complex(2, 1)},
	Test{complex(2, 1), complex(1, 1), complex(1.5, -0.5)},
	Test{complex(2, 1), complex(1, -1), complex(0.5, 1.5)},
	Test{complex(2, 1), complex(1, 2), complex(0.8, -0.6)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(-1, 0), complex(-2, -1)},
	Test{complex(2, 1), complex(-1, 1), complex(-0.5, -1.5)},
	Test{complex(2, 1), complex(-1, -1), complex(-1.5, 0.5)},
	Test{complex(2, 1), complex(-1, 2), complex(0, -1)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(2, 0), complex(1, 0.5)},
	Test{complex(2, 1), complex(2, 1), complex(1, 0)},
	Test{complex(2, 1), complex(2, -1), complex(0.6, 0.8)},
	Test{complex(2, 1), complex(2, 2), complex(0.75, -0.25)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(2, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(2, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(2, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(inf, 0), complex(0, 0)},
	Test{complex(2, 1), complex(inf, 1), complex(0, 0)},
	Test{complex(2, 1), complex(inf, -1), complex(0, 0)},
	Test{complex(2, 1), complex(inf, 2), complex(0, 0)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 1), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(2, 1), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(2, 1), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(2, 1), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(2, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 1), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 1), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, -1), complex(0, 0), complex(inf, -inf)},
	Test{complex(2, -1), complex(0, 1), complex(-1, -2)},
	Test{complex(2, -1), complex(0, -1), complex(1, 2)},
	Test{complex(2, -1), complex(0, 2), complex(-0.5, -1)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, -1), complex(1, 0), complex(2, -1)},
	Test{complex(2, -1), complex(1, 1), complex(0.5, -1.5)},
	Test{complex(2, -1), complex(1, -1), complex(1.5, 0.5)},
	Test{complex(2, -1), complex(1, 2), complex(0, -1)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, -1), complex(-1, 0), complex(-2, 1)},
	Test{complex(2, -1), complex(-1, 1), complex(-1.5, -0.5)},
	Test{complex(2, -1), complex(-1, -1), complex(-0.5, 1.5)},
	Test{complex(2, -1), complex(-1, 2), complex(-0.8, -0.6)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, -1), complex(2, 0), complex(1, -0.5)},
	Test{complex(2, -1), complex(2, 1), complex(0.6, -0.8)},
	Test{complex(2, -1), complex(2, -1), complex(1, 0)},
	Test{complex(2, -1), complex(2, 2), complex(0.25, -0.75)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(2, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(2, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(2, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, -1), complex(inf, 0), complex(0, negzero)},
	Test{complex(2, -1), complex(inf, 1), complex(0, negzero)},
	Test{complex(2, -1), complex(inf, -1), complex(0, negzero)},
	Test{complex(2, -1), complex(inf, 2), complex(0, negzero)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, -1), complex(-inf, 0), complex(negzero, 0)},
	Test{complex(2, -1), complex(-inf, 1), complex(negzero, 0)},
	Test{complex(2, -1), complex(-inf, -1), complex(negzero, 0)},
	Test{complex(2, -1), complex(-inf, 2), complex(negzero, 0)},
	Test{complex(2, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, -1), complex(-nan, inf), complex(negzero, negzero)},
	Test{complex(2, -1), complex(-nan, -inf), complex(0, 0)},
	Test{complex(2, 2), complex(0, 0), complex(inf, inf)},
	Test{complex(2, 2), complex(0, 1), complex(2, -2)},
	Test{complex(2, 2), complex(0, -1), complex(-2, 2)},
	Test{complex(2, 2), complex(0, 2), complex(1, -1)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 2), complex(1, 0), complex(2, 2)},
	Test{complex(2, 2), complex(1, 1), complex(2, 0)},
	Test{complex(2, 2), complex(1, -1), complex(0, 2)},
	Test{complex(2, 2), complex(1, 2), complex(1.2, -0.4)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 2), complex(-1, 0), complex(-2, -2)},
	Test{complex(2, 2), complex(-1, 1), complex(negzero, -2)},
	Test{complex(2, 2), complex(-1, -1), complex(-2, negzero)},
	Test{complex(2, 2), complex(-1, 2), complex(0.4, -1.2)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 2), complex(2, 0), complex(1, 1)},
	Test{complex(2, 2), complex(2, 1), complex(1.2, 0.4)},
	Test{complex(2, 2), complex(2, -1), complex(0.4, 1.2)},
	Test{complex(2, 2), complex(2, 2), complex(1, 0)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(2, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(2, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(2, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 2), complex(inf, 0), complex(0, 0)},
	Test{complex(2, 2), complex(inf, 1), complex(0, 0)},
	Test{complex(2, 2), complex(inf, -1), complex(0, 0)},
	Test{complex(2, 2), complex(inf, 2), complex(0, 0)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(2, 2), complex(-inf, 0), complex(negzero, negzero)},
	Test{complex(2, 2), complex(-inf, 1), complex(negzero, negzero)},
	Test{complex(2, 2), complex(-inf, -1), complex(negzero, negzero)},
	Test{complex(2, 2), complex(-inf, 2), complex(negzero, negzero)},
	Test{complex(2, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(2, 2), complex(-nan, inf), complex(0, negzero)},
	Test{complex(2, 2), complex(-nan, -inf), complex(negzero, 0)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, 0), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, 0), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, 0), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, 1), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, 1), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, 1), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, -1), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, -1), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, -1), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, 2), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, 2), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, 2), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(nan, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(0, 0), complex(inf, -nan)},
	Test{complex(inf, 0), complex(0, 1), complex(-nan, -inf)},
	Test{complex(inf, 0), complex(0, -1), complex(-nan, inf)},
	Test{complex(inf, 0), complex(0, 2), complex(-nan, -inf)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(1, 0), complex(inf, -nan)},
	Test{complex(inf, 0), complex(1, 1), complex(inf, -inf)},
	Test{complex(inf, 0), complex(1, -1), complex(inf, inf)},
	Test{complex(inf, 0), complex(1, 2), complex(inf, -inf)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-1, 0), complex(-inf, -nan)},
	Test{complex(inf, 0), complex(-1, 1), complex(-inf, -inf)},
	Test{complex(inf, 0), complex(-1, -1), complex(-inf, inf)},
	Test{complex(inf, 0), complex(-1, 2), complex(-inf, -inf)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(2, 0), complex(inf, -nan)},
	Test{complex(inf, 0), complex(2, 1), complex(inf, -inf)},
	Test{complex(inf, 0), complex(2, -1), complex(inf, inf)},
	Test{complex(inf, 0), complex(2, 2), complex(inf, -inf)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(inf, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(inf, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(inf, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(0, 0), complex(inf, inf)},
	Test{complex(inf, 1), complex(0, 1), complex(-nan, -inf)},
	Test{complex(inf, 1), complex(0, -1), complex(-nan, inf)},
	Test{complex(inf, 1), complex(0, 2), complex(-nan, -inf)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(1, 0), complex(inf, -nan)},
	Test{complex(inf, 1), complex(1, 1), complex(inf, -inf)},
	Test{complex(inf, 1), complex(1, -1), complex(inf, inf)},
	Test{complex(inf, 1), complex(1, 2), complex(inf, -inf)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-1, 0), complex(-inf, -nan)},
	Test{complex(inf, 1), complex(-1, 1), complex(-inf, -inf)},
	Test{complex(inf, 1), complex(-1, -1), complex(-inf, inf)},
	Test{complex(inf, 1), complex(-1, 2), complex(-inf, -inf)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(2, 0), complex(inf, -nan)},
	Test{complex(inf, 1), complex(2, 1), complex(inf, -inf)},
	Test{complex(inf, 1), complex(2, -1), complex(inf, inf)},
	Test{complex(inf, 1), complex(2, 2), complex(inf, -inf)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(inf, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(inf, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(inf, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(0, 0), complex(inf, -inf)},
	Test{complex(inf, -1), complex(0, 1), complex(-nan, -inf)},
	Test{complex(inf, -1), complex(0, -1), complex(-nan, inf)},
	Test{complex(inf, -1), complex(0, 2), complex(-nan, -inf)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(1, 0), complex(inf, -nan)},
	Test{complex(inf, -1), complex(1, 1), complex(inf, -inf)},
	Test{complex(inf, -1), complex(1, -1), complex(inf, inf)},
	Test{complex(inf, -1), complex(1, 2), complex(inf, -inf)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-1, 0), complex(-inf, -nan)},
	Test{complex(inf, -1), complex(-1, 1), complex(-inf, -inf)},
	Test{complex(inf, -1), complex(-1, -1), complex(-inf, inf)},
	Test{complex(inf, -1), complex(-1, 2), complex(-inf, -inf)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(2, 0), complex(inf, -nan)},
	Test{complex(inf, -1), complex(2, 1), complex(inf, -inf)},
	Test{complex(inf, -1), complex(2, -1), complex(inf, inf)},
	Test{complex(inf, -1), complex(2, 2), complex(inf, -inf)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(inf, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(inf, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(inf, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(0, 0), complex(inf, inf)},
	Test{complex(inf, 2), complex(0, 1), complex(-nan, -inf)},
	Test{complex(inf, 2), complex(0, -1), complex(-nan, inf)},
	Test{complex(inf, 2), complex(0, 2), complex(-nan, -inf)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(1, 0), complex(inf, -nan)},
	Test{complex(inf, 2), complex(1, 1), complex(inf, -inf)},
	Test{complex(inf, 2), complex(1, -1), complex(inf, inf)},
	Test{complex(inf, 2), complex(1, 2), complex(inf, -inf)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-1, 0), complex(-inf, -nan)},
	Test{complex(inf, 2), complex(-1, 1), complex(-inf, -inf)},
	Test{complex(inf, 2), complex(-1, -1), complex(-inf, inf)},
	Test{complex(inf, 2), complex(-1, 2), complex(-inf, -inf)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(2, 0), complex(inf, -nan)},
	Test{complex(inf, 2), complex(2, 1), complex(inf, -inf)},
	Test{complex(inf, 2), complex(2, -1), complex(inf, inf)},
	Test{complex(inf, 2), complex(2, 2), complex(inf, -inf)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(inf, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(inf, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(inf, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(0, 0), complex(-inf, -nan)},
	Test{complex(-inf, 0), complex(0, 1), complex(-nan, inf)},
	Test{complex(-inf, 0), complex(0, -1), complex(-nan, -inf)},
	Test{complex(-inf, 0), complex(0, 2), complex(-nan, inf)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(1, 0), complex(-inf, -nan)},
	Test{complex(-inf, 0), complex(1, 1), complex(-inf, inf)},
	Test{complex(-inf, 0), complex(1, -1), complex(-inf, -inf)},
	Test{complex(-inf, 0), complex(1, 2), complex(-inf, inf)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-1, 0), complex(inf, -nan)},
	Test{complex(-inf, 0), complex(-1, 1), complex(inf, inf)},
	Test{complex(-inf, 0), complex(-1, -1), complex(inf, -inf)},
	Test{complex(-inf, 0), complex(-1, 2), complex(inf, inf)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(2, 0), complex(-inf, -nan)},
	Test{complex(-inf, 0), complex(2, 1), complex(-inf, inf)},
	Test{complex(-inf, 0), complex(2, -1), complex(-inf, -inf)},
	Test{complex(-inf, 0), complex(2, 2), complex(-inf, inf)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(nan, 0), complex(nan, nan)},
	Test{complex(-inf, 0), complex(nan, 1), complex(nan, nan)},
	Test{complex(-inf, 0), complex(nan, -1), complex(nan, nan)},
	Test{complex(-inf, 0), complex(nan, 2), complex(nan, nan)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 0), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 0), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(0, 0), complex(-inf, inf)},
	Test{complex(-inf, 1), complex(0, 1), complex(-nan, inf)},
	Test{complex(-inf, 1), complex(0, -1), complex(-nan, -inf)},
	Test{complex(-inf, 1), complex(0, 2), complex(-nan, inf)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(1, 0), complex(-inf, -nan)},
	Test{complex(-inf, 1), complex(1, 1), complex(-inf, inf)},
	Test{complex(-inf, 1), complex(1, -1), complex(-inf, -inf)},
	Test{complex(-inf, 1), complex(1, 2), complex(-inf, inf)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-1, 0), complex(inf, -nan)},
	Test{complex(-inf, 1), complex(-1, 1), complex(inf, inf)},
	Test{complex(-inf, 1), complex(-1, -1), complex(inf, -inf)},
	Test{complex(-inf, 1), complex(-1, 2), complex(inf, inf)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(2, 0), complex(-inf, -nan)},
	Test{complex(-inf, 1), complex(2, 1), complex(-inf, inf)},
	Test{complex(-inf, 1), complex(2, -1), complex(-inf, -inf)},
	Test{complex(-inf, 1), complex(2, 2), complex(-inf, inf)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(nan, 0), complex(nan, nan)},
	Test{complex(-inf, 1), complex(nan, 1), complex(nan, nan)},
	Test{complex(-inf, 1), complex(nan, -1), complex(nan, nan)},
	Test{complex(-inf, 1), complex(nan, 2), complex(nan, nan)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(0, 0), complex(-inf, -inf)},
	Test{complex(-inf, -1), complex(0, 1), complex(-nan, inf)},
	Test{complex(-inf, -1), complex(0, -1), complex(-nan, -inf)},
	Test{complex(-inf, -1), complex(0, 2), complex(-nan, inf)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(1, 0), complex(-inf, -nan)},
	Test{complex(-inf, -1), complex(1, 1), complex(-inf, inf)},
	Test{complex(-inf, -1), complex(1, -1), complex(-inf, -inf)},
	Test{complex(-inf, -1), complex(1, 2), complex(-inf, inf)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-1, 0), complex(inf, -nan)},
	Test{complex(-inf, -1), complex(-1, 1), complex(inf, inf)},
	Test{complex(-inf, -1), complex(-1, -1), complex(inf, -inf)},
	Test{complex(-inf, -1), complex(-1, 2), complex(inf, inf)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(2, 0), complex(-inf, -nan)},
	Test{complex(-inf, -1), complex(2, 1), complex(-inf, inf)},
	Test{complex(-inf, -1), complex(2, -1), complex(-inf, -inf)},
	Test{complex(-inf, -1), complex(2, 2), complex(-inf, inf)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(nan, 0), complex(nan, nan)},
	Test{complex(-inf, -1), complex(nan, 1), complex(nan, nan)},
	Test{complex(-inf, -1), complex(nan, -1), complex(nan, nan)},
	Test{complex(-inf, -1), complex(nan, 2), complex(nan, nan)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, -1), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, -1), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(0, 0), complex(-inf, inf)},
	Test{complex(-inf, 2), complex(0, 1), complex(-nan, inf)},
	Test{complex(-inf, 2), complex(0, -1), complex(-nan, -inf)},
	Test{complex(-inf, 2), complex(0, 2), complex(-nan, inf)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(1, 0), complex(-inf, -nan)},
	Test{complex(-inf, 2), complex(1, 1), complex(-inf, inf)},
	Test{complex(-inf, 2), complex(1, -1), complex(-inf, -inf)},
	Test{complex(-inf, 2), complex(1, 2), complex(-inf, inf)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-1, 0), complex(inf, -nan)},
	Test{complex(-inf, 2), complex(-1, 1), complex(inf, inf)},
	Test{complex(-inf, 2), complex(-1, -1), complex(inf, -inf)},
	Test{complex(-inf, 2), complex(-1, 2), complex(inf, inf)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(2, 0), complex(-inf, -nan)},
	Test{complex(-inf, 2), complex(2, 1), complex(-inf, inf)},
	Test{complex(-inf, 2), complex(2, -1), complex(-inf, -inf)},
	Test{complex(-inf, 2), complex(2, 2), complex(-inf, inf)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(nan, 0), complex(nan, nan)},
	Test{complex(-inf, 2), complex(nan, 1), complex(nan, nan)},
	Test{complex(-inf, 2), complex(nan, -1), complex(nan, nan)},
	Test{complex(-inf, 2), complex(nan, 2), complex(nan, nan)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(nan, nan), complex(nan, nan)},
	Test{complex(-inf, 2), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-inf, 2), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(nan, nan), complex(0, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(0, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-1, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(2, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 0), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, -1), complex(nan, nan)},
	Test{complex(nan, nan), complex(-inf, 2), complex(nan, nan)},
	Test{complex(nan, nan), complex(nan, nan), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, inf), complex(nan, nan)},
	Test{complex(nan, nan), complex(-nan, -inf), complex(nan, nan)},
	Test{complex(-nan, inf), complex(0, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(0, 1), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(0, -1), complex(-inf, -nan)},
	Test{complex(-nan, inf), complex(0, 2), complex(inf, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(1, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(1, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(1, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(1, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-1, 0), complex(-nan, -inf)},
	Test{complex(-nan, inf), complex(-1, 1), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(-1, -1), complex(-inf, -inf)},
	Test{complex(-nan, inf), complex(-1, 2), complex(inf, -inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(2, 0), complex(-nan, inf)},
	Test{complex(-nan, inf), complex(2, 1), complex(inf, inf)},
	Test{complex(-nan, inf), complex(2, -1), complex(-inf, inf)},
	Test{complex(-nan, inf), complex(2, 2), complex(inf, inf)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(0, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(0, 1), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(0, -1), complex(inf, -nan)},
	Test{complex(-nan, -inf), complex(0, 2), complex(-inf, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(1, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(1, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(1, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(1, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-1, 0), complex(-nan, inf)},
	Test{complex(-nan, -inf), complex(-1, 1), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(-1, -1), complex(inf, inf)},
	Test{complex(-nan, -inf), complex(-1, 2), complex(-inf, inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(2, 0), complex(-nan, -inf)},
	Test{complex(-nan, -inf), complex(2, 1), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(2, -1), complex(inf, -inf)},
	Test{complex(-nan, -inf), complex(2, 2), complex(-inf, -inf)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, 0), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, -1), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, 2), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 0), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, -1), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-inf, 2), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(nan, nan), complex(nan, nan)},
	Test{complex(-nan, -inf), complex(-nan, inf), complex(-nan, -nan)},
	Test{complex(-nan, -inf), complex(-nan, -inf), complex(-nan, -nan)},
}
                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/complit.go                                                                        0100644 0000000 0000000 00000003326 13020111414 014521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test composite literals.

package main

type T struct {
	i    int
	f    float64
	s    string
	next *T
}

type R struct {
	num int
}

func itor(a int) *R {
	r := new(R)
	r.num = a
	return r
}

func eq(a []*R) {
	for i := 0; i < len(a); i++ {
		if a[i].num != i {
			panic("bad")
		}
	}
}

func teq(t *T, n int) {
	for i := 0; i < n; i++ {
		if t == nil || t.i != i {
			panic("bad")
		}
		t = t.next
	}
	if t != nil {
		panic("bad")
	}
}

type P struct {
	a, b int
}

func NewP(a, b int) *P {
	return &P{a, b}
}

func main() {
	var t T
	t = T{0, 7.2, "hi", &t}

	var tp *T
	tp = &T{0, 7.2, "hi", &t}

	tl := &T{i: 0, next: &T{i: 1, next: &T{i: 2, next: &T{i: 3, next: &T{i: 4}}}}}
	teq(tl, 5)

	a1 := []int{1, 2, 3}
	if len(a1) != 3 {
		panic("a1")
	}
	a2 := [10]int{1, 2, 3}
	if len(a2) != 10 || cap(a2) != 10 {
		panic("a2")
	}

	a3 := [10]int{1, 2, 3}
	if len(a3) != 10 || a2[3] != 0 {
		panic("a3")
	}

	var oai []int
	oai = []int{1, 2, 3}
	if len(oai) != 3 {
		panic("oai")
	}

	at := [...]*T{&t, tp, &t}
	if len(at) != 3 {
		panic("at")
	}

	c := make(chan int)
	ac := []chan int{c, c, c}
	if len(ac) != 3 {
		panic("ac")
	}

	aat := [][len(at)]*T{at, at}
	if len(aat) != 2 || len(aat[1]) != 3 {
		panic("aat")
	}

	s := string([]byte{'h', 'e', 'l', 'l', 'o'})
	if s != "hello" {
		panic("s")
	}

	m := map[string]float64{"one": 1.0, "two": 2.0, "pi": 22. / 7.}
	if len(m) != 3 {
		panic("m")
	}

	eq([]*R{itor(0), itor(1), itor(2), itor(3), itor(4), itor(5)})
	eq([]*R{{0}, {1}, {2}, {3}, {4}, {5}})

	p1 := NewP(1, 2)
	p2 := NewP(1, 2)
	if p1 == p2 {
		panic("NewP")
	}
}
                                                                                                                                                                                                                                                                                                          usr/local/go/test/complit1.go                                                                       0100644 0000000 0000000 00000002304 13020111414 014575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that illegal composite literals are detected.
// Does not compile.

package main

var m map[int][3]int

func f() [3]int

func fp() *[3]int

var mp map[int]*[3]int

var (
	_ = [3]int{1, 2, 3}[:] // ERROR "slice of unaddressable value"
	_ = m[0][:]            // ERROR "slice of unaddressable value"
	_ = f()[:]             // ERROR "slice of unaddressable value"

	// these are okay because they are slicing a pointer to an array
	_ = (&[3]int{1, 2, 3})[:]
	_ = mp[0][:]
	_ = fp()[:]
)

type T struct {
	i    int
	f    float64
	s    string
	next *T
}

var (
	_ = &T{0, 0, "", nil}               // ok
	_ = &T{i: 0, f: 0, s: "", next: {}} // ERROR "missing type in composite literal|omit types within composite literal"
	_ = &T{0, 0, "", {}}                // ERROR "missing type in composite literal|omit types within composite literal"
)

type M map[T]T

var (
	_ = M{{i:1}: {i:2}}
	_ = M{T{i:1}: {i:2}}
	_ = M{{i:1}: T{i:2}}
	_ = M{T{i:1}: T{i:2}}
)

type S struct { s [1]*M1 }
type M1 map[S]int
var _ = M1{{s:[1]*M1{&M1{{}:1}}}:2}

                                                                                                                                                                                                                                                                                                                            usr/local/go/test/compos.go                                                                         0100644 0000000 0000000 00000000624 13020111414 014350  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that returning &T{} from a function causes an allocation.

package main

type T struct {
	int
}

func f() *T {
	return &T{1}
}

func main() {
	x := f()
	y := f()
	if x == y {
		panic("not allocating & composite literals")
	}
}
                                                                                                            usr/local/go/test/const.go                                                                          0100644 0000000 0000000 00000005217 13020111414 014201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test simple boolean and numeric constants.

package main

import "os"

const (
	c0      = 0
	cm1     = -1
	chuge   = 1 << 100
	chuge_1 = chuge - 1
	c1      = chuge >> 100
	c3div2  = 3 / 2
	c1e3    = 1e3

	rsh1 = 1e100 >> 1000
	rsh2 = 1e302 >> 1000

	ctrue  = true
	cfalse = !ctrue
)

const (
	f0              = 0.0
	fm1             = -1.
	fhuge   float64 = 1 << 100
	fhuge_1 float64 = chuge - 1
	f1      float64 = chuge >> 100
	f3div2          = 3. / 2.
	f1e3    float64 = 1e3
)

func assert(t bool, s string) {
	if !t {
		panic(s)
	}
}

func ints() {
	assert(c0 == 0, "c0")
	assert(c1 == 1, "c1")
	assert(chuge > chuge_1, "chuge")
	assert(chuge_1+1 == chuge, "chuge 1")
	assert(chuge+cm1+1 == chuge, "cm1")
	assert(c3div2 == 1, "3/2")
	assert(c1e3 == 1000, "c1e3 int")
	assert(c1e3 == 1e3, "c1e3 float")
	assert(rsh1 == 0, "rsh1")
	assert(rsh2 == 9, "rsh2")

	// verify that all (in range) are assignable as ints
	var i int
	i = c0
	assert(i == c0, "i == c0")
	i = cm1
	assert(i == cm1, "i == cm1")
	i = c1
	assert(i == c1, "i == c1")
	i = c3div2
	assert(i == c3div2, "i == c3div2")
	i = c1e3
	assert(i == c1e3, "i == c1e3")

	// verify that all are assignable as floats
	var f float64
	f = c0
	assert(f == c0, "f == c0")
	f = cm1
	assert(f == cm1, "f == cm1")
	f = chuge
	assert(f == chuge, "f == chuge")
	f = chuge_1
	assert(f == chuge_1, "f == chuge_1")
	f = c1
	assert(f == c1, "f == c1")
	f = c3div2
	assert(f == c3div2, "f == c3div2")
	f = c1e3
	assert(f == c1e3, "f == c1e3")
}

func floats() {
	assert(f0 == c0, "f0")
	assert(f1 == c1, "f1")
	// TODO(gri): exp/ssa/interp constant folding is incorrect.
	if os.Getenv("GOSSAINTERP") == "" {
		assert(fhuge == fhuge_1, "fhuge") // float64 can't distinguish fhuge, fhuge_1.
	}
	assert(fhuge_1+1 == fhuge, "fhuge 1")
	assert(fhuge+fm1+1 == fhuge, "fm1")
	assert(f3div2 == 1.5, "3./2.")
	assert(f1e3 == 1000, "f1e3 int")
	assert(f1e3 == 1.e3, "f1e3 float")

	// verify that all (in range) are assignable as ints
	var i int
	i = f0
	assert(i == f0, "i == f0")
	i = fm1
	assert(i == fm1, "i == fm1")

	// verify that all are assignable as floats
	var f float64
	f = f0
	assert(f == f0, "f == f0")
	f = fm1
	assert(f == fm1, "f == fm1")
	f = fhuge
	assert(f == fhuge, "f == fhuge")
	f = fhuge_1
	assert(f == fhuge_1, "f == fhuge_1")
	f = f1
	assert(f == f1, "f == f1")
	f = f3div2
	assert(f == f3div2, "f == f3div2")
	f = f1e3
	assert(f == f1e3, "f == f1e3")
}

func main() {
	ints()
	floats()

	assert(ctrue == true, "ctrue == true")
	assert(cfalse == false, "cfalse == false")
}
                                                                                                                                                                                                                                                                                                                                                                                 usr/local/go/test/const1.go                                                                         0100644 0000000 0000000 00000006560 13020111414 014264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify overflow is detected when using numeric constants.
// Does not compile.

package main

import "unsafe"

type I interface{}

const (
	// assume all types behave similarly to int8/uint8
	Int8   int8  = 101
	Minus1 int8  = -1
	Uint8  uint8 = 102
	Const        = 103

	Float32    float32 = 104.5
	Float64    float64 = 105.5
	ConstFloat         = 106.5
	Big        float64 = 1e300

	String = "abc"
	Bool   = true
)

var (
	a1 = Int8 * 100              // ERROR "overflow"
	a2 = Int8 * -1               // OK
	a3 = Int8 * 1000             // ERROR "overflow"
	a4 = Int8 * int8(1000)       // ERROR "overflow"
	a5 = int8(Int8 * 1000)       // ERROR "overflow"
	a6 = int8(Int8 * int8(1000)) // ERROR "overflow"
	a7 = Int8 - 2*Int8 - 2*Int8  // ERROR "overflow"
	a8 = Int8 * Const / 100      // ERROR "overflow"
	a9 = Int8 * (Const / 100)    // OK

	b1        = Uint8 * Uint8         // ERROR "overflow"
	b2        = Uint8 * -1            // ERROR "overflow"
	b3        = Uint8 - Uint8         // OK
	b4        = Uint8 - Uint8 - Uint8 // ERROR "overflow"
	b5        = uint8(^0)             // ERROR "overflow"
	b5a       = int64(^0)             // OK
	b6        = ^uint8(0)             // OK
	b6a       = ^int64(0)             // OK
	b7        = uint8(Minus1)         // ERROR "overflow"
	b8        = uint8(int8(-1))       // ERROR "overflow"
	b8a       = uint8(-1)             // ERROR "overflow"
	b9   byte = (1 << 10) >> 8        // OK
	b10  byte = (1 << 10)             // ERROR "overflow"
	b11  byte = (byte(1) << 10) >> 8  // ERROR "overflow"
	b12  byte = 1000                  // ERROR "overflow"
	b13  byte = byte(1000)            // ERROR "overflow"
	b14  byte = byte(100) * byte(100) // ERROR "overflow"
	b15  byte = byte(100) * 100       // ERROR "overflow"
	b16  byte = byte(0) * 1000        // ERROR "overflow"
	b16a byte = 0 * 1000              // OK
	b17  byte = byte(0) * byte(1000)  // ERROR "overflow"
	b18  byte = Uint8 / 0             // ERROR "division by zero"

	c1 float64 = Big
	c2 float64 = Big * Big          // ERROR "overflow"
	c3 float64 = float64(Big) * Big // ERROR "overflow"
	c4         = Big * Big          // ERROR "overflow"
	c5         = Big / 0            // ERROR "division by zero"
	c6         = 1000 % 1e3         // ERROR "floating-point % operation|expected integer type"
)

func f(int)

func main() {
	f(Int8)             // ERROR "convert|wrong type|cannot"
	f(Minus1)           // ERROR "convert|wrong type|cannot"
	f(Uint8)            // ERROR "convert|wrong type|cannot"
	f(Const)            // OK
	f(Float32)          // ERROR "convert|wrong type|cannot"
	f(Float64)          // ERROR "convert|wrong type|cannot"
	f(ConstFloat)       // ERROR "truncate"
	f(ConstFloat - 0.5) // OK
	f(Big)              // ERROR "convert|wrong type|cannot"
	f(String)           // ERROR "convert|wrong type|cannot|incompatible"
	f(Bool)             // ERROR "convert|wrong type|cannot|incompatible"
}

const ptr = nil // ERROR "const.*nil"
const _ = string([]byte(nil)) // ERROR "is not a? ?constant"
const _ = uintptr(unsafe.Pointer((*int)(nil))) // ERROR "is not a? ?constant"
const _ = unsafe.Pointer((*int)(nil)) // ERROR "cannot be nil|invalid constant type"
const _ = (*int)(nil) // ERROR "cannot be nil|invalid constant type"
                                                                                                                                                usr/local/go/test/const2.go                                                                         0100644 0000000 0000000 00000001135 13020111414 014256  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that large integer constant expressions cause overflow.
// Does not compile.

package main

const (
	A int = 1
	B byte;	// ERROR "type without expr|expected .=."
)

const LargeA = 1000000000000000000
const LargeB = LargeA * LargeA * LargeA
const LargeC = LargeB * LargeB * LargeB // GC_ERROR "constant multiplication overflow"

const AlsoLargeA = LargeA << 400 << 400 >> 400 >> 400 // GC_ERROR "constant shift overflow"
                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/test/const3.go                                                                         0100644 0000000 0000000 00000001223 13020111414 014255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test typed integer constants.

package main

import "fmt"

type T int

func (t T) String() string { return fmt.Sprintf("T%d", int(t)) }

const (
	A T = 1 << (1 << iota)
	B
	C
	D
	E
)

func main() {
	s := fmt.Sprintf("%v %v %v %v %v", A, B, C, D, E)
	if s != "T2 T4 T16 T256 T65536" {
		println("type info didn't propagate in const: got", s)
		panic("fail")
	}
	x := uint(5)
	y := float64(uint64(1)<<x)	// used to fail to compile
	if y != 32 {
		println("wrong y", y)
		panic("fail")
	}
}
                                                                                                                                                                                                                                                                                                                                                                             usr/local/go/test/const4.go                                                                         0100644 0000000 0000000 00000002433 13020111414 014262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test len constants and non-constants, https://golang.org/issue/3244.

package main

var b struct {
	a [10]int
}

var m map[string][20]int

var s [][30]int

const (
	n1 = len(b.a)
	n2 = len(m[""])
	n3 = len(s[10])
)

// Non-constants (see also const5.go).
var (
	n4 = len(f())
	n5 = len(<-c)
	n6 = cap(g())
	n7 = cap(<-c1)
)

var calledF = false

func f() *[40]int {
	calledF = true
	return nil
}

var c = func() chan *[50]int {
	c := make(chan *[50]int, 2)
	c <- nil
	c <- new([50]int)
	return c
}()

var calledG = false

func g() *[60]int {
	calledG = true
	return nil
}

var c1 = func() chan *[70]int {
	c := make(chan *[70]int, 2)
	c <- nil
	c <- new([70]int)
	return c
}()

func main() {
	if n1 != 10 || n2 != 20 || n3 != 30 || n4 != 40 || n5 != 50 || n6 != 60 || n7 != 70 {
		println("BUG:", n1, n2, n3, n4, n5, n6, n7)
		panic("fail")
	}
	if !calledF {
		println("BUG: did not call f")
		panic("fail")
	}
	if <-c == nil {
		println("BUG: did not receive from c")
		panic("fail")
	}
	if !calledG {
		println("BUG: did not call g")
		panic("fail")
	}
	if <-c1 == nil {
		println("BUG: did not receive from c1")
		panic("fail")
	}
}
                                                                                                                                                                                                                                     usr/local/go/test/const5.go                                                                         0100644 0000000 0000000 00000001503 13020111414 014260  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that len non-constants are not constants, https://golang.org/issue/3244.

package p

var b struct {
	a[10]int
}

var m map[string][20]int

var s [][30]int

func f() *[40]int
var c chan *[50]int
var z complex128

const (
	n1 = len(b.a)
	n2 = len(m[""])
	n3 = len(s[10])

	n4 = len(f())  // ERROR "is not a constant|is not constant"
	n5 = len(<-c) // ERROR "is not a constant|is not constant"

	n6 = cap(f())  // ERROR "is not a constant|is not constant"
	n7 = cap(<-c) // ERROR "is not a constant|is not constant"
	n8 = real(z) // ERROR "is not a constant|is not constant"
	n9 = len([4]float64{real(z)}) // ERROR "is not a constant|is not constant"

)

                                                                                                                                                                                             usr/local/go/test/const6.go                                                                         0100644 0000000 0000000 00000001503 13020111414 014261  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Ideal vs non-ideal bool. See issue 3915, 3923.

package p

type mybool bool
type mybool1 bool

var (
	x, y int = 1, 2
	c1 bool = x < y
	c2 mybool = x < y
	c3 mybool = c2 == (x < y)
	c4 mybool = c2 == (1 < 2)
	c5 mybool = 1 < 2
	c6 mybool1 = x < y
	c7 = c1 == c2 // ERROR "mismatched types|incompatible types"
	c8 = c2 == c6 // ERROR "mismatched types|incompatible types"
	c9 = c1 == c6 // ERROR "mismatched types|incompatible types"
	_ = c2 && (x < y)
	_ = c2 && (1 < 2)
	_ = c1 && c2 // ERROR "mismatched types|incompatible types"
	_ = c2 && c6 // ERROR "mismatched types|incompatible types"
	_ = c1 && c6 // ERROR "mismatched types|incompatible types"
)
                                                                                                                                                                                             usr/local/go/test/convT2X.go                                                                        0100644 0000000 0000000 00000006521 13020111414 014355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test conversion from non-interface types to the empty interface.

package main

type J interface {
	Method()
}

type (
	U16  uint16
	U32  uint32
	U64  uint64
	U128 [2]uint64
	F32  float32
	F64  float64
	C128 complex128
	S    string
	B    []byte
	M    map[int]int
	C    chan int
	Z    struct{}
)

func (U16) Method()  {}
func (U32) Method()  {}
func (U64) Method()  {}
func (U128) Method() {}
func (F32) Method()  {}
func (F64) Method()  {}
func (C128) Method() {}
func (S) Method()    {}
func (B) Method()    {}
func (M) Method()    {}
func (C) Method()    {}
func (Z) Method()    {}

var (
	u16  = U16(1)
	u32  = U32(2)
	u64  = U64(3)
	u128 = U128{4, 5}
	f32  = F32(6)
	f64  = F64(7)
	c128 = C128(8 + 9i)
	s    = S("10")
	b    = B("11")
	m    = M{12: 13}
	c    = make(C, 14)
	z    = Z{}
	p    = &z
	pp   = &p
)

var (
	iu16  interface{} = u16
	iu32  interface{} = u32
	iu64  interface{} = u64
	iu128 interface{} = u128
	if32  interface{} = f32
	if64  interface{} = f64
	ic128 interface{} = c128
	is    interface{} = s
	ib    interface{} = b
	im    interface{} = m
	ic    interface{} = c
	iz    interface{} = z
	ip    interface{} = p
	ipp   interface{} = pp

	ju16  J = u16
	ju32  J = u32
	ju64  J = u64
	ju128 J = u128
	jf32  J = f32
	jf64  J = f64
	jc128 J = c128
	js    J = s
	jb    J = b
	jm    J = m
	jc    J = c
	jz J = z
	jp J = p // The method set for *T contains the methods for T.
	// pp does not implement error.
)

func second(a ...interface{}) interface{} {
	return a[1]
}

func main() {
	// Test equality.
	if u16 != iu16 {
		panic("u16 != iu16")
	}
	if u16 != ju16 {
		panic("u16 != ju16")
	}
	if u32 != iu32 {
		panic("u32 != iu32")
	}
	if u32 != ju32 {
		panic("u32 != ju32")
	}
	if u64 != iu64 {
		panic("u64 != iu64")
	}
	if u64 != ju64 {
		panic("u64 != ju64")
	}
	if u128 != iu128 {
		panic("u128 != iu128")
	}
	if u128 != ju128 {
		panic("u128 != ju128")
	}
	if f32 != if32 {
		panic("f32 != if32")
	}
	if f32 != jf32 {
		panic("f32 != jf32")
	}
	if f64 != if64 {
		panic("f64 != if64")
	}
	if f64 != jf64 {
		panic("f64 != jf64")
	}
	if c128 != ic128 {
		panic("c128 != ic128")
	}
	if c128 != jc128 {
		panic("c128 != jc128")
	}
	if s != is {
		panic("s != is")
	}
	if s != js {
		panic("s != js")
	}
	if c != ic {
		panic("c != ic")
	}
	if c != jc {
		panic("c != jc")
	}
	// There are no tests for b and m, as slices and maps are not comparable by ==.
	if z != iz {
		panic("z != iz")
	}
	if z != jz {
		panic("z != jz")
	}
	if p != ip {
		panic("p != ip")
	}
	if p != jp {
		panic("p != jp")
	}
	if pp != ipp {
		panic("pp != ipp")
	}
	// pp does not implement J.

	// Test that non-interface types can be used as ...interface{} arguments.
	if got := second(z, p, pp, u16, u32, u64, u128, f32, f64, c128, s, b, m, c); got != ip {
		println("second: got", got, "want", ip)
		panic("fail")
	}

	// Test that non-interface types can be sent on a chan interface{}.
	const n = 100
	uc := make(chan interface{})
	go func() {
		for i := 0; i < n; i++ {
			select {
			case uc <- nil:
			case uc <- u32:
			case uc <- u64:
			case uc <- u128:
			}
		}
	}()
	for i := 0; i < n; i++ {
		if got := <-uc; got != nil && got != u32 && got != u64 && got != u128 {
			println("recv: i", i, "got", got)
			panic("fail")
		}
	}
}
                                                                                                                                                                               usr/local/go/test/convert.go                                                                        0100644 0000000 0000000 00000001501 13020111414 014523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test types of constant expressions, using reflect.

package main

import "reflect"

func typeof(x interface{}) string { return reflect.TypeOf(x).String() }

func f() int { return 0 }

func g() int { return 0 }

type T func() int

var m = map[string]T{"f": f}

type A int
type B int

var a A = 1
var b B = 2
var x int

func main() {
	want := typeof(g)
	if t := typeof(f); t != want {
		println("type of f is", t, "want", want)
		panic("fail")
	}

	want = typeof(a)
	if t := typeof(+a); t != want {
		println("type of +a is", t, "want", want)
		panic("fail")
	}
	if t := typeof(a + 0); t != want {
		println("type of a+0 is", t, "want", want)
		panic("fail")
	}
}
                                                                                                                                                                                               usr/local/go/test/convert1.go                                                                       0100644 0000000 0000000 00000006644 13020111414 014621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that illegal conversions involving strings are detected.
// Does not compile.

package main

type Tbyte []byte
type Trune []rune
type Tint64 []int64
type Tstring string

func main() {
	s := "hello"
	sb := []byte("hello")
	sr := []rune("hello")
	si := []int64{'h', 'e', 'l', 'l', 'o'}

	ts := Tstring(s)
	tsb := Tbyte(sb)
	tsr := Trune(sr)
	tsi := Tint64(si)

	_ = string(s)
	_ = []byte(s)
	_ = []rune(s)
	_ = []int64(s) // ERROR "cannot convert.*\[\]int64|invalid type conversion"
	_ = Tstring(s)
	_ = Tbyte(s)
	_ = Trune(s)
	_ = Tint64(s) // ERROR "cannot convert.*Tint64|invalid type conversion"

	_ = string(sb)
	_ = []byte(sb)
	_ = []rune(sb)  // ERROR "cannot convert.*\[\]rune|invalid type conversion"
	_ = []int64(sb) // ERROR "cannot convert.*\[\]int64|invalid type conversion"
	_ = Tstring(sb)
	_ = Tbyte(sb)
	_ = Trune(sb)  // ERROR "cannot convert.*Trune|invalid type conversion"
	_ = Tint64(sb) // ERROR "cannot convert.*Tint64|invalid type conversion"

	_ = string(sr)
	_ = []byte(sr) // ERROR "cannot convert.*\[\]byte|invalid type conversion"
	_ = []rune(sr)
	_ = []int64(sr) // ERROR "cannot convert.*\[\]int64|invalid type conversion"
	_ = Tstring(sr)
	_ = Tbyte(sr) // ERROR "cannot convert.*Tbyte|invalid type conversion"
	_ = Trune(sr)
	_ = Tint64(sr) // ERROR "cannot convert.*Tint64|invalid type conversion"

	_ = string(si) // ERROR "cannot convert.* string|invalid type conversion"
	_ = []byte(si) // ERROR "cannot convert.*\[\]byte|invalid type conversion"
	_ = []rune(si) // ERROR "cannot convert.*\[\]rune|invalid type conversion"
	_ = []int64(si)
	_ = Tstring(si) // ERROR "cannot convert.*Tstring|invalid type conversion"
	_ = Tbyte(si)   // ERROR "cannot convert.*Tbyte|invalid type conversion"
	_ = Trune(si)   // ERROR "cannot convert.*Trune|invalid type conversion"
	_ = Tint64(si)

	_ = string(ts)
	_ = []byte(ts)
	_ = []rune(ts)
	_ = []int64(ts) // ERROR "cannot convert.*\[\]int64|invalid type conversion"
	_ = Tstring(ts)
	_ = Tbyte(ts)
	_ = Trune(ts)
	_ = Tint64(ts) // ERROR "cannot convert.*Tint64|invalid type conversion"

	_ = string(tsb)
	_ = []byte(tsb)
	_ = []rune(tsb)  // ERROR "cannot convert.*\[\]rune|invalid type conversion"
	_ = []int64(tsb) // ERROR "cannot convert.*\[\]int64|invalid type conversion"
	_ = Tstring(tsb)
	_ = Tbyte(tsb)
	_ = Trune(tsb)  // ERROR "cannot convert.*Trune|invalid type conversion"
	_ = Tint64(tsb) // ERROR "cannot convert.*Tint64|invalid type conversion"

	_ = string(tsr)
	_ = []byte(tsr) // ERROR "cannot convert.*\[\]byte|invalid type conversion"
	_ = []rune(tsr)
	_ = []int64(tsr) // ERROR "cannot convert.*\[\]int64|invalid type conversion"
	_ = Tstring(tsr)
	_ = Tbyte(tsr) // ERROR "cannot convert.*Tbyte|invalid type conversion"
	_ = Trune(tsr)
	_ = Tint64(tsr) // ERROR "cannot convert.*Tint64|invalid type conversion"

	_ = string(tsi) // ERROR "cannot convert.* string|invalid type conversion"
	_ = []byte(tsi) // ERROR "cannot convert.*\[\]byte|invalid type conversion"
	_ = []rune(tsi) // ERROR "cannot convert.*\[\]rune|invalid type conversion"
	_ = []int64(tsi)
	_ = Tstring(tsi) // ERROR "cannot convert.*Tstring|invalid type conversion"
	_ = Tbyte(tsi)   // ERROR "cannot convert.*Tbyte|invalid type conversion"
	_ = Trune(tsi)   // ERROR "cannot convert.*Trune|invalid type conversion"
	_ = Tint64(tsi)
}
                                                                                            usr/local/go/test/convert3.go                                                                       0100644 0000000 0000000 00000001040 13020111414 014604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify allowed and disallowed conversions.
// Does not compile.

package main

// everything here is legal except the ERROR line

var c chan int
var d1 chan<- int = c
var d2 = (chan<- int)(c)

var e *[4]int
var f1 []int = e[0:]
var f2 = []int(e[0:])

var g = []int(nil)

type H []int
type J []int

var h H
var j1 J = h // ERROR "compat|illegal|cannot"
var j2 = J(h)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/local/go/test/convlit.go                                                                        0100644 0000000 0000000 00000004357 13020111414 014535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that illegal assignments with both explicit and implicit conversions of literals are detected.
// Does not compile.

package main

import "unsafe"

// explicit conversion of constants
var x1 = string(1)
var x2 string = string(1)
var x3 = int(1.5)     // ERROR "convert|truncate"
var x4 int = int(1.5) // ERROR "convert|truncate"
var x5 = "a" + string(1)
var x6 = int(1e100)      // ERROR "overflow"
var x7 = float32(1e1000) // ERROR "overflow"

// unsafe.Pointer can only convert to/from uintptr
var _ = string(unsafe.Pointer(uintptr(65)))  // ERROR "convert"
var _ = float64(unsafe.Pointer(uintptr(65))) // ERROR "convert"
var _ = int(unsafe.Pointer(uintptr(65)))     // ERROR "convert"

// implicit conversions merit scrutiny
var s string
var bad1 string = 1  // ERROR "conver|incompatible|invalid|cannot"
var bad2 = s + 1     // ERROR "conver|incompatible|invalid"
var bad3 = s + 'a'   // ERROR "conver|incompatible|invalid"
var bad4 = "a" + 1   // ERROR "literals|incompatible|convert|invalid"
var bad5 = "a" + 'a' // ERROR "literals|incompatible|convert|invalid"

var bad6 int = 1.5       // ERROR "convert|truncate"
var bad7 int = 1e100     // ERROR "overflow"
var bad8 float32 = 1e200 // ERROR "overflow"

// but these implicit conversions are okay
var good1 string = "a"
var good2 int = 1.0
var good3 int = 1e9
var good4 float64 = 1e20

// explicit conversion of string is okay
var _ = []rune("abc")
var _ = []byte("abc")

// implicit is not
var _ []int = "abc"  // ERROR "cannot use|incompatible|invalid"
var _ []byte = "abc" // ERROR "cannot use|incompatible|invalid"

// named string is okay
type Tstring string

var ss Tstring = "abc"
var _ = []rune(ss)
var _ = []byte(ss)

// implicit is still not
var _ []rune = ss // ERROR "cannot use|incompatible|invalid"
var _ []byte = ss // ERROR "cannot use|incompatible|invalid"

// named slice is now ok
type Trune []rune
type Tbyte []byte

var _ = Trune("abc") // ok
var _ = Tbyte("abc") // ok

// implicit is still not
var _ Trune = "abc" // ERROR "cannot use|incompatible|invalid"
var _ Tbyte = "abc" // ERROR "cannot use|incompatible|invalid"
                                                                                                                                                                                                                                                                                 usr/local/go/test/convlit1.go                                                                       0100644 0000000 0000000 00000000712 13020111414 014605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that illegal uses of composite literals are detected.
// Does not compile.

package main

var a = []int { "a" };	// ERROR "conver|incompatible|cannot"
var b = int { 1 };	// ERROR "compos"


func f() int

func main() {
	if f < 1 { }	// ERROR "conver|incompatible|invalid"
}
                                                      usr/local/go/test/copy.go                                                                           0100644 0000000 0000000 00000015147 13020111414 014030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Semi-exhaustive test for the copy predeclared function.

package main

import (
	"fmt"
	"os"
)

const N = 40

var input8 = make([]uint8, N)
var output8 = make([]uint8, N)
var input16 = make([]uint16, N)
var output16 = make([]uint16, N)
var input32 = make([]uint32, N)
var output32 = make([]uint32, N)
var input64 = make([]uint64, N)
var output64 = make([]uint64, N)
var inputS string
var outputS = make([]uint8, N)

type my8 []uint8
type my16 []uint16
type my32 []uint32
type my32b []uint32
type my64 []uint64
type myS string

func u8(i int) uint8 {
	i = 'a' + i%26
	return uint8(i)
}

func u16(ii int) uint16 {
	var i = uint16(ii)
	i = 'a' + i%26
	i |= i << 8
	return i
}

func u32(ii int) uint32 {
	var i = uint32(ii)
	i = 'a' + i%26
	i |= i << 8
	i |= i << 16
	return i
}

func u64(ii int) uint64 {
	var i = uint64(ii)
	i = 'a' + i%26
	i |= i << 8
	i |= i << 16
	i |= i << 32
	return i
}

func reset() {
	// swap in and out to exercise copy-up and copy-down
	input8, output8 = output8, input8
	input16, output16 = output16, input16
	input32, output32 = output32, input32
	input64, output64 = output64, input64
	in := 0
	out := 13
	for i := range input8 {
		input8[i] = u8(in)
		output8[i] = u8(out)
		outputS[i] = u8(out)
		input16[i] = u16(in)
		output16[i] = u16(out)
		input32[i] = u32(in)
		output32[i] = u32(out)
		input64[i] = u64(in)
		output64[i] = u64(out)
		in++
		out++
	}
	inputS = string(input8)
}

func clamp(n int) int {
	if n > N {
		return N
	}
	return n
}

func ncopied(length, in, out int) int {
	n := length
	if in+n > N {
		n = N - in
	}
	if out+n > N {
		n = N - out
	}
	return n
}

func doAllSlices(length, in, out int) {
	reset()
	n := copy(my8(output8[out:clamp(out+length)]), input8[in:clamp(in+length)])
	verify8(length, in, out, n)
	n = copy(my8(outputS[out:clamp(out+length)]), myS(inputS[in:clamp(in+length)]))
	verifyS(length, in, out, n)
	n = copy(my16(output16[out:clamp(out+length)]), input16[in:clamp(in+length)])
	verify16(length, in, out, n)
	n = copy(my32(output32[out:clamp(out+length)]), my32b(input32[in:clamp(in+length)]))
	verify32(length, in, out, n)
	n = copy(my64(output64[out:clamp(out+length)]), input64[in:clamp(in+length)])
	verify64(length, in, out, n)
}

func bad8(state string, i, length, in, out int) {
	fmt.Printf("%s bad(%d %d %d): %c not %c:\n\t%s\n\t%s\n",
		state,
		length, in, out,
		output8[i],
		uint8(i+13),
		input8, output8)
	os.Exit(1)
}

func verify8(length, in, out, m int) {
	n := ncopied(length, in, out)
	if m != n {
		fmt.Printf("count bad(%d %d %d): %d not %d\n", length, in, out, m, n)
		os.Exit(1)
		return
	}
	// before
	var i int
	for i = 0; i < out; i++ {
		if output8[i] != u8(i+13) {
			bad8("before8", i, length, in, out)
			return
		}
	}
	// copied part
	for ; i < out+n; i++ {
		if output8[i] != u8(i+in-out) {
			bad8("copied8", i, length, in, out)
			return
		}
	}
	// after
	for ; i < len(output8); i++ {
		if output8[i] != u8(i+13) {
			bad8("after8", i, length, in, out)
			return
		}
	}
}

func badS(state string, i, length, in, out int) {
	fmt.Printf("%s bad(%d %d %d): %c not %c:\n\t%s\n\t%s\n",
		state,
		length, in, out,
		outputS[i],
		uint8(i+13),
		inputS, outputS)
	os.Exit(1)
}

func verifyS(length, in, out, m int) {
	n := ncopied(length, in, out)
	if m != n {
		fmt.Printf("count bad(%d %d %d): %d not %d\n", length, in, out, m, n)
		os.Exit(1)
		return
	}
	// before
	var i int
	for i = 0; i < out; i++ {
		if outputS[i] != u8(i+13) {
			badS("beforeS", i, length, in, out)
			return
		}
	}
	// copied part
	for ; i < out+n; i++ {
		if outputS[i] != u8(i+in-out) {
			badS("copiedS", i, length, in, out)
			return
		}
	}
	// after
	for ; i < len(outputS); i++ {
		if outputS[i] != u8(i+13) {
			badS("afterS", i, length, in, out)
			return
		}
	}
}

func bad16(state string, i, length, in, out int) {
	fmt.Printf("%s bad(%d %d %d): %x not %x:\n\t%v\n\t%v\n",
		state,
		length, in, out,
		output16[i],
		uint16(i+13),
		input16, output16)
	os.Exit(1)
}

func verify16(length, in, out, m int) {
	n := ncopied(length, in, out)
	if m != n {
		fmt.Printf("count bad(%d %d %d): %d not %d\n", length, in, out, m, n)
		os.Exit(1)
		return
	}
	// before
	var i int
	for i = 0; i < out; i++ {
		if output16[i] != u16(i+13) {
			bad16("before16", i, length, in, out)
			return
		}
	}
	// copied part
	for ; i < out+n; i++ {
		if output16[i] != u16(i+in-out) {
			bad16("copied16", i, length, in, out)
			return
		}
	}
	// after
	for ; i < len(output16); i++ {
		if output16[i] != u16(i+13) {
			bad16("after16", i, length, in, out)
			return
		}
	}
}

func bad32(state string, i, length, in, out int) {
	fmt.Printf("%s bad(%d %d %d): %x not %x:\n\t%v\n\t%v\n",
		state,
		length, in, out,
		output32[i],
		uint32(i+13),
		input32, output32)
	os.Exit(1)
}

func verify32(length, in, out, m int) {
	n := ncopied(length, in, out)
	if m != n {
		fmt.Printf("count bad(%d %d %d): %d not %d\n", length, in, out, m, n)
		os.Exit(1)
		return
	}
	// before
	var i int
	for i = 0; i < out; i++ {
		if output32[i] != u32(i+13) {
			bad32("before32", i, length, in, out)
			return
		}
	}
	// copied part
	for ; i < out+n; i++ {
		if output32[i] != u32(i+in-out) {
			bad32("copied32", i, length, in, out)
			return
		}
	}
	// after
	for ; i < len(output32); i++ {
		if output32[i] != u32(i+13) {
			bad32("after32", i, length, in, out)
			return
		}
	}
}

func bad64(state string, i, length, in, out int) {
	fmt.Printf("%s bad(%d %d %d): %x not %x:\n\t%v\n\t%v\n",
		state,
		length, in, out,
		output64[i],
		uint64(i+13),
		input64, output64)
	os.Exit(1)
}

func verify64(length, in, out, m int) {
	n := ncopied(length, in, out)
	if m != n {
		fmt.Printf("count bad(%d %d %d): %d not %d\n", length, in, out, m, n)
		os.Exit(1)
		return
	}
	// before
	var i int
	for i = 0; i < out; i++ {
		if output64[i] != u64(i+13) {
			bad64("before64", i, length, in, out)
			return
		}
	}
	// copied part
	for ; i < out+n; i++ {
		if output64[i] != u64(i+in-out) {
			bad64("copied64", i, length, in, out)
			return
		}
	}
	// after
	for ; i < len(output64); i++ {
		if output64[i] != u64(i+13) {
			bad64("after64", i, length, in, out)
			return
		}
	}
}

func slice() {
	for length := 0; length < N; length++ {
		for in := 0; in <= 32; in++ {
			for out := 0; out <= 32; out++ {
				doAllSlices(length, in, out)
			}
		}
	}
}

// Array test. Can be much simpler. It's only checking for correct handling of [0:].
func array() {
	var array [N]uint8
	reset()
	copy(array[0:], input8)
	for i := 0; i < N; i++ {
		output8[i] = 0
	}
	copy(output8, array[0:])
	verify8(N, 0, 0, N)
}

func main() {
	slice()
	array()
}
                                                                                                                                                                                                                                                                                                                                                                                                                         usr/local/go/test/crlf.go                                                                           0100644 0000000 0000000 00000001416 13020111414 013776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // runoutput

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test source files and strings containing \r and \r\n.

package main

import (
	"fmt"
	"strings"
)

func main() {
	prog = strings.Replace(prog, "BQ", "`", -1)
	prog = strings.Replace(prog, "CR", "\r", -1)
	fmt.Print(prog)
}

var prog = `
package main
CR

import "fmt"

var CR s = "hello\n" + CR
	" world"CR

var t = BQhelloCR
 worldBQ

var u = BQhCReCRlCRlCRoCR
 worldBQ

var golden = "hello\n world"

func main() {
	if s != golden {
		fmt.Printf("s=%q, want %q", s, golden)
	}
	if t != golden {
		fmt.Printf("t=%q, want %q", t, golden)
	}
	if u != golden {
		fmt.Printf("u=%q, want %q", u, golden)
	}
}
`
                                                                                                                                                                                                                                                  usr/local/go/test/ddd.go                                                                            0100644 0000000 0000000 00000010353 13020111414 013603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test variadic functions and calls (dot-dot-dot).

package main

func sum(args ...int) int {
	s := 0
	for _, v := range args {
		s += v
	}
	return s
}

func sumC(args ...int) int { return func() int { return sum(args...) }() }

var sumD = func(args ...int) int { return sum(args...) }

var sumE = func() func(...int) int { return func(args ...int) int { return sum(args...) } }()

var sumF = func(args ...int) func() int { return func() int { return sum(args...) } }

func sumA(args []int) int {
	s := 0
	for _, v := range args {
		s += v
	}
	return s
}

func sumB(args []int) int { return sum(args...) }

func sum2(args ...int) int { return 2 * sum(args...) }

func sum3(args ...int) int { return 3 * sumA(args) }

func sum4(args ...int) int { return 4 * sumB(args) }

func intersum(args ...interface{}) int {
	s := 0
	for _, v := range args {
		s += v.(int)
	}
	return s
}

type T []T

func ln(args ...T) int { return len(args) }

func ln2(args ...T) int { return 2 * ln(args...) }

func (*T) Sum(args ...int) int { return sum(args...) }

type U struct {
	*T
}

type I interface {
	Sum(...int) int
}

func main() {
	if x := sum(1, 2, 3); x != 6 {
		println("sum 6", x)
		panic("fail")
	}
	if x := sum(); x != 0 {
		println("sum 0", x)
		panic("fail")
	}
	if x := sum(10); x != 10 {
		println("sum 10", x)
		panic("fail")
	}
	if x := sum(1, 8); x != 9 {
		println("sum 9", x)
		panic("fail")
	}
	if x := sumC(4, 5, 6); x != 15 {
		println("sumC 15", x)
		panic("fail")
	}
	if x := sumD(4, 5, 7); x != 16 {
		println("sumD 16", x)
		panic("fail")
	}
	if x := sumE(4, 5, 8); x != 17 {
		println("sumE 17", x)
		panic("fail")
	}
	if x := sumF(4, 5, 9)(); x != 18 {
		println("sumF 18", x)
		panic("fail")
	}
	if x := sum2(1, 2, 3); x != 2*6 {
		println("sum 6", x)
		panic("fail")
	}
	if x := sum2(); x != 2*0 {
		println("sum 0", x)
		panic("fail")
	}
	if x := sum2(10); x != 2*10 {
		println("sum 10", x)
		panic("fail")
	}
	if x := sum2(1, 8); x != 2*9 {
		println("sum 9", x)
		panic("fail")
	}
	if x := sum3(1, 2, 3); x != 3*6 {
		println("sum 6", x)
		panic("fail")
	}
	if x := sum3(); x != 3*0 {
		println("sum 0", x)
		panic("fail")
	}
	if x := sum3(10); x != 3*10 {
		println("sum 10", x)
		panic("fail")
	}
	if x := sum3(1, 8); x != 3*9 {
		println("sum 9", x)
		panic("fail")
	}
	if x := sum4(1, 2, 3); x != 4*6 {
		println("sum 6", x)
		panic("fail")
	}
	if x := sum4(); x != 4*0 {
		println("sum 0", x)
		panic("fail")
	}
	if x := sum4(10); x != 4*10 {
		println("sum 10", x)
		panic("fail")
	}
	if x := sum4(1, 8); x != 4*9 {
		println("sum 9", x)
		panic("fail")
	}
	if x := intersum(1, 2, 3); x != 6 {
		println("intersum 6", x)
		panic("fail")
	}
	if x := intersum(); x != 0 {
		println("intersum 0", x)
		panic("fail")
	}
	if x := intersum(10); x != 10 {
		println("intersum 10", x)
		panic("fail")
	}
	if x := intersum(1, 8); x != 9 {
		println("intersum 9", x)
		panic("fail")
	}

	if x := ln(nil, nil, nil); x != 3 {
		println("ln 3", x)
		panic("fail")
	}
	if x := ln([]T{}); x != 1 {
		println("ln 1", x)
		panic("fail")
	}
	if x := ln2(nil, nil, nil); x != 2*3 {
		println("ln2 3", x)
		panic("fail")
	}
	if x := ln2([]T{}); x != 2*1 {
		println("ln2 1", x)
		panic("fail")
	}
	if x := ((*T)(nil)).Sum(1, 3, 5, 7); x != 16 {
		println("(*T)(nil).Sum", x)
		panic("fail")
	}
	if x := (*T).Sum(nil, 1, 3, 5, 6); x != 15 {
		println("(*T).Sum", x)
		panic("fail")
	}
	if x := (&U{}).Sum(1, 3, 5, 5); x != 14 {
		println("(&U{}).Sum", x)
		panic("fail")
	}
	var u U
	if x := u.Sum(1, 3, 5, 4); x != 13 {
		println("u.Sum", x)
		panic("fail")
	}
	if x := (&u).Sum(1, 3, 5, 3); x != 12 {
		println("(&u).Sum", x)
		panic("fail")
	}
	var i interface {
		Sum(...int) int
	} = &u
	if x := i.Sum(2, 3, 5, 7); x != 17 {
		println("i(=&u).Sum", x)
		panic("fail")
	}
	i = u
	if x := i.Sum(2, 3, 5, 6); x != 16 {
		println("i(=u).Sum", x)
		panic("fail")
	}
	var s struct {
		I
	}
	s.I = &u
	if x := s.Sum(2, 3, 5, 8); x != 18 {
		println("s{&u}.Sum", x)
		panic("fail")
	}
	if x := (*U).Sum(&U{}, 1, 3, 5, 2); x != 11 {
		println("(*U).Sum", x)
		panic("fail")
	}
	if x := U.Sum(U{}, 1, 3, 5, 1); x != 10 {
		println("U.Sum", x)
		panic("fail")
	}
}
                                                                                                                                                                                                                                                                                     usr/local/go/test/ddd1.go                                                                           0100644 0000000 0000000 00000003064 13020111414 013665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Verify that illegal uses of ... are detected.
// Does not compile.

package main

import "unsafe"

func sum(args ...int) int { return 0 }

var (
	_ = sum(1, 2, 3)
	_ = sum()
	_ = sum(1.0, 2.0)
	_ = sum(1.5)      // ERROR "integer"
	_ = sum("hello")  // ERROR ".hello. .type string. as type int|incompatible"
	_ = sum([]int{1}) // ERROR "\[\]int literal.*as type int|incompatible"
)

func sum3(int, int, int) int { return 0 }
func tuple() (int, int, int) { return 1, 2, 3 }

var (
	_ = sum(tuple())
	_ = sum(tuple()...) // ERROR "multiple-value|[.][.][.]"
	_ = sum3(tuple())
	_ = sum3(tuple()...) // ERROR "multiple-value|[.][.][.]" "not enough"
)

type T []T

func funny(args ...T) int { return 0 }

var (
	_ = funny(nil)
	_ = funny(nil, nil)
	_ = funny([]T{}) // ok because []T{} is a T; passes []T{[]T{}}
)

func bad(args ...int) {
	print(1, 2, args...)	// ERROR "[.][.][.]"
	println(args...)	// ERROR "[.][.][.]"
	ch := make(chan int)
	close(ch...)	// ERROR "[.][.][.]"
	_ = len(args...)	// ERROR "[.][.][.]"
	_ = new(int...)	// ERROR "[.][.][.]"
	n := 10
	_ = make([]byte, n...)	// ERROR "[.][.][.]"
	// TODO(rsc): enable after gofmt bug is fixed
	//	_ = make([]byte, 10 ...)	// error "[.][.][.]"
	var x int
	_ = unsafe.Pointer(&x...)	// ERROR "[.][.][.]"
	_ = unsafe.Sizeof(x...)	// ERROR "[.][.][.]"
	_ = [...]byte("foo") // ERROR "[.][.][.]"
	_ = [...][...]int{{1,2,3},{4,5,6}}	// ERROR "[.][.][.]"
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/test/ddd2.dir/                                                                         0040755 0000000 0000000 00000000000 13020111414 014114  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/ddd2.dir/ddd2.go                                                                  0100644 0000000 0000000 00000000475 13020111414 015263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file is compiled and then imported by ddd3.go.

package ddd

func Sum(args ...int) int {
	s := 0
	for _, v := range args {
		s += v
	}
	return s
}

                                                                                                                                                                                                   usr/local/go/test/ddd2.dir/ddd3.go                                                                  0100644 0000000 0000000 00000001110 13020111414 015247  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that variadic functions work across package boundaries.

package main

import "./ddd2"

func main() {
	if x := ddd.Sum(1, 2, 3); x != 6 {
		println("ddd.Sum 6", x)
		panic("fail")
	}
	if x := ddd.Sum(); x != 0 {
		println("ddd.Sum 0", x)
		panic("fail")
	}
	if x := ddd.Sum(10); x != 10 {
		println("ddd.Sum 10", x)
		panic("fail")
	}
	if x := ddd.Sum(1, 8); x != 9 {
		println("ddd.Sum 9", x)
		panic("fail")
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/local/go/test/ddd2.go                                                                           0100644 0000000 0000000 00000000375 13020111414 013670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // rundir

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that variadic functions work across package boundaries.

package ignored
                                                                                                                                                                                                                                                                   usr/local/go/test/decl.go                                                                           0100644 0000000 0000000 00000001636 13020111414 013763  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test correct short declarations and redeclarations.

package main

func f1() int                    { return 1 }
func f2() (float32, int)         { return 1, 2 }
func f3() (float32, int, string) { return 1, 2, "3" }

func x() (s string) {
	a, b, s := f3()
	_, _ = a, b
	return // tests that result var is in scope for redeclaration
}

func main() {
	i, f, s := f3()
	j, f := f2() // redeclare f
	k := f1()
	m, g, s := f3()
	m, h, s := f3()
	{
		// new block should be ok.
		i, f, s := f3()
		j, f := f2() // redeclare f
		k := f1()
		m, g, s := f3()
		m, h, s := f3()
		_, _, _, _, _, _, _, _, _ = i, f, s, j, k, m, g, s, h
	}
	if y := x(); y != "3" {
		println("x() failed", y)
		panic("fail")
	}
	_, _, _, _, _, _, _, _, _ = i, f, s, j, k, m, g, s, h
}
                                                                                                  usr/local/go/test/declbad.go                                                                        0100644 0000000 0000000 00000002636 13020111414 014433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that incorrect short declarations and redeclarations are detected.
// Does not compile.

package main

func f1() int                    { return 1 }
func f2() (float32, int)         { return 1, 2 }
func f3() (float32, int, string) { return 1, 2, "3" }

func main() {
	{
		// simple redeclaration
		i := f1()
		i := f1() // ERROR "redeclared|no new"
		_ = i
	}
	{
		// change of type for f
		i, f, s := f3()
		f, g, t := f3() // ERROR "redeclared|cannot assign|incompatible"
		_, _, _, _, _ = i, f, s, g, t
	}
	{
		// change of type for i
		i, f, s := f3()
		j, i, t := f3() // ERROR "redeclared|cannot assign|incompatible"
		_, _, _, _, _ = i, f, s, j, t
	}
	{
		// no new variables
		i, f, s := f3()
		i, f := f2() // ERROR "redeclared|no new"
		_, _, _ = i, f, s
	}
	{
		// multiline no new variables
		i := f1
		i := func() int { // ERROR "redeclared|no new|incompatible"
			return 0
		}
		_ = i
	}
	{
		// single redeclaration
		i, f, s := f3()
		i := 1 // ERROR "redeclared|no new|incompatible"
		_, _, _ = i, f, s
	}
	// double redeclaration
	{
		i, f, s := f3()
		i, f := f2() // ERROR "redeclared|no new"
		_, _, _ = i, f, s
	}
	{
		// triple redeclaration
		i, f, s := f3()
		i, f, s := f3() // ERROR "redeclared|no new"
		_, _, _ = i, f, s
	}
}
                                                                                                  usr/local/go/test/defer.go                                                                          0100644 0000000 0000000 00000001553 13020111414 014137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test defer.

package main

import "fmt"

var result string

func addInt(i int) { result += fmt.Sprint(i) }

func test1helper() {
	for i := 0; i < 10; i++ {
		defer addInt(i)
	}
}

func test1() {
	result = ""
	test1helper()
	if result != "9876543210" {
		fmt.Printf("test1: bad defer result (should be 9876543210): %q\n", result)
		panic("defer")
	}
}

func addDotDotDot(v ...interface{}) { result += fmt.Sprint(v...) }

func test2helper() {
	for i := 0; i < 10; i++ {
		defer addDotDotDot(i)
	}
}

func test2() {
	result = ""
	test2helper()
	if result != "9876543210" {
		fmt.Printf("test2: bad defer result (should be 9876543210): %q\n", result)
		panic("defer")
	}
}

func main() {
	test1()
	test2()
}
                                                                                                                                                     usr/local/go/test/deferfin.go                                                                       0100644 0000000 0000000 00000002174 13020111414 014634  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that defers do not prevent garbage collection.

package main

import (
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

var sink func()

func main() {
	// Does not work on 32-bits due to partially conservative GC.
	// Try to enable when we have fully precise GC.
	if runtime.GOARCH != "amd64" {
		return
	}
	// Likewise for gccgo.
	if runtime.Compiler == "gccgo" {
		return
	}
	N := 10
	count := int32(N)
	var wg sync.WaitGroup
	wg.Add(N)
	for i := 0; i < N; i++ {
		go func() {
			defer wg.Done()
			v := new(string)
			f := func() {
				if *v != "" {
					panic("oops")
				}
			}
			if *v != "" {
				// let the compiler think f escapes
				sink = f
			}
			runtime.SetFinalizer(v, func(p *string) {
				atomic.AddInt32(&count, -1)
			})
			defer f()
		}()
	}
	wg.Wait()
	for i := 0; i < 3; i++ {
		time.Sleep(10 * time.Millisecond)
		runtime.GC()
	}
	if count != 0 {
		println(count, "out of", N, "finalizer are not called")
		panic("not all finalizers are called")
	}
}

                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/deferprint.go                                                                     0100644 0000000 0000000 00000001116 13020111414 015207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // cmpout

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that we can defer the predeclared functions print and println.

package main

func main() {
	defer println(42, true, false, true, 1.5, "world", (chan int)(nil), []int(nil), (map[string]int)(nil), (func())(nil), byte(255))
	defer println(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)
	// Disabled so the test doesn't crash but left here for reference.
	// defer panic("dead")
	defer print("printing: ")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/test/deferprint.out                                                                    0100644 0000000 0000000 00000000176 13020111414 015416  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        printing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
42 true false true +1.500000e+000 world 0x0 [0/0]0x0 0x0 0x0 255
                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/test/divide.go                                                                         0100644 0000000 0000000 00000002342 13020111414 014313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test divide corner cases.

package main

import "fmt"

func f8(x, y, q, r int8) {
	if t := x / y; t != q {
		fmt.Printf("%d/%d = %d, want %d\n", x, y, t, q)
		panic("divide")
	}
	if t := x % y; t != r {
		fmt.Printf("%d%%%d = %d, want %d\n", x, y, t, r)
		panic("divide")
	}
}

func f16(x, y, q, r int16) {
	if t := x / y; t != q {
		fmt.Printf("%d/%d = %d, want %d\n", x, y, t, q)
		panic("divide")
	}
	if t := x % y; t != r {
		fmt.Printf("%d%%%d = %d, want %d\n", x, y, t, r)
		panic("divide")
	}
}

func f32(x, y, q, r int32) {
	if t := x / y; t != q {
		fmt.Printf("%d/%d = %d, want %d\n", x, y, t, q)
		panic("divide")
	}
	if t := x % y; t != r {
		fmt.Printf("%d%%%d = %d, want %d\n", x, y, t, r)
		panic("divide")
	}
}

func f64(x, y, q, r int64) {
	if t := x / y; t != q {
		fmt.Printf("%d/%d = %d, want %d\n", x, y, t, q)
		panic("divide")
	}
	if t := x % y; t != r {
		fmt.Printf("%d%%%d = %d, want %d\n", x, y, t, r)
		panic("divide")
	}
}

func main() {
	f8(-1<<7, -1, -1<<7, 0)
	f16(-1<<15, -1, -1<<15, 0)
	f32(-1<<31, -1, -1<<31, 0)
	f64(-1<<63, -1, -1<<63, 0)
}
                                                                                                                                                                                                                                                                                              usr/local/go/test/divmod.go                                                                         0100644 0000000 0000000 00000022436 13020111414 014337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test division of variables. Generate many test cases,
// compute correct answer using shift and subtract,
// and then compare against results from division and
// modulus operators.
//
// Primarily useful for testing software div/mod.

package main

const long = false

func main() {
	if long {
		// About 3e9 test cases (calls to checkdiv3).
		// Too long for everyday testing.
		gen2(3, 64, 2, 64, checkdiv1)
		println(ntest)
	} else {
		// About 4e6 test cases (calls to checkdiv3).
		// Runs for 8 seconds on ARM chromebook, much faster elsewhere.
		gen2(2, 64, 1, 64, checkdiv1)
	}
}

// generate all uint64 values x where x has at most n bits set in the low w
// and call f(x) for each.
func gen1(n, w int, f func(uint64)) {
	gen(0, 0, n, w-1, f)
}

func gen(val uint64, nbits, maxbits, pos int, f func(uint64)) {
	if pos < 0 {
		f(val)
		return
	}
	gen(val, nbits, maxbits, pos-1, f)
	if nbits < maxbits {
		gen(val|1<<uint(pos), nbits+1, maxbits, pos-1, f)
	}
}

// generate all uint64 values x, y where x has at most n1 bits set in the low w1
// and y has at most n2 bits set in the low w2 and call f(x, y) for each.
func gen2(n1, w1, n2, w2 int, f func(uint64, uint64)) {
	gen1(n1, w1, func(x uint64) {
		gen1(n2, w2, func(y uint64) {
			f(x, y)
		})
	})
}

// x and y are uint64s with at most 2 bits set.
// Check those values and values above and below,
// along with bitwise inversions of the same (done in checkdiv2).
func checkdiv1(x, y uint64) {
	checkdiv2(x, y)
	// If the low bit is set in x or y, adding or subtracting 1
	// produces a number that checkdiv1 is going to be called
	// with anyway, so don't duplicate effort.
	if x&1 == 0 {
		checkdiv2(x+1, y)
		checkdiv2(x-1, y)
	}
	if y&1 == 0 {
		checkdiv2(x, y-1)
		checkdiv2(x, y+1)
		if x&1 == 0 {
			checkdiv2(x+1, y-1)
			checkdiv2(x-1, y-1)
			checkdiv2(x-1, y+1)
			checkdiv2(x+1, y+1)
		}
	}
}

func checkdiv2(x, y uint64) {
	checkdiv3(x, y)
	checkdiv3(^x, y)
	checkdiv3(x, ^y)
	checkdiv3(^x, ^y)
}

var ntest int64 = 0

func checkdiv3(x, y uint64) {
	ntest++
	if ntest&(ntest-1) == 0 && long {
		println(ntest, "...")
	}
	checkuint64(x, y)
	if (uint64(uint32(x)) == x || uint64(uint32(^x)) == ^x) && (uint64(uint32(y)) == y || uint64(uint32(^y)) == ^y) {
		checkuint32(uint32(x), uint32(y))
	}
	if (uint64(uint16(x)) == x || uint64(uint16(^x)) == ^x) && (uint64(uint16(y)) == y || uint64(uint16(^y)) == ^y) {
		checkuint16(uint16(x), uint16(y))
	}
	if (uint64(uint8(x)) == x || uint64(uint8(^x)) == ^x) && (uint64(uint8(y)) == y || uint64(uint8(^y)) == ^y) {
		checkuint8(uint8(x), uint8(y))
	}
	
	
	sx := int64(x)
	sy := int64(y)
	checkint64(sx, sy)
	if (int64(int32(sx)) == sx || int64(int32(^sx)) == ^sx) && (int64(int32(sy)) == sy || int64(int32(^sy)) == ^sy) {
		checkint32(int32(sx), int32(sy))
	}
	if (int64(int16(sx)) == sx || int64(int16(^sx)) == ^sx) && (int64(int16(sy)) == sy || int64(int16(^sy)) == ^sy) {
		checkint16(int16(sx), int16(sy))
	}
	if (int64(int8(sx)) == sx || int64(int8(^sx)) == ^sx) && (int64(int8(sy)) == sy || int64(int8(^sy)) == ^sy) {
		checkint8(int8(sx), int8(sy))
	}
}

// Check result of x/y, x%y for various types.

func checkuint(x, y uint) {
	if y == 0 {
		divzerouint(x, y)
		modzerouint(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint(q) {
		print("uint(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint(r) {
		print("uint(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint64(x, y uint64) {
	if y == 0 {
		divzerouint64(x, y)
		modzerouint64(x, y)
		return
	}
	q, r := udiv(x, y)
	q1 := x/y
	r1 := x%y
	if q1 != q {
		print("uint64(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != r {
		print("uint64(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint32(x, y uint32) {
	if y == 0 {
		divzerouint32(x, y)
		modzerouint32(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint32(q) {
		print("uint32(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint32(r) {
		print("uint32(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint16(x, y uint16) {
	if y == 0 {
		divzerouint16(x, y)
		modzerouint16(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint16(q) {
		print("uint16(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint16(r) {
		print("uint16(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint8(x, y uint8) {
	if y == 0 {
		divzerouint8(x, y)
		modzerouint8(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint8(q) {
		print("uint8(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint8(r) {
		print("uint8(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint(x, y int) {
	if y == 0 {
		divzeroint(x, y)
		modzeroint(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int(q) {
		print("int(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int(r) {
		print("int(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint64(x, y int64) {
	if y == 0 {
		divzeroint64(x, y)
		modzeroint64(x, y)
		return
	}
	q, r := idiv(x, y)
	q1 := x/y
	r1 := x%y
	if q1 != q {
		print("int64(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != r {
		print("int64(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint32(x, y int32) {
	if y == 0 {
		divzeroint32(x, y)
		modzeroint32(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int32(q) {
		print("int32(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int32(r) {
		print("int32(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint16(x, y int16) {
	if y == 0 {
		divzeroint16(x, y)
		modzeroint16(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int16(q) {
		print("int16(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int16(r) {
		print("int16(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint8(x, y int8) {
	if y == 0 {
		divzeroint8(x, y)
		modzeroint8(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int8(q) {
		print("int8(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int8(r) {
		print("int8(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func divzerouint(x, y uint) uint {
	defer checkudivzero("uint", uint64(x))
	return x / y
}

func divzerouint64(x, y uint64) uint64 {
	defer checkudivzero("uint64", uint64(x))
	return x / y
}

func divzerouint32(x, y uint32) uint32 {
	defer checkudivzero("uint32", uint64(x))
	return x / y
}

func divzerouint16(x, y uint16) uint16 {
	defer checkudivzero("uint16", uint64(x))
	return x / y
}

func divzerouint8(x, y uint8) uint8 {
	defer checkudivzero("uint8", uint64(x))
	return x / y
}

func checkudivzero(typ string, x uint64) {
	if recover() == nil {
		print(typ, "(", x, " / 0) did not panic")
	}
}

func divzeroint(x, y int) int {
	defer checkdivzero("int", int64(x))
	return x / y
}

func divzeroint64(x, y int64) int64 {
	defer checkdivzero("int64", int64(x))
	return x / y
}

func divzeroint32(x, y int32) int32 {
	defer checkdivzero("int32", int64(x))
	return x / y
}

func divzeroint16(x, y int16) int16 {
	defer checkdivzero("int16", int64(x))
	return x / y
}

func divzeroint8(x, y int8) int8 {
	defer checkdivzero("int8", int64(x))
	return x / y
}

func checkdivzero(typ string, x int64) {
	if recover() == nil {
		print(typ, "(", x, " / 0) did not panic")
	}
}

func modzerouint(x, y uint) uint {
	defer checkumodzero("uint", uint64(x))
	return x % y
}

func modzerouint64(x, y uint64) uint64 {
	defer checkumodzero("uint64", uint64(x))
	return x % y
}

func modzerouint32(x, y uint32) uint32 {
	defer checkumodzero("uint32", uint64(x))
	return x % y
}

func modzerouint16(x, y uint16) uint16 {
	defer checkumodzero("uint16", uint64(x))
	return x % y
}

func modzerouint8(x, y uint8) uint8 {
	defer checkumodzero("uint8", uint64(x))
	return x % y
}

func checkumodzero(typ string, x uint64) {
	if recover() == nil {
		print(typ, "(", x, " % 0) did not panic")
	}
}

func modzeroint(x, y int) int {
	defer checkmodzero("int", int64(x))
	return x % y
}

func modzeroint64(x, y int64) int64 {
	defer checkmodzero("int64", int64(x))
	return x % y
}

func modzeroint32(x, y int32) int32 {
	defer checkmodzero("int32", int64(x))
	return x % y
}

func modzeroint16(x, y int16) int16 {
	defer checkmodzero("int16", int64(x))
	return x % y
}

func modzeroint8(x, y int8) int8 {
	defer checkmodzero("int8", int64(x))
	return x % y
}

func checkmodzero(typ string, x int64) {
	if recover() == nil {
		print(typ, "(", x, " % 0) did not panic")
	}
}

// unsigned divide and mod using shift and subtract.
func udiv(x, y uint64) (q, r uint64) {
	sh := 0
	for y+y > y && y+y <= x {
		sh++
		y <<= 1
	}
	for ; sh >= 0; sh-- {
		q <<= 1
		if x >= y {
			x -= y
			q |= 1
		}
		y >>= 1
	}
	return q, x	
}

// signed divide and mod: do unsigned and adjust signs.
func idiv(x, y int64) (q, r int64) {
	// special case for minint / -1 = minint
	if x-1 > x && y == -1 {
		return x, 0
	}
	ux := uint64(x)
	uy := uint64(y)
	if x < 0 {
		ux = -ux
	}
	if y < 0 {
		uy = -uy
	}
	uq, ur := udiv(ux, uy)
	q = int64(uq)
	r = int64(ur)
	if x < 0 {
		r = -r
	}
	if (x < 0) != (y < 0) {
		q = -q
	}
	return q, r
}
                                                                                                                                                                                                                                  usr/local/go/test/dwarf/                                                                            0040755 0000000 0000000 00000000000 13020111414 013625  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/dwarf/dwarf.dir/                                                                  0040755 0000000 0000000 00000000000 13020111414 015505  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/dwarf/dwarf.dir/main.go                                                           0100644 0000000 0000000 00000000735 13020111414 016762  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // $G $D/$F.go $D/z*.go && $L $F.$A && ./$A.out

// NOTE: This test is not run by 'run.go' and so not run by all.bash.
// To run this test you must use the ./run shell script.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main
func main() {
F1()
F2()
F3()
F4()
F5()
F6()
F7()
F8()
F9()
F10()
F11()
F12()
F13()
F14()
F15()
F16()
F17()
F18()
F19()
F20()
}
                                   usr/local/go/test/dwarf/dwarf.dir/z1.go                                                             0100644 0000000 0000000 00000000053 13020111414 016361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        

//line x1.go:4
package main
func F1() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/go/test/dwarf/dwarf.dir/z10.go                                                            0100644 0000000 0000000 00000000056 13020111414 016444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        


//line x10.go:4
package main
func F10() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/test/dwarf/dwarf.dir/z11.go                                                            0100644 0000000 0000000 00000000054 13020111414 016443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x11.go:4
package main
func F11() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z12.go                                                            0100644 0000000 0000000 00000000054 13020111414 016444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x12.go:4
package main
func F12() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z13.go                                                            0100644 0000000 0000000 00000000054 13020111414 016445  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x13.go:4
package main
func F13() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z14.go                                                            0100644 0000000 0000000 00000000054 13020111414 016446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x14.go:4
package main
func F14() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z15.go                                                            0100644 0000000 0000000 00000000054 13020111414 016447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x15.go:4
package main
func F15() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z16.go                                                            0100644 0000000 0000000 00000000054 13020111414 016450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x16.go:4
package main
func F16() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z17.go                                                            0100644 0000000 0000000 00000000054 13020111414 016451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x17.go:4
package main
func F17() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z18.go                                                            0100644 0000000 0000000 00000000055 13020111414 016453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        

//line x18.go:4
package main
func F18() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/test/dwarf/dwarf.dir/z19.go                                                            0100644 0000000 0000000 00000000054 13020111414 016453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x19.go:4
package main
func F19() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z2.go                                                             0100644 0000000 0000000 00000000052 13020111414 016361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x2.go:4
package main
func F2() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z20.go                                                            0100644 0000000 0000000 00000000054 13020111414 016443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x20.go:4
package main
func F20() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/dwarf.dir/z3.go                                                             0100644 0000000 0000000 00000000052 13020111414 016362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x3.go:4
package main
func F3() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z4.go                                                             0100644 0000000 0000000 00000000052 13020111414 016363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x4.go:4
package main
func F4() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z5.go                                                             0100644 0000000 0000000 00000000052 13020111414 016364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x5.go:4
package main
func F5() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z6.go                                                             0100644 0000000 0000000 00000000052 13020111414 016365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x6.go:4
package main
func F6() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z7.go                                                             0100644 0000000 0000000 00000000052 13020111414 016366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x7.go:4
package main
func F7() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z8.go                                                             0100644 0000000 0000000 00000000052 13020111414 016367  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x8.go:4
package main
func F8() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.dir/z9.go                                                             0100644 0000000 0000000 00000000052 13020111414 016370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
//line x9.go:4
package main
func F9() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/test/dwarf/dwarf.go                                                                    0100644 0000000 0000000 00000000414 13020111414 015253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // rundir

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// See issue 2241 and issue 1878: dwarf include stack size
// issues in linker.

package ignored
                                                                                                                                                                                                                                                    usr/local/go/test/dwarf/linedirectives.go                                                           0100644 0000000 0000000 00000002743 13020111414 017170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//line foo/bar.y:4
package main
//line foo/bar.y:60
func main() { 
//line foo/bar.y:297
	f, l := 0, 0
//line yacctab:1
	f, l = 1, 1
//line yaccpar:1
	f, l = 2, 1
//line foo/bar.y:82
	f, l = 3, 82
//line foo/bar.y:90
	f, l = 3, 90
//line foo/bar.y:92
	f, l = 3, 92
//line foo/bar.y:100
	f, l = 3, 100
//line foo/bar.y:104
	l = 104
//line foo/bar.y:112
	l = 112
//line foo/bar.y:117
	l = 117
//line foo/bar.y:121
	l = 121
//line foo/bar.y:125
	l = 125
//line foo/bar.y:133
	l = 133
//line foo/bar.y:146
	l = 146
//line foo/bar.y:148
//line foo/bar.y:153
//line foo/bar.y:155
	l = 155
//line foo/bar.y:160

//line foo/bar.y:164
//line foo/bar.y:173

//line foo/bar.y:178
//line foo/bar.y:180
//line foo/bar.y:185
//line foo/bar.y:195
//line foo/bar.y:197
//line foo/bar.y:202
//line foo/bar.y:204
//line foo/bar.y:208
//line foo/bar.y:211
//line foo/bar.y:213
//line foo/bar.y:215
//line foo/bar.y:217
//line foo/bar.y:221
//line foo/bar.y:229
//line foo/bar.y:236
//line foo/bar.y:238
//line foo/bar.y:240
//line foo/bar.y:244
//line foo/bar.y:249
//line foo/bar.y:253
//line foo/bar.y:257
//line foo/bar.y:262
//line foo/bar.y:267
//line foo/bar.y:272
	if l == f {
//line foo/bar.y:277
	panic("aie!")
//line foo/bar.y:281
	}
//line foo/bar.y:285
	return
//line foo/bar.y:288
//line foo/bar.y:290
}
//line foo/bar.y:293
//line foo/bar.y:295
                             usr/local/go/test/empty.go                                                                          0100644 0000000 0000000 00000000474 13020111414 014211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // compile

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that top-level parenthesized declarations can be empty.
// Compiles but does not run.

package P

import ( )
const ( )
var ( )
type ( )
                                                                                                                                                                                                    usr/local/go/test/env.go                                                                            0100644 0000000 0000000 00000001111 13020111414 013630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that the Go environment variables are present and accessible through
// package os and package runtime.

package main

import (
	"os"
	"runtime"
)

func main() {
	ga := os.Getenv("GOARCH")
	if ga != runtime.GOARCH {
		print("$GOARCH=", ga, "!= runtime.GOARCH=", runtime.GOARCH, "\n")
		os.Exit(1)
	}
	xxx := os.Getenv("DOES_NOT_EXIST")
	if xxx != "" {
		print("$DOES_NOT_EXIST=", xxx, "\n")
		os.Exit(1)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/go/test/eof.go                                                                            0100644 0000000 0000000 00000000465 13020111414 013624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // compile

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test a source file does not need a final newline.
// Compiles but does not run.

// No newline at the end of this file.

package main                                                                                                                                                                                                           usr/local/go/test/eof1.go                                                                           0100644 0000000 0000000 00000000516 13020111414 013702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // compile

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that a comment ending a source file does not need a final newline.
// Compiles but does not run.

package eof1

// No newline at the end of this comment.                                                                                                                                                                                  usr/local/go/test/errchk                                                                            0100755 0000000 0000000 00000007175 13020111414 013735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env perl
# Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# This script checks that the compilers emit the errors which we expect.
# Usage: errchk COMPILER [OPTS] SOURCEFILES.  This will run the command
# COMPILER [OPTS] SOURCEFILES.  The compilation is expected to fail; if
# it succeeds, this script will report an error.  The stderr output of
# the compiler will be matched against comments in SOURCEFILES.  For each
# line of the source files which should generate an error, there should
# be a comment of the form // ERROR "regexp".  If the compiler generates
# an error for a line which has no such comment, this script will report
# an error.  Likewise if the compiler does not generate an error for a
# line which has a comment, or if the error message does not match the
# <regexp>.  The <regexp> syntax is Perl but its best to stick to egrep.

use POSIX;

my $exitcode = 1;

if(@ARGV >= 1 && $ARGV[0] eq "-0") {
	$exitcode = 0;
	shift;
}

if(@ARGV < 1) {
	print STDERR "Usage: errchk COMPILER [OPTS] SOURCEFILES\n";
	exit 1;
}

# Grab SOURCEFILES
foreach(reverse 0 .. @ARGV-1) {
	unless($ARGV[$_] =~ /\.(go|s)$/) {
		@file = @ARGV[$_+1 .. @ARGV-1];
		last;
	}
}

foreach $file (@file) {
	open(SRC, $file) || die "BUG: errchk: open $file: $!";
	$src{$file} = [<SRC>];
	close(SRC);
}

# Run command
$cmd = join(' ', @ARGV);
open(CMD, "exec $cmd </dev/null 2>&1 |") || die "BUG: errchk: run $cmd: $!";

# gc error messages continue onto additional lines with leading tabs.
# Split the output at the beginning of each line that doesn't begin with a tab.
$out = join('', <CMD>);
@out = split(/^(?!\t)/m, $out);

close CMD;

if($exitcode != 0 && $? == 0) {
	print STDERR "BUG: errchk: command succeeded unexpectedly\n";
	print STDERR @out;
	exit 0;
}

if($exitcode == 0 && $? != 0) {
	print STDERR "BUG: errchk: command failed unexpectedly\n";
	print STDERR @out;
	exit 0;
}

if(!WIFEXITED($?)) {
	print STDERR "BUG: errchk: compiler crashed\n";
	print STDERR @out, "\n";
	exit 0;
}

sub bug() {
	if(!$bug++) {
		print STDERR "BUG: ";
	}
}

sub chk {
	my $file = shift;
	my $line = 0;
	my $regexp;
	my @errmsg;
	my @match;
	foreach my $src (@{$src{$file}}) {
		$line++;
		next if $src =~ m|////|;  # double comment disables ERROR
		next unless $src =~ m|// (GC_)?ERROR (.*)|;
		my $all = $2;
		if($all !~ /^"([^"]*)"/) {
			print STDERR "$file:$line: malformed regexp\n";
			next;
		}
		@errmsg = grep { /$file:$line[:[]/ } @out;
		@out = grep { !/$file:$line[:[]/ } @out;
		if(@errmsg == 0) {
			bug();
			print STDERR "errchk: $file:$line: missing expected error: '$all'\n";
			next;
		}
		foreach my $regexp ($all =~ /"([^"]*)"/g) {
			# Turn relative line number in message into absolute line number.
			if($regexp =~ /LINE(([+-])([0-9]+))?/) {
				my $n = $line;
				if(defined($1)) {
					if($2 eq "+") {
						$n += int($3);
					} else {
						$n -= int($3);
					}
				}
				$regexp = "$`$file:$n$'";
			}
	
			@match = grep { /$regexp/ } @errmsg;
			if(@match == 0) {
				bug();
				print STDERR "errchk: $file:$line: error messages do not match '$regexp'\n";
				next;
			}
			@errmsg = grep { !/$regexp/ } @errmsg;
		}
		if(@errmsg != 0) {
			bug();
			print STDERR "errchk: $file:$line: unmatched error messages:\n";
			foreach my $l (@errmsg) {
				print STDERR "> $l";
			}
		}
	}
}

foreach $file (@file) {
	chk($file)
}

if(@out != 0) {
	bug();
	print STDERR "errchk: unmatched error messages:\n";
	print STDERR "==================================================\n";
	print STDERR @out;
	print STDERR "==================================================\n";
}

exit 0;
                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/test/escape.go                                                                         0100644 0000000 0000000 00000007450 13020111414 014314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// Test for correct heap-moving of escaped variables.
// It is hard to check for the allocations, but it is easy
// to check that if you call the function twice at the
// same stack level, the pointers returned should be
// different.

var bad = false

var allptr = make([]*int, 0, 100)

func noalias(p, q *int, s string) {
	n := len(allptr)
	*p = -(n + 1)
	*q = -(n + 2)
	allptr = allptr[0 : n+2]
	allptr[n] = p
	allptr[n+1] = q
	n += 2
	for i := 0; i < n; i++ {
		if allptr[i] != nil && *allptr[i] != -(i+1) {
			println("aliased pointers", -(i + 1), *allptr[i], "after", s)
			allptr[i] = nil
			bad = true
		}
	}
}

func val(p, q *int, v int, s string) {
	if *p != v {
		println("wrong value want", v, "got", *p, "after", s)
		bad = true
	}
	if *q != v+1 {
		println("wrong value want", v+1, "got", *q, "after", s)
		bad = true
	}
}

func chk(p, q *int, v int, s string) {
	val(p, q, v, s)
	noalias(p, q, s)
}

func chkalias(p, q *int, v int, s string) {
	if p != q {
		println("want aliased pointers but got different after", s)
		bad = true
	}
	if *q != v+1 {
		println("wrong value want", v+1, "got", *q, "after", s)
		bad = true
	}
}

func i_escapes(x int) *int {
	var i int
	i = x
	return &i
}

func j_escapes(x int) *int {
	var j int = x
	j = x
	return &j
}

func k_escapes(x int) *int {
	k := x
	return &k
}

func in_escapes(x int) *int {
	return &x
}

func send(c chan int, x int) {
	c <- x
}

func select_escapes(x int) *int {
	c := make(chan int)
	go send(c, x)
	select {
	case req := <-c:
		return &req
	}
	return nil
}

func select_escapes1(x int, y int) (*int, *int) {
	c := make(chan int)
	var a [2]int
	var p [2]*int
	a[0] = x
	a[1] = y
	for i := 0; i < 2; i++ {
		go send(c, a[i])
		select {
		case req := <-c:
			p[i] = &req
		}
	}
	return p[0], p[1]
}

func range_escapes(x int) *int {
	var a [1]int
	a[0] = x
	for _, v := range a {
		return &v
	}
	return nil
}

// *is* aliased
func range_escapes2(x, y int) (*int, *int) {
	var a [2]int
	var p [2]*int
	a[0] = x
	a[1] = y
	for k, v := range a {
		p[k] = &v
	}
	return p[0], p[1]
}

// *is* aliased
func for_escapes2(x int, y int) (*int, *int) {
	var p [2]*int
	n := 0
	for i := x; n < 2; i = y {
		p[n] = &i
		n++
	}
	return p[0], p[1]
}

func for_escapes3(x int, y int) (*int, *int) {
	var f [2]func() *int
	n := 0
	for i := x; n < 2; i = y {
		p := new(int)
		*p = i
		f[n] = func() *int { return p }
		n++
	}
	return f[0](), f[1]()
}

func out_escapes(i int) (x int, p *int) {
	x = i
	p = &x // ERROR "address of out parameter"
	return
}

func out_escapes_2(i int) (x int, p *int) {
	x = i
	return x, &x // ERROR "address of out parameter"
}

func defer1(i int) (x int) {
	c := make(chan int)
	go func() { x = i; c <- 1 }()
	<-c
	return
}

func main() {
	p, q := i_escapes(1), i_escapes(2)
	chk(p, q, 1, "i_escapes")

	p, q = j_escapes(3), j_escapes(4)
	chk(p, q, 3, "j_escapes")

	p, q = k_escapes(5), k_escapes(6)
	chk(p, q, 5, "k_escapes")

	p, q = in_escapes(7), in_escapes(8)
	chk(p, q, 7, "in_escapes")

	p, q = select_escapes(9), select_escapes(10)
	chk(p, q, 9, "select_escapes")

	p, q = select_escapes1(11, 12)
	chk(p, q, 11, "select_escapes1")

	p, q = range_escapes(13), range_escapes(14)
	chk(p, q, 13, "range_escapes")

	p, q = range_escapes2(101, 102)
	chkalias(p, q, 101, "range_escapes2")

	p, q = for_escapes2(103, 104)
	chkalias(p, q, 103, "for_escapes2")

	p, q = for_escapes3(105, 106)
	chk(p, q, 105, "for_escapes3")

	_, p = out_escapes(15)
	_, q = out_escapes(16)
	chk(p, q, 15, "out_escapes")

	_, p = out_escapes_2(17)
	_, q = out_escapes_2(18)
	chk(p, q, 17, "out_escapes_2")

	x := defer1(20)
	if x != 20 {
		println("defer failed", x)
		bad = true
	}

	if bad {
		panic("BUG: no escape")
	}
}
                                                                                                                                                                                                                        usr/local/go/test/escape2.go                                                                        0100644 0000000 0000000 00000120251 13020111414 014371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test, using compiler diagnostic flags, that the escape analysis is working.
// Compiles but does not run.  Inlining is disabled.

// escape2n.go contains all the same tests but compiles with -N.

package foo

import (
	"fmt"
	"unsafe"
)

var gxx *int

func foo1(x int) { // ERROR "moved to heap: x$"
	gxx = &x // ERROR "&x escapes to heap$"
}

func foo2(yy *int) { // ERROR "leaking param: yy$"
	gxx = yy
}

func foo3(x int) *int { // ERROR "moved to heap: x$"
	return &x // ERROR "&x escapes to heap$"
}

type T *T

func foo3b(t T) { // ERROR "leaking param: t$"
	*t = t
}

// xx isn't going anywhere, so use of yy is ok
func foo4(xx, yy *int) { // ERROR "foo4 xx does not escape$" "foo4 yy does not escape$"
	xx = yy
}

// xx isn't going anywhere, so taking address of yy is ok
func foo5(xx **int, yy *int) { // ERROR "foo5 xx does not escape$" "foo5 yy does not escape$"
	xx = &yy // ERROR "foo5 &yy does not escape$"
}

func foo6(xx **int, yy *int) { // ERROR "foo6 xx does not escape$" "leaking param: yy$"
	*xx = yy
}

func foo7(xx **int, yy *int) { // ERROR "foo7 xx does not escape$" "foo7 yy does not escape$"
	**xx = *yy
}

func foo8(xx, yy *int) int { // ERROR "foo8 xx does not escape$" "foo8 yy does not escape$"
	xx = yy
	return *xx
}

func foo9(xx, yy *int) *int { // ERROR "leaking param: xx to result ~r2 level=0$" "leaking param: yy to result ~r2 level=0$"
	xx = yy
	return xx
}

func foo10(xx, yy *int) { // ERROR "foo10 xx does not escape$" "foo10 yy does not escape$"
	*xx = *yy
}

func foo11() int {
	x, y := 0, 42
	xx := &x // ERROR "foo11 &x does not escape$"
	yy := &y // ERROR "foo11 &y does not escape$"
	*xx = *yy
	return x
}

var xxx **int

func foo12(yyy **int) { // ERROR "leaking param: yyy$"
	xxx = yyy
}

// Must treat yyy as leaking because *yyy leaks, and the escape analysis
// summaries in exported metadata do not distinguish these two cases.
func foo13(yyy **int) { // ERROR "leaking param content: yyy$"
	*xxx = *yyy
}

func foo14(yyy **int) { // ERROR "foo14 yyy does not escape$"
	**xxx = **yyy
}

func foo15(yy *int) { // ERROR "moved to heap: yy$"
	xxx = &yy // ERROR "&yy escapes to heap$"
}

func foo16(yy *int) { // ERROR "leaking param: yy$"
	*xxx = yy
}

func foo17(yy *int) { // ERROR "foo17 yy does not escape$"
	**xxx = *yy
}

func foo18(y int) { // ERROR "moved to heap: y$"
	*xxx = &y // ERROR "&y escapes to heap$"
}

func foo19(y int) {
	**xxx = y
}

type Bar struct {
	i  int
	ii *int
}

func NewBar() *Bar {
	return &Bar{42, nil} // ERROR "&Bar literal escapes to heap$"
}

func NewBarp(x *int) *Bar { // ERROR "leaking param: x to result ~r1 level=-1$"
	return &Bar{42, x} // ERROR "&Bar literal escapes to heap$"
}

func NewBarp2(x *int) *Bar { // ERROR "NewBarp2 x does not escape$"
	return &Bar{*x, nil} // ERROR "&Bar literal escapes to heap$"
}

func (b *Bar) NoLeak() int { // ERROR "\(\*Bar\).NoLeak b does not escape$"
	return *(b.ii)
}

func (b *Bar) Leak() *int { // ERROR "leaking param: b to result ~r0 level=0$"
	return &b.i // ERROR "&b.i escapes to heap$"
}

func (b *Bar) AlsoNoLeak() *int { // ERROR "leaking param: b to result ~r0 level=1$"
	return b.ii
}

func (b Bar) AlsoLeak() *int { // ERROR "leaking param: b to result ~r0 level=0$"
	return b.ii
}

func (b Bar) LeaksToo() *int { // ERROR "leaking param: b to result ~r0 level=0$"
	v := 0    // ERROR "moved to heap: v$"
	b.ii = &v // ERROR "&v escapes to heap$"
	return b.ii
}

func (b *Bar) LeaksABit() *int { // ERROR "leaking param: b to result ~r0 level=1$"
	v := 0    // ERROR "moved to heap: v$"
	b.ii = &v // ERROR "&v escapes to heap$"
	return b.ii
}

func (b Bar) StillNoLeak() int { // ERROR "Bar.StillNoLeak b does not escape$"
	v := 0
	b.ii = &v // ERROR "Bar.StillNoLeak &v does not escape$"
	return b.i
}

func goLeak(b *Bar) { // ERROR "leaking param: b$"
	go b.NoLeak()
}

type Bar2 struct {
	i  [12]int
	ii []int
}

func NewBar2() *Bar2 {
	return &Bar2{[12]int{42}, nil} // ERROR "&Bar2 literal escapes to heap$"
}

func (b *Bar2) NoLeak() int { // ERROR "\(\*Bar2\).NoLeak b does not escape$"
	return b.i[0]
}

func (b *Bar2) Leak() []int { // ERROR "leaking param: b to result ~r0 level=0$"
	return b.i[:] // ERROR "b.i escapes to heap$"
}

func (b *Bar2) AlsoNoLeak() []int { // ERROR "leaking param: b to result ~r0 level=1$"
	return b.ii[0:1]
}

func (b Bar2) AgainNoLeak() [12]int { // ERROR "Bar2.AgainNoLeak b does not escape$"
	return b.i
}

func (b *Bar2) LeakSelf() { // ERROR "leaking param: b$"
	b.ii = b.i[0:4] // ERROR "b.i escapes to heap$"
}

func (b *Bar2) LeakSelf2() { // ERROR "leaking param: b$"
	var buf []int
	buf = b.i[0:] // ERROR "b.i escapes to heap$"
	b.ii = buf
}

func foo21() func() int {
	x := 42
	return func() int { // ERROR "func literal escapes to heap$"
		return x
	}
}

func foo21a() func() int {
	x := 42             // ERROR "moved to heap: x$"
	return func() int { // ERROR "func literal escapes to heap$"
		x++ // ERROR "&x escapes to heap$"
		return x
	}
}

func foo22() int {
	x := 42
	return func() int { // ERROR "foo22 func literal does not escape$"
		return x
	}()
}

func foo23(x int) func() int {
	return func() int { // ERROR "func literal escapes to heap$"
		return x
	}
}

func foo23a(x int) func() int {
	f := func() int { // ERROR "func literal escapes to heap$"
		return x
	}
	return f
}

func foo23b(x int) *(func() int) {
	f := func() int { return x } // ERROR "func literal escapes to heap$" "moved to heap: f$"
	return &f                    // ERROR "&f escapes to heap$"
}

func foo23c(x int) func() int { // ERROR "moved to heap: x$"
	return func() int { // ERROR "func literal escapes to heap$"
		x++ // ERROR "&x escapes to heap$"
		return x
	}
}

func foo24(x int) int {
	return func() int { // ERROR "foo24 func literal does not escape$"
		return x
	}()
}

var x *int

func fooleak(xx *int) int { // ERROR "leaking param: xx$"
	x = xx
	return *x
}

func foonoleak(xx *int) int { // ERROR "foonoleak xx does not escape$"
	return *x + *xx
}

func foo31(x int) int { // ERROR "moved to heap: x$"
	return fooleak(&x) // ERROR "&x escapes to heap$"
}

func foo32(x int) int {
	return foonoleak(&x) // ERROR "foo32 &x does not escape$"
}

type Foo struct {
	xx *int
	x  int
}

var F Foo
var pf *Foo

func (f *Foo) fooleak() { // ERROR "leaking param: f$"
	pf = f
}

func (f *Foo) foonoleak() { // ERROR "\(\*Foo\).foonoleak f does not escape$"
	F.x = f.x
}

func (f *Foo) Leak() { // ERROR "leaking param: f$"
	f.fooleak()
}

func (f *Foo) NoLeak() { // ERROR "\(\*Foo\).NoLeak f does not escape$"
	f.foonoleak()
}

func foo41(x int) { // ERROR "moved to heap: x$"
	F.xx = &x // ERROR "&x escapes to heap$"
}

func (f *Foo) foo42(x int) { // ERROR "\(\*Foo\).foo42 f does not escape$" "moved to heap: x$"
	f.xx = &x // ERROR "&x escapes to heap$"
}

func foo43(f *Foo, x int) { // ERROR "foo43 f does not escape$" "moved to heap: x$"
	f.xx = &x // ERROR "&x escapes to heap$"
}

func foo44(yy *int) { // ERROR "leaking param: yy$"
	F.xx = yy
}

func (f *Foo) foo45() { // ERROR "\(\*Foo\).foo45 f does not escape$"
	F.x = f.x
}

// See foo13 above for explanation of why f leaks.
func (f *Foo) foo46() { // ERROR "leaking param content: f$"
	F.xx = f.xx
}

func (f *Foo) foo47() { // ERROR "leaking param: f$"
	f.xx = &f.x // ERROR "&f.x escapes to heap$"
}

var ptrSlice []*int

func foo50(i *int) { // ERROR "leaking param: i$"
	ptrSlice[0] = i
}

var ptrMap map[*int]*int

func foo51(i *int) { // ERROR "leaking param: i$"
	ptrMap[i] = i
}

func indaddr1(x int) *int { // ERROR "moved to heap: x$"
	return &x // ERROR "&x escapes to heap$"
}

func indaddr2(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	return *&x // ERROR "indaddr2 &x does not escape$"
}

func indaddr3(x *int32) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	return *(**int)(unsafe.Pointer(&x)) // ERROR "indaddr3 &x does not escape$"
}

// From package math:

func Float32bits(f float32) uint32 {
	return *(*uint32)(unsafe.Pointer(&f)) // ERROR "Float32bits &f does not escape$"
}

func Float32frombits(b uint32) float32 {
	return *(*float32)(unsafe.Pointer(&b)) // ERROR "Float32frombits &b does not escape$"
}

func Float64bits(f float64) uint64 {
	return *(*uint64)(unsafe.Pointer(&f)) // ERROR "Float64bits &f does not escape$"
}

func Float64frombits(b uint64) float64 {
	return *(*float64)(unsafe.Pointer(&b)) // ERROR "Float64frombits &b does not escape$"
}

// contrast with
func float64bitsptr(f float64) *uint64 { // ERROR "moved to heap: f$"
	return (*uint64)(unsafe.Pointer(&f)) // ERROR "&f escapes to heap$"
}

func float64ptrbitsptr(f *float64) *uint64 { // ERROR "leaking param: f to result ~r1 level=0$"
	return (*uint64)(unsafe.Pointer(f))
}

func typesw(i interface{}) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	switch val := i.(type) {
	case *int:
		return val
	case *int8:
		v := int(*val) // ERROR "moved to heap: v$"
		return &v      // ERROR "&v escapes to heap$"
	}
	return nil
}

func exprsw(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	switch j := i; *j + 110 {
	case 12:
		return j
	case 42:
		return nil
	}
	return nil

}

// assigning to an array element is like assigning to the array
func foo60(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	var a [12]*int
	a[0] = i
	return a[1]
}

func foo60a(i *int) *int { // ERROR "foo60a i does not escape$"
	var a [12]*int
	a[0] = i
	return nil
}

// assigning to a struct field  is like assigning to the struct
func foo61(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	type S struct {
		a, b *int
	}
	var s S
	s.a = i
	return s.b
}

func foo61a(i *int) *int { // ERROR "foo61a i does not escape$"
	type S struct {
		a, b *int
	}
	var s S
	s.a = i
	return nil
}

// assigning to a struct field is like assigning to the struct but
// here this subtlety is lost, since s.a counts as an assignment to a
// track-losing dereference.
func foo62(i *int) *int { // ERROR "leaking param: i$"
	type S struct {
		a, b *int
	}
	s := new(S) // ERROR "foo62 new\(S\) does not escape$"
	s.a = i
	return nil // s.b
}

type M interface {
	M()
}

func foo63(m M) { // ERROR "foo63 m does not escape$"
}

func foo64(m M) { // ERROR "leaking param: m$"
	m.M()
}

func foo64b(m M) { // ERROR "leaking param: m$"
	defer m.M()
}

type MV int

func (MV) M() {}

func foo65() {
	var mv MV
	foo63(&mv) // ERROR "foo65 &mv does not escape$"
}

func foo66() {
	var mv MV  // ERROR "moved to heap: mv$"
	foo64(&mv) // ERROR "&mv escapes to heap$"
}

func foo67() {
	var mv MV
	foo63(mv) // ERROR "foo67 mv does not escape$"
}

func foo68() {
	var mv MV
	// escapes but it's an int so irrelevant
	foo64(mv) // ERROR "mv escapes to heap$"
}

func foo69(m M) { // ERROR "leaking param: m$"
	foo64(m)
}

func foo70(mv1 *MV, m M) { // ERROR "leaking param: m$" "leaking param: mv1$"
	m = mv1 // ERROR "mv1 escapes to heap$"
	foo64(m)
}

func foo71(x *int) []*int { // ERROR "leaking param: x$"
	var y []*int
	y = append(y, x)
	return y
}

func foo71a(x int) []*int { // ERROR "moved to heap: x$"
	var y []*int
	y = append(y, &x) // ERROR "&x escapes to heap$"
	return y
}

func foo72() {
	var x int
	var y [1]*int
	y[0] = &x // ERROR "foo72 &x does not escape$"
}

func foo72aa() [10]*int {
	var x int // ERROR "moved to heap: x$"
	var y [10]*int
	y[0] = &x // ERROR "&x escapes to heap$"
	return y
}

func foo72a() {
	var y [10]*int
	for i := 0; i < 10; i++ {
		// escapes its scope
		x := i    // ERROR "moved to heap: x$"
		y[i] = &x // ERROR "&x escapes to heap$"
	}
	return
}

func foo72b() [10]*int {
	var y [10]*int
	for i := 0; i < 10; i++ {
		x := i    // ERROR "moved to heap: x$"
		y[i] = &x // ERROR "&x escapes to heap$"
	}
	return y
}

// issue 2145
func foo73() {
	s := []int{3, 2, 1} // ERROR "foo73 \[\]int literal does not escape$"
	for _, v := range s {
		vv := v
		// actually just escapes its scope
		defer func() { // ERROR "func literal escapes to heap$"
			println(vv)
		}()
	}
}

func foo731() {
	s := []int{3, 2, 1} // ERROR "foo731 \[\]int literal does not escape$"
	for _, v := range s {
		vv := v // ERROR "moved to heap: vv$"
		// actually just escapes its scope
		defer func() { // ERROR "func literal escapes to heap$"
			vv = 42 // ERROR "&vv escapes to heap$"
			println(vv)
		}()
	}
}

func foo74() {
	s := []int{3, 2, 1} // ERROR "foo74 \[\]int literal does not escape$"
	for _, v := range s {
		vv := v
		// actually just escapes its scope
		fn := func() { // ERROR "func literal escapes to heap$"
			println(vv)
		}
		defer fn()
	}
}

func foo74a() {
	s := []int{3, 2, 1} // ERROR "foo74a \[\]int literal does not escape$"
	for _, v := range s {
		vv := v // ERROR "moved to heap: vv$"
		// actually just escapes its scope
		fn := func() { // ERROR "func literal escapes to heap$"
			vv += 1 // ERROR "&vv escapes to heap$"
			println(vv)
		}
		defer fn()
	}
}

// issue 3975
func foo74b() {
	var array [3]func()
	s := []int{3, 2, 1} // ERROR "foo74b \[\]int literal does not escape$"
	for i, v := range s {
		vv := v
		// actually just escapes its scope
		array[i] = func() { // ERROR "func literal escapes to heap$"
			println(vv)
		}
	}
}

func foo74c() {
	var array [3]func()
	s := []int{3, 2, 1} // ERROR "foo74c \[\]int literal does not escape$"
	for i, v := range s {
		vv := v // ERROR "moved to heap: vv$"
		// actually just escapes its scope
		array[i] = func() { // ERROR "func literal escapes to heap$"
			println(&vv) // ERROR "&vv escapes to heap$" "foo74c.func1 &vv does not escape$"
		}
	}
}

func myprint(y *int, x ...interface{}) *int { // ERROR "leaking param: y to result ~r2 level=0$" "myprint x does not escape$"
	return y
}

func myprint1(y *int, x ...interface{}) *interface{} { // ERROR "leaking param: x to result ~r2 level=0$" "myprint1 y does not escape$"
	return &x[0] // ERROR "&x\[0\] escapes to heap$"
}

func foo75(z *int) { // ERROR "foo75 z does not escape$"
	myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75 ... argument does not escape$"
}

func foo75a(z *int) { // ERROR "foo75a z does not escape$"
	myprint1(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75a ... argument does not escape$"
}

func foo75esc(z *int) { // ERROR "leaking param: z$"
	gxx = myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75esc ... argument does not escape$"
}

func foo75aesc(z *int) { // ERROR "foo75aesc z does not escape$"
	var ppi **interface{}       // assignments to pointer dereferences lose track
	*ppi = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
}

func foo75aesc1(z *int) { // ERROR "foo75aesc1 z does not escape$"
	sink = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$" "myprint1\(z, 1, 2, 3\) escapes to heap$"
}

func foo76(z *int) { // ERROR "z does not escape"
	myprint(nil, z) // ERROR "foo76 ... argument does not escape$" "z does not escape"
}

func foo76a(z *int) { // ERROR "z does not escape"
	myprint1(nil, z) // ERROR "foo76a ... argument does not escape$" "z does not escape"
}

func foo76b() {
	myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76b ... argument does not escape$"
}

func foo76c() {
	myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76c ... argument does not escape$"
}

func foo76d() {
	defer myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76d ... argument does not escape$"
}

func foo76e() {
	defer myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76e ... argument does not escape$"
}

func foo76f() {
	for {
		// TODO: This one really only escapes its scope, but we don't distinguish yet.
		defer myprint(nil, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
	}
}

func foo76g() {
	for {
		defer myprint1(nil, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
	}
}

func foo77(z []interface{}) { // ERROR "foo77 z does not escape$"
	myprint(nil, z...) // z does not escape
}

func foo77a(z []interface{}) { // ERROR "foo77a z does not escape$"
	myprint1(nil, z...)
}

func foo77b(z []interface{}) { // ERROR "leaking param: z$"
	var ppi **interface{}
	*ppi = myprint1(nil, z...)
}

func foo77c(z []interface{}) { // ERROR "leaking param: z$"
	sink = myprint1(nil, z...) // ERROR "myprint1\(nil, z...\) escapes to heap$"
}

func dotdotdot() {
	i := 0
	myprint(nil, &i) // ERROR "&i does not escape" "dotdotdot ... argument does not escape$"

	j := 0
	myprint1(nil, &j) // ERROR "&j does not escape" "dotdotdot ... argument does not escape$"
}

func foo78(z int) *int { // ERROR "moved to heap: z$"
	return &z // ERROR "&z escapes to heap$"
}

func foo78a(z int) *int { // ERROR "moved to heap: z$"
	y := &z   // ERROR "&z escapes to heap$"
	x := &y   // ERROR "foo78a &y does not escape$"
	return *x // really return y
}

func foo79() *int {
	return new(int) // ERROR "new\(int\) escapes to heap$"
}

func foo80() *int {
	var z *int
	for {
		// Really just escapes its scope but we don't distinguish
		z = new(int) // ERROR "new\(int\) escapes to heap$"
	}
	_ = z
	return nil
}

func foo81() *int {
	for {
		z := new(int) // ERROR "foo81 new\(int\) does not escape$"
		_ = z
	}
	return nil
}

func tee(p *int) (x, y *int) { return p, p } // ERROR "leaking param: p to result x level=0$" "leaking param: p to result y level=0$"

func noop(x, y *int) {} // ERROR "noop x does not escape$" "noop y does not escape$"

func foo82() {
	var x, y, z int  // ERROR "moved to heap: x$" "moved to heap: y$" "moved to heap: z$"
	go noop(tee(&z)) // ERROR "&z escapes to heap$"
	go noop(&x, &y)  // ERROR "&x escapes to heap$" "&y escapes to heap$"
	for {
		var u, v, w int     // ERROR "moved to heap: u$" "moved to heap: v$" "moved to heap: w$"
		defer noop(tee(&u)) // ERROR "&u escapes to heap$"
		defer noop(&v, &w)  // ERROR "&v escapes to heap$" "&w escapes to heap$"
	}
}

type Fooer interface {
	Foo()
}

type LimitedFooer struct {
	Fooer
	N int64
}

func LimitFooer(r Fooer, n int64) Fooer { // ERROR "leaking param: r to result ~r2 level=-1$"
	return &LimitedFooer{r, n} // ERROR "&LimitedFooer literal escapes to heap$"
}

func foo90(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{nil: x} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo91(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{x: nil} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo92(x *int) [2]*int { // ERROR "leaking param: x to result ~r1 level=0$"
	return [2]*int{x, nil}
}

// does not leak c
func foo93(c chan *int) *int { // ERROR "foo93 c does not escape$"
	for v := range c {
		return v
	}
	return nil
}

// does not leak m
func foo94(m map[*int]*int, b bool) *int { // ERROR "leaking param: m to result ~r2 level=1"
	for k, v := range m {
		if b {
			return k
		}
		return v
	}
	return nil
}

// does leak x
func foo95(m map[*int]*int, x *int) { // ERROR "foo95 m does not escape$" "leaking param: x$"
	m[x] = x
}

// does not leak m but does leak content
func foo96(m []*int) *int { // ERROR "leaking param: m to result ~r1 level=1"
	return m[0]
}

// does leak m
func foo97(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
	return m[0]
}

// does not leak m
func foo98(m map[int]*int) *int { // ERROR "foo98 m does not escape$"
	return m[0]
}

// does leak m
func foo99(m *[1]*int) []*int { // ERROR "leaking param: m to result ~r1 level=0$"
	return m[:]
}

// does not leak m
func foo100(m []*int) *int { // ERROR "leaking param: m to result ~r1 level=1"
	for _, v := range m {
		return v
	}
	return nil
}

// does leak m
func foo101(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
	for _, v := range m {
		return v
	}
	return nil
}

// does not leak m
func foo101a(m [1]*int) *int { // ERROR "foo101a m does not escape$"
	for i := range m { // ERROR "moved to heap: i$"
		return &i // ERROR "&i escapes to heap$"
	}
	return nil
}

// does leak x
func foo102(m []*int, x *int) { // ERROR "foo102 m does not escape$" "leaking param: x$"
	m[0] = x
}

// does not leak x
func foo103(m [1]*int, x *int) { // ERROR "foo103 m does not escape$" "foo103 x does not escape$"
	m[0] = x
}

var y []*int

// does not leak x but does leak content
func foo104(x []*int) { // ERROR "leaking param content: x"
	copy(y, x)
}

// does not leak x but does leak content
func foo105(x []*int) { // ERROR "leaking param content: x"
	_ = append(y, x...)
}

// does leak x
func foo106(x *int) { // ERROR "leaking param: x$"
	_ = append(y, x)
}

func foo107(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{x: nil} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo108(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{nil: x} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo109(x *int) *int { // ERROR "leaking param: x$"
	m := map[*int]*int{x: nil} // ERROR "foo109 map\[\*int\]\*int literal does not escape$"
	for k, _ := range m {
		return k
	}
	return nil
}

func foo110(x *int) *int { // ERROR "leaking param: x$"
	m := map[*int]*int{nil: x} // ERROR "foo110 map\[\*int\]\*int literal does not escape$"
	return m[nil]
}

func foo111(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0"
	m := []*int{x} // ERROR "foo111 \[\]\*int literal does not escape$"
	return m[0]
}

func foo112(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	m := [1]*int{x}
	return m[0]
}

func foo113(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	m := Bar{ii: x}
	return m.ii
}

func foo114(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	m := &Bar{ii: x} // ERROR "foo114 &Bar literal does not escape$"
	return m.ii
}

func foo115(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	return (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + 1))
}

func foo116(b bool) *int {
	if b {
		x := 1    // ERROR "moved to heap: x$"
		return &x // ERROR "&x escapes to heap$"
	} else {
		y := 1    // ERROR "moved to heap: y$"
		return &y // ERROR "&y escapes to heap$"
	}
	return nil
}

func foo117(unknown func(interface{})) { // ERROR "foo117 unknown does not escape$"
	x := 1      // ERROR "moved to heap: x$"
	unknown(&x) // ERROR "&x escapes to heap$"
}

func foo118(unknown func(*int)) { // ERROR "foo118 unknown does not escape$"
	x := 1      // ERROR "moved to heap: x$"
	unknown(&x) // ERROR "&x escapes to heap$"
}

func external(*int)

func foo119(x *int) { // ERROR "leaking param: x$"
	external(x)
}

func foo120() {
	// formerly exponential time analysis
L1:
L2:
L3:
L4:
L5:
L6:
L7:
L8:
L9:
L10:
L11:
L12:
L13:
L14:
L15:
L16:
L17:
L18:
L19:
L20:
L21:
L22:
L23:
L24:
L25:
L26:
L27:
L28:
L29:
L30:
L31:
L32:
L33:
L34:
L35:
L36:
L37:
L38:
L39:
L40:
L41:
L42:
L43:
L44:
L45:
L46:
L47:
L48:
L49:
L50:
L51:
L52:
L53:
L54:
L55:
L56:
L57:
L58:
L59:
L60:
L61:
L62:
L63:
L64:
L65:
L66:
L67:
L68:
L69:
L70:
L71:
L72:
L73:
L74:
L75:
L76:
L77:
L78:
L79:
L80:
L81:
L82:
L83:
L84:
L85:
L86:
L87:
L88:
L89:
L90:
L91:
L92:
L93:
L94:
L95:
L96:
L97:
L98:
L99:
L100:
	// use the labels to silence compiler errors
	goto L1
	goto L2
	goto L3
	goto L4
	goto L5
	goto L6
	goto L7
	goto L8
	goto L9
	goto L10
	goto L11
	goto L12
	goto L13
	goto L14
	goto L15
	goto L16
	goto L17
	goto L18
	goto L19
	goto L20
	goto L21
	goto L22
	goto L23
	goto L24
	goto L25
	goto L26
	goto L27
	goto L28
	goto L29
	goto L30
	goto L31
	goto L32
	goto L33
	goto L34
	goto L35
	goto L36
	goto L37
	goto L38
	goto L39
	goto L40
	goto L41
	goto L42
	goto L43
	goto L44
	goto L45
	goto L46
	goto L47
	goto L48
	goto L49
	goto L50
	goto L51
	goto L52
	goto L53
	goto L54
	goto L55
	goto L56
	goto L57
	goto L58
	goto L59
	goto L60
	goto L61
	goto L62
	goto L63
	goto L64
	goto L65
	goto L66
	goto L67
	goto L68
	goto L69
	goto L70
	goto L71
	goto L72
	goto L73
	goto L74
	goto L75
	goto L76
	goto L77
	goto L78
	goto L79
	goto L80
	goto L81
	goto L82
	goto L83
	goto L84
	goto L85
	goto L86
	goto L87
	goto L88
	goto L89
	goto L90
	goto L91
	goto L92
	goto L93
	goto L94
	goto L95
	goto L96
	goto L97
	goto L98
	goto L99
	goto L100
}

func foo121() {
	for i := 0; i < 10; i++ {
		defer myprint(nil, i) // ERROR "... argument escapes to heap$" "i escapes to heap$"
		go myprint(nil, i)    // ERROR "... argument escapes to heap$" "i escapes to heap$"
	}
}

// same as foo121 but check across import
func foo121b() {
	for i := 0; i < 10; i++ {
		defer fmt.Printf("%d", i) // ERROR "... argument escapes to heap$" "i escapes to heap$"
		go fmt.Printf("%d", i)    // ERROR "... argument escapes to heap$" "i escapes to heap$"
	}
}

// a harmless forward jump
func foo122() {
	var i *int

	goto L1
L1:
	i = new(int) // ERROR "foo122 new\(int\) does not escape$"
	_ = i
}

// a backward jump, increases loopdepth
func foo123() {
	var i *int

L1:
	i = new(int) // ERROR "new\(int\) escapes to heap$"

	goto L1
	_ = i
}

func foo124(x **int) { // ERROR "foo124 x does not escape$"
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo124 func literal does not escape$"
		*x = p // ERROR "leaking closure reference p$"
	}()
}

func foo125(ch chan *int) { // ERROR "foo125 ch does not escape$"
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo125 func literal does not escape$"
		ch <- p // ERROR "leaking closure reference p$"
	}()
}

func foo126() {
	var px *int // loopdepth 0
	for {
		// loopdepth 1
		var i int // ERROR "moved to heap: i$"
		func() {  // ERROR "foo126 func literal does not escape$"
			px = &i // ERROR "&i escapes to heap$"  "leaking closure reference i"
		}()
	}
	_ = px
}

var px *int

func foo127() {
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	q := p
	px = q
}

func foo128() {
	var i int
	p := &i // ERROR "foo128 &i does not escape$"
	q := p
	_ = q
}

func foo129() {
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo129 func literal does not escape$"
		q := p   // ERROR "leaking closure reference p$"
		func() { // ERROR "foo129.func1 func literal does not escape$"
			r := q // ERROR "leaking closure reference q$"
			px = r
		}()
	}()
}

func foo130() {
	for {
		var i int // ERROR "moved to heap: i$"
		func() {  // ERROR "foo130 func literal does not escape$"
			px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
		}()
	}
}

func foo131() {
	var i int // ERROR "moved to heap: i$"
	func() {  // ERROR "foo131 func literal does not escape$"
		px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
	}()
}

func foo132() {
	var i int   // ERROR "moved to heap: i$"
	go func() { // ERROR "func literal escapes to heap$"
		px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
	}()
}

func foo133() {
	var i int      // ERROR "moved to heap: i$"
	defer func() { // ERROR "foo133 func literal does not escape$"
		px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
	}()
}

func foo134() {
	var i int
	p := &i  // ERROR "foo134 &i does not escape$"
	func() { // ERROR "foo134 func literal does not escape$"
		q := p
		func() { // ERROR "foo134.func1 func literal does not escape$"
			r := q
			_ = r
		}()
	}()
}

func foo135() {
	var i int   // ERROR "moved to heap: i$"
	p := &i     // ERROR "&i escapes to heap$"
	go func() { // ERROR "func literal escapes to heap$"
		q := p
		func() { // ERROR "foo135.func1 func literal does not escape$"
			r := q
			_ = r
		}()
	}()
}

func foo136() {
	var i int   // ERROR "moved to heap: i$"
	p := &i     // ERROR "&i escapes to heap$"
	go func() { // ERROR "func literal escapes to heap$"
		q := p   // ERROR "leaking closure reference p$"
		func() { // ERROR "foo136.func1 func literal does not escape$"
			r := q // ERROR "leaking closure reference q$"
			px = r
		}()
	}()
}

func foo137() {
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo137 func literal does not escape$"
		q := p      // ERROR "leaking closure reference p$"
		go func() { // ERROR "func literal escapes to heap$"
			r := q
			_ = r
		}()
	}()
}

func foo138() *byte {
	type T struct {
		x [1]byte
	}
	t := new(T)    // ERROR "new\(T\) escapes to heap$"
	return &t.x[0] // ERROR "&t.x\[0\] escapes to heap$"
}

func foo139() *byte {
	type T struct {
		x struct {
			y byte
		}
	}
	t := new(T)   // ERROR "new\(T\) escapes to heap$"
	return &t.x.y // ERROR "&t.x.y escapes to heap$"
}

// issue 4751
func foo140() interface{} {
	type T struct {
		X string
	}
	type U struct {
		X string
		T *T
	}
	t := &T{} // ERROR "&T literal escapes to heap$"
	return U{ // ERROR "U literal escapes to heap$"
		X: t.X,
		T: t,
	}
}

//go:noescape

func F1([]byte)

func F2([]byte)

//go:noescape

func F3(x []byte) // ERROR "F3 x does not escape$"

func F4(x []byte)

func G() {
	var buf1 [10]byte
	F1(buf1[:]) // ERROR "G buf1 does not escape$"

	var buf2 [10]byte // ERROR "moved to heap: buf2$"
	F2(buf2[:])       // ERROR "buf2 escapes to heap$"

	var buf3 [10]byte
	F3(buf3[:]) // ERROR "G buf3 does not escape$"

	var buf4 [10]byte // ERROR "moved to heap: buf4$"
	F4(buf4[:])       // ERROR "buf4 escapes to heap$"
}

type Tm struct {
	x int
}

func (t *Tm) M() { // ERROR "\(\*Tm\).M t does not escape$"
}

func foo141() {
	var f func()

	t := new(Tm) // ERROR "new\(Tm\) escapes to heap$"
	f = t.M      // ERROR "foo141 t.M does not escape$"
	_ = f
}

var gf func()

func foo142() {
	t := new(Tm) // ERROR "new\(Tm\) escapes to heap$"
	gf = t.M     // ERROR "t.M escapes to heap$"
}

// issue 3888.
func foo143() {
	for i := 0; i < 1000; i++ {
		func() { // ERROR "foo143 func literal does not escape$"
			for i := 0; i < 1; i++ {
				var t Tm
				t.M() // ERROR "foo143.func1 t does not escape$"
			}
		}()
	}
}

// issue 5773
// Check that annotations take effect regardless of whether they
// are before or after the use in the source code.

//go:noescape

func foo144a(*int)

func foo144() {
	var x int
	foo144a(&x) // ERROR "foo144 &x does not escape$"
	var y int
	foo144b(&y) // ERROR "foo144 &y does not escape$"
}

//go:noescape

func foo144b(*int)

// issue 7313: for loop init should not be treated as "in loop"

type List struct {
	Next *List
}

func foo145(l List) { // ERROR "foo145 l does not escape$"
	var p *List
	for p = &l; p.Next != nil; p = p.Next { // ERROR "foo145 &l does not escape$"
	}
}

func foo146(l List) { // ERROR "foo146 l does not escape$"
	var p *List
	p = &l // ERROR "foo146 &l does not escape$"
	for ; p.Next != nil; p = p.Next {
	}
}

func foo147(l List) { // ERROR "foo147 l does not escape$"
	var p *List
	p = &l // ERROR "foo147 &l does not escape$"
	for p.Next != nil {
		p = p.Next
	}
}

func foo148(l List) { // ERROR "foo148 l does not escape$"
	for p := &l; p.Next != nil; p = p.Next { // ERROR "foo148 &l does not escape$"
	}
}

// related: address of variable should have depth of variable, not of loop

func foo149(l List) { // ERROR "foo149 l does not escape$"
	var p *List
	for {
		for p = &l; p.Next != nil; p = p.Next { // ERROR "foo149 &l does not escape$"
		}
	}
}

// issue 7934: missed ... if element type had no pointers

var save150 []byte

func foo150(x ...byte) { // ERROR "leaking param: x$"
	save150 = x
}

func bar150() {
	foo150(1, 2, 3) // ERROR "... argument escapes to heap$"
}

// issue 7931: bad handling of slice of array

var save151 *int

func foo151(x *int) { // ERROR "leaking param: x$"
	save151 = x
}

func bar151() {
	var a [64]int // ERROR "moved to heap: a$"
	a[4] = 101
	foo151(&(&a)[4:8][0]) // ERROR "&\(&a\)\[4:8\]\[0\] escapes to heap$" "&a escapes to heap$"
}

func bar151b() {
	var a [10]int      // ERROR "moved to heap: a$"
	b := a[:]          // ERROR "a escapes to heap$"
	foo151(&b[4:8][0]) // ERROR "&b\[4:8\]\[0\] escapes to heap$"
}

func bar151c() {
	var a [64]int // ERROR "moved to heap: a$"
	a[4] = 101
	foo151(&(&a)[4:8:8][0]) // ERROR "&\(&a\)\[4:8:8\]\[0\] escapes to heap$" "&a escapes to heap$"
}

func bar151d() {
	var a [10]int        // ERROR "moved to heap: a$"
	b := a[:]            // ERROR "a escapes to heap$"
	foo151(&b[4:8:8][0]) // ERROR "&b\[4:8:8\]\[0\] escapes to heap$"
}

// issue 8120

type U struct {
	s *string
}

func (u *U) String() *string { // ERROR "leaking param: u to result ~r0 level=1$"
	return u.s
}

type V struct {
	s *string
}

// BAD -- level of leak ought to be 0
func NewV(u U) *V { // ERROR "leaking param: u to result ~r1 level=-1"
	return &V{u.String()} // ERROR "&V literal escapes to heap$" "NewV u does not escape"
}

func foo152() {
	a := "a"   // ERROR "moved to heap: a$"
	u := U{&a} // ERROR "&a escapes to heap$"
	v := NewV(u)
	println(v)
}

// issue 8176 - &x in type switch body not marked as escaping

func foo153(v interface{}) *int { // ERROR "leaking param: v to result ~r1 level=-1$"
	switch x := v.(type) {
	case int: // ERROR "moved to heap: x$"
		return &x // ERROR "&x escapes to heap$"
	}
	panic(0)
}

// issue 8185 - &result escaping into result

func f() (x int, y *int) { // ERROR "moved to heap: x$"
	y = &x // ERROR "&x escapes to heap$"
	return
}

func g() (x interface{}) { // ERROR "moved to heap: x$"
	x = &x // ERROR "&x escapes to heap$"
	return
}

var sink interface{}

type Lit struct {
	p *int
}

func ptrlitNoescape() {
	// Both literal and element do not escape.
	i := 0
	x := &Lit{&i} // ERROR "ptrlitNoescape &Lit literal does not escape$" "ptrlitNoescape &i does not escape$"
	_ = x
}

func ptrlitNoEscape2() {
	// Literal does not escape, but element does.
	i := 0        // ERROR "moved to heap: i$"
	x := &Lit{&i} // ERROR "&i escapes to heap$" "ptrlitNoEscape2 &Lit literal does not escape$"
	sink = *x     // ERROR "\*x escapes to heap$"
}

func ptrlitEscape() {
	// Both literal and element escape.
	i := 0        // ERROR "moved to heap: i$"
	x := &Lit{&i} // ERROR "&Lit literal escapes to heap$" "&i escapes to heap$"
	sink = x      // ERROR "x escapes to heap$"
}

// self-assignments

type Buffer struct {
	arr  [64]byte
	buf1 []byte
	buf2 []byte
	str1 string
	str2 string
}

func (b *Buffer) foo() { // ERROR "\(\*Buffer\).foo b does not escape$"
	b.buf1 = b.buf1[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
	b.buf1 = b.buf1[1:2:3] // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
	b.buf1 = b.buf2[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
	b.buf1 = b.buf2[1:2:3] // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
}

func (b *Buffer) bar() { // ERROR "leaking param: b$"
	b.buf1 = b.arr[1:2] // ERROR "b.arr escapes to heap$"
}

func (b *Buffer) baz() { // ERROR "\(\*Buffer\).baz b does not escape$"
	b.str1 = b.str1[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment to b.str1$"
	b.str1 = b.str2[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment to b.str1$"
}

func (b *Buffer) bat() { // ERROR "leaking param content: b$"
	o := new(Buffer) // ERROR "new\(Buffer\) escapes to heap$"
	o.buf1 = b.buf1[1:2]
	sink = o // ERROR "o escapes to heap$"
}

func quux(sp *string, bp *[]byte) { // ERROR "quux bp does not escape$" "quux sp does not escape$"
	*sp = (*sp)[1:2] // ERROR "quux ignoring self-assignment to \*sp$"
	*bp = (*bp)[1:2] // ERROR "quux ignoring self-assignment to \*bp$"
}

type StructWithString struct {
	p *int
	s string
}

// This is escape analysis false negative.
// We assign the pointer to x.p but leak x.s. Escape analysis coarsens flows
// to just x, and thus &i looks escaping.
func fieldFlowTracking() {
	var x StructWithString
	i := 0     // ERROR "moved to heap: i$"
	x.p = &i   // ERROR "&i escapes to heap$"
	sink = x.s // ERROR "x.s escapes to heap$"
}

// String operations.

func slicebytetostring0() {
	b := make([]byte, 20) // ERROR "slicebytetostring0 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "slicebytetostring0 string\(b\) does not escape$"
	_ = s
}

func slicebytetostring1() {
	b := make([]byte, 20) // ERROR "slicebytetostring1 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "slicebytetostring1 string\(b\) does not escape$"
	s1 := s[0:1]
	_ = s1
}

func slicebytetostring2() {
	b := make([]byte, 20) // ERROR "slicebytetostring2 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "string\(b\) escapes to heap$"
	s1 := s[0:1]          // ERROR "moved to heap: s1$"
	sink = &s1            // ERROR "&s1 escapes to heap$"
}

func slicebytetostring3() {
	b := make([]byte, 20) // ERROR "slicebytetostring3 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "string\(b\) escapes to heap$"
	s1 := s[0:1]
	sink = s1 // ERROR "s1 escapes to heap$"
}

func addstr0() {
	s0 := "a"
	s1 := "b"
	s := s0 + s1 // ERROR "addstr0 s0 \+ s1 does not escape$"
	_ = s
}

func addstr1() {
	s0 := "a"
	s1 := "b"
	s := "c"
	s += s0 + s1 // ERROR "addstr1 s0 \+ s1 does not escape$"
	_ = s
}

func addstr2() {
	b := make([]byte, 20) // ERROR "addstr2 make\(\[\]byte, 20\) does not escape$"
	s0 := "a"
	s := string(b) + s0 // ERROR "addstr2 string\(b\) \+ s0 does not escape$" "addstr2 string\(b\) does not escape$"
	_ = s
}

func addstr3() {
	s0 := "a"
	s1 := "b"
	s := s0 + s1 // ERROR "s0 \+ s1 escapes to heap$"
	s2 := s[0:1]
	sink = s2 // ERROR "s2 escapes to heap$"
}

func intstring0() bool {
	// string does not escape
	x := '0'
	s := string(x) // ERROR "intstring0 string\(x\) does not escape$"
	return s == "0"
}

func intstring1() string {
	// string does not escape, but the buffer does
	x := '0'
	s := string(x) // ERROR "string\(x\) escapes to heap$"
	return s
}

func intstring2() {
	// string escapes to heap
	x := '0'
	s := string(x) // ERROR "moved to heap: s$" "string\(x\) escapes to heap$"
	sink = &s      // ERROR "&s escapes to heap$"
}

func stringtoslicebyte0() {
	s := "foo"
	x := []byte(s) // ERROR "stringtoslicebyte0 \(\[\]byte\)\(s\) does not escape$"
	_ = x
}

func stringtoslicebyte1() []byte {
	s := "foo"
	return []byte(s) // ERROR "\(\[\]byte\)\(s\) escapes to heap$"
}

func stringtoslicebyte2() {
	s := "foo"
	sink = []byte(s) // ERROR "\(\[\]byte\)\(s\) escapes to heap$"
}

func stringtoslicerune0() {
	s := "foo"
	x := []rune(s) // ERROR "stringtoslicerune0 \(\[\]rune\)\(s\) does not escape$"
	_ = x
}

func stringtoslicerune1() []rune {
	s := "foo"
	return []rune(s) // ERROR "\(\[\]rune\)\(s\) escapes to heap$"
}

func stringtoslicerune2() {
	s := "foo"
	sink = []rune(s) // ERROR "\(\[\]rune\)\(s\) escapes to heap$"
}

func slicerunetostring0() {
	r := []rune{1, 2, 3} // ERROR "slicerunetostring0 \[\]rune literal does not escape$"
	s := string(r)       // ERROR "slicerunetostring0 string\(r\) does not escape$"
	_ = s
}

func slicerunetostring1() string {
	r := []rune{1, 2, 3} // ERROR "slicerunetostring1 \[\]rune literal does not escape$"
	return string(r)     // ERROR "string\(r\) escapes to heap$"
}

func slicerunetostring2() {
	r := []rune{1, 2, 3} // ERROR "slicerunetostring2 \[\]rune literal does not escape$"
	sink = string(r)     // ERROR "string\(r\) escapes to heap$"
}

func makemap0() {
	m := make(map[int]int) // ERROR "makemap0 make\(map\[int\]int\) does not escape$"
	m[0] = 0
	m[1]++
	delete(m, 1)
	sink = m[0] // ERROR "m\[0\] escapes to heap$"
}

func makemap1() map[int]int {
	return make(map[int]int) // ERROR "make\(map\[int\]int\) escapes to heap$"
}

func makemap2() {
	m := make(map[int]int) // ERROR "make\(map\[int\]int\) escapes to heap$"
	sink = m               // ERROR "m escapes to heap$"
}

func nonescapingEface(m map[interface{}]bool) bool { // ERROR "nonescapingEface m does not escape$"
	return m["foo"] // ERROR "nonescapingEface .foo. does not escape$"
}

func nonescapingIface(m map[M]bool) bool { // ERROR "nonescapingIface m does not escape$"
	return m[MV(0)] // ERROR "nonescapingIface MV\(0\) does not escape$"
}

func issue10353() {
	x := new(int) // ERROR "new\(int\) escapes to heap$"
	issue10353a(x)()
}

func issue10353a(x *int) func() { // ERROR "leaking param: x to result ~r1 level=-1$"
	return func() { // ERROR "func literal escapes to heap$"
		println(*x)
	}
}

func issue10353b() {
	var f func()
	for {
		x := new(int) // ERROR "new\(int\) escapes to heap$"
		f = func() {  // ERROR "func literal escapes to heap$"
			println(*x)
		}
	}
	_ = f
}

func issue11387(x int) func() int {
	f := func() int { return x }    // ERROR "func literal escapes to heap"
	slice1 := []func() int{f}       // ERROR "\[\].* does not escape"
	slice2 := make([]func() int, 1) // ERROR "make\(.*\) does not escape"
	copy(slice2, slice1)
	return slice2[0]
}
                                                                                                                                                                                                                                                                                                                                                       usr/local/go/test/escape2n.go                                                                       0100644 0000000 0000000 00000120305 13020111414 014547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -N -m -l

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test, using compiler diagnostic flags, that the escape analysis is working.
// Compiles but does not run.  Inlining is disabled.
// Registerization is disabled too (-N), which should
// have no effect on escape analysis.

package foo

import (
	"fmt"
	"unsafe"
)

var gxx *int

func foo1(x int) { // ERROR "moved to heap: x$"
	gxx = &x // ERROR "&x escapes to heap$"
}

func foo2(yy *int) { // ERROR "leaking param: yy$"
	gxx = yy
}

func foo3(x int) *int { // ERROR "moved to heap: x$"
	return &x // ERROR "&x escapes to heap$"
}

type T *T

func foo3b(t T) { // ERROR "leaking param: t$"
	*t = t
}

// xx isn't going anywhere, so use of yy is ok
func foo4(xx, yy *int) { // ERROR "foo4 xx does not escape$" "foo4 yy does not escape$"
	xx = yy
}

// xx isn't going anywhere, so taking address of yy is ok
func foo5(xx **int, yy *int) { // ERROR "foo5 xx does not escape$" "foo5 yy does not escape$"
	xx = &yy // ERROR "foo5 &yy does not escape$"
}

func foo6(xx **int, yy *int) { // ERROR "foo6 xx does not escape$" "leaking param: yy$"
	*xx = yy
}

func foo7(xx **int, yy *int) { // ERROR "foo7 xx does not escape$" "foo7 yy does not escape$"
	**xx = *yy
}

func foo8(xx, yy *int) int { // ERROR "foo8 xx does not escape$" "foo8 yy does not escape$"
	xx = yy
	return *xx
}

func foo9(xx, yy *int) *int { // ERROR "leaking param: xx to result ~r2 level=0$" "leaking param: yy to result ~r2 level=0$"
	xx = yy
	return xx
}

func foo10(xx, yy *int) { // ERROR "foo10 xx does not escape$" "foo10 yy does not escape$"
	*xx = *yy
}

func foo11() int {
	x, y := 0, 42
	xx := &x // ERROR "foo11 &x does not escape$"
	yy := &y // ERROR "foo11 &y does not escape$"
	*xx = *yy
	return x
}

var xxx **int

func foo12(yyy **int) { // ERROR "leaking param: yyy$"
	xxx = yyy
}

// Must treat yyy as leaking because *yyy leaks, and the escape analysis
// summaries in exported metadata do not distinguish these two cases.
func foo13(yyy **int) { // ERROR "leaking param content: yyy$"
	*xxx = *yyy
}

func foo14(yyy **int) { // ERROR "foo14 yyy does not escape$"
	**xxx = **yyy
}

func foo15(yy *int) { // ERROR "moved to heap: yy$"
	xxx = &yy // ERROR "&yy escapes to heap$"
}

func foo16(yy *int) { // ERROR "leaking param: yy$"
	*xxx = yy
}

func foo17(yy *int) { // ERROR "foo17 yy does not escape$"
	**xxx = *yy
}

func foo18(y int) { // ERROR "moved to heap: y$"
	*xxx = &y // ERROR "&y escapes to heap$"
}

func foo19(y int) {
	**xxx = y
}

type Bar struct {
	i  int
	ii *int
}

func NewBar() *Bar {
	return &Bar{42, nil} // ERROR "&Bar literal escapes to heap$"
}

func NewBarp(x *int) *Bar { // ERROR "leaking param: x to result ~r1 level=-1$"
	return &Bar{42, x} // ERROR "&Bar literal escapes to heap$"
}

func NewBarp2(x *int) *Bar { // ERROR "NewBarp2 x does not escape$"
	return &Bar{*x, nil} // ERROR "&Bar literal escapes to heap$"
}

func (b *Bar) NoLeak() int { // ERROR "\(\*Bar\).NoLeak b does not escape$"
	return *(b.ii)
}

func (b *Bar) Leak() *int { // ERROR "leaking param: b to result ~r0 level=0$"
	return &b.i // ERROR "&b.i escapes to heap$"
}

func (b *Bar) AlsoNoLeak() *int { // ERROR "leaking param: b to result ~r0 level=1$"
	return b.ii
}

func (b Bar) AlsoLeak() *int { // ERROR "leaking param: b to result ~r0 level=0$"
	return b.ii
}

func (b Bar) LeaksToo() *int { // ERROR "leaking param: b to result ~r0 level=0$"
	v := 0    // ERROR "moved to heap: v$"
	b.ii = &v // ERROR "&v escapes to heap$"
	return b.ii
}

func (b *Bar) LeaksABit() *int { // ERROR "leaking param: b to result ~r0 level=1$"
	v := 0    // ERROR "moved to heap: v$"
	b.ii = &v // ERROR "&v escapes to heap$"
	return b.ii
}

func (b Bar) StillNoLeak() int { // ERROR "Bar.StillNoLeak b does not escape$"
	v := 0
	b.ii = &v // ERROR "Bar.StillNoLeak &v does not escape$"
	return b.i
}

func goLeak(b *Bar) { // ERROR "leaking param: b$"
	go b.NoLeak()
}

type Bar2 struct {
	i  [12]int
	ii []int
}

func NewBar2() *Bar2 {
	return &Bar2{[12]int{42}, nil} // ERROR "&Bar2 literal escapes to heap$"
}

func (b *Bar2) NoLeak() int { // ERROR "\(\*Bar2\).NoLeak b does not escape$"
	return b.i[0]
}

func (b *Bar2) Leak() []int { // ERROR "leaking param: b to result ~r0 level=0$"
	return b.i[:] // ERROR "b.i escapes to heap$"
}

func (b *Bar2) AlsoNoLeak() []int { // ERROR "leaking param: b to result ~r0 level=1$"
	return b.ii[0:1]
}

func (b Bar2) AgainNoLeak() [12]int { // ERROR "Bar2.AgainNoLeak b does not escape$"
	return b.i
}

func (b *Bar2) LeakSelf() { // ERROR "leaking param: b$"
	b.ii = b.i[0:4] // ERROR "b.i escapes to heap$"
}

func (b *Bar2) LeakSelf2() { // ERROR "leaking param: b$"
	var buf []int
	buf = b.i[0:] // ERROR "b.i escapes to heap$"
	b.ii = buf
}

func foo21() func() int {
	x := 42
	return func() int { // ERROR "func literal escapes to heap$"
		return x
	}
}

func foo21a() func() int {
	x := 42             // ERROR "moved to heap: x$"
	return func() int { // ERROR "func literal escapes to heap$"
		x++ // ERROR "&x escapes to heap$"
		return x
	}
}

func foo22() int {
	x := 42
	return func() int { // ERROR "foo22 func literal does not escape$"
		return x
	}()
}

func foo23(x int) func() int {
	return func() int { // ERROR "func literal escapes to heap$"
		return x
	}
}

func foo23a(x int) func() int {
	f := func() int { // ERROR "func literal escapes to heap$"
		return x
	}
	return f
}

func foo23b(x int) *(func() int) {
	f := func() int { return x } // ERROR "func literal escapes to heap$" "moved to heap: f$"
	return &f                    // ERROR "&f escapes to heap$"
}

func foo23c(x int) func() int { // ERROR "moved to heap: x$"
	return func() int { // ERROR "func literal escapes to heap$"
		x++ // ERROR "&x escapes to heap$"
		return x
	}
}

func foo24(x int) int {
	return func() int { // ERROR "foo24 func literal does not escape$"
		return x
	}()
}

var x *int

func fooleak(xx *int) int { // ERROR "leaking param: xx$"
	x = xx
	return *x
}

func foonoleak(xx *int) int { // ERROR "foonoleak xx does not escape$"
	return *x + *xx
}

func foo31(x int) int { // ERROR "moved to heap: x$"
	return fooleak(&x) // ERROR "&x escapes to heap$"
}

func foo32(x int) int {
	return foonoleak(&x) // ERROR "foo32 &x does not escape$"
}

type Foo struct {
	xx *int
	x  int
}

var F Foo
var pf *Foo

func (f *Foo) fooleak() { // ERROR "leaking param: f$"
	pf = f
}

func (f *Foo) foonoleak() { // ERROR "\(\*Foo\).foonoleak f does not escape$"
	F.x = f.x
}

func (f *Foo) Leak() { // ERROR "leaking param: f$"
	f.fooleak()
}

func (f *Foo) NoLeak() { // ERROR "\(\*Foo\).NoLeak f does not escape$"
	f.foonoleak()
}

func foo41(x int) { // ERROR "moved to heap: x$"
	F.xx = &x // ERROR "&x escapes to heap$"
}

func (f *Foo) foo42(x int) { // ERROR "\(\*Foo\).foo42 f does not escape$" "moved to heap: x$"
	f.xx = &x // ERROR "&x escapes to heap$"
}

func foo43(f *Foo, x int) { // ERROR "foo43 f does not escape$" "moved to heap: x$"
	f.xx = &x // ERROR "&x escapes to heap$"
}

func foo44(yy *int) { // ERROR "leaking param: yy$"
	F.xx = yy
}

func (f *Foo) foo45() { // ERROR "\(\*Foo\).foo45 f does not escape$"
	F.x = f.x
}

// See foo13 above for explanation of why f leaks.
func (f *Foo) foo46() { // ERROR "leaking param content: f$"
	F.xx = f.xx
}

func (f *Foo) foo47() { // ERROR "leaking param: f$"
	f.xx = &f.x // ERROR "&f.x escapes to heap$"
}

var ptrSlice []*int

func foo50(i *int) { // ERROR "leaking param: i$"
	ptrSlice[0] = i
}

var ptrMap map[*int]*int

func foo51(i *int) { // ERROR "leaking param: i$"
	ptrMap[i] = i
}

func indaddr1(x int) *int { // ERROR "moved to heap: x$"
	return &x // ERROR "&x escapes to heap$"
}

func indaddr2(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	return *&x // ERROR "indaddr2 &x does not escape$"
}

func indaddr3(x *int32) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	return *(**int)(unsafe.Pointer(&x)) // ERROR "indaddr3 &x does not escape$"
}

// From package math:

func Float32bits(f float32) uint32 {
	return *(*uint32)(unsafe.Pointer(&f)) // ERROR "Float32bits &f does not escape$"
}

func Float32frombits(b uint32) float32 {
	return *(*float32)(unsafe.Pointer(&b)) // ERROR "Float32frombits &b does not escape$"
}

func Float64bits(f float64) uint64 {
	return *(*uint64)(unsafe.Pointer(&f)) // ERROR "Float64bits &f does not escape$"
}

func Float64frombits(b uint64) float64 {
	return *(*float64)(unsafe.Pointer(&b)) // ERROR "Float64frombits &b does not escape$"
}

// contrast with
func float64bitsptr(f float64) *uint64 { // ERROR "moved to heap: f$"
	return (*uint64)(unsafe.Pointer(&f)) // ERROR "&f escapes to heap$"
}

func float64ptrbitsptr(f *float64) *uint64 { // ERROR "leaking param: f to result ~r1 level=0$"
	return (*uint64)(unsafe.Pointer(f))
}

func typesw(i interface{}) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	switch val := i.(type) {
	case *int:
		return val
	case *int8:
		v := int(*val) // ERROR "moved to heap: v$"
		return &v      // ERROR "&v escapes to heap$"
	}
	return nil
}

func exprsw(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	switch j := i; *j + 110 {
	case 12:
		return j
	case 42:
		return nil
	}
	return nil

}

// assigning to an array element is like assigning to the array
func foo60(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	var a [12]*int
	a[0] = i
	return a[1]
}

func foo60a(i *int) *int { // ERROR "foo60a i does not escape$"
	var a [12]*int
	a[0] = i
	return nil
}

// assigning to a struct field  is like assigning to the struct
func foo61(i *int) *int { // ERROR "leaking param: i to result ~r1 level=0$"
	type S struct {
		a, b *int
	}
	var s S
	s.a = i
	return s.b
}

func foo61a(i *int) *int { // ERROR "foo61a i does not escape$"
	type S struct {
		a, b *int
	}
	var s S
	s.a = i
	return nil
}

// assigning to a struct field is like assigning to the struct but
// here this subtlety is lost, since s.a counts as an assignment to a
// track-losing dereference.
func foo62(i *int) *int { // ERROR "leaking param: i$"
	type S struct {
		a, b *int
	}
	s := new(S) // ERROR "foo62 new\(S\) does not escape$"
	s.a = i
	return nil // s.b
}

type M interface {
	M()
}

func foo63(m M) { // ERROR "foo63 m does not escape$"
}

func foo64(m M) { // ERROR "leaking param: m$"
	m.M()
}

func foo64b(m M) { // ERROR "leaking param: m$"
	defer m.M()
}

type MV int

func (MV) M() {}

func foo65() {
	var mv MV
	foo63(&mv) // ERROR "foo65 &mv does not escape$"
}

func foo66() {
	var mv MV  // ERROR "moved to heap: mv$"
	foo64(&mv) // ERROR "&mv escapes to heap$"
}

func foo67() {
	var mv MV
	foo63(mv) // ERROR "foo67 mv does not escape$"
}

func foo68() {
	var mv MV
	// escapes but it's an int so irrelevant
	foo64(mv) // ERROR "mv escapes to heap$"
}

func foo69(m M) { // ERROR "leaking param: m$"
	foo64(m)
}

func foo70(mv1 *MV, m M) { // ERROR "leaking param: m$" "leaking param: mv1$"
	m = mv1 // ERROR "mv1 escapes to heap$"
	foo64(m)
}

func foo71(x *int) []*int { // ERROR "leaking param: x$"
	var y []*int
	y = append(y, x)
	return y
}

func foo71a(x int) []*int { // ERROR "moved to heap: x$"
	var y []*int
	y = append(y, &x) // ERROR "&x escapes to heap$"
	return y
}

func foo72() {
	var x int
	var y [1]*int
	y[0] = &x // ERROR "foo72 &x does not escape$"
}

func foo72aa() [10]*int {
	var x int // ERROR "moved to heap: x$"
	var y [10]*int
	y[0] = &x // ERROR "&x escapes to heap$"
	return y
}

func foo72a() {
	var y [10]*int
	for i := 0; i < 10; i++ {
		// escapes its scope
		x := i    // ERROR "moved to heap: x$"
		y[i] = &x // ERROR "&x escapes to heap$"
	}
	return
}

func foo72b() [10]*int {
	var y [10]*int
	for i := 0; i < 10; i++ {
		x := i    // ERROR "moved to heap: x$"
		y[i] = &x // ERROR "&x escapes to heap$"
	}
	return y
}

// issue 2145
func foo73() {
	s := []int{3, 2, 1} // ERROR "foo73 \[\]int literal does not escape$"
	for _, v := range s {
		vv := v
		// actually just escapes its scope
		defer func() { // ERROR "func literal escapes to heap$"
			println(vv)
		}()
	}
}

func foo731() {
	s := []int{3, 2, 1} // ERROR "foo731 \[\]int literal does not escape$"
	for _, v := range s {
		vv := v // ERROR "moved to heap: vv$"
		// actually just escapes its scope
		defer func() { // ERROR "func literal escapes to heap$"
			vv = 42 // ERROR "&vv escapes to heap$"
			println(vv)
		}()
	}
}

func foo74() {
	s := []int{3, 2, 1} // ERROR "foo74 \[\]int literal does not escape$"
	for _, v := range s {
		vv := v
		// actually just escapes its scope
		fn := func() { // ERROR "func literal escapes to heap$"
			println(vv)
		}
		defer fn()
	}
}

func foo74a() {
	s := []int{3, 2, 1} // ERROR "foo74a \[\]int literal does not escape$"
	for _, v := range s {
		vv := v // ERROR "moved to heap: vv$"
		// actually just escapes its scope
		fn := func() { // ERROR "func literal escapes to heap$"
			vv += 1 // ERROR "&vv escapes to heap$"
			println(vv)
		}
		defer fn()
	}
}

// issue 3975
func foo74b() {
	var array [3]func()
	s := []int{3, 2, 1} // ERROR "foo74b \[\]int literal does not escape$"
	for i, v := range s {
		vv := v
		// actually just escapes its scope
		array[i] = func() { // ERROR "func literal escapes to heap$"
			println(vv)
		}
	}
}

func foo74c() {
	var array [3]func()
	s := []int{3, 2, 1} // ERROR "foo74c \[\]int literal does not escape$"
	for i, v := range s {
		vv := v // ERROR "moved to heap: vv$"
		// actually just escapes its scope
		array[i] = func() { // ERROR "func literal escapes to heap$"
			println(&vv) // ERROR "&vv escapes to heap$" "foo74c.func1 &vv does not escape$"
		}
	}
}

func myprint(y *int, x ...interface{}) *int { // ERROR "leaking param: y to result ~r2 level=0$" "myprint x does not escape$"
	return y
}

func myprint1(y *int, x ...interface{}) *interface{} { // ERROR "leaking param: x to result ~r2 level=0$" "myprint1 y does not escape$"
	return &x[0] // ERROR "&x\[0\] escapes to heap$"
}

func foo75(z *int) { // ERROR "foo75 z does not escape$"
	myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75 ... argument does not escape$"
}

func foo75a(z *int) { // ERROR "foo75a z does not escape$"
	myprint1(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75a ... argument does not escape$"
}

func foo75esc(z *int) { // ERROR "leaking param: z$"
	gxx = myprint(z, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo75esc ... argument does not escape$"
}

func foo75aesc(z *int) { // ERROR "foo75aesc z does not escape$"
	var ppi **interface{}       // assignments to pointer dereferences lose track
	*ppi = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
}

func foo75aesc1(z *int) { // ERROR "foo75aesc1 z does not escape$"
	sink = myprint1(z, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$" "myprint1\(z, 1, 2, 3\) escapes to heap$"
}

func foo76(z *int) { // ERROR "z does not escape"
	myprint(nil, z) // ERROR "foo76 ... argument does not escape$" "z does not escape"
}

func foo76a(z *int) { // ERROR "z does not escape"
	myprint1(nil, z) // ERROR "foo76a ... argument does not escape$" "z does not escape"
}

func foo76b() {
	myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76b ... argument does not escape$"
}

func foo76c() {
	myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76c ... argument does not escape$"
}

func foo76d() {
	defer myprint(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76d ... argument does not escape$"
}

func foo76e() {
	defer myprint1(nil, 1, 2, 3) // ERROR "1 does not escape" "2 does not escape" "3 does not escape" "foo76e ... argument does not escape$"
}

func foo76f() {
	for {
		// TODO: This one really only escapes its scope, but we don't distinguish yet.
		defer myprint(nil, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
	}
}

func foo76g() {
	for {
		defer myprint1(nil, 1, 2, 3) // ERROR "... argument escapes to heap$" "1 escapes to heap$" "2 escapes to heap$" "3 escapes to heap$"
	}
}

func foo77(z []interface{}) { // ERROR "foo77 z does not escape$"
	myprint(nil, z...) // z does not escape
}

func foo77a(z []interface{}) { // ERROR "foo77a z does not escape$"
	myprint1(nil, z...)
}

func foo77b(z []interface{}) { // ERROR "leaking param: z$"
	var ppi **interface{}
	*ppi = myprint1(nil, z...)
}

func foo77c(z []interface{}) { // ERROR "leaking param: z$"
	sink = myprint1(nil, z...) // ERROR "myprint1\(nil, z...\) escapes to heap$"
}

func dotdotdot() {
	i := 0
	myprint(nil, &i) // ERROR "&i does not escape" "dotdotdot ... argument does not escape$"

	j := 0
	myprint1(nil, &j) // ERROR "&j does not escape" "dotdotdot ... argument does not escape$"
}

func foo78(z int) *int { // ERROR "moved to heap: z$"
	return &z // ERROR "&z escapes to heap$"
}

func foo78a(z int) *int { // ERROR "moved to heap: z$"
	y := &z   // ERROR "&z escapes to heap$"
	x := &y   // ERROR "foo78a &y does not escape$"
	return *x // really return y
}

func foo79() *int {
	return new(int) // ERROR "new\(int\) escapes to heap$"
}

func foo80() *int {
	var z *int
	for {
		// Really just escapes its scope but we don't distinguish
		z = new(int) // ERROR "new\(int\) escapes to heap$"
	}
	_ = z
	return nil
}

func foo81() *int {
	for {
		z := new(int) // ERROR "foo81 new\(int\) does not escape$"
		_ = z
	}
	return nil
}

func tee(p *int) (x, y *int) { return p, p } // ERROR "leaking param: p to result x level=0$" "leaking param: p to result y level=0$"

func noop(x, y *int) {} // ERROR "noop x does not escape$" "noop y does not escape$"

func foo82() {
	var x, y, z int  // ERROR "moved to heap: x$" "moved to heap: y$" "moved to heap: z$"
	go noop(tee(&z)) // ERROR "&z escapes to heap$"
	go noop(&x, &y)  // ERROR "&x escapes to heap$" "&y escapes to heap$"
	for {
		var u, v, w int     // ERROR "moved to heap: u$" "moved to heap: v$" "moved to heap: w$"
		defer noop(tee(&u)) // ERROR "&u escapes to heap$"
		defer noop(&v, &w)  // ERROR "&v escapes to heap$" "&w escapes to heap$"
	}
}

type Fooer interface {
	Foo()
}

type LimitedFooer struct {
	Fooer
	N int64
}

func LimitFooer(r Fooer, n int64) Fooer { // ERROR "leaking param: r to result ~r2 level=-1$"
	return &LimitedFooer{r, n} // ERROR "&LimitedFooer literal escapes to heap$"
}

func foo90(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{nil: x} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo91(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{x: nil} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo92(x *int) [2]*int { // ERROR "leaking param: x to result ~r1 level=0$"
	return [2]*int{x, nil}
}

// does not leak c
func foo93(c chan *int) *int { // ERROR "foo93 c does not escape$"
	for v := range c {
		return v
	}
	return nil
}

// does not leak m
func foo94(m map[*int]*int, b bool) *int { // ERROR "leaking param: m to result ~r2 level=1"
	for k, v := range m {
		if b {
			return k
		}
		return v
	}
	return nil
}

// does leak x
func foo95(m map[*int]*int, x *int) { // ERROR "foo95 m does not escape$" "leaking param: x$"
	m[x] = x
}

// does not leak m but does leak content
func foo96(m []*int) *int { // ERROR "leaking param: m to result ~r1 level=1"
	return m[0]
}

// does leak m
func foo97(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
	return m[0]
}

// does not leak m
func foo98(m map[int]*int) *int { // ERROR "foo98 m does not escape$"
	return m[0]
}

// does leak m
func foo99(m *[1]*int) []*int { // ERROR "leaking param: m to result ~r1 level=0$"
	return m[:]
}

// does not leak m
func foo100(m []*int) *int { // ERROR "leaking param: m to result ~r1 level=1"
	for _, v := range m {
		return v
	}
	return nil
}

// does leak m
func foo101(m [1]*int) *int { // ERROR "leaking param: m to result ~r1 level=0$"
	for _, v := range m {
		return v
	}
	return nil
}

// does not leak m
func foo101a(m [1]*int) *int { // ERROR "foo101a m does not escape$"
	for i := range m { // ERROR "moved to heap: i$"
		return &i // ERROR "&i escapes to heap$"
	}
	return nil
}

// does leak x
func foo102(m []*int, x *int) { // ERROR "foo102 m does not escape$" "leaking param: x$"
	m[0] = x
}

// does not leak x
func foo103(m [1]*int, x *int) { // ERROR "foo103 m does not escape$" "foo103 x does not escape$"
	m[0] = x
}

var y []*int

// does not leak x but does leak content
func foo104(x []*int) { // ERROR "leaking param content: x"
	copy(y, x)
}

// does not leak x but does leak content
func foo105(x []*int) { // ERROR "leaking param content: x"
	_ = append(y, x...)
}

// does leak x
func foo106(x *int) { // ERROR "leaking param: x$"
	_ = append(y, x)
}

func foo107(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{x: nil} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo108(x *int) map[*int]*int { // ERROR "leaking param: x$"
	return map[*int]*int{nil: x} // ERROR "map\[\*int\]\*int literal escapes to heap$"
}

func foo109(x *int) *int { // ERROR "leaking param: x$"
	m := map[*int]*int{x: nil} // ERROR "foo109 map\[\*int\]\*int literal does not escape$"
	for k, _ := range m {
		return k
	}
	return nil
}

func foo110(x *int) *int { // ERROR "leaking param: x$"
	m := map[*int]*int{nil: x} // ERROR "foo110 map\[\*int\]\*int literal does not escape$"
	return m[nil]
}

func foo111(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0"
	m := []*int{x} // ERROR "foo111 \[\]\*int literal does not escape$"
	return m[0]
}

func foo112(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	m := [1]*int{x}
	return m[0]
}

func foo113(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	m := Bar{ii: x}
	return m.ii
}

func foo114(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	m := &Bar{ii: x} // ERROR "foo114 &Bar literal does not escape$"
	return m.ii
}

func foo115(x *int) *int { // ERROR "leaking param: x to result ~r1 level=0$"
	return (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + 1))
}

func foo116(b bool) *int {
	if b {
		x := 1    // ERROR "moved to heap: x$"
		return &x // ERROR "&x escapes to heap$"
	} else {
		y := 1    // ERROR "moved to heap: y$"
		return &y // ERROR "&y escapes to heap$"
	}
	return nil
}

func foo117(unknown func(interface{})) { // ERROR "foo117 unknown does not escape$"
	x := 1      // ERROR "moved to heap: x$"
	unknown(&x) // ERROR "&x escapes to heap$"
}

func foo118(unknown func(*int)) { // ERROR "foo118 unknown does not escape$"
	x := 1      // ERROR "moved to heap: x$"
	unknown(&x) // ERROR "&x escapes to heap$"
}

func external(*int)

func foo119(x *int) { // ERROR "leaking param: x$"
	external(x)
}

func foo120() {
	// formerly exponential time analysis
L1:
L2:
L3:
L4:
L5:
L6:
L7:
L8:
L9:
L10:
L11:
L12:
L13:
L14:
L15:
L16:
L17:
L18:
L19:
L20:
L21:
L22:
L23:
L24:
L25:
L26:
L27:
L28:
L29:
L30:
L31:
L32:
L33:
L34:
L35:
L36:
L37:
L38:
L39:
L40:
L41:
L42:
L43:
L44:
L45:
L46:
L47:
L48:
L49:
L50:
L51:
L52:
L53:
L54:
L55:
L56:
L57:
L58:
L59:
L60:
L61:
L62:
L63:
L64:
L65:
L66:
L67:
L68:
L69:
L70:
L71:
L72:
L73:
L74:
L75:
L76:
L77:
L78:
L79:
L80:
L81:
L82:
L83:
L84:
L85:
L86:
L87:
L88:
L89:
L90:
L91:
L92:
L93:
L94:
L95:
L96:
L97:
L98:
L99:
L100:
	// use the labels to silence compiler errors
	goto L1
	goto L2
	goto L3
	goto L4
	goto L5
	goto L6
	goto L7
	goto L8
	goto L9
	goto L10
	goto L11
	goto L12
	goto L13
	goto L14
	goto L15
	goto L16
	goto L17
	goto L18
	goto L19
	goto L20
	goto L21
	goto L22
	goto L23
	goto L24
	goto L25
	goto L26
	goto L27
	goto L28
	goto L29
	goto L30
	goto L31
	goto L32
	goto L33
	goto L34
	goto L35
	goto L36
	goto L37
	goto L38
	goto L39
	goto L40
	goto L41
	goto L42
	goto L43
	goto L44
	goto L45
	goto L46
	goto L47
	goto L48
	goto L49
	goto L50
	goto L51
	goto L52
	goto L53
	goto L54
	goto L55
	goto L56
	goto L57
	goto L58
	goto L59
	goto L60
	goto L61
	goto L62
	goto L63
	goto L64
	goto L65
	goto L66
	goto L67
	goto L68
	goto L69
	goto L70
	goto L71
	goto L72
	goto L73
	goto L74
	goto L75
	goto L76
	goto L77
	goto L78
	goto L79
	goto L80
	goto L81
	goto L82
	goto L83
	goto L84
	goto L85
	goto L86
	goto L87
	goto L88
	goto L89
	goto L90
	goto L91
	goto L92
	goto L93
	goto L94
	goto L95
	goto L96
	goto L97
	goto L98
	goto L99
	goto L100
}

func foo121() {
	for i := 0; i < 10; i++ {
		defer myprint(nil, i) // ERROR "... argument escapes to heap$" "i escapes to heap$"
		go myprint(nil, i)    // ERROR "... argument escapes to heap$" "i escapes to heap$"
	}
}

// same as foo121 but check across import
func foo121b() {
	for i := 0; i < 10; i++ {
		defer fmt.Printf("%d", i) // ERROR "... argument escapes to heap$" "i escapes to heap$"
		go fmt.Printf("%d", i)    // ERROR "... argument escapes to heap$" "i escapes to heap$"
	}
}

// a harmless forward jump
func foo122() {
	var i *int

	goto L1
L1:
	i = new(int) // ERROR "foo122 new\(int\) does not escape$"
	_ = i
}

// a backward jump, increases loopdepth
func foo123() {
	var i *int

L1:
	i = new(int) // ERROR "new\(int\) escapes to heap$"

	goto L1
	_ = i
}

func foo124(x **int) { // ERROR "foo124 x does not escape$"
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo124 func literal does not escape$"
		*x = p // ERROR "leaking closure reference p$"
	}()
}

func foo125(ch chan *int) { // ERROR "foo125 ch does not escape$"
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo125 func literal does not escape$"
		ch <- p // ERROR "leaking closure reference p$"
	}()
}

func foo126() {
	var px *int // loopdepth 0
	for {
		// loopdepth 1
		var i int // ERROR "moved to heap: i$"
		func() {  // ERROR "foo126 func literal does not escape$"
			px = &i // ERROR "&i escapes to heap$" "leaking closure reference i"
		}()
	}
	_ = px
}

var px *int

func foo127() {
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	q := p
	px = q
}

func foo128() {
	var i int
	p := &i // ERROR "foo128 &i does not escape$"
	q := p
	_ = q
}

func foo129() {
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo129 func literal does not escape$"
		q := p   // ERROR "leaking closure reference p$"
		func() { // ERROR "foo129.func1 func literal does not escape$"
			r := q // ERROR "leaking closure reference q$"
			px = r
		}()
	}()
}

func foo130() {
	for {
		var i int // ERROR "moved to heap: i$"
		func() {  // ERROR "foo130 func literal does not escape$"
			px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
		}()
	}
}

func foo131() {
	var i int // ERROR "moved to heap: i$"
	func() {  // ERROR "foo131 func literal does not escape$"
		px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
	}()
}

func foo132() {
	var i int   // ERROR "moved to heap: i$"
	go func() { // ERROR "func literal escapes to heap$"
		px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
	}()
}

func foo133() {
	var i int      // ERROR "moved to heap: i$"
	defer func() { // ERROR "foo133 func literal does not escape$"
		px = &i // ERROR "&i escapes to heap$" "leaking closure reference i$"
	}()
}

func foo134() {
	var i int
	p := &i  // ERROR "foo134 &i does not escape$"
	func() { // ERROR "foo134 func literal does not escape$"
		q := p
		func() { // ERROR "foo134.func1 func literal does not escape$"
			r := q
			_ = r
		}()
	}()
}

func foo135() {
	var i int   // ERROR "moved to heap: i$"
	p := &i     // ERROR "&i escapes to heap$"
	go func() { // ERROR "func literal escapes to heap$"
		q := p
		func() { // ERROR "foo135.func1 func literal does not escape$"
			r := q
			_ = r
		}()
	}()
}

func foo136() {
	var i int   // ERROR "moved to heap: i$"
	p := &i     // ERROR "&i escapes to heap$"
	go func() { // ERROR "func literal escapes to heap$"
		q := p   // ERROR "leaking closure reference p$"
		func() { // ERROR "foo136.func1 func literal does not escape$"
			r := q // ERROR "leaking closure reference q$"
			px = r
		}()
	}()
}

func foo137() {
	var i int // ERROR "moved to heap: i$"
	p := &i   // ERROR "&i escapes to heap$"
	func() {  // ERROR "foo137 func literal does not escape$"
		q := p      // ERROR "leaking closure reference p$"
		go func() { // ERROR "func literal escapes to heap$"
			r := q
			_ = r
		}()
	}()
}

func foo138() *byte {
	type T struct {
		x [1]byte
	}
	t := new(T)    // ERROR "new\(T\) escapes to heap$"
	return &t.x[0] // ERROR "&t.x\[0\] escapes to heap$"
}

func foo139() *byte {
	type T struct {
		x struct {
			y byte
		}
	}
	t := new(T)   // ERROR "new\(T\) escapes to heap$"
	return &t.x.y // ERROR "&t.x.y escapes to heap$"
}

// issue 4751
func foo140() interface{} {
	type T struct {
		X string
	}
	type U struct {
		X string
		T *T
	}
	t := &T{} // ERROR "&T literal escapes to heap$"
	return U{ // ERROR "U literal escapes to heap$"
		X: t.X,
		T: t,
	}
}

//go:noescape

func F1([]byte)

func F2([]byte)

//go:noescape

func F3(x []byte) // ERROR "F3 x does not escape$"

func F4(x []byte)

func G() {
	var buf1 [10]byte
	F1(buf1[:]) // ERROR "G buf1 does not escape$"

	var buf2 [10]byte // ERROR "moved to heap: buf2$"
	F2(buf2[:])       // ERROR "buf2 escapes to heap$"

	var buf3 [10]byte
	F3(buf3[:]) // ERROR "G buf3 does not escape$"

	var buf4 [10]byte // ERROR "moved to heap: buf4$"
	F4(buf4[:])       // ERROR "buf4 escapes to heap$"
}

type Tm struct {
	x int
}

func (t *Tm) M() { // ERROR "\(\*Tm\).M t does not escape$"
}

func foo141() {
	var f func()

	t := new(Tm) // ERROR "new\(Tm\) escapes to heap$"
	f = t.M      // ERROR "foo141 t.M does not escape$"
	_ = f
}

var gf func()

func foo142() {
	t := new(Tm) // ERROR "new\(Tm\) escapes to heap$"
	gf = t.M     // ERROR "t.M escapes to heap$"
}

// issue 3888.
func foo143() {
	for i := 0; i < 1000; i++ {
		func() { // ERROR "foo143 func literal does not escape$"
			for i := 0; i < 1; i++ {
				var t Tm
				t.M() // ERROR "foo143.func1 t does not escape$"
			}
		}()
	}
}

// issue 5773
// Check that annotations take effect regardless of whether they
// are before or after the use in the source code.

//go:noescape

func foo144a(*int)

func foo144() {
	var x int
	foo144a(&x) // ERROR "foo144 &x does not escape$"
	var y int
	foo144b(&y) // ERROR "foo144 &y does not escape$"
}

//go:noescape

func foo144b(*int)

// issue 7313: for loop init should not be treated as "in loop"

type List struct {
	Next *List
}

func foo145(l List) { // ERROR "foo145 l does not escape$"
	var p *List
	for p = &l; p.Next != nil; p = p.Next { // ERROR "foo145 &l does not escape$"
	}
}

func foo146(l List) { // ERROR "foo146 l does not escape$"
	var p *List
	p = &l // ERROR "foo146 &l does not escape$"
	for ; p.Next != nil; p = p.Next {
	}
}

func foo147(l List) { // ERROR "foo147 l does not escape$"
	var p *List
	p = &l // ERROR "foo147 &l does not escape$"
	for p.Next != nil {
		p = p.Next
	}
}

func foo148(l List) { // ERROR "foo148 l does not escape$"
	for p := &l; p.Next != nil; p = p.Next { // ERROR "foo148 &l does not escape$"
	}
}

// related: address of variable should have depth of variable, not of loop

func foo149(l List) { // ERROR "foo149 l does not escape$"
	var p *List
	for {
		for p = &l; p.Next != nil; p = p.Next { // ERROR "foo149 &l does not escape$"
		}
	}
}

// issue 7934: missed ... if element type had no pointers

var save150 []byte

func foo150(x ...byte) { // ERROR "leaking param: x$"
	save150 = x
}

func bar150() {
	foo150(1, 2, 3) // ERROR "... argument escapes to heap$"
}

// issue 7931: bad handling of slice of array

var save151 *int

func foo151(x *int) { // ERROR "leaking param: x$"
	save151 = x
}

func bar151() {
	var a [64]int // ERROR "moved to heap: a$"
	a[4] = 101
	foo151(&(&a)[4:8][0]) // ERROR "&\(&a\)\[4:8\]\[0\] escapes to heap$" "&a escapes to heap$"
}

func bar151b() {
	var a [10]int      // ERROR "moved to heap: a$"
	b := a[:]          // ERROR "a escapes to heap$"
	foo151(&b[4:8][0]) // ERROR "&b\[4:8\]\[0\] escapes to heap$"
}

func bar151c() {
	var a [64]int // ERROR "moved to heap: a$"
	a[4] = 101
	foo151(&(&a)[4:8:8][0]) // ERROR "&\(&a\)\[4:8:8\]\[0\] escapes to heap$" "&a escapes to heap$"
}

func bar151d() {
	var a [10]int        // ERROR "moved to heap: a$"
	b := a[:]            // ERROR "a escapes to heap$"
	foo151(&b[4:8:8][0]) // ERROR "&b\[4:8:8\]\[0\] escapes to heap$"
}

// issue 8120

type U struct {
	s *string
}

func (u *U) String() *string { // ERROR "leaking param: u to result ~r0 level=1$"
	return u.s
}

type V struct {
	s *string
}

// BAD -- level of leak ought to be 0
func NewV(u U) *V { // ERROR "leaking param: u to result ~r1 level=-1"
	return &V{u.String()} // ERROR "&V literal escapes to heap$" "NewV u does not escape"
}

func foo152() {
	a := "a"   // ERROR "moved to heap: a$"
	u := U{&a} // ERROR "&a escapes to heap$"
	v := NewV(u)
	println(v)
}

// issue 8176 - &x in type switch body not marked as escaping

func foo153(v interface{}) *int { // ERROR "leaking param: v to result ~r1 level=-1$"
	switch x := v.(type) {
	case int: // ERROR "moved to heap: x$"
		return &x // ERROR "&x escapes to heap$"
	}
	panic(0)
}

// issue 8185 - &result escaping into result

func f() (x int, y *int) { // ERROR "moved to heap: x$"
	y = &x // ERROR "&x escapes to heap$"
	return
}

func g() (x interface{}) { // ERROR "moved to heap: x$"
	x = &x // ERROR "&x escapes to heap$"
	return
}

var sink interface{}

type Lit struct {
	p *int
}

func ptrlitNoescape() {
	// Both literal and element do not escape.
	i := 0
	x := &Lit{&i} // ERROR "ptrlitNoescape &Lit literal does not escape$" "ptrlitNoescape &i does not escape$"
	_ = x
}

func ptrlitNoEscape2() {
	// Literal does not escape, but element does.
	i := 0        // ERROR "moved to heap: i$"
	x := &Lit{&i} // ERROR "&i escapes to heap$" "ptrlitNoEscape2 &Lit literal does not escape$"
	sink = *x     // ERROR "\*x escapes to heap$"
}

func ptrlitEscape() {
	// Both literal and element escape.
	i := 0        // ERROR "moved to heap: i$"
	x := &Lit{&i} // ERROR "&Lit literal escapes to heap$" "&i escapes to heap$"
	sink = x      // ERROR "x escapes to heap$"
}

// self-assignments

type Buffer struct {
	arr  [64]byte
	buf1 []byte
	buf2 []byte
	str1 string
	str2 string
}

func (b *Buffer) foo() { // ERROR "\(\*Buffer\).foo b does not escape$"
	b.buf1 = b.buf1[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
	b.buf1 = b.buf1[1:2:3] // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
	b.buf1 = b.buf2[1:2]   // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
	b.buf1 = b.buf2[1:2:3] // ERROR "\(\*Buffer\).foo ignoring self-assignment to b.buf1$"
}

func (b *Buffer) bar() { // ERROR "leaking param: b$"
	b.buf1 = b.arr[1:2] // ERROR "b.arr escapes to heap$"
}

func (b *Buffer) baz() { // ERROR "\(\*Buffer\).baz b does not escape$"
	b.str1 = b.str1[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment to b.str1$"
	b.str1 = b.str2[1:2] // ERROR "\(\*Buffer\).baz ignoring self-assignment to b.str1$"
}

func (b *Buffer) bat() { // ERROR "leaking param content: b$"
	o := new(Buffer) // ERROR "new\(Buffer\) escapes to heap$"
	o.buf1 = b.buf1[1:2]
	sink = o // ERROR "o escapes to heap$"
}

func quux(sp *string, bp *[]byte) { // ERROR "quux bp does not escape$" "quux sp does not escape$"
	*sp = (*sp)[1:2] // ERROR "quux ignoring self-assignment to \*sp$"
	*bp = (*bp)[1:2] // ERROR "quux ignoring self-assignment to \*bp$"
}

type StructWithString struct {
	p *int
	s string
}

// This is escape analysis false negative.
// We assign the pointer to x.p but leak x.s. Escape analysis coarsens flows
// to just x, and thus &i looks escaping.
func fieldFlowTracking() {
	var x StructWithString
	i := 0     // ERROR "moved to heap: i$"
	x.p = &i   // ERROR "&i escapes to heap$"
	sink = x.s // ERROR "x.s escapes to heap$"
}

// String operations.

func slicebytetostring0() {
	b := make([]byte, 20) // ERROR "slicebytetostring0 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "slicebytetostring0 string\(b\) does not escape$"
	_ = s
}

func slicebytetostring1() {
	b := make([]byte, 20) // ERROR "slicebytetostring1 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "slicebytetostring1 string\(b\) does not escape$"
	s1 := s[0:1]
	_ = s1
}

func slicebytetostring2() {
	b := make([]byte, 20) // ERROR "slicebytetostring2 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "string\(b\) escapes to heap$"
	s1 := s[0:1]          // ERROR "moved to heap: s1$"
	sink = &s1            // ERROR "&s1 escapes to heap$"
}

func slicebytetostring3() {
	b := make([]byte, 20) // ERROR "slicebytetostring3 make\(\[\]byte, 20\) does not escape$"
	s := string(b)        // ERROR "string\(b\) escapes to heap$"
	s1 := s[0:1]
	sink = s1 // ERROR "s1 escapes to heap$"
}

func addstr0() {
	s0 := "a"
	s1 := "b"
	s := s0 + s1 // ERROR "addstr0 s0 \+ s1 does not escape$"
	_ = s
}

func addstr1() {
	s0 := "a"
	s1 := "b"
	s := "c"
	s += s0 + s1 // ERROR "addstr1 s0 \+ s1 does not escape$"
	_ = s
}

func addstr2() {
	b := make([]byte, 20) // ERROR "addstr2 make\(\[\]byte, 20\) does not escape$"
	s0 := "a"
	s := string(b) + s0 // ERROR "addstr2 string\(b\) \+ s0 does not escape$" "addstr2 string\(b\) does not escape$"
	_ = s
}

func addstr3() {
	s0 := "a"
	s1 := "b"
	s := s0 + s1 // ERROR "s0 \+ s1 escapes to heap$"
	s2 := s[0:1]
	sink = s2 // ERROR "s2 escapes to heap$"
}

func intstring0() bool {
	// string does not escape
	x := '0'
	s := string(x) // ERROR "intstring0 string\(x\) does not escape$"
	return s == "0"
}

func intstring1() string {
	// string does not escape, but the buffer does
	x := '0'
	s := string(x) // ERROR "string\(x\) escapes to heap$"
	return s
}

func intstring2() {
	// string escapes to heap
	x := '0'
	s := string(x) // ERROR "moved to heap: s$" "string\(x\) escapes to heap$"
	sink = &s      // ERROR "&s escapes to heap$"
}

func stringtoslicebyte0() {
	s := "foo"
	x := []byte(s) // ERROR "stringtoslicebyte0 \(\[\]byte\)\(s\) does not escape$"
	_ = x
}

func stringtoslicebyte1() []byte {
	s := "foo"
	return []byte(s) // ERROR "\(\[\]byte\)\(s\) escapes to heap$"
}

func stringtoslicebyte2() {
	s := "foo"
	sink = []byte(s) // ERROR "\(\[\]byte\)\(s\) escapes to heap$"
}

func stringtoslicerune0() {
	s := "foo"
	x := []rune(s) // ERROR "stringtoslicerune0 \(\[\]rune\)\(s\) does not escape$"
	_ = x
}

func stringtoslicerune1() []rune {
	s := "foo"
	return []rune(s) // ERROR "\(\[\]rune\)\(s\) escapes to heap$"
}

func stringtoslicerune2() {
	s := "foo"
	sink = []rune(s) // ERROR "\(\[\]rune\)\(s\) escapes to heap$"
}

func slicerunetostring0() {
	r := []rune{1, 2, 3} // ERROR "slicerunetostring0 \[\]rune literal does not escape$"
	s := string(r)       // ERROR "slicerunetostring0 string\(r\) does not escape$"
	_ = s
}

func slicerunetostring1() string {
	r := []rune{1, 2, 3} // ERROR "slicerunetostring1 \[\]rune literal does not escape$"
	return string(r)     // ERROR "string\(r\) escapes to heap$"
}

func slicerunetostring2() {
	r := []rune{1, 2, 3} // ERROR "slicerunetostring2 \[\]rune literal does not escape$"
	sink = string(r)     // ERROR "string\(r\) escapes to heap$"
}

func makemap0() {
	m := make(map[int]int) // ERROR "makemap0 make\(map\[int\]int\) does not escape$"
	m[0] = 0
	m[1]++
	delete(m, 1)
	sink = m[0] // ERROR "m\[0\] escapes to heap$"
}

func makemap1() map[int]int {
	return make(map[int]int) // ERROR "make\(map\[int\]int\) escapes to heap$"
}

func makemap2() {
	m := make(map[int]int) // ERROR "make\(map\[int\]int\) escapes to heap$"
	sink = m               // ERROR "m escapes to heap$"
}

func nonescapingEface(m map[interface{}]bool) bool { // ERROR "nonescapingEface m does not escape$"
	return m["foo"] // ERROR "nonescapingEface .foo. does not escape$"
}

func nonescapingIface(m map[M]bool) bool { // ERROR "nonescapingIface m does not escape$"
	return m[MV(0)] // ERROR "nonescapingIface MV\(0\) does not escape$"
}

func issue10353() {
	x := new(int) // ERROR "new\(int\) escapes to heap$"
	issue10353a(x)()
}

func issue10353a(x *int) func() { // ERROR "leaking param: x to result ~r1 level=-1$"
	return func() { // ERROR "func literal escapes to heap$"
		println(*x)
	}
}

func issue10353b() {
	var f func()
	for {
		x := new(int) // ERROR "new\(int\) escapes to heap$"
		f = func() {  // ERROR "func literal escapes to heap$"
			println(*x)
		}
	}
	_ = f
}

func issue11387(x int) func() int {
	f := func() int { return x }    // ERROR "func literal escapes to heap"
	slice1 := []func() int{f}       // ERROR "\[\].* does not escape"
	slice2 := make([]func() int, 1) // ERROR "make\(.*\) does not escape"
	copy(slice2, slice1)
	return slice2[0]
}
                                                                                                                                                                                                                                                                                                                           usr/local/go/test/escape3.go                                                                        0100644 0000000 0000000 00000001015 13020111414 014366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test the run-time behavior of escape analysis-related optimizations.

package main

func main() {
	test1()
}

func test1() {
	check1(0)
	check1(1)
	check1(2)
}

type T1 struct {
	X, Y, Z int
}

func f() int {
	return 1
}

func check1(pass int) T1 {
	v := []T1{{X: f(), Z: f()}}
	if v[0].Y != 0 {
		panic("nonzero init")
	}
	v[0].Y = pass
	return v[0]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/test/escape4.go                                                                        0100644 0000000 0000000 00000002604 13020111414 014374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test, using compiler diagnostic flags, that the escape analysis is working.
// Compiles but does not run.  Inlining is enabled.

package foo

var p *int

func alloc(x int) *int { // ERROR "can inline alloc" "moved to heap: x"
	return &x // ERROR "&x escapes to heap"
}

var f func()

func f1() {
	p = alloc(2) // ERROR "inlining call to alloc" "&x escapes to heap" "moved to heap: x"

	// Escape analysis used to miss inlined code in closures.

	func() { // ERROR "func literal does not escape" "can inline f1.func1"
		p = alloc(3) // ERROR "inlining call to alloc" "&x escapes to heap" "moved to heap: x"
	}()

	f = func() { // ERROR "func literal escapes to heap" "can inline f1.func2"
		p = alloc(3) // ERROR "inlining call to alloc" "&x escapes to heap" "moved to heap: x"
	}
	f()
}

func f2() {} // ERROR "can inline f2"

// No inline for panic, recover.
func f3() { panic(1) }
func f4() { recover() }

func f5() *byte {
	type T struct {
		x [1]byte
	}
	t := new(T)    // ERROR "new.T. escapes to heap"
	return &t.x[0] // ERROR "&t.x.0. escapes to heap"
}

func f6() *byte {
	type T struct {
		x struct {
			y byte
		}
	}
	t := new(T)   // ERROR "new.T. escapes to heap"
	return &t.x.y // ERROR "&t.x.y escapes to heap"
}
                                                                                                                            usr/local/go/test/escape5.go                                                                        0100644 0000000 0000000 00000006660 13020111414 014403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test, using compiler diagnostic flags, that the escape analysis is working.
// Compiles but does not run.  Inlining is disabled.

package foo

func noleak(p *int) int { // ERROR "p does not escape"
	return *p
}

func leaktoret(p *int) *int { // ERROR "leaking param: p to result"
	return p
}

func leaktoret2(p *int) (*int, *int) { // ERROR "leaking param: p to result ~r1" "leaking param: p to result ~r2"
	return p, p
}

func leaktoret22(p, q *int) (*int, *int) { // ERROR "leaking param: p to result ~r2" "leaking param: q to result ~r3"
	return p, q
}

func leaktoret22b(p, q *int) (*int, *int) { // ERROR "leaking param: p to result ~r3" "leaking param: q to result ~r2"
	return leaktoret22(q, p)
}

func leaktoret22c(p, q *int) (*int, *int) { // ERROR "leaking param: p to result ~r3" "leaking param: q to result ~r2"
	r, s := leaktoret22(q, p)
	return r, s
}

func leaktoret22d(p, q *int) (r, s *int) { // ERROR "leaking param: p to result s" "leaking param: q to result r"
	r, s = leaktoret22(q, p)
	return
}

func leaktoret22e(p, q *int) (r, s *int) { // ERROR "leaking param: p to result s" "leaking param: q to result r"
	r, s = leaktoret22(q, p)
	return r, s
}

func leaktoret22f(p, q *int) (r, s *int) { // ERROR "leaking param: p to result s" "leaking param: q to result r"
	rr, ss := leaktoret22(q, p)
	return rr, ss
}

var gp *int

func leaktosink(p *int) *int { // ERROR "leaking param: p"
	gp = p
	return p
}

func f1() {
	var x int
	p := noleak(&x) // ERROR "&x does not escape"
	_ = p
}

func f2() {
	var x int
	p := leaktoret(&x) // ERROR "&x does not escape"
	_ = p
}

func f3() {
	var x int          // ERROR "moved to heap: x"
	p := leaktoret(&x) // ERROR "&x escapes to heap"
	gp = p
}

func f4() {
	var x int              // ERROR "moved to heap: x"
	p, q := leaktoret2(&x) // ERROR "&x escapes to heap"
	gp = p
	gp = q
}

func f5() {
	var x int
	leaktoret22(leaktoret2(&x)) // ERROR "&x does not escape"
}

func f6() {
	var x int                               // ERROR "moved to heap: x"
	px1, px2 := leaktoret22(leaktoret2(&x)) // ERROR "&x escapes to heap"
	gp = px1
	_ = px2
}

type T struct{ x int }

func (t *T) Foo(u int) (*T, bool) { // ERROR "leaking param: t to result"
	t.x += u
	return t, true
}

func f7() *T {
	r, _ := new(T).Foo(42) // ERROR "new.T. escapes to heap"
	return r
}

func leakrecursive1(p, q *int) (*int, *int) { // ERROR "leaking param: p" "leaking param: q"
	return leakrecursive2(q, p)
}

func leakrecursive2(p, q *int) (*int, *int) { // ERROR "leaking param: p" "leaking param: q"
	if *p > *q {
		return leakrecursive1(q, p)
	}
	// without this, leakrecursive? are safe for p and q, b/c in fact their graph does not have leaking edges.
	return p, q
}

var global interface{}

type T1 struct {
	X *int
}

type T2 struct {
	Y *T1
}

func f8(p *T1) (k T2) { // ERROR "leaking param: p to result k" "leaking param: p"
	if p == nil {
		k = T2{}
		return
	}

	// should make p leak always
	global = p // ERROR "p escapes to heap"
	return T2{p}
}

func f9() {
	var j T1 // ERROR "moved to heap: j"
	f8(&j)   // ERROR "&j escapes to heap"
}

func f10() {
	// These don't escape but are too big for the stack
	var x [1 << 30]byte         // ERROR "moved to heap: x"
	var y = make([]byte, 1<<30) // ERROR "make\(\[\]byte, 1 << 30\) escapes to heap"
	_ = x[0] + y[0]
}
                                                                                usr/local/go/test/escape_array.go                                                                   0100644 0000000 0000000 00000007242 13020111414 015511  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for arrays and some large things

package foo

var Ssink *string

type U [2]*string

func bar(a, b *string) U { // ERROR "leaking param: a to result ~r2 level=0$" "leaking param: b to result ~r2 level=0$"
	return U{a, b}
}

func foo(x U) U { // ERROR "leaking param: x to result ~r1 level=0$"
	return U{x[1], x[0]}
}

func bff(a, b *string) U { // ERROR "leaking param: a to result ~r2 level=0$" "leaking param: b to result ~r2 level=0$"
	return foo(foo(bar(a, b)))
}

func tbff1() *string {
	a := "cat"
	b := "dog"       // ERROR "moved to heap: b$"
	u := bff(&a, &b) // ERROR "tbff1 &a does not escape$" "tbff1 &b does not escape$"
	_ = u[0]
	return &b // ERROR "&b escapes to heap$"
}

// BAD: need fine-grained analysis to track u[0] and u[1] differently.
func tbff2() *string {
	a := "cat"       // ERROR "moved to heap: a$"
	b := "dog"       // ERROR "moved to heap: b$"
	u := bff(&a, &b) // ERROR "&a escapes to heap$" "&b escapes to heap$"
	_ = u[0]
	return u[1]
}

func car(x U) *string { // ERROR "leaking param: x to result ~r1 level=0$"
	return x[0]
}

// BAD: need fine-grained analysis to track x[0] and x[1] differently.
func fun(x U, y *string) *string { // ERROR "leaking param: x to result ~r2 level=0$" "leaking param: y to result ~r2 level=0$"
	x[0] = y
	return x[1]
}

func fup(x *U, y *string) *string { // ERROR "leaking param: x to result ~r2 level=1$" "leaking param: y$"
	x[0] = y // leaking y to heap is intended
	return x[1]
}

func fum(x *U, y **string) *string { // ERROR "leaking param: x to result ~r2 level=1$" "leaking param content: y$"
	x[0] = *y
	return x[1]
}

func fuo(x *U, y *U) *string { // ERROR "leaking param: x to result ~r2 level=1$" "leaking param content: y$"
	x[0] = y[0]
	return x[1]
}

// These two tests verify that:
// small array literals are stack allocated;
// pointers stored in small array literals do not escape;
// large array literals are heap allocated;
// pointers stored in large array literals escape.
func hugeLeaks1(x **string, y **string) { // ERROR "leaking param content: x" "hugeLeaks1 y does not escape" "mark escaped content: x"
	a := [10]*string{*y}
	_ = a
	// 4 x 4,000,000 exceeds MaxStackVarSize, therefore it must be heap allocated if pointers are 4 bytes or larger.
	b := [4000000]*string{*x} // ERROR "moved to heap: b"
	_ = b
}

func hugeLeaks2(x *string, y *string) { // ERROR "leaking param: x" "hugeLeaks2 y does not escape"
	a := [10]*string{y}
	_ = a
	// 4 x 4,000,000 exceeds MaxStackVarSize, therefore it must be heap allocated if pointers are 4 bytes or larger.
	b := [4000000]*string{x} // ERROR "moved to heap: b"
	_ = b
}

// BAD: x need not leak.
func doesNew1(x *string, y *string) { // ERROR "leaking param: x" "leaking param: y"
	a := new([10]*string) // ERROR "new\(\[10\]\*string\) does not escape"
	a[0] = x
	b := new([65537]*string) // ERROR "new\(\[65537\]\*string\) escapes to heap"
	b[0] = y
}

type a10 struct {
	s *string
	i [10]int32
}

type a65537 struct {
	s *string
	i [65537]int32
}

// BAD: x need not leak.
func doesNew2(x *string, y *string) { // ERROR "leaking param: x" "leaking param: y"
	a := new(a10) // ERROR "new\(a10\) does not escape"
	a.s = x
	b := new(a65537) // ERROR "new\(a65537\) escapes to heap"
	b.s = y
}

// BAD: x need not leak.
func doesMakeSlice(x *string, y *string) { // ERROR "leaking param: x" "leaking param: y"
	a := make([]*string, 10) // ERROR "make\(\[\]\*string, 10\) does not escape"
	a[0] = x
	b := make([]*string, 65537) // ERROR "make\(\[\]\*string, 65537\) escapes to heap"
	b[0] = y
}
                                                                                                                                                                                                                                                                                                                                                              usr/local/go/test/escape_calls.go                                                                   0100644 0000000 0000000 00000002606 13020111414 015470  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for function parameters.

// In this test almost everything is BAD except the simplest cases
// where input directly flows to output.

package foo

func f(buf []byte) []byte { // ERROR "leaking param: buf to result ~r1 level=0$"
	return buf
}

func g(*byte) string

func h(e int) {
	var x [32]byte // ERROR "moved to heap: x$"
	g(&f(x[:])[0]) // ERROR "&f\(x\[:\]\)\[0\] escapes to heap$" "x escapes to heap$"
}

type Node struct {
	s           string
	left, right *Node
}

func walk(np **Node) int { // ERROR "leaking param content: np"
	n := *np
	w := len(n.s)
	if n == nil {
		return 0
	}
	wl := walk(&n.left)  // ERROR "walk &n.left does not escape"
	wr := walk(&n.right) // ERROR "walk &n.right does not escape"
	if wl < wr {
		n.left, n.right = n.right, n.left
		wl, wr = wr, wl
	}
	*np = n
	return w + wl + wr
}

// Test for bug where func var f used prototype's escape analysis results.
func prototype(xyz []string) {} // ERROR "prototype xyz does not escape"
func bar() {
	var got [][]string
	f := prototype
	f = func(ss []string) { got = append(got, ss) } // ERROR "leaking param: ss" "func literal does not escape"
	s := "string"
	f([]string{s}) // ERROR "\[\]string literal escapes to heap"
}
                                                                                                                          usr/local/go/test/escape_closure.go                                                                 0100644 0000000 0000000 00000012445 13020111414 016050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for closure arguments.

package escape

var sink interface{}

func ClosureCallArgs0() {
	x := 0         // ERROR "moved to heap: x"
	func(p *int) { // ERROR "p does not escape" "func literal does not escape"
		*p = 1
		// BAD: x should not escape to heap here
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs1() {
	x := 0 // ERROR "moved to heap: x"
	for {
		func(p *int) { // ERROR "p does not escape" "func literal does not escape"
			*p = 1
			// BAD: x should not escape to heap here
		}(&x) // ERROR "&x escapes to heap"
	}
}

func ClosureCallArgs2() {
	for {
		// BAD: x should not escape here
		x := 0         // ERROR "moved to heap: x"
		func(p *int) { // ERROR "p does not escape" "func literal does not escape"
			*p = 1
		}(&x) // ERROR "&x escapes to heap"
	}
}

func ClosureCallArgs3() {
	x := 0         // ERROR "moved to heap: x"
	func(p *int) { // ERROR "leaking param: p" "func literal does not escape"
		sink = p // ERROR "p escapes to heap"
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs4() {
	// BAD: x should not leak here
	x := 0                  // ERROR "moved to heap: x"
	_ = func(p *int) *int { // ERROR "leaking param: p to result ~r1" "func literal does not escape"
		return p
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs5() {
	x := 0                     // ERROR "moved to heap: x"
	sink = func(p *int) *int { // ERROR "leaking param: p to result ~r1" "func literal does not escape"
		return p
	}(&x) // ERROR "&x escapes to heap" "\(func literal\)\(&x\) escapes to heap"
}

func ClosureCallArgs6() {
	x := 0         // ERROR "moved to heap: x"
	func(p *int) { // ERROR "moved to heap: p" "func literal does not escape"
		sink = &p // ERROR "&p escapes to heap"
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs7() {
	var pp *int
	for {
		x := 0         // ERROR "moved to heap: x"
		func(p *int) { // ERROR "leaking param: p" "func literal does not escape"
			pp = p
		}(&x) // ERROR "&x escapes to heap"
	}
	_ = pp
}

func ClosureCallArgs8() {
	x := 0               // ERROR "moved to heap: x"
	defer func(p *int) { // ERROR "p does not escape" "func literal does not escape"
		*p = 1
		// BAD: x should not escape to heap here
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs9() {
	// BAD: x should not leak
	x := 0 // ERROR "moved to heap: x"
	for {
		defer func(p *int) { // ERROR "func literal escapes to heap" "p does not escape"
			*p = 1
		}(&x) // ERROR "&x escapes to heap"
	}
}

func ClosureCallArgs10() {
	for {
		x := 0               // ERROR "moved to heap: x"
		defer func(p *int) { // ERROR "func literal escapes to heap" "p does not escape"
			*p = 1
		}(&x) // ERROR "&x escapes to heap"
	}
}

func ClosureCallArgs11() {
	x := 0               // ERROR "moved to heap: x"
	defer func(p *int) { // ERROR "leaking param: p" "func literal does not escape"
		sink = p // ERROR "p escapes to heap"
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs12() {
	// BAD: x should not leak
	x := 0                    // ERROR "moved to heap: x"
	defer func(p *int) *int { // ERROR "leaking param: p to result ~r1" "func literal does not escape"
		return p
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs13() {
	x := 0               // ERROR "moved to heap: x"
	defer func(p *int) { // ERROR "moved to heap: p" "func literal does not escape"
		sink = &p // ERROR "&p escapes to heap"
	}(&x) // ERROR "&x escapes to heap"
}

func ClosureCallArgs14() {
	x := 0 // ERROR "moved to heap: x"
	// BAD: &x should not escape here
	p := &x                  // ERROR "moved to heap: p" "&x escapes to heap"
	_ = func(p **int) *int { // ERROR "leaking param: p to result ~r1 level=1" "func literal does not escape"
		return *p
		// BAD: p should not escape here
	}(&p) // ERROR "&p escapes to heap"
}

func ClosureCallArgs15() {
	x := 0                      // ERROR "moved to heap: x"
	p := &x                     // ERROR "moved to heap: p" "&x escapes to heap"
	sink = func(p **int) *int { // ERROR "leaking param: p to result ~r1 level=1" "func literal does not escape"
		return *p
		// BAD: p should not escape here
	}(&p) // ERROR "&p escapes to heap" "\(func literal\)\(&p\) escapes to heap"
}

func ClosureLeak1(s string) string { // ERROR "ClosureLeak1 s does not escape"
	t := s + "YYYY"         // ERROR "escapes to heap"
	return ClosureLeak1a(t) // ERROR "ClosureLeak1 ... argument does not escape"
}

// See #14409 -- returning part of captured var leaks it.
func ClosureLeak1a(a ...string) string { // ERROR "leaking param: a to result ~r1 level=1"
	return func() string { // ERROR "ClosureLeak1a func literal does not escape"
		return a[0]
	}()
}

func ClosureLeak2(s string) string { // ERROR "ClosureLeak2 s does not escape"
	t := s + "YYYY"       // ERROR "escapes to heap"
	c := ClosureLeak2a(t) // ERROR "ClosureLeak2 ... argument does not escape"
	return c
}
func ClosureLeak2a(a ...string) string { // ERROR "leaking param: a to result ~r1 level=1"
	return ClosureLeak2b(func() string { // ERROR "ClosureLeak2a func literal does not escape"
		return a[0]
	})
}
func ClosureLeak2b(f func() string) string { // ERROR "leaking param: f to result ~r1 level=1"
	return f()
}
                                                                                                                                                                                                                           usr/local/go/test/escape_field.go                                                                   0100644 0000000 0000000 00000010022 13020111414 015444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis with respect to field assignments.

package escape

var sink interface{}

type X struct {
	p1 *int
	p2 *int
	a  [2]*int
}

type Y struct {
	x X
}

func field0() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	x.p1 = &i   // ERROR "&i escapes to heap$"
	sink = x.p1 // ERROR "x\.p1 escapes to heap"
}

func field1() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	// BAD: &i should not escape
	x.p1 = &i   // ERROR "&i escapes to heap$"
	sink = x.p2 // ERROR "x\.p2 escapes to heap"
}

func field3() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	x.p1 = &i // ERROR "&i escapes to heap$"
	sink = x  // ERROR "x escapes to heap"
}

func field4() {
	i := 0 // ERROR "moved to heap: i$"
	var y Y
	y.x.p1 = &i // ERROR "&i escapes to heap$"
	x := y.x
	sink = x // ERROR "x escapes to heap"
}

func field5() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	// BAD: &i should not escape here
	x.a[0] = &i   // ERROR "&i escapes to heap$"
	sink = x.a[1] // ERROR "x\.a\[1\] escapes to heap"
}

// BAD: we are not leaking param x, only x.p2
func field6(x *X) { // ERROR "leaking param content: x$"
	sink = x.p2 // ERROR "x\.p2 escapes to heap"
}

func field6a() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	// BAD: &i should not escape
	x.p1 = &i  // ERROR "&i escapes to heap$"
	field6(&x) // ERROR "field6a &x does not escape"
}

func field7() {
	i := 0
	var y Y
	y.x.p1 = &i // ERROR "field7 &i does not escape$"
	x := y.x
	var y1 Y
	y1.x = x
	_ = y1.x.p1
}

func field8() {
	i := 0 // ERROR "moved to heap: i$"
	var y Y
	y.x.p1 = &i // ERROR "&i escapes to heap$"
	x := y.x
	var y1 Y
	y1.x = x
	sink = y1.x.p1 // ERROR "y1\.x\.p1 escapes to heap"
}

func field9() {
	i := 0 // ERROR "moved to heap: i$"
	var y Y
	y.x.p1 = &i // ERROR "&i escapes to heap$"
	x := y.x
	var y1 Y
	y1.x = x
	sink = y1.x // ERROR "y1\.x escapes to heap"
}

func field10() {
	i := 0 // ERROR "moved to heap: i$"
	var y Y
	// BAD: &i should not escape
	y.x.p1 = &i // ERROR "&i escapes to heap$"
	x := y.x
	var y1 Y
	y1.x = x
	sink = y1.x.p2 // ERROR "y1\.x\.p2 escapes to heap"
}

func field11() {
	i := 0         // ERROR "moved to heap: i$"
	x := X{p1: &i} // ERROR "&i escapes to heap$"
	sink = x.p1    // ERROR "x\.p1 escapes to heap"
}

func field12() {
	i := 0 // ERROR "moved to heap: i$"
	// BAD: &i should not escape
	x := X{p1: &i} // ERROR "&i escapes to heap$"
	sink = x.p2    // ERROR "x\.p2 escapes to heap"
}

func field13() {
	i := 0          // ERROR "moved to heap: i$"
	x := &X{p1: &i} // ERROR "&i escapes to heap$" "field13 &X literal does not escape$"
	sink = x.p1     // ERROR "x\.p1 escapes to heap"
}

func field14() {
	i := 0 // ERROR "moved to heap: i$"
	// BAD: &i should not escape
	x := &X{p1: &i} // ERROR "&i escapes to heap$" "field14 &X literal does not escape$"
	sink = x.p2     // ERROR "x\.p2 escapes to heap"
}

func field15() {
	i := 0          // ERROR "moved to heap: i$"
	x := &X{p1: &i} // ERROR "&X literal escapes to heap$" "&i escapes to heap$"
	sink = x        // ERROR "x escapes to heap"
}

func field16() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	// BAD: &i should not escape
	x.p1 = &i                 // ERROR "&i escapes to heap$"
	var iface interface{} = x // ERROR "x escapes to heap"
	x1 := iface.(X)
	sink = x1.p2 // ERROR "x1\.p2 escapes to heap"
}

func field17() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	x.p1 = &i                 // ERROR "&i escapes to heap$"
	var iface interface{} = x // ERROR "x escapes to heap"
	x1 := iface.(X)
	sink = x1.p1 // ERROR "x1\.p1 escapes to heap"
}

func field18() {
	i := 0 // ERROR "moved to heap: i$"
	var x X
	// BAD: &i should not escape
	x.p1 = &i                 // ERROR "&i escapes to heap$"
	var iface interface{} = x // ERROR "x escapes to heap"
	y, _ := iface.(Y)         // Put X, but extracted Y. The cast will fail, so y is zero initialized.
	sink = y                  // ERROR "y escapes to heap"
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/go/test/escape_iface.go                                                                   0100644 0000000 0000000 00000012302 13020111414 015433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for interface conversions.

package escape

var sink interface{}

type M interface {
	M()
}

func mescapes(m M) { // ERROR "leaking param: m"
	sink = m // ERROR "m escapes to heap"
}

func mdoesnotescape(m M) { // ERROR "m does not escape"
}

// Tests for type stored directly in iface and with value receiver method.
type M0 struct {
	p *int
}

func (M0) M() {
}

func efaceEscape0() {
	{
		i := 0
		v := M0{&i} // ERROR "&i does not escape"
		var x M = v // ERROR "v does not escape"
		_ = x
	}
	{
		i := 0      // ERROR "moved to heap: i"
		v := M0{&i} // ERROR "&i escapes to heap"
		var x M = v // ERROR "v escapes to heap"
		sink = x    // ERROR "x escapes to heap"
	}
	{
		i := 0
		v := M0{&i} // ERROR "&i does not escape"
		var x M = v // ERROR "v does not escape"
		v1 := x.(M0)
		_ = v1
	}
	{
		i := 0      // ERROR "moved to heap: i"
		v := M0{&i} // ERROR "&i escapes to heap"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v escapes to heap"
		v1 := x.(M0)
		sink = v1 // ERROR "v1 escapes to heap"
	}
	{
		i := 0      // ERROR "moved to heap: i"
		v := M0{&i} // ERROR "&i escapes to heap"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v escapes to heap"
		x.M()
	}
	{
		i := 0      // ERROR "moved to heap: i"
		v := M0{&i} // ERROR "&i escapes to heap"
		var x M = v // ERROR "v escapes to heap"
		mescapes(x)
	}
	{
		i := 0
		v := M0{&i} // ERROR "&i does not escape"
		var x M = v // ERROR "v does not escape"
		mdoesnotescape(x)
	}
}

// Tests for type stored indirectly in iface and with value receiver method.
type M1 struct {
	p *int
	x int
}

func (M1) M() {
}

func efaceEscape1() {
	{
		i := 0
		v := M1{&i, 0} // ERROR "&i does not escape"
		var x M = v    // ERROR "v does not escape"
		_ = x
	}
	{
		i := 0         // ERROR "moved to heap: i"
		v := M1{&i, 0} // ERROR "&i escapes to heap"
		var x M = v    // ERROR "v escapes to heap"
		sink = x       // ERROR "x escapes to heap"
	}
	{
		i := 0
		v := M1{&i, 0} // ERROR "&i does not escape"
		var x M = v    // ERROR "v does not escape"
		v1 := x.(M1)
		_ = v1
	}
	{
		i := 0         // ERROR "moved to heap: i"
		v := M1{&i, 0} // ERROR "&i escapes to heap"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v escapes to heap"
		v1 := x.(M1)
		sink = v1 // ERROR "v1 escapes to heap"
	}
	{
		i := 0         // ERROR "moved to heap: i"
		v := M1{&i, 0} // ERROR "&i escapes to heap"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v escapes to heap"
		x.M()
	}
	{
		i := 0         // ERROR "moved to heap: i"
		v := M1{&i, 0} // ERROR "&i escapes to heap"
		var x M = v    // ERROR "v escapes to heap"
		mescapes(x)
	}
	{
		i := 0
		v := M1{&i, 0} // ERROR "&i does not escape"
		var x M = v    // ERROR "v does not escape"
		mdoesnotescape(x)
	}
}

// Tests for type stored directly in iface and with pointer receiver method.
type M2 struct {
	p *int
}

func (*M2) M() {
}

func efaceEscape2() {
	{
		i := 0
		v := &M2{&i} // ERROR "&i does not escape" "&M2 literal does not escape"
		var x M = v  // ERROR "v does not escape"
		_ = x
	}
	{
		i := 0       // ERROR "moved to heap: i"
		v := &M2{&i} // ERROR "&i escapes to heap" "&M2 literal escapes to heap"
		var x M = v  // ERROR "v escapes to heap"
		sink = x     // ERROR "x escapes to heap"
	}
	{
		i := 0
		v := &M2{&i} // ERROR "&i does not escape" "&M2 literal does not escape"
		var x M = v  // ERROR "v does not escape"
		v1 := x.(*M2)
		_ = v1
	}
	{
		i := 0       // ERROR "moved to heap: i"
		v := &M2{&i} // ERROR "&i escapes to heap" "&M2 literal escapes to heap"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v escapes to heap"
		v1 := x.(*M2)
		sink = v1 // ERROR "v1 escapes to heap"
	}
	{
		i := 0       // ERROR "moved to heap: i"
		v := &M2{&i} // ERROR "&i escapes to heap" "&M2 literal does not escape"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v does not escape"
		v1 := x.(*M2)
		sink = *v1 // ERROR "v1 escapes to heap"
	}
	{
		i := 0       // ERROR "moved to heap: i"
		v := &M2{&i} // ERROR "&i escapes to heap" "&M2 literal does not escape"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v does not escape"
		v1, ok := x.(*M2)
		sink = *v1 // ERROR "v1 escapes to heap"
		_ = ok
	}
	{
		i := 0       // ERROR "moved to heap: i"
		v := &M2{&i} // ERROR "&i escapes to heap" "&M2 literal escapes to heap"
		// BAD: v does not escape to heap here
		var x M = v // ERROR "v escapes to heap"
		x.M()
	}
	{
		i := 0       // ERROR "moved to heap: i"
		v := &M2{&i} // ERROR "&i escapes to heap" "&M2 literal escapes to heap"
		var x M = v  // ERROR "v escapes to heap"
		mescapes(x)
	}
	{
		i := 0
		v := &M2{&i} // ERROR "&i does not escape" "&M2 literal does not escape"
		var x M = v  // ERROR "v does not escape"
		mdoesnotescape(x)
	}
}

type T1 struct {
	p *int
}

type T2 struct {
	T1 T1
}

func dotTypeEscape() *T2 { // #11931
	var x interface{}
	x = &T1{p: new(int)} // ERROR "new\(int\) escapes to heap" "&T1 literal does not escape"
	return &T2{
		T1: *(x.(*T1)), // ERROR "&T2 literal escapes to heap"
	}
}
                                                                                                                                                                                                                                                                                                                              usr/local/go/test/escape_indir.go                                                                   0100644 0000000 0000000 00000010234 13020111414 015473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis when assigning to indirections.

package escape

var sink interface{}

type ConstPtr struct {
	p *int
	c ConstPtr2
	x **ConstPtr
}

type ConstPtr2 struct {
	p *int
	i int
}

func constptr0() {
	i := 0           // ERROR "moved to heap: i"
	x := &ConstPtr{} // ERROR "&ConstPtr literal does not escape"
	// BAD: i should not escape here
	x.p = &i // ERROR "&i escapes to heap"
	_ = x
}

func constptr01() *ConstPtr {
	i := 0           // ERROR "moved to heap: i"
	x := &ConstPtr{} // ERROR "&ConstPtr literal escapes to heap"
	x.p = &i         // ERROR "&i escapes to heap"
	return x
}

func constptr02() ConstPtr {
	i := 0           // ERROR "moved to heap: i"
	x := &ConstPtr{} // ERROR "&ConstPtr literal does not escape"
	x.p = &i         // ERROR "&i escapes to heap"
	return *x
}

func constptr03() **ConstPtr {
	i := 0           // ERROR "moved to heap: i"
	x := &ConstPtr{} // ERROR "&ConstPtr literal escapes to heap" "moved to heap: x"
	x.p = &i         // ERROR "&i escapes to heap"
	return &x        // ERROR "&x escapes to heap"
}

func constptr1() {
	i := 0           // ERROR "moved to heap: i"
	x := &ConstPtr{} // ERROR "&ConstPtr literal escapes to heap"
	x.p = &i         // ERROR "&i escapes to heap"
	sink = x         // ERROR "x escapes to heap"
}

func constptr2() {
	i := 0           // ERROR "moved to heap: i"
	x := &ConstPtr{} // ERROR "&ConstPtr literal does not escape"
	x.p = &i         // ERROR "&i escapes to heap"
	sink = *x        // ERROR "\*x escapes to heap"
}

func constptr4() *ConstPtr {
	p := new(ConstPtr) // ERROR "new\(ConstPtr\) escapes to heap"
	*p = *&ConstPtr{}  // ERROR "&ConstPtr literal does not escape"
	return p
}

func constptr5() *ConstPtr {
	p := new(ConstPtr) // ERROR "new\(ConstPtr\) escapes to heap"
	p1 := &ConstPtr{}  // ERROR "&ConstPtr literal does not escape"
	*p = *p1
	return p
}

// BAD: p should not escape here
func constptr6(p *ConstPtr) { // ERROR "leaking param content: p"
	p1 := &ConstPtr{} // ERROR "&ConstPtr literal does not escape"
	*p1 = *p
	_ = p1
}

func constptr7() **ConstPtr {
	p := new(ConstPtr) // ERROR "new\(ConstPtr\) escapes to heap" "moved to heap: p"
	var tmp ConstPtr2
	p1 := &tmp // ERROR "&tmp does not escape"
	p.c = *p1
	return &p // ERROR "&p escapes to heap"
}

func constptr8() *ConstPtr {
	p := new(ConstPtr) // ERROR "new\(ConstPtr\) escapes to heap"
	var tmp ConstPtr2
	p.c = *&tmp // ERROR "&tmp does not escape"
	return p
}

func constptr9() ConstPtr {
	p := new(ConstPtr) // ERROR "new\(ConstPtr\) does not escape"
	var p1 ConstPtr2
	i := 0    // ERROR "moved to heap: i"
	p1.p = &i // ERROR "&i escapes to heap"
	p.c = p1
	return *p
}

func constptr10() ConstPtr {
	x := &ConstPtr{} // ERROR "moved to heap: x" "&ConstPtr literal escapes to heap"
	i := 0           // ERROR "moved to heap: i"
	var p *ConstPtr
	p = &ConstPtr{p: &i, x: &x} // ERROR "&i escapes to heap" "&x escapes to heap" "&ConstPtr literal does not escape"
	var pp **ConstPtr
	pp = &p // ERROR "&p does not escape"
	return **pp
}

func constptr11() *ConstPtr {
	i := 0             // ERROR "moved to heap: i"
	p := new(ConstPtr) // ERROR "new\(ConstPtr\) escapes to heap"
	p1 := &ConstPtr{}  // ERROR "&ConstPtr literal does not escape"
	p1.p = &i          // ERROR "&i escapes to heap"
	*p = *p1
	return p
}

func foo(p **int) { // ERROR "foo p does not escape"
	i := 0 // ERROR "moved to heap: i"
	y := p
	*y = &i // ERROR "&i escapes to heap"
}

func foo1(p *int) { // ERROR "p does not escape"
	i := 0  // ERROR "moved to heap: i"
	y := &p // ERROR "&p does not escape"
	*y = &i // ERROR "&i escapes to heap"
}

func foo2() {
	type Z struct {
		f **int
	}
	x := new(int) // ERROR "moved to heap: x" "new\(int\) escapes to heap"
	sink = &x     // ERROR "&x escapes to heap"
	var z Z
	z.f = &x // ERROR "&x does not escape"
	p := z.f
	i := 0  // ERROR "moved to heap: i"
	*p = &i // ERROR "&i escapes to heap"
}

var global *byte

func f() {
	var x byte    // ERROR "moved to heap: x"
	global = &*&x // ERROR "&\(\*\(&x\)\) escapes to heap" "&x escapes to heap"
}
                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/test/escape_level.go                                                                   0100644 0000000 0000000 00000005605 13020111414 015503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test indirection level computation in escape analysis.

package escape

var sink interface{}

func level0() {
	i := 0     // ERROR "moved to heap: i"
	p0 := &i   // ERROR "moved to heap: p0" "&i escapes to heap"
	p1 := &p0  // ERROR "moved to heap: p1" "&p0 escapes to heap"
	p2 := &p1  // ERROR "moved to heap: p2" "&p1 escapes to heap"
	sink = &p2 // ERROR "&p2 escapes to heap"
}

func level1() {
	i := 0    // ERROR "moved to heap: i"
	p0 := &i  // ERROR "moved to heap: p0" "&i escapes to heap"
	p1 := &p0 // ERROR "moved to heap: p1" "&p0 escapes to heap"
	p2 := &p1 // ERROR "&p1 escapes to heap"
	sink = p2 // ERROR "p2 escapes to heap"
}

func level2() {
	i := 0     // ERROR "moved to heap: i"
	p0 := &i   // ERROR "moved to heap: p0" "&i escapes to heap"
	p1 := &p0  // ERROR "&p0 escapes to heap"
	p2 := &p1  // ERROR "&p1 does not escape"
	sink = *p2 // ERROR "\*p2 escapes to heap"
}

func level3() {
	i := 0      // ERROR "moved to heap: i"
	p0 := &i    // ERROR "&i escapes to heap"
	p1 := &p0   // ERROR "&p0 does not escape"
	p2 := &p1   // ERROR "&p1 does not escape"
	sink = **p2 // ERROR "\* \(\*p2\) escapes to heap"
}

func level4() {
	i := 0     // ERROR "moved to heap: i"
	p0 := &i   // ERROR "moved to heap: p0" "&i escapes to heap"
	p1 := &p0  // ERROR "&p0 escapes to heap"
	p2 := p1   // ERROR "moved to heap: p2"
	sink = &p2 // ERROR "&p2 escapes to heap"
}

func level5() {
	i := 0    // ERROR "moved to heap: i"
	p0 := &i  // ERROR "moved to heap: p0" "&i escapes to heap"
	p1 := &p0 // ERROR "&p0 escapes to heap"
	p2 := p1
	sink = p2 // ERROR "p2 escapes to heap"
}

func level6() {
	i := 0    // ERROR "moved to heap: i"
	p0 := &i  // ERROR "&i escapes to heap"
	p1 := &p0 // ERROR "&p0 does not escape"
	p2 := p1
	sink = *p2 // ERROR "\*p2 escapes to heap"
}

func level7() {
	i := 0    // ERROR "moved to heap: i"
	p0 := &i  // ERROR "&i escapes to heap"
	p1 := &p0 // ERROR "&p0 does not escape"
	// note *p1 == &i
	p2 := *p1  // ERROR "moved to heap: p2"
	sink = &p2 // ERROR "&p2 escapes to heap"
}

func level8() {
	i := 0    // ERROR "moved to heap: i"
	p0 := &i  // ERROR "&i escapes to heap"
	p1 := &p0 // ERROR "&p0 does not escape"
	p2 := *p1
	sink = p2 // ERROR "p2 escapes to heap"
}

func level9() {
	i := 0
	p0 := &i  // ERROR "&i does not escape"
	p1 := &p0 // ERROR "&p0 does not escape"
	p2 := *p1
	sink = *p2 // ERROR "\*p2 escapes to heap"
}

func level10() {
	i := 0
	p0 := &i // ERROR "&i does not escape"
	p1 := *p0
	p2 := &p1  // ERROR "&p1 does not escape"
	sink = *p2 // ERROR "\*p2 escapes to heap"
}

func level11() {
	i := 0
	p0 := &i   // ERROR "&i does not escape"
	p1 := &p0  // ERROR "&p0 does not escape"
	p2 := **p1 // ERROR "moved to heap: p2"
	sink = &p2 // ERROR "&p2 escapes to heap"
}
                                                                                                                           usr/local/go/test/escape_map.go                                                                     0100644 0000000 0000000 00000006474 13020111414 015156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for maps.

package escape

var sink interface{}

func map0() {
	m := make(map[*int]*int) // ERROR "make\(map\[\*int\]\*int\) does not escape"
	// BAD: i should not escape
	i := 0 // ERROR "moved to heap: i"
	// BAD: j should not escape
	j := 0     // ERROR "moved to heap: j"
	m[&i] = &j // ERROR "&i escapes to heap" "&j escapes to heap"
	_ = m
}

func map1() *int {
	m := make(map[*int]*int) // ERROR "make\(map\[\*int\]\*int\) does not escape"
	// BAD: i should not escape
	i := 0       // ERROR "moved to heap: i"
	j := 0       // ERROR "moved to heap: j"
	m[&i] = &j   // ERROR "&i escapes to heap" "&j escapes to heap"
	return m[&i] // ERROR "&i does not escape"
}

func map2() map[*int]*int {
	m := make(map[*int]*int) // ERROR "make\(map\[\*int\]\*int\) escapes to heap"
	i := 0                   // ERROR "moved to heap: i"
	j := 0                   // ERROR "moved to heap: j"
	m[&i] = &j               // ERROR "&i escapes to heap" "&j escapes to heap"
	return m
}

func map3() []*int {
	m := make(map[*int]*int) // ERROR "make\(map\[\*int\]\*int\) does not escape"
	i := 0                   // ERROR "moved to heap: i"
	// BAD: j should not escape
	j := 0     // ERROR "moved to heap: j"
	m[&i] = &j // ERROR "&i escapes to heap" "&j escapes to heap"
	var r []*int
	for k := range m {
		r = append(r, k)
	}
	return r
}

func map4() []*int {
	m := make(map[*int]*int) // ERROR "make\(map\[\*int\]\*int\) does not escape"
	// BAD: i should not escape
	i := 0     // ERROR "moved to heap: i"
	j := 0     // ERROR "moved to heap: j"
	m[&i] = &j // ERROR "&i escapes to heap" "&j escapes to heap"
	var r []*int
	for k, v := range m {
		// We want to test exactly "for k, v := range m" rather than "for _, v := range m".
		// The following if is merely to use (but not leak) k.
		if k != nil {
			r = append(r, v)
		}
	}
	return r
}

func map5(m map[*int]*int) { // ERROR "m does not escape"
	i := 0     // ERROR "moved to heap: i"
	j := 0     // ERROR "moved to heap: j"
	m[&i] = &j // ERROR "&i escapes to heap" "&j escapes to heap"
}

func map6(m map[*int]*int) { // ERROR "m does not escape"
	if m != nil {
		m = make(map[*int]*int) // ERROR "make\(map\[\*int\]\*int\) does not escape"
	}
	i := 0     // ERROR "moved to heap: i"
	j := 0     // ERROR "moved to heap: j"
	m[&i] = &j // ERROR "&i escapes to heap" "&j escapes to heap"
}

func map7() {
	// BAD: i should not escape
	i := 0 // ERROR "moved to heap: i"
	// BAD: j should not escape
	j := 0                     // ERROR "moved to heap: j"
	m := map[*int]*int{&i: &j} // ERROR "&i escapes to heap" "&j escapes to heap" "literal does not escape"
	_ = m
}

func map8() {
	i := 0                     // ERROR "moved to heap: i"
	j := 0                     // ERROR "moved to heap: j"
	m := map[*int]*int{&i: &j} // ERROR "&i escapes to heap" "&j escapes to heap" "literal escapes to heap"
	sink = m // ERROR "m escapes to heap"
}

func map9() *int {
	// BAD: i should not escape
	i := 0                     // ERROR "moved to heap: i"
	j := 0                     // ERROR "moved to heap: j"
	m := map[*int]*int{&i: &j} // ERROR "&i escapes to heap" "&j escapes to heap" "literal does not escape"
	return m[nil]
}
                                                                                                                                                                                                    usr/local/go/test/escape_param.go                                                                   0100644 0000000 0000000 00000022735 13020111414 015477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for function parameters.

// In this test almost everything is BAD except the simplest cases
// where input directly flows to output.

package escape

var sink interface{}

// in -> out
func param0(p *int) *int { // ERROR "leaking param: p to result ~r1"
	return p
}

func caller0a() {
	i := 0
	_ = param0(&i) // ERROR "caller0a &i does not escape$"
}

func caller0b() {
	i := 0            // ERROR "moved to heap: i$"
	sink = param0(&i) // ERROR "&i escapes to heap$" "param0\(&i\) escapes to heap"
}

// in, in -> out, out
func param1(p1, p2 *int) (*int, *int) { // ERROR "leaking param: p1 to result ~r2" "leaking param: p2 to result ~r3"
	return p1, p2
}

func caller1() {
	i := 0 // ERROR "moved to heap: i$"
	j := 0
	sink, _ = param1(&i, &j) // ERROR "&i escapes to heap$" "caller1 &j does not escape$"
}

// in -> other in
func param2(p1 *int, p2 **int) { // ERROR "leaking param: p1$" "param2 p2 does not escape$"
	*p2 = p1
}

func caller2a() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	param2(&i, &p) // ERROR "&i escapes to heap$" "caller2a &p does not escape$"
	_ = p
}

func caller2b() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	param2(&i, &p) // ERROR "&i escapes to heap$" "caller2b &p does not escape$"
	sink = p       // ERROR "p escapes to heap$"
}

// in -> in
type Pair struct {
	p1 *int
	p2 *int
}

func param3(p *Pair) { // ERROR "leaking param content: p$"
	p.p1 = p.p2
}

func caller3a() {
	i := 0            // ERROR "moved to heap: i$"
	j := 0            // ERROR "moved to heap: j$"
	p := Pair{&i, &j} // ERROR "&i escapes to heap$" "&j escapes to heap$"
	param3(&p)        // ERROR "caller3a &p does not escape"
	_ = p
}

func caller3b() {
	i := 0            // ERROR "moved to heap: i$"
	j := 0            // ERROR "moved to heap: j$"
	p := Pair{&i, &j} // ERROR "&i escapes to heap$" "&j escapes to heap$"
	param3(&p)        // ERROR "caller3b &p does not escape"
	sink = p          // ERROR "p escapes to heap$"
}

// in -> rcvr
func (p *Pair) param4(i *int) { // ERROR "\(\*Pair\).param4 p does not escape$" "leaking param: i$"
	p.p1 = i
}

func caller4a() {
	i := 0 // ERROR "moved to heap: i$"
	p := Pair{}
	p.param4(&i) // ERROR "&i escapes to heap$" "caller4a p does not escape$"
	_ = p
}

func caller4b() {
	i := 0 // ERROR "moved to heap: i$"
	p := Pair{}
	p.param4(&i) // ERROR "&i escapes to heap$" "caller4b p does not escape$"
	sink = p     // ERROR "p escapes to heap$"
}

// in -> heap
func param5(i *int) { // ERROR "leaking param: i$"
	sink = i // ERROR "i escapes to heap$"
}

func caller5() {
	i := 0     // ERROR "moved to heap: i$"
	param5(&i) // ERROR "&i escapes to heap$"
}

// *in -> heap
func param6(i ***int) { // ERROR "leaking param content: i$"
	sink = *i // ERROR "\*i escapes to heap$"
}

func caller6a() {
	i := 0      // ERROR "moved to heap: i$"
	p := &i     // ERROR "&i escapes to heap$" "moved to heap: p$"
	p2 := &p    // ERROR "&p escapes to heap$"
	param6(&p2) // ERROR "caller6a &p2 does not escape"
}

// **in -> heap
func param7(i ***int) { // ERROR "leaking param content: i$"
	sink = **i // ERROR "\* \(\*i\) escapes to heap"
}

func caller7() {
	i := 0      // ERROR "moved to heap: i$"
	p := &i     // ERROR "&i escapes to heap$" "moved to heap: p$"
	p2 := &p    // ERROR "&p escapes to heap$"
	param7(&p2) // ERROR "caller7 &p2 does not escape"
}

// **in -> heap
func param8(i **int) { // ERROR "param8 i does not escape$"
	sink = **i // ERROR "\* \(\*i\) escapes to heap"
}

func caller8() {
	i := 0
	p := &i    // ERROR "caller8 &i does not escape$"
	param8(&p) // ERROR "caller8 &p does not escape$"
}

// *in -> out
func param9(p ***int) **int { // ERROR "leaking param: p to result ~r1 level=1"
	return *p
}

func caller9a() {
	i := 0
	p := &i         // ERROR "caller9a &i does not escape"
	p2 := &p        // ERROR "caller9a &p does not escape"
	_ = param9(&p2) // ERROR "caller9a &p2 does not escape$"
}

func caller9b() {
	i := 0             // ERROR "moved to heap: i$"
	p := &i            // ERROR "&i escapes to heap$" "moved to heap: p$"
	p2 := &p           // ERROR "&p escapes to heap$"
	sink = param9(&p2) // ERROR "caller9b &p2 does not escape$"  "param9\(&p2\) escapes to heap"
}

// **in -> out
func param10(p ***int) *int { // ERROR "leaking param: p to result ~r1 level=2"
	return **p
}

func caller10a() {
	i := 0
	p := &i          // ERROR "caller10a &i does not escape"
	p2 := &p         // ERROR "caller10a &p does not escape"
	_ = param10(&p2) // ERROR "caller10a &p2 does not escape$"
}

func caller10b() {
	i := 0              // ERROR "moved to heap: i$"
	p := &i             // ERROR "&i escapes to heap$"
	p2 := &p            // ERROR "caller10b &p does not escape$"
	sink = param10(&p2) // ERROR "caller10b &p2 does not escape$" "param10\(&p2\) escapes to heap"
}

// in escapes to heap (address of param taken and returned)
func param11(i **int) ***int { // ERROR "moved to heap: i$"
	return &i // ERROR "&i escapes to heap$"
}

func caller11a() {
	i := 0          // ERROR "moved to heap: i"
	p := &i         // ERROR "moved to heap: p" "&i escapes to heap"
	_ = param11(&p) // ERROR "&p escapes to heap"
}

func caller11b() {
	i := 0             // ERROR "moved to heap: i$"
	p := &i            // ERROR "&i escapes to heap$" "moved to heap: p$"
	sink = param11(&p) // ERROR "&p escapes to heap$" "param11\(&p\) escapes to heap"
}

func caller11c() { // GOOD
	i := 0              // ERROR "moved to heap: i$"
	p := &i             // ERROR "moved to heap: p" "&i escapes to heap"
	sink = *param11(&p) // ERROR "&p escapes to heap" "\*param11\(&p\) escapes to heap"
}

func caller11d() {
	i := 0             // ERROR "moved to heap: i$"
	p := &i            // ERROR "&i escapes to heap" "moved to heap: p"
	p2 := &p           // ERROR "&p escapes to heap"
	sink = param11(p2) // ERROR "param11\(p2\) escapes to heap"
}

// &in -> rcvr
type Indir struct {
	p ***int
}

func (r *Indir) param12(i **int) { // ERROR "\(\*Indir\).param12 r does not escape$" "moved to heap: i$"
	r.p = &i // ERROR "&i escapes to heap$"
}

func caller12a() {
	i := 0  // ERROR "moved to heap: i$"
	p := &i // ERROR "&i escapes to heap$" "moved to heap: p$"
	var r Indir
	r.param12(&p) // ERROR "&p escapes to heap$" "caller12a r does not escape$"
	_ = r
}

func caller12b() {
	i := 0        // ERROR "moved to heap: i$"
	p := &i       // ERROR "&i escapes to heap$" "moved to heap: p$"
	r := &Indir{} // ERROR "caller12b &Indir literal does not escape$"
	r.param12(&p) // ERROR "&p escapes to heap$"
	_ = r
}

func caller12c() {
	i := 0  // ERROR "moved to heap: i$"
	p := &i // ERROR "&i escapes to heap$" "moved to heap: p$"
	r := Indir{}
	r.param12(&p) // ERROR "&p escapes to heap$" "caller12c r does not escape$"
	sink = r      // ERROR "r escapes to heap$"
}

func caller12d() {
	i := 0  // ERROR "moved to heap: i$"
	p := &i // ERROR "&i escapes to heap$" "moved to heap: p$"
	r := Indir{}
	r.param12(&p) // ERROR "&p escapes to heap$" "caller12d r does not escape$"
	sink = **r.p  // ERROR "\* \(\*r\.p\) escapes to heap"
}

// in -> value rcvr
type Val struct {
	p **int
}

func (v Val) param13(i *int) { // ERROR "Val.param13 v does not escape$" "leaking param: i$"
	*v.p = i
}

func caller13a() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	var v Val
	v.p = &p      // ERROR "caller13a &p does not escape$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	_ = v
}

func caller13b() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	v := Val{&p}  // ERROR "caller13b &p does not escape$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	_ = v
}

func caller13c() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	v := &Val{&p} // ERROR "caller13c &Val literal does not escape$" "caller13c &p does not escape$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	_ = v
}

func caller13d() {
	i := 0     // ERROR "moved to heap: i$"
	var p *int // ERROR "moved to heap: p$"
	var v Val
	v.p = &p      // ERROR "&p escapes to heap$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	sink = v      // ERROR "v escapes to heap$"
}

func caller13e() {
	i := 0        // ERROR "moved to heap: i$"
	var p *int    // ERROR "moved to heap: p$"
	v := Val{&p}  // ERROR "&p escapes to heap$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	sink = v      // ERROR "v escapes to heap$"
}

func caller13f() {
	i := 0        // ERROR "moved to heap: i$"
	var p *int    // ERROR "moved to heap: p$"
	v := &Val{&p} // ERROR "&Val literal escapes to heap$" "&p escapes to heap$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	sink = v      // ERROR "v escapes to heap$"
}

func caller13g() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	v := Val{&p}  // ERROR "caller13g &p does not escape$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	sink = *v.p   // ERROR "\*v\.p escapes to heap"
}

func caller13h() {
	i := 0 // ERROR "moved to heap: i$"
	var p *int
	v := &Val{&p} // ERROR "caller13h &Val literal does not escape$" "caller13h &p does not escape$"
	v.param13(&i) // ERROR "&i escapes to heap$"
	sink = **v.p  // ERROR "\* \(\*v\.p\) escapes to heap"
}

type Node struct {
	p *Node
}

var Sink *Node

func f(x *Node) { // ERROR "leaking param content: x"
	Sink = &Node{x.p} // ERROR "&Node literal escapes to heap"
}

func g(x *Node) *Node { // ERROR "leaking param: x to result ~r1 level=0"
	return &Node{x.p} // ERROR "&Node literal escapes to heap"
}

func h(x *Node) { // ERROR "leaking param: x"
	y := &Node{x} // ERROR "h &Node literal does not escape"
	Sink = g(y)
	f(y)
}
                                   usr/local/go/test/escape_slice.go                                                                   0100644 0000000 0000000 00000007455 13020111414 015500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for slices.

package escape

import (
	"os"
	"strings"
)

var sink interface{}

func slice0() {
	var s []*int
	// BAD: i should not escape
	i := 0            // ERROR "moved to heap: i"
	s = append(s, &i) // ERROR "&i escapes to heap"
	_ = s
}

func slice1() *int {
	var s []*int
	i := 0            // ERROR "moved to heap: i"
	s = append(s, &i) // ERROR "&i escapes to heap"
	return s[0]
}

func slice2() []*int {
	var s []*int
	i := 0            // ERROR "moved to heap: i"
	s = append(s, &i) // ERROR "&i escapes to heap"
	return s
}

func slice3() *int {
	var s []*int
	i := 0            // ERROR "moved to heap: i"
	s = append(s, &i) // ERROR "&i escapes to heap"
	for _, p := range s {
		return p
	}
	return nil
}

func slice4(s []*int) { // ERROR "s does not escape"
	i := 0    // ERROR "moved to heap: i"
	s[0] = &i // ERROR "&i escapes to heap"
}

func slice5(s []*int) { // ERROR "s does not escape"
	if s != nil {
		s = make([]*int, 10) // ERROR "make\(\[\]\*int, 10\) does not escape"
	}
	i := 0    // ERROR "moved to heap: i"
	s[0] = &i // ERROR "&i escapes to heap"
}

func slice6() {
	s := make([]*int, 10) // ERROR "make\(\[\]\*int, 10\) does not escape"
	// BAD: i should not escape
	i := 0    // ERROR "moved to heap: i"
	s[0] = &i // ERROR "&i escapes to heap"
	_ = s
}

func slice7() *int {
	s := make([]*int, 10) // ERROR "make\(\[\]\*int, 10\) does not escape"
	i := 0                // ERROR "moved to heap: i"
	s[0] = &i             // ERROR "&i escapes to heap"
	return s[0]
}

func slice8() {
	i := 0
	s := []*int{&i} // ERROR "&i does not escape" "literal does not escape"
	_ = s
}

func slice9() *int {
	i := 0          // ERROR "moved to heap: i"
	s := []*int{&i} // ERROR "&i escapes to heap" "literal does not escape"
	return s[0]
}

func slice10() []*int {
	i := 0          // ERROR "moved to heap: i"
	s := []*int{&i} // ERROR "&i escapes to heap" "literal escapes to heap"
	return s
}

func envForDir(dir string) []string { // ERROR "dir does not escape"
	env := os.Environ()
	return mergeEnvLists([]string{"PWD=" + dir}, env) // ERROR ".PWD=. \+ dir escapes to heap" "\[\]string literal does not escape"
}

func mergeEnvLists(in, out []string) []string { // ERROR "leaking param content: in" "leaking param content: out" "leaking param: out to result ~r2 level=0"
NextVar:
	for _, inkv := range in {
		k := strings.SplitAfterN(inkv, "=", 2)[0]
		for i, outkv := range out {
			if strings.HasPrefix(outkv, k) {
				out[i] = inkv
				continue NextVar
			}
		}
		out = append(out, inkv)
	}
	return out
}

const (
	IPv4len = 4
	IPv6len = 16
)

var v4InV6Prefix = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff}

func IPv4(a, b, c, d byte) IP {
	p := make(IP, IPv6len) // ERROR "make\(IP, IPv6len\) escapes to heap"
	copy(p, v4InV6Prefix)
	p[12] = a
	p[13] = b
	p[14] = c
	p[15] = d
	return p
}

type IP []byte

type IPAddr struct {
	IP   IP
	Zone string // IPv6 scoped addressing zone
}

type resolveIPAddrTest struct {
	network       string
	litAddrOrName string
	addr          *IPAddr
	err           error
}

var resolveIPAddrTests = []resolveIPAddrTest{
	{"ip", "127.0.0.1", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil},
	{"ip4", "127.0.0.1", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil},
	{"ip4:icmp", "127.0.0.1", &IPAddr{IP: IPv4(127, 0, 0, 1)}, nil},
}

func setupTestData() {
	resolveIPAddrTests = append(resolveIPAddrTests,
		[]resolveIPAddrTest{ // ERROR "\[\]resolveIPAddrTest literal does not escape"
			{"ip",
				"localhost",
				&IPAddr{IP: IPv4(127, 0, 0, 1)}, // ERROR "&IPAddr literal escapes to heap"
				nil},
			{"ip4",
				"localhost",
				&IPAddr{IP: IPv4(127, 0, 0, 1)}, // ERROR "&IPAddr literal escapes to heap"
				nil},
		}...)
}
                                                                                                                                                                                                                   usr/local/go/test/escape_struct_param1.go                                                           0100644 0000000 0000000 00000031557 13020111414 017166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for *struct function parameters.
// Note companion strict_param2 checks struct function parameters with similar tests.

package notmain

var Ssink *string

type U struct {
	_sp  *string
	_spp **string
}

type V struct {
	_u   U
	_up  *U
	_upp **U
}

func (u *U) SP() *string { // ERROR "leaking param: u to result ~r0 level=1$"
	return u._sp
}

func (u *U) SPP() **string { // ERROR "leaking param: u to result ~r0 level=1$"
	return u._spp
}

func (u *U) SPPi() *string { // ERROR "leaking param: u to result ~r0 level=2$"
	return *u._spp
}

func tSPPi() {
	s := "cat"        // ERROR "moved to heap: s$"
	ps := &s          // ERROR "&s escapes to heap$"
	pps := &ps        // ERROR "tSPPi &ps does not escape$"
	pu := &U{ps, pps} // ERROR "tSPPi &U literal does not escape$"
	Ssink = pu.SPPi()
}

func tiSPP() {
	s := "cat"        // ERROR "moved to heap: s$"
	ps := &s          // ERROR "&s escapes to heap$"
	pps := &ps        // ERROR "tiSPP &ps does not escape$"
	pu := &U{ps, pps} // ERROR "tiSPP &U literal does not escape$"
	Ssink = *pu.SPP()
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of ps
func tSP() {
	s := "cat"        // ERROR "moved to heap: s$"
	ps := &s          // ERROR "&s escapes to heap$" "moved to heap: ps$"
	pps := &ps        // ERROR "&ps escapes to heap$"
	pu := &U{ps, pps} // ERROR "tSP &U literal does not escape$"
	Ssink = pu.SP()
}

func (v *V) u() U { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._u
}

func (v *V) UP() *U { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._up
}

func (v *V) UPP() **U { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._upp
}

func (v *V) UPPia() *U { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v._upp
}

func (v *V) UPPib() *U { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v.UPP()
}

func (v *V) USPa() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._u._sp
}

func (v *V) USPb() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v.u()._sp
}

func (v *V) USPPia() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v._u._spp
}

func (v *V) USPPib() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v._u.SPPi() // ERROR "\(\*V\).USPPib v._u does not escape$"
}

func (v *V) UPiSPa() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v._up._sp
}

func (v *V) UPiSPb() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v._up.SP()
}

func (v *V) UPiSPc() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v.UP()._sp
}

func (v *V) UPiSPd() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v.UP().SP()
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPa() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPa &ps2 does not escape$" "tUPiSPa &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPa &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPa &V literal does not escape$" "tUPiSPa &u3 does not escape$"
	Ssink = v.UPiSPa()   // Ssink = &s3 (only &s3 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPb() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPb &ps2 does not escape$" "tUPiSPb &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPb &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPb &V literal does not escape$" "tUPiSPb &u3 does not escape$"
	Ssink = v.UPiSPb()   // Ssink = &s3 (only &s3 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPc() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPc &ps2 does not escape$" "tUPiSPc &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPc &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPc &V literal does not escape$" "tUPiSPc &u3 does not escape$"
	Ssink = v.UPiSPc()   // Ssink = &s3 (only &s3 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPd() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPd &ps2 does not escape$" "tUPiSPd &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPd &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPd &V literal does not escape$" "tUPiSPd &u3 does not escape$"
	Ssink = v.UPiSPd()   // Ssink = &s3 (only &s3 really escapes)
}

func (v V) UPiSPPia() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v._up._spp
}

func (v V) UPiSPPib() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v._up.SPPi()
}

func (v V) UPiSPPic() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v.UP()._spp // ERROR "V.UPiSPPic v does not escape$"
}

func (v V) UPiSPPid() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v.UP().SPPi() // ERROR "V.UPiSPPid v does not escape$"
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPia() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPia &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPia &ps2 does not escape$" "tUPiSPPia &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPia &U literal does not escape$" "tUPiSPPia &ps4 does not escape$" "tUPiSPPia &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPia &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPia &V literal does not escape$" "tUPiSPPia &u3 does not escape$"
	Ssink = v.UPiSPPia() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPib() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPib &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPib &ps2 does not escape$" "tUPiSPPib &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPib &U literal does not escape$" "tUPiSPPib &ps4 does not escape$" "tUPiSPPib &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPib &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPib &V literal does not escape$" "tUPiSPPib &u3 does not escape$"
	Ssink = v.UPiSPPib() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPic() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPic &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPic &ps2 does not escape$" "tUPiSPPic &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPic &U literal does not escape$" "tUPiSPPic &ps4 does not escape$" "tUPiSPPic &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPic &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPic &V literal does not escape$" "tUPiSPPic &u3 does not escape$"
	Ssink = v.UPiSPPic() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPid() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPid &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPid &ps2 does not escape$" "tUPiSPPid &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPid &U literal does not escape$" "tUPiSPPid &ps4 does not escape$" "tUPiSPPid &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPid &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPid &V literal does not escape$" "tUPiSPPid &u3 does not escape$"
	Ssink = v.UPiSPPid() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

func (v *V) UPPiSPPia() *string { // ERROR "leaking param: v to result ~r0 level=4$"
	return *(*v._upp)._spp
}

// This test isolates the one value that needs to escape, not because
// it distinguishes fields but because it knows that &s6 is the only
// value reachable by two indirects from v.
// The test depends on the level cap in the escape analysis tags
// being able to encode that fact.
func tUPPiSPPia() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"
	s5 := "emu"
	s6 := "fox"           // ERROR "moved to heap: s6$"
	ps2 := &s2            // ERROR "tUPPiSPPia &s2 does not escape$"
	ps4 := &s4            // ERROR "tUPPiSPPia &s4 does not escape$"
	ps6 := &s6            // ERROR "&s6 escapes to heap$"
	u1 := U{&s1, &ps2}    // ERROR "tUPPiSPPia &ps2 does not escape$" "tUPPiSPPia &s1 does not escape$"
	u2 := &U{&s3, &ps4}   // ERROR "tUPPiSPPia &U literal does not escape$" "tUPPiSPPia &ps4 does not escape$" "tUPPiSPPia &s3 does not escape$"
	u3 := &U{&s5, &ps6}   // ERROR "tUPPiSPPia &U literal does not escape$" "tUPPiSPPia &ps6 does not escape$" "tUPPiSPPia &s5 does not escape$"
	v := &V{u1, u2, &u3}  // ERROR "tUPPiSPPia &V literal does not escape$" "tUPPiSPPia &u3 does not escape$"
	Ssink = v.UPPiSPPia() // Ssink = *&ps6 = &s6 (only &s6 really escapes)
}
                                                                                                                                                 usr/local/go/test/escape_struct_param2.go                                                           0100644 0000000 0000000 00000031422 13020111414 017156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for struct function parameters.
// Note companion strict_param1 checks *struct function parameters with similar tests.

package notmain

var Ssink *string

type U struct {
	_sp  *string
	_spp **string
}

type V struct {
	_u   U
	_up  *U
	_upp **U
}

func (u U) SP() *string { // ERROR "leaking param: u to result ~r0 level=0$"
	return u._sp
}

func (u U) SPP() **string { // ERROR "leaking param: u to result ~r0 level=0$"
	return u._spp
}

func (u U) SPPi() *string { // ERROR "leaking param: u to result ~r0 level=1$"
	return *u._spp
}

func tSPPi() {
	s := "cat"        // ERROR "moved to heap: s$"
	ps := &s          // ERROR "&s escapes to heap$"
	pps := &ps        // ERROR "tSPPi &ps does not escape$"
	pu := &U{ps, pps} // ERROR "tSPPi &U literal does not escape$"
	Ssink = pu.SPPi()
}

func tiSPP() {
	s := "cat"        // ERROR "moved to heap: s$"
	ps := &s          // ERROR "&s escapes to heap$"
	pps := &ps        // ERROR "tiSPP &ps does not escape$"
	pu := &U{ps, pps} // ERROR "tiSPP &U literal does not escape$"
	Ssink = *pu.SPP()
}

// BAD: need fine-grained analysis to avoid spurious escape of ps
func tSP() {
	s := "cat"        // ERROR "moved to heap: s$"
	ps := &s          // ERROR "&s escapes to heap$" "moved to heap: ps$"
	pps := &ps        // ERROR "&ps escapes to heap$"
	pu := &U{ps, pps} // ERROR "tSP &U literal does not escape$"
	Ssink = pu.SP()
}

func (v V) u() U { // ERROR "leaking param: v to result ~r0 level=0$"
	return v._u
}

func (v V) UP() *U { // ERROR "leaking param: v to result ~r0 level=0$"
	return v._up
}

func (v V) UPP() **U { // ERROR "leaking param: v to result ~r0 level=0$"
	return v._upp
}

func (v V) UPPia() *U { // ERROR "leaking param: v to result ~r0 level=1$"
	return *v._upp
}

func (v V) UPPib() *U { // ERROR "leaking param: v to result ~r0 level=1$"
	return *v.UPP()
}

func (v V) USPa() *string { // ERROR "leaking param: v to result ~r0 level=0$"
	return v._u._sp
}

func (v V) USPb() *string { // ERROR "leaking param: v to result ~r0 level=0$"
	return v.u()._sp
}

func (v V) USPPia() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return *v._u._spp
}

func (v V) USPPib() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._u.SPPi()
}

func (v V) UPiSPa() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._up._sp
}

func (v V) UPiSPb() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v._up.SP()
}

func (v V) UPiSPc() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v.UP()._sp
}

func (v V) UPiSPd() *string { // ERROR "leaking param: v to result ~r0 level=1$"
	return v.UP().SP()
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPa() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPa &ps2 does not escape$" "tUPiSPa &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPa &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPa &V literal does not escape$" "tUPiSPa &u3 does not escape$"
	Ssink = v.UPiSPa()   // Ssink = &s3 (only &s3 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPb() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPb &ps2 does not escape$" "tUPiSPb &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPb &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPb &V literal does not escape$" "tUPiSPb &u3 does not escape$"
	Ssink = v.UPiSPb()   // Ssink = &s3 (only &s3 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPc() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPc &ps2 does not escape$" "tUPiSPc &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPc &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPc &V literal does not escape$" "tUPiSPc &u3 does not escape$"
	Ssink = v.UPiSPc()   // Ssink = &s3 (only &s3 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s3
func tUPiSPd() {
	s1 := "ant"
	s2 := "bat"          // ERROR "moved to heap: s2$"
	s3 := "cat"          // ERROR "moved to heap: s3$"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "&s2 escapes to heap$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$" "moved to heap: ps4$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPd &ps2 does not escape$" "tUPiSPd &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "&ps4 escapes to heap$" "&s3 escapes to heap$" "tUPiSPd &U literal does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&U literal escapes to heap$" "&ps6 escapes to heap$" "&s5 escapes to heap$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPd &V literal does not escape$" "tUPiSPd &u3 does not escape$"
	Ssink = v.UPiSPd()   // Ssink = &s3 (only &s3 really escapes)
}

func (v V) UPiSPPia() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v._up._spp
}

func (v V) UPiSPPib() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v._up.SPPi()
}

func (v V) UPiSPPic() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return *v.UP()._spp
}

func (v V) UPiSPPid() *string { // ERROR "leaking param: v to result ~r0 level=2$"
	return v.UP().SPPi()
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPia() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPia &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPia &ps2 does not escape$" "tUPiSPPia &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPia &U literal does not escape$" "tUPiSPPia &ps4 does not escape$" "tUPiSPPia &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPia &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPia &V literal does not escape$" "tUPiSPPia &u3 does not escape$"
	Ssink = v.UPiSPPia() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPib() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPib &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPib &ps2 does not escape$" "tUPiSPPib &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPib &U literal does not escape$" "tUPiSPPib &ps4 does not escape$" "tUPiSPPib &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPib &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPib &V literal does not escape$" "tUPiSPPib &u3 does not escape$"
	Ssink = v.UPiSPPib() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPic() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPic &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPic &ps2 does not escape$" "tUPiSPPic &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPic &U literal does not escape$" "tUPiSPPic &ps4 does not escape$" "tUPiSPPic &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPic &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPic &V literal does not escape$" "tUPiSPPic &u3 does not escape$"
	Ssink = v.UPiSPPic() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

// BAD: need fine-grained (field-sensitive) analysis to avoid spurious escape of all but &s4
func tUPiSPPid() {
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"          // ERROR "moved to heap: s4$"
	s5 := "emu"          // ERROR "moved to heap: s5$"
	s6 := "fox"          // ERROR "moved to heap: s6$"
	ps2 := &s2           // ERROR "tUPiSPPid &s2 does not escape$"
	ps4 := &s4           // ERROR "&s4 escapes to heap$"
	ps6 := &s6           // ERROR "&s6 escapes to heap$" "moved to heap: ps6$"
	u1 := U{&s1, &ps2}   // ERROR "tUPiSPPid &ps2 does not escape$" "tUPiSPPid &s1 does not escape$"
	u2 := &U{&s3, &ps4}  // ERROR "tUPiSPPid &U literal does not escape$" "tUPiSPPid &ps4 does not escape$" "tUPiSPPid &s3 does not escape$"
	u3 := &U{&s5, &ps6}  // ERROR "&ps6 escapes to heap$" "&s5 escapes to heap$" "tUPiSPPid &U literal does not escape$"
	v := &V{u1, u2, &u3} // ERROR "tUPiSPPid &V literal does not escape$" "tUPiSPPid &u3 does not escape$"
	Ssink = v.UPiSPPid() // Ssink = *&ps4 = &s4 (only &s4 really escapes)
}

func (v V) UPPiSPPia() *string { // ERROR "leaking param: v to result ~r0 level=3$"
	return *(*v._upp)._spp
}

// This test isolates the one value that needs to escape, not because
// it distinguishes fields but because it knows that &s6 is the only
// value reachable by two indirects from v.
// The test depends on the level cap in the escape analysis tags
// being able to encode that fact.
func tUPPiSPPia() { // This test is sensitive to the level cap in function summary results.
	s1 := "ant"
	s2 := "bat"
	s3 := "cat"
	s4 := "dog"
	s5 := "emu"
	s6 := "fox"           // ERROR "moved to heap: s6$"
	ps2 := &s2            // ERROR "tUPPiSPPia &s2 does not escape$"
	ps4 := &s4            // ERROR "tUPPiSPPia &s4 does not escape$"
	ps6 := &s6            // ERROR "&s6 escapes to heap$"
	u1 := U{&s1, &ps2}    // ERROR "tUPPiSPPia &ps2 does not escape$" "tUPPiSPPia &s1 does not escape$"
	u2 := &U{&s3, &ps4}   // ERROR "tUPPiSPPia &U literal does not escape$" "tUPPiSPPia &ps4 does not escape$" "tUPPiSPPia &s3 does not escape$"
	u3 := &U{&s5, &ps6}   // ERROR "tUPPiSPPia &U literal does not escape$" "tUPPiSPPia &ps6 does not escape$" "tUPPiSPPia &s5 does not escape$"
	v := &V{u1, u2, &u3}  // ERROR "tUPPiSPPia &V literal does not escape$" "tUPPiSPPia &u3 does not escape$"
	Ssink = v.UPPiSPPia() // Ssink = *&ps6 = &s6 (only &s6 really escapes)
}
                                                                                                                                                                                                                                              usr/local/go/test/escape_struct_return.go                                                           0100644 0000000 0000000 00000003021 13020111414 017305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck -0 -m -l

// Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test escape analysis for function parameters.

package foo

var Ssink *string

type U struct {
	_sp  *string
	_spp **string
}

func A(sp *string, spp **string) U { // ERROR "leaking param: sp to result ~r2 level=0$" "leaking param: spp to result ~r2 level=0$"
	return U{sp, spp}
}

func B(spp **string) U { // ERROR "leaking param: spp to result ~r1 level=0$" "leaking param: spp to result ~r1 level=1$"
	return U{*spp, spp}
}

func tA1() {
	s := "cat"
	sp := &s   // ERROR "tA1 &s does not escape$"
	spp := &sp // ERROR "tA1 &sp does not escape$"
	u := A(sp, spp)
	_ = u
	println(s)
}

func tA2() {
	s := "cat"
	sp := &s   // ERROR "tA2 &s does not escape$"
	spp := &sp // ERROR "tA2 &sp does not escape$"
	u := A(sp, spp)
	println(*u._sp)
}

func tA3() {
	s := "cat"
	sp := &s   // ERROR "tA3 &s does not escape$"
	spp := &sp // ERROR "tA3 &sp does not escape$"
	u := A(sp, spp)
	println(**u._spp)
}

func tB1() {
	s := "cat"
	sp := &s   // ERROR "tB1 &s does not escape$"
	spp := &sp // ERROR "tB1 &sp does not escape$"
	u := B(spp)
	_ = u
	println(s)
}

func tB2() {
	s := "cat"
	sp := &s   // ERROR "tB2 &s does not escape$"
	spp := &sp // ERROR "tB2 &sp does not escape$"
	u := B(spp)
	println(*u._sp)
}

func tB3() {
	s := "cat"
	sp := &s   // ERROR "tB3 &s does not escape$"
	spp := &sp // ERROR "tB3 &sp does not escape$"
	u := B(spp)
	println(**u._spp)
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/go/test/fibo.go                                                                           0100644 0000000 0000000 00000014434 13020111414 013773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // skip

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Usage:
// fibo <n>     compute fibonacci(n), n must be >= 0
// fibo -bench  benchmark fibonacci computation (takes about 1 min)
//
// Additional flags:
// -half        add values using two half-digit additions
// -opt         optimize memory allocation through reuse
// -short       only print the first 10 digits of very large fibonacci numbers

// Command fibo is a stand-alone test and benchmark to
// evaluate the performance of bignum arithmetic written
// entirely in Go.
package main

import (
	"flag"
	"fmt"
	"math/big" // only used for printing
	"os"
	"strconv"
	"testing"
	"text/tabwriter"
	"time"
)

var (
	bench = flag.Bool("bench", false, "run benchmarks")
	half  = flag.Bool("half", false, "use half-digit addition")
	opt   = flag.Bool("opt", false, "optimize memory usage")
	short = flag.Bool("short", false, "only print first 10 digits of result")
)

// A large natural number is represented by a nat, each "digit" is
// a big.Word; the value zero corresponds to the empty nat slice.
type nat []big.Word

const W = 1 << (5 + ^big.Word(0)>>63) // big.Word size in bits

// The following methods are extracted from math/big to make this a
// stand-alone program that can easily be run without dependencies
// and compiled with different compilers.

func (z nat) make(n int) nat {
	if n <= cap(z) {
		return z[:n] // reuse z
	}
	// Choosing a good value for e has significant performance impact
	// because it increases the chance that a value can be reused.
	const e = 4 // extra capacity
	return make(nat, n, n+e)
}

// z = x
func (z nat) set(x nat) nat {
	z = z.make(len(x))
	copy(z, x)
	return z
}

// z = x + y
// (like add, but operating on half-digits at a time)
func (z nat) halfAdd(x, y nat) nat {
	m := len(x)
	n := len(y)

	switch {
	case m < n:
		return z.add(y, x)
	case m == 0:
		// n == 0 because m >= n; result is 0
		return z.make(0)
	case n == 0:
		// result is x
		return z.set(x)
	}
	// m >= n > 0

	const W2 = W / 2         // half-digit size in bits
	const M2 = (1 << W2) - 1 // lower half-digit mask

	z = z.make(m + 1)
	var c big.Word
	for i := 0; i < n; i++ {
		// lower half-digit
		c += x[i]&M2 + y[i]&M2
		d := c & M2
		c >>= W2
		// upper half-digit
		c += x[i]>>W2 + y[i]>>W2
		z[i] = c<<W2 | d
		c >>= W2
	}
	for i := n; i < m; i++ {
		// lower half-digit
		c += x[i] & M2
		d := c & M2
		c >>= W2
		// upper half-digit
		c += x[i] >> W2
		z[i] = c<<W2 | d
		c >>= W2
	}
	if c != 0 {
		z[m] = c
		m++
	}
	return z[:m]
}

// z = x + y
func (z nat) add(x, y nat) nat {
	m := len(x)
	n := len(y)

	switch {
	case m < n:
		return z.add(y, x)
	case m == 0:
		// n == 0 because m >= n; result is 0
		return z.make(0)
	case n == 0:
		// result is x
		return z.set(x)
	}
	// m >= n > 0

	z = z.make(m + 1)
	var c big.Word

	for i, xi := range x[:n] {
		yi := y[i]
		zi := xi + yi + c
		z[i] = zi
		// see "Hacker's Delight", section 2-12 (overflow detection)
		c = ((xi & yi) | ((xi | yi) &^ zi)) >> (W - 1)
	}
	for i, xi := range x[n:] {
		zi := xi + c
		z[n+i] = zi
		c = (xi &^ zi) >> (W - 1)
		if c == 0 {
			copy(z[n+i+1:], x[i+1:])
			break
		}
	}
	if c != 0 {
		z[m] = c
		m++
	}
	return z[:m]
}

func bitlen(x big.Word) int {
	n := 0
	for x > 0 {
		x >>= 1
		n++
	}
	return n
}

func (x nat) bitlen() int {
	if i := len(x); i > 0 {
		return (i-1)*W + bitlen(x[i-1])
	}
	return 0
}

func (x nat) String() string {
	const shortLen = 10
	s := new(big.Int).SetBits(x).String()
	if *short && len(s) > shortLen {
		s = s[:shortLen] + "..."
	}
	return s
}

func fibo(n int, half, opt bool) nat {
	switch n {
	case 0:
		return nil
	case 1:
		return nat{1}
	}
	f0 := nat(nil)
	f1 := nat{1}
	if half {
		if opt {
			var f2 nat // reuse f2
			for i := 1; i < n; i++ {
				f2 = f2.halfAdd(f1, f0)
				f0, f1, f2 = f1, f2, f0
			}
		} else {
			for i := 1; i < n; i++ {
				f2 := nat(nil).halfAdd(f1, f0) // allocate a new f2 each time
				f0, f1 = f1, f2
			}
		}
	} else {
		if opt {
			var f2 nat // reuse f2
			for i := 1; i < n; i++ {
				f2 = f2.add(f1, f0)
				f0, f1, f2 = f1, f2, f0
			}
		} else {
			for i := 1; i < n; i++ {
				f2 := nat(nil).add(f1, f0) // allocate a new f2 each time
				f0, f1 = f1, f2
			}
		}
	}
	return f1 // was f2 before shuffle
}

var tests = []struct {
	n    int
	want string
}{
	{0, "0"},
	{1, "1"},
	{2, "1"},
	{3, "2"},
	{4, "3"},
	{5, "5"},
	{6, "8"},
	{7, "13"},
	{8, "21"},
	{9, "34"},
	{10, "55"},
	{100, "354224848179261915075"},
	{1000, "43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875"},
}

func test(half, opt bool) {
	for _, test := range tests {
		got := fibo(test.n, half, opt).String()
		if got != test.want {
			fmt.Printf("error: got std fibo(%d) = %s; want %s\n", test.n, got, test.want)
			os.Exit(1)
		}
	}
}

func selfTest() {
	if W != 32 && W != 64 {
		fmt.Printf("error: unexpected wordsize %d", W)
		os.Exit(1)
	}
	for i := 0; i < 4; i++ {
		test(i&2 == 0, i&1 != 0)
	}
}

func doFibo(n int) {
	start := time.Now()
	f := fibo(n, *half, *opt)
	t := time.Since(start)
	fmt.Printf("fibo(%d) = %s (%d bits, %s)\n", n, f, f.bitlen(), t)
}

func benchFibo(b *testing.B, n int, half, opt bool) {
	for i := 0; i < b.N; i++ {
		fibo(n, half, opt)
	}
}

func doBench(half, opt bool) {
	w := tabwriter.NewWriter(os.Stdout, 0, 8, 2, ' ', tabwriter.AlignRight)
	fmt.Fprintf(w, "wordsize = %d, half = %v, opt = %v\n", W, half, opt)
	fmt.Fprintf(w, "n\talloc count\talloc bytes\tns/op\ttime/op\t\n")
	for n := 1; n <= 1e6; n *= 10 {
		res := testing.Benchmark(func(b *testing.B) { benchFibo(b, n, half, opt) })
		fmt.Fprintf(w, "%d\t%d\t%d\t%d\t%s\t\n", n, res.AllocsPerOp(), res.AllocedBytesPerOp(), res.NsPerOp(), time.Duration(res.NsPerOp()))
	}
	fmt.Fprintln(w)
	w.Flush()
}

func main() {
	selfTest()
	flag.Parse()

	if args := flag.Args(); len(args) > 0 {
		// command-line use
		fmt.Printf("half = %v, opt = %v, wordsize = %d bits\n", *half, *opt, W)
		for _, arg := range args {
			n, err := strconv.Atoi(arg)
			if err != nil || n < 0 {
				fmt.Println("invalid argument", arg)
				continue
			}
			doFibo(n)
		}
		return
	}

	if *bench {
		for i := 0; i < 4; i++ {
			doBench(i&2 == 0, i&1 != 0)
		}
	}
}
                                                                                                                                                                                                                                    usr/local/go/test/finprofiled.go                                                                    0100644 0000000 0000000 00000003700 13020111414 015347  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that tiny allocations with finalizers are correctly profiled.
// Previously profile special records could have been processed prematurely
// (while the object is still live).

package main

import (
	"runtime"
	"time"
	"unsafe"
)

func main() {
	runtime.MemProfileRate = 1
	// Allocate 1M 4-byte objects and set a finalizer for every third object.
	// Assuming that tiny block size is 16, some objects get finalizers setup
	// only for middle bytes. The finalizer resurrects that object.
	// As the result, all allocated memory must stay alive.
	const (
		N = 1 << 20
		tinyBlockSize = 16 // runtime._TinySize
	)
	hold := make([]*int32, 0, N)
	for i := 0; i < N; i++ {
		x := new(int32)
		if i%3 == 0 {
			runtime.SetFinalizer(x, func(p *int32) {
				hold = append(hold, p)
			})
		}
	}
	// Finalize as much as possible.
	// Note: the sleep only increases probility of bug detection,
	// it cannot lead to false failure.
	for i := 0; i < 5; i++ {
		runtime.GC()
		time.Sleep(10 * time.Millisecond)
	}
	// Read memory profile.
	var prof []runtime.MemProfileRecord
	for {
		if n, ok := runtime.MemProfile(prof, false); ok {
			prof = prof[:n]
			break
		} else {
			prof = make([]runtime.MemProfileRecord, n+10)
		}
	}
	// See how much memory in tiny objects is profiled.
	var totalBytes int64
	for _, p := range prof {
		bytes := p.AllocBytes - p.FreeBytes
		nobj := p.AllocObjects - p.FreeObjects
		size := bytes / nobj
		if size == tinyBlockSize {
			totalBytes += bytes
		}
	}
	// 2*tinyBlockSize slack is for any boundary effects.
	if want := N*int64(unsafe.Sizeof(int32(0))) - 2*tinyBlockSize; totalBytes < want {
		println("got", totalBytes, "want >=", want)
		panic("some of the tiny objects are not profiled")
	}
	// Just to keep hold alive.
	if len(hold) != 0 && hold[0] == nil {
		panic("bad")
	}
}
                                                                usr/local/go/test/fixedbugs/                                                                        0040755 0000000 0000000 00000000000 13020111414 014502  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/test/fixedbugs/bug000.go                                                               0100644 0000000 0000000 00000000456 13020111414 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var x int;
	switch x {
	case 0:
		{}
	case 1:
		x = 0;
	}
}
/*
bug0.go:8: case statement out of place
*/
                                                                                                                                                                                                                  usr/local/go/test/fixedbugs/bug002.go                                                               0100644 0000000 0000000 00000000431 13020111414 016023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	if ; false {}  // compiles; should be an error (should be simplevardecl before ;)
}
                                                                                                                                                                                                                                       usr/local/go/test/fixedbugs/bug003.go                                                               0100644 0000000 0000000 00000000462 13020111414 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	switch ; { case true: return; default: return }
}
/*
bug003.go:6: fatal error: walkswitch: not case EMPTY
*/
                                                                                                                                                                                                              usr/local/go/test/fixedbugs/bug004.go                                                               0100644 0000000 0000000 00000000454 13020111414 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	switch ; { case false: return; }  // compiles; should be an error (should be simplevardecl before ;)
}
                                                                                                                                                                                                                    usr/local/go/test/fixedbugs/bug005.go                                                               0100644 0000000 0000000 00000000505 13020111414 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	Foo: {
		return;
	}
	goto Foo;
}
/*
bug5.go:4: Foo undefined
bug5.go:4: fatal error: walktype: switch 1 unknown op GOTO l(4)
*/
                                                                                                                                                                                           usr/local/go/test/fixedbugs/bug006.go                                                               0100644 0000000 0000000 00000000536 13020111414 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "os"

const (
	x float64 = iota
	g float64 = 4.5 * iota
)

func main() {
	if g == 0.0 {
		print("zero\n")
	}
	if g != 4.5 {
		print(" fail\n")
		os.Exit(1)
	}
}
                                                                                                                                                                  usr/local/go/test/fixedbugs/bug007.go                                                               0100644 0000000 0000000 00000000741 13020111414 016034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type (
	Point struct {
		x, y float64
	}
	Polar Point
)

func main() {
}

/*
bug7.go:5: addtyp: renaming Point to Polar
main.go.c:14: error: redefinition of typedef ‘_T_2’
main.go.c:13: error: previous declaration of ‘_T_2’ was here
main.go.c:16: error: redefinition of ‘struct _T_2’
*/
                               usr/local/go/test/fixedbugs/bug008.go                                                               0100644 0000000 0000000 00000000625 13020111414 016036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	i5 := 5;

	switch {  // compiler crash fixable with 'switch true'
	case i5 < 5: dummy := 0; _ = dummy;
	case i5 == 5: dummy := 0; _ = dummy;
	case i5 > 5: dummy := 0; _ = dummy;
	}
}
/*
Segmentation fault
*/
                                                                                                           usr/local/go/test/fixedbugs/bug009.go                                                               0100644 0000000 0000000 00000000545 13020111414 016040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main


func main() {
	fired := false; _ = fired;
}
/*
bug9.go:5: defaultlit: unknown literal: LITERAL-B0 a(1)
bug9.go:5: fatal error: addvar: n=NAME-fired G0 a(1) l(5) t=<N> nil
*/
                                                                                                                                                           usr/local/go/test/fixedbugs/bug010.go                                                               0100644 0000000 0000000 00000000702 13020111414 016023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main


func f(i int, f float64) {
	i = 8
	f = 8.0
	return
}

func main() {
	f(3, float64(5))
}

/*
bug10.go:5: i undefined
bug10.go:6: illegal conversion of constant to 020({},<_o001>{<i><int32>INT32;<f><float32>FLOAT32;},{})
bug10.go:7: error in shape across assignment
*/
                                                              usr/local/go/test/fixedbugs/bug011.go                                                               0100644 0000000 0000000 00000000714 13020111414 016027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main


type T struct {
	x, y int
}

func (t *T) m(a int, b float64) int {
	return (t.x + a) * (t.y + int(b))
}

func main() {
	var t *T = new(T)
	t.x = 1
	t.y = 2
	r10 := t.m(1, 3.0)
	_ = r10
}
/*
bug11.go:16: fatal error: walktype: switch 1 unknown op CALLMETH l(16) <int32>INT32
*/
                                                    usr/local/go/test/fixedbugs/bug012.go                                                               0100644 0000000 0000000 00000001364 13020111414 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main


func main() {
	var u30 uint64 = 0;
	var u31 uint64 = 1;
	_, _ = u30, u31;
	var u32 uint64 = 18446744073709551615;
	var u33 uint64 = +18446744073709551615;
	if u32 != (1<<64)-1 { panic("u32\n"); }
	if u33 != (1<<64)-1 { panic("u33\n"); }
	var i34 int64 = ^0;  // note: 2's complement means ^0 == -1
	if i34 != -1 { panic("i34") }
}
/*
bug12.go:5: overflow converting constant to <uint64>UINT64
bug12.go:6: overflow converting constant to <uint64>UINT64
bug12.go:7: overflow converting constant to <uint64>UINT64
bug12.go:8: overflow converting constant to <uint64>UINT64
*/
                                                                                                                                                                                                                                                                            usr/local/go/test/fixedbugs/bug013.go                                                               0100644 0000000 0000000 00000000633 13020111414 016031  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var cu0 uint16 = '\u1234';
	var cU1 uint32 = '\U00101234';
	_, _ = cu0, cU1;
}
/*
bug13.go:4: missing '
bug13.go:4: syntax error
bug13.go:5: newline in string
bug13.go:5: missing '
bug13.go:6: newline in string
*/
                                                                                                     usr/local/go/test/fixedbugs/bug014.go                                                               0100644 0000000 0000000 00000000640 13020111414 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var c00 uint8 = '\0';  // ERROR "oct|char"
	var c01 uint8 = '\07';  // ERROR "oct|char"
	var cx0 uint8 = '\x0';  // ERROR "hex|char"
	var cx1 uint8 = '\x';  // ERROR "hex|char"
	_, _, _, _ = c00, c01, cx0, cx1
}
                                                                                                usr/local/go/test/fixedbugs/bug015.go                                                               0100644 0000000 0000000 00000000415 13020111414 016031  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var i33 int64;
	if i33 == (1<<64) -1 {  // ERROR "overflow"
	}
}
                                                                                                                                                                                                                                                   usr/local/go/test/fixedbugs/bug016.go                                                               0100644 0000000 0000000 00000000632 13020111414 016033  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var i int = 100
	i = i << -3 // ERROR "overflows|negative"
}

/*
ixedbugs/bug016.go:7: overflow converting constant to <uint32>UINT32
fixedbugs/bug016.go:7: illegal types for operand: AS
	(<int32>INT32)
*/
                                                                                                      usr/local/go/test/fixedbugs/bug017.go                                                               0100644 0000000 0000000 00000001570 13020111414 016036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var s2 string = "\a\b\f\n\r\t\v";  // \r is miscompiled
	_ = s2;
}
/*
main.go.c: In function ‘main_main’:
main.go.c:20: error: missing terminating " character
main.go.c:21: error: missing terminating " character
main.go.c:24: error: ‘def’ undeclared (first use in this function)
main.go.c:24: error: (Each undeclared identifier is reported only once
main.go.c:24: error: for each function it appears in.)
main.go.c:24: error: syntax error before ‘def’
main.go.c:24: error: missing terminating " character
main.go.c:25: warning: excess elements in struct initializer
main.go.c:25: warning: (near initialization for ‘slit’)
main.go.c:36: error: syntax error at end of input
*/
                                                                                                                                        usr/local/go/test/fixedbugs/bug020.go                                                               0100644 0000000 0000000 00000000746 13020111414 016034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // compile

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

var digits string;

func putint(buf []byte, i, base, val int, digits string) {
		buf[i] = digits[val];
}

func main() {
}

/*
uetli:~/Source/go1/test gri$ 6g bugs/bug020.go
bugs/bug020.go:7: type of a structure field cannot be an open array
bugs/bug020.go:7: fatal error: width of a dynamic array
*/
                          usr/local/go/test/fixedbugs/bug021.go                                                               0100644 0000000 0000000 00000000353 13020111414 016027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	s1 := "hi";
	s2 := "ho";
	s1 += s2;
}
                                                                                                                                                                                                                                                                                     usr/local/go/test/fixedbugs/bug022.go                                                               0100644 0000000 0000000 00000001021 13020111414 016021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func putint(digits *string) {
	var i byte;
	i = (*digits)[7];  // compiles
	i = digits[7];  // ERROR "illegal|is not|invalid"
	_ = i;
}

func main() {
	s := "asdfasdfasdfasdf";
	putint(&s);
}

/*
bug022.go:8: illegal types for operand
	(*<string>*STRING) INDEXPTR (<int32>INT32)
bug022.go:8: illegal types for operand
	(<uint8>UINT8) AS
*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/go/test/fixedbugs/bug023.go                                                               0100644 0000000 0000000 00000000705 13020111414 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type Type interface {
	TypeName() string;
}

type TInt struct {
}

// TInt
func (i *TInt) TypeName() string {
	return "int";
}


func main() {
	var t Type;
	t = nil;
	_ = t;
}

/*
bug023.go:20: fatal error: naddr: const <Type>I{<TypeName>110(<_t117>{},<_o119>{},{});}
*/
                                                           usr/local/go/test/fixedbugs/bug024.go                                                               0100644 0000000 0000000 00000000605 13020111414 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var i int;
	i = '\'';
	i = '\\';
	var s string;
	s = "\"";
	_, _ = i, s;
}
/*
bug.go:5: unknown escape sequence: '
bug.go:6: unknown escape sequence: \
bug.go:8: unknown escape sequence: "
*/
                                                                                                                           usr/local/go/test/fixedbugs/bug026.go                                                               0100644 0000000 0000000 00000000677 13020111414 016045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type Element interface {
}

type Vector struct {
}

func (v *Vector) Insert(i int, e Element) {
}


func main() {
	type I struct { val int; };  // BUG: can't be local; works if global
	v := new(Vector);
	v.Insert(0, new(I));
}
/*
check: main_sigs_I: not defined
*/
                                                                 usr/local/go/test/fixedbugs/bug027.go                                                               0100644 0000000 0000000 00000002312 13020111414 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "fmt"

type Element interface {
}

type Vector struct {
	nelem int
	elem  []Element
}

func New() *Vector {
	v := new(Vector)
	v.nelem = 0
	v.elem = make([]Element, 10)
	return v
}

func (v *Vector) At(i int) Element {
	return v.elem[i]
}

func (v *Vector) Insert(e Element) {
	v.elem[v.nelem] = e
	v.nelem++
}

func main() {
	type I struct{ val int }
	i0 := new(I)
	i0.val = 0
	i1 := new(I)
	i1.val = 11
	i2 := new(I)
	i2.val = 222
	i3 := new(I)
	i3.val = 3333
	i4 := new(I)
	i4.val = 44444
	v := New()
	r := "hi\n"
	v.Insert(i4)
	v.Insert(i3)
	v.Insert(i2)
	v.Insert(i1)
	v.Insert(i0)
	for i := 0; i < v.nelem; i++ {
		var x *I
		x = v.At(i).(*I)
		r += fmt.Sprintln(i, x.val) // prints correct list
	}
	for i := 0; i < v.nelem; i++ {
		r += fmt.Sprintln(i, v.At(i).(*I).val)
	}
	expect := `hi
0 44444
1 3333
2 222
3 11
4 0
0 44444
1 3333
2 222
3 11
4 0
`
	if r != expect {
		panic(r)
	}
}

/*
bug027.go:50: illegal types for operand
	(<Element>I{}) CONV (<I>{})
bug027.go:50: illegal types for operand
	(<Element>I{}) CONV (<I>{})
*/
                                                                                                                                                                                                                                                                                                                      usr/local/go/test/fixedbugs/bug028.go                                                               0100644 0000000 0000000 00000000640 13020111414 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main


func Alloc(i int) int {
	switch i {
	default:
		return 5;
	case 1:
		return 1;
	case 10:
		return 10;
	}
	return 0
}

func main() {
	s := Alloc(7);
	if s != 5 { panic("bad") }
}

/*
bug028.go:7: unreachable statements in a switch
*/
                                                                                                usr/local/go/test/fixedbugs/bug030.go                                                               0100644 0000000 0000000 00000000377 13020111414 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var x int;
	x := 0; // ERROR "declar|:="
	_ = x;
}
                                                                                                                                                                                                                                                                 usr/local/go/test/fixedbugs/bug031.go                                                               0100644 0000000 0000000 00000001442 13020111414 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
prog := "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxxxxxxxxxxxxx"+
"xxxxxx"+
"xxxxxxxxxxxxxxxxxxxx"+
"xxxxxxxx"+
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
;
_ = prog;
}

/* Segmentation fault */
                                                                                                                                                                                                                              usr/local/go/test/fixedbugs/bug035.go                                                               0100644 0000000 0000000 00000000504 13020111414 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func f9(a int) (i int, f float64) {
	i := 9          // ERROR "redecl|no new"
	f := float64(9) // ERROR "redecl|no new"
	return i, f
}
                                                                                                                                                                                            usr/local/go/test/fixedbugs/bug037.go                                                               0100644 0000000 0000000 00000000357 13020111414 016042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	s := vlong(0);  // ERROR "undef"
}
                                                                                                                                                                                                                                                                                 usr/local/go/test/fixedbugs/bug039.go                                                               0100644 0000000 0000000 00000000425 13020111414 016040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func f (x int) {	// GCCGO_ERROR "previous"
	var x int;	// ERROR "redecl|redefinition"
}
                                                                                                                                                                                                                                           usr/local/go/test/fixedbugs/bug040.go                                                               0100644 0000000 0000000 00000000432 13020111414 016026  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func f (x,		// GCCGO_ERROR "previous"
	x int) {	// ERROR "duplicate argument|redefinition"
}
                                                                                                                                                                                                                                      usr/local/go/test/fixedbugs/bug045.go                                                               0100644 0000000 0000000 00000000500 13020111414 016027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type T struct {
	i int
}

func main() {
	var ta []*T;

	ta = new([1]*T)[0:];
	ta[0] = nil;
}
/*
bug045.go:13: fatal error: goc: exit 1
*/
                                                                                                                                                                                                usr/local/go/test/fixedbugs/bug046.go                                                               0100644 0000000 0000000 00000000453 13020111414 016037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type T *struct {}

func (x T) M () {}  // ERROR "pointer|receiver"

/*
bug046.go:7: illegal <this> pointer
*/
                                                                                                                                                                                                                     usr/local/go/test/fixedbugs/bug047.go                                                               0100644 0000000 0000000 00000000540 13020111414 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {

	type T struct {
		s string
		f float64
	}
	var s string = "hello"
	var f float64 = 0.2
	t := T{s, f}

	type M map[int]int
	m0 := M{7: 8}

	_, _ = t, m0
}
                                                                                                                                                                usr/local/go/test/fixedbugs/bug048.go                                                               0100644 0000000 0000000 00000000366 13020111414 016044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	type M map[int] int;
	m1 := M{7 : 8};
	_ = m1;
}
                                                                                                                                                                                                                                                                          usr/local/go/test/fixedbugs/bug049.go                                                               0100644 0000000 0000000 00000000525 13020111414 016042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func atom(s string) {
	if s == nil {	// ERROR "nil|incompatible"
		return;
	}
}

func main() {}

/*
bug047.go:4: fatal error: stringpool: not string
*/
                                                                                                                                                                           usr/local/go/test/fixedbugs/bug050.go                                                               0100644 0000000 0000000 00000000322 13020111414 016025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func main() {	// ERROR "package"
}
                                                                                                                                                                                                                                                                                                              usr/local/go/test/fixedbugs/bug051.go                                                               0100644 0000000 0000000 00000000413 13020111414 016027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // errorcheck

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func f() int {
	return 0;
}

func main() {
	const n = f();	// ERROR "const"
}
                                                                                                                                                                                                                                                     usr/local/go/test/fixedbugs/bug052.go                                                               0100644 0000000 0000000 00000000525 13020111414 016034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	c := 10;
	d := 7;
	var x [10]int;
	i := 0;
	/* this works:
	q := c/d;
	x[i] = q;
	*/
	// this doesn't:
	x[i] = c/d;	// BUG segmentation fault
}
                                                                                                                                                                           usr/local/go/test/fixedbugs/bug053.go                                                               0100644 0000000 0000000 00000000424 13020111414 016033  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func main() {
	var len int;	// len should not be a keyword - this doesn't compile
	_ = len;
}
                                                                                                                                                                                                                                            usr/local/go/test/fixedbugs/bug054.go                                                               0100644 0000000 0000000 00000001235 13020111414 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // run

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type Element interface {
}

type Vector struct {
	elem []Element;
}

func (v *Vector) At(i int) Element {
	return v.elem[i];
}

type TStruct struct {
	name string;
	fields *Vector;
}

func (s *TStruct) field(i int) *TStruct {
	return s.fields.At(i).(*TStruct);
}

func main() {
	v := new(Vector);
	v.elem = make([]Element, 10);
	t := new(TStruct);
	t.name = "hi";
	v.elem[0] = t;
	s := new(TStruct);
	s.name = "foo";
	s.fields = v;
	if s.field(0).name != "hi" {
		panic("bad name")
	}
}
                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/test/fixedbugs/bug055.go                                                               0100644 0000000 0000000 00000000575 13020111414 016044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        