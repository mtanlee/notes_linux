pe)
			__attribute__warn_unused_result__;

PERL_CALLCONV MAGIC*	Perl_mg_find_mglob(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_FIND_MGLOB	\
	assert(sv)

PERL_CALLCONV MAGIC*	Perl_mg_findext(pTHX_ const SV* sv, int type, const MGVTBL *vtbl)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_mg_free(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_FREE	\
	assert(sv)

PERL_CALLCONV void	Perl_mg_free_type(pTHX_ SV* sv, int how)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_FREE_TYPE	\
	assert(sv)

PERL_CALLCONV int	Perl_mg_get(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_GET	\
	assert(sv)

PERL_CALLCONV U32	Perl_mg_length(pTHX_ SV* sv)
			__attribute__deprecated__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_LENGTH	\
	assert(sv)

PERL_CALLCONV void	Perl_mg_localize(pTHX_ SV* sv, SV* nsv, bool setmagic)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MG_LOCALIZE	\
	assert(sv); assert(nsv)

PERL_CALLCONV void	Perl_mg_magical(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_MAGICAL	\
	assert(sv)

PERL_CALLCONV int	Perl_mg_set(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_SET	\
	assert(sv)

PERL_CALLCONV I32	Perl_mg_size(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_SIZE	\
	assert(sv)

PERL_CALLCONV void	Perl_mini_mktime(pTHX_ struct tm *ptm)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MINI_MKTIME	\
	assert(ptm)

PERL_CALLCONV int	Perl_mode_from_discipline(pTHX_ const char* s, STRLEN len);
PERL_CALLCONV void *	Perl_more_bodies(pTHX_ const svtype sv_type, const size_t body_size, const size_t arena_size);
PERL_CALLCONV const char*	Perl_moreswitches(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MORESWITCHES	\
	assert(s)

PERL_CALLCONV const struct mro_alg *	Perl_mro_get_from_name(pTHX_ SV *name)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_GET_FROM_NAME	\
	assert(name)

PERL_CALLCONV AV*	Perl_mro_get_linear_isa(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA	\
	assert(stash)

PERL_CALLCONV SV*	Perl_mro_get_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MRO_GET_PRIVATE_DATA	\
	assert(smeta); assert(which)

PERL_CALLCONV void	Perl_mro_isa_changed_in(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_ISA_CHANGED_IN	\
	assert(stash)

PERL_CALLCONV struct mro_meta*	Perl_mro_meta_init(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_META_INIT	\
	assert(stash)

PERL_CALLCONV void	Perl_mro_method_changed_in(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_METHOD_CHANGED_IN	\
	assert(stash)

PERL_CALLCONV void	Perl_mro_package_moved(pTHX_ HV * const stash, HV * const oldstash, const GV * const gv, U32 flags)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MRO_PACKAGE_MOVED	\
	assert(gv)

PERL_CALLCONV void	Perl_mro_register(pTHX_ const struct mro_alg *mro)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_REGISTER	\
	assert(mro)

PERL_CALLCONV void	Perl_mro_set_mro(pTHX_ struct mro_meta *const meta, SV *const name)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MRO_SET_MRO	\
	assert(meta); assert(name)

PERL_CALLCONV SV*	Perl_mro_set_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which, SV *const data)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MRO_SET_PRIVATE_DATA	\
	assert(smeta); assert(which); assert(data)

PERL_CALLCONV NV	Perl_my_atof(pTHX_ const char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MY_ATOF	\
	assert(s)

PERL_CALLCONV char*	Perl_my_atof2(pTHX_ const char *s, NV* value)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MY_ATOF2	\
	assert(s); assert(value)

PERL_CALLCONV OP *	Perl_my_attrs(pTHX_ OP *o, OP *attrs)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MY_ATTRS	\
	assert(o)

PERL_CALLCONV void	Perl_my_clearenv(pTHX);
PERL_CALLCONV int	Perl_my_dirfd(pTHX_ DIR* dir);
PERL_CALLCONV_NO_RET void	Perl_my_exit(pTHX_ U32 status)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_my_failure_exit(pTHX)
			__attribute__noreturn__;

PERL_CALLCONV I32	Perl_my_fflush_all(pTHX);
PERL_CALLCONV Pid_t	Perl_my_fork(void);
/* PERL_CALLCONV I32	Perl_my_lstat(pTHX); */
PERL_CALLCONV I32	Perl_my_lstat_flags(pTHX_ const U32 flags);
PERL_CALLCONV PerlIO*	Perl_my_popen_list(pTHX_ const char* mode, int n, SV ** args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MY_POPEN_LIST	\
	assert(mode); assert(args)

PERL_CALLCONV void	Perl_my_setenv(pTHX_ const char* nam, const char* val);
PERL_CALLCONV int	Perl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)
			__attribute__format__(__printf__,3,4)
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_MY_SNPRINTF	\
	assert(buffer); assert(format)

PERL_CALLCONV int	Perl_my_socketpair(int family, int type, int protocol, int fd[2]);
/* PERL_CALLCONV I32	Perl_my_stat(pTHX); */
PERL_CALLCONV I32	Perl_my_stat_flags(pTHX_ const U32 flags);
PERL_CALLCONV char *	Perl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
			__attribute__format__(__strftime__,pTHX_1,0)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MY_STRFTIME	\
	assert(fmt)

PERL_CALLCONV void	Perl_my_unexec(pTHX);
PERL_CALLCONV int	Perl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap)
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_MY_VSNPRINTF	\
	assert(buffer); assert(format)

PERL_CALLCONV OP*	Perl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block);
PERL_CALLCONV OP*	Perl_newANONHASH(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newANONLIST(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newANONSUB(pTHX_ I32 floor, OP* proto, OP* block);
PERL_CALLCONV OP*	Perl_newASSIGNOP(pTHX_ I32 flags, OP* left, I32 optype, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__;

/* PERL_CALLCONV CV*	newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block); */
PERL_CALLCONV CV*	Perl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block, bool o_is_gv);
/* PERL_CALLCONV AV*	Perl_newAV(pTHX)
			__attribute__warn_unused_result__; */

PERL_CALLCONV OP*	Perl_newAVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWAVREF	\
	assert(o)

PERL_CALLCONV OP*	Perl_newBINOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newCONDOP(pTHX_ I32 flags, OP* first, OP* trueop, OP* falseop)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWCONDOP	\
	assert(first)

PERL_CALLCONV CV*	Perl_newCONSTSUB(pTHX_ HV* stash, const char* name, SV* sv);
PERL_CALLCONV CV*	Perl_newCONSTSUB_flags(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags, SV* sv);
PERL_CALLCONV OP*	Perl_newCVREF(pTHX_ I32 flags, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newFOROP(pTHX_ I32 flags, OP* sv, OP* expr, OP* block, OP* cont)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWFOROP	\
	assert(expr)

PERL_CALLCONV OP*	Perl_newGIVENOP(pTHX_ OP* cond, OP* block, PADOFFSET defsv_off)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWGIVENOP	\
	assert(cond); assert(block)

PERL_CALLCONV GP *	Perl_newGP(pTHX_ GV *const gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWGP	\
	assert(gv)

PERL_CALLCONV OP*	Perl_newGVOP(pTHX_ I32 type, I32 flags, GV* gv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWGVOP	\
	assert(gv)

PERL_CALLCONV OP*	Perl_newGVREF(pTHX_ I32 type, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

/* PERL_CALLCONV GV*	newGVgen(pTHX_ const char* pack)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV GV*	Perl_newGVgen_flags(pTHX_ const char* pack, U32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWGVGEN_FLAGS	\
	assert(pack)

/* PERL_CALLCONV HV*	Perl_newHV(pTHX)
			__attribute__warn_unused_result__; */

PERL_CALLCONV OP*	Perl_newHVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWHVREF	\
	assert(o)

PERL_CALLCONV HV*	Perl_newHVhv(pTHX_ HV *hv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

/* PERL_CALLCONV IO*	Perl_newIO(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__; */

PERL_CALLCONV OP*	Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newLOGOP(pTHX_ I32 optype, I32 flags, OP *first, OP *other)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_NEWLOGOP	\
	assert(first); assert(other)

PERL_CALLCONV OP*	Perl_newLOOPEX(pTHX_ I32 type, OP* label)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWLOOPEX	\
	assert(label)

PERL_CALLCONV OP*	Perl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP* expr, OP* block)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV CV *	Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWMYSUB	\
	assert(o)

PERL_CALLCONV OP*	Perl_newNULLLIST(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newOP(pTHX_ I32 optype, I32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newPMOP(pTHX_ I32 type, I32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_newPROG(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWPROG	\
	assert(o)

PERL_CALLCONV OP*	Perl_newPVOP(pTHX_ I32 type, I32 flags, char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newRANGE(pTHX_ I32 flags, OP* left, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWRANGE	\
	assert(left); assert(right)

PERL_CALLCONV SV*	Perl_newRV(pTHX_ SV *const sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWRV	\
	assert(sv)

PERL_CALLCONV SV*	Perl_newRV_noinc(pTHX_ SV *const sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWRV_NOINC	\
	assert(sv)

PERL_CALLCONV OP*	Perl_newSLICEOP(pTHX_ I32 flags, OP* subscript, OP* listop)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newSTATEOP(pTHX_ I32 flags, char* label, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_newSTUB(pTHX_ GV *gv, bool fake)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWSTUB	\
	assert(gv)

/* PERL_CALLCONV CV*	Perl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block); */
PERL_CALLCONV SV*	Perl_newSV(pTHX_ const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newSVOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWSVOP	\
	assert(sv)

PERL_CALLCONV OP*	Perl_newSVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWSVREF	\
	assert(o)

PERL_CALLCONV SV*	Perl_newSV_type(pTHX_ const svtype type)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWSVAVDEFELEM	\
	assert(av)

PERL_CALLCONV SV*	Perl_newSVhek(pTHX_ const HEK *const hek)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSViv(pTHX_ const IV i)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVnv(pTHX_ const NV n)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpv(pTHX_ const char *const s, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpv_share(pTHX_ const char* s, U32 hash)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvf(pTHX_ const char *const pat, ...)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWSVPVF	\
	assert(pat)

PERL_CALLCONV SV*	Perl_newSVpvn(pTHX_ const char *const s, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvn_share(pTHX_ const char* s, I32 len, U32 hash)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVrv(pTHX_ SV *const rv, const char *const classname)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEWSVRV	\
	assert(rv)

PERL_CALLCONV SV*	Perl_newSVsv(pTHX_ SV *const old)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVuv(pTHX_ const UV u)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newUNOP(pTHX_ I32 type, I32 flags, OP* first)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newWHENOP(pTHX_ OP* cond, OP* block)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWWHENOP	\
	assert(block)

PERL_CALLCONV OP*	Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP* loop, OP* expr, OP* block, OP* cont, I32 has_my)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWXS	\
	assert(subaddr); assert(filename)

PERL_CALLCONV CV *	Perl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWXS_FLAGS	\
	assert(subaddr); assert(filename)

PERL_CALLCONV CV *	Perl_newXS_len_flags(pTHX_ const char *name, STRLEN len, XSUBADDR_t subaddr, const char *const filename, const char *const proto, SV **const_svp, U32 flags)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS	\
	assert(subaddr); assert(filename)

PERL_CALLCONV void	Perl_new_collate(pTHX_ const char* newcoll);
PERL_CALLCONV void	Perl_new_ctype(pTHX_ const char* newctype)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEW_CTYPE	\
	assert(newctype)

PERL_CALLCONV void	Perl_new_numeric(pTHX_ const char* newcoll);
PERL_CALLCONV PERL_SI*	Perl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_new_version(pTHX_ SV *ver)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEW_VERSION	\
	assert(ver)

PERL_CALLCONV STRLEN *	Perl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits, STRLEN size)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD	\
	assert(bits)

PERL_CALLCONV PerlIO*	Perl_nextargv(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEXTARGV	\
	assert(gv)

PERL_CALLCONV char*	Perl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4);
#define PERL_ARGS_ASSERT_NINSTR	\
	assert(big); assert(bigend); assert(little); assert(lend)

PERL_CALLCONV int	Perl_nothreadhook(pTHX);
PERL_CALLCONV OP*	Perl_oopsAV(pTHX_ OP* o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OOPSAV	\
	assert(o)

PERL_CALLCONV OP*	Perl_oopsHV(pTHX_ OP* o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OOPSHV	\
	assert(o)

PERL_CALLCONV OP*	Perl_op_append_elem(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV OP*	Perl_op_append_list(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV void	Perl_op_clear(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_CLEAR	\
	assert(o)

PERL_CALLCONV SV*	Perl_op_const_sv(pTHX_ const OP* o, CV* cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_op_contextualize(pTHX_ OP* o, I32 context)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_CONTEXTUALIZE	\
	assert(o)

PERL_CALLCONV void	Perl_op_dump(pTHX_ const OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_DUMP	\
	assert(o)

PERL_CALLCONV void	Perl_op_free(pTHX_ OP* arg);
PERL_CALLCONV OP*	Perl_op_linklist(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_LINKLIST	\
	assert(o)

/* PERL_CALLCONV OP*	op_lvalue(pTHX_ OP* o, I32 type); */
PERL_CALLCONV OP*	Perl_op_lvalue_flags(pTHX_ OP* o, I32 type, U32 flags);
PERL_CALLCONV void	Perl_op_null(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_NULL	\
	assert(o)

PERL_CALLCONV OP*	Perl_op_prepend_elem(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV void	Perl_op_refcnt_lock(pTHX);
PERL_CALLCONV void	Perl_op_refcnt_unlock(pTHX);
PERL_CALLCONV OP*	Perl_op_scope(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_op_unscope(pTHX_ OP* o);
PERL_CALLCONV void	Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5)
			__attribute__nonnull__(pTHX_6);
#define PERL_ARGS_ASSERT_PACK_CAT	\
	assert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist); assert(next_in_list)

PERL_CALLCONV void	Perl_package_version(pTHX_ OP* v)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PACKAGE_VERSION	\
	assert(v)

PERL_CALLCONV void	Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_PACKLIST	\
	assert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist)

PERL_CALLCONV PADOFFSET	Perl_pad_add_anon(pTHX_ CV* func, I32 optype)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_ADD_ANON	\
	assert(func)

PERL_CALLCONV PADOFFSET	Perl_pad_add_name_pv(pTHX_ const char *name, const U32 flags, HV *typestash, HV *ourstash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PV	\
	assert(name)

PERL_CALLCONV PADOFFSET	Perl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags, HV *typestash, HV *ourstash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN	\
	assert(namepv)

PERL_CALLCONV PADOFFSET	Perl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_SV	\
	assert(name)

PERL_CALLCONV PADOFFSET	Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype);
PERL_CALLCONV void	Perl_pad_block_start(pTHX_ int full);
PERL_CALLCONV HV*	Perl_pad_compname_type(pTHX_ const PADOFFSET po)
			__attribute__warn_unused_result__;

PERL_CALLCONV PADOFFSET	Perl_pad_findmy_pv(pTHX_ const char* name, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_FINDMY_PV	\
	assert(name)

PERL_CALLCONV PADOFFSET	Perl_pad_findmy_pvn(pTHX_ const char* namepv, STRLEN namelen, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_FINDMY_PVN	\
	assert(namepv)

PERL_CALLCONV PADOFFSET	Perl_pad_findmy_sv(pTHX_ SV* name, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_FINDMY_SV	\
	assert(name)

PERL_CALLCONV void	Perl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS	\
	assert(padlist); assert(old_cv); assert(new_cv)

PERL_CALLCONV void	Perl_pad_free(pTHX_ PADOFFSET po);
PERL_CALLCONV OP *	Perl_pad_leavemy(pTHX);
PERL_CALLCONV PADLIST*	Perl_pad_new(pTHX_ int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_pad_push(pTHX_ PADLIST *padlist, int depth)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_PUSH	\
	assert(padlist)

PERL_CALLCONV void	Perl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust);
PERL_CALLCONV void	Perl_pad_tidy(pTHX_ padtidy_type type);
PERL_CALLCONV PAD **	Perl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PADLIST_STORE	\
	assert(padlist)

PERL_CALLCONV OP*	Perl_parse_arithexpr(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_barestmt(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_block(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_fullexpr(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_fullstmt(pTHX_ U32 flags);
PERL_CALLCONV SV*	Perl_parse_label(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_listexpr(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_stmtseq(pTHX_ U32 flags);
PERL_CALLCONV OP *	Perl_parse_subsignature(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_parse_termexpr(pTHX_ U32 flags);
PERL_CALLCONV U32	Perl_parse_unicode_opts(pTHX_ const char **popt)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS	\
	assert(popt)

PERL_CALLCONV void	Perl_parser_free(pTHX_ const yy_parser *parser)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PARSER_FREE	\
	assert(parser)

PERL_CALLCONV void	Perl_peep(pTHX_ OP* o);
PERL_CALLCONV PerlInterpreter*	perl_alloc(void);
PERL_CALLCONV void	perl_construct(PerlInterpreter *my_perl)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PERL_CONSTRUCT	\
	assert(my_perl)

PERL_CALLCONV int	perl_destruct(PerlInterpreter *my_perl)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PERL_DESTRUCT	\
	assert(my_perl)

PERL_CALLCONV void	perl_free(PerlInterpreter *my_perl)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PERL_FREE	\
	assert(my_perl)

PERL_CALLCONV int	perl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit, int argc, char** argv, char** env)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PERL_PARSE	\
	assert(my_perl)

PERL_CALLCONV int	perl_run(PerlInterpreter *my_perl)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PERL_RUN	\
	assert(my_perl)

PERL_CALLCONV void	Perl_pmop_dump(pTHX_ PMOP* pm);
PERL_CALLCONV OP*	Perl_pmruntime(pTHX_ OP *o, OP *expr, bool isreg, I32 floor)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PMRUNTIME	\
	assert(o); assert(expr)

PERL_CALLCONV void	Perl_pop_scope(pTHX);
PERL_CALLCONV void	Perl_populate_isa(pTHX_ const char *name, STRLEN len, ...)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_POPULATE_ISA	\
	assert(name)

PERL_CALLCONV REGEXP*	Perl_pregcomp(pTHX_ SV * const pattern, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PREGCOMP	\
	assert(pattern)

PERL_CALLCONV I32	Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, SSize_t minend, SV* screamer, U32 nosave)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_6);
#define PERL_ARGS_ASSERT_PREGEXEC	\
	assert(prog); assert(stringarg); assert(strend); assert(strbeg); assert(screamer)

PERL_CALLCONV void	Perl_pregfree(pTHX_ REGEXP* r);
PERL_CALLCONV void	Perl_pregfree2(pTHX_ REGEXP *rx)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PREGFREE2	\
	assert(rx)

PERL_CALLCONV const char*	Perl_prescan_version(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PRESCAN_VERSION	\
	assert(s)

PERL_CALLCONV void	Perl_ptr_table_clear(pTHX_ PTR_TBL_t *const tbl)
			__attribute__deprecated__;

PERL_CALLCONV void*	Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PTR_TABLE_FETCH	\
	assert(tbl)

PERL_CALLCONV void	Perl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl);
PERL_CALLCONV PTR_TBL_t*	Perl_ptr_table_new(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PTR_TABLE_SPLIT	\
	assert(tbl)

PERL_CALLCONV void	Perl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_PTR_TABLE_STORE	\
	assert(tbl); assert(newsv)

PERL_CALLCONV void	Perl_push_scope(pTHX);
PERL_CALLCONV char*	Perl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PV_DISPLAY	\
	assert(dsv); assert(pv)

PERL_CALLCONV char*	Perl_pv_escape(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PV_ESCAPE	\
	assert(dsv); assert(str)

PERL_CALLCONV char*	Perl_pv_pretty(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PV_PRETTY	\
	assert(dsv); assert(str)

PERL_CALLCONV char*	Perl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PV_UNI_DISPLAY	\
	assert(dsv); assert(spv)

PERL_CALLCONV void	Perl_qerror(pTHX_ SV* err)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_QERROR	\
	assert(err)

PERL_CALLCONV REGEXP*	Perl_re_compile(pTHX_ SV * const pattern, U32 orig_rx_flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_RE_COMPILE	\
	assert(pattern)

PERL_CALLCONV char*	Perl_re_intuit_start(pTHX_ REGEXP * const rx, SV* sv, const char* const strbeg, char* strpos, char* strend, const U32 flags, re_scream_pos_data *data)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_RE_INTUIT_START	\
	assert(rx); assert(strbeg); assert(strpos); assert(strend)

PERL_CALLCONV SV*	Perl_re_intuit_string(pTHX_ REGEXP  *const r)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_RE_INTUIT_STRING	\
	assert(r)

PERL_CALLCONV REGEXP*	Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count, OP *expr, const regexp_engine* eng, REGEXP *old_re, bool *is_bare_re, U32 rx_flags, U32 pm_flags)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_RE_OP_COMPILE	\
	assert(eng)

PERL_CALLCONV Malloc_t	Perl_realloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_reentrant_free(pTHX);
PERL_CALLCONV void	Perl_reentrant_init(pTHX);
PERL_CALLCONV void*	Perl_reentrant_retry(const char *f, ...)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_REENTRANT_RETRY	\
	assert(f)

PERL_CALLCONV void	Perl_reentrant_size(pTHX);
/* PERL_CALLCONV OP*	Perl_ref(pTHX_ OP* o, I32 type); */
PERL_CALLCONV HV *	Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *c, U32 flags);
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain, const char *key, U32 hash, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV	\
	assert(key)

PERL_CALLCONV SV *	Perl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain, const char *keypv, STRLEN keylen, U32 hash, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN	\
	assert(keypv)

PERL_CALLCONV SV *	Perl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain, SV *key, U32 hash, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV	\
	assert(key)

PERL_CALLCONV void	Perl_refcounted_he_free(pTHX_ struct refcounted_he *he);
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_inc(pTHX_ struct refcounted_he *he);
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent, const char *key, U32 hash, SV *value, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV	\
	assert(key)

PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent, const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN	\
	assert(keypv)

PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent, SV *key, U32 hash, SV *value, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV	\
	assert(key)

PERL_CALLCONV SV*	Perl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF	\
	assert(rx)

PERL_CALLCONV SV*	Perl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL	\
	assert(rx)

PERL_CALLCONV bool	Perl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS	\
	assert(rx); assert(key)

PERL_CALLCONV SV*	Perl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH	\
	assert(rx); assert(namesv)

PERL_CALLCONV SV*	Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY	\
	assert(rx)

PERL_CALLCONV SV*	Perl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER	\
	assert(rx)

PERL_CALLCONV SV*	Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY	\
	assert(rx)

PERL_CALLCONV SV*	Perl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR	\
	assert(rx)

PERL_CALLCONV void	Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH	\
	assert(rx)

PERL_CALLCONV I32	Perl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv, const I32 paren)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH	\
	assert(rx); assert(sv)

PERL_CALLCONV void	Perl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren, SV const * const value)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE	\
	assert(rx)

PERL_CALLCONV SV*	Perl_reg_qr_package(pTHX_ REGEXP * const rx)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_QR_PACKAGE	\
	assert(rx)

PERL_CALLCONV REGEXP*	Perl_reg_temp_copy(pTHX_ REGEXP* ret_x, REGEXP* rx)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REG_TEMP_COPY	\
	assert(rx)

PERL_CALLCONV SV*	Perl_regclass_swash(pTHX_ const regexp *prog, const struct regnode *node, bool doinit, SV **listsvp, SV **altsvp)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGCLASS_SWASH	\
	assert(node)

PERL_CALLCONV void	Perl_regdump(pTHX_ const regexp* r)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REGDUMP	\
	assert(r)

PERL_CALLCONV I32	Perl_regexec_flags(pTHX_ REGEXP *const rx, char *stringarg, char *strend, char *strbeg, SSize_t minend, SV *sv, void *data, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_6);
#define PERL_ARGS_ASSERT_REGEXEC_FLAGS	\
	assert(rx); assert(stringarg); assert(strend); assert(strbeg); assert(sv)

PERL_CALLCONV void	Perl_regfree_internal(pTHX_ REGEXP *const rx)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REGFREE_INTERNAL	\
	assert(rx)

PERL_CALLCONV void	Perl_reginitcolors(pTHX);
PERL_CALLCONV regnode*	Perl_regnext(pTHX_ regnode* p)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_regprop(pTHX_ const regexp *prog, SV* sv, const regnode* o, const regmatch_info *reginfo)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REGPROP	\
	assert(sv); assert(o)

PERL_CALLCONV void	Perl_repeatcpy(char* to, const char* from, I32 len, IV count)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_REPEATCPY	\
	assert(to); assert(from)

PERL_CALLCONV void	Perl_report_evil_fh(pTHX_ const GV *gv);
PERL_CALLCONV void	Perl_report_uninit(pTHX_ const SV *uninit_sv);
PERL_CALLCONV void	Perl_report_wrongway_fh(pTHX_ const GV *gv, const char have);
PERL_CALLCONV void	Perl_require_pv(pTHX_ const char* pv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REQUIRE_PV	\
	assert(pv)

PERL_CALLCONV char*	Perl_rninstr(const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4);
#define PERL_ARGS_ASSERT_RNINSTR	\
	assert(big); assert(bigend); assert(little); assert(lend)

PERL_CALLCONV void	Perl_rpeep(pTHX_ OP* o);
PERL_CALLCONV Sighandler_t	Perl_rsignal(pTHX_ int i, Sighandler_t t);
PERL_CALLCONV int	Perl_rsignal_restore(pTHX_ int i, Sigsave_t* t);
PERL_CALLCONV int	Perl_rsignal_save(pTHX_ int i, Sighandler_t t1, Sigsave_t* save)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_RSIGNAL_SAVE	\
	assert(save)

PERL_CALLCONV Sighandler_t	Perl_rsignal_state(pTHX_ int i);
PERL_CALLCONV int	Perl_runops_debug(pTHX);
PERL_CALLCONV int	Perl_runops_standard(pTHX);
PERL_CALLCONV CV*	Perl_rv2cv_op_cv(pTHX_ OP *cvop, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_RV2CV_OP_CV	\
	assert(cvop)

PERL_CALLCONV void	Perl_rxres_save(pTHX_ void **rsp, REGEXP *rx)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_RXRES_SAVE	\
	assert(rsp); assert(rx)

PERL_CALLCONV Malloc_t	Perl_safesyscalloc(MEM_SIZE elements, MEM_SIZE size)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Free_t	Perl_safesysfree(Malloc_t where);
PERL_CALLCONV Malloc_t	Perl_safesysmalloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Malloc_t	Perl_safesysrealloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_save_I16(pTHX_ I16* intp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_I16	\
	assert(intp)

PERL_CALLCONV void	Perl_save_I32(pTHX_ I32* intp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_I32	\
	assert(intp)

PERL_CALLCONV void	Perl_save_I8(pTHX_ I8* bytep)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_I8	\
	assert(bytep)

PERL_CALLCONV void	Perl_save_adelete(pTHX_ AV *av, SSize_t key)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_ADELETE	\
	assert(av)

/* PERL_CALLCONV void	Perl_save_aelem(pTHX_ AV* av, SSize_t idx, SV **sptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV void	Perl_save_aelem_flags(pTHX_ AV* av, SSize_t idx, SV **sptr, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SAVE_AELEM_FLAGS	\
	assert(av); assert(sptr)

PERL_CALLCONV I32	Perl_save_alloc(pTHX_ I32 size, I32 pad);
PERL_CALLCONV void	Perl_save_aptr(pTHX_ AV** aptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_APTR	\
	assert(aptr)

PERL_CALLCONV AV*	Perl_save_ary(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_ARY	\
	assert(gv)

PERL_CALLCONV void	Perl_save_bool(pTHX_ bool* boolp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_BOOL	\
	assert(boolp)

PERL_CALLCONV void	Perl_save_clearsv(pTHX_ SV** svp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_CLEARSV	\
	assert(svp)

PERL_CALLCONV void	Perl_save_delete(pTHX_ HV *hv, char *key, I32 klen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SAVE_DELETE	\
	assert(hv); assert(key)

PERL_CALLCONV void	Perl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SAVE_DESTRUCTOR	\
	assert(p)

PERL_CALLCONV void	Perl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p);
/* PERL_CALLCONV void	Perl_save_freeop(pTHX_ OP* o); */
/* PERL_CALLCONV void	Perl_save_freepv(pTHX_ char* pv); */
/* PERL_CALLCONV void	Perl_save_freesv(pTHX_ SV* sv); */
PERL_CALLCONV void	Perl_save_generic_pvref(pTHX_ char** str)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_GENERIC_PVREF	\
	assert(str)

PERL_CALLCONV void	Perl_save_generic_svref(pTHX_ SV** sptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_GENERIC_SVREF	\
	assert(sptr)

PERL_CALLCONV void	Perl_save_gp(pTHX_ GV* gv, I32 empty)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_GP	\
	assert(gv)

PERL_CALLCONV HV*	Perl_save_hash(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_HASH	\
	assert(gv)

PERL_CALLCONV void	Perl_save_hdelete(pTHX_ HV *hv, SV *keysv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SAVE_HDELETE	\
	assert(hv); assert(keysv)

/* PERL_CALLCONV void	Perl_save_helem(pTHX_ HV *hv, SV *key, SV **sptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV void	Perl_save_helem_flags(pTHX_ HV *hv, SV *key, SV **sptr, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SAVE_HELEM_FLAGS	\
	assert(hv); assert(key); assert(sptr)

PERL_CALLCONV void	Perl_save_hints(pTHX);
PERL_CALLCONV void	Perl_save_hptr(pTHX_ HV** hptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_HPTR	\
	assert(hptr)

PERL_CALLCONV void	Perl_save_int(pTHX_ int* intp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_INT	\
	assert(intp)

PERL_CALLCONV void	Perl_save_item(pTHX_ SV* item)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_ITEM	\
	assert(item)

PERL_CALLCONV void	Perl_save_iv(pTHX_ IV *ivp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_IV	\
	assert(ivp)

PERL_CALLCONV void	Perl_save_list(pTHX_ SV** sarg, I32 maxsarg)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_LIST	\
	assert(sarg)

PERL_CALLCONV void	Perl_save_long(pTHX_ long* longp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_LONG	\
	assert(longp)

/* PERL_CALLCONV void	Perl_save_mortalizesv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SAVE_MORTALIZESV	\
	assert(sv)

PERL_CALLCONV void	Perl_save_nogv(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_NOGV	\
	assert(gv)

/* PERL_CALLCONV void	Perl_save_op(pTHX); */
PERL_CALLCONV void	Perl_save_padsv_and_mortalize(pTHX_ PADOFFSET off);
PERL_CALLCONV void	Perl_save_pptr(pTHX_ char** pptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_PPTR	\
	assert(pptr)

PERL_CALLCONV void	Perl_save_pushi32ptr(pTHX_ const I32 i, void *const ptr, const int type);
PERL_CALLCONV void	Perl_save_pushptr(pTHX_ void *const ptr, const int type);
PERL_CALLCONV void	Perl_save_pushptrptr(pTHX_ void *const ptr1, void *const ptr2, const int type);
PERL_CALLCONV void	Perl_save_re_context(pTHX);
PERL_CALLCONV SV*	Perl_save_scalar(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_SCALAR	\
	assert(gv)

PERL_CALLCONV void	Perl_save_set_svflags(pTHX_ SV *sv, U32 mask, U32 val)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_SET_SVFLAGS	\
	assert(sv)

PERL_CALLCONV void	Perl_save_shared_pvref(pTHX_ char** str)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_SHARED_PVREF	\
	assert(str)

PERL_CALLCONV void	Perl_save_sptr(pTHX_ SV** sptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_SPTR	\
	assert(sptr)

PERL_CALLCONV void	Perl_save_strlen(pTHX_ STRLEN* ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_STRLEN	\
	assert(ptr)

PERL_CALLCONV SV*	Perl_save_svref(pTHX_ SV** sptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_SVREF	\
	assert(sptr)

PERL_CALLCONV void	Perl_save_vptr(pTHX_ void *ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_VPTR	\
	assert(ptr)

PERL_CALLCONV char*	Perl_savepv(pTHX_ const char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savepvn(pTHX_ const char* pv, I32 len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedpv(pTHX_ const char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedsvpv(pTHX_ SV *sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVESHAREDSVPV	\
	assert(sv)

PERL_CALLCONV void	Perl_savestack_grow(pTHX);
PERL_CALLCONV void	Perl_savestack_grow_cnt(pTHX_ I32 need);
PERL_CALLCONV char*	Perl_savesvpv(pTHX_ SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVESVPV	\
	assert(sv)

PERL_CALLCONV OP*	Perl_sawparens(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalar(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalarvoid(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCALARVOID	\
	assert(o)

PERL_CALLCONV NV	Perl_scan_bin(pTHX_ const char* start, STRLEN len, STRLEN* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SCAN_BIN	\
	assert(start); assert(retlen)

PERL_CALLCONV NV	Perl_scan_hex(pTHX_ const char* start, STRLEN len, STRLEN* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SCAN_HEX	\
	assert(start); assert(retlen)

PERL_CALLCONV char*	Perl_scan_num(pTHX_ const char* s, YYSTYPE *lvalp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SCAN_NUM	\
	assert(s); assert(lvalp)

PERL_CALLCONV NV	Perl_scan_oct(pTHX_ const char* start, STRLEN len, STRLEN* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SCAN_OCT	\
	assert(start); assert(retlen)

PERL_CALLCONV const char*	Perl_scan_version(pTHX_ const char *s, SV *rv, bool qv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SCAN_VERSION	\
	assert(s); assert(rv)

PERL_CALLCONV char*	Perl_scan_vstring(pTHX_ const char *s, const char *const e, SV *sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SCAN_VSTRING	\
	assert(s); assert(e); assert(sv)

PERL_CALLCONV char*	Perl_screaminstr(pTHX_ SV *bigstr, SV *littlestr, I32 start_shift, I32 end_shift, I32 *old_posp, I32 last)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_SCREAMINSTR	\
	assert(bigstr); assert(littlestr); assert(old_posp)

PERL_CALLCONV U32	Perl_seed(pTHX);
PERL_CALLCONV void	Perl_set_caret_X(pTHX);
PERL_CALLCONV void	Perl_set_context(void *t)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_SET_CONTEXT	\
	assert(t)

PERL_CALLCONV void	Perl_set_numeric_local(pTHX);
PERL_CALLCONV void	Perl_set_numeric_radix(pTHX);
PERL_CALLCONV void	Perl_set_numeric_standard(pTHX);
PERL_CALLCONV void	Perl_setdefout(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SETDEFOUT	\
	assert(gv)

PERL_CALLCONV HEK*	Perl_share_hek(pTHX_ const char* str, I32 len, U32 hash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SHARE_HEK	\
	assert(str)

PERL_CALLCONV void	Perl_sortsv(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SORTSV	\
	assert(cmp)

PERL_CALLCONV void	Perl_sortsv_flags(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp, U32 flags)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SORTSV_FLAGS	\
	assert(cmp)

PERL_CALLCONV SV**	Perl_stack_grow(pTHX_ SV** sp, SV** p, SSize_t n)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_STACK_GROW	\
	assert(sp); assert(p)

PERL_CALLCONV PerlIO*	Perl_start_glob(pTHX_ SV *tmpglob, IO *io)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_START_GLOB	\
	assert(tmpglob); assert(io)

PERL_CALLCONV I32	Perl_start_subparse(pTHX_ I32 is_format, U32 flags);
PERL_CALLCONV NV	Perl_str_to_version(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_STR_TO_VERSION	\
	assert(sv)

PERL_CALLCONV void	Perl_sub_crush_depth(pTHX_ CV* cv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SUB_CRUSH_DEPTH	\
	assert(cv)

/* PERL_CALLCONV bool	sv_2bool(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV bool	Perl_sv_2bool_flags(pTHX_ SV *sv, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2BOOL_FLAGS	\
	assert(sv)

PERL_CALLCONV CV*	Perl_sv_2cv(pTHX_ SV* sv, HV **const st, GV **const gvp, const I32 lref)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SV_2CV	\
	assert(st); assert(gvp)

PERL_CALLCONV IO*	Perl_sv_2io(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2IO	\
	assert(sv)

/* PERL_CALLCONV IV	Perl_sv_2iv(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_2IV	\
	assert(sv)

PERL_CALLCONV IV	Perl_sv_2iv_flags(pTHX_ SV *const sv, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2IV_FLAGS	\
	assert(sv)

PERL_CALLCONV SV*	Perl_sv_2mortal(pTHX_ SV *const sv);
PERL_CALLCONV SV*	Perl_sv_2num(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2NUM	\
	assert(sv)

PERL_CALLCONV NV	Perl_sv_2nv_flags(pTHX_ SV *const sv, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2NV_FLAGS	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_2pv(pTHX_ SV *sv, STRLEN *lp)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_2PV	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_2pv_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2PV_FLAGS	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_2pv_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_2PV_NOLEN	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_2pvbyte(pTHX_ SV *sv, STRLEN *const lp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2PVBYTE	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_2pvbyte_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_2PVBYTE_NOLEN	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_2pvutf8(pTHX_ SV *sv, STRLEN *const lp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2PVUTF8	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_2pvutf8_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_2PVUTF8_NOLEN	\
	assert(sv)

/* PERL_CALLCONV UV	Perl_sv_2uv(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_2UV	\
	assert(sv)

PERL_CALLCONV UV	Perl_sv_2uv_flags(pTHX_ SV *const sv, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2UV_FLAGS	\
	assert(sv)

PERL_CALLCONV int	Perl_sv_backoff(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_BACKOFF	\
	assert(sv)

PERL_CALLCONV SV*	Perl_sv_bless(pTHX_ SV *const sv, HV *const stash)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_BLESS	\
	assert(sv); assert(stash)

PERL_CALLCONV bool	Perl_sv_cat_decode(pTHX_ SV* dsv, SV *encoding, SV *ssv, int *offset, char* tstr, int tlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_SV_CAT_DECODE	\
	assert(dsv); assert(encoding); assert(ssv); assert(offset); assert(tstr)

PERL_CALLCONV void	Perl_sv_catpv(pTHX_ SV *const sv, const char* ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_CATPV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_catpv_flags(pTHX_ SV *dstr, const char *sstr, const I32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATPV_FLAGS	\
	assert(dstr); assert(sstr)

PERL_CALLCONV void	Perl_sv_catpv_mg(pTHX_ SV *const sv, const char *const ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_CATPV_MG	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_catpvf(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATPVF	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_catpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATPVF_MG	\
	assert(sv); assert(pat)

/* PERL_CALLCONV void	Perl_sv_catpvn(pTHX_ SV *dsv, const char *sstr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_SV_CATPVN	\
	assert(dsv); assert(sstr)

PERL_CALLCONV void	Perl_sv_catpvn_flags(pTHX_ SV *const dstr, const char *sstr, const STRLEN len, const I32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATPVN_FLAGS	\
	assert(dstr); assert(sstr)

/* PERL_CALLCONV void	Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_SV_CATPVN_MG	\
	assert(sv); assert(ptr)

/* PERL_CALLCONV void	Perl_sv_catsv(pTHX_ SV *dstr, SV *sstr)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_CATSV	\
	assert(dstr)

PERL_CALLCONV void	Perl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_CATSV_FLAGS	\
	assert(dsv)

/* PERL_CALLCONV void	Perl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_CATSV_MG	\
	assert(dsv)

PERL_CALLCONV void	Perl_sv_chop(pTHX_ SV *const sv, const char *const ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_CHOP	\
	assert(sv)

PERL_CALLCONV I32	Perl_sv_clean_all(pTHX);
PERL_CALLCONV void	Perl_sv_clean_objs(pTHX);
PERL_CALLCONV void	Perl_sv_clear(pTHX_ SV *const orig_sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_CLEAR	\
	assert(orig_sv)

PERL_CALLCONV I32	Perl_sv_cmp(pTHX_ SV *const sv1, SV *const sv2);
PERL_CALLCONV I32	Perl_sv_cmp_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);
PERL_CALLCONV I32	Perl_sv_cmp_locale(pTHX_ SV *const sv1, SV *const sv2);
PERL_CALLCONV I32	Perl_sv_cmp_locale_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);
/* PERL_CALLCONV void	Perl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_SV_COPYPV	\
	assert(dsv); assert(ssv)

PERL_CALLCONV void	Perl_sv_copypv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_COPYPV_FLAGS	\
	assert(dsv); assert(ssv)

/* PERL_CALLCONV void	Perl_sv_copypv_nomg(pTHX_ SV *const dsv, SV *const ssv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV void	Perl_sv_dec(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_dec_nomg(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_del_backref(pTHX_ SV *const tsv, SV *const sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DEL_BACKREF	\
	assert(tsv); assert(sv)

PERL_CALLCONV bool	Perl_sv_derived_from(pTHX_ SV* sv, const char *const name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_derived_from_pv(pTHX_ SV* sv, const char *const name, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PV	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_derived_from_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PVN	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_derived_from_sv(pTHX_ SV* sv, SV *namesv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_SV	\
	assert(sv); assert(namesv)

PERL_CALLCONV bool	Perl_sv_destroyable(pTHX_ SV *sv);
PERL_CALLCONV bool	Perl_sv_does(pTHX_ SV* sv, const char *const name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DOES	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_does_pv(pTHX_ SV* sv, const char *const name, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DOES_PV	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_does_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DOES_PVN	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_does_sv(pTHX_ SV* sv, SV* namesv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DOES_SV	\
	assert(sv); assert(namesv)

PERL_CALLCONV void	Perl_sv_dump(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_DUMP	\
	assert(sv)

/* PERL_CALLCONV I32	sv_eq(pTHX_ SV* sv1, SV* sv2); */
PERL_CALLCONV I32	Perl_sv_eq_flags(pTHX_ SV* sv1, SV* sv2, const U32 flags);
/* PERL_CALLCONV void	Perl_sv_force_normal(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_free(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_free2(pTHX_ SV *const sv, const U32 refcnt)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_FREE2	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_free_arenas(pTHX);
PERL_CALLCONV char*	Perl_sv_gets(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_GETS	\
	assert(sv); assert(fp)

PERL_CALLCONV char*	Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_GROW	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_inc(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_inc_nomg(pTHX_ SV *const sv);
/* PERL_CALLCONV void	Perl_sv_insert(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4); */
#define PERL_ARGS_ASSERT_SV_INSERT	\
	assert(bigstr); assert(little)

PERL_CALLCONV void	Perl_sv_insert_flags(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_SV_INSERT_FLAGS	\
	assert(bigstr); assert(little)

PERL_CALLCONV int	Perl_sv_isa(pTHX_ SV* sv, const char *const name)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_ISA	\
	assert(name)

PERL_CALLCONV int	Perl_sv_isobject(pTHX_ SV* sv);
PERL_CALLCONV IV	Perl_sv_iv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_IV	\
	assert(sv)

PERL_CALLCONV STRLEN	Perl_sv_len(pTHX_ SV *const sv);
PERL_CALLCONV STRLEN	Perl_sv_len_utf8(pTHX_ SV *const sv);
PERL_CALLCONV STRLEN	Perl_sv_len_utf8_nomg(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_LEN_UTF8_NOMG	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_magic(pTHX_ SV *const sv, SV *const obj, const int how, const char *const name, const I32 namlen)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_MAGIC	\
	assert(sv)

PERL_CALLCONV MAGIC *	Perl_sv_magicext(pTHX_ SV *const sv, SV *const obj, const int how, const MGVTBL *const vtbl, const char *const name, const I32 namlen)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_MAGICEXT	\
	assert(sv)

PERL_CALLCONV MAGIC *	Perl_sv_magicext_mglob(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_MAGICEXT_MGLOB	\
	assert(sv)

/* PERL_CALLCONV SV*	Perl_sv_mortalcopy(pTHX_ SV *const oldsv)
			__attribute__malloc__
			__attribute__warn_unused_result__; */

PERL_CALLCONV SV*	Perl_sv_mortalcopy_flags(pTHX_ SV *const oldsv, U32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_sv_newmortal(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_sv_newref(pTHX_ SV *const sv);
/* PERL_CALLCONV void	Perl_sv_nolocking(pTHX_ SV *sv); */
PERL_CALLCONV void	Perl_sv_nosharing(pTHX_ SV *sv);
PERL_CALLCONV NV	Perl_sv_nv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_NV	\
	assert(sv)

PERL_STATIC_INLINE bool	S_sv_only_taint_gmagic(SV *sv)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_SV_ONLY_TAINT_GMAGIC	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_peek(pTHX_ SV* sv);
PERL_CALLCONV void	Perl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_POS_B2U	\
	assert(offsetp)

PERL_CALLCONV STRLEN	Perl_sv_pos_b2u_flags(pTHX_ SV *const sv, STRLEN const offset, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_POS_B2U_FLAGS	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_pos_u2b(pTHX_ SV *const sv, I32 *const offsetp, I32 *const lenp)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_POS_U2B	\
	assert(offsetp)

PERL_CALLCONV STRLEN	Perl_sv_pos_u2b_flags(pTHX_ SV *const sv, STRLEN uoffset, STRLEN *const lenp, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_POS_U2B_FLAGS	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_pv(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_PV	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_pvbyte(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_PVBYTE	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_PVBYTEN	\
	assert(sv); assert(lp)

PERL_CALLCONV char*	Perl_sv_pvbyten_force(pTHX_ SV *const sv, STRLEN *const lp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_PVBYTEN_FORCE	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_PVN	\
	assert(sv); assert(lp)

/* PERL_CALLCONV char*	Perl_sv_pvn_force(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_PVN_FORCE	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvn_nomg(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_PVN_NOMG	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_pvutf8(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_PVUTF8	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_PVUTF8N	\
	assert(sv); assert(lp)

PERL_CALLCONV char*	Perl_sv_pvutf8n_force(pTHX_ SV *const sv, STRLEN *const lp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_PVUTF8N_FORCE	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_recode_to_utf8(pTHX_ SV* sv, SV *encoding)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_RECODE_TO_UTF8	\
	assert(sv); assert(encoding)

PERL_CALLCONV SV*	Perl_sv_ref(pTHX_ SV *dst, const SV *const sv, const int ob)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_REF	\
	assert(sv)

PERL_CALLCONV const char*	Perl_sv_reftype(pTHX_ const SV *const sv, const int ob)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_REFTYPE	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_replace(pTHX_ SV *const sv, SV *const nsv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_REPLACE	\
	assert(sv); assert(nsv)

PERL_CALLCONV void	Perl_sv_report_used(pTHX);
PERL_CALLCONV void	Perl_sv_reset(pTHX_ const char* s, HV *const stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_RESET	\
	assert(s)

PERL_CALLCONV void	Perl_sv_resetpvn(pTHX_ const char* s, STRLEN len, HV *const stash);
PERL_CALLCONV SV*	Perl_sv_rvweaken(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_RVWEAKEN	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_sethek(pTHX_ SV *const sv, const HEK *const hek)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETHEK	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setiv(pTHX_ SV *const sv, const IV num)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETIV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setiv_mg(pTHX_ SV *const sv, const IV i)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETIV_MG	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setnv(pTHX_ SV *const sv, const NV num)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETNV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setnv_mg(pTHX_ SV *const sv, const NV num)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETNV_MG	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setpv(pTHX_ SV *const sv, const char *const ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETPV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setpv_mg(pTHX_ SV *const sv, const char *const ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETPV_MG	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setpvf(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_SETPVF	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_SETPVF_MG	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpviv(pTHX_ SV *const sv, const IV num)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETPVIV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setpviv_mg(pTHX_ SV *const sv, const IV iv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETPVIV_MG	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETPVN	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setpvn_mg(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_SETPVN_MG	\
	assert(sv); assert(ptr)

PERL_CALLCONV SV*	Perl_sv_setref_iv(pTHX_ SV *const rv, const char *const classname, const IV iv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETREF_IV	\
	assert(rv)

PERL_CALLCONV SV*	Perl_sv_setref_nv(pTHX_ SV *const rv, const char *const classname, const NV nv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETREF_NV	\
	assert(rv)

PERL_CALLCONV SV*	Perl_sv_setref_pv(pTHX_ SV *const rv, const char *const classname, void *const pv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETREF_PV	\
	assert(rv)

PERL_CALLCONV SV*	Perl_sv_setref_pvn(pTHX_ SV *const rv, const char *const classname, const char *const pv, const STRLEN n)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SV_SETREF_PVN	\
	assert(rv); assert(pv)

PERL_CALLCONV SV*	Perl_sv_setref_uv(pTHX_ SV *const rv, const char *const classname, const UV uv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETREF_UV	\
	assert(rv)

/* PERL_CALLCONV void	Perl_sv_setsv(pTHX_ SV *dstr, SV *sstr)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_SETSV	\
	assert(dstr)

PERL_CALLCONV void	Perl_sv_setsv_flags(pTHX_ SV *dstr, SV *sstr, const I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETSV_FLAGS	\
	assert(dstr)

PERL_CALLCONV void	Perl_sv_setsv_mg(pTHX_ SV *const dstr, SV *const sstr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETSV_MG	\
	assert(dstr)

PERL_CALLCONV void	Perl_sv_setuv(pTHX_ SV *const sv, const UV num)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETUV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_setuv_mg(pTHX_ SV *const sv, const UV u)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_SETUV_MG	\
	assert(sv)

/* PERL_CALLCONV void	Perl_sv_taint(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_TAINT	\
	assert(sv)

PERL_CALLCONV bool	Perl_sv_tainted(pTHX_ SV *const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_TAINTED	\
	assert(sv)

PERL_CALLCONV I32	Perl_sv_true(pTHX_ SV *const sv);
PERL_CALLCONV char*	Perl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_UNI_DISPLAY	\
	assert(dsv); assert(ssv)

PERL_CALLCONV int	Perl_sv_unmagic(pTHX_ SV *const sv, const int type)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UNMAGIC	\
	assert(sv)

PERL_CALLCONV int	Perl_sv_unmagicext(pTHX_ SV *const sv, const int type, MGVTBL *vtbl)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UNMAGICEXT	\
	assert(sv)

/* PERL_CALLCONV void	Perl_sv_unref(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_UNREF	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_unref_flags(pTHX_ SV *const ref, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UNREF_FLAGS	\
	assert(ref)

PERL_CALLCONV void	Perl_sv_untaint(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UNTAINT	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_upgrade(pTHX_ SV *const sv, svtype new_type)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UPGRADE	\
	assert(sv)

/* PERL_CALLCONV void	Perl_sv_usepvn(pTHX_ SV* sv, char* ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_USEPVN	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_usepvn_flags(pTHX_ SV *const sv, char* ptr, const STRLEN len, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_USEPVN_FLAGS	\
	assert(sv)

/* PERL_CALLCONV void	Perl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_USEPVN_MG	\
	assert(sv)

PERL_CALLCONV bool	Perl_sv_utf8_decode(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UTF8_DECODE	\
	assert(sv)

PERL_CALLCONV bool	Perl_sv_utf8_downgrade(pTHX_ SV *const sv, const bool fail_ok)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UTF8_DOWNGRADE	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_utf8_encode(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UTF8_ENCODE	\
	assert(sv)

/* PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE	\
	assert(sv)

/* PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade_flags(pTHX_ SV *const sv, const I32 flags)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade_flags_grow(pTHX_ SV *const sv, const I32 flags, STRLEN extra)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS_GROW	\
	assert(sv)

/* PERL_CALLCONV STRLEN	sv_utf8_upgrade_nomg(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV UV	Perl_sv_uv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UV	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_vcatpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VCATPVF	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_vcatpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VCATPVF_MG	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_vcatpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VCATPVFN	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_vcatpvfn_flags(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VCATPVFN_FLAGS	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_vsetpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VSETPVF	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_vsetpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VSETPVF_MG	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_vsetpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_VSETPVFN	\
	assert(sv); assert(pat)

PERL_CALLCONV UV	Perl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SWASH_FETCH	\
	assert(swash); assert(ptr)

PERL_CALLCONV SV*	Perl_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SWASH_INIT	\
	assert(pkg); assert(name); assert(listsv)

/* PERL_CALLCONV void	sync_locale(void); */
PERL_CALLCONV void	Perl_sys_init(int* argc, char*** argv)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_SYS_INIT	\
	assert(argc); assert(argv)

PERL_CALLCONV void	Perl_sys_init3(int* argc, char*** argv, char*** env)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_SYS_INIT3	\
	assert(argc); assert(argv); assert(env)

PERL_CALLCONV void	Perl_sys_term(void);
PERL_CALLCONV void	Perl_taint_env(pTHX);
PERL_CALLCONV void	Perl_taint_proper(pTHX_ const char* f, const char *const s)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TAINT_PROPER	\
	assert(s)

PERL_CALLCONV OP *	Perl_tied_method(pTHX_ SV *methname, SV **sp, SV *const sv, const MAGIC *const mg, const U32 flags, U32 argc, ...)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_TIED_METHOD	\
	assert(methname); assert(sp); assert(sv); assert(mg)

PERL_CALLCONV void	Perl_tmps_grow(pTHX_ SSize_t n);
/* PERL_CALLCONV UV	Perl_to_uni_fold(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV UV	Perl_to_uni_lower(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_TO_UNI_LOWER	\
	assert(p); assert(lenp)

PERL_CALLCONV U32	Perl_to_uni_lower_lc(pTHX_ U32 c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_uni_title(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_TO_UNI_TITLE	\
	assert(p); assert(lenp)

PERL_CALLCONV U32	Perl_to_uni_title_lc(pTHX_ U32 c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_uni_upper(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_TO_UNI_UPPER	\
	assert(p); assert(lenp)

PERL_CALLCONV U32	Perl_to_uni_upper_lc(pTHX_ U32 c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_utf8_case(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, SV **swashp, const char *normal, const char *special)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_TO_UTF8_CASE	\
	assert(p); assert(ustrp); assert(swashp); assert(normal)

/* PERL_CALLCONV UV	Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_TO_UTF8_FOLD	\
	assert(p); assert(ustrp)

/* PERL_CALLCONV UV	Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_TO_UTF8_LOWER	\
	assert(p); assert(ustrp)

/* PERL_CALLCONV UV	Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_TO_UTF8_TITLE	\
	assert(p); assert(ustrp)

/* PERL_CALLCONV UV	Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_TO_UTF8_UPPER	\
	assert(p); assert(ustrp)

PERL_CALLCONV bool	Perl_try_amagic_bin(pTHX_ int method, int flags);
PERL_CALLCONV bool	Perl_try_amagic_un(pTHX_ int method, int flags);
PERL_CALLCONV I32	Perl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s, const char *strbeg, const char *strend, char **new_s, I32 ocnt, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_UNPACK_STR	\
	assert(pat); assert(patend); assert(s); assert(strend)

PERL_CALLCONV I32	Perl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_UNPACKSTRING	\
	assert(pat); assert(patend); assert(s); assert(strend)

PERL_CALLCONV void	Perl_unshare_hek(pTHX_ HEK* hek);
PERL_CALLCONV void	Perl_unsharepvn(pTHX_ const char* sv, I32 len, U32 hash);
PERL_CALLCONV SV*	Perl_upg_version(pTHX_ SV *ver, bool qv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UPG_VERSION	\
	assert(ver)

PERL_CALLCONV U8*	Perl_utf16_to_utf8(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_UTF16_TO_UTF8	\
	assert(p); assert(d); assert(newlen)

PERL_CALLCONV U8*	Perl_utf16_to_utf8_reversed(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_UTF16_TO_UTF8_REVERSED	\
	assert(p); assert(d); assert(newlen)

PERL_CALLCONV IV	Perl_utf8_distance(pTHX_ const U8 *a, const U8 *b)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF8_DISTANCE	\
	assert(a); assert(b)

PERL_CALLCONV U8*	Perl_utf8_hop(pTHX_ const U8 *s, I32 off)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UTF8_HOP	\
	assert(s)

PERL_CALLCONV STRLEN	Perl_utf8_length(pTHX_ const U8* s, const U8 *e)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF8_LENGTH	\
	assert(s); assert(e)

PERL_CALLCONV U8*	Perl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF8_TO_BYTES	\
	assert(s); assert(len)

PERL_CALLCONV UV	Perl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__deprecated__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UTF8_TO_UVCHR	\
	assert(s)

/* PERL_CALLCONV UV	utf8_to_uvchr_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV UV	Perl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__deprecated__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI	\
	assert(s)

PERL_CALLCONV UV	Perl_utf8_to_uvuni_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
			__attribute__deprecated__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI_BUF	\
	assert(s); assert(send)

PERL_CALLCONV UV	Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR	\
	assert(s)

PERL_CALLCONV UV	Perl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UTF8N_TO_UVUNI	\
	assert(s)

/* PERL_CALLCONV U8*	uvchr_to_utf8(pTHX_ U8 *d, UV uv)
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV U8*	uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV U8*	Perl_uvoffuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS	\
	assert(d)

PERL_CALLCONV U8*	Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8	\
	assert(d)

PERL_CALLCONV U8*	Perl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS	\
	assert(d)

PERL_CALLCONV UV	Perl_valid_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVCHR	\
	assert(s)

PERL_CALLCONV UV	Perl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__deprecated__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI	\
	assert(s)

PERL_CALLCONV bool	Perl_validate_proto(pTHX_ SV *name, SV *proto, bool warn)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VALIDATE_PROTO	\
	assert(name)

PERL_CALLCONV int	Perl_vcmp(pTHX_ SV *lhv, SV *rhv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_VCMP	\
	assert(lhv); assert(rhv)

PERL_CALLCONV_NO_RET void	Perl_vcroak(pTHX_ const char* pat, va_list* args)
			__attribute__noreturn__;

PERL_CALLCONV void	Perl_vdeb(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VDEB	\
	assert(pat)

PERL_CALLCONV char*	Perl_vform(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VFORM	\
	assert(pat)

PERL_CALLCONV void	Perl_vivify_defelem(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VIVIFY_DEFELEM	\
	assert(sv)

PERL_CALLCONV SV*	Perl_vivify_ref(pTHX_ SV* sv, U32 to_what)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VIVIFY_REF	\
	assert(sv)

PERL_CALLCONV void	Perl_vload_module(pTHX_ U32 flags, SV* name, SV* ver, va_list* args)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_VLOAD_MODULE	\
	assert(name)

PERL_CALLCONV SV*	Perl_vmess(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VMESS	\
	assert(pat)

PERL_CALLCONV SV*	Perl_vnewSVpvf(pTHX_ const char *const pat, va_list *const args)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VNEWSVPVF	\
	assert(pat)

PERL_CALLCONV SV*	Perl_vnormal(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VNORMAL	\
	assert(vs)

PERL_CALLCONV SV*	Perl_vnumify(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VNUMIFY	\
	assert(vs)

PERL_CALLCONV SV*	Perl_vstringify(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VSTRINGIFY	\
	assert(vs)

PERL_CALLCONV SV*	Perl_vverify(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VVERIFY	\
	assert(vs)

PERL_CALLCONV void	Perl_vwarn(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VWARN	\
	assert(pat)

PERL_CALLCONV void	Perl_vwarner(pTHX_ U32 err, const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_VWARNER	\
	assert(pat)

PERL_CALLCONV I32	Perl_wait4pid(pTHX_ Pid_t pid, int* statusp, int flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_WAIT4PID	\
	assert(statusp)

PERL_CALLCONV void	Perl_warn(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WARN	\
	assert(pat)

PERL_CALLCONV void	Perl_warn_sv(pTHX_ SV *baseex)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WARN_SV	\
	assert(baseex)

PERL_CALLCONV void	Perl_warner(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_WARNER	\
	assert(pat)

PERL_CALLCONV I32	Perl_was_lvalue_sub(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_watch(pTHX_ char** addr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WATCH	\
	assert(addr)

/* PERL_CALLCONV I32	whichsig(pTHX_ const char* sig)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV I32	Perl_whichsig_pv(pTHX_ const char* sig)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WHICHSIG_PV	\
	assert(sig)

PERL_CALLCONV I32	Perl_whichsig_pvn(pTHX_ const char* sig, STRLEN len)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WHICHSIG_PVN	\
	assert(sig)

PERL_CALLCONV I32	Perl_whichsig_sv(pTHX_ SV* sigsv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WHICHSIG_SV	\
	assert(sigsv)

PERL_CALLCONV void	Perl_wrap_op_checker(pTHX_ Optype opcode, Perl_check_t new_checker, Perl_check_t *old_checker_p)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_WRAP_OP_CHECKER	\
	assert(new_checker); assert(old_checker_p)

PERL_CALLCONV void	Perl_write_to_stderr(pTHX_ SV* msv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WRITE_TO_STDERR	\
	assert(msv)

PERL_CALLCONV void	Perl_xs_apiversion_bootcheck(pTHX_ SV *module, const char *api_p, STRLEN api_len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_XS_APIVERSION_BOOTCHECK	\
	assert(module); assert(api_p)

PERL_CALLCONV void	Perl_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p, STRLEN xs_len)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK	\
	assert(xs_p)

PERL_CALLCONV int	Perl_yyerror(pTHX_ const char *const s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_YYERROR	\
	assert(s)

PERL_CALLCONV int	Perl_yyerror_pv(pTHX_ const char *const s, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_YYERROR_PV	\
	assert(s)

PERL_CALLCONV int	Perl_yyerror_pvn(pTHX_ const char *const s, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_YYERROR_PVN	\
	assert(s)

PERL_CALLCONV int	Perl_yylex(pTHX);
PERL_CALLCONV int	Perl_yyparse(pTHX_ int gramtype);
PERL_CALLCONV void	Perl_yyunlex(pTHX);
#if !(defined(DEBUGGING))
#  if !defined(NV_PRESERVES_UV)
#    if defined(PERL_IN_SV_C)
STATIC int	S_sv_2iuv_non_preserve(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE	\
	assert(sv)

#    endif
#  endif
#endif
#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))
PERL_CALLCONV Signal_t	Perl_csighandler(int sig);
PERL_CALLCONV Signal_t	Perl_sighandler(int sig);
#endif
#if !(defined(NO_MATHOMS))
PERL_CALLCONV void	Perl_sv_nounlocking(pTHX_ SV *sv);
#endif
#if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))
PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_EXEC	\
	assert(cmd)

#endif
#if !(defined(PERL_GLOBAL_STRUCT_PRIVATE))
#  if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV void*	Perl_my_cxt_init(pTHX_ int *index, size_t size)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MY_CXT_INIT	\
	assert(index)

#  endif
#endif
#if !(defined(PERL_MAD))
PERL_CALLCONV void	Perl_newFORM(pTHX_ I32 floor, OP* o, OP* block);
PERL_CALLCONV void	Perl_package(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PACKAGE	\
	assert(o)

PERL_CALLCONV void	Perl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_UTILIZE	\
	assert(idop)

#endif
#if !(defined(WIN32))
/* PERL_CALLCONV char*	my_setlocale(pTHX_ int category, const char* locale)
			__attribute__pure__; */

#endif
#if !(defined(_MSC_VER))
PERL_CALLCONV_NO_RET int	Perl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET	\
	assert(sv); assert(mg)

#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
PERL_CALLCONV char*	Perl_my_bzero(char* loc, I32 len)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_MY_BZERO	\
	assert(loc)

#endif
#if !defined(HAS_GETENV_LEN)
PERL_CALLCONV char*	Perl_getenv_len(pTHX_ const char *env_elem, unsigned long *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GETENV_LEN	\
	assert(env_elem); assert(len)

#endif
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
PERL_CALLCONV I32	Perl_my_memcmp(const char* s1, const char* s2, I32 len)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_MY_MEMCMP	\
	assert(s1); assert(s2)

#endif
#if !defined(HAS_MEMSET)
PERL_CALLCONV void*	Perl_my_memset(char* loc, I32 ch, I32 len)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_MY_MEMSET	\
	assert(loc)

#endif
#if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#  if defined(PERL_IN_PP_SYS_C)
STATIC int	S_dooneliner(pTHX_ const char *cmd, const char *filename)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DOONELINER	\
	assert(cmd); assert(filename)

#  endif
#endif
#if !defined(HAS_RENAME)
PERL_CALLCONV I32	Perl_same_dirent(pTHX_ const char* a, const char* b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SAME_DIRENT	\
	assert(a); assert(b)

#endif
#if !defined(HAS_SIGNBIT)
PERL_CALLCONV int	Perl_signbit(NV f)
			__attribute__pure__;

#endif
#if !defined(HAS_STRLCAT)
PERL_CALLCONV Size_t	Perl_my_strlcat(char *dst, const char *src, Size_t size);
#endif
#if !defined(HAS_STRLCPY)
PERL_CALLCONV Size_t	Perl_my_strlcpy(char *dst, const char *src, Size_t size);
#endif
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
PERL_CALLCONV I32	Perl_my_chsize(pTHX_ int fd, Off_t length)
			__attribute__warn_unused_result__;

#endif
#if !defined(NV_PRESERVES_UV)
#  if defined(DEBUGGING)
#    if defined(PERL_IN_SV_C)
STATIC int	S_sv_2iuv_non_preserve(pTHX_ SV *const sv, I32 numtype)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE	\
	assert(sv)

#    endif
#  endif
#endif
#if !defined(PERL_DISABLE_PMC)
#  if defined(PERL_IN_PP_CTL_C)
STATIC PerlIO *	S_doopen_pm(pTHX_ SV *name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DOOPEN_PM	\
	assert(name)

#  endif
#endif
#if !defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV I32	Perl_my_pclose(pTHX_ PerlIO* ptr);
PERL_CALLCONV PerlIO*	Perl_my_popen(pTHX_ const char* cmd, const char* mode)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MY_POPEN	\
	assert(cmd); assert(mode)

#endif
#if !defined(PERL_IS_MINIPERL)
#  if defined(PERL_IN_PERL_C)
STATIC SV *	S_incpush_if_exists(pTHX_ AV *const av, SV *dir, SV *const stem)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_INCPUSH_IF_EXISTS	\
	assert(av); assert(dir); assert(stem)

#  endif
#endif
#if !defined(PERL_NO_UTF16_FILTER)
#  if defined(PERL_IN_TOKE_C)
STATIC U8*	S_add_utf16_textfilter(pTHX_ U8 *const s, bool reversed)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_ADD_UTF16_TEXTFILTER	\
	assert(s)

STATIC I32	S_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF16_TEXTFILTER	\
	assert(sv)

#  endif
#endif
#if !defined(SETUID_SCRIPTS_ARE_SECURE_NOW)
#  if defined(PERL_IN_PERL_C)
STATIC void	S_validate_suid(pTHX_ PerlIO *rsfp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VALIDATE_SUID	\
	assert(rsfp)

#  endif
#endif
#if !defined(SPRINTF_RETURNS_STRLEN)
PERL_CALLCONV int	Perl_my_sprintf(char *buffer, const char *pat, ...)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_MY_SPRINTF	\
	assert(buffer); assert(pat)

#endif
#if !defined(WIN32)
PERL_CALLCONV bool	Perl_do_exec3(pTHX_ const char *incmd, int fd, int do_report)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_EXEC3	\
	assert(incmd)

#endif
#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
PERL_CALLCONV char*	Perl_my_bcopy(const char* from, char* to, I32 len)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_MY_BCOPY	\
	assert(from); assert(to)

#endif
#if defined(DEBUGGING)
PERL_CALLCONV int	Perl_get_debug_opts(pTHX_ const char **s, bool givehelp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_DEBUG_OPTS	\
	assert(s)

PERL_CALLCONV void	Perl_hv_assert(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_ASSERT	\
	assert(hv)

PERL_CALLCONV void	Perl_pad_setsv(pTHX_ PADOFFSET po, SV* sv)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PAD_SETSV	\
	assert(sv)

PERL_CALLCONV SV*	Perl_pad_sv(pTHX_ PADOFFSET po);
#  if defined(PERL_IN_PAD_C)
STATIC void	S_cv_dump(pTHX_ const CV *cv, const char *title)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CV_DUMP	\
	assert(cv); assert(title)

#  endif
#  if defined(PERL_IN_REGCOMP_C)
STATIC void	S_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DUMP_TRIE	\
	assert(trie); assert(revcharmap)

STATIC void	S_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST	\
	assert(trie); assert(revcharmap)

STATIC void	S_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE	\
	assert(trie); assert(revcharmap)

STATIC const regnode*	S_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node, const regnode *last, const regnode *plast, SV* sv, I32 indent, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_6);
#define PERL_ARGS_ASSERT_DUMPUNTIL	\
	assert(r); assert(start); assert(node); assert(sv)

STATIC void	S_put_byte(pTHX_ SV* sv, int c)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PUT_BYTE	\
	assert(sv)

STATIC bool	S_put_latin1_charclass_innards(pTHX_ SV* sv, char* bitmap)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PUT_LATIN1_CHARCLASS_INNARDS	\
	assert(sv); assert(bitmap)

STATIC void	S_put_range(pTHX_ SV* sv, UV start, UV end)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PUT_RANGE	\
	assert(sv)

STATIC void	S_regdump_extflags(pTHX_ const char *lead, const U32 flags);
STATIC void	S_regdump_intflags(pTHX_ const char *lead, const U32 flags);
STATIC U8	S_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REGTAIL_STUDY	\
	assert(pRExC_state); assert(p); assert(val)

#  endif
#  if defined(PERL_IN_REGEXEC_C)
STATIC void	S_debug_start_match(pTHX_ const REGEXP *prog, const bool do_utf8, const char *start, const char *end, const char *blurb)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_DEBUG_START_MATCH	\
	assert(prog); assert(start); assert(end); assert(blurb)

STATIC void	S_dump_exec_pos(pTHX_ const char *locinput, const regnode *scan, const char *loc_regeol, const char *loc_bostr, const char *loc_reg_starttry, const bool do_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_DUMP_EXEC_POS	\
	assert(locinput); assert(scan); assert(loc_regeol); assert(loc_bostr); assert(loc_reg_starttry)

#  endif
#  if defined(PERL_IN_SV_C)
STATIC void	S_del_sv(pTHX_ SV *p)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DEL_SV	\
	assert(p)

#  endif
#  if defined(PERL_IN_TOKE_C)
STATIC void	S_printbuf(pTHX_ const char *const fmt, const char *const s)
			__attribute__format__(__printf__,pTHX_1,0)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PRINTBUF	\
	assert(fmt); assert(s)

STATIC int	S_tokereport(pTHX_ I32 rv, const YYSTYPE* lvalp)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TOKEREPORT	\
	assert(lvalp)

#  endif
#endif
#if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)
PERL_CALLCONV void	Perl_dump_sv_child(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_SV_CHILD	\
	assert(sv)

#endif
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
PERL_CALLCONV I32	Perl_do_ipcctl(pTHX_ I32 optype, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_IPCCTL	\
	assert(mark); assert(sp)

PERL_CALLCONV I32	Perl_do_ipcget(pTHX_ I32 optype, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_IPCGET	\
	assert(mark); assert(sp)

PERL_CALLCONV I32	Perl_do_msgrcv(pTHX_ SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_MSGRCV	\
	assert(mark); assert(sp)

PERL_CALLCONV I32	Perl_do_msgsnd(pTHX_ SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_MSGSND	\
	assert(mark); assert(sp)

PERL_CALLCONV I32	Perl_do_semop(pTHX_ SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_SEMOP	\
	assert(mark); assert(sp)

PERL_CALLCONV I32	Perl_do_shmio(pTHX_ I32 optype, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_SHMIO	\
	assert(mark); assert(sp)

#endif
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
PERL_CALLCONV Signal_t	Perl_csighandler(int sig, siginfo_t *info, void *uap);
PERL_CALLCONV Signal_t	Perl_sighandler(int sig, siginfo_t *info, void *uap);
#endif
#if defined(HAVE_INTERP_INTERN)
PERL_CALLCONV void	Perl_sys_intern_clear(pTHX);
PERL_CALLCONV void	Perl_sys_intern_init(pTHX);
#  if defined(USE_ITHREADS)
PERL_CALLCONV void	Perl_sys_intern_dup(pTHX_ struct interp_intern* src, struct interp_intern* dst)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SYS_INTERN_DUP	\
	assert(src); assert(dst)

#  endif
#endif
#if defined(MYMALLOC)
PERL_CALLCONV void	Perl_dump_mstats(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_MSTATS	\
	assert(s)

PERL_CALLCONV int	Perl_get_mstats(pTHX_ perl_mstats_t *buf, int buflen, int level)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_MSTATS	\
	assert(buf)

PERL_CALLCONV MEM_SIZE	Perl_malloc_good_size(size_t nbytes)
			__attribute__warn_unused_result__;

PERL_CALLCONV MEM_SIZE	Perl_malloced_size(void *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_MALLOCED_SIZE	\
	assert(p)

#endif
#if defined(NO_MATHOMS)
/* PERL_CALLCONV void	Perl_sv_nounlocking(pTHX_ SV *sv); */
#endif
#if defined(PERL_ANY_COW)
PERL_CALLCONV SV*	Perl_sv_setsv_cow(pTHX_ SV* dstr, SV* sstr)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_SETSV_COW	\
	assert(sstr)

#endif
#if defined(PERL_CORE)
PERL_CALLCONV void	Perl_opslab_force_free(pTHX_ OPSLAB *slab)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OPSLAB_FORCE_FREE	\
	assert(slab)

PERL_CALLCONV void	Perl_opslab_free(pTHX_ OPSLAB *slab)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OPSLAB_FREE	\
	assert(slab)

PERL_CALLCONV void	Perl_opslab_free_nopad(pTHX_ OPSLAB *slab)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD	\
	assert(slab)

PERL_CALLCONV void	Perl_parser_free_nexttoke_ops(pTHX_ yy_parser *parser, OPSLAB *slab)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS	\
	assert(parser); assert(slab)

#  if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV void	Perl_Slab_to_ro(pTHX_ OPSLAB *slab)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SLAB_TO_RO	\
	assert(slab)

PERL_CALLCONV void	Perl_Slab_to_rw(pTHX_ OPSLAB *const slab)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SLAB_TO_RW	\
	assert(slab)

#  endif
#endif
#if defined(PERL_CORE) || defined (PERL_EXT)
PERL_STATIC_INLINE STRLEN	S_sv_or_pv_pos_u2b(pTHX_ SV *sv, const char *pv, STRLEN pos, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_OR_PV_POS_U2B	\
	assert(sv); assert(pv)

#endif
#if defined(PERL_CR_FILTER)
#  if defined(PERL_IN_TOKE_C)
STATIC I32	S_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen);
STATIC void	S_strip_return(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_STRIP_RETURN	\
	assert(sv)

#  endif
#endif
#if defined(PERL_DEBUG_READONLY_COW)
PERL_CALLCONV void	Perl_sv_buf_to_ro(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_BUF_TO_RO	\
	assert(sv)

#  if defined(PERL_IN_SV_C)
STATIC void	S_sv_buf_to_rw(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_BUF_TO_RW	\
	assert(sv)

#  endif
#endif
#if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV PADOFFSET	Perl_op_refcnt_dec(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_REFCNT_DEC	\
	assert(o)

PERL_CALLCONV OP *	Perl_op_refcnt_inc(pTHX_ OP *o);
#endif
#if defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION)
/* PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd)
			__attribute__nonnull__(pTHX_1); */

#endif
#if defined(PERL_DONT_CREATE_GVSV)
/* PERL_CALLCONV GV*	Perl_gv_SVadd(pTHX_ GV *gv); */
#endif
#if defined(PERL_GLOBAL_STRUCT)
PERL_CALLCONV struct perl_vars *	Perl_GetVars(pTHX);
PERL_CALLCONV void	Perl_free_global_struct(pTHX_ struct perl_vars *plvarsp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT	\
	assert(plvarsp)

PERL_CALLCONV struct perl_vars*	Perl_init_global_struct(pTHX);
#endif
#if defined(PERL_GLOBAL_STRUCT_PRIVATE)
#  if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV int	Perl_my_cxt_index(pTHX_ const char *my_cxt_key)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MY_CXT_INDEX	\
	assert(my_cxt_key)

PERL_CALLCONV void*	Perl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MY_CXT_INIT	\
	assert(my_cxt_key)

#  endif
#endif
#if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV_NO_RET void	Perl_croak_nocontext(const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,1,2);

PERL_CALLCONV void	Perl_deb_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_DEB_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV OP*	Perl_die_nocontext(const char* pat, ...)
			__attribute__format__null_ok__(__printf__,1,2);

PERL_CALLCONV char*	Perl_form_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_FORM_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV int	Perl_fprintf_nocontext(PerlIO *stream, const char *format, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_FPRINTF_NOCONTEXT	\
	assert(stream); assert(format)

PERL_CALLCONV void	Perl_load_module_nocontext(U32 flags, SV* name, SV* ver, ...)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_LOAD_MODULE_NOCONTEXT	\
	assert(name)

PERL_CALLCONV SV*	Perl_mess_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_MESS_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV SV*	Perl_newSVpvf_nocontext(const char *const pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_NEWSVPVF_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV int	Perl_printf_nocontext(const char *format, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PRINTF_NOCONTEXT	\
	assert(format)

PERL_CALLCONV void	Perl_sv_catpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_SV_CATPVF_MG_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_catpvf_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_SV_CATPVF_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_SV_SETPVF_MG_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpvf_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_SV_SETPVF_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_warn_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_WARN_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV void	Perl_warner_nocontext(U32 err, const char* pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_WARNER_NOCONTEXT	\
	assert(pat)

#endif
#if defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV PerlInterpreter*	perl_alloc_using(struct IPerlMem *ipM, struct IPerlMem *ipMS, struct IPerlMem *ipMP, struct IPerlEnv *ipE, struct IPerlStdIO *ipStd, struct IPerlLIO *ipLIO, struct IPerlDir *ipD, struct IPerlSock *ipS, struct IPerlProc *ipP)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4)
			__attribute__nonnull__(5)
			__attribute__nonnull__(6)
			__attribute__nonnull__(7)
			__attribute__nonnull__(8)
			__attribute__nonnull__(9);
#define PERL_ARGS_ASSERT_PERL_ALLOC_USING	\
	assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)

#  if defined(USE_ITHREADS)
PERL_CALLCONV PerlInterpreter*	perl_clone_using(PerlInterpreter *proto_perl, UV flags, struct IPerlMem* ipM, struct IPerlMem* ipMS, struct IPerlMem* ipMP, struct IPerlEnv* ipE, struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO, struct IPerlDir* ipD, struct IPerlSock* ipS, struct IPerlProc* ipP)
			__attribute__nonnull__(1)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4)
			__attribute__nonnull__(5)
			__attribute__nonnull__(6)
			__attribute__nonnull__(7)
			__attribute__nonnull__(8)
			__attribute__nonnull__(9)
			__attribute__nonnull__(10)
			__attribute__nonnull__(11);
#define PERL_ARGS_ASSERT_PERL_CLONE_USING	\
	assert(proto_perl); assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)

#  endif
#endif
#if defined(PERL_IN_AV_C)
STATIC MAGIC*	S_get_aux_mg(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_AUX_MG	\
	assert(av)

#endif
#if defined(PERL_IN_DEB_C)
STATIC void	S_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max, I32 mark_min, I32 mark_max)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DEB_STACK_N	\
	assert(stack_base)

#endif
#if defined(PERL_IN_DOIO_C)
STATIC void	S_exec_failed(pTHX_ const char *cmd, int fd, int do_report)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_EXEC_FAILED	\
	assert(cmd)

STATIC bool	S_ingroup(pTHX_ Gid_t testgid, bool effective)
			__attribute__warn_unused_result__;

STATIC bool	S_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname, PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype, int writing, bool was_fdopen, const char *type)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_OPENN_CLEANUP	\
	assert(gv); assert(io); assert(mode); assert(oname)

STATIC IO *	S_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp, int *savefd, char *savetype)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5)
			__attribute__nonnull__(pTHX_6);
#define PERL_ARGS_ASSERT_OPENN_SETUP	\
	assert(gv); assert(mode); assert(saveifp); assert(saveofp); assert(savefd); assert(savetype)

#endif
#if defined(PERL_IN_DOOP_C)
STATIC I32	S_do_trans_complex(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX	\
	assert(sv)

STATIC I32	S_do_trans_complex_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX_UTF8	\
	assert(sv)

STATIC I32	S_do_trans_count(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS_COUNT	\
	assert(sv)

STATIC I32	S_do_trans_count_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS_COUNT_UTF8	\
	assert(sv)

STATIC I32	S_do_trans_simple(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE	\
	assert(sv)

STATIC I32	S_do_trans_simple_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE_UTF8	\
	assert(sv)

#endif
#if defined(PERL_IN_DUMP_C)
STATIC CV*	S_deb_curcv(pTHX_ const I32 ix);
STATIC void	S_debprof(pTHX_ const OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DEBPROF	\
	assert(o)

STATIC SV*	S_pm_description(pTHX_ const PMOP *pm)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PM_DESCRIPTION	\
	assert(pm)

STATIC UV	S_sequence_num(pTHX_ const OP *o);
#  if defined(PERL_MAD)
STATIC void	S_xmldump_attr(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_XMLDUMP_ATTR	\
	assert(file); assert(pat)

#  endif
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)
PERL_CALLCONV void	Perl_hv_kill_backrefs(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_KILL_BACKREFS	\
	assert(hv)

#endif
#if defined(PERL_IN_GV_C)
STATIC bool	S_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len, const U32 is_utf8, const I32 add, svtype sv_type)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_FIND_DEFAULT_STASH	\
	assert(stash); assert(name)

STATIC void	S_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_INIT_SVTYPE	\
	assert(gv)

STATIC bool	S_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_IS_IN_MAIN	\
	assert(name)

STATIC bool	S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, bool addmg, svtype sv_type)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GV_MAGICALIZE	\
	assert(gv); assert(stash); assert(name)

STATIC void	S_gv_magicalize_isa(pTHX_ GV *gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA	\
	assert(gv)

STATIC void	S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV	\
	assert(gv); assert(name)

STATIC bool	S_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name, STRLEN *len, const char *nambeg, STRLEN full_len, const U32 is_utf8, const I32 add)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME	\
	assert(stash); assert(gv); assert(name); assert(len); assert(nambeg)

STATIC HV*	S_require_tie_mod(pTHX_ GV *gv, const char *varpv, SV* namesv, const char *methpv, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_REQUIRE_TIE_MOD	\
	assert(gv); assert(varpv); assert(namesv); assert(methpv)

#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)
PERL_CALLCONV void	Perl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_ADD_BACKREF	\
	assert(tsv); assert(sv)

#endif
#if defined(PERL_IN_HV_C)
STATIC void	S_clear_placeholders(pTHX_ HV *hv, U32 items)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS	\
	assert(hv)

STATIC void	S_hfreeentries(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HFREEENTRIES	\
	assert(hv)

STATIC void	S_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HSPLIT	\
	assert(hv)

STATIC struct xpvhv_aux*	S_hv_auxinit(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_AUXINIT	\
	assert(hv)

STATIC struct xpvhv_aux*	S_hv_auxinit_internal(struct xpvhv_aux *iter)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_HV_AUXINIT_INTERNAL	\
	assert(iter)

STATIC SV*	S_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);
STATIC SV*	S_hv_free_ent_ret(pTHX_ HV *hv, HE *entry)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HV_FREE_ENT_RET	\
	assert(hv); assert(entry)

STATIC void	S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_HV_MAGIC_CHECK	\
	assert(hv); assert(needs_copy); assert(needs_store)

PERL_STATIC_NO_RET void	S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_HV_NOTALLOWED	\
	assert(key); assert(msg)

STATIC HE*	S_new_he(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_STATIC_INLINE U32	S_ptr_hash(PTRV u);
STATIC SV *	S_refcounted_he_value(pTHX_ const struct refcounted_he *he)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE	\
	assert(he)

STATIC HEK*	S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_SAVE_HEK_FLAGS	\
	assert(str)

STATIC HEK*	S_share_hek_flags(pTHX_ const char *str, I32 len, U32 hash, int flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SHARE_HEK_FLAGS	\
	assert(str)

STATIC void	S_unshare_hek_or_pvn(pTHX_ const HEK* hek, const char* str, I32 len, U32 hash);
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void	Perl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_KILL_BACKREFS	\
	assert(sv)

#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV SV*	Perl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY	\
	assert(hv); assert(indexp)

#endif
#if defined(PERL_IN_LOCALE_C) && defined(USE_LOCALE)
STATIC bool	S_is_cur_LC_category_utf8(pTHX_ int category);
STATIC char*	S_stdize_locale(pTHX_ char* locs)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_STDIZE_LOCALE	\
	assert(locs)

#endif
#if defined(PERL_IN_MALLOC_C)
STATIC int	S_adjust_size_and_find_bucket(size_t *nbytes_p)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_ADJUST_SIZE_AND_FIND_BUCKET	\
	assert(nbytes_p)

#endif
#if defined(PERL_IN_MG_C)
STATIC void	S_fixup_errno_string(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING	\
	assert(sv)

STATIC SV*	S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, int n, SV *val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MAGIC_METHCALL1	\
	assert(sv); assert(mg); assert(meth)

STATIC int	S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MAGIC_METHPACK	\
	assert(sv); assert(mg); assert(meth)

STATIC void	S_restore_magic(pTHX_ const void *p);
STATIC void	S_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS	\
	assert(sv)

STATIC void	S_unwind_handler_stack(pTHX_ const void *p);
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV bool	Perl_translate_substr_offsets(pTHX_ STRLEN curlen, IV pos1_iv, bool pos1_is_uv, IV len_iv, bool len_is_uv, STRLEN *posp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_6)
			__attribute__nonnull__(pTHX_7);
#define PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS	\
	assert(posp); assert(lenp)

#endif
#if defined(PERL_IN_MRO_C)
STATIC void	S_mro_clean_isarev(pTHX_ HV * const isa, const char * const name, const STRLEN len, HV * const exceptions, U32 hash, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MRO_CLEAN_ISAREV	\
	assert(isa); assert(name)

STATIC void	S_mro_gather_and_rename(pTHX_ HV * const stashes, HV * const seen_stashes, HV *stash, HV *oldstash, SV *namesv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_MRO_GATHER_AND_RENAME	\
	assert(stashes); assert(seen_stashes); assert(namesv)

STATIC AV*	S_mro_get_linear_isa_dfs(pTHX_ HV* stash, U32 level)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA_DFS	\
	assert(stash)

#endif
#if defined(PERL_IN_NUMERIC_C)
STATIC NV	S_mulexp10(NV value, I32 exponent);
#endif
#if defined(PERL_IN_OP_C)
PERL_STATIC_INLINE bool	S_aassign_common_vars(pTHX_ OP* o);
STATIC void	S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_APPLY_ATTRS	\
	assert(stash); assert(target)

STATIC void	S_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_APPLY_ATTRS_MY	\
	assert(stash); assert(target); assert(imopsp)

STATIC void	S_bad_type_gv(pTHX_ I32 n, const char *t, GV *gv, U32 flags, const OP *kid)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_BAD_TYPE_GV	\
	assert(t); assert(gv); assert(kid)

STATIC void	S_bad_type_pv(pTHX_ I32 n, const char *t, const char *name, U32 flags, const OP *kid)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_BAD_TYPE_PV	\
	assert(t); assert(name); assert(kid)

STATIC void	S_cop_free(pTHX_ COP *cop)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_COP_FREE	\
	assert(cop)

STATIC OP *	S_dup_attrlist(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUP_ATTRLIST	\
	assert(o)

STATIC void	S_finalize_op(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FINALIZE_OP	\
	assert(o)

STATIC void	S_find_and_forget_pmops(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS	\
	assert(o)

STATIC OP*	S_fold_constants(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FOLD_CONSTANTS	\
	assert(o)

STATIC OP*	S_force_list(pTHX_ OP* arg);
STATIC void	S_forget_pmop(pTHX_ PMOP *const o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORGET_PMOP	\
	assert(o)

STATIC OP*	S_gen_constant_list(pTHX_ OP* o);
STATIC SV*	S_gv_ename(pTHX_ GV *gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_ENAME	\
	assert(gv)

STATIC void	S_inplace_aassign(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INPLACE_AASSIGN	\
	assert(o)

STATIC bool	S_is_handle_constructor(const OP *o, I32 numargs)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR	\
	assert(o)

STATIC I32	S_is_list_assignment(pTHX_ const OP *o)
			__attribute__warn_unused_result__;

STATIC OP*	S_listkids(pTHX_ OP* o);
STATIC bool	S_looks_like_bool(pTHX_ const OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL	\
	assert(o)

STATIC OP*	S_modkids(pTHX_ OP *o, I32 type);
STATIC void	S_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV *name)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MOVE_PROTO_ATTR	\
	assert(proto); assert(attrs); assert(name)

STATIC OP *	S_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MY_KID	\
	assert(imopsp)

STATIC OP*	S_newDEFSVOP(pTHX)
			__attribute__warn_unused_result__;

STATIC OP*	S_newGIVWHENOP(pTHX_ OP* cond, OP *block, I32 enter_opcode, I32 leave_opcode, PADOFFSET entertarg)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWGIVWHENOP	\
	assert(block)

STATIC OP*	S_new_logop(pTHX_ I32 type, I32 flags, OP **firstp, OP **otherp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_NEW_LOGOP	\
	assert(firstp); assert(otherp)

STATIC void	S_no_bareword_allowed(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED	\
	assert(o)

STATIC OP*	S_no_fh_allowed(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NO_FH_ALLOWED	\
	assert(o)

STATIC void	S_null_listop_in_list_context(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NULL_LISTOP_IN_LIST_CONTEXT	\
	assert(o)

PERL_STATIC_INLINE OP*	S_op_integerize(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_INTEGERIZE	\
	assert(o)

PERL_STATIC_INLINE OP*	S_op_std_init(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_STD_INIT	\
	assert(o)

STATIC OP*	S_pmtrans(pTHX_ OP* o, OP* expr, OP* repl)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_PMTRANS	\
	assert(o); assert(expr); assert(repl)

STATIC void	S_process_special_blocks(pTHX_ I32 floor, const char *const fullname, GV *const gv, CV *const cv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS	\
	assert(fullname); assert(gv); assert(cv)

STATIC OP*	S_ref_array_or_hash(pTHX_ OP* cond);
STATIC OP*	S_refkids(pTHX_ OP* o, I32 type);
STATIC bool	S_scalar_mod_type(const OP *o, I32 type)
			__attribute__warn_unused_result__;

STATIC OP*	S_scalarboolean(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCALARBOOLEAN	\
	assert(o)

STATIC OP*	S_scalarkids(pTHX_ OP* o);
STATIC OP*	S_scalarseq(pTHX_ OP* o);
STATIC OP*	S_search_const(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SEARCH_CONST	\
	assert(o)

STATIC void	S_simplify_sort(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SIMPLIFY_SORT	\
	assert(o)

STATIC OP*	S_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV	\
	assert(o); assert(name)

STATIC OP*	S_too_few_arguments_sv(pTHX_ OP *o, SV* namesv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_SV	\
	assert(o); assert(namesv)

STATIC OP*	S_too_many_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV	\
	assert(o); assert(name)

STATIC OP*	S_too_many_arguments_sv(pTHX_ OP *o, SV* namesv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_SV	\
	assert(o); assert(namesv)

#endif
#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void	Perl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv, SV * const *new_const_svp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REPORT_REDEFINED_CV	\
	assert(name); assert(old_cv)

#endif
#if defined(PERL_IN_PAD_C)
STATIC PADOFFSET	S_pad_alloc_name(pTHX_ SV *namesv, U32 flags, HV *typestash, HV *ourstash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_ALLOC_NAME	\
	assert(namesv)

STATIC void	S_pad_check_dup(pTHX_ SV *name, U32 flags, const HV *ourstash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PAD_CHECK_DUP	\
	assert(name)

STATIC PADOFFSET	S_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq, int warn, SV** out_capture, SV** out_name_sv, int *out_flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_8)
			__attribute__nonnull__(pTHX_9);
#define PERL_ARGS_ASSERT_PAD_FINDLEX	\
	assert(namepv); assert(cv); assert(out_name_sv); assert(out_flags)

STATIC void	S_pad_reset(pTHX);
#endif
#if defined(PERL_IN_PERL_C)
STATIC void	S_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_FIND_BEGINNING	\
	assert(linestr_sv); assert(rsfp)

STATIC void	S_forbid_setid(pTHX_ const char flag, const bool suidscript);
STATIC void	S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INCPUSH	\
	assert(dir)

STATIC void	S_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INCPUSH_USE_SEP	\
	assert(p)

STATIC void	S_init_ids(pTHX);
STATIC void	S_init_interp(pTHX);
STATIC void	S_init_main_stash(pTHX);
STATIC void	S_init_perllib(pTHX);
STATIC void	S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS	\
	assert(argv)

STATIC void	S_init_predump_symbols(pTHX);
STATIC SV*	S_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MAYBERELOCATE	\
	assert(dir)

PERL_STATIC_NO_RET void	S_minus_v(pTHX)
			__attribute__noreturn__;

PERL_STATIC_NO_RET void	S_my_exit_jump(pTHX)
			__attribute__noreturn__;

STATIC void	S_nuke_stacks(pTHX);
STATIC PerlIO *	S_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_OPEN_SCRIPT	\
	assert(scriptname); assert(suidscript)

STATIC void*	S_parse_body(pTHX_ char **env, XSINIT_t xsinit);
PERL_STATIC_NO_RET void	S_run_body(pTHX_ I32 oldscope)
			__attribute__noreturn__;

PERL_STATIC_NO_RET void	S_usage(pTHX)
			__attribute__noreturn__;

#endif
#if defined(PERL_IN_PP_C)
STATIC void	S_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_CHOMP	\
	assert(retval); assert(sv)

STATIC OP*	S_do_delete_local(pTHX);
STATIC SV*	S_refto(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REFTO	\
	assert(sv)

#endif
#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)
PERL_CALLCONV GV*	Perl_softref2xv(pTHX_ SV *const sv, const char *const what, const svtype type, SV ***spp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_SOFTREF2XV	\
	assert(sv); assert(what); assert(spp)

#endif
#if defined(PERL_IN_PP_CTL_C)
STATIC SV **	S_adjust_stack_on_leave(pTHX_ SV **newsp, SV **sp, SV **mark, I32 gimme, U32 flags, bool lvalue)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_ADJUST_STACK_ON_LEAVE	\
	assert(newsp); assert(sp); assert(mark)

STATIC PerlIO *	S_check_type_and_open(pTHX_ SV *name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN	\
	assert(name)

STATIC void	S_destroy_matcher(pTHX_ PMOP* matcher)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DESTROY_MATCHER	\
	assert(matcher)

STATIC OP*	S_do_smartmatch(pTHX_ HV* seen_this, HV* seen_other, const bool copied);
STATIC OP*	S_docatch(pTHX_ OP *o)
			__attribute__warn_unused_result__;

STATIC bool	S_doeval(pTHX_ int gimme, CV* outside, U32 seq, HV* hh);
STATIC OP*	S_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5)
			__attribute__nonnull__(pTHX_6);
#define PERL_ARGS_ASSERT_DOFINDLABEL	\
	assert(o); assert(label); assert(opstack); assert(oplimit)

STATIC MAGIC *	S_doparseform(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DOPARSEFORM	\
	assert(sv)

STATIC I32	S_dopoptoeval(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptogiven(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DOPOPTOLABEL	\
	assert(label)

STATIC I32	S_dopoptoloop(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptosub_at(pTHX_ const PERL_CONTEXT* cxstk, I32 startingblock)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DOPOPTOSUB_AT	\
	assert(cxstk)

STATIC I32	S_dopoptowhen(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC PMOP*	S_make_matcher(pTHX_ REGEXP* re)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MAKE_MATCHER	\
	assert(re)

STATIC bool	S_matcher_matches_sv(pTHX_ PMOP* matcher, SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MATCHER_MATCHES_SV	\
	assert(matcher); assert(sv)

STATIC bool	S_num_overflow(NV value, I32 fldsize, I32 frcsize)
			__attribute__warn_unused_result__;

PERL_STATIC_INLINE bool	S_path_is_searchable(const char *name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE	\
	assert(name)

STATIC I32	S_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_RUN_USER_FILTER	\
	assert(buf_sv)

STATIC void	S_rxres_free(pTHX_ void** rsp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_RXRES_FREE	\
	assert(rsp)

STATIC void	S_rxres_restore(pTHX_ void **rsp, REGEXP *rx)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_RXRES_RESTORE	\
	assert(rsp); assert(rx)

STATIC void	S_save_lines(pTHX_ AV *array, SV *sv)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SAVE_LINES	\
	assert(sv)

#endif
#if defined(PERL_IN_PP_HOT_C)
STATIC void	S_do_oddball(pTHX_ SV **oddkey, SV **firstkey)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_ODDBALL	\
	assert(oddkey); assert(firstkey)

STATIC SV*	S_method_common(pTHX_ SV* meth, U32* hashp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_METHOD_COMMON	\
	assert(meth)

#endif
#if defined(PERL_IN_PP_PACK_C)
STATIC char *	S_bytes_to_uni(const U8 *start, STRLEN len, char *dest, const bool needs_swap)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_BYTES_TO_UNI	\
	assert(start); assert(dest)

STATIC int	S_div128(pTHX_ SV *pnum, bool *done)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DIV128	\
	assert(pnum); assert(done)

STATIC char	S_first_symbol(const char *pat, const char *patend)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_FIRST_SYMBOL	\
	assert(pat); assert(patend)

STATIC const char *	S_get_num(pTHX_ const char *patptr, I32 *lenptr)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GET_NUM	\
	assert(patptr); assert(lenptr)

STATIC const char *	S_group_end(pTHX_ const char *patptr, const char *patend, char ender)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GROUP_END	\
	assert(patptr); assert(patend)

STATIC SV*	S_is_an_int(pTHX_ const char *s, STRLEN l)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_AN_INT	\
	assert(s)

STATIC I32	S_measure_struct(pTHX_ struct tempsym* symptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MEASURE_STRUCT	\
	assert(symptr)

STATIC SV*	S_mul128(pTHX_ SV *sv, U8 m)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MUL128	\
	assert(sv)

STATIC bool	S_need_utf8(const char *pat, const char *patend)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_NEED_UTF8	\
	assert(pat); assert(patend)

STATIC bool	S_next_symbol(pTHX_ struct tempsym* symptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEXT_SYMBOL	\
	assert(symptr)

STATIC SV **	S_pack_rec(pTHX_ SV *cat, struct tempsym* symptr, SV **beglist, SV **endlist)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_PACK_REC	\
	assert(cat); assert(symptr); assert(beglist); assert(endlist)

STATIC char *	S_sv_exp_grow(pTHX_ SV *sv, STRLEN needed)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_EXP_GROW	\
	assert(sv)

STATIC I32	S_unpack_rec(pTHX_ struct tempsym* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_UNPACK_REC	\
	assert(symptr); assert(s); assert(strbeg); assert(strend)

#endif
#if defined(PERL_IN_PP_SORT_C)
STATIC I32	S_amagic_cmp(pTHX_ SV *const str1, SV *const str2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AMAGIC_CMP	\
	assert(str1); assert(str2)

STATIC I32	S_amagic_cmp_locale(pTHX_ SV *const str1, SV *const str2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AMAGIC_CMP_LOCALE	\
	assert(str1); assert(str2)

STATIC I32	S_amagic_i_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AMAGIC_I_NCMP	\
	assert(a); assert(b)

STATIC I32	S_amagic_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AMAGIC_NCMP	\
	assert(a); assert(b)

STATIC void	S_qsortsvu(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t compare)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_QSORTSVU	\
	assert(compare)

STATIC I32	S_sortcv(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SORTCV	\
	assert(a); assert(b)

STATIC I32	S_sortcv_stacked(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SORTCV_STACKED	\
	assert(a); assert(b)

STATIC I32	S_sortcv_xsub(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SORTCV_XSUB	\
	assert(a); assert(b)

STATIC I32	S_sv_i_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_I_NCMP	\
	assert(a); assert(b)

STATIC I32	S_sv_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_NCMP	\
	assert(a); assert(b)

#endif
#if defined(PERL_IN_PP_SYS_C)
STATIC OP*	S_doform(pTHX_ CV *cv, GV *gv, OP *retop)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DOFORM	\
	assert(cv); assert(gv)

STATIC SV *	S_space_join_names_mortal(pTHX_ char *const *array)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SPACE_JOIN_NAMES_MORTAL	\
	assert(array)

#endif
#if defined(PERL_IN_REGCOMP_C)
STATIC void	S__append_range_to_invlist(pTHX_ SV* const invlist, const UV start, const UV end)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST	\
	assert(invlist)

PERL_STATIC_INLINE UV*	S__invlist_array_init(pTHX_ SV* const invlist, const bool will_have_0)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT	\
	assert(invlist)

PERL_STATIC_INLINE SV*	S_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp)
			__attribute__warn_unused_result__;

STATIC U32	S_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_ADD_DATA	\
	assert(pRExC_state); assert(s)

PERL_STATIC_INLINE void	S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state, regnode *node, I32 *flagp, STRLEN len, UV code_point, bool downgradable)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT	\
	assert(pRExC_state); assert(node); assert(flagp)

PERL_STATIC_INLINE U8	S_compute_EXACTish(pTHX_ RExC_state_t *pRExC_state)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_COMPUTE_EXACTISH	\
	assert(pRExC_state)

STATIC bool	S_could_it_be_a_POSIX_class(pTHX_ RExC_state_t *pRExC_state)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_COULD_IT_BE_A_POSIX_CLASS	\
	assert(pRExC_state)

STATIC SV*	S_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state, const regnode_charclass* const node)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC	\
	assert(pRExC_state); assert(node)

PERL_STATIC_INLINE STRLEN*	S_get_invlist_iter_addr(pTHX_ SV* invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR	\
	assert(invlist)

PERL_STATIC_INLINE IV*	S_get_invlist_previous_index_addr(pTHX_ SV* invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR	\
	assert(invlist)

STATIC bool	S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode** nodep, UV *valuep, I32 *flagp, U32 depth, bool in_char_class, const bool strict)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_GROK_BSLASH_N	\
	assert(pRExC_state); assert(flagp)

STATIC regnode*	S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV ** return_invlist, I32 *flagp, U32 depth, char * const oregcomp_parse)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_HANDLE_REGEX_SETS	\
	assert(pRExC_state); assert(flagp); assert(oregcomp_parse)

PERL_STATIC_INLINE UV*	S_invlist_array(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_ARRAY	\
	assert(invlist)

PERL_STATIC_INLINE SV*	S_invlist_clone(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_CLONE	\
	assert(invlist)

STATIC void	S_invlist_extend(pTHX_ SV* const invlist, const UV len)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_EXTEND	\
	assert(invlist)

PERL_STATIC_INLINE UV	S_invlist_highest(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_HIGHEST	\
	assert(invlist)

PERL_STATIC_INLINE bool	S_invlist_is_iterating(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_IS_ITERATING	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_iterfinish(pTHX_ SV* invlist)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_ITERFINISH	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_iterinit(pTHX_ SV* invlist)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_ITERINIT	\
	assert(invlist)

STATIC bool	S_invlist_iternext(pTHX_ SV* invlist, UV* start, UV* end)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_INVLIST_ITERNEXT	\
	assert(invlist); assert(start); assert(end)

PERL_STATIC_INLINE UV	S_invlist_max(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_MAX	\
	assert(invlist)

PERL_STATIC_INLINE IV	S_invlist_previous_index(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_SET_LEN	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_set_previous_index(pTHX_ SV* const invlist, const IV index)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_trim(pTHX_ SV* const invlist)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INVLIST_TRIM	\
	assert(invlist)

STATIC U32	S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *unfolded_multi_char, U32 flags, regnode *val, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_JOIN_EXACT	\
	assert(pRExC_state); assert(scan); assert(min_subtract); assert(unfolded_multi_char)

STATIC I32	S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_MAKE_TRIE	\
	assert(pRExC_state); assert(startbranch); assert(first); assert(last); assert(tail)

STATIC void	S_make_trie_failtable(pTHX_ RExC_state_t *pRExC_state, regnode *source, regnode *stclass, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MAKE_TRIE_FAILTABLE	\
	assert(pRExC_state); assert(source); assert(stclass)

STATIC char *	S_nextchar(pTHX_ RExC_state_t *pRExC_state)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NEXTCHAR	\
	assert(pRExC_state)

STATIC void	S_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS	\
	assert(pRExC_state)

STATIC void	S_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST	\
	assert(node); assert(invlist_ptr)

PERL_STATIC_NO_RET void	S_re_croak2(pTHX_ bool utf8, const char* pat1, const char* pat2, ...)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_RE_CROAK2	\
	assert(pat1); assert(pat2)

STATIC regnode*	S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REG	\
	assert(pRExC_state); assert(flagp)

STATIC regnode*	S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_NODE	\
	assert(pRExC_state)

STATIC UV	S_reg_recode(pTHX_ const char value, SV **encp)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REG_RECODE	\
	assert(encp)

STATIC SV *	S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_SCAN_NAME	\
	assert(pRExC_state)

STATIC bool	S_reg_skipcomment(pTHX_ RExC_state_t *pRExC_state)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REG_SKIPCOMMENT	\
	assert(pRExC_state)

STATIC regnode*	S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REGANODE	\
	assert(pRExC_state)

STATIC regnode*	S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGATOM	\
	assert(pRExC_state); assert(flagp)

STATIC regnode*	S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGBRANCH	\
	assert(pRExC_state); assert(flagp)

STATIC regnode*	S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth, const bool stop_at_1, bool allow_multi_fold, const bool silence_non_portable, SV** ret_invlist)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGCLASS	\
	assert(pRExC_state); assert(flagp)

STATIC void	S_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *opnd, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REGINSERT	\
	assert(pRExC_state); assert(opnd)

STATIC char *	S_regpatws(RExC_state_t *pRExC_state, char *p, const bool recognize_comment)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_REGPATWS	\
	assert(pRExC_state); assert(p)

STATIC regnode*	S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGPIECE	\
	assert(pRExC_state); assert(flagp)

PERL_STATIC_INLINE I32	S_regpposixcc(pTHX_ RExC_state_t *pRExC_state, I32 value, const bool strict)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REGPPOSIXCC	\
	assert(pRExC_state)

STATIC void	S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REGTAIL	\
	assert(pRExC_state); assert(p); assert(val)

PERL_STATIC_INLINE STRLEN	S_reguni(pTHX_ const RExC_state_t *pRExC_state, UV uv, char *s)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REGUNI	\
	assert(pRExC_state); assert(s)

STATIC char *	S_regwhite(RExC_state_t *pRExC_state, char *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_REGWHITE	\
	assert(pRExC_state); assert(p)

STATIC void	S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, struct scan_data_t *data, SSize_t *minlenp, int is_inf)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SCAN_COMMIT	\
	assert(pRExC_state); assert(data); assert(minlenp)

STATIC void	S_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state, regnode* const node, SV* const cp_list, SV* const runtime_defns, SV* const only_utf8_locale_list, SV* const swash, const bool has_user_defined_property)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SET_ANYOF_ARG	\
	assert(pRExC_state); assert(node)

PERL_STATIC_INLINE void	S_ssc_add_range(pTHX_ regnode_ssc *ssc, UV const start, UV const end)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SSC_ADD_RANGE	\
	assert(ssc)

STATIC void	S_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *and_with)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SSC_AND	\
	assert(pRExC_state); assert(ssc); assert(and_with)

STATIC void	S_ssc_anything(pTHX_ regnode_ssc *ssc)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SSC_ANYTHING	\
	assert(ssc)

PERL_STATIC_INLINE void	S_ssc_clear_locale(pTHX_ regnode_ssc *ssc)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE	\
	assert(ssc)

PERL_STATIC_INLINE void	S_ssc_cp_and(pTHX_ regnode_ssc *ssc, UV const cp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SSC_CP_AND	\
	assert(ssc)

STATIC void	S_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SSC_FINALIZE	\
	assert(pRExC_state); assert(ssc)

STATIC void	S_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SSC_INIT	\
	assert(pRExC_state); assert(ssc)

PERL_STATIC_INLINE void	S_ssc_intersection(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SSC_INTERSECTION	\
	assert(ssc); assert(invlist)

STATIC int	S_ssc_is_anything(pTHX_ const regnode_ssc *ssc)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SSC_IS_ANYTHING	\
	assert(ssc)

STATIC int	S_ssc_is_cp_posixl_init(pTHX_ const RExC_state_t *pRExC_state, const regnode_ssc *ssc)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT	\
	assert(pRExC_state); assert(ssc)

STATIC void	S_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *or_with)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SSC_OR	\
	assert(pRExC_state); assert(ssc); assert(or_with)

PERL_STATIC_INLINE void	S_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SSC_UNION	\
	assert(ssc); assert(invlist)

STATIC SSize_t	S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, SSize_t *minlenp, SSize_t *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U32 recursed_depth, regnode_ssc *and_withp, U32 flags, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_STUDY_CHUNK	\
	assert(pRExC_state); assert(scanp); assert(minlenp); assert(deltap); assert(last)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)
PERL_CALLCONV void	Perl__invlist_dump(pTHX_ PerlIO *file, I32 level, const char* const indent, SV* const invlist)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT__INVLIST_DUMP	\
	assert(file); assert(indent); assert(invlist)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV*	Perl__new_invlist_C_array(pTHX_ const UV* const list)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY	\
	assert(list)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
PERL_CALLCONV SV*	Perl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog, const struct regnode *node, bool doinit, SV **listsvp, SV **lonly_utf8_locale)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA	\
	assert(node)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV*	Perl__get_swash_invlist(pTHX_ SV* const swash)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__GET_SWASH_INVLIST	\
	assert(swash)

PERL_STATIC_INLINE bool	S__invlist_contains_cp(pTHX_ SV* const invlist, const UV cp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__INVLIST_CONTAINS_CP	\
	assert(invlist)

PERL_CALLCONV SV*	Perl__invlist_contents(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__INVLIST_CONTENTS	\
	assert(invlist)

PERL_STATIC_INLINE UV	S__invlist_len(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__INVLIST_LEN	\
	assert(invlist)

PERL_CALLCONV IV	Perl__invlist_search(pTHX_ SV* const invlist, const UV cp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__INVLIST_SEARCH	\
	assert(invlist)

PERL_CALLCONV HV*	Perl__swash_inversion_hash(pTHX_ SV* const swash)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__SWASH_INVERSION_HASH	\
	assert(swash)

PERL_STATIC_INLINE bool*	S_get_invlist_offset_addr(pTHX_ SV* invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_INVLIST_OFFSET_ADDR	\
	assert(invlist)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_TOKE_C)
PERL_CALLCONV SV*	Perl__core_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none, SV* invlist, U8* const flags_p)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT__CORE_SWASH_INIT	\
	assert(pkg); assert(name); assert(listsv)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C)
STATIC char*	S_form_short_octal_warning(pTHX_ const char * const s, const STRLEN len)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORM_SHORT_OCTAL_WARNING	\
	assert(s)

STATIC char	S_grok_bslash_c(pTHX_ const char source, const bool output_warning)
			__attribute__warn_unused_result__;

STATIC bool	S_grok_bslash_o(pTHX_ char** s, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GROK_BSLASH_O	\
	assert(s); assert(uv); assert(error_msg)

PERL_STATIC_INLINE bool	S_grok_bslash_x(pTHX_ char** s, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GROK_BSLASH_X	\
	assert(s); assert(uv); assert(error_msg)

PERL_STATIC_INLINE I32	S_regcurly(pTHX_ const char *s, const bool rbrace_must_be_escaped)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REGCURLY	\
	assert(s)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV*	Perl__add_range_to_invlist(pTHX_ SV* invlist, const UV start, const UV end)
			__attribute__warn_unused_result__;

/* PERL_CALLCONV void	_invlist_intersection(pTHX_ SV* const a, SV* const b, SV** i)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV void	Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** i)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND	\
	assert(b); assert(i)

PERL_CALLCONV void	Perl__invlist_invert(pTHX_ SV* const invlist)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__INVLIST_INVERT	\
	assert(invlist)

PERL_CALLCONV void	Perl__invlist_populate_swatch(pTHX_ SV* const invlist, const UV start, const UV end, U8* swatch)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT__INVLIST_POPULATE_SWATCH	\
	assert(invlist); assert(swatch)

/* PERL_CALLCONV void	_invlist_subtract(pTHX_ SV* const a, SV* const b, SV** result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */

/* PERL_CALLCONV void	_invlist_union(pTHX_ SV* const a, SV* const b, SV** output)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV void	Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** output)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND	\
	assert(b); assert(output)

PERL_CALLCONV SV*	Perl__new_invlist(pTHX_ IV initial_size)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0, UV** other_elements_ptr)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST	\
	assert(other_elements_ptr)

PERL_CALLCONV SV*	Perl__swash_to_invlist(pTHX_ SV* const swash)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__SWASH_TO_INVLIST	\
	assert(swash)

#endif
#if defined(PERL_IN_REGEXEC_C)
STATIC char*	S_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, const char *strend, regmatch_info *reginfo)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_FIND_BYCLASS	\
	assert(prog); assert(c); assert(s); assert(strend)

STATIC bool	S_isFOO_lc(pTHX_ const U8 classnum, const U8 character)
			__attribute__warn_unused_result__;

STATIC bool	S_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_ISFOO_UTF8_LC	\
	assert(character)

STATIC I32	S_reg_check_named_buff_matched(pTHX_ const regexp *rex, const regnode *scan)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED	\
	assert(rex); assert(scan)

STATIC void	S_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGCPPOP	\
	assert(rex); assert(maxopenparen_p)

STATIC CHECKPOINT	S_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_REGCPPUSH	\
	assert(rex)

STATIC U8*	S_reghop3(U8 *s, SSize_t off, const U8 *lim)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_REGHOP3	\
	assert(s); assert(lim)

STATIC U8*	S_reghop4(U8 *s, SSize_t off, const U8 *llim, const U8 *rlim)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4);
#define PERL_ARGS_ASSERT_REGHOP4	\
	assert(s); assert(llim); assert(rlim)

STATIC U8*	S_reghopmaybe3(U8 *s, SSize_t off, const U8 *lim)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_REGHOPMAYBE3	\
	assert(s); assert(lim)

STATIC bool	S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8 * const p, const U8 * const p_end, bool const utf8_target)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_REGINCLASS	\
	assert(n); assert(p); assert(p_end)

STATIC SSize_t	S_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_REGMATCH	\
	assert(reginfo); assert(startpos); assert(prog)

STATIC I32	S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p, regmatch_info *const reginfo, I32 max, int depth)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_REGREPEAT	\
	assert(prog); assert(startposp); assert(p); assert(reginfo)

STATIC I32	S_regtry(pTHX_ regmatch_info *reginfo, char **startposp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGTRY	\
	assert(reginfo); assert(startposp)

STATIC bool	S_to_byte_substr(pTHX_ regexp * prog)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_TO_BYTE_SUBSTR	\
	assert(prog)

STATIC void	S_to_utf8_substr(pTHX_ regexp * prog)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_TO_UTF8_SUBSTR	\
	assert(prog)

#endif
#if defined(PERL_IN_SCOPE_C)
STATIC void	S_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2, const int type);
STATIC SV*	S_save_scalar_at(pTHX_ SV **sptr, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SAVE_SCALAR_AT	\
	assert(sptr)

#endif
#if defined(PERL_IN_SV_C)
STATIC char *	S_F0convert(NV nv, char *const endbuf, STRLEN *const len)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);
#define PERL_ARGS_ASSERT_F0CONVERT	\
	assert(endbuf); assert(len)

STATIC void	S_anonymise_cv_maybe(pTHX_ GV *gv, CV *cv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE	\
	assert(gv); assert(cv)

STATIC void	S_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache, STRLEN real, SV *const sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT	\
	assert(func); assert(sv)

STATIC bool	S_curse(pTHX_ SV * const sv, const bool check_refcnt)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CURSE	\
	assert(sv)

STATIC I32	S_expect_number(pTHX_ char **const pattern)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_EXPECT_NUMBER	\
	assert(pattern)

STATIC I32	S_find_array_subscript(pTHX_ const AV *const av, const SV *const val)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT	\
	assert(val)

STATIC SV *	S_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT	\
	assert(val)

STATIC SV*	S_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv, bool top);
STATIC bool	S_glob_2number(pTHX_ GV* const gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GLOB_2NUMBER	\
	assert(gv)

STATIC void	S_glob_assign_glob(pTHX_ SV *const dstr, SV *const sstr, const int dtype)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB	\
	assert(dstr); assert(sstr)

STATIC void	S_glob_assign_ref(pTHX_ SV *const dstr, SV *const sstr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GLOB_ASSIGN_REF	\
	assert(dstr); assert(sstr)

STATIC SV *	S_more_sv(pTHX);
STATIC void	S_not_a_number(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NOT_A_NUMBER	\
	assert(sv)

STATIC PTR_TBL_ENT_t *	S_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PTR_TABLE_FIND	\
	assert(tbl)

STATIC bool	S_sv_2iuv_common(pTHX_ SV *const sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_2IUV_COMMON	\
	assert(sv)

STATIC void	S_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_ADD_ARENA	\
	assert(ptr)

STATIC STRLEN	S_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target, const U8 *end, STRLEN endu)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY	\
	assert(s); assert(target); assert(end)

STATIC STRLEN	S_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start, const U8 *const send, STRLEN uoffset, STRLEN uoffset0, STRLEN boffset0)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_SV_POS_U2B_CACHED	\
	assert(sv); assert(mgp); assert(start); assert(send)

STATIC STRLEN	S_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send, STRLEN *const uoffset, bool *const at_end)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4);
#define PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS	\
	assert(start); assert(send); assert(uoffset); assert(at_end)

STATIC STRLEN	S_sv_pos_u2b_midway(const U8 *const start, const U8 *send, STRLEN uoffset, const STRLEN uend)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY	\
	assert(start); assert(send)

PERL_STATIC_INLINE void	S_sv_unglob(pTHX_ SV *const sv, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_UNGLOB	\
	assert(sv)

STATIC char *	S_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(5);
#define PERL_ARGS_ASSERT_UIV_2BUF	\
	assert(buf); assert(peob)

STATIC void	S_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN ulen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE	\
	assert(sv); assert(mgp)

STATIC void	S_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte, const STRLEN utf8, const STRLEN blen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE	\
	assert(sv); assert(mgp)

STATIC I32	S_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_VISIT	\
	assert(f)

#  if defined(PERL_OLD_COPY_ON_WRITE)
STATIC void	S_sv_release_COW(pTHX_ SV *sv, const char *pvx, SV *after)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_SV_RELEASE_COW	\
	assert(sv); assert(pvx); assert(after)

#  endif
#  if defined(USE_ITHREADS)
STATIC SV*	S_sv_dup_common(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DUP_COMMON	\
	assert(sstr); assert(param)

STATIC SV **	S_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest, SSize_t items, CLONE_PARAMS *const param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE	\
	assert(source); assert(dest); assert(param)

STATIC void	S_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK	\
	assert(unreferenced)

#  endif
#endif
#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)
PERL_CALLCONV SV *	Perl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ, const SV *const keyname, I32 aindex, int subscript_type)
			__attribute__warn_unused_result__;

#endif
#if defined(PERL_IN_TOKE_C)
STATIC int	S_ao(pTHX_ int toketype);
STATIC void	S_check_uni(pTHX);
STATIC void	S_checkcomma(pTHX_ const char *s, const char *name, const char *what)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CHECKCOMMA	\
	assert(s); assert(name); assert(what)

STATIC int	S_deprecate_commaless_var_list(pTHX);
STATIC char *	S_filter_gets(pTHX_ SV *sv, STRLEN append)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FILTER_GETS	\
	assert(sv)

STATIC HV *	S_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FIND_IN_MY_STASH	\
	assert(pkgname)

STATIC void	S_force_ident(pTHX_ const char *s, int kind)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORCE_IDENT	\
	assert(s)

STATIC void	S_force_ident_maybe_lex(pTHX_ char pit);
STATIC void	S_force_next(pTHX_ I32 type);
STATIC char*	S_force_strict_version(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORCE_STRICT_VERSION	\
	assert(s)

STATIC char*	S_force_version(pTHX_ char *s, int guessing)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORCE_VERSION	\
	assert(s)

STATIC char*	S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORCE_WORD	\
	assert(start)

PERL_STATIC_INLINE SV*	S_get_and_check_backslash_N_name(pTHX_ const char* s, const char* const e)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME	\
	assert(s); assert(e)

STATIC void	S_incline(pTHX_ const char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INCLINE	\
	assert(s)

STATIC int	S_intuit_method(pTHX_ char *s, GV *gv, CV *cv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INTUIT_METHOD	\
	assert(s)

STATIC int	S_intuit_more(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INTUIT_MORE	\
	assert(s)

STATIC I32	S_lop(pTHX_ I32 f, int x, char *s)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_LOP	\
	assert(s)

PERL_STATIC_NO_RET void	S_missingterm(pTHX_ char *s)
			__attribute__noreturn__;

STATIC SV*	S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen, SV *sv, SV *pv, const char *type, STRLEN typelen)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_NEW_CONSTANT	\
	assert(key); assert(sv)

STATIC void	S_no_op(pTHX_ const char *const what, char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_NO_OP	\
	assert(what)

STATIC void	S_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_PARSE_IDENT	\
	assert(s); assert(d); assert(e)

STATIC int	S_pending_ident(pTHX);
STATIC char*	S_scan_const(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_CONST	\
	assert(start)

STATIC char*	S_scan_formline(pTHX_ char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_FORMLINE	\
	assert(s)

STATIC char*	S_scan_heredoc(pTHX_ char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_HEREDOC	\
	assert(s)

STATIC char*	S_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SCAN_IDENT	\
	assert(s); assert(dest)

STATIC char*	S_scan_inputsymbol(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL	\
	assert(start)

STATIC char*	S_scan_pat(pTHX_ char *start, I32 type)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_PAT	\
	assert(start)

STATIC char*	S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims, int re_reparse, bool deprecate_escaped_matching, char **delimp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_STR	\
	assert(start)

STATIC char*	S_scan_subst(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_SUBST	\
	assert(start)

STATIC char*	S_scan_trans(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SCAN_TRANS	\
	assert(start)

STATIC char*	S_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_SCAN_WORD	\
	assert(s); assert(dest); assert(slp)

STATIC char*	S_skipspace_flags(pTHX_ char *s, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SKIPSPACE_FLAGS	\
	assert(s)

STATIC I32	S_sublex_done(pTHX)
			__attribute__warn_unused_result__;

STATIC I32	S_sublex_push(pTHX)
			__attribute__warn_unused_result__;

STATIC I32	S_sublex_start(pTHX)
			__attribute__warn_unused_result__;

STATIC char*	S_swallow_bom(pTHX_ U8 *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SWALLOW_BOM	\
	assert(s)

STATIC char *	S_tokenize_use(pTHX_ int is_use, char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_TOKENIZE_USE	\
	assert(s)

STATIC SV*	S_tokeq(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_TOKEQ	\
	assert(sv)

STATIC void	S_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len);
STATIC int	S_yywarn(pTHX_ const char *const s, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_YYWARN	\
	assert(s)

#  if defined(PERL_MAD)
STATIC void	S_curmad(pTHX_ char slot, SV *sv);
STATIC char*	S_skipspace0(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SKIPSPACE0	\
	assert(s)

STATIC char*	S_skipspace1(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SKIPSPACE1	\
	assert(s)

STATIC char*	S_skipspace2(pTHX_ char *s, SV **sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SKIPSPACE2	\
	assert(s)

STATIC void	S_start_force(pTHX_ int where);
#  endif
#endif
#if defined(PERL_IN_UNIVERSAL_C)
STATIC bool	S_isa_lookup(pTHX_ HV *stash, const char * const name, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_ISA_LOOKUP	\
	assert(stash); assert(name)

#endif
#if defined(PERL_IN_UTF8_C)
STATIC UV	S_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING	\
	assert(p); assert(ustrp); assert(lenp)

PERL_STATIC_INLINE STRLEN	S_is_utf8_char_slow(const U8 *s, const STRLEN len)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_IS_UTF8_CHAR_SLOW	\
	assert(s)

PERL_STATIC_INLINE bool	S_is_utf8_common(pTHX_ const U8 *const p, SV **swash, const char * const swashname, SV* const invlist)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_IS_UTF8_COMMON	\
	assert(p); assert(swash); assert(swashname)

STATIC SV*	S_swatch_get(pTHX_ SV* swash, UV start, UV span)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SWATCH_GET	\
	assert(swash)

STATIC U8	S_to_lower_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp)
			__attribute__warn_unused_result__;

#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV UV	Perl__to_upper_title_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const char S_or_s)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1	\
	assert(p); assert(lenp)

#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
PERL_CALLCONV UV	Perl__to_fold_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const unsigned int flags)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT__TO_FOLD_LATIN1	\
	assert(p); assert(lenp)

#endif
#if defined(PERL_IN_UTIL_C)
STATIC bool	S_ckwarn_common(pTHX_ U32 w);
STATIC bool	S_invoke_exception_hook(pTHX_ SV *ex, bool warn);
STATIC SV*	S_mess_alloc(pTHX);
STATIC SV *	S_with_queued_errors(pTHX_ SV *ex)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS	\
	assert(ex)

#  if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)
STATIC void	S_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
			__attribute__nonnull__(4)
			__attribute__nonnull__(8)
			__attribute__nonnull__(10);
#define PERL_ARGS_ASSERT_MEM_LOG_COMMON	\
	assert(type_name); assert(filename); assert(funcname)

#  endif
#endif
#if defined(PERL_MAD)
PERL_CALLCONV void	Perl_addmad(pTHX_ MADPROP* tm, MADPROP** root, char slot);
PERL_CALLCONV void	Perl_append_madprops(pTHX_ MADPROP* tm, OP* o, char slot);
PERL_CALLCONV void	Perl_do_op_xmldump(pTHX_ I32 level, PerlIO *file, const OP *o)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_OP_XMLDUMP	\
	assert(file)

PERL_CALLCONV void	Perl_do_pmop_xmldump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_PMOP_XMLDUMP	\
	assert(file)

PERL_CALLCONV void	Perl_mad_free(pTHX_ MADPROP* mp);
PERL_CALLCONV int	Perl_madlex(pTHX);
PERL_CALLCONV int	Perl_madparse(pTHX_ int gramtype);
PERL_CALLCONV OP*	Perl_newFORM(pTHX_ I32 floor, OP* o, OP* block);
PERL_CALLCONV MADPROP*	Perl_newMADPROP(pTHX_ char key, char type, void* val, I32 vlen);
PERL_CALLCONV MADPROP*	Perl_newMADsv(pTHX_ char key, SV* sv)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_NEWMADSV	\
	assert(sv)

PERL_CALLCONV TOKEN*	Perl_newTOKEN(pTHX_ I32 optype, YYSTYPE lval, MADPROP* madprop);
PERL_CALLCONV void	Perl_op_getmad(pTHX_ OP* from, OP* o, char slot);
PERL_CALLCONV void	Perl_op_getmad_weak(pTHX_ OP* from, OP* o, char slot);
PERL_CALLCONV void	Perl_op_xmldump(pTHX_ const OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_OP_XMLDUMP	\
	assert(o)

PERL_CALLCONV OP*	Perl_package(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_PACKAGE	\
	assert(o)

PERL_CALLCONV void	Perl_pad_peg(const char* s)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PAD_PEG	\
	assert(s)

PERL_CALLCONV void	Perl_pmop_xmldump(pTHX_ const PMOP* pm);
PERL_CALLCONV void	Perl_prepend_madprops(pTHX_ MADPROP* mp, OP* o, char slot);
PERL_CALLCONV char*	Perl_sv_catxmlpv(pTHX_ SV *dsv, const char *pv, int utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATXMLPV	\
	assert(dsv); assert(pv)

PERL_CALLCONV char*	Perl_sv_catxmlpvn(pTHX_ SV *dsv, const char *pv, STRLEN len, int utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATXMLPVN	\
	assert(dsv); assert(pv)

PERL_CALLCONV char*	Perl_sv_catxmlsv(pTHX_ SV *dsv, SV *ssv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_CATXMLSV	\
	assert(dsv); assert(ssv)

PERL_CALLCONV char*	Perl_sv_xmlpeek(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SV_XMLPEEK	\
	assert(sv)

PERL_CALLCONV void	Perl_token_free(pTHX_ TOKEN *tk)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_TOKEN_FREE	\
	assert(tk)

PERL_CALLCONV void	Perl_token_getmad(pTHX_ TOKEN *tk, OP *o, char slot)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_TOKEN_GETMAD	\
	assert(tk)

PERL_CALLCONV OP *	Perl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_UTILIZE	\
	assert(idop)

PERL_CALLCONV void	Perl_xmldump_all(pTHX);
PERL_CALLCONV void	Perl_xmldump_all_perl(pTHX_ bool justperl);
PERL_CALLCONV void	Perl_xmldump_eval(pTHX);
PERL_CALLCONV void	Perl_xmldump_form(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_XMLDUMP_FORM	\
	assert(gv)

PERL_CALLCONV void	Perl_xmldump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_XMLDUMP_INDENT	\
	assert(file); assert(pat)

PERL_CALLCONV void	Perl_xmldump_packsubs(pTHX_ const HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS	\
	assert(stash)

PERL_CALLCONV void	Perl_xmldump_packsubs_perl(pTHX_ const HV* stash, bool justperl)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS_PERL	\
	assert(stash)

PERL_CALLCONV void	Perl_xmldump_sub(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_XMLDUMP_SUB	\
	assert(gv)

PERL_CALLCONV void	Perl_xmldump_sub_perl(pTHX_ const GV* gv, bool justperl)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_XMLDUMP_SUB_PERL	\
	assert(gv)

PERL_CALLCONV void	Perl_xmldump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_XMLDUMP_VINDENT	\
	assert(file); assert(pat)

#endif
#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)
STATIC void	S_pidgone(pTHX_ Pid_t pid, int status);
#endif
#if defined(UNLINK_ALL_VERSIONS)
PERL_CALLCONV I32	Perl_unlnk(pTHX_ const char* f)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_UNLNK	\
	assert(f)

#endif
#if defined(USE_ITHREADS)
PERL_CALLCONV PADOFFSET	Perl_alloccopstash(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_ALLOCCOPSTASH	\
	assert(hv)

PERL_CALLCONV void*	Perl_any_dup(pTHX_ void* v, const PerlInterpreter* proto_perl)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_ANY_DUP	\
	assert(proto_perl)

PERL_CALLCONV void	Perl_clone_params_del(CLONE_PARAMS *param)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_CLONE_PARAMS_DEL	\
	assert(param)

PERL_CALLCONV CLONE_PARAMS *	Perl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_CLONE_PARAMS_NEW	\
	assert(from); assert(to)

PERL_CALLCONV PERL_CONTEXT*	Perl_cx_dup(pTHX_ PERL_CONTEXT* cx, I32 ix, I32 max, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_CX_DUP	\
	assert(param)

PERL_CALLCONV DIR*	Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DIRP_DUP	\
	assert(param)

PERL_CALLCONV PerlIO*	Perl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_FP_DUP	\
	assert(param)

PERL_CALLCONV GP*	Perl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GP_DUP	\
	assert(param)

PERL_CALLCONV HE*	Perl_he_dup(pTHX_ const HE* e, bool shared, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_HE_DUP	\
	assert(param)

PERL_CALLCONV HEK*	Perl_hek_dup(pTHX_ HEK* e, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HEK_DUP	\
	assert(param)

PERL_CALLCONV MAGIC*	Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MG_DUP	\
	assert(param)

PERL_CALLCONV struct mro_meta*	Perl_mro_meta_dup(pTHX_ struct mro_meta* smeta, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MRO_META_DUP	\
	assert(smeta); assert(param)

PERL_CALLCONV OP*	Perl_newPADOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_NEWPADOP	\
	assert(sv)

PERL_CALLCONV PADLIST *	Perl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PADLIST_DUP	\
	assert(param)

PERL_CALLCONV yy_parser*	Perl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PARSER_DUP	\
	assert(param)

PERL_CALLCONV PerlInterpreter*	perl_clone(PerlInterpreter *proto_perl, UV flags)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_PERL_CLONE	\
	assert(proto_perl)

PERL_CALLCONV void	Perl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_RE_DUP_GUTS	\
	assert(sstr); assert(dstr); assert(param)

PERL_CALLCONV void*	Perl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_REGDUPE_INTERNAL	\
	assert(r); assert(param)

PERL_CALLCONV void	Perl_rvpv_dup(pTHX_ SV *const dstr, const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_RVPV_DUP	\
	assert(dstr); assert(sstr); assert(param)

PERL_CALLCONV PERL_SI*	Perl_si_dup(pTHX_ PERL_SI* si, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SI_DUP	\
	assert(param)

PERL_CALLCONV ANY*	Perl_ss_dup(pTHX_ PerlInterpreter* proto_perl, CLONE_PARAMS* param)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SS_DUP	\
	assert(proto_perl); assert(param)

PERL_CALLCONV SV*	Perl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DUP	\
	assert(param)

PERL_CALLCONV SV*	Perl_sv_dup_inc(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_DUP_INC	\
	assert(param)

#endif
#if defined(USE_LOCALE_COLLATE)
PERL_CALLCONV int	Perl_magic_setcollxfrm(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETCOLLXFRM	\
	assert(sv); assert(mg)

PERL_CALLCONV char*	Perl_mem_collxfrm(pTHX_ const char* s, STRLEN len, STRLEN* xlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MEM_COLLXFRM	\
	assert(s); assert(xlen)

/* PERL_CALLCONV char*	sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV char*	Perl_sv_collxfrm_flags(pTHX_ SV *const sv, STRLEN *const nxp, I32 const flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_SV_COLLXFRM_FLAGS	\
	assert(sv); assert(nxp)

#endif
#if defined(USE_PERLIO)
PERL_CALLCONV void	Perl_PerlIO_clearerr(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_close(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_eof(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_error(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_fileno(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_fill(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_flush(pTHX_ PerlIO *f);
PERL_CALLCONV STDCHAR *	Perl_PerlIO_get_base(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)
			__attribute__warn_unused_result__;

PERL_CALLCONV SSize_t	Perl_PerlIO_get_cnt(pTHX_ PerlIO *f)
			__attribute__warn_unused_result__;

PERL_CALLCONV STDCHAR *	Perl_PerlIO_get_ptr(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PERLIO_READ	\
	assert(vbuf)

PERL_CALLCONV int	Perl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_CALLCONV void	Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, SSize_t cnt);
PERL_CALLCONV void	Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR *ptr, SSize_t cnt);
PERL_CALLCONV void	Perl_PerlIO_setlinebuf(pTHX_ PerlIO *f);
PERL_CALLCONV PerlIO *	Perl_PerlIO_stderr(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV PerlIO *	Perl_PerlIO_stdin(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV PerlIO *	Perl_PerlIO_stdout(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV Off_t	Perl_PerlIO_tell(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PERLIO_UNREAD	\
	assert(vbuf)

PERL_CALLCONV SSize_t	Perl_PerlIO_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_PERLIO_WRITE	\
	assert(vbuf)

#endif
#if defined(WIN32)
PERL_CALLCONV char*	Perl_my_setlocale(pTHX_ int category, const char* locale)
			__attribute__pure__;

PERL_CALLCONV_NO_RET void	win32_croak_not_implemented(const char * fname)
			__attribute__noreturn__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_WIN32_CROAK_NOT_IMPLEMENTED	\
	assert(fname)

#endif
#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)
PERL_CALLCONV int	Perl_do_aspawn(pTHX_ SV* really, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_ASPAWN	\
	assert(mark); assert(sp)

PERL_CALLCONV int	Perl_do_spawn(pTHX_ char* cmd)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_SPAWN	\
	assert(cmd)

PERL_CALLCONV int	Perl_do_spawn_nowait(pTHX_ char* cmd)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_SPAWN_NOWAIT	\
	assert(cmd)

#endif
#if defined(_MSC_VER)
PERL_CALLCONV int	Perl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET	\
	assert(sv); assert(mg)

#endif
#ifdef PERL_CORE
#  include "pp_proto.h"
#endif
END_EXTERN_C

/* ex: set ro: */
                                                                                                                                                                             usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/reentr.h                                                  0100644 0000000 0000000 00000230676 12744441327 017422  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    reentr.h
 *
 *    Copyright (C) 2002, 2003, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/reentr.pl from data in regen/reentr.pl.
 * Any changes made here will be lost!
 */

#ifndef REENTR_H
#define REENTR_H

/* If compiling for a threaded perl, we will macro-wrap the system/library
 * interfaces (e.g. getpwent()) which have threaded versions
 * (e.g. getpwent_r()), which will handle things correctly for
 * the Perl interpreter, but otherwise (for XS) the wrapping does
 * not take place.  See L<perlxs/Thread-aware system interfaces>.
 */

#ifndef PERL_REENTR_API
# if defined(PERL_CORE) || defined(PERL_EXT)
#  define PERL_REENTR_API 1
# else
#  define PERL_REENTR_API 0
# endif
#endif

#ifdef USE_REENTRANT_API
 
/* Deprecations: some platforms have the said reentrant interfaces
 * but they are declared obsolete and are not to be used.  Often this
 * means that the platform has threadsafed the interfaces (hopefully).
 * All this is OS version dependent, so we are of course fooling ourselves.
 * If you know of more deprecations on some platforms, please add your own
 * (by editing reentr.pl, mind!) */

#ifdef __hpux
#   undef HAS_CRYPT_R
#   undef HAS_ENDGRENT_R
#   undef HAS_ENDPWENT_R
#   undef HAS_GETGRENT_R
#   undef HAS_GETPWENT_R
#   undef HAS_SETLOCALE_R
#   undef HAS_STRERROR_R
#   define NETDB_R_OBSOLETE
#endif

#if defined(__osf__) && defined(__alpha) /* Tru64 aka Digital UNIX */
#   undef HAS_CRYPT_R
#   undef HAS_STRERROR_R
#   define NETDB_R_OBSOLETE
#endif

/*
 * As of OpenBSD 3.7, reentrant functions are now working, they just are
 * incompatible with everyone else.  To make OpenBSD happy, we have to
 * memzero out certain structures before calling the functions.
 */
#if defined(__OpenBSD__)
#    define REENTR_MEMZERO(a,b) memzero(a,b)
#else
#    define REENTR_MEMZERO(a,b) 0
#endif 

#ifdef NETDB_R_OBSOLETE
#   undef HAS_ENDHOSTENT_R
#   undef HAS_ENDNETENT_R
#   undef HAS_ENDPROTOENT_R
#   undef HAS_ENDSERVENT_R
#   undef HAS_GETHOSTBYADDR_R
#   undef HAS_GETHOSTBYNAME_R
#   undef HAS_GETHOSTENT_R
#   undef HAS_GETNETBYADDR_R
#   undef HAS_GETNETBYNAME_R
#   undef HAS_GETNETENT_R
#   undef HAS_GETPROTOBYNAME_R
#   undef HAS_GETPROTOBYNUMBER_R
#   undef HAS_GETPROTOENT_R
#   undef HAS_GETSERVBYNAME_R
#   undef HAS_GETSERVBYPORT_R
#   undef HAS_GETSERVENT_R
#   undef HAS_SETHOSTENT_R
#   undef HAS_SETNETENT_R
#   undef HAS_SETPROTOENT_R
#   undef HAS_SETSERVENT_R
#endif

#ifdef I_PWD
#   include <pwd.h>
#endif
#ifdef I_GRP
#   include <grp.h>
#endif
#ifdef I_NETDB
#   include <netdb.h>
#endif
#ifdef I_CRYPT
#   ifdef I_CRYPT
#       include <crypt.h>
#   endif
#endif
#ifdef HAS_GETSPNAM_R
#   ifdef I_SHADOW
#       include <shadow.h>
#   endif
#endif

#define REENTRANT_PROTO_B_B	1
#define REENTRANT_PROTO_B_BI	2
#define REENTRANT_PROTO_B_BW	3
#define REENTRANT_PROTO_B_CCD	4
#define REENTRANT_PROTO_B_CCS	5
#define REENTRANT_PROTO_B_IBI	6
#define REENTRANT_PROTO_B_IBW	7
#define REENTRANT_PROTO_B_SB	8
#define REENTRANT_PROTO_B_SBI	9
#define REENTRANT_PROTO_I_BI	10
#define REENTRANT_PROTO_I_BW	11
#define REENTRANT_PROTO_I_CCSBWR	12
#define REENTRANT_PROTO_I_CCSD	13
#define REENTRANT_PROTO_I_CII	14
#define REENTRANT_PROTO_I_CIISD	15
#define REENTRANT_PROTO_I_CSBI	16
#define REENTRANT_PROTO_I_CSBIR	17
#define REENTRANT_PROTO_I_CSBWR	18
#define REENTRANT_PROTO_I_CSBWRE	19
#define REENTRANT_PROTO_I_CSD	20
#define REENTRANT_PROTO_I_CWISBWRE	21
#define REENTRANT_PROTO_I_CWISD	22
#define REENTRANT_PROTO_I_D	23
#define REENTRANT_PROTO_I_H	24
#define REENTRANT_PROTO_I_IBI	25
#define REENTRANT_PROTO_I_IBW	26
#define REENTRANT_PROTO_I_ICBI	27
#define REENTRANT_PROTO_I_ICSBWR	28
#define REENTRANT_PROTO_I_ICSD	29
#define REENTRANT_PROTO_I_ID	30
#define REENTRANT_PROTO_I_IISD	31
#define REENTRANT_PROTO_I_ISBWR	32
#define REENTRANT_PROTO_I_ISD	33
#define REENTRANT_PROTO_I_LISBI	34
#define REENTRANT_PROTO_I_LISD	35
#define REENTRANT_PROTO_I_SB	36
#define REENTRANT_PROTO_I_SBI	37
#define REENTRANT_PROTO_I_SBIE	38
#define REENTRANT_PROTO_I_SBIH	39
#define REENTRANT_PROTO_I_SBIR	40
#define REENTRANT_PROTO_I_SBWR	41
#define REENTRANT_PROTO_I_SBWRE	42
#define REENTRANT_PROTO_I_SD	43
#define REENTRANT_PROTO_I_TISD	44
#define REENTRANT_PROTO_I_TS	45
#define REENTRANT_PROTO_I_TSBI	46
#define REENTRANT_PROTO_I_TSBIR	47
#define REENTRANT_PROTO_I_TSBWR	48
#define REENTRANT_PROTO_I_TSR	49
#define REENTRANT_PROTO_I_TsISBWRE	50
#define REENTRANT_PROTO_I_UISBWRE	51
#define REENTRANT_PROTO_I_uISBWRE	52
#define REENTRANT_PROTO_S_CBI	53
#define REENTRANT_PROTO_S_CCSBI	54
#define REENTRANT_PROTO_S_CIISBIE	55
#define REENTRANT_PROTO_S_CSBI	56
#define REENTRANT_PROTO_S_CSBIE	57
#define REENTRANT_PROTO_S_CWISBIE	58
#define REENTRANT_PROTO_S_CWISBWIE	59
#define REENTRANT_PROTO_S_ICSBI	60
#define REENTRANT_PROTO_S_ISBI	61
#define REENTRANT_PROTO_S_LISBI	62
#define REENTRANT_PROTO_S_SBI	63
#define REENTRANT_PROTO_S_SBIE	64
#define REENTRANT_PROTO_S_SBW	65
#define REENTRANT_PROTO_S_TISBI	66
#define REENTRANT_PROTO_S_TSBI	67
#define REENTRANT_PROTO_S_TSBIE	68
#define REENTRANT_PROTO_S_TWISBIE	69
#define REENTRANT_PROTO_V_D	70
#define REENTRANT_PROTO_V_H	71
#define REENTRANT_PROTO_V_ID	72

/* Defines for indicating which special features are supported. */

/* The getgrent getgrgid getgrnam using buffer? */

#if defined(HAS_GETGRENT_R) && (GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIR || GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBW || GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETGRENT_R_HAS_BUFFER
#else
#   undef  GETGRENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETGRGID_R) && (GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBWR || GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBIR || GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBI || GETGRGID_R_PROTO == REENTRANT_PROTO_S_TSBI)
#   define GETGRGID_R_HAS_BUFFER
#else
#   undef  GETGRGID_R_HAS_BUFFER
#endif
#if defined(HAS_GETGRNAM_R) && (GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR || GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CBI || GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBI || GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CSBI)
#   define GETGRNAM_R_HAS_BUFFER
#else
#   undef  GETGRNAM_R_HAS_BUFFER
#endif

/* Any of the getgrent getgrgid getgrnam using buffer? */

#if (defined(GETGRENT_R_HAS_BUFFER) || defined(GETGRGID_R_HAS_BUFFER) || defined(GETGRNAM_R_HAS_BUFFER))
#   define USE_GRENT_BUFFER
#else
#   undef  USE_GRENT_BUFFER
#endif

/* The getgrent getgrgid getgrnam using ptr? */

#if defined(HAS_GETGRENT_R) && (GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIR)
#   define GETGRENT_R_HAS_PTR
#else
#   undef  GETGRENT_R_HAS_PTR
#endif
#if defined(HAS_GETGRGID_R) && (GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBWR || GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBIR)
#   define GETGRGID_R_HAS_PTR
#else
#   undef  GETGRGID_R_HAS_PTR
#endif
#if defined(HAS_GETGRNAM_R) && (GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR)
#   define GETGRNAM_R_HAS_PTR
#else
#   undef  GETGRNAM_R_HAS_PTR
#endif

/* Any of the getgrent getgrgid getgrnam using ptr? */

#if (defined(GETGRENT_R_HAS_PTR) || defined(GETGRGID_R_HAS_PTR) || defined(GETGRNAM_R_HAS_PTR))
#   define USE_GRENT_PTR
#else
#   undef  USE_GRENT_PTR
#endif

/* The getpwent getpwnam getpwuid using ptr? */

#if defined(HAS_GETPWENT_R) && (GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIR)
#   define GETPWENT_R_HAS_PTR
#else
#   undef  GETPWENT_R_HAS_PTR
#endif
#if defined(HAS_GETPWNAM_R) && (GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR)
#   define GETPWNAM_R_HAS_PTR
#else
#   undef  GETPWNAM_R_HAS_PTR
#endif
#if defined(HAS_GETPWUID_R) && (GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBWR || GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBIR)
#   define GETPWUID_R_HAS_PTR
#else
#   undef  GETPWUID_R_HAS_PTR
#endif

/* Any of the getpwent getpwnam getpwuid using ptr? */

#if (defined(GETPWENT_R_HAS_PTR) || defined(GETPWNAM_R_HAS_PTR) || defined(GETPWUID_R_HAS_PTR))
#   define USE_PWENT_PTR
#else
#   undef  USE_PWENT_PTR
#endif

/* The getspent getspnam using ptr? */

#if defined(HAS_GETSPNAM_R) && (GETSPNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR)
#   define GETSPNAM_R_HAS_PTR
#else
#   undef  GETSPNAM_R_HAS_PTR
#endif

/* Any of the getspent getspnam using ptr? */

#if (defined(GETSPENT_R_HAS_PTR) || defined(GETSPNAM_R_HAS_PTR))
#   define USE_SPENT_PTR
#else
#   undef  USE_SPENT_PTR
#endif

/* The getgrent getgrgid getgrnam setgrent endgrent using fptr? */

#if defined(HAS_GETGRENT_R) && (GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETGRENT_R_HAS_FPTR
#else
#   undef  GETGRENT_R_HAS_FPTR
#endif
#if defined(HAS_SETGRENT_R) && (SETGRENT_R_PROTO == REENTRANT_PROTO_I_H || SETGRENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define SETGRENT_R_HAS_FPTR
#else
#   undef  SETGRENT_R_HAS_FPTR
#endif
#if defined(HAS_ENDGRENT_R) && (ENDGRENT_R_PROTO == REENTRANT_PROTO_I_H || ENDGRENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define ENDGRENT_R_HAS_FPTR
#else
#   undef  ENDGRENT_R_HAS_FPTR
#endif

/* Any of the getgrent getgrgid getgrnam setgrent endgrent using fptr? */

#if (defined(GETGRENT_R_HAS_FPTR) || defined(GETGRGID_R_HAS_FPTR) || defined(GETGRNAM_R_HAS_FPTR) || defined(SETGRENT_R_HAS_FPTR) || defined(ENDGRENT_R_HAS_FPTR))
#   define USE_GRENT_FPTR
#else
#   undef  USE_GRENT_FPTR
#endif

/* The getpwent getpwnam getpwuid setpwent endpwent using fptr? */

#if defined(HAS_GETPWENT_R) && (GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETPWENT_R_HAS_FPTR
#else
#   undef  GETPWENT_R_HAS_FPTR
#endif
#if defined(HAS_SETPWENT_R) && (SETPWENT_R_PROTO == REENTRANT_PROTO_I_H || SETPWENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define SETPWENT_R_HAS_FPTR
#else
#   undef  SETPWENT_R_HAS_FPTR
#endif
#if defined(HAS_ENDPWENT_R) && (ENDPWENT_R_PROTO == REENTRANT_PROTO_I_H || ENDPWENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define ENDPWENT_R_HAS_FPTR
#else
#   undef  ENDPWENT_R_HAS_FPTR
#endif

/* Any of the getpwent getpwnam getpwuid setpwent endpwent using fptr? */

#if (defined(GETPWENT_R_HAS_FPTR) || defined(GETPWNAM_R_HAS_FPTR) || defined(GETPWUID_R_HAS_FPTR) || defined(SETPWENT_R_HAS_FPTR) || defined(ENDPWENT_R_HAS_FPTR))
#   define USE_PWENT_FPTR
#else
#   undef  USE_PWENT_FPTR
#endif

/* The getpwent getpwgid getpwnam using buffer? */

#if defined(HAS_GETPWENT_R) && (GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIR || GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBW || GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETPWENT_R_HAS_BUFFER
#else
#   undef  GETPWENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETPWNAM_R) && (GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR || GETPWNAM_R_PROTO == REENTRANT_PROTO_S_CSBI || GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBI)
#   define GETPWNAM_R_HAS_BUFFER
#else
#   undef  GETPWNAM_R_HAS_BUFFER
#endif

/* Any of the getpwent getpwgid getpwnam using buffer? */

#if (defined(GETPWENT_R_HAS_BUFFER) || defined(GETPWGID_R_HAS_BUFFER) || defined(GETPWNAM_R_HAS_BUFFER))
#   define USE_PWENT_BUFFER
#else
#   undef  USE_PWENT_BUFFER
#endif

/* The gethostent gethostbyaddr gethostbyname using ptr? */

#if defined(HAS_GETHOSTENT_R) && (GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE)
#   define GETHOSTENT_R_HAS_PTR
#else
#   undef  GETHOSTENT_R_HAS_PTR
#endif
#if defined(HAS_GETHOSTBYADDR_R) && (GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE)
#   define GETHOSTBYADDR_R_HAS_PTR
#else
#   undef  GETHOSTBYADDR_R_HAS_PTR
#endif
#if defined(HAS_GETHOSTBYNAME_R) && (GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE)
#   define GETHOSTBYNAME_R_HAS_PTR
#else
#   undef  GETHOSTBYNAME_R_HAS_PTR
#endif

/* Any of the gethostent gethostbyaddr gethostbyname using ptr? */

#if (defined(GETHOSTENT_R_HAS_PTR) || defined(GETHOSTBYADDR_R_HAS_PTR) || defined(GETHOSTBYNAME_R_HAS_PTR))
#   define USE_HOSTENT_PTR
#else
#   undef  USE_HOSTENT_PTR
#endif

/* The getnetent getnetbyaddr getnetbyname using ptr? */

#if defined(HAS_GETNETENT_R) && (GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE)
#   define GETNETENT_R_HAS_PTR
#else
#   undef  GETNETENT_R_HAS_PTR
#endif
#if defined(HAS_GETNETBYADDR_R) && (GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE)
#   define GETNETBYADDR_R_HAS_PTR
#else
#   undef  GETNETBYADDR_R_HAS_PTR
#endif
#if defined(HAS_GETNETBYNAME_R) && (GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE)
#   define GETNETBYNAME_R_HAS_PTR
#else
#   undef  GETNETBYNAME_R_HAS_PTR
#endif

/* Any of the getnetent getnetbyaddr getnetbyname using ptr? */

#if (defined(GETNETENT_R_HAS_PTR) || defined(GETNETBYADDR_R_HAS_PTR) || defined(GETNETBYNAME_R_HAS_PTR))
#   define USE_NETENT_PTR
#else
#   undef  USE_NETENT_PTR
#endif

/* The getprotoent getprotobyname getprotobynumber using ptr? */

#if defined(HAS_GETPROTOENT_R) && (GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBWR)
#   define GETPROTOENT_R_HAS_PTR
#else
#   undef  GETPROTOENT_R_HAS_PTR
#endif
#if defined(HAS_GETPROTOBYNAME_R) && (GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWR)
#   define GETPROTOBYNAME_R_HAS_PTR
#else
#   undef  GETPROTOBYNAME_R_HAS_PTR
#endif
#if defined(HAS_GETPROTOBYNUMBER_R) && (GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISBWR)
#   define GETPROTOBYNUMBER_R_HAS_PTR
#else
#   undef  GETPROTOBYNUMBER_R_HAS_PTR
#endif

/* Any of the getprotoent getprotobyname getprotobynumber using ptr? */

#if (defined(GETPROTOENT_R_HAS_PTR) || defined(GETPROTOBYNAME_R_HAS_PTR) || defined(GETPROTOBYNUMBER_R_HAS_PTR))
#   define USE_PROTOENT_PTR
#else
#   undef  USE_PROTOENT_PTR
#endif

/* The getservent getservbyname getservbyport using ptr? */

#if defined(HAS_GETSERVENT_R) && (GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBWR)
#   define GETSERVENT_R_HAS_PTR
#else
#   undef  GETSERVENT_R_HAS_PTR
#endif
#if defined(HAS_GETSERVBYNAME_R) && (GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSBWR)
#   define GETSERVBYNAME_R_HAS_PTR
#else
#   undef  GETSERVBYNAME_R_HAS_PTR
#endif
#if defined(HAS_GETSERVBYPORT_R) && (GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSBWR)
#   define GETSERVBYPORT_R_HAS_PTR
#else
#   undef  GETSERVBYPORT_R_HAS_PTR
#endif

/* Any of the getservent getservbyname getservbyport using ptr? */

#if (defined(GETSERVENT_R_HAS_PTR) || defined(GETSERVBYNAME_R_HAS_PTR) || defined(GETSERVBYPORT_R_HAS_PTR))
#   define USE_SERVENT_PTR
#else
#   undef  USE_SERVENT_PTR
#endif

/* The gethostent gethostbyaddr gethostbyname using buffer? */

#if defined(HAS_GETHOSTENT_R) && (GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBIE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBI)
#   define GETHOSTENT_R_HAS_BUFFER
#else
#   undef  GETHOSTENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETHOSTBYADDR_R) && (GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBWIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CIISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE)
#   define GETHOSTBYADDR_R_HAS_BUFFER
#else
#   undef  GETHOSTBYADDR_R_HAS_BUFFER
#endif
#if defined(HAS_GETHOSTBYNAME_R) && (GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE || GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBIE)
#   define GETHOSTBYNAME_R_HAS_BUFFER
#else
#   undef  GETHOSTBYNAME_R_HAS_BUFFER
#endif

/* Any of the gethostent gethostbyaddr gethostbyname using buffer? */

#if (defined(GETHOSTENT_R_HAS_BUFFER) || defined(GETHOSTBYADDR_R_HAS_BUFFER) || defined(GETHOSTBYNAME_R_HAS_BUFFER))
#   define USE_HOSTENT_BUFFER
#else
#   undef  USE_HOSTENT_BUFFER
#endif

/* The getnetent getnetbyaddr getnetbyname using buffer? */

#if defined(HAS_GETNETENT_R) && (GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBIE || GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBI)
#   define GETNETENT_R_HAS_BUFFER
#else
#   undef  GETNETENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETNETBYADDR_R) && (GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_LISBI || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_TISBI || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_LISBI || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE)
#   define GETNETBYADDR_R_HAS_BUFFER
#else
#   undef  GETNETBYADDR_R_HAS_BUFFER
#endif
#if defined(HAS_GETNETBYNAME_R) && (GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE || GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBI || GETNETBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI)
#   define GETNETBYNAME_R_HAS_BUFFER
#else
#   undef  GETNETBYNAME_R_HAS_BUFFER
#endif

/* Any of the getnetent getnetbyaddr getnetbyname using buffer? */

#if (defined(GETNETENT_R_HAS_BUFFER) || defined(GETNETBYADDR_R_HAS_BUFFER) || defined(GETNETBYNAME_R_HAS_BUFFER))
#   define USE_NETENT_BUFFER
#else
#   undef  USE_NETENT_BUFFER
#endif

/* The getprotoent getprotobyname getprotobynumber using buffer? */

#if defined(HAS_GETPROTOENT_R) && (GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETPROTOENT_R_PROTO == REENTRANT_PROTO_S_SBI)
#   define GETPROTOENT_R_HAS_BUFFER
#else
#   undef  GETPROTOENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETPROTOBYNAME_R) && (GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI)
#   define GETPROTOBYNAME_R_HAS_BUFFER
#else
#   undef  GETPROTOBYNAME_R_HAS_BUFFER
#endif
#if defined(HAS_GETPROTOBYNUMBER_R) && (GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISBWR || GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_S_ISBI)
#   define GETPROTOBYNUMBER_R_HAS_BUFFER
#else
#   undef  GETPROTOBYNUMBER_R_HAS_BUFFER
#endif

/* Any of the getprotoent getprotobyname getprotobynumber using buffer? */

#if (defined(GETPROTOENT_R_HAS_BUFFER) || defined(GETPROTOBYNAME_R_HAS_BUFFER) || defined(GETPROTOBYNUMBER_R_HAS_BUFFER))
#   define USE_PROTOENT_BUFFER
#else
#   undef  USE_PROTOENT_BUFFER
#endif

/* The getservent getservbyname getservbyport using buffer? */

#if defined(HAS_GETSERVENT_R) && (GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETSERVENT_R_PROTO == REENTRANT_PROTO_S_SBI)
#   define GETSERVENT_R_HAS_BUFFER
#else
#   undef  GETSERVENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETSERVBYNAME_R) && (GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSBWR || GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_S_CCSBI)
#   define GETSERVBYNAME_R_HAS_BUFFER
#else
#   undef  GETSERVBYNAME_R_HAS_BUFFER
#endif
#if defined(HAS_GETSERVBYPORT_R) && (GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSBWR || GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_S_ICSBI)
#   define GETSERVBYPORT_R_HAS_BUFFER
#else
#   undef  GETSERVBYPORT_R_HAS_BUFFER
#endif

/* Any of the getservent getservbyname getservbyport using buffer? */

#if (defined(GETSERVENT_R_HAS_BUFFER) || defined(GETSERVBYNAME_R_HAS_BUFFER) || defined(GETSERVBYPORT_R_HAS_BUFFER))
#   define USE_SERVENT_BUFFER
#else
#   undef  USE_SERVENT_BUFFER
#endif

/* The gethostent gethostbyaddr gethostbyname using errno? */

#if defined(HAS_GETHOSTENT_R) && (GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBIE)
#   define GETHOSTENT_R_HAS_ERRNO
#else
#   undef  GETHOSTENT_R_HAS_ERRNO
#endif
#if defined(HAS_GETHOSTBYADDR_R) && (GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBWIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CIISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE)
#   define GETHOSTBYADDR_R_HAS_ERRNO
#else
#   undef  GETHOSTBYADDR_R_HAS_ERRNO
#endif
#if defined(HAS_GETHOSTBYNAME_R) && (GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE || GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBIE)
#   define GETHOSTBYNAME_R_HAS_ERRNO
#else
#   undef  GETHOSTBYNAME_R_HAS_ERRNO
#endif

/* Any of the gethostent gethostbyaddr gethostbyname using errno? */

#if (defined(GETHOSTENT_R_HAS_ERRNO) || defined(GETHOSTBYADDR_R_HAS_ERRNO) || defined(GETHOSTBYNAME_R_HAS_ERRNO))
#   define USE_HOSTENT_ERRNO
#else
#   undef  USE_HOSTENT_ERRNO
#endif

/* The getnetent getnetbyaddr getnetbyname using errno? */

#if defined(HAS_GETNETENT_R) && (GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBIE)
#   define GETNETENT_R_HAS_ERRNO
#else
#   undef  GETNETENT_R_HAS_ERRNO
#endif
#if defined(HAS_GETNETBYADDR_R) && (GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE)
#   define GETNETBYADDR_R_HAS_ERRNO
#else
#   undef  GETNETBYADDR_R_HAS_ERRNO
#endif
#if defined(HAS_GETNETBYNAME_R) && (GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE)
#   define GETNETBYNAME_R_HAS_ERRNO
#else
#   undef  GETNETBYNAME_R_HAS_ERRNO
#endif

/* Any of the getnetent getnetbyaddr getnetbyname using errno? */

#if (defined(GETNETENT_R_HAS_ERRNO) || defined(GETNETBYADDR_R_HAS_ERRNO) || defined(GETNETBYNAME_R_HAS_ERRNO))
#   define USE_NETENT_ERRNO
#else
#   undef  USE_NETENT_ERRNO
#endif


typedef struct {
#ifdef HAS_ASCTIME_R
	char*	_asctime_buffer;
	size_t	_asctime_size;
#endif /* HAS_ASCTIME_R */
#ifdef HAS_CRYPT_R
#if CRYPT_R_PROTO == REENTRANT_PROTO_B_CCD
	CRYPTD* _crypt_data;
#else
	struct crypt_data *_crypt_struct_buffer;
#endif
#endif /* HAS_CRYPT_R */
#ifdef HAS_CTIME_R
	char*	_ctime_buffer;
	size_t	_ctime_size;
#endif /* HAS_CTIME_R */
#ifdef HAS_GETGRNAM_R
	struct group	_grent_struct;
	char*	_grent_buffer;
	size_t	_grent_size;
#   ifdef USE_GRENT_PTR
	struct group*	_grent_ptr;
#   endif
#   ifdef USE_GRENT_FPTR
	FILE*	_grent_fptr;
#   endif
#endif /* HAS_GETGRNAM_R */
#ifdef HAS_GETHOSTBYNAME_R
	struct hostent	_hostent_struct;
#   if GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
	struct hostent_data	_hostent_data;
#   else
	char*	_hostent_buffer;
	size_t	_hostent_size;
#   endif
#   ifdef USE_HOSTENT_PTR
	struct hostent*	_hostent_ptr;
#   endif
#   ifdef USE_HOSTENT_ERRNO
	int	_hostent_errno;
#   endif 
#endif /* HAS_GETHOSTBYNAME_R */
#ifdef HAS_GETLOGIN_R
	char*	_getlogin_buffer;
	size_t	_getlogin_size;
#endif /* HAS_GETLOGIN_R */
#ifdef HAS_GETNETBYNAME_R
	struct netent	_netent_struct;
#   if GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
	struct netent_data	_netent_data;
#   else
	char*	_netent_buffer;
	size_t	_netent_size;
#   endif
#   ifdef USE_NETENT_PTR
	struct netent*	_netent_ptr;
#   endif
#   ifdef USE_NETENT_ERRNO
	int	_netent_errno;
#   endif 
#endif /* HAS_GETNETBYNAME_R */
#ifdef HAS_GETPROTOBYNAME_R
	struct protoent	_protoent_struct;
#   if GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
	struct protoent_data	_protoent_data;
#   else
	char*	_protoent_buffer;
	size_t	_protoent_size;
#   endif
#   ifdef USE_PROTOENT_PTR
	struct protoent*	_protoent_ptr;
#   endif
#   ifdef USE_PROTOENT_ERRNO
	int	_protoent_errno;
#   endif 
#endif /* HAS_GETPROTOBYNAME_R */
#ifdef HAS_GETPWNAM_R
	struct passwd	_pwent_struct;
	char*	_pwent_buffer;
	size_t	_pwent_size;
#   ifdef USE_PWENT_PTR
	struct passwd*	_pwent_ptr;
#   endif
#   ifdef USE_PWENT_FPTR
	FILE*	_pwent_fptr;
#   endif
#endif /* HAS_GETPWNAM_R */
#ifdef HAS_GETSERVBYNAME_R
	struct servent	_servent_struct;
#   if GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD
	struct servent_data	_servent_data;
#   else
	char*	_servent_buffer;
	size_t	_servent_size;
#   endif
#   ifdef USE_SERVENT_PTR
	struct servent*	_servent_ptr;
#   endif
#   ifdef USE_SERVENT_ERRNO
	int	_servent_errno;
#   endif 
#endif /* HAS_GETSERVBYNAME_R */
#ifdef HAS_GETSPNAM_R
	struct spwd	_spent_struct;
	char*	_spent_buffer;
	size_t	_spent_size;
#   ifdef USE_SPENT_PTR
	struct spwd*	_spent_ptr;
#   endif
#   ifdef USE_SPENT_FPTR
	FILE*	_spent_fptr;
#   endif
#endif /* HAS_GETSPNAM_R */
#ifdef HAS_READDIR_R
	struct dirent*	_readdir_struct;
	size_t	_readdir_size;
#   if READDIR_R_PROTO == REENTRANT_PROTO_I_TSR
	struct dirent*	_readdir_ptr;
#   endif
#endif /* HAS_READDIR_R */
#ifdef HAS_READDIR64_R
	struct dirent64*	_readdir64_struct;
	size_t	_readdir64_size;
#   if READDIR64_R_PROTO == REENTRANT_PROTO_I_TSR
	struct dirent64*	_readdir64_ptr;
#   endif
#endif /* HAS_READDIR64_R */
#ifdef HAS_SETLOCALE_R
	char*	_setlocale_buffer;
	size_t	_setlocale_size;
#endif /* HAS_SETLOCALE_R */
#ifdef HAS_STRERROR_R
	char*	_strerror_buffer;
	size_t	_strerror_size;
#endif /* HAS_STRERROR_R */
#ifdef HAS_TTYNAME_R
	char*	_ttyname_buffer;
	size_t	_ttyname_size;
#endif /* HAS_TTYNAME_R */

    int dummy; /* cannot have empty structs */
} REENTR;

/* The wrappers. */

#ifdef HAS_ASCTIME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef asctime
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_B_SB
#       define asctime(a) asctime_r(a, PL_reentrant_buffer->_asctime_buffer)
#   endif
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_B_SBI
#       define asctime(a) asctime_r(a, PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size)
#   endif
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_I_SB
#       define asctime(a) (asctime_r(a, PL_reentrant_buffer->_asctime_buffer) == 0 ? PL_reentrant_buffer->_asctime_buffer : 0)
#   endif
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_I_SBI
#       define asctime(a) (asctime_r(a, PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size) == 0 ? PL_reentrant_buffer->_asctime_buffer : 0)
#   endif
#  endif
#endif /* HAS_ASCTIME_R */

#ifdef HAS_CRYPT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef crypt
#   if !defined(crypt) && CRYPT_R_PROTO == REENTRANT_PROTO_B_CCS
#       define crypt(a, b) crypt_r(a, b, PL_reentrant_buffer->_crypt_struct_buffer)
#   endif
#   if !defined(crypt) && CRYPT_R_PROTO == REENTRANT_PROTO_B_CCD
#       define crypt(a, b) crypt_r(a, b, &PL_reentrant_buffer->_crypt_data)
#   endif
#  endif
#endif /* HAS_CRYPT_R */

#ifdef HAS_CTERMID_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef ctermid
#   if !defined(ctermid) && CTERMID_R_PROTO == REENTRANT_PROTO_B_B
#       define ctermid(a) ctermid_r(a)
#   endif
#  endif
#endif /* HAS_CTERMID_R */

#ifdef HAS_CTIME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef ctime
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_B_SB
#       define ctime(a) ctime_r(a, PL_reentrant_buffer->_ctime_buffer)
#   endif
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_B_SBI
#       define ctime(a) ctime_r(a, PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size)
#   endif
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_I_SB
#       define ctime(a) (ctime_r(a, PL_reentrant_buffer->_ctime_buffer) == 0 ? PL_reentrant_buffer->_ctime_buffer : 0)
#   endif
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_I_SBI
#       define ctime(a) (ctime_r(a, PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size) == 0 ? PL_reentrant_buffer->_ctime_buffer : 0)
#   endif
#  endif
#endif /* HAS_CTIME_R */

#ifdef HAS_ENDGRENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endgrent
#   if !defined(endgrent) && ENDGRENT_R_PROTO == REENTRANT_PROTO_I_H
#       define endgrent() (endgrent_r(&PL_reentrant_buffer->_grent_fptr) == 0 ? 1 : 0)
#   endif
#   if !defined(endgrent) && ENDGRENT_R_PROTO == REENTRANT_PROTO_V_H
#       define endgrent() endgrent_r(&PL_reentrant_buffer->_grent_fptr)
#   endif
#  endif
#endif /* HAS_ENDGRENT_R */

#ifdef HAS_ENDHOSTENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endhostent
#   if !defined(endhostent) && ENDHOSTENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endhostent() (endhostent_r(&PL_reentrant_buffer->_hostent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(endhostent) && ENDHOSTENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endhostent() endhostent_r(&PL_reentrant_buffer->_hostent_data)
#   endif
#  endif
#endif /* HAS_ENDHOSTENT_R */

#ifdef HAS_ENDNETENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endnetent
#   if !defined(endnetent) && ENDNETENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endnetent() (endnetent_r(&PL_reentrant_buffer->_netent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(endnetent) && ENDNETENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endnetent() endnetent_r(&PL_reentrant_buffer->_netent_data)
#   endif
#  endif
#endif /* HAS_ENDNETENT_R */

#ifdef HAS_ENDPROTOENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endprotoent
#   if !defined(endprotoent) && ENDPROTOENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endprotoent() (endprotoent_r(&PL_reentrant_buffer->_protoent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(endprotoent) && ENDPROTOENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endprotoent() endprotoent_r(&PL_reentrant_buffer->_protoent_data)
#   endif
#  endif
#endif /* HAS_ENDPROTOENT_R */

#ifdef HAS_ENDPWENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endpwent
#   if !defined(endpwent) && ENDPWENT_R_PROTO == REENTRANT_PROTO_I_H
#       define endpwent() (endpwent_r(&PL_reentrant_buffer->_pwent_fptr) == 0 ? 1 : 0)
#   endif
#   if !defined(endpwent) && ENDPWENT_R_PROTO == REENTRANT_PROTO_V_H
#       define endpwent() endpwent_r(&PL_reentrant_buffer->_pwent_fptr)
#   endif
#  endif
#endif /* HAS_ENDPWENT_R */

#ifdef HAS_ENDSERVENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endservent
#   if !defined(endservent) && ENDSERVENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endservent() (endservent_r(&PL_reentrant_buffer->_servent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(endservent) && ENDSERVENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endservent() endservent_r(&PL_reentrant_buffer->_servent_data)
#   endif
#  endif
#endif /* HAS_ENDSERVENT_R */

#ifdef HAS_GETGRENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getgrent
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#   endif
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIR
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#   endif
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBW
#       define getgrent() (getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#   endif
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getgrent() (getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#   endif
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#   endif
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIH
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_fptr)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#   endif
#  endif
#endif /* HAS_GETGRENT_R */

#ifdef HAS_GETGRGID_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getgrgid
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBWR
#       define getgrgid(a) ((PL_reentrant_retint = getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#   endif
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBIR
#       define getgrgid(a) ((PL_reentrant_retint = getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#   endif
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBI
#       define getgrgid(a) ((PL_reentrant_retint = getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#   endif
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_S_TSBI
#       define getgrgid(a) (getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#   endif
#  endif
#endif /* HAS_GETGRGID_R */

#ifdef HAS_GETGRNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getgrnam
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getgrnam(a) ((PL_reentrant_retint = getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#   endif
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR
#       define getgrnam(a) ((PL_reentrant_retint = getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#   endif
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CBI
#       define getgrnam(a) (getgrnam_r(a, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? PL_reentrant_buffer->_grent_buffer : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#   endif
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBI
#       define getgrnam(a) ((PL_reentrant_retint = getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#   endif
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getgrnam(a) (getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#   endif
#  endif
#endif /* HAS_GETGRNAM_R */

#ifdef HAS_GETHOSTBYADDR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gethostbyaddr
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBWIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TWISBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CIISBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CSBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? 1 : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TSBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? 1 : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISD
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CIISD
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CII
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c)) == 0 ? 1 : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#   endif
#  endif
#endif /* HAS_GETHOSTBYADDR_R */

#ifdef HAS_GETHOSTBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gethostbyname
#   if !defined(gethostbyname) && GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE
#       define gethostbyname(a) ((PL_reentrant_retint = gethostbyname_r(a, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyname", a) : 0))
#   endif
#   if !defined(gethostbyname) && GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBIE
#       define gethostbyname(a) (gethostbyname_r(a, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyname", a) : 0))
#   endif
#   if !defined(gethostbyname) && GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
#       define gethostbyname(a) ((PL_reentrant_retint = gethostbyname_r(a, &PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyname", a) : 0))
#   endif
#  endif
#endif /* HAS_GETHOSTBYNAME_R */

#ifdef HAS_GETHOSTENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gethostent
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#   endif
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBIE
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#   endif
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBIE
#       define gethostent() (gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#   endif
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define gethostent() (gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#   endif
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#   endif
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#   endif
#  endif
#endif /* HAS_GETHOSTENT_R */

#ifdef HAS_GETLOGIN_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getlogin
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_I_BW
#       define getlogin() ((PL_reentrant_retint = getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)) == 0 ? PL_reentrant_buffer->_getlogin_buffer : ((PL_reentrant_retint == ERANGE) ? (char *) Perl_reentrant_retry("getlogin") : 0))
#   endif
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_I_BI
#       define getlogin() ((PL_reentrant_retint = getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)) == 0 ? PL_reentrant_buffer->_getlogin_buffer : ((PL_reentrant_retint == ERANGE) ? (char *) Perl_reentrant_retry("getlogin") : 0))
#   endif
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_B_BW
#       define getlogin() getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)
#   endif
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_B_BI
#       define getlogin() getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)
#   endif
#  endif
#endif /* HAS_GETLOGIN_R */

#ifdef HAS_GETNETBYADDR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getnetbyaddr
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_LISBI
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_TISBI
#       define getnetbyaddr(a, b) (getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_LISBI
#       define getnetbyaddr(a, b) (getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_TISD
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_LISD
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_IISD
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#   endif
#  endif
#endif /* HAS_GETNETBYADDR_R */

#ifdef HAS_GETNETBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getnetbyname
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE
#       define getnetbyname(a) ((PL_reentrant_retint = getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#   endif
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBI
#       define getnetbyname(a) ((PL_reentrant_retint = getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#   endif
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getnetbyname(a) (getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#   endif
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
#       define getnetbyname(a) ((PL_reentrant_retint = getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#   endif
#  endif
#endif /* HAS_GETNETBYNAME_R */

#ifdef HAS_GETNETENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getnetent
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#   endif
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBIE
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_errno)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#   endif
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBIE
#       define getnetent() (getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_errno) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#   endif
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getnetent() (getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#   endif
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#   endif
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#   endif
#  endif
#endif /* HAS_GETNETENT_R */

#ifdef HAS_GETPROTOBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getprotobyname
#   if !defined(getprotobyname) && GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getprotobyname(a) ((PL_reentrant_retint = getprotobyname_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, &PL_reentrant_buffer->_protoent_ptr)) == 0 ? PL_reentrant_buffer->_protoent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobyname", a) : 0))
#   endif
#   if !defined(getprotobyname) && GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getprotobyname(a) (getprotobyname_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size) ? &PL_reentrant_buffer->_protoent_struct : ((errno == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobyname", a) : 0))
#   endif
#   if !defined(getprotobyname) && GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
#       define getprotobyname(a) (REENTR_MEMZERO(&PL_reentrant_buffer->_protoent_data, sizeof(PL_reentrant_buffer->_protoent_data)),(PL_reentrant_retint = getprotobyname_r(a, &PL_reentrant_buffer->_protoent_struct, &PL_reentrant_buffer->_protoent_data)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobyname", a) : 0))
#   endif
#  endif
#endif /* HAS_GETPROTOBYNAME_R */

#ifdef HAS_GETPROTOBYNUMBER_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getprotobynumber
#   if !defined(getprotobynumber) && GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISBWR
#       define getprotobynumber(a) ((PL_reentrant_retint = getprotobynumber_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, &PL_reentrant_buffer->_protoent_ptr)) == 0 ? PL_reentrant_buffer->_protoent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobynumber", a) : 0))
#   endif
#   if !defined(getprotobynumber) && GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_S_ISBI
#       define getprotobynumber(a) (getprotobynumber_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size) ? &PL_reentrant_buffer->_protoent_struct : ((errno == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobynumber", a) : 0))
#   endif
#   if !defined(getprotobynumber) && GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISD
#       define getprotobynumber(a) (REENTR_MEMZERO(&PL_reentrant_buffer->_protoent_data, sizeof(PL_reentrant_buffer->_protoent_data)),(PL_reentrant_retint = getprotobynumber_r(a, &PL_reentrant_buffer->_protoent_struct, &PL_reentrant_buffer->_protoent_data)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobynumber", a) : 0))
#   endif
#  endif
#endif /* HAS_GETPROTOBYNUMBER_R */

#ifdef HAS_GETPROTOENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getprotoent
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getprotoent() ((PL_reentrant_retint = getprotoent_r(&PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, &PL_reentrant_buffer->_protoent_ptr)) == 0 ? PL_reentrant_buffer->_protoent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#   endif
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getprotoent() ((PL_reentrant_retint = getprotoent_r(&PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#   endif
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getprotoent() (getprotoent_r(&PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size) ? &PL_reentrant_buffer->_protoent_struct : ((errno == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#   endif
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define getprotoent() (REENTR_MEMZERO(&PL_reentrant_buffer->_protoent_data, sizeof(PL_reentrant_buffer->_protoent_data)),(PL_reentrant_retint = getprotoent_r(&PL_reentrant_buffer->_protoent_struct, &PL_reentrant_buffer->_protoent_data)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#   endif
#  endif
#endif /* HAS_GETPROTOENT_R */

#ifdef HAS_GETPWENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getpwent
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#   endif
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIR
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#   endif
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBW
#       define getpwent() (getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#   endif
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getpwent() (getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#   endif
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#   endif
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIH
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_fptr)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#   endif
#  endif
#endif /* HAS_GETPWENT_R */

#ifdef HAS_GETPWNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getpwnam
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getpwnam(a) ((PL_reentrant_retint = getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#   endif
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR
#       define getpwnam(a) ((PL_reentrant_retint = getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#   endif
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getpwnam(a) (getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#   endif
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBI
#       define getpwnam(a) ((PL_reentrant_retint = getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#   endif
#  endif
#endif /* HAS_GETPWNAM_R */

#ifdef HAS_GETPWUID_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getpwuid
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBWR
#       define getpwuid(a) ((PL_reentrant_retint = getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#   endif
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBIR
#       define getpwuid(a) ((PL_reentrant_retint = getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#   endif
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBI
#       define getpwuid(a) ((PL_reentrant_retint = getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#   endif
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_S_TSBI
#       define getpwuid(a) (getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#   endif
#  endif
#endif /* HAS_GETPWUID_R */

#ifdef HAS_GETSERVBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getservbyname
#   if !defined(getservbyname) && GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSBWR
#       define getservbyname(a, b) ((PL_reentrant_retint = getservbyname_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, &PL_reentrant_buffer->_servent_ptr)) == 0 ? PL_reentrant_buffer->_servent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyname", a, b) : 0))
#   endif
#   if !defined(getservbyname) && GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_S_CCSBI
#       define getservbyname(a, b) (getservbyname_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size) ? &PL_reentrant_buffer->_servent_struct : ((errno == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyname", a, b) : 0))
#   endif
#   if !defined(getservbyname) && GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD
#       define getservbyname(a, b) (REENTR_MEMZERO(&PL_reentrant_buffer->_servent_data, sizeof(PL_reentrant_buffer->_servent_data)),(PL_reentrant_retint = getservbyname_r(a, b, &PL_reentrant_buffer->_servent_struct, &PL_reentrant_buffer->_servent_data)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyname", a, b) : 0))
#   endif
#  endif
#endif /* HAS_GETSERVBYNAME_R */

#ifdef HAS_GETSERVBYPORT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getservbyport
#   if !defined(getservbyport) && GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSBWR
#       define getservbyport(a, b) ((PL_reentrant_retint = getservbyport_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, &PL_reentrant_buffer->_servent_ptr)) == 0 ? PL_reentrant_buffer->_servent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyport", a, b) : 0))
#   endif
#   if !defined(getservbyport) && GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_S_ICSBI
#       define getservbyport(a, b) (getservbyport_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size) ? &PL_reentrant_buffer->_servent_struct : ((errno == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyport", a, b) : 0))
#   endif
#   if !defined(getservbyport) && GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSD
#       define getservbyport(a, b) (REENTR_MEMZERO(&PL_reentrant_buffer->_servent_data, sizeof(PL_reentrant_buffer->_servent_data)),(PL_reentrant_retint = getservbyport_r(a, b, &PL_reentrant_buffer->_servent_struct, &PL_reentrant_buffer->_servent_data)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyport", a, b) : 0))
#   endif
#  endif
#endif /* HAS_GETSERVBYPORT_R */

#ifdef HAS_GETSERVENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getservent
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getservent() ((PL_reentrant_retint = getservent_r(&PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, &PL_reentrant_buffer->_servent_ptr)) == 0 ? PL_reentrant_buffer->_servent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#   endif
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getservent() ((PL_reentrant_retint = getservent_r(&PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#   endif
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getservent() (getservent_r(&PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size) ? &PL_reentrant_buffer->_servent_struct : ((errno == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#   endif
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define getservent() (REENTR_MEMZERO(&PL_reentrant_buffer->_servent_data, sizeof(PL_reentrant_buffer->_servent_data)),(PL_reentrant_retint = getservent_r(&PL_reentrant_buffer->_servent_struct, &PL_reentrant_buffer->_servent_data)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#   endif
#  endif
#endif /* HAS_GETSERVENT_R */

#ifdef HAS_GETSPNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getspnam
#   if !defined(getspnam) && GETSPNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getspnam(a) ((PL_reentrant_retint = getspnam_r(a, &PL_reentrant_buffer->_spent_struct, PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size, &PL_reentrant_buffer->_spent_ptr)) == 0 ? PL_reentrant_buffer->_spent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct spwd *) Perl_reentrant_retry("getspnam", a) : 0))
#   endif
#   if !defined(getspnam) && GETSPNAM_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getspnam(a) (getspnam_r(a, &PL_reentrant_buffer->_spent_struct, PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size) ? &PL_reentrant_buffer->_spent_struct : ((errno == ERANGE) ? (struct spwd *) Perl_reentrant_retry("getspnam", a) : 0))
#   endif
#  endif
#endif /* HAS_GETSPNAM_R */

#ifdef HAS_READDIR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef readdir
#   if !defined(readdir) && READDIR_R_PROTO == REENTRANT_PROTO_I_TSR
#       define readdir(a) (readdir_r(a, PL_reentrant_buffer->_readdir_struct, &PL_reentrant_buffer->_readdir_ptr) == 0 ? PL_reentrant_buffer->_readdir_ptr : 0)
#   endif
#   if !defined(readdir) && READDIR_R_PROTO == REENTRANT_PROTO_I_TS
#       define readdir(a) (readdir_r(a, PL_reentrant_buffer->_readdir_struct) == 0 ? PL_reentrant_buffer->_readdir_struct : 0)
#   endif
#  endif
#endif /* HAS_READDIR_R */

#ifdef HAS_READDIR64_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef readdir64
#   if !defined(readdir64) && READDIR64_R_PROTO == REENTRANT_PROTO_I_TSR
#       define readdir64(a) (readdir64_r(a, PL_reentrant_buffer->_readdir64_struct, &PL_reentrant_buffer->_readdir64_ptr) == 0 ? PL_reentrant_buffer->_readdir64_ptr : 0)
#   endif
#   if !defined(readdir64) && READDIR64_R_PROTO == REENTRANT_PROTO_I_TS
#       define readdir64(a) (readdir64_r(a, PL_reentrant_buffer->_readdir64_struct) == 0 ? PL_reentrant_buffer->_readdir64_struct : 0)
#   endif
#  endif
#endif /* HAS_READDIR64_R */

#ifdef HAS_SETGRENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setgrent
#   if !defined(setgrent) && SETGRENT_R_PROTO == REENTRANT_PROTO_I_H
#       define setgrent() (setgrent_r(&PL_reentrant_buffer->_grent_fptr) == 0 ? 1 : 0)
#   endif
#   if !defined(setgrent) && SETGRENT_R_PROTO == REENTRANT_PROTO_V_H
#       define setgrent() setgrent_r(&PL_reentrant_buffer->_grent_fptr)
#   endif
#  endif
#endif /* HAS_SETGRENT_R */

#ifdef HAS_SETHOSTENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef sethostent
#   if !defined(sethostent) && SETHOSTENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define sethostent(a) (sethostent_r(a, &PL_reentrant_buffer->_hostent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(sethostent) && SETHOSTENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define sethostent(a) sethostent_r(a, &PL_reentrant_buffer->_hostent_data)
#   endif
#  endif
#endif /* HAS_SETHOSTENT_R */

#ifdef HAS_SETLOCALE_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setlocale
#   if !defined(setlocale) && SETLOCALE_R_PROTO == REENTRANT_PROTO_I_ICBI
#       define setlocale(a, b) (setlocale_r(a, b, PL_reentrant_buffer->_setlocale_buffer, PL_reentrant_buffer->_setlocale_size) == 0 ? PL_reentrant_buffer->_setlocale_buffer : 0)
#   endif
#  endif
#endif /* HAS_SETLOCALE_R */

#ifdef HAS_SETNETENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setnetent
#   if !defined(setnetent) && SETNETENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define setnetent(a) (setnetent_r(a, &PL_reentrant_buffer->_netent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(setnetent) && SETNETENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define setnetent(a) setnetent_r(a, &PL_reentrant_buffer->_netent_data)
#   endif
#  endif
#endif /* HAS_SETNETENT_R */

#ifdef HAS_SETPROTOENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setprotoent
#   if !defined(setprotoent) && SETPROTOENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define setprotoent(a) (setprotoent_r(a, &PL_reentrant_buffer->_protoent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(setprotoent) && SETPROTOENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define setprotoent(a) setprotoent_r(a, &PL_reentrant_buffer->_protoent_data)
#   endif
#  endif
#endif /* HAS_SETPROTOENT_R */

#ifdef HAS_SETPWENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setpwent
#   if !defined(setpwent) && SETPWENT_R_PROTO == REENTRANT_PROTO_I_H
#       define setpwent() (setpwent_r(&PL_reentrant_buffer->_pwent_fptr) == 0 ? 1 : 0)
#   endif
#   if !defined(setpwent) && SETPWENT_R_PROTO == REENTRANT_PROTO_V_H
#       define setpwent() setpwent_r(&PL_reentrant_buffer->_pwent_fptr)
#   endif
#  endif
#endif /* HAS_SETPWENT_R */

#ifdef HAS_SETSERVENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setservent
#   if !defined(setservent) && SETSERVENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define setservent(a) (setservent_r(a, &PL_reentrant_buffer->_servent_data) == 0 ? 1 : 0)
#   endif
#   if !defined(setservent) && SETSERVENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define setservent(a) setservent_r(a, &PL_reentrant_buffer->_servent_data)
#   endif
#  endif
#endif /* HAS_SETSERVENT_R */

#ifdef HAS_STRERROR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef strerror
#   if !defined(strerror) && STRERROR_R_PROTO == REENTRANT_PROTO_I_IBW
#       define strerror(a) (strerror_r(a, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size) == 0 ? PL_reentrant_buffer->_strerror_buffer : 0)
#   endif
#   if !defined(strerror) && STRERROR_R_PROTO == REENTRANT_PROTO_I_IBI
#       define strerror(a) (strerror_r(a, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size) == 0 ? PL_reentrant_buffer->_strerror_buffer : 0)
#   endif
#   if !defined(strerror) && STRERROR_R_PROTO == REENTRANT_PROTO_B_IBW
#       define strerror(a) strerror_r(a, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size)
#   endif
#  endif
#endif /* HAS_STRERROR_R */

#ifdef HAS_TMPNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef tmpnam
#   if !defined(tmpnam) && TMPNAM_R_PROTO == REENTRANT_PROTO_B_B
#       define tmpnam(a) tmpnam_r(a)
#   endif
#  endif
#endif /* HAS_TMPNAM_R */

#ifdef HAS_TTYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef ttyname
#   if !defined(ttyname) && TTYNAME_R_PROTO == REENTRANT_PROTO_I_IBW
#       define ttyname(a) (ttyname_r(a, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size) == 0 ? PL_reentrant_buffer->_ttyname_buffer : 0)
#   endif
#   if !defined(ttyname) && TTYNAME_R_PROTO == REENTRANT_PROTO_I_IBI
#       define ttyname(a) (ttyname_r(a, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size) == 0 ? PL_reentrant_buffer->_ttyname_buffer : 0)
#   endif
#   if !defined(ttyname) && TTYNAME_R_PROTO == REENTRANT_PROTO_B_IBI
#       define ttyname(a) ttyname_r(a, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size)
#   endif
#  endif
#endif /* HAS_TTYNAME_R */



#endif /* USE_REENTRANT_API */
 
#endif

/* ex: set ro: */
                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/regcharclass.h                                            0100644 0000000 0000000 00000150656 12744441327 020563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    regcharclass.h
 *
 *    Copyright (C) 2007, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/regcharclass.pl.
 * Any changes made here will be lost!
 * WARNING: These macros are for internal Perl core use only, and may be
 * changed or removed without notice.
 */


#ifndef H_REGCHARCLASS   /* Guard against nested #includes */
#define H_REGCHARCLASS 1

/*
	LNBREAK: Line Break: \R

	"\x0D\x0A"      # CRLF - Network (Windows) line ending
	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_LNBREAK_safe(s,e,is_utf8)                                        \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0C ) ? 1\
    : ( 0x0D == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x0A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 1 )               \
    : ( is_utf8 ) ?                                                         \
	( ( 0xC2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                       \
	    ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )           \
	: ( ( ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
    : ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) )                           \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0C ) ? 1\
    : ( 0x0D == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x0A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 1 )               \
    : ( is_utf8 ) ?                                                         \
	( ( ( 0xC2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) ? 2 : 0 )\
    : ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) )                           \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0D ) ? 1\
    : ( !( is_utf8 ) ) ?                                                    \
	( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) )                           \
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_utf8_safe(s,e)                                           \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0C ) ? 1\
    : ( 0x0D == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x0A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 1 )               \
    : ( 0xC2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )               \
    : ( ( ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0C ) ? 1\
    : ( 0x0D == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x0A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 1 )               \
    : ( ( 0xC2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) ? 2 : 0 )\
: ((e)-(s) > 0) ?                                                           \
    ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0D )\
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_latin1_safe(s,e)                                         \
( ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0C ) || 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ? 1\
    : ( 0x0D == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x0A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 1 )               \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0D ) || 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) )\
: 0 )

/*
	HORIZWS: Horizontal Whitespace: \h \H

	\p{HorizSpace}
*/
/*** GENERATED CODE ***/
#define is_HORIZWS_high(s)                                                  \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( 0x9A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x8A ) || 0xAF == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )\
    : ( ( 0x81 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( ( ( 0xE3 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_cp_high(cp)                                              \
( 0x1680 == NATIVE_TO_UNI(cp) || ( 0x1680 < NATIVE_TO_UNI(cp) &&            \
( ( 0x2000 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0x200A ) || ( 0x200A < NATIVE_TO_UNI(cp) &&\
( 0x202F == NATIVE_TO_UNI(cp) || ( 0x202F < NATIVE_TO_UNI(cp) &&            \
( 0x205F == NATIVE_TO_UNI(cp) || 0x3000 == NATIVE_TO_UNI(cp) ) ) ) ) ) ) )

/*
	VERTWS: Vertical Whitespace: \v \V

	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_VERTWS_high(s)                                                   \
( ( ( ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xA8 ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_cp_high(cp)                                               \
( 0x2028 == NATIVE_TO_UNI(cp) || 0x2029 == NATIVE_TO_UNI(cp) )

/*
	XDIGIT: Hexadecimal digits

	\p{XDigit}
*/
/*** GENERATED CODE ***/
#define is_XDIGIT_high(s)                                                   \
( ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( 0x90 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x99 ) || ( 0xA1 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xA6 ) ) ? 3 : 0 )\
    : ( ( 0xBD == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x81 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) ) ? 3 : 0 )\
: 0 )

/*** GENERATED CODE ***/
#define is_XDIGIT_cp_high(cp)                                               \
( ( 0xFF10 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0xFF19 ) || ( 0xFF19 < NATIVE_TO_UNI(cp) &&\
( ( 0xFF21 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0xFF26 ) || ( 0xFF41 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0xFF46 ) ) ) )

/*
	XPERLSPACE: \p{XPerlSpace}

	\p{XPerlSpace}
*/
/*** GENERATED CODE ***/
#define is_XPERLSPACE_high(s)                                               \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( 0x9A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x8A ) || ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xA8 || 0xAF == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )\
    : ( ( 0x81 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( ( ( 0xE3 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_XPERLSPACE_cp_high(cp)                                           \
( 0x1680 == NATIVE_TO_UNI(cp) || ( 0x1680 < NATIVE_TO_UNI(cp) &&            \
( ( 0x2000 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0x200A ) || ( 0x200A < NATIVE_TO_UNI(cp) &&\
( 0x2028 == NATIVE_TO_UNI(cp) || ( 0x2028 < NATIVE_TO_UNI(cp) &&            \
( 0x2029 == NATIVE_TO_UNI(cp) || ( 0x2029 < NATIVE_TO_UNI(cp) &&            \
( 0x202F == NATIVE_TO_UNI(cp) || ( 0x202F < NATIVE_TO_UNI(cp) &&            \
( 0x205F == NATIVE_TO_UNI(cp) || 0x3000 == NATIVE_TO_UNI(cp) ) ) ) ) ) ) ) ) ) ) )

/*
	REPLACEMENT: Unicode REPLACEMENT CHARACTER

	0xFFFD
*/
/*** GENERATED CODE ***/
#define is_REPLACEMENT_utf8_safe(s,e)                                       \
( ( ( ( ( ((e) - (s)) >= 3 ) && ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0xBD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )

/*
	NONCHAR: Non character code points

	\p{Nchar}
*/
/*** GENERATED CODE ***/
#define is_NONCHAR_utf8(s)                                                  \
( ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0xB7 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0x90 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xAF ) ? 3 : 0 )\
    : ( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xBE ) ) ? 3 : 0 )\
: ( 0xF0 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) == 0x9F || ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xEF ) == 0xAF ) ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[3]) >= 0xBE ) ) ? 4 : 0 )\
: ( 0xF1 <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0xF3 ) ?\
    ( ( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xCF ) == 0x8F ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[3]) >= 0xBE ) ) ? 4 : 0 )\
: ( ( ( ( 0xF4 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x8F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[3]) >= 0xBE ) ) ? 4 : 0 )

/*
	SURROGATE: Surrogate characters

	\p{Gc=Cs}
*/
/*** GENERATED CODE ***/
#define is_SURROGATE_utf8(s)                                                \
( ( ( 0xED == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[1]) >= 0xA0 ) ) ? 3 : 0 )

/*
	GCB_L: Grapheme_Cluster_Break=L

	\p{_X_GCB_L}
*/
/*** GENERATED CODE ***/
#define is_GCB_L_utf8(s)                                                    \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x84 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	3                                                                   \
    : ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x9F ) ) ? 3 : 0 )\
: ( ( ( 0xEA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0xA5 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0xA0 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xBC ) ) ? 3 : 0 )

/*
	GCB_LV_LVT_V: Grapheme_Cluster_Break=(LV or LVT or V)

	\p{_X_LV_LVT_V}
*/
/*** GENERATED CODE ***/
#define is_GCB_LV_LVT_V_utf8(s)                                             \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xA0 ) ? 3 : 0 )               \
    : ( ( 0x86 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xA7 ) ) ? 3 : 0 )\
: ( 0xEA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) >= 0xB0 ) ?                           \
	3                                                                   \
    : 0 )                                                                   \
: ( 0xEB == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0xEC == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
    3                                                                       \
: ( 0xED == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) <= 0x9D ) ?                           \
	3                                                                   \
    : ( 0x9E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xA3 ) || ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xB0 ) ) ? 3 : 0 )\
    : ( ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) ) ? 3 : 0 )\
: 0 )

/*
	GCB_Prepend: Grapheme_Cluster_Break=Prepend

	\p{_X_GCB_Prepend}
*/
/*** GENERATED CODE ***/
#define is_GCB_Prepend_utf8(s)                                              \
( 0 )

/*
	GCB_RI: Grapheme_Cluster_Break=RI

	\p{_X_RI}
*/
/*** GENERATED CODE ***/
#define is_GCB_RI_utf8(s)                                                   \
( ( ( ( ( 0xF0 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[3]) >= 0xA6 ) ) ? 4 : 0 )

/*
	GCB_SPECIAL_BEGIN_START: Grapheme_Cluster_Break=special_begin_starts

	\p{_X_Special_Begin_Start}
*/
/*** GENERATED CODE ***/
#define is_GCB_SPECIAL_BEGIN_START_utf8(s)                                  \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xFC ) == 0x84 ) ?                \
	3                                                                   \
    : 0 )                                                                   \
: ( 0xEA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0xA5 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0xA0 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xBC ) ? 3 : 0 )\
    : ( NATIVE_TO_LATIN1(((U8*)s)[1]) >= 0xB0 ) ?                           \
	3                                                                   \
    : 0 )                                                                   \
: ( 0xEB == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0xEC == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
    3                                                                       \
: ( 0xED == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) <= 0x9D ) ?                           \
	3                                                                   \
    : ( 0x9E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xA3 ) || ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xB0 ) ) ? 3 : 0 )\
    : ( ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) || ( 0x8B <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xBB ) ) ) ? 3 : 0 )\
: ( ( ( ( 0xF0 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[3]) >= 0xA6 ) ) ? 4 : 0 )

/*
	GCB_T: Grapheme_Cluster_Break=T

	\p{_X_GCB_T}
*/
/*** GENERATED CODE ***/
#define is_GCB_T_utf8(s)                                                    \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x86 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xA8 ) ? 3 : 0 )               \
    : ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	3                                                                   \
    : 0 )                                                                   \
: ( ( ( 0xED == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0x8B <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xBB ) ) ? 3 : 0 )

/*
	GCB_V: Grapheme_Cluster_Break=V

	\p{_X_GCB_V}
*/
/*** GENERATED CODE ***/
#define is_GCB_V_utf8(s)                                                    \
( ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xA0 ) ? 3 : 0 )               \
    : ( ( 0x86 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xA7 ) ) ? 3 : 0 )\
: ( 0xED == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x9E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xB0 ) ? 3 : 0 )               \
    : ( ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) ) ? 3 : 0 )\
: 0 )

/*
	QUOTEMETA: Meta-characters that \Q should quote

	\p{_Perl_Quotemeta}
*/
/*** GENERATED CODE ***/
#define is_QUOTEMETA_high(s)                                                \
( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x8F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xD8 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x9C == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[2]) || 0xA0 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )\
    : ( 0x9A == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )               \
    : ( 0x9E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xB4 ) ? 3 : 0 )    \
    : ( ( 0xA0 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8B <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x8E ) ) ? 3 : 0 )\
: ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xBE ) ? 3 : 0 )               \
    : ( 0x81 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( 0x81 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x93 ) || ( 0x95 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xAF ) ) ? 3 : 0 )\
    : ( 0x86 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0x90 ) ? 3 : 0 )               \
    : ( ( 0x87 <= NATIVE_TO_LATIN1(((U8*)s)[1]) && NATIVE_TO_LATIN1(((U8*)s)[1]) <= 0x90 ) || ( 0x94 <= NATIVE_TO_LATIN1(((U8*)s)[1]) && NATIVE_TO_LATIN1(((U8*)s)[1]) <= 0x9C ) || ( 0x9F <= NATIVE_TO_LATIN1(((U8*)s)[1]) && NATIVE_TO_LATIN1(((U8*)s)[1]) <= 0xAF ) || ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xFE ) == 0xB8 ) ?\
	3                                                                   \
    : ( 0x91 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x9F ) ? 3 : 0 )               \
    : ( 0x9D == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xB5 ) ? 3 : 0 )               \
    : ( ( 0x9E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0x94 ) ) ? 3 : 0 )\
: ( 0xE3 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x83 ) || ( 0x88 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xA0 ) || 0xB0 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )\
    : ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xA4 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0xB4 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) >= 0xBE ) ? 3 : 0 )               \
    : ( 0xB8 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x8F ) ? 3 : 0 )               \
    : ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[2]) || 0x86 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )\
    : ( 0xBB == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )               \
    : ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( 0xA0 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )               \
    : ( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xB0 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0xB8 ) ) ? 3 : 0 )\
: ( 0xF0 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( ( 0x9D == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB3 <= NATIVE_TO_LATIN1(((U8*)s)[3]) && NATIVE_TO_LATIN1(((U8*)s)[3]) <= 0xBA ) ) ? 4 : 0 )\
: ( ( 0xF3 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0xA0 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) ? 4 : 0 )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	do regen/regcharclass_multi_char_folds.pl
	&regcharclass_multi_char_folds::multi_char_folds(1)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e)                             \
( ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x74 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e)                             \
( ( 0x74 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x88 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x77 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0x79 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8A == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x6E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xFD ) == 0xAC ) ?            \
	    ( ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xB7 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?\
	    ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ?               \
		    ( ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[4]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[5]) ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x88 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ?               \
		    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ?           \
			( ( ( NATIVE_TO_LATIN1(((U8*)s)[5]) & 0xFE ) == 0x80 ) ? 6 : 0 )\
		    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[4]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[5]) ) ) ? 6 : 0 )\
		: 0 )                                                       \
	    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: 0 )                                                               \
    : ( 0xCF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x81 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x93 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x88 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ?               \
		    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ?           \
			( ( ( NATIVE_TO_LATIN1(((U8*)s)[5]) & 0xFE ) == 0x80 ) ? 6 : 0 )\
		    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[4]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[5]) ) ) ? 6 : 0 )\
		: ( 0x93 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ?               \
		    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ?           \
			( ( ( NATIVE_TO_LATIN1(((U8*)s)[5]) & 0xFE ) == 0x80 ) ? 6 : 4 )\
		    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[4]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[5]) ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0x89 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ?               \
		    ( ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[4]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[5]) ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( ( ( 0x8E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0xA5 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xD6 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB4 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[3]) & 0xF7 ) == 0xA5 ) || NATIVE_TO_LATIN1(((U8*)s)[3]) == 0xAB || NATIVE_TO_LATIN1(((U8*)s)[3]) == 0xB6 ) ) ? 4 : 0 )\
	: ( ( ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB6 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xD8 ) == 0x80 ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ) ? 5 : 0 )\
	: ( ( ( ( 0xBD == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF8 ) == 0xA0 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFB ) == 0xB0 ) || NATIVE_TO_LATIN1(((U8*)s)[2]) == 0xBC ) ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ) ? 5 : 0 )\
    : 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part2(s,e)                             \
( ( 0x61 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
	( ( ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[2]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 2 )\
	: ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x68 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x6A == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x74 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x74 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x88 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x77 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0x79 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8A == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x6E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xFD ) == 0xAC ) ?            \
	    ( ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xB7 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?\
	    ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ? 4 : 0 )       \
	    : ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( ( ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xCF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x81 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x93 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x93 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ? 4 : 0 )       \
	    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0x89 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ? 4 : 0 )       \
	    : ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( ( ( 0x8E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0xA5 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xD6 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB4 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[3]) & 0xF7 ) == 0xA5 ) || NATIVE_TO_LATIN1(((U8*)s)[3]) == 0xAB || NATIVE_TO_LATIN1(((U8*)s)[3]) == 0xB6 ) ) ? 4 : 0 )\
	: ( ( ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB6 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part3(s,e)                             \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x61 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[2]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 2 )\
	: ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x68 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x6A == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x74 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x74 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x88 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x77 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0x79 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8A == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( ( ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( 0x6E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x69 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x74 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) ? 2 : 0 )\
: 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part4(s,e)                             \
( ( 0x61 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
	( ( ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[2]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 2 )\
	: ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x68 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x6A == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ? is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e) : is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e) )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part5(s,e)                             \
( ((e)-(s) > 4) ?                                                           \
    ( ( 0x61 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x66 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[2]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 2 )\
	: ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x6C == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x68 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x69 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x6A == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8C == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x73 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0x74 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
    : ( 0x74 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x88 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0x77 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0x79 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
	( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x8A == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0x6E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
    : ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xFD ) == 0xAC ) ?            \
	    ( ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB1 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xB7 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?\
	    ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ? 4 : 0 )       \
	    : ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( ( ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xCF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0x81 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x93 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCC == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x93 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ? 4 : 0 )       \
	    : ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0x89 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( 0xCD == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ?                   \
		( ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ? 4 : 0 )       \
	    : ( ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( ( ( 0x8E == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0xA5 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xD6 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( 0x82 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
	: ( 0xB4 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[3]) & 0xF7 ) == 0xA5 ) || NATIVE_TO_LATIN1(((U8*)s)[3]) == 0xAB || NATIVE_TO_LATIN1(((U8*)s)[3]) == 0xB6 ) ) ? 4 : 0 )\
	: ( ( ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( 0xD5 == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) && ( 0xB6 == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) ? 4 : 0 )\
    : ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                           \
	( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                       \
	    ( ( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xD8 ) == 0x80 ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ) ? 5 : 0 )\
	: ( ( ( ( 0xBD == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF8 ) == 0xA0 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFB ) == 0xB0 ) || NATIVE_TO_LATIN1(((U8*)s)[2]) == 0xBC ) ) && ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[3]) ) ) && ( 0xB9 == NATIVE_TO_LATIN1(((U8*)s)[4]) ) ) ? 5 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 3) ? is_MULTI_CHAR_FOLD_utf8_safe_part2(s,e) : is_MULTI_CHAR_FOLD_utf8_safe_part3(s,e) )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe(s,e)                                   \
( ((e)-(s) > 5) ? is_MULTI_CHAR_FOLD_utf8_safe_part4(s,e) : is_MULTI_CHAR_FOLD_utf8_safe_part5(s,e) )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(0)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_latin1_safe(s,e)                                 \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0xDF ) == 0x46 ) ?                \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x46 ) ?            \
	    ( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xDF ) == 0x49 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xDF ) == 0x4C ) ) ? 3 : 2 )\
	: ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x49 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x4C ) ) ? 2 : 0 )\
    : ( ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0xDF ) == 0x53 ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x53 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x54 ) ) ) ? 2 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0xDF ) == 0x46 ) ?                \
	( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x46 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x49 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x4C ) ) ? 2 : 0 )\
    : ( ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0xDF ) == 0x53 ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x53 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x54 ) ) ) ? 2 : 0 )\
: 0 )

/*
	FOLDS_TO_MULTI: characters that fold to multi-char strings

	\p{_Perl_Folds_To_Multi_Char}
*/
/*** GENERATED CODE ***/
#define is_FOLDS_TO_MULTI_utf8(s)                                           \
( ( 0xC3 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x9F == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xC4 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0xC7 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
    ( ( 0xB0 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x89 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x90 ) ? 2 : 0 )        \
: ( 0xD6 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x87 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0xBA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( 0x96 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x9A ) || 0x9E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ? 3 : 0 )\
    : ( 0xBD == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF9 ) == 0x90 ) ? 3 : 0 )    \
    : ( 0xBE == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ?                           \
	( ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xE0 ) == 0x80 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF0 ) == 0xA0 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFA ) == 0xB2 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF7 ) == 0xB4 ) ) ? 3 : 0 )\
    : ( ( 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xCA ) == 0x82 ) || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF7 ) == 0x84 ) || NATIVE_TO_LATIN1(((U8*)s)[2]) == 0xA4 || ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xF7 ) == 0xB4 ) ) ) ? 3 : 0 )\
: ( ( ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0xAC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) || ( 0x93 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x97 ) ) ) ? 3 : 0 )

/*
	PROBLEMATIC_LOCALE_FOLD: characters whose fold is problematic under locale

	\p{_Perl_Problematic_Locale_Folds}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_utf8(s)                                  \
( ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0x80 ) == 0x00 ) ? 1                  \
: ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0xFE ) == 0xC2 ) ?                    \
    2                                                                       \
: ( 0xC4 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0xC7 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
    ( ( 0xB0 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x89 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xB8 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
: ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x9C ) ? 2 : 0 )        \
: ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( 0xBA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( 0x96 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x9A ) || 0x9E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( 0x84 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xAA ) ) ? 3 : 0 )\
: ( ( ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0xAC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_cp(cp)                                   \
( NATIVE_TO_UNI(cp) <= 0xFF || ( 0xFF < NATIVE_TO_UNI(cp) &&                \
( 0x130 == NATIVE_TO_UNI(cp) || ( 0x130 < NATIVE_TO_UNI(cp) &&              \
( 0x149 == NATIVE_TO_UNI(cp) || ( 0x149 < NATIVE_TO_UNI(cp) &&              \
( 0x178 == NATIVE_TO_UNI(cp) || ( 0x178 < NATIVE_TO_UNI(cp) &&              \
( 0x17F == NATIVE_TO_UNI(cp) || ( 0x17F < NATIVE_TO_UNI(cp) &&              \
( 0x1F0 == NATIVE_TO_UNI(cp) || ( 0x1F0 < NATIVE_TO_UNI(cp) &&              \
( 0x39C == NATIVE_TO_UNI(cp) || ( 0x39C < NATIVE_TO_UNI(cp) &&              \
( 0x3BC == NATIVE_TO_UNI(cp) || ( 0x3BC < NATIVE_TO_UNI(cp) &&              \
( ( 0x1E96 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0x1E9A ) || ( 0x1E9A < NATIVE_TO_UNI(cp) &&\
( 0x1E9E == NATIVE_TO_UNI(cp) || ( 0x1E9E < NATIVE_TO_UNI(cp) &&            \
( 0x212A == NATIVE_TO_UNI(cp) || ( 0x212A < NATIVE_TO_UNI(cp) &&            \
( 0x212B == NATIVE_TO_UNI(cp) || ( 0xFB00 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PROBLEMATIC_LOCALE_FOLDEDS_START: The first folded character of folds which are problematic under locale

	\p{_Perl_Problematic_Locale_Foldeds_Start}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_utf8(s)                         \
( ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0x80 ) == 0x00 ) ? 1                  \
: ( ( NATIVE_TO_LATIN1(((U8*)s)[0]) & 0xFE ) == 0xC2 ) ?                    \
    2                                                                       \
: ( 0xC4 == NATIVE_TO_LATIN1(((U8*)s)[0]) || 0xC7 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?\
    ( ( 0xB0 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xC5 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0x89 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xB8 == NATIVE_TO_LATIN1(((U8*)s)[1]) || 0xBF == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )\
: ( 0xCA == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( 0xBC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )                   \
: ( 0xCE == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( NATIVE_TO_LATIN1(((U8*)s)[1]) & 0xDF ) == 0x9C ) ? 2 : 0 )        \
: ( 0xE1 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( 0xBA == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( 0x96 <= NATIVE_TO_LATIN1(((U8*)s)[2]) && NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x9A ) || 0x9E == NATIVE_TO_LATIN1(((U8*)s)[2]) ) ) ? 3 : 0 )\
: ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                               \
    ( ( ( 0x84 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xAA ) ) ? 3 : 0 )\
: ( ( ( 0xEF == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0xAC == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( NATIVE_TO_LATIN1(((U8*)s)[2]) <= 0x86 ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(cp)                          \
( NATIVE_TO_UNI(cp) <= 0xFF || ( 0xFF < NATIVE_TO_UNI(cp) &&                \
( 0x130 == NATIVE_TO_UNI(cp) || ( 0x130 < NATIVE_TO_UNI(cp) &&              \
( 0x149 == NATIVE_TO_UNI(cp) || ( 0x149 < NATIVE_TO_UNI(cp) &&              \
( 0x178 == NATIVE_TO_UNI(cp) || ( 0x178 < NATIVE_TO_UNI(cp) &&              \
( 0x17F == NATIVE_TO_UNI(cp) || ( 0x17F < NATIVE_TO_UNI(cp) &&              \
( 0x1F0 == NATIVE_TO_UNI(cp) || ( 0x1F0 < NATIVE_TO_UNI(cp) &&              \
( 0x2BC == NATIVE_TO_UNI(cp) || ( 0x2BC < NATIVE_TO_UNI(cp) &&              \
( 0x39C == NATIVE_TO_UNI(cp) || ( 0x39C < NATIVE_TO_UNI(cp) &&              \
( 0x3BC == NATIVE_TO_UNI(cp) || ( 0x3BC < NATIVE_TO_UNI(cp) &&              \
( ( 0x1E96 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0x1E9A ) || ( 0x1E9A < NATIVE_TO_UNI(cp) &&\
( 0x1E9E == NATIVE_TO_UNI(cp) || ( 0x1E9E < NATIVE_TO_UNI(cp) &&            \
( 0x212A == NATIVE_TO_UNI(cp) || ( 0x212A < NATIVE_TO_UNI(cp) &&            \
( 0x212B == NATIVE_TO_UNI(cp) || ( 0xFB00 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PATWS: pattern white space

	\p{PatWS}
*/
/*** GENERATED CODE ***/
#define is_PATWS_safe(s,e,is_utf8)                                          \
( ((e) > (s)) ?                                                             \
    ( ( ( 0x09 <= NATIVE_TO_LATIN1(((U8*)s)[0]) && NATIVE_TO_LATIN1(((U8*)s)[0]) <= 0x0D ) || 0x20 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ? 1\
    : (! is_utf8 ) ?                                                        \
	    ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) )                       \
	: (((e) - (s)) >= UTF8SKIP(s)) ?                                    \
	    ( ( 0xC2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                   \
		( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )       \
	    : ( ( ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0x8E || ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
	: 0 )                                                               \
: 0 )

/*** GENERATED CODE ***/
#define is_PATWS_non_low_safe(s,e,is_utf8)                                  \
( ((e) > (s)) ?                                                             \
    ( (! is_utf8) ?                                                         \
	( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[0]) )                           \
    : (((e) - (s)) >= UTF8SKIP(s)) ?                                        \
	( ( 0xC2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) ?                       \
	    ( ( 0x85 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ? 2 : 0 )           \
	: ( ( ( 0xE2 == NATIVE_TO_LATIN1(((U8*)s)[0]) ) && ( 0x80 == NATIVE_TO_LATIN1(((U8*)s)[1]) ) ) && ( ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0x8E || ( NATIVE_TO_LATIN1(((U8*)s)[2]) & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_PATWS_cp(cp)                                                     \
( ( 0x09 <= NATIVE_TO_UNI(cp) && NATIVE_TO_UNI(cp) <= 0x0D ) || ( 0x0D < NATIVE_TO_UNI(cp) &&\
( 0x20 == NATIVE_TO_UNI(cp) || ( 0x20 < NATIVE_TO_UNI(cp) &&                \
( 0x85 == NATIVE_TO_UNI(cp) || ( 0x85 < NATIVE_TO_UNI(cp) &&                \
( 0x200E == NATIVE_TO_UNI(cp) || ( 0x200E < NATIVE_TO_UNI(cp) &&            \
( 0x200F == NATIVE_TO_UNI(cp) || ( 0x200F < NATIVE_TO_UNI(cp) &&            \
( 0x2028 == NATIVE_TO_UNI(cp) || 0x2029 == NATIVE_TO_UNI(cp) ) ) ) ) ) ) ) ) ) ) )


#endif /* H_REGCHARCLASS */

/* ex: set ro: */
                                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/regcomp.h                                                 0100644 0000000 0000000 00000113144 12744441327 017545  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    regcomp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
#include "regcharclass.h"

/* Convert branch sequences to more efficient trie ops? */
#define PERL_ENABLE_TRIE_OPTIMISATION 1

/* Be really aggressive about optimising patterns with trie sequences? */
#define PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION 1

/* Should the optimiser take positive assertions into account? */
#define PERL_ENABLE_POSITIVE_ASSERTION_STUDY 0

/* Not for production use: */
#define PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS 0

/* Activate offsets code - set to if 1 to enable */
#ifdef DEBUGGING
#define RE_TRACK_PATTERN_OFFSETS
#endif

/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart	sv that must begin a match; NULL if none obvious
 * reganch	is the match anchored (at beginning-of-line only)?
 * regmust	string (pointer into program) that match must include, or NULL
 *  [regmust changed to SV* for bminstr()--law]
 * regmlen	length of regmust string
 *  [regmlen not used currently]
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that pregcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in pregexec() needs it and pregcomp() is computing
 * it anyway.
 * [regmust is now supplied always.  The tests that use regmust have a
 * heuristic that disables the test if it usually matches.]
 *
 * [In fact, we now use regmust in many cases to locate where the search
 * starts in the string, so if regback is >= 0, the regmust search is never
 * wasted effort.  The regback variable says how many characters back from
 * where regmust matched is the earliest possible start of the match.
 * For instance, /[a-z].foo/ has a regmust of 'foo' and a regback of 2.]
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are defined
 * in regnodes.h which is generated from regcomp.sym by regcomp.pl.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 *
 * [The "next" pointer is always aligned on an even
 * boundary, and reads the offset directly as a short.  Also, there is no
 * special test to reverse the sign of BACK pointers since the offset is
 * stored negative.]
 */

/* This is the stuff that used to live in regexp.h that was truly
   private to the engine itself. It now lives here. */



 typedef struct regexp_internal {
        int name_list_idx;	/* Optional data index of an array of paren names */
        union {
	    U32 *offsets;           /* offset annotations 20001228 MJD
                                       data about mapping the program to the
                                       string -
                                       offsets[0] is proglen when this is used
                                       */
            U32 proglen;
        } u;

        regnode *regstclass;    /* Optional startclass as identified or constructed
                                   by the optimiser */
        struct reg_data *data;	/* Additional miscellaneous data used by the program.
                                   Used to make it easier to clone and free arbitrary
                                   data that the regops need. Often the ARG field of
                                   a regop is an index into this structure */
	struct reg_code_block *code_blocks;/* positions of literal (?{}) */
	int num_code_blocks;	/* size of code_blocks[] */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
} regexp_internal;

#define RXi_SET(x,y) (x)->pprivate = (void*)(y)   
#define RXi_GET(x)   ((regexp_internal *)((x)->pprivate))
#define RXi_GET_DECL(r,ri) regexp_internal *ri = RXi_GET(r)
/*
 * Flags stored in regexp->intflags
 * These are used only internally to the regexp engine
 *
 * See regexp.h for flags used externally to the regexp engine
 */
#define RXp_INTFLAGS(rx)        ((rx)->intflags)
#define RX_INTFLAGS(prog)        RXp_INTFLAGS(ReANY(prog))

#define PREGf_SKIP		0x00000001
#define PREGf_IMPLICIT		0x00000002 /* Converted .* to ^.* */
#define PREGf_NAUGHTY		0x00000004 /* how exponential is this pattern? */
#define PREGf_VERBARG_SEEN	0x00000008
#define PREGf_CUTGROUP_SEEN	0x00000010
#define PREGf_USE_RE_EVAL	0x00000020 /* compiled with "use re 'eval'" */
/* these used to be extflags, but are now intflags */
#define PREGf_NOSCAN            0x00000040
#define PREGf_CANY_SEEN         0x00000080
#define PREGf_GPOS_SEEN         0x00000100
#define PREGf_GPOS_FLOAT        0x00000200

#define PREGf_ANCH_BOL          0x00000400
#define PREGf_ANCH_MBOL         0x00000800
#define PREGf_ANCH_SBOL         0x00001000
#define PREGf_ANCH_GPOS         0x00002000

#define PREGf_ANCH              (PREGf_ANCH_SBOL | PREGf_ANCH_GPOS | \
                                 PREGf_ANCH_MBOL | PREGf_ANCH_BOL )

/* this is where the old regcomp.h started */

struct regnode_string {
    U8	str_len;
    U8  type;
    U16 next_off;
    char string[1];
};

/* Argument bearing node - workhorse, 
   arg1 is often for the data field */
struct regnode_1 {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
};

/* Similar to a regnode_1 but with an extra signed argument */
struct regnode_2L {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
    I32 arg2;
};

/* 'Two field' -- Two 16 bit unsigned args */
struct regnode_2 {
    U8	flags;
    U8  type;
    U16 next_off;
    U16 arg1;
    U16 arg2;
};


#define ANYOF_BITMAP_SIZE	(256 / 8)   /* 8 bits/Byte */

/* Note that these form structs which are supersets of the next smaller one, by
 * appending fields.  Alignment problems can occur if one of those optional
 * fields requires stricter alignment than the base struct.  And formal
 * parameters that can really be two or more of the structs should be
 * declared as the smallest one it could be.  See commit message for
 * 7dcac5f6a5195002b55c935ee1d67f67e1df280b.  Regnode allocation is done
 * without regard to alignment, and changing it to would also require changing
 * the code that inserts and deletes regnodes.  The basic single-argument
 * regnode has a U32, which is what reganode() allocates as a unit.  Therefore
 * no field can require stricter alignment than U32. */

/* also used by trie */
struct regnode_charclass {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];	/* only compile-time */
};

/* has runtime (locale) \d, \w, ..., [:posix:] classes */
struct regnode_charclass_class {
    U8	flags;				/* ANYOF_POSIXL bit must go here */
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];		/* both compile-time */
    U32 classflags;	                        /* and run-time */
};

/* A synthetic start class (SSC); is a regnode_charclass_posixl_fold, plus an
 * extra SV*, used only during its construction and which is not used by
 * regexec.c.  Note that the 'next_off' field is unused, as the SSC stands
 * alone, so there is never a next node.  Also, there is no alignment issue,
 * becase these are declared or allocated as a complete unit so the compiler
 * takes care of alignment.  This is unlike the other regnodes which are
 * allocated in terms of multiples of a single-argument regnode.  SSC nodes can
 * have a pointer field because there is no alignment issue, and because it is
 * set to NULL after construction, before any cloning of the pattern */
struct regnode_ssc {
    U8	flags;				/* ANYOF_POSIXL bit must go here */
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];	/* both compile-time */
    U32 classflags;	                /* and run-time */

    /* Auxiliary, only used during construction; NULL afterwards: list of code
     * points matched */
    SV* invlist;
};

/*  We take advantage of 'next_off' not otherwise being used in the SSC by
 *  actually using it: by setting it to 1.  This allows us to test and
 *  distinguish between an SSC and other ANYOF node types, as 'next_off' cannot
 *  otherwise be 1, because it is the offset to the next regnode expressed in
 *  units of regnodes.  Since an ANYOF node contains extra fields, it adds up
 *  to 12 regnode units on 32-bit systems, (hence the minimum this can be (if
 *  not 0) is 11 there.  Even if things get tightly packed on a 64-bit system,
 *  it still would be more than 1. */
#define set_ANYOF_SYNTHETIC(n) STMT_START{ OP(n) = ANYOF;              \
                                           NEXT_OFF(n) = 1;            \
                               } STMT_END
#define is_ANYOF_SYNTHETIC(n) (OP(n) == ANYOF && NEXT_OFF(n) == 1)

/* XXX fix this description.
   Impose a limit of REG_INFTY on various pattern matching operations
   to limit stack growth and to avoid "infinite" recursions.
*/
/* The default size for REG_INFTY is I16_MAX, which is the same as
   SHORT_MAX (see perl.h).  Unfortunately I16 isn't necessarily 16 bits
   (see handy.h).  On the Cray C90, sizeof(short)==4 and hence I16_MAX is
   ((1<<31)-1), while on the Cray T90, sizeof(short)==8 and I16_MAX is
   ((1<<63)-1).  To limit stack growth to reasonable sizes, supply a
   smaller default.
	--Andy Dougherty  11 June 1998
*/
#if SHORTSIZE > 2
#  ifndef REG_INFTY
#    define REG_INFTY ((1<<15)-1)
#  endif
#endif

#ifndef REG_INFTY
#  define REG_INFTY I16_MAX
#endif

#define ARG_VALUE(arg) (arg)
#define ARG__SET(arg,val) ((arg) = (val))

#undef ARG
#undef ARG1
#undef ARG2

#define ARG(p) ARG_VALUE(ARG_LOC(p))
#define ARG1(p) ARG_VALUE(ARG1_LOC(p))
#define ARG2(p) ARG_VALUE(ARG2_LOC(p))
#define ARG2L(p) ARG_VALUE(ARG2L_LOC(p))

#define ARG_SET(p, val) ARG__SET(ARG_LOC(p), (val))
#define ARG1_SET(p, val) ARG__SET(ARG1_LOC(p), (val))
#define ARG2_SET(p, val) ARG__SET(ARG2_LOC(p), (val))
#define ARG2L_SET(p, val) ARG__SET(ARG2L_LOC(p), (val))

#undef NEXT_OFF
#undef NODE_ALIGN

#define NEXT_OFF(p) ((p)->next_off)
#define NODE_ALIGN(node)
#define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */

#define SIZE_ALIGN NODE_ALIGN

#undef OP
#undef OPERAND
#undef MASK
#undef STRING

#define	OP(p)		((p)->type)
#define FLAGS(p)	((p)->flags)	/* Caution: Doesn't apply to all      \
					   regnode types.  For some, it's the \
					   character set of the regnode */
#define	OPERAND(p)	(((struct regnode_string *)p)->string)
#define MASK(p)		((char*)OPERAND(p))
#define	STR_LEN(p)	(((struct regnode_string *)p)->str_len)
#define	STRING(p)	(((struct regnode_string *)p)->string)
#define STR_SZ(l)	((l + sizeof(regnode) - 1) / sizeof(regnode))
#define NODE_SZ_STR(p)	(STR_SZ(STR_LEN(p))+1)

#undef NODE_ALIGN
#undef ARG_LOC
#undef NEXTOPER
#undef PREVOPER

#define	NODE_ALIGN(node)
#define	ARG_LOC(p)	(((struct regnode_1 *)p)->arg1)
#define	ARG1_LOC(p)	(((struct regnode_2 *)p)->arg1)
#define	ARG2_LOC(p)	(((struct regnode_2 *)p)->arg2)
#define ARG2L_LOC(p)	(((struct regnode_2L *)p)->arg2)

#define NODE_STEP_REGNODE	1	/* sizeof(regnode)/sizeof(regnode) */
#define EXTRA_STEP_2ARGS	EXTRA_SIZE(struct regnode_2)

#define NODE_STEP_B	4

#define	NEXTOPER(p)	((p) + NODE_STEP_REGNODE)
#define	PREVOPER(p)	((p) - NODE_STEP_REGNODE)

#define FILL_ADVANCE_NODE(ptr, op) STMT_START { \
    (ptr)->type = op;    (ptr)->next_off = 0;   (ptr)++; } STMT_END
#define FILL_ADVANCE_NODE_ARG(ptr, op, arg) STMT_START { \
    ARG_SET(ptr, arg);  FILL_ADVANCE_NODE(ptr, op); (ptr) += 1; } STMT_END

#define REG_MAGIC 0234

#define SIZE_ONLY (RExC_emit == (regnode *) & RExC_emit_dummy)
#define PASS1 SIZE_ONLY
#define PASS2 (! SIZE_ONLY)

/* If the bitmap doesn't fully represent what this ANYOF node can match, the
 * ARG is set to this special value (since 0, 1, ... are legal, but will never
 * reach this high). */
#define ANYOF_NONBITMAP_EMPTY	((U32) -1)

/* Flags for node->flags of ANYOF.  These are in short supply, with none
 * currently available.  The ABOVE_LATIN1_ALL bit could be freed up
 * by resorting to creating a swash containing everything above 255.  This
 * introduces a performance penalty.  An option that wouldn't slow things down
 * would be to split one of the two LOC flags out into a separate
 * node, like what was done with ANYOF_NON_UTF8_NON_ASCII_ALL in commit
 * 34fdef848b1687b91892ba55e9e0c3430e0770f6 (but which was reverted because it
 * wasn't the best option available at the time), and using a LOC flag is
 * probably better than that commit anyway.  But it could be reinstated if we
 * need a bit.  The LOC flags are only for /l nodes; the reverted commit was
 * only for /d, so there are no combinatorial issues.  The LOC flag to use is
 * probably the POSIXL one.
 * Several flags are not used in synthetic start class (SSC) nodes, so could be
 * shared should new flags be needed for SSCs, like ANYOF_EMPTY_STRING now. */

/* regexec.c is expecting this to be in the low bit */
#define ANYOF_INVERT		 0x01

/* For the SSC node only, which cannot be inverted, so is shared with that bit.
 * This means "Does this SSC match an empty string?"  This is used only during
 * regex compilation. */
#define ANYOF_EMPTY_STRING       ANYOF_INVERT

/* Are there things that will match only if the target string is encoded in
 * UTF-8?  (This is not set if ANYOF_AOVE_LATIN1_ALL is set) */
#define ANYOF_UTF8               0x02

/* The fold is calculated and stored in the bitmap where possible at compile
 * time.  However under locale, the actual folding varies depending on
 * what the locale is at the time of execution, so it has to be deferred until
 * then */
#define ANYOF_LOC_FOLD           0x04

/* Set if this is a regnode_charclass_posixl vs a regnode_charclass.  This
 * is used for runtime \d, \w, [:posix:], ..., which are used only in locale
 * and the optimizer's synthetic start class.  Non-locale \d, etc are resolved
 * at compile-time */
#define ANYOF_POSIXL	         0x08
#define ANYOF_CLASS	         ANYOF_POSIXL
#define ANYOF_LARGE              ANYOF_POSIXL

/* Should we raise a warning if matching against an above-Unicode code point?
 * */
#define ANYOF_WARN_SUPER        0x10

/* Can match something outside the bitmap that isn't in utf8 */
#define ANYOF_NONBITMAP_NON_UTF8 0x20

/* Matches every code point 0x100 and above*/
#define ANYOF_ABOVE_LATIN1_ALL	 0x40
#define ANYOF_UNICODE_ALL	 ANYOF_ABOVE_LATIN1_ALL

/* Match all Latin1 characters that aren't ASCII when the target string is not
 * in utf8. */
#define ANYOF_NON_UTF8_NON_ASCII_ALL 0x80

#define ANYOF_FLAGS_ALL		(0xff)

#define ANYOF_LOCALE_FLAGS (ANYOF_LOC_FOLD | ANYOF_POSIXL)

/* These are the flags that apply to both regular ANYOF nodes and synthetic
 * start class nodes during construction of the SSC.  During finalization of
 * the SSC, other of the flags could be added to it */
#define ANYOF_COMMON_FLAGS    (ANYOF_WARN_SUPER|ANYOF_UTF8)

/* Character classes for node->classflags of ANYOF */
/* Should be synchronized with a table in regprop() */
/* 2n should be the normal one, paired with its complement at 2n+1 */

#define ANYOF_ALPHA    ((_CC_ALPHA) * 2)
#define ANYOF_NALPHA   ((ANYOF_ALPHA) + 1)
#define ANYOF_ALPHANUMERIC   ((_CC_ALPHANUMERIC) * 2)    /* [[:alnum:]] isalnum(3), utf8::IsAlnum */
#define ANYOF_NALPHANUMERIC  ((ANYOF_ALPHANUMERIC) + 1)
#define ANYOF_ASCII    ((_CC_ASCII) * 2)
#define ANYOF_NASCII   ((ANYOF_ASCII) + 1)
#define ANYOF_BLANK    ((_CC_BLANK) * 2)     /* GNU extension: space and tab: non-vertical space */
#define ANYOF_NBLANK   ((ANYOF_BLANK) + 1)
#define ANYOF_CASED    ((_CC_CASED) * 2)    /* Pseudo class for [:lower:] or
                                               [:upper:] under /i */
#define ANYOF_NCASED   ((ANYOF_CASED) + 1)
#define ANYOF_CNTRL    ((_CC_CNTRL) * 2)
#define ANYOF_NCNTRL   ((ANYOF_CNTRL) + 1)
#define ANYOF_DIGIT    ((_CC_DIGIT) * 2)     /* \d */
#define ANYOF_NDIGIT   ((ANYOF_DIGIT) + 1)
#define ANYOF_GRAPH    ((_CC_GRAPH) * 2)
#define ANYOF_NGRAPH   ((ANYOF_GRAPH) + 1)
#define ANYOF_LOWER    ((_CC_LOWER) * 2)
#define ANYOF_NLOWER   ((ANYOF_LOWER) + 1)
#define ANYOF_PRINT    ((_CC_PRINT) * 2)
#define ANYOF_NPRINT   ((ANYOF_PRINT) + 1)
#define ANYOF_PSXSPC   ((_CC_PSXSPC) * 2)    /* POSIX space: \s plus the vertical tab */
#define ANYOF_NPSXSPC  ((ANYOF_PSXSPC) + 1)
#define ANYOF_PUNCT    ((_CC_PUNCT) * 2)
#define ANYOF_NPUNCT   ((ANYOF_PUNCT) + 1)
#define ANYOF_SPACE    ((_CC_SPACE) * 2)     /* \s */
#define ANYOF_NSPACE   ((ANYOF_SPACE) + 1)
#define ANYOF_UPPER    ((_CC_UPPER) * 2)
#define ANYOF_NUPPER   ((ANYOF_UPPER) + 1)
#define ANYOF_WORDCHAR ((_CC_WORDCHAR) * 2)  /* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
#define ANYOF_NWORDCHAR   ((ANYOF_WORDCHAR) + 1)
#define ANYOF_XDIGIT   ((_CC_XDIGIT) * 2)
#define ANYOF_NXDIGIT  ((ANYOF_XDIGIT) + 1)

/* pseudo classes below this, not stored in the class bitmap, but used as flags
   during compilation of char classes */

#define ANYOF_VERTWS    ((_CC_VERTSPACE) * 2)
#define ANYOF_NVERTWS   ((ANYOF_VERTWS)+1)

/* It is best if this is the last one, as all above it are stored as bits in a
 * bitmap, and it isn't part of that bitmap */
#if _CC_VERTSPACE != _HIGHEST_REGCOMP_DOT_H_SYNC
#   error Problem with handy.h _HIGHEST_REGCOMP_DOT_H_SYNC #define
#endif

#define ANYOF_POSIXL_MAX (ANYOF_VERTWS) /* So upper loop limit is written:
                                         *       '< ANYOF_MAX'
                                         * Hence doesn't include VERTWS, as that
                                         * is a pseudo class */
#define ANYOF_MAX      ANYOF_POSIXL_MAX

#if (ANYOF_POSIXL_MAX > 32)   /* Must fit in 32-bit word */
#   error Problem with handy.h _CC_foo #defines
#endif

#define ANYOF_HORIZWS	((ANYOF_POSIXL_MAX)+2) /* = (ANYOF_NVERTWS + 1) */
#define ANYOF_NHORIZWS	((ANYOF_POSIXL_MAX)+3)

#define ANYOF_UNIPROP   ((ANYOF_POSIXL_MAX)+4)  /* Used to indicate a Unicode
                                                   property: \p{} or \P{} */

/* Backward source code compatibility. */

#define ANYOF_ALNUML	 ANYOF_ALNUM
#define ANYOF_NALNUML	 ANYOF_NALNUM
#define ANYOF_SPACEL	 ANYOF_SPACE
#define ANYOF_NSPACEL	 ANYOF_NSPACE
#define ANYOF_ALNUM ANYOF_WORDCHAR
#define ANYOF_NALNUM ANYOF_NWORDCHAR

/* Utility macros for the bitmap and classes of ANYOF */

#define ANYOF_SIZE		(sizeof(struct regnode_charclass))
#define ANYOF_POSIXL_SIZE	(sizeof(regnode_charclass_posixl))
#define ANYOF_CLASS_SIZE	ANYOF_POSIXL_SIZE

#define ANYOF_FLAGS(p)		((p)->flags)

#define ANYOF_BIT(c)		(1 << ((c) & 7))

#define ANYOF_POSIXL_SET(p, c)	(((regnode_charclass_posixl*) (p))->classflags |= (1U << (c)))
#define ANYOF_CLASS_SET(p, c)	ANYOF_POSIXL_SET((p), (c))

#define ANYOF_POSIXL_CLEAR(p, c) (((regnode_charclass_posixl*) (p))->classflags &= ~ (1U <<(c)))
#define ANYOF_CLASS_CLEAR(p, c)	ANYOF_POSIXL_CLEAR((p), (c))

#define ANYOF_POSIXL_TEST(p, c)	(((regnode_charclass_posixl*) (p))->classflags & (1U << (c)))
#define ANYOF_CLASS_TEST(p, c)	ANYOF_POSIXL_TEST((p), (c))

#define ANYOF_POSIXL_ZERO(ret)	STMT_START { ((regnode_charclass_posixl*) (ret))->classflags = 0; } STMT_END
#define ANYOF_CLASS_ZERO(ret)	ANYOF_POSIXL_ZERO(ret)

/* Shifts a bit to get, eg. 0x4000_0000, then subtracts 1 to get 0x3FFF_FFFF */
#define ANYOF_POSIXL_SETALL(ret) STMT_START { ((regnode_charclass_posixl*) (ret))->classflags = ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1; } STMT_END
#define ANYOF_CLASS_SETALL(ret) ANYOF_POSIXL_SETALL(ret)

#define ANYOF_POSIXL_TEST_ANY_SET(p)                               \
        ((ANYOF_FLAGS(p) & ANYOF_POSIXL)                           \
	 && (((regnode_charclass_posixl*)(p))->classflags))
#define ANYOF_CLASS_TEST_ANY_SET(p) ANYOF_POSIXL_TEST_ANY_SET(p)

/* Since an SSC always has this field, we don't have to test for that; nor do
 * we want to because the bit isn't set for SSC during its construction */
#define ANYOF_POSIXL_SSC_TEST_ANY_SET(p)                               \
                            cBOOL(((regnode_ssc*)(p))->classflags)
#define ANYOF_POSIXL_SSC_TEST_ALL_SET(p) /* Are all bits set? */       \
        (((regnode_ssc*) (p))->classflags                              \
                        == ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1)

#define ANYOF_POSIXL_TEST_ALL_SET(p)                                   \
        ((ANYOF_FLAGS(p) & ANYOF_POSIXL)                               \
         && ((regnode_charclass_posixl*) (p))->classflags              \
                        == ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1)

#define ANYOF_POSIXL_OR(source, dest) STMT_START { (dest)->classflags |= (source)->classflags ; } STMT_END
#define ANYOF_CLASS_OR(source, dest) ANYOF_POSIXL_OR((source), (dest))

#define ANYOF_POSIXL_AND(source, dest) STMT_START { (dest)->classflags &= (source)->classflags ; } STMT_END

#define ANYOF_BITMAP_ZERO(ret)	Zero(((struct regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)
#define ANYOF_BITMAP(p)		(((struct regnode_charclass*)(p))->bitmap)
#define ANYOF_BITMAP_BYTE(p, c)	(ANYOF_BITMAP(p)[(((U8)(c)) >> 3) & 31])
#define ANYOF_BITMAP_SET(p, c)	(ANYOF_BITMAP_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_BITMAP_CLEAR(p,c)	(ANYOF_BITMAP_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_BITMAP_TEST(p, c)	(ANYOF_BITMAP_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_BITMAP_SETALL(p)		\
	memset (ANYOF_BITMAP(p), 255, ANYOF_BITMAP_SIZE)
#define ANYOF_BITMAP_CLEARALL(p)	\
	Zero (ANYOF_BITMAP(p), ANYOF_BITMAP_SIZE)
/* Check that all 256 bits are all set.  Used in S_cl_is_anything()  */
#define ANYOF_BITMAP_TESTALLSET(p)	/* Assumes sizeof(p) == 32 */     \
	memEQ (ANYOF_BITMAP(p), "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377", ANYOF_BITMAP_SIZE)

#define ANYOF_SKIP		((ANYOF_SIZE - 1)/sizeof(regnode))
#define ANYOF_POSIXL_SKIP	((ANYOF_POSIXL_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_SKIP	ANYOF_POSIXL_SKIP

/*
 * Utility definitions.
 */
#ifndef CHARMASK
#  define UCHARAT(p)	((int)*(const U8*)(p))
#else
#  define UCHARAT(p)	((int)*(p)&CHARMASK)
#endif

#define EXTRA_SIZE(guy) ((sizeof(guy)-1)/sizeof(struct regnode))

#define REG_ZERO_LEN_SEEN                   0x00000001
#define REG_LOOKBEHIND_SEEN                 0x00000002
#define REG_GPOS_SEEN                       0x00000004
/* spare */
#define REG_CANY_SEEN                       0x00000010
#define REG_RECURSE_SEEN                    0x00000020
#define REG_TOP_LEVEL_BRANCHES_SEEN         0x00000040
#define REG_VERBARG_SEEN                    0x00000080
#define REG_CUTGROUP_SEEN                   0x00000100
#define REG_RUN_ON_COMMENT_SEEN             0x00000200
#define REG_UNFOLDED_MULTI_SEEN             0x00000400
#define REG_GOSTART_SEEN                    0x00000800
#define REG_UNBOUNDED_QUANTIFIER_SEEN       0x00001000


START_EXTERN_C

#ifdef PLUGGABLE_RE_EXTENSION
#include "re_nodes.h"
#else
#include "regnodes.h"
#endif

#ifndef PLUGGABLE_RE_EXTENSION
#ifndef DOINIT
EXTCONST regexp_engine PL_core_reg_engine;
#else /* DOINIT */
EXTCONST regexp_engine PL_core_reg_engine = { 
        Perl_re_compile,
        Perl_regexec_flags,
        Perl_re_intuit_start,
        Perl_re_intuit_string, 
        Perl_regfree_internal,
        Perl_reg_numbered_buff_fetch,
        Perl_reg_numbered_buff_store,
        Perl_reg_numbered_buff_length,
        Perl_reg_named_buff,
        Perl_reg_named_buff_iter,
        Perl_reg_qr_package,
#if defined(USE_ITHREADS)        
        Perl_regdupe_internal,
#endif        
        Perl_re_op_compile
};
#endif /* DOINIT */
#endif /* PLUGGABLE_RE_EXTENSION */


END_EXTERN_C


/* .what is a character array with one character for each member of .data
 * The character describes the function of the corresponding .data item:
 *   a - AV for paren_name_list under DEBUGGING
 *   f - start-class data for regstclass optimization
 *   l - start op for literal (?{EVAL}) item
 *   L - start op for literal (?{EVAL}) item, with separate CV (qr//)
 *   r - pointer to an embedded code-containing qr, e.g. /ab$qr/
 *   s - swash for Unicode-style character class, and the multicharacter
 *       strings resulting from casefolding the single-character entries
 *       in the character class
 *   t - trie struct
 *   u - trie struct's widecharmap (a HV, so can't share, must dup)
 *       also used for revcharmap and words under DEBUGGING
 *   T - aho-trie struct
 *   S - sv for named capture lookup
 * 20010712 mjd@plover.com
 * (Remember to update re_dup() and pregfree() if you add any items.)
 */
struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

/* Code in S_to_utf8_substr() and S_to_byte_substr() in regexec.c accesses
   anchored* and float* via array indexes 0 and 1.  */
#define anchored_substr substrs->data[0].substr
#define anchored_utf8 substrs->data[0].utf8_substr
#define anchored_offset substrs->data[0].min_offset
#define anchored_end_shift substrs->data[0].end_shift

#define float_substr substrs->data[1].substr
#define float_utf8 substrs->data[1].utf8_substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define float_end_shift substrs->data[1].end_shift

#define check_substr substrs->data[2].substr
#define check_utf8 substrs->data[2].utf8_substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset
#define check_end_shift substrs->data[2].end_shift

#define RX_ANCHORED_SUBSTR(rx)	(ReANY(rx)->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	(ReANY(rx)->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	(ReANY(rx)->float_substr)
#define RX_FLOAT_UTF8(rx)	(ReANY(rx)->float_utf8)

/* trie related stuff */

/* a transition record for the state machine. the
   check field determines which state "owns" the
   transition. the char the transition is for is
   determined by offset from the owning states base
   field.  the next field determines which state
   is to be transitioned to if any.
*/
struct _reg_trie_trans {
  U32 next;
  U32 check;
};

/* a transition list element for the list based representation */
struct _reg_trie_trans_list_elem {
    U16 forid;
    U32 newstate;
};
typedef struct _reg_trie_trans_list_elem reg_trie_trans_le;

/* a state for compressed nodes. base is an offset
  into an array of reg_trie_trans array. If wordnum is
  nonzero the state is accepting. if base is zero then
  the state has no children (and will be accepting)
*/
struct _reg_trie_state {
  U16 wordnum;
  union {
    U32                base;
    reg_trie_trans_le* list;
  } trans;
};

/* info per word; indexed by wordnum */
typedef struct {
    U16  prev;	/* previous word in acceptance chain; eg in
		 * zzz|abc|ab/ after matching the chars abc, the
		 * accepted word is #2, and the previous accepted
		 * word is #3 */
    U32 len;	/* how many chars long is this word? */
    U32 accept;	/* accept state for this word */
} reg_trie_wordinfo;


typedef struct _reg_trie_state    reg_trie_state;
typedef struct _reg_trie_trans    reg_trie_trans;


/* anything in here that needs to be freed later
   should be dealt with in pregfree.
   refcount is first in both this and _reg_ac_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_trie_data {
    U32             refcount;        /* number of times this trie is referenced */
    U32             lasttrans;       /* last valid transition element */
    U16             *charmap;        /* byte to charid lookup array */
    reg_trie_state  *states;         /* state data */
    reg_trie_trans  *trans;          /* array of transition elements */
    char            *bitmap;         /* stclass bitmap */
    U16 	    *jump;           /* optional 1 indexed array of offsets before tail 
                                        for the node following a given word. */
    reg_trie_wordinfo *wordinfo;     /* array of info per word */
    U16             uniquecharcount; /* unique chars in trie (width of trans table) */
    U32             startstate;      /* initial state - used for common prefix optimisation */
    STRLEN          minlen;          /* minimum length of words in trie - build/opt only? */
    STRLEN          maxlen;          /* maximum length of words in trie - build/opt only? */
    U32             prefixlen;       /* #chars in common prefix */
    U32             statecount;      /* Build only - number of states in the states array 
                                        (including the unused zero state) */
    U32             wordcount;       /* Build only */
#ifdef DEBUGGING
    STRLEN          charcount;       /* Build only */
#endif
};
/* There is one (3 under DEBUGGING) pointers that logically belong in this
   structure, but are held outside as they need duplication on thread cloning,
   whereas the rest of the structure can be read only:
    HV              *widecharmap;    code points > 255 to charid
#ifdef DEBUGGING
    AV              *words;          Array of words contained in trie, for dumping
    AV              *revcharmap;     Map of each charid back to its character representation
#endif
*/

#define TRIE_WORDS_OFFSET 2

typedef struct _reg_trie_data reg_trie_data;

/* refcount is first in both this and _reg_trie_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_ac_data {
    U32              refcount;
    U32              trie;
    U32              *fail;
    reg_trie_state   *states;
};
typedef struct _reg_ac_data reg_ac_data;

/* ANY_BIT doesn't use the structure, so we can borrow it here.
   This is simpler than refactoring all of it as wed end up with
   three different sets... */

#define TRIE_BITMAP(p)		(((reg_trie_data *)(p))->bitmap)
#define TRIE_BITMAP_BYTE(p, c)	(TRIE_BITMAP(p)[(((U8)(c)) >> 3) & 31])
#define TRIE_BITMAP_SET(p, c)	(TRIE_BITMAP_BYTE(p, c) |=  ANYOF_BIT((U8)c))
#define TRIE_BITMAP_CLEAR(p,c)	(TRIE_BITMAP_BYTE(p, c) &= ~ANYOF_BIT((U8)c))
#define TRIE_BITMAP_TEST(p, c)	(TRIE_BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

#define IS_ANYOF_TRIE(op) ((op)==TRIEC || (op)==AHOCORASICKC)
#define IS_TRIE_AC(op) ((op)>=AHOCORASICK)


#define BITMAP_BYTE(p, c)	(((U8*)p)[(((U8)(c)) >> 3) & 31])
#define BITMAP_TEST(p, c)	(BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

/* these defines assume uniquecharcount is the correct variable, and state may be evaluated twice */
#define TRIE_NODENUM(state) (((state)-1)/(trie->uniquecharcount)+1)
#define SAFE_TRIE_NODENUM(state) ((state) ? (((state)-1)/(trie->uniquecharcount)+1) : (state))
#define TRIE_NODEIDX(state) ((state) ? (((state)-1)*(trie->uniquecharcount)+1) : (state))

#ifdef DEBUGGING
#define TRIE_CHARCOUNT(trie) ((trie)->charcount)
#else
#define TRIE_CHARCOUNT(trie) (trie_charcount)
#endif

#define RE_TRIE_MAXBUF_INIT 65536
#define RE_TRIE_MAXBUF_NAME "\022E_TRIE_MAXBUF"
#define RE_DEBUG_FLAGS "\022E_DEBUG_FLAGS"

/*

RE_DEBUG_FLAGS is used to control what debug output is emitted
its divided into three groups of options, some of which interact.
The three groups are: Compile, Execute, Extra. There is room for a
further group, as currently only the low three bytes are used.

    Compile Options:
    
    PARSE
    PEEP
    TRIE
    PROGRAM
    OFFSETS

    Execute Options:

    INTUIT
    MATCH
    TRIE

    Extra Options

    TRIE
    OFFSETS

If you modify any of these make sure you make corresponding changes to
re.pm, especially to the documentation.

*/


/* Compile */
#define RE_DEBUG_COMPILE_MASK      0x0000FF
#define RE_DEBUG_COMPILE_PARSE     0x000001
#define RE_DEBUG_COMPILE_OPTIMISE  0x000002
#define RE_DEBUG_COMPILE_TRIE      0x000004
#define RE_DEBUG_COMPILE_DUMP      0x000008
#define RE_DEBUG_COMPILE_FLAGS     0x000010

/* Execute */
#define RE_DEBUG_EXECUTE_MASK      0x00FF00
#define RE_DEBUG_EXECUTE_INTUIT    0x000100
#define RE_DEBUG_EXECUTE_MATCH     0x000200
#define RE_DEBUG_EXECUTE_TRIE      0x000400

/* Extra */
#define RE_DEBUG_EXTRA_MASK        0xFF0000
#define RE_DEBUG_EXTRA_TRIE        0x010000
#define RE_DEBUG_EXTRA_OFFSETS     0x020000
#define RE_DEBUG_EXTRA_OFFDEBUG    0x040000
#define RE_DEBUG_EXTRA_STATE       0x080000
#define RE_DEBUG_EXTRA_OPTIMISE    0x100000
#define RE_DEBUG_EXTRA_BUFFERS     0x400000
#define RE_DEBUG_EXTRA_GPOS        0x800000
/* combined */
#define RE_DEBUG_EXTRA_STACK       0x280000

#define RE_DEBUG_FLAG(x) (re_debug_flags & x)
/* Compile */
#define DEBUG_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_MASK) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_OPTIMISE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_OPTIMISE) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_DUMP_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_DUMP) x  )
#define DEBUG_TRIE_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_TRIE) x )
#define DEBUG_FLAGS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_FLAGS) x )
/* Execute */
#define DEBUG_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MASK) x  )
#define DEBUG_INTUIT_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_INTUIT) x  )
#define DEBUG_MATCH_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MATCH) x  )
#define DEBUG_TRIE_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_TRIE) x )

/* Extra */
#define DEBUG_EXTRA_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_MASK) x  )
#define DEBUG_OFFSETS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFSETS) x  )
#define DEBUG_STATE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STATE) x )
#define DEBUG_STACK_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STACK) x )
#define DEBUG_BUFFERS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_BUFFERS) x )

#define DEBUG_OPTIMISE_MORE_r(x) DEBUG_r( \
    if ((RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE) == \
         (re_debug_flags & (RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE)) ) x )
#define MJD_OFFSET_DEBUG(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFDEBUG) \
        Perl_warn_nocontext x )
#define DEBUG_TRIE_COMPILE_MORE_r(x) DEBUG_TRIE_COMPILE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )
#define DEBUG_TRIE_EXECUTE_MORE_r(x) DEBUG_TRIE_EXECUTE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )

#define DEBUG_TRIE_r(x) DEBUG_r( \
    if (re_debug_flags & (RE_DEBUG_COMPILE_TRIE \
        | RE_DEBUG_EXECUTE_TRIE )) x )
#define DEBUG_GPOS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_GPOS) x )

/* initialization */
/* get_sv() can return NULL during global destruction. */
#define GET_RE_DEBUG_FLAGS DEBUG_r({ \
        SV * re_debug_flags_sv = NULL; \
        re_debug_flags_sv = get_sv(RE_DEBUG_FLAGS, 1); \
        if (re_debug_flags_sv) { \
            if (!SvIOK(re_debug_flags_sv)) \
                sv_setuv(re_debug_flags_sv, RE_DEBUG_COMPILE_DUMP | RE_DEBUG_EXECUTE_MASK ); \
            re_debug_flags=SvIV(re_debug_flags_sv); \
        }\
})

#ifdef DEBUGGING

#define GET_RE_DEBUG_FLAGS_DECL VOL IV re_debug_flags  = 0; \
        PERL_UNUSED_VAR(re_debug_flags); GET_RE_DEBUG_FLAGS;

#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2) \
    const char * const rpv =                          \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
    const int rlen = SvCUR(dsv)

#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m) \
    const char * const rpv =                          \
        pv_pretty((dsv), (SvPV_nolen_const(sv)), (SvCUR(sv)), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )

#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)                    \
    const char * const rpv =                                       \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[0], PL_colors[1], \
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_ESCAPE_NONASCII | PERL_PV_PRETTY_ELLIPSES | \
              ((isuni) ? PERL_PV_ESCAPE_UNI : 0))                  \
        )

#define RE_SV_DUMPLEN(ItEm) (SvCUR(ItEm) - (SvTAIL(ItEm)!=0))
#define RE_SV_TAIL(ItEm) (SvTAIL(ItEm) ? "$" : "")
    
#else /* if not DEBUGGING */

#define GET_RE_DEBUG_FLAGS_DECL
#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2)
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)
#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)
#define RE_SV_DUMPLEN(ItEm)
#define RE_SV_TAIL(ItEm)

#endif /* DEBUG RELATED DEFINES */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/regexp.h                                                  0100644 0000000 0000000 00000076605 12744441327 017415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    regexp.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1999, 2000, 2001, 2003,
 *    2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 */
#ifndef PLUGGABLE_RE_EXTENSION
/* we don't want to include this stuff if we are inside of
   an external regex engine based on the core one - like re 'debug'*/

#include "utf8.h"

struct regnode {
    U8	flags;
    U8  type;
    U16 next_off;
};

typedef struct regnode regnode;

struct reg_substr_data;

struct reg_data;

struct regexp_engine;
struct regexp;

struct reg_substr_datum {
    SSize_t min_offset; /* min pos (in chars) that substr must appear */
    SSize_t max_offset  /* max pos (in chars) that substr must appear */;
    SV *substr;		/* non-utf8 variant */
    SV *utf8_substr;	/* utf8 variant */
    SSize_t end_shift;  /* how many fixed chars must end the string */
};
struct reg_substr_data {
    U8      check_ix;   /* index into data[] of check substr */
    struct reg_substr_datum data[3];	/* Actual array */
};

#ifdef PERL_ANY_COW
#define SV_SAVED_COPY   SV *saved_copy; /* If non-NULL, SV which is COW from original */
#else
#define SV_SAVED_COPY
#endif

/* offsets within a string of a particular /(.)/ capture */

typedef struct regexp_paren_pair {
    SSize_t start;
    SSize_t end;
    /* 'start_tmp' records a new opening position before the matching end
     * has been found, so that the old start and end values are still
     * valid, e.g.
     *	  "abc" =~ /(.(?{print "[$1]"}))+/
     *outputs [][a][b]
     * This field is not part of the API.  */
    SSize_t start_tmp;
} regexp_paren_pair;

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)
#define _invlist_union(a, b, output) _invlist_union_maybe_complement_2nd(a, b, FALSE, output)
#define _invlist_intersection(a, b, output) _invlist_intersection_maybe_complement_2nd(a, b, FALSE, output)

/* Subtracting b from a leaves in a everything that was there that isn't in b,
 * that is the intersection of a with b's complement */
#define _invlist_subtract(a, b, output) _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)
#endif

/* record the position of a (?{...}) within a pattern */

struct reg_code_block {
    STRLEN start;
    STRLEN end;
    OP     *block;
    REGEXP *src_regex;
};


/*
  The regexp/REGEXP struct, see L<perlreapi> for further documentation
  on the individual fields. The struct is ordered so that the most
  commonly used fields are placed at the start.

  Any patch that adds items to this struct will need to include
  changes to F<sv.c> (C<Perl_re_dup()>) and F<regcomp.c>
  (C<pregfree()>). This involves freeing or cloning items in the
  regexp's data array based on the data item's type.
*/

#define _REGEXP_COMMON							\
        /* what engine created this regexp? */				\
	const struct regexp_engine* engine; 				\
	REGEXP *mother_re; /* what re is this a lightweight copy of? */	\
	HV *paren_names;   /* Optional hash of paren names */		\
	/* Information about the match that the perl core uses to */	\
	/* manage things */						\
	U32 extflags;	/* Flags used both externally and internally */	\
	SSize_t minlen;	/* mininum possible number of chars in string to match */\
	SSize_t minlenret; /* mininum possible number of chars in $& */		\
	STRLEN gofs;	/* chars left of pos that we search from */	\
	/* substring data about strings that must appear in the */	\
	/* final match, used for optimisations */			\
	struct reg_substr_data *substrs;				\
	U32 nparens;	/* number of capture buffers */			\
	/* private engine specific data */				\
	U32 intflags;	/* Engine Specific Internal flags */		\
	void *pprivate;	/* Data private to the regex engine which */	\
			/* created this object. */			\
	/* Data about the last/current match. These are modified */	\
	/* during matching */						\
	U32 lastparen;			/* last open paren matched */	\
	U32 lastcloseparen;		/* last close paren matched */	\
	/* Array of offsets for (@-) and (@+) */			\
	regexp_paren_pair *offs;					\
	/* saved or original string so \digit works forever. */		\
	char *subbeg;							\
	SV_SAVED_COPY	/* If non-NULL, SV which is COW from original */\
	SSize_t sublen;	/* Length of string pointed by subbeg */	\
	SSize_t suboffset; /* byte offset of subbeg from logical start of str */ \
	SSize_t subcoffset; /* suboffset equiv, but in chars (for @-/@+) */ \
	/* Information about the match that isn't often used */		\
        SSize_t maxlen;        /* mininum possible number of chars in string to match */\
	/* offset from wrapped to the start of precomp */		\
	PERL_BITFIELD32 pre_prefix:4;					\
        /* original flags used to compile the pattern, may differ */    \
        /* from extflags in various ways */                             \
        PERL_BITFIELD32 compflags:9;                                    \
	CV *qr_anoncv	/* the anon sub wrapped round qr/(?{..})/ */

typedef struct regexp {
	_XPV_HEAD;
	_REGEXP_COMMON;
} regexp;

#define RXp_PAREN_NAMES(rx)	((rx)->paren_names)

/* used for high speed searches */
typedef struct re_scream_pos_data_s
{
    char **scream_olds;		/* match pos */
    SSize_t *scream_pos;	/* Internal iterator of scream. */
} re_scream_pos_data;

/* regexp_engine structure. This is the dispatch table for regexes.
 * Any regex engine implementation must be able to build one of these.
 */
typedef struct regexp_engine {
    REGEXP* (*comp) (pTHX_ SV * const pattern, U32 flags);
    I32     (*exec) (pTHX_ REGEXP * const rx, char* stringarg, char* strend,
                     char* strbeg, SSize_t minend, SV* sv,
                     void* data, U32 flags);
    char*   (*intuit) (pTHX_
                        REGEXP * const rx,
                        SV *sv,
                        const char * const strbeg,
                        char *strpos,
                        char *strend,
                        const U32 flags,
                       re_scream_pos_data *data);
    SV*     (*checkstr) (pTHX_ REGEXP * const rx);
    void    (*free) (pTHX_ REGEXP * const rx);
    void    (*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32 paren,
                                    SV * const sv);
    void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,
                                   SV const * const value);
    I32     (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const SV * const sv,
                                    const I32 paren);
    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, const U32 flags);
    SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,
                                const U32 flags);
    SV*     (*qr_package)(pTHX_ REGEXP * const rx);
#ifdef USE_ITHREADS
    void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
#endif
    REGEXP* (*op_comp) (pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const struct regexp_engine* eng,
		    REGEXP *VOL old_re,
		    bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags);
} regexp_engine;

/*
  These are passed to the numbered capture variable callbacks as the
  paren name. >= 1 is reserved for actual numbered captures, i.e. $1,
  $2 etc.
*/
#define RX_BUFF_IDX_CARET_PREMATCH  -5 /* ${^PREMATCH}  */
#define RX_BUFF_IDX_CARET_POSTMATCH -4 /* ${^POSTMATCH} */
#define RX_BUFF_IDX_CARET_FULLMATCH -3 /* ${^MATCH}     */
#define RX_BUFF_IDX_PREMATCH        -2 /* $` */
#define RX_BUFF_IDX_POSTMATCH       -1 /* $' */
#define RX_BUFF_IDX_FULLMATCH        0 /* $& */

/*
  Flags that are passed to the named_buff and named_buff_iter
  callbacks above. Those routines are called from universal.c via the
  Tie::Hash::NamedCapture interface for %+ and %- and the re::
  functions in the same file.
*/

/* The Tie::Hash::NamedCapture operation this is part of, if any */
#define RXapif_FETCH     0x0001
#define RXapif_STORE     0x0002
#define RXapif_DELETE    0x0004
#define RXapif_CLEAR     0x0008
#define RXapif_EXISTS    0x0010
#define RXapif_SCALAR    0x0020
#define RXapif_FIRSTKEY  0x0040
#define RXapif_NEXTKEY   0x0080

/* Whether %+ or %- is being operated on */
#define RXapif_ONE       0x0100 /* %+ */
#define RXapif_ALL       0x0200 /* %- */

/* Whether this is being called from a re:: function */
#define RXapif_REGNAME         0x0400
#define RXapif_REGNAMES        0x0800
#define RXapif_REGNAMES_COUNT  0x1000

/*
=head1 REGEXP Functions

=for apidoc Am|REGEXP *|SvRX|SV *sv

Convenience macro to get the REGEXP from a SV.  This is approximately
equivalent to the following snippet:

    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv))
        sv = MUTABLE_SV(SvRV(sv));
    if (SvTYPE(sv) == SVt_REGEXP)
        return (REGEXP*) sv;

NULL will be returned if a REGEXP* is not found.

=for apidoc Am|bool|SvRXOK|SV* sv

Returns a boolean indicating whether the SV (or the one it references)
is a REGEXP.

If you want to do something with the REGEXP* later use SvRX instead
and check for NULL.

=cut
*/

#define SvRX(sv)   (Perl_get_re_arg(aTHX_ sv))
#define SvRXOK(sv) (Perl_get_re_arg(aTHX_ sv) ? TRUE : FALSE)


/* Flags stored in regexp->extflags
 * These are used by code external to the regexp engine
 *
 * Note that the flags whose names start with RXf_PMf_ are defined in
 * op_reg_common.h, being copied from the parallel flags of op_pmflags
 *
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
 *
 */

#include "op_reg_common.h"

#define RXf_PMf_STD_PMMOD	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED)

#define CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl)                        \
    case IGNORE_PAT_MOD:    *(pmfl) |= RXf_PMf_FOLD;       break;   \
    case MULTILINE_PAT_MOD: *(pmfl) |= RXf_PMf_MULTILINE;  break;   \
    case SINGLE_PAT_MOD:    *(pmfl) |= RXf_PMf_SINGLELINE; break;   \
    case XTENDED_PAT_MOD:   *(pmfl) |= RXf_PMf_EXTENDED;   break

/* Note, includes charset ones, assumes 0 is the default for them */
#define STD_PMMOD_FLAGS_CLEAR(pmfl)                        \
    *(pmfl) &= ~(RXf_PMf_FOLD|RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_EXTENDED|RXf_PMf_CHARSET)

/* chars and strings used as regex pattern modifiers
 * Singular is a 'c'har, plural is a "string"
 *
 * NOTE, KEEPCOPY was originally 'k', but was changed to 'p' for preserve
 * for compatibility reasons with Regexp::Common which highjacked (?k:...)
 * for its own uses. So 'k' is out as well.
 */
#define DEFAULT_PAT_MOD      '^'    /* Short for all the default modifiers */
#define EXEC_PAT_MOD         'e'
#define KEEPCOPY_PAT_MOD     'p'
#define ONCE_PAT_MOD         'o'
#define GLOBAL_PAT_MOD       'g'
#define CONTINUE_PAT_MOD     'c'
#define MULTILINE_PAT_MOD    'm'
#define SINGLE_PAT_MOD       's'
#define IGNORE_PAT_MOD       'i'
#define XTENDED_PAT_MOD      'x'
#define NONDESTRUCT_PAT_MOD  'r'
#define LOCALE_PAT_MOD       'l'
#define UNICODE_PAT_MOD      'u'
#define DEPENDS_PAT_MOD      'd'
#define ASCII_RESTRICT_PAT_MOD 'a'

#define ONCE_PAT_MODS        "o"
#define KEEPCOPY_PAT_MODS    "p"
#define EXEC_PAT_MODS        "e"
#define LOOP_PAT_MODS        "gc"
#define NONDESTRUCT_PAT_MODS "r"
#define LOCALE_PAT_MODS      "l"
#define UNICODE_PAT_MODS     "u"
#define DEPENDS_PAT_MODS     "d"
#define ASCII_RESTRICT_PAT_MODS "a"
#define ASCII_MORE_RESTRICT_PAT_MODS "aa"

/* This string is expected by regcomp.c to be ordered so that the first
 * character is the flag in bit RXf_PMf_STD_PMMOD_SHIFT of extflags; the next
 * character is bit +1, etc. */
#define STD_PAT_MODS        "msix"

#define CHARSET_PAT_MODS    ASCII_RESTRICT_PAT_MODS DEPENDS_PAT_MODS LOCALE_PAT_MODS UNICODE_PAT_MODS

/* This string is expected by XS_re_regexp_pattern() in universal.c to be ordered
 * so that the first character is the flag in bit RXf_PMf_STD_PMMOD_SHIFT of
 * extflags; the next character is in bit +1, etc. */
#define INT_PAT_MODS    STD_PAT_MODS    KEEPCOPY_PAT_MODS

#define EXT_PAT_MODS    ONCE_PAT_MODS   KEEPCOPY_PAT_MODS
#define QR_PAT_MODS     STD_PAT_MODS    EXT_PAT_MODS	   CHARSET_PAT_MODS
#define M_PAT_MODS      QR_PAT_MODS     LOOP_PAT_MODS
#define S_PAT_MODS      M_PAT_MODS      EXEC_PAT_MODS      NONDESTRUCT_PAT_MODS

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
 *
 */

/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT)

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_SPLIT                (1<<(RXf_BASE_SHIFT-1))
#if RXf_SPLIT != RXf_PMf_SPLIT
#   error "RXf_SPLIT does not match RXf_PMf_SPLIT"
#endif

/* Manually decorate this function with gcc-style attributes just to
 * avoid having to restructure the header files and their called order,
 * as proto.h would have to be included before this file, and isn't */

PERL_STATIC_INLINE const char *
get_regex_charset_name(const U32 flags, STRLEN* const lenp)
    __attribute__warn_unused_result__;

#define MAX_CHARSET_NAME_LENGTH 2

PERL_STATIC_INLINE const char *
get_regex_charset_name(const U32 flags, STRLEN* const lenp)
{
    /* Returns a string that corresponds to the name of the regex character set
     * given by 'flags', and *lenp is set the length of that string, which
     * cannot exceed MAX_CHARSET_NAME_LENGTH characters */

    *lenp = 1;
    switch (get_regex_charset(flags)) {
        case REGEX_DEPENDS_CHARSET: return DEPENDS_PAT_MODS;
        case REGEX_LOCALE_CHARSET:  return LOCALE_PAT_MODS;
        case REGEX_UNICODE_CHARSET: return UNICODE_PAT_MODS;
	case REGEX_ASCII_RESTRICTED_CHARSET: return ASCII_RESTRICT_PAT_MODS;
	case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
	    *lenp = 2;
	    return ASCII_MORE_RESTRICT_PAT_MODS;
        default:
	    return "?";	    /* Unknown */
    }
}

/* Do we have some sort of anchor? */
#define RXf_IS_ANCHORED         (1<<(RXf_BASE_SHIFT+0))
#define RXf_UNUSED1             (1<<(RXf_BASE_SHIFT+1))
#define RXf_UNUSED2             (1<<(RXf_BASE_SHIFT+2))
#define RXf_UNUSED3             (1<<(RXf_BASE_SHIFT+3))
#define RXf_UNUSED4             (1<<(RXf_BASE_SHIFT+4))
#define RXf_UNUSED5             (1<<(RXf_BASE_SHIFT+5))

/* What we have seen */
#define RXf_NO_INPLACE_SUBST    (1<<(RXf_BASE_SHIFT+6))
#define RXf_EVAL_SEEN   	(1<<(RXf_BASE_SHIFT+7))
#define RXf_UNUSED8             (1<<(RXf_BASE_SHIFT+8))

/* Special */
#define RXf_UNBOUNDED_QUANTIFIER_SEEN   (1<<(RXf_BASE_SHIFT+9))
#define RXf_CHECK_ALL   	(1<<(RXf_BASE_SHIFT+10))

/* UTF8 related */
#define RXf_MATCH_UTF8  	(1<<(RXf_BASE_SHIFT+11)) /* $1 etc are utf8 */

/* Intuit related */
#define RXf_USE_INTUIT_NOML	(1<<(RXf_BASE_SHIFT+12))
#define RXf_USE_INTUIT_ML	(1<<(RXf_BASE_SHIFT+13))
#define RXf_INTUIT_TAIL 	(1<<(RXf_BASE_SHIFT+14))
#define RXf_USE_INTUIT		(RXf_USE_INTUIT_NOML|RXf_USE_INTUIT_ML)

/* Copy and tainted info */
#define RXf_COPY_DONE   	(1<<(RXf_BASE_SHIFT+16))

/* post-execution: $1 et al are tainted */
#define RXf_TAINTED_SEEN	(1<<(RXf_BASE_SHIFT+17))
/* this pattern was tainted during compilation */
#define RXf_TAINTED		(1<<(RXf_BASE_SHIFT+18))

/* Flags indicating special patterns */
#define RXf_START_ONLY		(1<<(RXf_BASE_SHIFT+19)) /* Pattern is /^/ */
#define RXf_SKIPWHITE                (1<<(RXf_BASE_SHIFT+20)) /* Pattern is for a split " " */
#define RXf_WHITE		(1<<(RXf_BASE_SHIFT+21)) /* Pattern is /\s+/ */
#define RXf_NULL		(1U<<(RXf_BASE_SHIFT+22)) /* Pattern is // */
#if RXf_BASE_SHIFT+22 > 31
#   error Too many RXf_PMf bits used.  See regnodes.h for any spare in middle
#endif

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
 *
 */

#ifdef NO_TAINT_SUPPORT
#   define RX_ISTAINTED(prog)    0
#   define RX_TAINT_on(prog)     NOOP
#   define RXp_MATCH_TAINTED(prog) 0
#   define RX_MATCH_TAINTED(prog)  0
#   define RXp_MATCH_TAINTED_on(prog) NOOP
#   define RX_MATCH_TAINTED_on(prog)  NOOP
#   define RX_MATCH_TAINTED_off(prog) NOOP
#else
#   define RX_ISTAINTED(prog)    (RX_EXTFLAGS(prog) & RXf_TAINTED)
#   define RX_TAINT_on(prog)     (RX_EXTFLAGS(prog) |= RXf_TAINTED)
#   define RXp_MATCH_TAINTED(prog)    (RXp_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED(prog)     (RX_EXTFLAGS(prog)  & RXf_TAINTED_SEEN)
#   define RXp_MATCH_TAINTED_on(prog) (RXp_EXTFLAGS(prog) |= RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED_on(prog)  (RX_EXTFLAGS(prog)  |= RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED_off(prog) (RX_EXTFLAGS(prog)  &= ~RXf_TAINTED_SEEN)
#endif

#define RX_HAS_CUTGROUP(prog) ((prog)->intflags & PREGf_CUTGROUP_SEEN)
#define RX_MATCH_TAINTED_set(prog, t) ((t) \
				       ? RX_MATCH_TAINTED_on(prog) \
				       : RX_MATCH_TAINTED_off(prog))

#define RXp_MATCH_COPIED(prog)		(RXp_EXTFLAGS(prog) & RXf_COPY_DONE)
#define RX_MATCH_COPIED(prog)		(RX_EXTFLAGS(prog) & RXf_COPY_DONE)
#define RXp_MATCH_COPIED_on(prog)	(RXp_EXTFLAGS(prog) |= RXf_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	(RX_EXTFLAGS(prog) |= RXf_COPY_DONE)
#define RXp_MATCH_COPIED_off(prog)	(RXp_EXTFLAGS(prog) &= ~RXf_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	(RX_EXTFLAGS(prog) &= ~RXf_COPY_DONE)
#define RX_MATCH_COPIED_set(prog,t)	((t) \
					 ? RX_MATCH_COPIED_on(prog) \
					 : RX_MATCH_COPIED_off(prog))

#define RXp_EXTFLAGS(rx)	((rx)->extflags)
#define RXp_COMPFLAGS(rx)        ((rx)->compflags)

/* For source compatibility. We used to store these explicitly.  */
#define RX_PRECOMP(prog)	(RX_WRAPPED(prog) + ReANY(prog)->pre_prefix)
#define RX_PRECOMP_const(prog)	(RX_WRAPPED_const(prog) + ReANY(prog)->pre_prefix)
/* FIXME? Are we hardcoding too much here and constraining plugin extension
   writers? Specifically, the value 1 assumes that the wrapped version always
   has exactly one character at the end, a ')'. Will that always be true?  */
#define RX_PRELEN(prog)		(RX_WRAPLEN(prog) - ReANY(prog)->pre_prefix - 1)
#define RX_WRAPPED(prog)	ReANY(prog)->xpv_len_u.xpvlenu_pv
#define RX_WRAPPED_const(prog)	((const char *)RX_WRAPPED(prog))
#define RX_WRAPLEN(prog)	SvCUR(prog)
#define RX_CHECK_SUBSTR(prog)	(ReANY(prog)->check_substr)
#define RX_REFCNT(prog)		SvREFCNT(prog)
#define RX_EXTFLAGS(prog)	RXp_EXTFLAGS(ReANY(prog))
#define RX_COMPFLAGS(prog)        RXp_COMPFLAGS(ReANY(prog))
#define RX_ENGINE(prog)		(ReANY(prog)->engine)
#define RX_SUBBEG(prog)		(ReANY(prog)->subbeg)
#define RX_SUBOFFSET(prog)	(ReANY(prog)->suboffset)
#define RX_SUBCOFFSET(prog)	(ReANY(prog)->subcoffset)
#define RX_OFFS(prog)		(ReANY(prog)->offs)
#define RX_NPARENS(prog)	(ReANY(prog)->nparens)
#define RX_SUBLEN(prog)		(ReANY(prog)->sublen)
#define RX_MINLEN(prog)		(ReANY(prog)->minlen)
#define RX_MINLENRET(prog)	(ReANY(prog)->minlenret)
#define RX_GOFS(prog)		(ReANY(prog)->gofs)
#define RX_LASTPAREN(prog)	(ReANY(prog)->lastparen)
#define RX_LASTCLOSEPAREN(prog)	(ReANY(prog)->lastcloseparen)
#define RX_SAVED_COPY(prog)	(ReANY(prog)->saved_copy)
/* last match was zero-length */
#define RX_ZERO_LEN(prog) \
        (RX_OFFS(prog)[0].start + (SSize_t)RX_GOFS(prog) \
          == RX_OFFS(prog)[0].end)

#endif /* PLUGGABLE_RE_EXTENSION */

/* Stuff that needs to be included in the pluggable extension goes below here */

#ifdef PERL_ANY_COW
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (RX_SAVED_COPY(rx)) { \
	    SV_CHECK_THINKFIRST_COW_DROP(RX_SAVED_COPY(rx)); \
	} \
	if (RX_MATCH_COPIED(rx)) { \
	    Safefree(RX_SUBBEG(rx)); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#else
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (RX_MATCH_COPIED(rx)) { \
	    Safefree(RX_SUBBEG(rx)); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#endif

#define RXp_MATCH_UTF8(prog)		(RXp_EXTFLAGS(prog) & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8(prog)		(RX_EXTFLAGS(prog) & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		(RX_EXTFLAGS(prog) |= RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		(RX_EXTFLAGS(prog) &= ~RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_set(prog, t)	((t) \
			? RX_MATCH_UTF8_on(prog) \
			: RX_MATCH_UTF8_off(prog))

/* Whether the pattern stored at RX_WRAPPED is in UTF-8  */
#define RX_UTF8(prog)			SvUTF8(prog)


/* bits in flags arg of Perl_regexec_flags() */

#define REXEC_COPY_STR  0x01    /* Need to copy the string for captures. */
#define REXEC_CHECKED   0x02    /* re_intuit_start() already called. */
#define REXEC_SCREAM    0x04    /* currently unused. */
#define REXEC_IGNOREPOS 0x08    /* use stringarg, not pos(), for \G match */
#define REXEC_NOT_FIRST 0x10    /* This is another iteration of //g:
                                   no need to copy string again */

                                     /* under REXEC_COPY_STR, it's ok for the
                                        engine (modulo PL_sawamperand etc)
                                        to skip copying: ... */
#define REXEC_COPY_SKIP_PRE  0x20    /* ...the $` part of the string, or */
#define REXEC_COPY_SKIP_POST 0x40    /* ...the $' part of the string */
#define REXEC_FAIL_ON_UNDERFLOW 0x80 /* fail the match if $& would start before
                                        the start pos (so s/.\G// would fail
                                        on second iteration */

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define ReREFCNT_inc(re)						\
    ({									\
	/* This is here to generate a casting warning if incorrect.  */	\
	REGEXP *const _rerefcnt_inc = (re);				\
	assert(SvTYPE(_rerefcnt_inc) == SVt_REGEXP);			\
	SvREFCNT_inc(_rerefcnt_inc);					\
	_rerefcnt_inc;							\
    })
#  define ReREFCNT_dec(re)						\
    ({									\
	/* This is here to generate a casting warning if incorrect.  */	\
	REGEXP *const _rerefcnt_dec = (re);				\
	SvREFCNT_dec(_rerefcnt_dec);					\
    })
#else
#  define ReREFCNT_dec(re)	SvREFCNT_dec(re)
#  define ReREFCNT_inc(re)	((REGEXP *) SvREFCNT_inc(re))
#endif
#define ReANY(re)		S_ReANY((const REGEXP *)(re))

/* FIXME for plugins. */

#define FBMcf_TAIL_DOLLAR	1
#define FBMcf_TAIL_DOLLARM	2
#define FBMcf_TAIL_Z		4
#define FBMcf_TAIL_z		8
#define FBMcf_TAIL		(FBMcf_TAIL_DOLLAR|FBMcf_TAIL_DOLLARM|FBMcf_TAIL_Z|FBMcf_TAIL_z)

#define FBMrf_MULTILINE	1

struct regmatch_state;
struct regmatch_slab;

/* like regmatch_info_aux, but contains extra fields only needed if the
 * pattern contains (?{}). If used, is snuck into the second slot in the
 * regmatch_state stack at the start of execution */

typedef struct {
    regexp *rex;
    PMOP    *curpm;     /* saved PL_curpm */
#ifdef PERL_ANY_COW
    SV      *saved_copy; /* saved saved_copy field from rex */
#endif
    char    *subbeg;    /* saved subbeg     field from rex */
    STRLEN  sublen;     /* saved sublen     field from rex */
    STRLEN  suboffset;  /* saved suboffset  field from rex */
    STRLEN  subcoffset; /* saved subcoffset field from rex */
    MAGIC   *pos_magic; /* pos() magic attached to $_ */
    SSize_t pos;        /* the original value of pos() in pos_magic */
    U8      pos_flags;  /* flags to be restored; currently only MGf_BYTES*/
} regmatch_info_aux_eval;


/* fields that logically  live in regmatch_info, but which need cleaning
 * up on croak(), and so are instead are snuck into the first slot in
 * the regmatch_state stack at the start of execution */

typedef struct {
    regmatch_info_aux_eval *info_aux_eval;
    struct regmatch_state *old_regmatch_state; /* saved PL_regmatch_state */
    struct regmatch_slab  *old_regmatch_slab;  /* saved PL_regmatch_slab */
    char *poscache;	/* S-L cache of fail positions of WHILEMs */
} regmatch_info_aux;


/* some basic information about the current match that is created by
 * Perl_regexec_flags and then passed to regtry(), regmatch() etc.
 * It is allocated as a local var on the stack, so nothing should be
 * stored in it that needs preserving or clearing up on croak().
 * For that, see the aux_info and aux_info_eval members of the
 * regmatch_state union. */

typedef struct {
    REGEXP *prog;        /* the regex being executed */
    const char * strbeg; /* real start of string */
    char *strend;        /* one byte beyond last char of match string */
    char *till;          /* matches shorter than this fail (see minlen arg) */
    SV *sv;              /* the SV string currently being matched */
    char *ganch;         /* position of \G anchor */
    char *cutpoint;      /* (*COMMIT) position (if any) */
    regmatch_info_aux      *info_aux; /* extra fields that need cleanup */
    regmatch_info_aux_eval *info_aux_eval; /* extra saved state for (?{}) */
    I32  poscache_maxiter; /* how many whilems todo before S-L cache kicks in */
    I32  poscache_iter;    /* current countdown from _maxiter to zero */
    STRLEN poscache_size;  /* size of regmatch_info_aux.poscache */
    bool intuit;    /* re_intuit_start() is the top-level caller */
    bool is_utf8_pat;    /* regex is utf8 */
    bool is_utf8_target; /* string being matched is utf8 */
    bool warned; /* we have issued a recursion warning; no need for more */
} regmatch_info;
 

/* structures for holding and saving the state maintained by regmatch() */

#ifndef MAX_RECURSE_EVAL_NOCHANGE_DEPTH
#define MAX_RECURSE_EVAL_NOCHANGE_DEPTH 1000
#endif

typedef I32 CHECKPOINT;

typedef struct regmatch_state {
    int resume_state;		/* where to jump to on return */
    char *locinput;		/* where to backtrack in string on failure */

    union {

        /* the 'info_aux' and 'info_aux_eval' union members are cuckoos in
         * the nest. They aren't saved backtrack state; rather they
         * represent one or two extra chunks of data that need allocating
         * at the start of a match. These fields would logically live in
         * the regmatch_info struct, except that is allocated on the
         * C stack, and these fields are all things that require cleanup
         * after a croak(), when the stack is lost.
         * As a convenience, we just use the first 1 or 2 regmatch_state
         * slots to store this info, as we will be allocating a slab of
         * these anyway. Otherwise we'd have to malloc and then free them,
         * or allocate them on the save stack (where they will get
         * realloced if the save stack grows).
         * info_aux contains the extra fields that are always needed;
         * info_aux_eval contains extra fields that only needed if
         * the pattern contains code blocks
         * We split them into two separate structs to avoid increasing
         * the size of the union.
         */

        regmatch_info_aux info_aux;

        regmatch_info_aux_eval info_aux_eval;

	/* this is a fake union member that matches the first element
	 * of each member that needs to store positive backtrack
	 * information */
	struct {
	    struct regmatch_state *prev_yes_state;
	} yes;

        /* branchlike members */
        /* this is a fake union member that matches the first elements
         * of each member that needs to behave like a branch */
        struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    U32 lastcloseparen;
	    CHECKPOINT cp;
	    
        } branchlike;
        	    
	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    U32 lastcloseparen;
	    CHECKPOINT cp;
	    
	    regnode *next_branch; /* next branch node */
	} branch;

	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    U32 lastcloseparen;
	    CHECKPOINT cp;

	    U32		accepted; /* how many accepting states left */
	    bool	longfold;/* saw a fold with a 1->n char mapping */
	    U16         *jump;  /* positive offsets from me */
	    regnode	*me;	/* Which node am I - needed for jump tries*/
	    U8		*firstpos;/* pos in string of first trie match */
	    U32		firstchars;/* len in chars of firstpos from start */
	    U16		nextword;/* next word to try */
	    U16		topword; /* longest accepted word */
	} trie;

        /* special types - these members are used to store state for special
           regops like eval, if/then, lookaround and the markpoint state */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_eval;
	    struct regmatch_state *prev_curlyx;
	    REGEXP	*prev_rex;
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    U32        close_paren; /* which close bracket is our end */
	    regnode	*B;	/* the node following us  */
	} eval;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    I32 wanted;
	    I32 logical;	/* saved copy of 'logical' var */
	    regnode  *me; /* the IFMATCH/SUSPEND/UNLESSM node  */
	} ifmatch; /* and SUSPEND/UNLESSM */
	
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_mark;
	    SV* mark_name;
	    char *mark_loc;
	} mark;
	
	struct {
	    int val;
	} keeper;

        /* quantifiers - these members are used for storing state for
           for the regops used to implement quantifiers */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_curlyx; /* previous cur_curlyx */
	    regnode	*me;	/* the CURLYX node  */
	    regnode	*B;	/* the B node in /A*B/  */
	    CHECKPOINT	cp;	/* remember current savestack index */
	    bool	minmod;
	    int		parenfloor;/* how far back to strip paren data */

	    /* these two are modified by WHILEM */
	    int		count;	/* how many instances of A we've matched */
	    char	*lastloc;/* where previous A matched (0-len detect) */
	} curlyx;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *save_curlyx;
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    char	*save_lastloc;	/* previous curlyx.lastloc */
	    I32		cache_offset;
	    I32		cache_mask;
	} whilem;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    int c1, c2;		/* case fold search */
	    CHECKPOINT cp;
	    U32 lastparen;
	    U32 lastcloseparen;
	    I32 alen;		/* length of first-matched A string */
	    I32 count;
	    bool minmod;
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
	    regnode *me;	/* the curlym node */
            U8 c1_utf8[UTF8_MAXBYTES+1];  /* */
            U8 c2_utf8[UTF8_MAXBYTES+1];
	} curlym;

	struct {
	    U32 paren;
	    CHECKPOINT cp;
	    U32 lastparen;
	    U32 lastcloseparen;
	    int c1, c2;		/* case fold search */
	    char *maxpos;	/* highest possible point in string to match */
	    char *oldloc;	/* the previous locinput */
	    int count;
	    int min, max;	/* {m,n} */
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
            U8 c1_utf8[UTF8_MAXBYTES+1];  /* */
            U8 c2_utf8[UTF8_MAXBYTES+1];
	} curly; /* and CURLYN/PLUS/STAR */

    } u;
} regmatch_state;

/* how many regmatch_state structs to allocate as a single slab.
 * We do it in 4K blocks for efficiency. The "3" is 2 for the next/prev
 * pointers, plus 1 for any mythical malloc overhead. */
 
#define PERL_REGMATCH_SLAB_SLOTS \
    ((4096 - 3 * sizeof (void*)) / sizeof(regmatch_state))

typedef struct regmatch_slab {
    regmatch_state states[PERL_REGMATCH_SLAB_SLOTS];
    struct regmatch_slab *prev, *next;
} regmatch_slab;



/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                           usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/regnodes.h                                                0100644 0000000 0000000 00000105044 12744441327 017717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/regcomp.pl from regcomp.sym.
   Any changes made here will be lost!
 */

/* Regops and State definitions */

#define REGNODE_MAX           	93
#define REGMATCH_STATE_MAX    	133

#define	END                   	0	/* 0000 End of program. */
#define	SUCCEED               	1	/* 0x01 Return from a subroutine, basically. */
#define	BOL                   	2	/* 0x02 Match "" at beginning of line. */
#define	MBOL                  	3	/* 0x03 Same, assuming multiline. */
#define	SBOL                  	4	/* 0x04 Same, assuming singleline. */
#define	EOS                   	5	/* 0x05 Match "" at end of string. */
#define	EOL                   	6	/* 0x06 Match "" at end of line. */
#define	MEOL                  	7	/* 0x07 Same, assuming multiline. */
#define	SEOL                  	8	/* 0x08 Same, assuming singleline. */
#define	BOUND                 	9	/* 0x09 Match "" at any word boundary using native charset rules for non-utf8 */
#define	BOUNDL                	10	/* 0x0a Match "" at any locale word boundary */
#define	BOUNDU                	11	/* 0x0b Match "" at any word boundary using Unicode rules */
#define	BOUNDA                	12	/* 0x0c Match "" at any word boundary using ASCII rules */
#define	NBOUND                	13	/* 0x0d Match "" at any word non-boundary using native charset rules for non-utf8 */
#define	NBOUNDL               	14	/* 0x0e Match "" at any locale word non-boundary */
#define	NBOUNDU               	15	/* 0x0f Match "" at any word non-boundary using Unicode rules */
#define	NBOUNDA               	16	/* 0x10 Match "" at any word non-boundary using ASCII rules */
#define	GPOS                  	17	/* 0x11 Matches where last m//g left off. */
#define	REG_ANY               	18	/* 0x12 Match any one character (except newline). */
#define	SANY                  	19	/* 0x13 Match any one character. */
#define	CANY                  	20	/* 0x14 Match any one byte. */
#define	ANYOF                 	21	/* 0x15 Match character in (or not in) this class, single char match only */
#define	POSIXD                	22	/* 0x16 Some [[:class:]] under /d; the FLAGS field gives which one */
#define	POSIXL                	23	/* 0x17 Some [[:class:]] under /l; the FLAGS field gives which one */
#define	POSIXU                	24	/* 0x18 Some [[:class:]] under /u; the FLAGS field gives which one */
#define	POSIXA                	25	/* 0x19 Some [[:class:]] under /a; the FLAGS field gives which one */
#define	NPOSIXD               	26	/* 0x1a complement of POSIXD, [[:^class:]] */
#define	NPOSIXL               	27	/* 0x1b complement of POSIXL, [[:^class:]] */
#define	NPOSIXU               	28	/* 0x1c complement of POSIXU, [[:^class:]] */
#define	NPOSIXA               	29	/* 0x1d complement of POSIXA, [[:^class:]] */
#define	CLUMP                 	30	/* 0x1e Match any extended grapheme cluster sequence */
#define	BRANCH                	31	/* 0x1f Match this alternative, or the next... */
#define	BACK                  	32	/* 0x20 Match "", "next" ptr points backward. */
#define	EXACT                 	33	/* 0x21 Match this string (preceded by length). */
#define	EXACTF                	34	/* 0x22 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	35	/* 0x23 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	36	/* 0x24 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA               	37	/* 0x25 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	EXACTFU_SS            	38	/* 0x26 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA_NO_TRIE       	39	/* 0x27 Match this string (which is not trie-able; not guaranteed to be folded) using /iaa rules (w/len). */
#define	NOTHING               	40	/* 0x28 Match empty string. */
#define	TAIL                  	41	/* 0x29 Match empty string. Can jump here from outside. */
#define	STAR                  	42	/* 0x2a Match this (simple) thing 0 or more times. */
#define	PLUS                  	43	/* 0x2b Match this (simple) thing 1 or more times. */
#define	CURLY                 	44	/* 0x2c Match this simple thing {n,m} times. */
#define	CURLYN                	45	/* 0x2d Capture next-after-this simple thing */
#define	CURLYM                	46	/* 0x2e Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	47	/* 0x2f Match this complex thing {n,m} times. */
#define	WHILEM                	48	/* 0x30 Do curly processing and see if rest matches. */
#define	OPEN                  	49	/* 0x31 Mark this point in input as start of #n. */
#define	CLOSE                 	50	/* 0x32 Analogous to OPEN. */
#define	REF                   	51	/* 0x33 Match some already matched string */
#define	REFF                  	52	/* 0x34 Match already matched string, folded using native charset rules for non-utf8 */
#define	REFFL                 	53	/* 0x35 Match already matched string, folded in loc. */
#define	REFFU                 	54	/* 0x36 Match already matched string, folded using unicode rules for non-utf8 */
#define	REFFA                 	55	/* 0x37 Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	NREF                  	56	/* 0x38 Match some already matched string */
#define	NREFF                 	57	/* 0x39 Match already matched string, folded using native charset rules for non-utf8 */
#define	NREFFL                	58	/* 0x3a Match already matched string, folded in loc. */
#define	NREFFU                	59	/* 0x3b Match already matched string, folded using unicode rules for non-utf8 */
#define	NREFFA                	60	/* 0x3c Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	IFMATCH               	61	/* 0x3d Succeeds if the following matches. */
#define	UNLESSM               	62	/* 0x3e Fails if the following matches. */
#define	SUSPEND               	63	/* 0x3f "Independent" sub-RE. */
#define	IFTHEN                	64	/* 0x40 Switch, should be preceded by switcher. */
#define	GROUPP                	65	/* 0x41 Whether the group matched. */
#define	LONGJMP               	66	/* 0x42 Jump far away. */
#define	BRANCHJ               	67	/* 0x43 BRANCH with long offset. */
#define	EVAL                  	68	/* 0x44 Execute some Perl code. */
#define	MINMOD                	69	/* 0x45 Next operator is not greedy. */
#define	LOGICAL               	70	/* 0x46 Next opcode should set the flag only. */
#define	RENUM                 	71	/* 0x47 Group with independently numbered parens. */
#define	TRIE                  	72	/* 0x48 Match many EXACT(F[ALU]?)? at once. flags==type */
#define	TRIEC                 	73	/* 0x49 Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	74	/* 0x4a Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	75	/* 0x4b Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	76	/* 0x4c recurse to paren arg1 at (signed) ofs arg2 */
#define	GOSTART               	77	/* 0x4d recurse to start of pattern */
#define	NGROUPP               	78	/* 0x4e Whether the group matched. */
#define	INSUBP                	79	/* 0x4f Whether we are in a specific recurse. */
#define	DEFINEP               	80	/* 0x50 Never execute directly. */
#define	ENDLIKE               	81	/* 0x51 Used only for the type field of verbs */
#define	OPFAIL                	82	/* 0x52 Same as (?!) */
#define	ACCEPT                	83	/* 0x53 Accepts the current matched string. */
#define	VERB                  	84	/* 0x54 Used only for the type field of verbs */
#define	PRUNE                 	85	/* 0x55 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	86	/* 0x56 Push the current location for rollback by cut. */
#define	SKIP                  	87	/* 0x57 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	88	/* 0x58 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	89	/* 0x59 On failure go to the next alternation in the group */
#define	KEEPS                 	90	/* 0x5a $& begins here. */
#define	LNBREAK               	91	/* 0x5b generic newline pattern */
#define	OPTIMIZED             	92	/* 0x5c Placeholder for dump. */
#define	PSEUDO                	93	/* 0x5d Pseudo opcode for internal use. */
	/* ------------ States ------------- */
#define	TRIE_next             	(REGNODE_MAX + 1)	/* state for TRIE */
#define	TRIE_next_fail        	(REGNODE_MAX + 2)	/* state for TRIE */
#define	EVAL_AB               	(REGNODE_MAX + 3)	/* state for EVAL */
#define	EVAL_AB_fail          	(REGNODE_MAX + 4)	/* state for EVAL */
#define	CURLYX_end            	(REGNODE_MAX + 5)	/* state for CURLYX */
#define	CURLYX_end_fail       	(REGNODE_MAX + 6)	/* state for CURLYX */
#define	WHILEM_A_pre          	(REGNODE_MAX + 7)	/* state for WHILEM */
#define	WHILEM_A_pre_fail     	(REGNODE_MAX + 8)	/* state for WHILEM */
#define	WHILEM_A_min          	(REGNODE_MAX + 9)	/* state for WHILEM */
#define	WHILEM_A_min_fail     	(REGNODE_MAX + 10)	/* state for WHILEM */
#define	WHILEM_A_max          	(REGNODE_MAX + 11)	/* state for WHILEM */
#define	WHILEM_A_max_fail     	(REGNODE_MAX + 12)	/* state for WHILEM */
#define	WHILEM_B_min          	(REGNODE_MAX + 13)	/* state for WHILEM */
#define	WHILEM_B_min_fail     	(REGNODE_MAX + 14)	/* state for WHILEM */
#define	WHILEM_B_max          	(REGNODE_MAX + 15)	/* state for WHILEM */
#define	WHILEM_B_max_fail     	(REGNODE_MAX + 16)	/* state for WHILEM */
#define	BRANCH_next           	(REGNODE_MAX + 17)	/* state for BRANCH */
#define	BRANCH_next_fail      	(REGNODE_MAX + 18)	/* state for BRANCH */
#define	CURLYM_A              	(REGNODE_MAX + 19)	/* state for CURLYM */
#define	CURLYM_A_fail         	(REGNODE_MAX + 20)	/* state for CURLYM */
#define	CURLYM_B              	(REGNODE_MAX + 21)	/* state for CURLYM */
#define	CURLYM_B_fail         	(REGNODE_MAX + 22)	/* state for CURLYM */
#define	IFMATCH_A             	(REGNODE_MAX + 23)	/* state for IFMATCH */
#define	IFMATCH_A_fail        	(REGNODE_MAX + 24)	/* state for IFMATCH */
#define	CURLY_B_min_known     	(REGNODE_MAX + 25)	/* state for CURLY */
#define	CURLY_B_min_known_fail	(REGNODE_MAX + 26)	/* state for CURLY */
#define	CURLY_B_min           	(REGNODE_MAX + 27)	/* state for CURLY */
#define	CURLY_B_min_fail      	(REGNODE_MAX + 28)	/* state for CURLY */
#define	CURLY_B_max           	(REGNODE_MAX + 29)	/* state for CURLY */
#define	CURLY_B_max_fail      	(REGNODE_MAX + 30)	/* state for CURLY */
#define	COMMIT_next           	(REGNODE_MAX + 31)	/* state for COMMIT */
#define	COMMIT_next_fail      	(REGNODE_MAX + 32)	/* state for COMMIT */
#define	MARKPOINT_next        	(REGNODE_MAX + 33)	/* state for MARKPOINT */
#define	MARKPOINT_next_fail   	(REGNODE_MAX + 34)	/* state for MARKPOINT */
#define	SKIP_next             	(REGNODE_MAX + 35)	/* state for SKIP */
#define	SKIP_next_fail        	(REGNODE_MAX + 36)	/* state for SKIP */
#define	CUTGROUP_next         	(REGNODE_MAX + 37)	/* state for CUTGROUP */
#define	CUTGROUP_next_fail    	(REGNODE_MAX + 38)	/* state for CUTGROUP */
#define	KEEPS_next            	(REGNODE_MAX + 39)	/* state for KEEPS */
#define	KEEPS_next_fail       	(REGNODE_MAX + 40)	/* state for KEEPS */

/* PL_regkind[] What type of regop or state is this. */

#ifndef DOINIT
EXTCONST U8 PL_regkind[];
#else
EXTCONST U8 PL_regkind[] = {
	END,      	/* END                    */
	END,      	/* SUCCEED                */
	BOL,      	/* BOL                    */
	BOL,      	/* MBOL                   */
	BOL,      	/* SBOL                   */
	EOL,      	/* EOS                    */
	EOL,      	/* EOL                    */
	EOL,      	/* MEOL                   */
	EOL,      	/* SEOL                   */
	BOUND,    	/* BOUND                  */
	BOUND,    	/* BOUNDL                 */
	BOUND,    	/* BOUNDU                 */
	BOUND,    	/* BOUNDA                 */
	NBOUND,   	/* NBOUND                 */
	NBOUND,   	/* NBOUNDL                */
	NBOUND,   	/* NBOUNDU                */
	NBOUND,   	/* NBOUNDA                */
	GPOS,     	/* GPOS                   */
	REG_ANY,  	/* REG_ANY                */
	REG_ANY,  	/* SANY                   */
	REG_ANY,  	/* CANY                   */
	ANYOF,    	/* ANYOF                  */
	POSIXD,   	/* POSIXD                 */
	POSIXD,   	/* POSIXL                 */
	POSIXD,   	/* POSIXU                 */
	POSIXD,   	/* POSIXA                 */
	NPOSIXD,  	/* NPOSIXD                */
	NPOSIXD,  	/* NPOSIXL                */
	NPOSIXD,  	/* NPOSIXU                */
	NPOSIXD,  	/* NPOSIXA                */
	CLUMP,    	/* CLUMP                  */
	BRANCH,   	/* BRANCH                 */
	BACK,     	/* BACK                   */
	EXACT,    	/* EXACT                  */
	EXACT,    	/* EXACTF                 */
	EXACT,    	/* EXACTFL                */
	EXACT,    	/* EXACTFU                */
	EXACT,    	/* EXACTFA                */
	EXACT,    	/* EXACTFU_SS             */
	EXACT,    	/* EXACTFA_NO_TRIE        */
	NOTHING,  	/* NOTHING                */
	NOTHING,  	/* TAIL                   */
	STAR,     	/* STAR                   */
	PLUS,     	/* PLUS                   */
	CURLY,    	/* CURLY                  */
	CURLY,    	/* CURLYN                 */
	CURLY,    	/* CURLYM                 */
	CURLY,    	/* CURLYX                 */
	WHILEM,   	/* WHILEM                 */
	OPEN,     	/* OPEN                   */
	CLOSE,    	/* CLOSE                  */
	REF,      	/* REF                    */
	REF,      	/* REFF                   */
	REF,      	/* REFFL                  */
	REF,      	/* REFFU                  */
	REF,      	/* REFFA                  */
	REF,      	/* NREF                   */
	REF,      	/* NREFF                  */
	REF,      	/* NREFFL                 */
	REF,      	/* NREFFU                 */
	REF,      	/* NREFFA                 */
	BRANCHJ,  	/* IFMATCH                */
	BRANCHJ,  	/* UNLESSM                */
	BRANCHJ,  	/* SUSPEND                */
	BRANCHJ,  	/* IFTHEN                 */
	GROUPP,   	/* GROUPP                 */
	LONGJMP,  	/* LONGJMP                */
	BRANCHJ,  	/* BRANCHJ                */
	EVAL,     	/* EVAL                   */
	MINMOD,   	/* MINMOD                 */
	LOGICAL,  	/* LOGICAL                */
	BRANCHJ,  	/* RENUM                  */
	TRIE,     	/* TRIE                   */
	TRIE,     	/* TRIEC                  */
	TRIE,     	/* AHOCORASICK            */
	TRIE,     	/* AHOCORASICKC           */
	GOSUB,    	/* GOSUB                  */
	GOSTART,  	/* GOSTART                */
	NGROUPP,  	/* NGROUPP                */
	INSUBP,   	/* INSUBP                 */
	DEFINEP,  	/* DEFINEP                */
	ENDLIKE,  	/* ENDLIKE                */
	ENDLIKE,  	/* OPFAIL                 */
	ENDLIKE,  	/* ACCEPT                 */
	VERB,     	/* VERB                   */
	VERB,     	/* PRUNE                  */
	VERB,     	/* MARKPOINT              */
	VERB,     	/* SKIP                   */
	VERB,     	/* COMMIT                 */
	VERB,     	/* CUTGROUP               */
	KEEPS,    	/* KEEPS                  */
	LNBREAK,  	/* LNBREAK                */
	NOTHING,  	/* OPTIMIZED              */
	PSEUDO,   	/* PSEUDO                 */
	/* ------------ States ------------- */
	TRIE,     	/* TRIE_next              */
	TRIE,     	/* TRIE_next_fail         */
	EVAL,     	/* EVAL_AB                */
	EVAL,     	/* EVAL_AB_fail           */
	CURLYX,   	/* CURLYX_end             */
	CURLYX,   	/* CURLYX_end_fail        */
	WHILEM,   	/* WHILEM_A_pre           */
	WHILEM,   	/* WHILEM_A_pre_fail      */
	WHILEM,   	/* WHILEM_A_min           */
	WHILEM,   	/* WHILEM_A_min_fail      */
	WHILEM,   	/* WHILEM_A_max           */
	WHILEM,   	/* WHILEM_A_max_fail      */
	WHILEM,   	/* WHILEM_B_min           */
	WHILEM,   	/* WHILEM_B_min_fail      */
	WHILEM,   	/* WHILEM_B_max           */
	WHILEM,   	/* WHILEM_B_max_fail      */
	BRANCH,   	/* BRANCH_next            */
	BRANCH,   	/* BRANCH_next_fail       */
	CURLYM,   	/* CURLYM_A               */
	CURLYM,   	/* CURLYM_A_fail          */
	CURLYM,   	/* CURLYM_B               */
	CURLYM,   	/* CURLYM_B_fail          */
	IFMATCH,  	/* IFMATCH_A              */
	IFMATCH,  	/* IFMATCH_A_fail         */
	CURLY,    	/* CURLY_B_min_known      */
	CURLY,    	/* CURLY_B_min_known_fail */
	CURLY,    	/* CURLY_B_min            */
	CURLY,    	/* CURLY_B_min_fail       */
	CURLY,    	/* CURLY_B_max            */
	CURLY,    	/* CURLY_B_max_fail       */
	COMMIT,   	/* COMMIT_next            */
	COMMIT,   	/* COMMIT_next_fail       */
	MARKPOINT,	/* MARKPOINT_next         */
	MARKPOINT,	/* MARKPOINT_next_fail    */
	SKIP,     	/* SKIP_next              */
	SKIP,     	/* SKIP_next_fail         */
	CUTGROUP, 	/* CUTGROUP_next          */
	CUTGROUP, 	/* CUTGROUP_next_fail     */
	KEEPS,    	/* KEEPS_next             */
	KEEPS,    	/* KEEPS_next_fail        */
};
#endif

/* regarglen[] - How large is the argument part of the node (in regnodes) */

#ifdef REG_COMP_C
static const U8 regarglen[] = {
	0,                                   	/* END          */
	0,                                   	/* SUCCEED      */
	0,                                   	/* BOL          */
	0,                                   	/* MBOL         */
	0,                                   	/* SBOL         */
	0,                                   	/* EOS          */
	0,                                   	/* EOL          */
	0,                                   	/* MEOL         */
	0,                                   	/* SEOL         */
	0,                                   	/* BOUND        */
	0,                                   	/* BOUNDL       */
	0,                                   	/* BOUNDU       */
	0,                                   	/* BOUNDA       */
	0,                                   	/* NBOUND       */
	0,                                   	/* NBOUNDL      */
	0,                                   	/* NBOUNDU      */
	0,                                   	/* NBOUNDA      */
	0,                                   	/* GPOS         */
	0,                                   	/* REG_ANY      */
	0,                                   	/* SANY         */
	0,                                   	/* CANY         */
	0,                                   	/* ANYOF        */
	0,                                   	/* POSIXD       */
	0,                                   	/* POSIXL       */
	0,                                   	/* POSIXU       */
	0,                                   	/* POSIXA       */
	0,                                   	/* NPOSIXD      */
	0,                                   	/* NPOSIXL      */
	0,                                   	/* NPOSIXU      */
	0,                                   	/* NPOSIXA      */
	0,                                   	/* CLUMP        */
	0,                                   	/* BRANCH       */
	0,                                   	/* BACK         */
	0,                                   	/* EXACT        */
	0,                                   	/* EXACTF       */
	0,                                   	/* EXACTFL      */
	0,                                   	/* EXACTFU      */
	0,                                   	/* EXACTFA      */
	0,                                   	/* EXACTFU_SS   */
	0,                                   	/* EXACTFA_NO_TRIE */
	0,                                   	/* NOTHING      */
	0,                                   	/* TAIL         */
	0,                                   	/* STAR         */
	0,                                   	/* PLUS         */
	EXTRA_SIZE(struct regnode_2),        	/* CURLY        */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYN       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYM       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYX       */
	0,                                   	/* WHILEM       */
	EXTRA_SIZE(struct regnode_1),        	/* OPEN         */
	EXTRA_SIZE(struct regnode_1),        	/* CLOSE        */
	EXTRA_SIZE(struct regnode_1),        	/* REF          */
	EXTRA_SIZE(struct regnode_1),        	/* REFF         */
	EXTRA_SIZE(struct regnode_1),        	/* REFFL        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFU        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFA        */
	EXTRA_SIZE(struct regnode_1),        	/* NREF         */
	EXTRA_SIZE(struct regnode_1),        	/* NREFF        */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFL       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFU       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFA       */
	EXTRA_SIZE(struct regnode_1),        	/* IFMATCH      */
	EXTRA_SIZE(struct regnode_1),        	/* UNLESSM      */
	EXTRA_SIZE(struct regnode_1),        	/* SUSPEND      */
	EXTRA_SIZE(struct regnode_1),        	/* IFTHEN       */
	EXTRA_SIZE(struct regnode_1),        	/* GROUPP       */
	EXTRA_SIZE(struct regnode_1),        	/* LONGJMP      */
	EXTRA_SIZE(struct regnode_1),        	/* BRANCHJ      */
	EXTRA_SIZE(struct regnode_1),        	/* EVAL         */
	0,                                   	/* MINMOD       */
	0,                                   	/* LOGICAL      */
	EXTRA_SIZE(struct regnode_1),        	/* RENUM        */
	EXTRA_SIZE(struct regnode_1),        	/* TRIE         */
	EXTRA_SIZE(struct regnode_charclass),	/* TRIEC        */
	EXTRA_SIZE(struct regnode_1),        	/* AHOCORASICK  */
	EXTRA_SIZE(struct regnode_charclass),	/* AHOCORASICKC */
	EXTRA_SIZE(struct regnode_2L),       	/* GOSUB        */
	0,                                   	/* GOSTART      */
	EXTRA_SIZE(struct regnode_1),        	/* NGROUPP      */
	EXTRA_SIZE(struct regnode_1),        	/* INSUBP       */
	EXTRA_SIZE(struct regnode_1),        	/* DEFINEP      */
	0,                                   	/* ENDLIKE      */
	0,                                   	/* OPFAIL       */
	EXTRA_SIZE(struct regnode_1),        	/* ACCEPT       */
	EXTRA_SIZE(struct regnode_1),        	/* VERB         */
	EXTRA_SIZE(struct regnode_1),        	/* PRUNE        */
	EXTRA_SIZE(struct regnode_1),        	/* MARKPOINT    */
	EXTRA_SIZE(struct regnode_1),        	/* SKIP         */
	EXTRA_SIZE(struct regnode_1),        	/* COMMIT       */
	EXTRA_SIZE(struct regnode_1),        	/* CUTGROUP     */
	0,                                   	/* KEEPS        */
	0,                                   	/* LNBREAK      */
	0,                                   	/* OPTIMIZED    */
	0,                                   	/* PSEUDO       */
};

/* reg_off_by_arg[] - Which argument holds the offset to the next node */

static const char reg_off_by_arg[] = {
	0,	/* END          */
	0,	/* SUCCEED      */
	0,	/* BOL          */
	0,	/* MBOL         */
	0,	/* SBOL         */
	0,	/* EOS          */
	0,	/* EOL          */
	0,	/* MEOL         */
	0,	/* SEOL         */
	0,	/* BOUND        */
	0,	/* BOUNDL       */
	0,	/* BOUNDU       */
	0,	/* BOUNDA       */
	0,	/* NBOUND       */
	0,	/* NBOUNDL      */
	0,	/* NBOUNDU      */
	0,	/* NBOUNDA      */
	0,	/* GPOS         */
	0,	/* REG_ANY      */
	0,	/* SANY         */
	0,	/* CANY         */
	0,	/* ANYOF        */
	0,	/* POSIXD       */
	0,	/* POSIXL       */
	0,	/* POSIXU       */
	0,	/* POSIXA       */
	0,	/* NPOSIXD      */
	0,	/* NPOSIXL      */
	0,	/* NPOSIXU      */
	0,	/* NPOSIXA      */
	0,	/* CLUMP        */
	0,	/* BRANCH       */
	0,	/* BACK         */
	0,	/* EXACT        */
	0,	/* EXACTF       */
	0,	/* EXACTFL      */
	0,	/* EXACTFU      */
	0,	/* EXACTFA      */
	0,	/* EXACTFU_SS   */
	0,	/* EXACTFA_NO_TRIE */
	0,	/* NOTHING      */
	0,	/* TAIL         */
	0,	/* STAR         */
	0,	/* PLUS         */
	0,	/* CURLY        */
	0,	/* CURLYN       */
	0,	/* CURLYM       */
	0,	/* CURLYX       */
	0,	/* WHILEM       */
	0,	/* OPEN         */
	0,	/* CLOSE        */
	0,	/* REF          */
	0,	/* REFF         */
	0,	/* REFFL        */
	0,	/* REFFU        */
	0,	/* REFFA        */
	0,	/* NREF         */
	0,	/* NREFF        */
	0,	/* NREFFL       */
	0,	/* NREFFU       */
	0,	/* NREFFA       */
	2,	/* IFMATCH      */
	2,	/* UNLESSM      */
	1,	/* SUSPEND      */
	1,	/* IFTHEN       */
	0,	/* GROUPP       */
	1,	/* LONGJMP      */
	1,	/* BRANCHJ      */
	0,	/* EVAL         */
	0,	/* MINMOD       */
	0,	/* LOGICAL      */
	1,	/* RENUM        */
	0,	/* TRIE         */
	0,	/* TRIEC        */
	0,	/* AHOCORASICK  */
	0,	/* AHOCORASICKC */
	0,	/* GOSUB        */
	0,	/* GOSTART      */
	0,	/* NGROUPP      */
	0,	/* INSUBP       */
	0,	/* DEFINEP      */
	0,	/* ENDLIKE      */
	0,	/* OPFAIL       */
	0,	/* ACCEPT       */
	0,	/* VERB         */
	0,	/* PRUNE        */
	0,	/* MARKPOINT    */
	0,	/* SKIP         */
	0,	/* COMMIT       */
	0,	/* CUTGROUP     */
	0,	/* KEEPS        */
	0,	/* LNBREAK      */
	0,	/* OPTIMIZED    */
	0,	/* PSEUDO       */
};

#endif /* REG_COMP_C */

/* reg_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_name[];
#else
EXTCONST char * const PL_reg_name[] = {
	"END",                   	/* 0000 */
	"SUCCEED",               	/* 0x01 */
	"BOL",                   	/* 0x02 */
	"MBOL",                  	/* 0x03 */
	"SBOL",                  	/* 0x04 */
	"EOS",                   	/* 0x05 */
	"EOL",                   	/* 0x06 */
	"MEOL",                  	/* 0x07 */
	"SEOL",                  	/* 0x08 */
	"BOUND",                 	/* 0x09 */
	"BOUNDL",                	/* 0x0a */
	"BOUNDU",                	/* 0x0b */
	"BOUNDA",                	/* 0x0c */
	"NBOUND",                	/* 0x0d */
	"NBOUNDL",               	/* 0x0e */
	"NBOUNDU",               	/* 0x0f */
	"NBOUNDA",               	/* 0x10 */
	"GPOS",                  	/* 0x11 */
	"REG_ANY",               	/* 0x12 */
	"SANY",                  	/* 0x13 */
	"CANY",                  	/* 0x14 */
	"ANYOF",                 	/* 0x15 */
	"POSIXD",                	/* 0x16 */
	"POSIXL",                	/* 0x17 */
	"POSIXU",                	/* 0x18 */
	"POSIXA",                	/* 0x19 */
	"NPOSIXD",               	/* 0x1a */
	"NPOSIXL",               	/* 0x1b */
	"NPOSIXU",               	/* 0x1c */
	"NPOSIXA",               	/* 0x1d */
	"CLUMP",                 	/* 0x1e */
	"BRANCH",                	/* 0x1f */
	"BACK",                  	/* 0x20 */
	"EXACT",                 	/* 0x21 */
	"EXACTF",                	/* 0x22 */
	"EXACTFL",               	/* 0x23 */
	"EXACTFU",               	/* 0x24 */
	"EXACTFA",               	/* 0x25 */
	"EXACTFU_SS",            	/* 0x26 */
	"EXACTFA_NO_TRIE",       	/* 0x27 */
	"NOTHING",               	/* 0x28 */
	"TAIL",                  	/* 0x29 */
	"STAR",                  	/* 0x2a */
	"PLUS",                  	/* 0x2b */
	"CURLY",                 	/* 0x2c */
	"CURLYN",                	/* 0x2d */
	"CURLYM",                	/* 0x2e */
	"CURLYX",                	/* 0x2f */
	"WHILEM",                	/* 0x30 */
	"OPEN",                  	/* 0x31 */
	"CLOSE",                 	/* 0x32 */
	"REF",                   	/* 0x33 */
	"REFF",                  	/* 0x34 */
	"REFFL",                 	/* 0x35 */
	"REFFU",                 	/* 0x36 */
	"REFFA",                 	/* 0x37 */
	"NREF",                  	/* 0x38 */
	"NREFF",                 	/* 0x39 */
	"NREFFL",                	/* 0x3a */
	"NREFFU",                	/* 0x3b */
	"NREFFA",                	/* 0x3c */
	"IFMATCH",               	/* 0x3d */
	"UNLESSM",               	/* 0x3e */
	"SUSPEND",               	/* 0x3f */
	"IFTHEN",                	/* 0x40 */
	"GROUPP",                	/* 0x41 */
	"LONGJMP",               	/* 0x42 */
	"BRANCHJ",               	/* 0x43 */
	"EVAL",                  	/* 0x44 */
	"MINMOD",                	/* 0x45 */
	"LOGICAL",               	/* 0x46 */
	"RENUM",                 	/* 0x47 */
	"TRIE",                  	/* 0x48 */
	"TRIEC",                 	/* 0x49 */
	"AHOCORASICK",           	/* 0x4a */
	"AHOCORASICKC",          	/* 0x4b */
	"GOSUB",                 	/* 0x4c */
	"GOSTART",               	/* 0x4d */
	"NGROUPP",               	/* 0x4e */
	"INSUBP",                	/* 0x4f */
	"DEFINEP",               	/* 0x50 */
	"ENDLIKE",               	/* 0x51 */
	"OPFAIL",                	/* 0x52 */
	"ACCEPT",                	/* 0x53 */
	"VERB",                  	/* 0x54 */
	"PRUNE",                 	/* 0x55 */
	"MARKPOINT",             	/* 0x56 */
	"SKIP",                  	/* 0x57 */
	"COMMIT",                	/* 0x58 */
	"CUTGROUP",              	/* 0x59 */
	"KEEPS",                 	/* 0x5a */
	"LNBREAK",               	/* 0x5b */
	"OPTIMIZED",             	/* 0x5c */
	"PSEUDO",                	/* 0x5d */
	/* ------------ States ------------- */
	"TRIE_next",             	/* REGNODE_MAX +0x01 */
	"TRIE_next_fail",        	/* REGNODE_MAX +0x02 */
	"EVAL_AB",               	/* REGNODE_MAX +0x03 */
	"EVAL_AB_fail",          	/* REGNODE_MAX +0x04 */
	"CURLYX_end",            	/* REGNODE_MAX +0x05 */
	"CURLYX_end_fail",       	/* REGNODE_MAX +0x06 */
	"WHILEM_A_pre",          	/* REGNODE_MAX +0x07 */
	"WHILEM_A_pre_fail",     	/* REGNODE_MAX +0x08 */
	"WHILEM_A_min",          	/* REGNODE_MAX +0x09 */
	"WHILEM_A_min_fail",     	/* REGNODE_MAX +0x0a */
	"WHILEM_A_max",          	/* REGNODE_MAX +0x0b */
	"WHILEM_A_max_fail",     	/* REGNODE_MAX +0x0c */
	"WHILEM_B_min",          	/* REGNODE_MAX +0x0d */
	"WHILEM_B_min_fail",     	/* REGNODE_MAX +0x0e */
	"WHILEM_B_max",          	/* REGNODE_MAX +0x0f */
	"WHILEM_B_max_fail",     	/* REGNODE_MAX +0x10 */
	"BRANCH_next",           	/* REGNODE_MAX +0x11 */
	"BRANCH_next_fail",      	/* REGNODE_MAX +0x12 */
	"CURLYM_A",              	/* REGNODE_MAX +0x13 */
	"CURLYM_A_fail",         	/* REGNODE_MAX +0x14 */
	"CURLYM_B",              	/* REGNODE_MAX +0x15 */
	"CURLYM_B_fail",         	/* REGNODE_MAX +0x16 */
	"IFMATCH_A",             	/* REGNODE_MAX +0x17 */
	"IFMATCH_A_fail",        	/* REGNODE_MAX +0x18 */
	"CURLY_B_min_known",     	/* REGNODE_MAX +0x19 */
	"CURLY_B_min_known_fail",	/* REGNODE_MAX +0x1a */
	"CURLY_B_min",           	/* REGNODE_MAX +0x1b */
	"CURLY_B_min_fail",      	/* REGNODE_MAX +0x1c */
	"CURLY_B_max",           	/* REGNODE_MAX +0x1d */
	"CURLY_B_max_fail",      	/* REGNODE_MAX +0x1e */
	"COMMIT_next",           	/* REGNODE_MAX +0x1f */
	"COMMIT_next_fail",      	/* REGNODE_MAX +0x20 */
	"MARKPOINT_next",        	/* REGNODE_MAX +0x21 */
	"MARKPOINT_next_fail",   	/* REGNODE_MAX +0x22 */
	"SKIP_next",             	/* REGNODE_MAX +0x23 */
	"SKIP_next_fail",        	/* REGNODE_MAX +0x24 */
	"CUTGROUP_next",         	/* REGNODE_MAX +0x25 */
	"CUTGROUP_next_fail",    	/* REGNODE_MAX +0x26 */
	"KEEPS_next",            	/* REGNODE_MAX +0x27 */
	"KEEPS_next_fail",       	/* REGNODE_MAX +0x28 */
};
#endif /* DOINIT */

/* PL_reg_extflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_extflags_name[];
#else
EXTCONST char * const PL_reg_extflags_name[] = {
	/* Bits in extflags defined: 11111110111111111111111111111111 */
	"MULTILINE",        /* 0x00000001 */
	"SINGLELINE",       /* 0x00000002 */
	"FOLD",             /* 0x00000004 */
	"EXTENDED",         /* 0x00000008 */
	"KEEPCOPY",         /* 0x00000010 */
	"CHARSET0",         /* 0x00000020 : "CHARSET" - 0x000000e0 */
	"CHARSET1",         /* 0x00000040 : "CHARSET" - 0x000000e0 */
	"CHARSET2",         /* 0x00000080 : "CHARSET" - 0x000000e0 */
	"SPLIT",            /* 0x00000100 */
	"IS_ANCHORED",      /* 0x00000200 */
	"UNUSED1",          /* 0x00000400 */
	"UNUSED2",          /* 0x00000800 */
	"UNUSED3",          /* 0x00001000 */
	"UNUSED4",          /* 0x00002000 */
	"UNUSED5",          /* 0x00004000 */
	"NO_INPLACE_SUBST", /* 0x00008000 */
	"EVAL_SEEN",        /* 0x00010000 */
	"UNUSED8",          /* 0x00020000 */
	"UNBOUNDED_QUANTIFIER_SEEN",/* 0x00040000 */
	"CHECK_ALL",        /* 0x00080000 */
	"MATCH_UTF8",       /* 0x00100000 */
	"USE_INTUIT_NOML",  /* 0x00200000 */
	"USE_INTUIT_ML",    /* 0x00400000 */
	"INTUIT_TAIL",      /* 0x00800000 */
	"UNUSED_BIT_24",    /* 0x01000000 */
	"COPY_DONE",        /* 0x02000000 */
	"TAINTED_SEEN",     /* 0x04000000 */
	"TAINTED",          /* 0x08000000 */
	"START_ONLY",       /* 0x10000000 */
	"SKIPWHITE",        /* 0x20000000 */
	"WHITE",            /* 0x40000000 */
	"NULL",             /* 0x80000000 */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_EXTFLAGS_NAME_SIZE 32
#endif

/* PL_reg_intflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_intflags_name[];
#else
EXTCONST char * const PL_reg_intflags_name[] = {
	"SKIP",                       /* 0x00000001 - PREGf_SKIP */
	"IMPLICIT",                   /* 0x00000002 - PREGf_IMPLICIT -  Converted .* to ^.*  */
	"NAUGHTY",                    /* 0x00000004 - PREGf_NAUGHTY -  how exponential is this pattern?  */
	"VERBARG_SEEN",               /* 0x00000008 - PREGf_VERBARG_SEEN */
	"CUTGROUP_SEEN",              /* 0x00000010 - PREGf_CUTGROUP_SEEN */
	"USE_RE_EVAL",                /* 0x00000020 - PREGf_USE_RE_EVAL -  compiled with "use re 'eval'"  */
	"NOSCAN",                     /* 0x00000040 - PREGf_NOSCAN */
	"CANY_SEEN",                  /* 0x00000080 - PREGf_CANY_SEEN */
	"GPOS_SEEN",                  /* 0x00000100 - PREGf_GPOS_SEEN */
	"GPOS_FLOAT",                 /* 0x00000200 - PREGf_GPOS_FLOAT */
	"ANCH_BOL",                   /* 0x00000400 - PREGf_ANCH_BOL */
	"ANCH_MBOL",                  /* 0x00000800 - PREGf_ANCH_MBOL */
	"ANCH_SBOL",                  /* 0x00001000 - PREGf_ANCH_SBOL */
	"ANCH_GPOS",                  /* 0x00002000 - PREGf_ANCH_GPOS */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_INTFLAGS_NAME_SIZE 14
#endif

/* The following have no fixed length. U8 so we can do strchr() on it. */
#define REGNODE_VARIES(node) (PL_varies_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_varies[] __attribute__deprecated__;
#else
EXTCONST U8 PL_varies[] __attribute__deprecated__ = {
    CLUMP, BRANCH, BACK, STAR, PLUS, CURLY, CURLYN, CURLYM, CURLYX, WHILEM,
    REF, REFF, REFFL, REFFU, REFFA, NREF, NREFF, NREFFL, NREFFU, NREFFA,
    SUSPEND, IFTHEN, BRANCHJ,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_varies_bitmask[];
#else
EXTCONST U8 PL_varies_bitmask[] = {
    0x00, 0x00, 0x00, 0xC0, 0x01, 0xFC, 0xF9, 0x9F, 0x09, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
#define REGNODE_SIMPLE(node) (PL_simple_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_simple[] __attribute__deprecated__;
#else
EXTCONST U8 PL_simple[] __attribute__deprecated__ = {
    REG_ANY, SANY, CANY, ANYOF, POSIXD, POSIXL, POSIXU, POSIXA, NPOSIXD,
    NPOSIXL, NPOSIXU, NPOSIXA,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_simple_bitmask[];
#else
EXTCONST U8 PL_simple_bitmask[] = {
    0x00, 0x00, 0xFC, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/scope.h                                                   0100644 0000000 0000000 00000027213 12744441327 017223  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    scope.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* *** these are ordered by number of of auto-popped args */

/* zero args */

#define SAVEt_ALLOC		0
#define SAVEt_CLEARPADRANGE	1
#define SAVEt_CLEARSV		2
#define SAVEt_REGCONTEXT	3
/*** SPARE      	        4 ***/

#define SAVEt_ARG0_MAX		4

/* one arg */

#define SAVEt_BOOL		5
#define SAVEt_COMPILE_WARNINGS	6
#define SAVEt_COMPPAD		7
#define SAVEt_FREECOPHH		8
#define SAVEt_FREEOP		9
#define SAVEt_FREEPV		10
#define SAVEt_FREESV		11
#define SAVEt_I16		12
#define SAVEt_I32_SMALL		13
#define SAVEt_I8		14
#define SAVEt_INT_SMALL		15
#define SAVEt_MORTALIZESV	16
#define SAVEt_NSTAB		17
#define SAVEt_OP		18
#define SAVEt_PARSER		19
#define SAVEt_STACK_POS		20
#define SAVEt_READONLY_OFF	21

#define SAVEt_ARG1_MAX		21

/* two args */

#define SAVEt_APTR		22
#define SAVEt_AV		23
#define SAVEt_DESTRUCTOR	24
#define SAVEt_DESTRUCTOR_X	25
#define SAVEt_GENERIC_PVREF	26
#define SAVEt_GENERIC_SVREF	27
#define SAVEt_GP		28
#define SAVEt_GVSV		29
#define SAVEt_HINTS		30
#define SAVEt_HPTR		31
#define SAVEt_HV		32
#define SAVEt_I32		33
#define SAVEt_INT		34
#define SAVEt_ITEM		35
#define SAVEt_IV		36
#define SAVEt_LONG		37
#define SAVEt_PPTR		38
#define SAVEt_SAVESWITCHSTACK	39
#define SAVEt_SHARED_PVREF	40
#define SAVEt_SPTR		41
#define SAVEt_STRLEN		42
#define SAVEt_SV		43
#define SAVEt_SVREF		44
#define SAVEt_VPTR		45
#define SAVEt_ADELETE		46

#define SAVEt_ARG2_MAX		46

/* three args */

#define SAVEt_DELETE		47
#define SAVEt_HELEM		48
#define SAVEt_PADSV_AND_MORTALIZE 49
#define SAVEt_SET_SVFLAGS	50
#define SAVEt_GVSLOT		51
#define SAVEt_AELEM		52

#define SAVEf_SETMAGIC		1
#define SAVEf_KEEPOLDELEM	2

#define SAVE_TIGHT_SHIFT	6
#define SAVE_MASK		0x3F

#define save_aelem(av,idx,sptr)	save_aelem_flags(av,idx,sptr,SAVEf_SETMAGIC)
#define save_helem(hv,key,sptr)	save_helem_flags(hv,key,sptr,SAVEf_SETMAGIC)

#ifndef SCOPE_SAVES_SIGNAL_MASK
#define SCOPE_SAVES_SIGNAL_MASK 0
#endif

/* the maximum number of entries that might be pushed using the SS_ADD*
 * macros */
#define SS_MAXPUSH 4

#define SSCHECK(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max)) savestack_grow()
#define SSGROW(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max)) savestack_grow_cnt(need + SS_MAXPUSH)
#define SSPUSHINT(i) (PL_savestack[PL_savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (PL_savestack[PL_savestack_ix++].any_long = (long)(i))
#define SSPUSHBOOL(p) (PL_savestack[PL_savestack_ix++].any_bool = (p))
#define SSPUSHIV(i) (PL_savestack[PL_savestack_ix++].any_iv = (IV)(i))
#define SSPUSHUV(u) (PL_savestack[PL_savestack_ix++].any_uv = (UV)(u))
#define SSPUSHPTR(p) (PL_savestack[PL_savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (PL_savestack[PL_savestack_ix++].any_dptr = (p))
#define SSPUSHDXPTR(p) (PL_savestack[PL_savestack_ix++].any_dxptr = (p))

/* SS_ADD*: newer, faster versions of the above. Don't mix the two sets of
 * macros. These are fast because they save reduce accesses to the PL_
 * vars and move the size check to the end. Doing the check last means
 * that values in registers will have been pushed and no longer needed, so
 * don't need saving around the call to grow. Also, tail-call elimination
 * of the grow() can be done. These changes reduce the code of something
 * like save_pushptrptr() to half its former size.
 * Of course, doing the size check *after* pushing means we must always
 * ensure there are SS_MAXPUSH free slots on the savestack
 *
 * These are for internal core use only and are subject to change */

#define dSS_ADD \
    I32 ix = PL_savestack_ix;     \
    ANY *ssp = &PL_savestack[ix]

#define SS_ADD_END(need) \
    assert((need) <= SS_MAXPUSH);                               \
    ix += (need);                                               \
    PL_savestack_ix = ix;                                       \
    assert(ix <= PL_savestack_max);                             \
    if (UNLIKELY((ix + SS_MAXPUSH) > PL_savestack_max)) savestack_grow(); \
    assert(PL_savestack_ix + SS_MAXPUSH <= PL_savestack_max);

#define SS_ADD_INT(i)   ((ssp++)->any_i32 = (I32)(i))
#define SS_ADD_LONG(i)  ((ssp++)->any_long = (long)(i))
#define SS_ADD_BOOL(p)  ((ssp++)->any_bool = (p))
#define SS_ADD_IV(i)    ((ssp++)->any_iv = (IV)(i))
#define SS_ADD_UV(u)    ((ssp++)->any_uv = (UV)(u))
#define SS_ADD_PTR(p)   ((ssp++)->any_ptr = (void*)(p))
#define SS_ADD_DPTR(p)  ((ssp++)->any_dptr = (p))
#define SS_ADD_DXPTR(p) ((ssp++)->any_dxptr = (p))

#define SSPOPINT (PL_savestack[--PL_savestack_ix].any_i32)
#define SSPOPLONG (PL_savestack[--PL_savestack_ix].any_long)
#define SSPOPBOOL (PL_savestack[--PL_savestack_ix].any_bool)
#define SSPOPIV (PL_savestack[--PL_savestack_ix].any_iv)
#define SSPOPUV (PL_savestack[--PL_savestack_ix].any_uv)
#define SSPOPPTR (PL_savestack[--PL_savestack_ix].any_ptr)
#define SSPOPDPTR (PL_savestack[--PL_savestack_ix].any_dptr)
#define SSPOPDXPTR (PL_savestack[--PL_savestack_ix].any_dxptr)


/*
=head1 Callback Functions

=for apidoc Ams||SAVETMPS
Opening bracket for temporaries on a callback.  See C<FREETMPS> and
L<perlcall>.

=for apidoc Ams||FREETMPS
Closing bracket for temporaries on a callback.  See C<SAVETMPS> and
L<perlcall>.

=for apidoc Ams||ENTER
Opening bracket on a callback.  See C<LEAVE> and L<perlcall>.

=for apidoc Ams||LEAVE
Closing bracket on a callback.  See C<ENTER> and L<perlcall>.

=over

=item ENTER_with_name(name)

Same as C<ENTER>, but when debugging is enabled it also associates the
given literal string with the new scope.

=item LEAVE_with_name(name)

Same as C<LEAVE>, but when debugging is enabled it first checks that the
scope has the given name. Name must be a literal string.

=back

=cut
*/

#define SAVETMPS Perl_save_strlen(aTHX_ (STRLEN *)&PL_tmps_floor), \
		 PL_tmps_floor = PL_tmps_ix
#define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps()

#ifdef DEBUGGING
#define ENTER							\
    STMT_START {						\
	push_scope();						\
	DEBUG_SCOPE("ENTER")					\
    } STMT_END
#define LEAVE							\
    STMT_START {						\
	DEBUG_SCOPE("LEAVE")					\
	pop_scope();						\
    } STMT_END
#define ENTER_with_name(name)						\
    STMT_START {							\
	push_scope();							\
	if (PL_scopestack_name)						\
	    PL_scopestack_name[PL_scopestack_ix-1] = name;		\
	DEBUG_SCOPE("ENTER \"" name "\"")				\
    } STMT_END
#define LEAVE_with_name(name)						\
    STMT_START {							\
	DEBUG_SCOPE("LEAVE \"" name "\"")				\
	if (PL_scopestack_name)	{					\
	    assert(((char*)PL_scopestack_name[PL_scopestack_ix-1]	\
			== (char*)name)					\
		    || strEQ(PL_scopestack_name[PL_scopestack_ix-1], name));        \
	}								\
	pop_scope();							\
    } STMT_END
#else
#define ENTER push_scope()
#define LEAVE pop_scope()
#define ENTER_with_name(name) ENTER
#define LEAVE_with_name(name) LEAVE
#endif
#define LEAVE_SCOPE(old) STMT_START { \
	if (PL_savestack_ix > old) leave_scope(old); \
    } STMT_END

#define SAVEI8(i)	save_I8((I8*)&(i))
#define SAVEI16(i)	save_I16((I16*)&(i))
#define SAVEI32(i)	save_I32((I32*)&(i))
#define SAVEINT(i)	save_int((int*)&(i))
#define SAVEIV(i)	save_iv((IV*)&(i))
#define SAVELONG(l)	save_long((long*)&(l))
#define SAVEBOOL(b)	save_bool(&(b))
#define SAVESPTR(s)	save_sptr((SV**)&(s))
#define SAVEPPTR(s)	save_pptr((char**)&(s))
#define SAVEVPTR(s)	save_vptr((void*)&(s))
#define SAVEPADSVANDMORTALIZE(s)	save_padsv_and_mortalize(s)
#define SAVEFREESV(s)	save_freesv(MUTABLE_SV(s))
#define SAVEMORTALIZESV(s)	save_mortalizesv(MUTABLE_SV(s))
#define SAVEFREEOP(o)	save_freeop((OP*)(o))
#define SAVEFREEPV(p)	save_freepv((char*)(p))
#define SAVECLEARSV(sv)	save_clearsv((SV**)&(sv))
#define SAVEGENERICSV(s)	save_generic_svref((SV**)&(s))
#define SAVEGENERICPV(s)	save_generic_pvref((char**)&(s))
#define SAVESHAREDPV(s)		save_shared_pvref((char**)&(s))
#define SAVESETSVFLAGS(sv,mask,val)	save_set_svflags(sv,mask,val)
#define SAVEFREECOPHH(h)	save_pushptr((void *)(h), SAVEt_FREECOPHH)
#define SAVEDELETE(h,k,l) \
	  save_delete(MUTABLE_HV(h), (char*)(k), (I32)(l))
#define SAVEHDELETE(h,s) \
	  save_hdelete(MUTABLE_HV(h), (s))
#define SAVEADELETE(a,k) \
	  save_adelete(MUTABLE_AV(a), (SSize_t)(k))
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), (void*)(p))

#define SAVEDESTRUCTOR_X(f,p) \
	  save_destructor_x((DESTRUCTORFUNC_t)(f), (void*)(p))

#define SAVESTACK_POS() \
    STMT_START {				   \
        dSS_ADD;                                   \
        SS_ADD_INT(PL_stack_sp - PL_stack_base);   \
        SS_ADD_UV(SAVEt_STACK_POS);                \
        SS_ADD_END(2);                             \
    } STMT_END

#define SAVEOP()	save_op()

#define SAVEHINTS()	save_hints()

#define SAVECOMPPAD() save_pushptr(MUTABLE_SV(PL_comppad), SAVEt_COMPPAD)

#define SAVESWITCHSTACK(f,t) \
    STMT_START {					\
	save_pushptrptr(MUTABLE_SV(f), MUTABLE_SV(t), SAVEt_SAVESWITCHSTACK); \
	SWITCHSTACK((f),(t));				\
	PL_curstackinfo->si_stack = (t);		\
    } STMT_END

/* Need to do the cop warnings like this, rather than a "SAVEFREESHAREDPV",
   because realloc() means that the value can actually change. Possibly
   could have done savefreesharedpvREF, but this way actually seems cleaner,
   as it simplifies the code that does the saves, and reduces the load on the
   save stack.  */
#define SAVECOMPILEWARNINGS() save_pushptr(PL_compiling.cop_warnings, SAVEt_COMPILE_WARNINGS)

#define SAVEPARSER(p) save_pushptr((p), SAVEt_PARSER)

#ifdef USE_ITHREADS
#  define SAVECOPSTASH_FREE(c)	SAVEIV((c)->cop_stashoff)
#  define SAVECOPFILE(c)	SAVEPPTR(CopFILE(c))
#  define SAVECOPFILE_FREE(c)	SAVESHAREDPV(CopFILE(c))
#else
#  /* XXX not refcounted */
#  define SAVECOPSTASH_FREE(c)	SAVESPTR(CopSTASH(c))
#  define SAVECOPFILE(c)	SAVESPTR(CopFILEGV(c))
#  define SAVECOPFILE_FREE(c)	SAVEGENERICSV(CopFILEGV(c))
#endif

#define SAVECOPLINE(c)		SAVEI32(CopLINE(c))

/* SSNEW() temporarily allocates a specified number of bytes of data on the
 * savestack.  It returns an integer index into the savestack, because a
 * pointer would get broken if the savestack is moved on reallocation.
 * SSNEWa() works like SSNEW(), but also aligns the data to the specified
 * number of bytes.  MEM_ALIGNBYTES is perhaps the most useful.  The
 * alignment will be preserved through savestack reallocation *only* if
 * realloc returns data aligned to a size divisible by "align"!
 *
 * SSPTR() converts the index returned by SSNEW/SSNEWa() into a pointer.
 */

#define SSNEW(size)             Perl_save_alloc(aTHX_ (size), 0)
#define SSNEWt(n,t)             SSNEW((n)*sizeof(t))
#define SSNEWa(size,align)	Perl_save_alloc(aTHX_ (size), \
    (I32)(align - ((size_t)((caddr_t)&PL_savestack[PL_savestack_ix]) % align)) % align)
#define SSNEWat(n,t,align)	SSNEWa((n)*sizeof(t), align)

#define SSPTR(off,type)         ((type)  ((char*)PL_savestack + off))
#define SSPTRt(off,type)        ((type*) ((char*)PL_savestack + off))

#define save_freesv(op)		save_pushptr((void *)(op), SAVEt_FREESV)
#define save_mortalizesv(op)	save_pushptr((void *)(op), SAVEt_MORTALIZESV)

# define save_freeop(op)                    \
STMT_START {                                 \
      OP * const _o = (OP *)(op);             \
      assert(!_o->op_savefree);               \
      _o->op_savefree = 1;                     \
      save_pushptr((void *)(_o), SAVEt_FREEOP); \
    } STMT_END
#define save_freepv(pv)		save_pushptr((void *)(pv), SAVEt_FREEPV)
#define save_op()		save_pushptr((void *)(PL_op), SAVEt_OP)

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/sv.h                                                      0100644 0000000 0000000 00000240713 12744441327 016544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    sv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef sv_flags
#undef sv_flags		/* Convex has this in <signal.h> for sigvec() */
#endif

/*
=head1 SV Flags

=for apidoc AmU||svtype
An enum of flags for Perl types.  These are found in the file B<sv.h>
in the C<svtype> enum.  Test these flags with the C<SvTYPE> macro.

The types are:

    SVt_NULL
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_INVLIST
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO

These are most easily explained from the bottom up.

SVt_PVIO is for I/O objects, SVt_PVFM for formats, SVt_PVCV for
subroutines, SVt_PVHV for hashes and SVt_PVAV for arrays.

All the others are scalar types, that is, things that can be bound to a
C<$> variable.  For these, the internal types are mostly orthogonal to
types in the Perl language.

Hence, checking C<< SvTYPE(sv) < SVt_PVAV >> is the best way to see whether
something is a scalar.

SVt_PVGV represents a typeglob.  If !SvFAKE(sv), then it is a real,
incoercible typeglob.  If SvFAKE(sv), then it is a scalar to which a
typeglob has been assigned.  Assigning to it again will stop it from being
a typeglob.  SVt_PVLV represents a scalar that delegates to another scalar
behind the scenes.  It is used, e.g., for the return value of C<substr> and
for tied hash and array elements.  It can hold any scalar value, including
a typeglob.  SVt_REGEXP is for regular
expressions.  SVt_INVLIST is for Perl
core internal use only.

SVt_PVMG represents a "normal" scalar (not a typeglob, regular expression,
or delegate).  Since most scalars do not need all the internal fields of a
PVMG, we save memory by allocating smaller structs when possible.  All the
other types are just simpler forms of SVt_PVMG, with fewer internal fields.
 SVt_NULL can only hold undef.  SVt_IV can hold undef, an integer, or a
reference.  (SVt_RV is an alias for SVt_IV, which exists for backward
compatibility.)  SVt_NV can hold any of those or a double.  SVt_PV can only
hold undef or a string.  SVt_PVIV is a superset of SVt_PV and SVt_IV.
SVt_PVNV is similar.  SVt_PVMG can hold anything SVt_PVNV can hold, but it
can, but does not have to, be blessed or magical.

=for apidoc AmU||SVt_NULL
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_IV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_NV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVIV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVNV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVMG
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_INVLIST
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_REGEXP
Type flag for regular expressions.  See L</svtype>.

=for apidoc AmU||SVt_PVGV
Type flag for typeglobs.  See L</svtype>.

=for apidoc AmU||SVt_PVLV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVAV
Type flag for arrays.  See L</svtype>.

=for apidoc AmU||SVt_PVHV
Type flag for hashes.  See L</svtype>.

=for apidoc AmU||SVt_PVCV
Type flag for subroutines.  See L</svtype>.

=for apidoc AmU||SVt_PVFM
Type flag for formats.  See L</svtype>.

=for apidoc AmU||SVt_PVIO
Type flag for I/O objects.  See L</svtype>.

=cut

  These are ordered so that the simpler types have a lower value; SvUPGRADE
  doesn't allow you to upgrade from a higher numbered type to a lower numbered
  one; also there is code that assumes that anything that has as a PV component
  has a type numbered >= SVt_PV.
*/


typedef enum {
	SVt_NULL,	/* 0 */
	/* BIND was here, before INVLIST replaced it.  */
	SVt_IV,		/* 1 */
	SVt_NV,		/* 2 */
	/* RV was here, before it was merged with IV.  */
	SVt_PV,		/* 3 */
	SVt_INVLIST,	/* 4, implemented as a PV */
	SVt_PVIV,	/* 5 */
	SVt_PVNV,	/* 6 */
	SVt_PVMG,	/* 7 */
	SVt_REGEXP,	/* 8 */
	/* PVBM was here, before BIND replaced it.  */
	SVt_PVGV,	/* 9 */
	SVt_PVLV,	/* 10 */
	SVt_PVAV,	/* 11 */
	SVt_PVHV,	/* 12 */
	SVt_PVCV,	/* 13 */
	SVt_PVFM,	/* 14 */
	SVt_PVIO,	/* 15 */
	SVt_LAST	/* keep last in enum. used to size arrays */
} svtype;

/* *** any alterations to the SV types above need to be reflected in
 * SVt_MASK and the various PL_valid_types_* tables.  As of this writing those
 * tables are in perl.h.  There are also two affected names tables in dump.c,
 * one in B.xs, and 'bodies_by_type[]' in sv.c */

#define SVt_MASK 0xf	/* smallest bitmask that covers all types */

#ifndef PERL_CORE
/* Although Fast Boyer Moore tables are now being stored in PVGVs, for most
   purposes external code wanting to consider PVBM probably needs to think of
   PVMG instead.  */
#  define SVt_PVBM	SVt_PVMG
/* Anything wanting to create a reference from clean should ensure that it has
   a scalar of type SVt_IV now:  */
#  define SVt_RV	SVt_IV
#endif

/* There is collusion here with sv_clear - sv_clear exits early for SVt_NULL
   so never reaches the clause at the end that uses sv_type_details->body_size
   to determine whether to call safefree(). Hence body_size can be set
   non-zero to record the size of HEs, without fear of bogus frees.  */
#if defined(PERL_IN_HV_C) || defined(PERL_IN_XS_APITEST)
#define HE_SVSLOT	SVt_NULL
#endif

#define PERL_ARENA_ROOTS_SIZE	(SVt_LAST)

/* typedefs to eliminate some typing */
typedef struct he HE;
typedef struct hek HEK;

/* Using C's structural equivalence to help emulate C++ inheritance here... */

/* start with 2 sv-head building blocks */
#define _SV_HEAD(ptrtype) \
    ptrtype	sv_any;		/* pointer to body */	\
    U32		sv_refcnt;	/* how many references to us */	\
    U32		sv_flags	/* what we are */

#define _SV_HEAD_UNION \
    union {				\
	char*   svu_pv;		/* pointer to malloced string */	\
	IV      svu_iv;			\
	UV      svu_uv;			\
	SV*     svu_rv;		/* pointer to another SV */		\
	struct regexp* svu_rx;		\
	SV**    svu_array;		\
	HE**	svu_hash;		\
	GP*	svu_gp;			\
	PerlIO *svu_fp;			\
    }	sv_u


struct STRUCT_SV {		/* struct sv { */
    _SV_HEAD(void*);
    _SV_HEAD_UNION;
#ifdef DEBUG_LEAKING_SCALARS
    PERL_BITFIELD32 sv_debug_optype:9;	/* the type of OP that allocated us */
    PERL_BITFIELD32 sv_debug_inpad:1;	/* was allocated in a pad for an OP */
    PERL_BITFIELD32 sv_debug_line:16;	/* the line where we were allocated */
    UV		    sv_debug_serial;	/* serial number of sv allocation   */
    char *	    sv_debug_file;	/* the file where we were allocated */
    SV *	    sv_debug_parent;	/* what we were cloned from (ithreads)*/
#endif
};

struct gv {
    _SV_HEAD(XPVGV*);		/* pointer to xpvgv body */
    _SV_HEAD_UNION;
};

struct cv {
    _SV_HEAD(XPVCV*);		/* pointer to xpvcv body */
    _SV_HEAD_UNION;
};

struct av {
    _SV_HEAD(XPVAV*);		/* pointer to xpvav body */
    _SV_HEAD_UNION;
};

struct hv {
    _SV_HEAD(XPVHV*);		/* pointer to xpvhv body */
    _SV_HEAD_UNION;
};

struct io {
    _SV_HEAD(XPVIO*);		/* pointer to xpvio body */
    _SV_HEAD_UNION;
};

struct p5rx {
    _SV_HEAD(struct regexp*);	/* pointer to regexp body */
    _SV_HEAD_UNION;
};

#undef _SV_HEAD
#undef _SV_HEAD_UNION		/* ensure no pollution */

/*
=head1 SV Manipulation Functions

=for apidoc Am|U32|SvREFCNT|SV* sv
Returns the value of the object's reference count.

=for apidoc Am|SV*|SvREFCNT_inc|SV* sv
Increments the reference count of the given SV, returning the SV.

All of the following SvREFCNT_inc* macros are optimized versions of
SvREFCNT_inc, and can be replaced with SvREFCNT_inc.

=for apidoc Am|SV*|SvREFCNT_inc_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_void|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_void_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple|SV* sv
Same as SvREFCNT_inc, but can only be used with expressions without side
effects.  Since we don't have to store a temporary value, it's faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple_NN|SV* sv
Same as SvREFCNT_inc_simple, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_simple_void|SV* sv
Same as SvREFCNT_inc_simple, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_simple_void_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|void|SvREFCNT_dec|SV* sv
Decrements the reference count of the given SV.  I<sv> may be NULL.

=for apidoc Am|void|SvREFCNT_dec_NN|SV* sv
Same as SvREFCNT_dec, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|svtype|SvTYPE|SV* sv
Returns the type of the SV.  See C<svtype>.

=for apidoc Am|void|SvUPGRADE|SV* sv|svtype type
Used to upgrade an SV to a more complex form.  Uses C<sv_upgrade> to
perform the upgrade if necessary.  See C<svtype>.

=cut
*/

#define SvANY(sv)	(sv)->sv_any
#define SvFLAGS(sv)	(sv)->sv_flags
#define SvREFCNT(sv)	(sv)->sv_refcnt

#define SvREFCNT_inc(sv)		S_SvREFCNT_inc(MUTABLE_SV(sv))
#define SvREFCNT_inc_simple(sv)		SvREFCNT_inc(sv)
#define SvREFCNT_inc_NN(sv)		S_SvREFCNT_inc_NN(MUTABLE_SV(sv))
#define SvREFCNT_inc_void(sv)		S_SvREFCNT_inc_void(MUTABLE_SV(sv))

/* These guys don't need the curly blocks */
#define SvREFCNT_inc_simple_void(sv)	STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),MUTABLE_SV(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))

#define SvREFCNT_dec(sv)	S_SvREFCNT_dec(aTHX_ MUTABLE_SV(sv))
#define SvREFCNT_dec_NN(sv)	S_SvREFCNT_dec_NN(aTHX_ MUTABLE_SV(sv))

#define SVTYPEMASK	0xff
#define SvTYPE(sv)	((svtype)((sv)->sv_flags & SVTYPEMASK))

/* Sadly there are some parts of the core that have pointers to already-freed
   SV heads, and rely on being able to tell that they are now free. So mark
   them all by using a consistent macro.  */
#define SvIS_FREED(sv)	((sv)->sv_flags == SVTYPEMASK)

/* this is defined in this peculiar way to avoid compiler warnings.
 * See the <20121213131428.GD1842@iabyn.com> thread in p5p */
#define SvUPGRADE(sv, mt) \
    ((void)(SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt),1)))

#define SVf_IOK		0x00000100  /* has valid public integer value */
#define SVf_NOK		0x00000200  /* has valid public numeric value */
#define SVf_POK		0x00000400  /* has valid public pointer value */
#define SVf_ROK		0x00000800  /* has a valid reference pointer */

#define SVp_IOK		0x00001000  /* has valid non-public integer value */
#define SVp_NOK		0x00002000  /* has valid non-public numeric value */
#define SVp_POK		0x00004000  /* has valid non-public pointer value */
#define SVp_SCREAM	0x00008000  /* method name is DOES */
#define SVphv_CLONEABLE	SVp_SCREAM  /* PVHV (stashes) clone its objects */
#define SVpgv_GP	SVp_SCREAM  /* GV has a valid GP */
#define SVprv_PCS_IMPORTED  SVp_SCREAM  /* RV is a proxy for a constant
				       subroutine in another package. Set the
				       GvIMPORTED_CV_on() if it needs to be
				       expanded to a real GV */
#define SVpad_NAMELIST	SVp_SCREAM  /* AV is a padnamelist */
#define SVf_IsCOW	0x00010000  /* copy on write (shared hash key if
				       SvLEN == 0) */
#define SVs_PADTMP	0x00020000  /* in use as tmp; only if ! SVs_PADMY */
#define SVs_PADSTALE	0x00020000  /* lexical has gone out of scope;
					only valid for SVs_PADMY */
#define SVpad_TYPED	0x00020000  /* pad name is a Typed Lexical */
#define SVs_PADMY	0x00040000  /* in use a "my" variable */
#define SVpad_OUR	0x00040000  /* pad name is "our" instead of "my" */
#define SVs_TEMP	0x00080000  /* string is stealable? */
#define SVs_OBJECT	0x00100000  /* is "blessed" */
#define SVs_GMG		0x00200000  /* has magical get method */
#define SVs_SMG		0x00400000  /* has magical set method */
#define SVs_RMG		0x00800000  /* has random magical methods */

#define SVf_FAKE	0x01000000  /* 0: glob is just a copy
				       1: SV head arena wasn't malloc()ed
				       2: For PVCV, whether CvUNIQUE(cv)
					  refers to an eval or once only
					  [CvEVAL(cv), CvSPECIAL(cv)]
				       3: On a pad name SV, that slot in the
					  frame AV is a REFCNT'ed reference
					  to a lexical from "outside". */
#define SVf_OOK		0x02000000  /* has valid offset value. For a PVHV this
				       means that a hv_aux struct is present
				       after the main array */
#define SVf_BREAK	0x04000000  /* refcnt is artificially low - used by
				       SVs in final arena cleanup.
				       Set in S_regtry on PL_reg_curpm, so that
				       perl_destruct will skip it. */
#define SVf_READONLY	0x08000000  /* may not be modified */




#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE|SVs_RMG|SVf_IsCOW)

#define SVf_OK		(SVf_IOK|SVf_NOK|SVf_POK|SVf_ROK| \
			 SVp_IOK|SVp_NOK|SVp_POK|SVpgv_GP)

#define PRIVSHIFT 4	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */

#define SVf_AMAGIC	0x10000000  /* has magical overloaded methods */

/* note that SVf_AMAGIC is now only set on stashes, so this bit is free
 * for non-HV SVs */

/* Ensure this value does not clash with the GV_ADD* flags in gv.h: */
#define SVf_UTF8        0x20000000  /* SvPV is UTF-8 encoded
				       This is also set on RVs whose overloaded
				       stringification is UTF-8. This might
				       only happen as a side effect of SvPV() */
/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */

/* PVAV could probably use 0x2000000 without conflict. I assume that PVFM can
   be UTF-8 encoded, and PVCVs could well have UTF-8 prototypes. PVIOs haven't
   been restructured, so sometimes get used as string buffers.  */


/* Some private flags. */


/* PVNV, PVMG only, and only used in pads. Should be safe to test on any scalar
   SV, as the core is careful to avoid setting both.

   SVf_POK, SVp_POK also set:
   0x00004400   Normal
   0x0000C400   method name for DOES (SvSCREAM)
   0x40004400   FBM compiled (SvVALID)
   0x4000C400   pad name.

   0x00008000   GV with GP
   0x00008800   RV with PCS imported
*/
#define SVpad_NAME	(SVp_SCREAM|SVpbm_VALID)
				    /* This SV is a name in the PAD, so
				       SVpad_TYPED, SVpad_OUR and SVpad_STATE
				       apply */
/* PVAV */
#define SVpav_REAL	0x40000000  /* free old entries */
/* PVHV */
#define SVphv_LAZYDEL	0x40000000  /* entry in xhv_eiter must be deleted */
/* This is only set true on a PVGV when it's playing "PVBM", but is tested for
   on any regular scalar (anything <= PVLV) */
#define SVpbm_VALID	0x40000000
/* Only used in toke.c on an SV stored in PL_lex_repl */
#define SVrepl_EVAL	0x40000000  /* Replacement part of s///e */

/* IV, PVIV, PVNV, PVMG, PVGV and (I assume) PVLV  */
#define SVf_IVisUV	0x80000000  /* use XPVUV instead of XPVIV */
/* PVAV */
#define SVpav_REIFY 	0x80000000  /* can become real */
/* PVHV */
#define SVphv_HASKFLAGS	0x80000000  /* keys have flag byte after hash */
/* PVGV when SVpbm_VALID is true */
#define SVpbm_TAIL	0x80000000
/* RV upwards. However, SVf_ROK and SVp_IOK are exclusive  */
#define SVprv_WEAKREF   0x80000000  /* Weak reference */
/* pad name vars only */
#define SVpad_STATE	0x80000000  /* pad name is a "state" var */

#define _XPV_HEAD							\
    HV*		xmg_stash;	/* class package */			\
    union _xmgu	xmg_u;							\
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */    \
    union {								\
	STRLEN	xpvlenu_len; 	/* allocated size */			\
	char *	xpvlenu_pv;	/* regexp string */			\
    } xpv_len_u	

#define xpv_len	xpv_len_u.xpvlenu_len

union _xnvu {
    NV	    xnv_nv;		/* numeric value, if any */
    HV *    xgv_stash;
    struct {
	U32 xlow;
	U32 xhigh;
    }	    xpad_cop_seq;	/* used by pad.c for cop_sequence */
};

union _xivu {
    IV	    xivu_iv;		/* integer value */
    UV	    xivu_uv;
    HEK *   xivu_namehek;	/* xpvlv, xpvgv: GvNAME */
};

union _xmgu {
    MAGIC*  xmg_magic;		/* linked list of magicalness */
    HV*	    xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    STRLEN  xmg_hash_index;	/* used while freeing hash entries */
};				/* also used by PadnamelistMAXNAMED */

struct xpv {
    _XPV_HEAD;
};

struct xpviv {
    _XPV_HEAD;
    union _xivu xiv_u;
};

#define xiv_iv xiv_u.xivu_iv

struct xpvuv {
    _XPV_HEAD;
    union _xivu xuv_u;
};

#define xuv_uv xuv_u.xivu_uv

struct xpvnv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

/* This structure must match the beginning of struct xpvhv in hv.h. */
struct xpvmg {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

struct xpvlv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
    union {
	STRLEN	xlvu_targoff;
	SSize_t xlvu_stargoff;
    } xlv_targoff_u;
    STRLEN	xlv_targlen;
    SV*		xlv_targ;
    char	xlv_type;	/* k=keys .=pos x=substr v=vec /=join/re
				 * y=alem/helem/iter t=tie T=tied HE */
    char	xlv_flags;	/* 1 = negative offset  2 = negative len */
};

#define xlv_targoff xlv_targoff_u.xlvu_targoff

struct xpvinvlist {
    _XPV_HEAD;
    IV          prev_index;
    STRLEN	iterator;
    bool	is_offset;	/* */
};

/* This structure works in 3 ways - regular scalar, GV with GP, or fast
   Boyer-Moore.  */
struct xpvgv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

typedef U32 cv_flags_t;

#define _XPVCV_COMMON								\
    HV *	xcv_stash;							\
    union {									\
	OP *	xcv_start;							\
	ANY	xcv_xsubany;							\
    }		xcv_start_u;					    		\
    union {									\
	OP *	xcv_root;							\
	void	(*xcv_xsub) (pTHX_ CV*);					\
    }		xcv_root_u;							\
    union {								\
	GV *	xcv_gv;							\
	HEK *	xcv_hek;						\
    }		xcv_gv_u;						\
    char *	xcv_file;							\
    PADLIST *	xcv_padlist;							\
    CV *	xcv_outside;							\
    U32		xcv_outside_seq; /* the COP sequence (at the point of our	\
				  * compilation) in the lexically enclosing	\
				  * sub */					\
    cv_flags_t	xcv_flags;						\
    I32	xcv_depth	/* >= 2 indicates recursive call */

/* This structure must match XPVCV in cv.h */

struct xpvfm {
    _XPV_HEAD;
    _XPVCV_COMMON;
};


struct xpvio {
    _XPV_HEAD;
    union _xivu xiv_u;
    /* ifp and ofp are normally the same, but sockets need separate streams */
    PerlIO *	xio_ofp;
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the
     *  following union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report
     * titled [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
    /* IV xio_lines is now in IVX  $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    char	xio_type;
    U8		xio_flags;
};

#define xio_dirp	xio_dirpu.xiou_dirp
#define xio_any		xio_dirpu.xiou_any

#define IOf_ARGV	1	/* this fp iterates over ARGV */
#define IOf_START	2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH	4	/* this fp wants a flush after write op */
#define IOf_DIDTOP	8	/* just did top of form */
#define IOf_UNTAINT	16	/* consider this fp (and its data) "safe" */
#define IOf_NOLINE	32	/* slurped a pseudo-line from empty file */
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge)
				   Also, when this is set, SvPVX() is valid */

/* The following macros define implementation-independent predicates on SVs. */

/*
=for apidoc Am|U32|SvNIOK|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.

=for apidoc Am|U32|SvNIOKp|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.  Checks the B<private> setting.  Use C<SvNIOK> instead.

=for apidoc Am|void|SvNIOK_off|SV* sv
Unsets the NV/IV status of an SV.

=for apidoc Am|U32|SvOK|SV* sv
Returns a U32 value indicating whether the value is defined.  This is
only meaningful for scalars.

=for apidoc Am|U32|SvIOKp|SV* sv
Returns a U32 value indicating whether the SV contains an integer.  Checks
the B<private> setting.  Use C<SvIOK> instead.

=for apidoc Am|U32|SvNOKp|SV* sv
Returns a U32 value indicating whether the SV contains a double.  Checks the
B<private> setting.  Use C<SvNOK> instead.

=for apidoc Am|U32|SvPOKp|SV* sv
Returns a U32 value indicating whether the SV contains a character string.
Checks the B<private> setting.  Use C<SvPOK> instead.

=for apidoc Am|U32|SvIOK|SV* sv
Returns a U32 value indicating whether the SV contains an integer.

=for apidoc Am|void|SvIOK_on|SV* sv
Tells an SV that it is an integer.

=for apidoc Am|void|SvIOK_off|SV* sv
Unsets the IV status of an SV.

=for apidoc Am|void|SvIOK_only|SV* sv
Tells an SV that it is an integer and disables all other OK bits.

=for apidoc Am|void|SvIOK_only_UV|SV* sv
Tells an SV that it is an unsigned integer and disables all other OK bits.

=for apidoc Am|bool|SvIOK_UV|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either SvUOK or SVIOK.

=for apidoc Am|bool|SvUOK|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either SvUOK or SVIOK.

=for apidoc Am|bool|SvIOK_notUV|SV* sv
Returns a boolean indicating whether the SV contains a signed integer.

=for apidoc Am|U32|SvNOK|SV* sv
Returns a U32 value indicating whether the SV contains a double.

=for apidoc Am|void|SvNOK_on|SV* sv
Tells an SV that it is a double.

=for apidoc Am|void|SvNOK_off|SV* sv
Unsets the NV status of an SV.

=for apidoc Am|void|SvNOK_only|SV* sv
Tells an SV that it is a double and disables all other OK bits.

=for apidoc Am|U32|SvPOK|SV* sv
Returns a U32 value indicating whether the SV contains a character
string.

=for apidoc Am|void|SvPOK_on|SV* sv
Tells an SV that it is a string.

=for apidoc Am|void|SvPOK_off|SV* sv
Unsets the PV status of an SV.

=for apidoc Am|void|SvPOK_only|SV* sv
Tells an SV that it is a string and disables all other OK bits.
Will also turn off the UTF-8 status.

=for apidoc Am|bool|SvVOK|SV* sv
Returns a boolean indicating whether the SV contains a v-string.

=for apidoc Am|U32|SvOOK|SV* sv
Returns a U32 indicating whether the pointer to the string buffer is offset.
This hack is used internally to speed up removal of characters from the
beginning of a SvPV.  When SvOOK is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before SvPVX.
This offset used to be stored in SvIVX, but is now stored within the spare
part of the buffer.

=for apidoc Am|U32|SvROK|SV* sv
Tests if the SV is an RV.

=for apidoc Am|void|SvROK_on|SV* sv
Tells an SV that it is an RV.

=for apidoc Am|void|SvROK_off|SV* sv
Unsets the RV status of an SV.

=for apidoc Am|SV*|SvRV|SV* sv
Dereferences an RV to return the SV.

=for apidoc Am|IV|SvIVX|SV* sv
Returns the raw value in the SV's IV slot, without checks or conversions.
Only use when you are sure SvIOK is true.  See also C<SvIV()>.

=for apidoc Am|UV|SvUVX|SV* sv
Returns the raw value in the SV's UV slot, without checks or conversions.
Only use when you are sure SvIOK is true.  See also C<SvUV()>.

=for apidoc Am|NV|SvNVX|SV* sv
Returns the raw value in the SV's NV slot, without checks or conversions.
Only use when you are sure SvNOK is true.  See also C<SvNV()>.

=for apidoc Am|char*|SvPVX|SV* sv
Returns a pointer to the physical string in the SV.  The SV must contain a
string.  Prior to 5.9.3 it is not safe
to execute this macro unless the SV's
type >= SVt_PV.

This is also used to store the name of an autoloaded subroutine in an XS
AUTOLOAD routine.  See L<perlguts/Autoloading with XSUBs>.

=for apidoc Am|STRLEN|SvCUR|SV* sv
Returns the length of the string which is in the SV.  See C<SvLEN>.

=for apidoc Am|STRLEN|SvLEN|SV* sv
Returns the size of the string buffer in the SV, not including any part
attributable to C<SvOOK>.  See C<SvCUR>.

=for apidoc Am|char*|SvEND|SV* sv
Returns a pointer to the spot just after the last character in
the string which is in the SV, where there is usually a trailing
C<NUL> character (even though Perl scalars do not strictly require it).
See C<SvCUR>.  Access the character as *(SvEND(sv)).

Warning: If C<SvCUR> is equal to C<SvLEN>, then C<SvEND> points to
unallocated memory.

=for apidoc Am|HV*|SvSTASH|SV* sv
Returns the stash of the SV.

=for apidoc Am|void|SvIV_set|SV* sv|IV val
Set the value of the IV pointer in sv to val.  It is possible to perform
the same function of this macro with an lvalue assignment to C<SvIVX>.
With future Perls, however, it will be more efficient to use 
C<SvIV_set> instead of the lvalue assignment to C<SvIVX>.

=for apidoc Am|void|SvNV_set|SV* sv|NV val
Set the value of the NV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvPV_set|SV* sv|char* val
This is probably not what you want to use, you probably wanted
L</sv_usepvn_flags> or L</sv_setpvn> or L</sv_setpvs>.

Set the value of the PV pointer in C<sv> to the Perl allocated
C<NUL>-terminated string C<val>.  See also C<SvIV_set>.

Remember to free the previous PV buffer. There are many things to check.
Beware that the existing pointer may be involved in copy-on-write or other
mischief, so do C<SvOOK_off(sv)> and use C<sv_force_normal> or
C<SvPV_force> (or check the SvIsCOW flag) first to make sure this
modification is safe. Then finally, if it is not a COW, call C<SvPV_free> to
free the previous PV buffer.

=for apidoc Am|void|SvUV_set|SV* sv|UV val
Set the value of the UV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvRV_set|SV* sv|SV* val
Set the value of the RV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvMAGIC_set|SV* sv|MAGIC* val
Set the value of the MAGIC pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvSTASH_set|SV* sv|HV* val
Set the value of the STASH pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvCUR_set|SV* sv|STRLEN len
Set the current length of the string which is in the SV.  See C<SvCUR>
and C<SvIV_set>.

=for apidoc Am|void|SvLEN_set|SV* sv|STRLEN len
Set the actual length of the string which is in the SV.  See C<SvIV_set>.

=cut
*/

#define SvNIOK(sv)		(SvFLAGS(sv) & (SVf_IOK|SVf_NOK))
#define SvNIOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK))
#define SvNIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK| \
						  SVp_IOK|SVp_NOK|SVf_IVisUV))

#define assert_not_ROK(sv)	assert_(!SvROK(sv) || !SvRV(sv))
#define assert_not_glob(sv)	assert_(!isGV_with_GP(sv))

#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK || isREGEXP(sv))
#define SvOK_off(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
							SvOOK_off(sv))
#define SvOK_off_exc_UV(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_UTF8),		\
							SvOOK_off(sv))

#define SvOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK))
#define SvIOKp(sv)		(SvFLAGS(sv) & SVp_IOK)
#define SvIOKp_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX_(sv)	\
				    SvFLAGS(sv) |= SVp_IOK)
#define SvNOKp(sv)		(SvFLAGS(sv) & SVp_NOK)
#define SvNOKp_on(sv)		(assert_not_glob(sv) SvFLAGS(sv) |= SVp_NOK)
#define SvPOKp(sv)		(SvFLAGS(sv) & SVp_POK)
#define SvPOKp_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= SVp_POK)

#define SvIOK(sv)		(SvFLAGS(sv) & SVf_IOK)
#define SvIOK_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX_(sv)	\
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV))
#define SvIOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_only_UV(sv)	(assert_not_glob(sv) SvOK_off_exc_UV(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvIOK_UV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == (SVf_IOK|SVf_IVisUV))
#define SvUOK(sv)		SvIOK_UV(sv)
#define SvIOK_notUV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == SVf_IOK)

#define SvIsUV(sv)		(SvFLAGS(sv) & SVf_IVisUV)
#define SvIsUV_on(sv)		(SvFLAGS(sv) |= SVf_IVisUV)
#define SvIsUV_off(sv)		(SvFLAGS(sv) &= ~SVf_IVisUV)

#define SvNOK(sv)		(SvFLAGS(sv) & SVf_NOK)
#define SvNOK_on(sv)		(assert_not_glob(sv) \
				 SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
#define SvNOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_NOK|SVp_NOK))
#define SvNOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))

/*
=for apidoc Am|U32|SvUTF8|SV* sv
Returns a U32 value indicating the UTF-8 status of an SV.  If things are set-up
properly, this indicates whether or not the SV contains UTF-8 encoded data.
You should use this I<after> a call to SvPV() or one of its variants, in
case any call to string overloading updates the internal flag.

=for apidoc Am|void|SvUTF8_on|SV *sv
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a string and disables all other OK bits,
and leaves the UTF-8 status as it was.

=cut
 */

/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV),		\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvVOK(sv)		(SvMAGICAL(sv)				\
				 && mg_find(sv,PERL_MAGIC_vstring))
/* returns the vstring magic, if any */
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
				 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		(SvFLAGS(sv) |= SVf_OOK)
#define SvOOK_off(sv)		((void)(SvOOK(sv) && sv_backoff(sv)))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

#define SvAMAGIC(sv)		(SvROK(sv) && SvOBJECT(SvRV(sv)) &&	\
				 HvAMAGIC(SvSTASH(SvRV(sv))))

/* To be used on the stashes themselves: */
#define HvAMAGIC(hv)		(SvFLAGS(hv) & SVf_AMAGIC)
#define HvAMAGIC_on(hv)		(SvFLAGS(hv) |= SVf_AMAGIC)
#define HvAMAGIC_off(hv)	(SvFLAGS(hv) &=~ SVf_AMAGIC)


/* "nog" means "doesn't have get magic" */
#define SvPOK_nog(sv)		((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK)
#define SvIOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVs_GMG)) == SVf_IOK)
#define SvUOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nog(sv)		((SvFLAGS(sv) & (SVf_NOK|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nog(sv)		(SvNIOK(sv) && !(SvFLAGS(sv) & SVs_GMG))

#define SvPOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvIOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_THINKFIRST|SVs_GMG)) == SVf_IOK)
#define SvUOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVf_THINKFIRST|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_NOK|SVf_THINKFIRST|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nogthink(sv)	(SvNIOK(sv) && !(SvFLAGS(sv) & (SVf_THINKFIRST|SVs_GMG)))

#define SvPOK_utf8_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_utf8_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))

#define SvPOK_byte_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == SVf_POK)
#define SvPOK_byte_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

#define SvPOK_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvPOK_utf8_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_byte_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

/*
=for apidoc Am|U32|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or
overloading.  If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed.  Hence you must be careful to
only read it once per user logical operation and work
with that returned value.  If neither is true then
the scalar's value cannot change unless written to.

=cut
*/

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

#define Gv_AMG(stash) \
	(HvNAME(stash) && Gv_AMupdate(stash,FALSE) \
	    ? 1					    \
	    : (HvAMAGIC_off(stash), 0))

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
				  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))

#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
				 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

/*
=for apidoc m|U32|SvTHINKFIRST|SV *sv

A quick flag check to see whether an sv should be passed to sv_force_normal
to be "downgraded" before SvIVX or SvPVX can be modified directly.

For example, if your scalar is a reference and you want to modify the SvIVX
slot, you can't just do SvROK_off, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
sv_setsv, sv_setiv and sv_pvn_force.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

SvTHINKFIRST sometimes produces false positives.  In those cases
sv_force_normal does nothing.

=cut
*/

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SvPADMY(sv)		(SvFLAGS(sv) & SVs_PADMY)
#define SvPADMY_on(sv)		(SvFLAGS(sv) |= SVs_PADMY)

/* SVs_PADTMP and SVs_PADSTALE share the same bit, mediated by SVs_PADMY */

#define SvPADTMP(sv)	((SvFLAGS(sv) & (SVs_PADMY|SVs_PADTMP)) == SVs_PADTMP)
#define SvPADSTALE(sv)	((SvFLAGS(sv) & (SVs_PADMY|SVs_PADSTALE)) \
				    == (SVs_PADMY|SVs_PADSTALE))

#define SvPADTMP_on(sv)		S_SvPADTMP_on(MUTABLE_SV(sv))
#define SvPADTMP_off(sv)	S_SvPADTMP_off(MUTABLE_SV(sv))
#define SvPADSTALE_on(sv)	S_SvPADSTALE_on(MUTABLE_SV(sv))
#define SvPADSTALE_off(sv)	S_SvPADSTALE_off(MUTABLE_SV(sv))

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

#define SvREADONLY(sv)		(SvFLAGS(sv) & SVf_READONLY)
#define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
#define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)

#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#ifndef PERL_CORE
#  define SvCOMPILED(sv)	0
#  define SvCOMPILED_on(sv)
#  define SvCOMPILED_off(sv)
#endif

#define SvEVALED(sv)		(SvFLAGS(sv) & SVrepl_EVAL)
#define SvEVALED_on(sv)		(SvFLAGS(sv) |= SVrepl_EVAL)
#define SvEVALED_off(sv)	(SvFLAGS(sv) &= ~SVrepl_EVAL)

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvVALID(sv)		({ const SV *const _svvalid = (const SV*)(sv); \
				   if (SvFLAGS(_svvalid) & SVpbm_VALID && !SvSCREAM(_svvalid)) \
				       assert(!isGV_with_GP(_svvalid));	\
				   (SvFLAGS(_svvalid) & SVpbm_VALID);	\
				})
#  define SvVALID_on(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   assert(!SvSCREAM(_svvalid));		\
				   (SvFLAGS(_svvalid) |= SVpbm_VALID);	\
				})
#  define SvVALID_off(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   assert(!SvSCREAM(_svvalid));		\
				   (SvFLAGS(_svvalid) &= ~SVpbm_VALID);	\
				})

#  define SvTAIL(sv)	({ const SV *const _svtail = (const SV *)(sv);	\
			    assert(SvTYPE(_svtail) != SVt_PVAV);	\
			    assert(SvTYPE(_svtail) != SVt_PVHV);	\
			    assert(!SvSCREAM(_svtail));			\
			    (SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
				== (SVpbm_TAIL|SVpbm_VALID);		\
			})
#else
#  define SvVALID(sv)		((SvFLAGS(sv) & SVpbm_VALID) && !SvSCREAM(sv))
#  define SvVALID_on(sv)	(SvFLAGS(sv) |= SVpbm_VALID)
#  define SvVALID_off(sv)	(SvFLAGS(sv) &= ~SVpbm_VALID)
#  define SvTAIL(sv)	    ((SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
			     == (SVpbm_TAIL|SVpbm_VALID))

#endif
#define SvTAIL_on(sv)		(SvFLAGS(sv) |= SVpbm_TAIL)
#define SvTAIL_off(sv)		(SvFLAGS(sv) &= ~SVpbm_TAIL)


#define SvPAD_TYPED(sv) \
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_TYPED)) == (SVpad_NAME|SVpad_TYPED))

#define SvPAD_OUR(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_OUR)) == (SVpad_NAME|SVpad_OUR))

#define SvPAD_STATE(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_STATE)) == (SVpad_NAME|SVpad_STATE))

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvPAD_TYPED_on(sv)	({					\
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVMG);				\
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_TYPED);		\
	})
#define SvPAD_OUR_on(sv)	({					\
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVMG);				\
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_OUR);			\
	})
#define SvPAD_STATE_on(sv)	({					\
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVNV || SvTYPE(_svpad) == SVt_PVMG); \
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_STATE);		\
	})
#else
#  define SvPAD_TYPED_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_TYPED)
#  define SvPAD_OUR_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_OUR)
#  define SvPAD_STATE_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_STATE)
#endif

#define SvOURSTASH(sv)	\
	(SvPAD_OUR(sv) ? ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash : NULL)
#define SvOURSTASH_set(sv, st)					\
        STMT_START {						\
	    assert(SvTYPE(sv) == SVt_PVMG);			\
	    ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash = st;	\
	} STMT_END

#define SvRVx(sv) SvRV(sv)

#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
#  define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert_(!SvREADONLY(sv)) (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  define SvMAGIC(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#  define SvSTASH(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_stash))
#else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
	(*({ SV *const _svpvx = MUTABLE_SV(sv);				\
	    assert(PL_valid_types_PVX[SvTYPE(_svpvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svpvx));				\
	    assert(!(SvTYPE(_svpvx) == SVt_PVIO				\
		     && !(IoFLAGS(_svpvx) & IOf_FAKE_DIRP)));		\
	    &((_svpvx)->sv_u.svu_pv);					\
	 }))
#    define SvCUR(sv)							\
	(*({ const SV *const _svcur = (const SV *)(sv);			\
	    assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]	\
		|| SvTYPE(_svcur) == SVt_REGEXP);			\
	    assert(!isGV_with_GP(_svcur));				\
	    assert(!(SvTYPE(_svcur) == SVt_PVIO				\
		     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
	    &(((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
	 }))
#    define SvIVX(sv)							\
	(*({ const SV *const _svivx = (const SV *)(sv);			\
	    assert(PL_valid_types_IVX[SvTYPE(_svivx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svivx));				\
	    &(((XPVIV*) MUTABLE_PTR(SvANY(_svivx)))->xiv_iv);		\
	 }))
#    define SvUVX(sv)							\
	(*({ const SV *const _svuvx = (const SV *)(sv);			\
	    assert(PL_valid_types_IVX[SvTYPE(_svuvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svuvx));				\
	    &(((XPVUV*) MUTABLE_PTR(SvANY(_svuvx)))->xuv_uv);		\
	 }))
#    define SvNVX(sv)							\
	(*({ const SV *const _svnvx = (const SV *)(sv);			\
	    assert(PL_valid_types_NVX[SvTYPE(_svnvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svnvx));				\
	    &(((XPVNV*) MUTABLE_PTR(SvANY(_svnvx)))->xnv_u.xnv_nv);	\
	 }))
#    define SvRV(sv)							\
	(*({ SV *const _svrv = MUTABLE_SV(sv);				\
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svrv));				\
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
	    &((_svrv)->sv_u.svu_rv);					\
	 }))
#    define SvRV_const(sv)						\
	({ const SV *const _svrv = (const SV *)(sv);			\
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svrv));				\
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
	    (_svrv)->sv_u.svu_rv;					\
	 })
#    define SvMAGIC(sv)							\
	(*({ const SV *const _svmagic = (const SV *)(sv);		\
	    assert(SvTYPE(_svmagic) >= SVt_PVMG);			\
	    if(SvTYPE(_svmagic) == SVt_PVMG)				\
		assert(!SvPAD_OUR(_svmagic));				\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svmagic)))->xmg_u.xmg_magic); \
	  }))
#    define SvSTASH(sv)							\
	(*({ const SV *const _svstash = (const SV *)(sv);		\
	    assert(SvTYPE(_svstash) >= SVt_PVMG);			\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svstash)))->xmg_stash);	\
	  }))
#  else
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs  */
#  define SvPVX_mutable(sv)	(0 + (sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)(0 + (sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))


/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
	STMT_START {if (!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv))) \
		(void) SvIV(sv); } STMT_END
#define SvIV_please_nomg(sv) \
	(!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv)) \
	    ? (SvIV_nomg(sv), SvIOK(sv))	  \
	    : SvIOK(sv))
#define SvIV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVIV*)  SvANY(sv))->xiv_iv = (val)); } STMT_END
#define SvNV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_NV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVNV*)SvANY(sv))->xnv_u.xnv_nv = (val)); } STMT_END
#define SvPV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		((sv)->sv_u.svu_pv = (val)); } STMT_END
#define SvUV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVUV*)SvANY(sv))->xuv_uv = (val)); } STMT_END
#define SvRV_set(sv, val) \
        STMT_START { \
		assert(PL_valid_types_RV[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
#define SvMAGIC_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
#define SvSTASH_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
#define SvCUR_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]	\
			|| SvTYPE(sv) == SVt_REGEXP);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		(((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
#define SvLEN_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));	\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		(((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
#define SvEND_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		SvCUR_set(sv, (val) - SvPVX(sv)); } STMT_END

#define SvPV_renew(sv,n) \
	STMT_START { SvLEN_set(sv, n); \
		SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
				(char*)saferealloc((Malloc_t)SvPVX(sv), \
						   (MEM_SIZE)((n)))));  \
		 } STMT_END

#define SvPV_shrink_to_cur(sv) STMT_START { \
		   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
		   SvPV_renew(sv, _lEnGtH); \
		 } STMT_END

#define SvPV_free(sv)							\
    STMT_START {							\
		     assert(SvTYPE(sv) >= SVt_PV);			\
		     if (SvLEN(sv)) {					\
			 assert(!SvROK(sv));				\
			 if(UNLIKELY(SvOOK(sv))) {			\
			     STRLEN zok; 				\
			     SvOOK_offset(sv, zok);			\
			     SvPV_set(sv, SvPVX_mutable(sv) - zok);	\
			     SvFLAGS(sv) &= ~SVf_OOK;			\
			 }						\
			 Safefree(SvPVX(sv));				\
		     }							\
		 } STMT_END

#ifdef PERL_CORE
/* Code that crops up in three places to take a scalar and ready it to hold
   a reference */
#  define prepare_SV_for_RV(sv)						\
    STMT_START {							\
		    if (SvTYPE(sv) < SVt_PV && SvTYPE(sv) != SVt_IV)	\
			sv_upgrade(sv, SVt_IV);				\
		    else if (SvTYPE(sv) >= SVt_PV) {			\
			SvPV_free(sv);					\
			SvLEN_set(sv, 0);				\
                        SvCUR_set(sv, 0);				\
		    }							\
		 } STMT_END
#endif

#ifndef PERL_CORE
#  define BmFLAGS(sv)		(SvTAIL(sv) ? FBMcf_TAIL : 0)
#endif

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define BmUSEFUL(sv)							\
	(*({ SV *const _bmuseful = MUTABLE_SV(sv);			\
	    assert(SvTYPE(_bmuseful) >= SVt_PVIV);			\
	    assert(SvVALID(_bmuseful));					\
	    assert(!SvIOK(_bmuseful));					\
	    &(((XPVIV*) SvANY(_bmuseful))->xiv_u.xivu_iv);              \
	 }))
#else
#  define BmUSEFUL(sv)          ((XPVIV*) SvANY(sv))->xiv_u.xivu_iv

#endif

#ifndef PERL_CORE
# define BmRARE(sv)	0
# define BmPREVIOUS(sv)	0
#endif

#define FmLINES(sv)	((XPVIV*)  SvANY(sv))->xiv_iv

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvSTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff_u.xlvu_stargoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen
#define LvFLAGS(sv)	((XPVLV*)  SvANY(sv))->xlv_flags

#define IoIFP(sv)	(sv)->sv_u.svu_fp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xiv_u.xivu_iv
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */

/*
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted.  Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted if tainting is enabled.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV.  Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features.  XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value.  Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also implicit
inputs such as locale settings.  C<SvTAINT> propagates that taintedness to
the outputs of an expression in a pessimistic fashion; i.e., without paying
attention to precisely which outputs are influenced by which inputs.

=cut
*/

#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

#ifdef NO_TAINT_SUPPORT
#   define SvTAINTED(sv) 0
#else
#   define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#endif
#define SvTAINTED_on(sv)  STMT_START{ if(UNLIKELY(TAINTING_get)){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(UNLIKELY(TAINTING_get)){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
	if (UNLIKELY(TAINTING_get)) {	\
	    if (UNLIKELY(TAINT_get))	\
		SvTAINTED_on(sv);	\
	}				\
    } STMT_END

/*
=for apidoc Am|char*|SvPV_force|SV* sv|STRLEN len
Like C<SvPV> but will force the SV into containing a string (C<SvPOK>), and
only a string (C<SvPOK_only>), by hook or by crook.  You need force if you are
going to update the C<SvPVX> directly.  Processes get magic.

Note that coercing an arbitrary scalar into a plain PV will potentially
strip useful data from it.  For example if the SV was C<SvROK>, then the
referent will have its reference count decremented, and the SV itself may
be converted to an C<SvPOK> scalar with a string buffer containing a value
such as C<"ARRAY(0x1234)">.

=for apidoc Am|char*|SvPV_force_nomg|SV* sv|STRLEN len
Like C<SvPV_force>, but doesn't process get magic.

=for apidoc Am|char*|SvPV|SV* sv|STRLEN len
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified version becoming C<SvPOK>.  Handles 'get' magic.  The
C<len> variable will be set to the length of the string (this is a macro, so
don't use C<&len>).  See also C<SvPVx> for a version which guarantees to
evaluate sv only once.

Note that there is no guarantee that the return value of C<SvPV()> is
equal to C<SvPVX(sv)>, or that C<SvPVX(sv)> contains valid data, or that
successive calls to C<SvPV(sv)> will return the same pointer value each
time.  This is due to the way that things like overloading and
Copy-On-Write are handled.  In these cases, the return value may point to
a temporary buffer or similar.  If you absolutely need the SvPVX field to
be valid (for example, if you intend to write to it), then see
L</SvPV_force>.

=for apidoc Am|char*|SvPVx|SV* sv|STRLEN len
A version of C<SvPV> which guarantees to evaluate C<sv> only once.
Only use this if C<sv> is an expression with side effects, otherwise use the
more efficient C<SvPV>.

=for apidoc Am|char*|SvPV_nomg|SV* sv|STRLEN len
Like C<SvPV> but doesn't process magic.

=for apidoc Am|char*|SvPV_nolen|SV* sv
Like C<SvPV> but doesn't set a length variable.

=for apidoc Am|char*|SvPV_nomg_nolen|SV* sv
Like C<SvPV_nolen> but doesn't process magic.

=for apidoc Am|IV|SvIV|SV* sv
Coerces the given SV to an integer and returns it.  See C<SvIVx> for a
version which guarantees to evaluate sv only once.

=for apidoc Am|IV|SvIV_nomg|SV* sv
Like C<SvIV> but doesn't process magic.

=for apidoc Am|IV|SvIVx|SV* sv
Coerces the given SV to an integer and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvIV>.

=for apidoc Am|NV|SvNV|SV* sv
Coerce the given SV to a double and return it.  See C<SvNVx> for a version
which guarantees to evaluate sv only once.

=for apidoc Am|NV|SvNV_nomg|SV* sv
Like C<SvNV> but doesn't process magic.

=for apidoc Am|NV|SvNVx|SV* sv
Coerces the given SV to a double and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvNV>.

=for apidoc Am|UV|SvUV|SV* sv
Coerces the given SV to an unsigned integer and returns it.  See C<SvUVx>
for a version which guarantees to evaluate sv only once.

=for apidoc Am|UV|SvUV_nomg|SV* sv
Like C<SvUV> but doesn't process magic.

=for apidoc Am|UV|SvUVx|SV* sv
Coerces the given SV to an unsigned integer and
returns it.  Guarantees to evaluate C<sv> only once.  Only
use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvUV>.

=for apidoc Am|bool|SvTRUE|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false.  See SvOK() for a defined/undefined test.  Handles 'get' magic
unless the scalar is already SvPOK, SvIOK or SvNOK (the public, not the
private flags).

=for apidoc Am|bool|SvTRUE_nomg|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false.  See SvOK() for a defined/undefined test.  Does not handle 'get' magic.

=for apidoc Am|char*|SvPVutf8_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVutf8|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVutf8_nolen|SV* sv
Like C<SvPV_nolen>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVbyte_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte_nolen|SV* sv
Like C<SvPV_nolen>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVutf8x_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8_force>
otherwise.

=for apidoc Am|char*|SvPVutf8x|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8>
otherwise.

=for apidoc Am|char*|SvPVbytex_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte_force>
otherwise.

=for apidoc Am|char*|SvPVbytex|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte>
otherwise.

=for apidoc Am|U32|SvIsCOW|SV* sv
Returns a U32 value indicating whether the SV is Copy-On-Write (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW).

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.

=for apidoc Am|void|sv_catpvn_nomg|SV* sv|const char* ptr|STRLEN len
Like C<sv_catpvn> but doesn't process magic.

=for apidoc Am|void|sv_catpv_nomg|SV* sv|const char* ptr
Like C<sv_catpv> but doesn't process magic.

=for apidoc Am|void|sv_setsv_nomg|SV* dsv|SV* ssv
Like C<sv_setsv> but doesn't process magic.

=for apidoc Am|void|sv_catsv_nomg|SV* dsv|SV* ssv
Like C<sv_catsv> but doesn't process magic.

=for apidoc Amdb|STRLEN|sv_utf8_upgrade_nomg|NN SV *sv

Like sv_utf8_upgrade, but doesn't do magic on C<sv>.

=cut
*/

/* Let us hope that bitmaps for UV and IV are the same */
#define SvIV(sv) (SvIOK_nog(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvUOK_nog(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK_nog(sv) ? SvNVX(sv) : sv_2nv(sv))

#define SvIV_nomg(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv_flags(sv, 0))
#define SvUV_nomg(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv_flags(sv, 0))
#define SvNV_nomg(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv_flags(sv, 0))

/* ----*/

#define SvPV(sv, lp)         SvPV_flags(sv, lp, SV_GMAGIC)
#define SvPV_const(sv, lp)   SvPV_flags_const(sv, lp, SV_GMAGIC)
#define SvPV_mutable(sv, lp) SvPV_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_flags(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))
#define SvPV_flags_const(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
     (const char*) sv_2pv_flags(sv, &lp, flags|SV_CONST_RETURN))
#define SvPV_flags_const_nolen(sv, flags) \
    (SvPOK_nog(sv) \
     ? SvPVX_const(sv) : \
     (const char*) sv_2pv_flags(sv, 0, flags|SV_CONST_RETURN))
#define SvPV_flags_mutable(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
     sv_2pv_flags(sv, &lp, flags|SV_MUTABLE_RETURN))

#define SvPV_force(sv, lp) SvPV_force_flags(sv, lp, SV_GMAGIC)
#define SvPV_force_nolen(sv) SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, lp) SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_force_nomg(sv, lp) SvPV_force_flags(sv, lp, 0)
#define SvPV_force_nomg_nolen(sv) SvPV_force_flags_nolen(sv, 0)

#define SvPV_force_flags(sv, lp, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))

#define SvPV_force_flags_nolen(sv, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))

#define SvPV_force_flags_mutable(sv, lp, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
     : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))

#define SvPV_nolen(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC))

/* "_nomg" in these defines means no mg_get() */
#define SvPV_nomg_nolen(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, 0))

#define SvPV_nolen_const(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX_const(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC|SV_CONST_RETURN))

#define SvPV_nomg(sv, lp) SvPV_flags(sv, lp, 0)
#define SvPV_nomg_const(sv, lp) SvPV_flags_const(sv, lp, 0)
#define SvPV_nomg_const_nolen(sv) SvPV_flags_const_nolen(sv, 0)

/* ----*/

#define SvPVutf8(sv, lp) \
    (SvPOK_utf8_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#define SvPVutf8_force(sv, lp) \
    (SvPOK_utf8_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))

#define SvPVutf8_nolen(sv) \
    (SvPOK_utf8_nog(sv) \
     ? SvPVX(sv) : sv_2pvutf8(sv, 0))

/* ----*/

#define SvPVbyte(sv, lp) \
    (SvPOK_byte_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#define SvPVbyte_force(sv, lp) \
    (SvPOK_byte_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyten_force(sv, &lp))

#define SvPVbyte_nolen(sv) \
    (SvPOK_byte_nog(sv) \
     ? SvPVX(sv) : sv_2pvbyte(sv, 0))

    
/* define FOOx(): idempotent versions of FOO(). If possible, use a local
 * var to evaluate the arg once; failing that, use a global if possible;
 * failing that, call a function to do the work
 */

#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)

#define SvTRUE(sv)        (LIKELY(sv) && (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_nomg(sv)   (LIKELY(sv) && (                                SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_NN(sv)              (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_nomg_NN(sv) (                                        SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_common(sv,fallback) (			\
      !SvOK(sv)						\
	? 0						\
    : SvPOK(sv)						\
	? SvPVXtrue(sv)					\
    : (SvFLAGS(sv) & (SVf_IOK|SVf_NOK))			\
	? (   (SvIOK(sv) && SvIVX(sv) != 0)		\
	   || (SvNOK(sv) && SvNVX(sv) != 0.0))		\
    : (fallback))

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)

#  define SvIVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvNV(_sv); })
#  define SvPVx(sv, lp) ({SV *_sv = (sv); SvPV(_sv, lp); })
#  define SvPVx_const(sv, lp) ({SV *_sv = (sv); SvPV_const(_sv, lp); })
#  define SvPVx_nolen(sv) ({SV *_sv = (sv); SvPV_nolen(_sv); })
#  define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
#  define SvPVutf8x(sv, lp) ({SV *_sv = (sv); SvPVutf8(_sv, lp); })
#  define SvPVbytex(sv, lp) ({SV *_sv = (sv); SvPVbyte(_sv, lp); })
#  define SvPVbytex_nolen(sv) ({SV *_sv = (sv); SvPVbyte_nolen(_sv); })
#  define SvTRUEx(sv)      ({SV *_sv = (sv); SvTRUE(_sv); })
#  define SvTRUEx_nomg(sv) ({SV *_sv = (sv); SvTRUE_nomg(_sv); })

#else /* __GNUC__ */

/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#  define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#  define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#  define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#  define SvTRUEx(sv)      ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#  define SvTRUEx_nomg(sv) ((PL_Sv = (sv)), SvTRUE_nomg(PL_Sv))
#endif /* __GNU__ */

#define SvPVXtrue(sv)	(					\
    ((XPV*)SvANY((sv))) 					\
     && (							\
	((XPV*)SvANY((sv)))->xpv_cur > 1			\
	|| (							\
	    ((XPV*)SvANY((sv)))->xpv_cur			\
	    && *(sv)->sv_u.svu_pv != '0'				\
	)							\
    )								\
)

#define SvIsCOW(sv)		(SvFLAGS(sv) & SVf_IsCOW)
#define SvIsCOW_on(sv)		(SvFLAGS(sv) |= SVf_IsCOW)
#define SvIsCOW_off(sv)		(SvFLAGS(sv) &= ~SVf_IsCOW)
#define SvIsCOW_shared_hash(sv)	(SvIsCOW(sv) && SvLEN(sv) == 0)

#define SvSHARED_HEK_FROM_PV(pvx) \
	((struct hek*)(pvx - STRUCT_OFFSET(struct hek, hek_key)))
#define SvSHARED_HASH(sv) (0 + SvSHARED_HEK_FROM_PV(SvPVX_const(sv))->hek_hash)

/* flag values for sv_*_flags functions */
#define SV_IMMEDIATE_UNREF	1
#define SV_GMAGIC		2
#define SV_COW_DROP_PV		4
#define SV_UTF8_NO_ENCODING	8
#define SV_NOSTEAL		16
#define SV_CONST_RETURN		32
#define SV_MUTABLE_RETURN	64
#define SV_SMAGIC		128
#define SV_HAS_TRAILING_NUL	256
#define SV_COW_SHARED_HASH_KEYS	512
/* This one is only enabled for PERL_OLD_COPY_ON_WRITE */
#define SV_COW_OTHER_PVS	1024
/* Make sv_2pv_flags return NULL if something is undefined.  */
#define SV_UNDEF_RETURNS_NULL	2048
/* Tell sv_utf8_upgrade() to not check to see if an upgrade is really needed.
 * This is used when the caller has already determined it is, and avoids
 * redundant work */
#define SV_FORCE_UTF8_UPGRADE	4096
/* if (after resolving magic etc), the SV is found to be overloaded,
 * don't call the overload magic, just return as-is */
#define SV_SKIP_OVERLOAD	8192
/* It is not yet clear whether we want this as an API, or what the
 * constants should be named. */
#ifdef PERL_CORE
# define SV_CATBYTES		16384
# define SV_CATUTF8		32768
#endif

/* The core is safe for this COW optimisation. XS code on CPAN may not be.
   So only default to doing the COW setup if we're in the core.
 */
#ifdef PERL_CORE
#  ifndef SV_DO_COW_SVSETSV
#    define SV_DO_COW_SVSETSV	SV_COW_SHARED_HASH_KEYS|SV_COW_OTHER_PVS
#  endif
#endif

#ifndef SV_DO_COW_SVSETSV
#  define SV_DO_COW_SVSETSV	0
#endif


#define sv_unref(sv)    	sv_unref_flags(sv, 0)
#define sv_force_normal(sv)	sv_force_normal_flags(sv, 0)
#define sv_usepvn(sv, p, l)	sv_usepvn_flags(sv, p, l, 0)
#define sv_usepvn_mg(sv, p, l)	sv_usepvn_flags(sv, p, l, SV_SMAGIC)

/* We are about to replace the SV's current value. So if it's copy on write
   we need to normalise it. Use the SV_COW_DROP_PV flag hint to say that
   the value is about to get thrown away, so drop the PV rather than go to
   the effort of making a read-write copy only for it to get immediately
   discarded.  */

#define SV_CHECK_THINKFIRST_COW_DROP(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, SV_COW_DROP_PV)

#ifdef PERL_OLD_COPY_ON_WRITE
#define SvRELEASE_IVX(sv)   \
    ((SvIsCOW(sv) ? sv_force_normal_flags(sv, 0) : (void) 0), 0)
#  define SvIsCOW_normal(sv)	(SvIsCOW(sv) && SvLEN(sv))
#  define SvRELEASE_IVX_(sv)	SvRELEASE_IVX(sv),
#  define SvCANCOW(sv) \
	(SvIsCOW(sv) || (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS)
/* This is a pessimistic view. Scalar must be purely a read-write PV to copy-
   on-write.  */
#  define CAN_COW_MASK	(SVs_OBJECT|SVs_GMG|SVs_SMG|SVs_RMG|SVf_IOK|SVf_NOK| \
			 SVf_POK|SVf_ROK|SVp_IOK|SVp_NOK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#else
#  define SvRELEASE_IVX(sv)   0
/* This little game brought to you by the need to shut this warning up:
mg.c: In function 'Perl_magic_get':
mg.c:1024: warning: left-hand operand of comma expression has no effect
*/
#  define SvRELEASE_IVX_(sv)  /**/
#  ifdef PERL_NEW_COPY_ON_WRITE
#   define SvCANCOW(sv)					    \
	(SvIsCOW(sv)					     \
	 ? SvLEN(sv) ? CowREFCNT(sv) != SV_COW_REFCNT_MAX : 1 \
	 : (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS       \
			    && SvCUR(sv)+1 < SvLEN(sv))
   /* Note: To allow 256 COW "copies", a refcnt of 0 means 1. */
#   define CowREFCNT(sv)	(*(U8 *)(SvPVX(sv)+SvLEN(sv)-1))
#   define SV_COW_REFCNT_MAX	((1 << sizeof(U8)*8) - 1)
#   define CAN_COW_MASK	(SVf_POK|SVf_ROK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#  endif
#endif /* PERL_OLD_COPY_ON_WRITE */

#define CAN_COW_FLAGS	(SVp_POK|SVf_POK)

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, 0)


/* all these 'functions' are now just macros */

#define sv_pv(sv) SvPV_nolen(sv)
#define sv_pvutf8(sv) SvPVutf8_nolen(sv)
#define sv_pvbyte(sv) SvPVbyte_nolen(sv)

#define sv_pvn_force_nomg(sv, lp) sv_pvn_force_flags(sv, lp, 0)
#define sv_utf8_upgrade_flags(sv, flags) sv_utf8_upgrade_flags_grow(sv, flags, 0)
#define sv_utf8_upgrade_nomg(sv) sv_utf8_upgrade_flags(sv, 0)
#define sv_catpvn_nomg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, 0)
#define sv_catpv_nomg(dsv, sstr) sv_catpv_flags(dsv, sstr, 0)
#define sv_setsv(dsv, ssv) \
	sv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_DO_COW_SVSETSV)
#define sv_catsv(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0)
#define sv_catsv_mg(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC|SV_SMAGIC)
#define sv_catpvn(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC)
#define sv_catpvn_mg(sv, sstr, slen) sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
#define sv_copypv(dsv, ssv) sv_copypv_flags(dsv, ssv, SV_GMAGIC)
#define sv_copypv_nomg(dsv, ssv) sv_copypv_flags(dsv, ssv, 0)
#define sv_2pv(sv, lp) sv_2pv_flags(sv, lp, SV_GMAGIC)
#define sv_2pv_nolen(sv) sv_2pv(sv, 0)
#define sv_2pvbyte_nolen(sv) sv_2pvbyte(sv, 0)
#define sv_2pvutf8_nolen(sv) sv_2pvutf8(sv, 0)
#define sv_2pv_nomg(sv, lp) sv_2pv_flags(sv, lp, 0)
#define sv_pvn_force(sv, lp) sv_pvn_force_flags(sv, lp, SV_GMAGIC)
#define sv_utf8_upgrade(sv) sv_utf8_upgrade_flags(sv, SV_GMAGIC)
#define sv_2iv(sv) sv_2iv_flags(sv, SV_GMAGIC)
#define sv_2uv(sv) sv_2uv_flags(sv, SV_GMAGIC)
#define sv_2nv(sv) sv_2nv_flags(sv, SV_GMAGIC)
#define sv_eq(sv1, sv2) sv_eq_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp(sv1, sv2) sv_cmp_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp_locale(sv1, sv2) sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC)
#define sv_collxfrm(sv, nxp) sv_cmp_flags(sv, nxp, SV_GMAGIC)
#define sv_2bool(sv) sv_2bool_flags(sv, SV_GMAGIC)
#define sv_2bool_nomg(sv) sv_2bool_flags(sv, 0)
#define sv_insert(bigstr, offset, len, little, littlelen)		\
	Perl_sv_insert_flags(aTHX_ (bigstr),(offset), (len), (little),	\
			     (littlelen), SV_GMAGIC)
#define sv_mortalcopy(sv) \
	Perl_sv_mortalcopy_flags(aTHX_ sv, SV_GMAGIC|SV_DO_COW_SVSETSV)

/* Should be named SvCatPVN_utf8_upgrade? */
#define sv_catpvn_nomg_utf8_upgrade(dsv, sstr, slen, nsv)	\
	STMT_START {					\
	    if (!(nsv))					\
		nsv = newSVpvn_flags(sstr, slen, SVs_TEMP);	\
	    else					\
		sv_setpvn(nsv, sstr, slen);		\
	    SvUTF8_off(nsv);				\
	    sv_utf8_upgrade(nsv);			\
	    sv_catsv_nomg(dsv, nsv);			\
	} STMT_END
#define sv_catpvn_nomg_maybeutf8(dsv, sstr, slen, is_utf8) \
	sv_catpvn_flags(dsv, sstr, slen, (is_utf8)?SV_CATUTF8:SV_CATBYTES)

#if defined(PERL_CORE) || defined(PERL_EXT)
# define sv_or_pv_len_utf8(sv, pv, bytelen)	      \
    (SvGAMAGIC(sv)				       \
	? utf8_length((U8 *)(pv), (U8 *)(pv)+(bytelen))	\
	: sv_len_utf8(sv))
#endif

/*
=for apidoc Am|SV*|newRV_inc|SV* sv

Creates an RV wrapper for an SV.  The reference count for the original SV is
incremented.

=cut
*/

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this sv is associated with */

/*
=head1 Magical Functions

=for apidoc Am|void|SvGETMAGIC|SV* sv
Invokes C<mg_get> on an SV if it has 'get' magic.  For example, this
will call C<FETCH> on a tied variable.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSETMAGIC|SV* sv
Invokes C<mg_set> on an SV if it has 'set' magic.  This is necessary
after modifying a scalar, in case it is a magical variable like C<$|>
or a tied variable (it calls C<STORE>).  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSetSV|SV* dsv|SV* ssv
Calls C<sv_setsv> if dsv is not the same as ssv.  May evaluate arguments
more than once.  Does not handle 'set' magic on the destination SV.

=for apidoc Am|void|SvSetSV_nosteal|SV* dsv|SV* ssv
Calls a non-destructive version of C<sv_setsv> if dsv is not the same as
ssv.  May evaluate arguments more than once.

=for apidoc Am|void|SvSetMagicSV|SV* dsv|SV* ssv
Like C<SvSetSV>, but does any set magic required afterwards.

=for apidoc Am|void|SvSetMagicSV_nosteal|SV* dsv|SV* ssv
Like C<SvSetSV_nosteal>, but does any set magic required afterwards.

=for apidoc Am|void|SvSHARE|SV* sv
Arranges for sv to be shared between threads if a suitable module
has been loaded.

=for apidoc Am|void|SvLOCK|SV* sv
Arranges for a mutual exclusion lock to be obtained on sv if a suitable module
has been loaded.

=for apidoc Am|void|SvUNLOCK|SV* sv
Releases a mutual exclusion lock on sv if a suitable module
has been loaded.

=head1 SV Manipulation Functions

=for apidoc Am|char *|SvGROW|SV* sv|STRLEN len
Expands the character buffer in the SV so that it has room for the
indicated number of bytes (remember to reserve space for an extra trailing
C<NUL> character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character
buffer.  SV must be of type >= SVt_PV.  One
alternative is to call C<sv_grow> if you are not sure of the type of SV.

=cut
*/

#define SvSHARE(sv) PL_sharehook(aTHX_ sv)
#define SvLOCK(sv) PL_lockhook(aTHX_ sv)
#define SvUNLOCK(sv) PL_unlockhook(aTHX_ sv)
#define SvDESTROYABLE(sv) PL_destroyhook(aTHX_ sv)

#define SvGETMAGIC(x) ((void)(UNLIKELY(SvGMAGICAL(x)) && mg_get(x)))
#define SvSETMAGIC(x) STMT_START { if (UNLIKELY(SvSMAGICAL(x))) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
	STMT_START {					\
	    if (LIKELY((dst) != (src))) {		\
		sv_setsv(dst, src);			\
		finally;				\
	    }						\
	} STMT_END
#define SvSetSV_nosteal_and(dst,src,finally) \
	STMT_START {					\
	    if (LIKELY((dst) != (src))) {			\
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL | SV_DO_COW_SVSETSV);	\
		finally;				\
	    }						\
	} STMT_END

#define SvSetSV(dst,src) \
		SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
		SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))


#if !defined(SKIP_DEBUGGING)
#define SvPEEK(sv) sv_peek(sv)
#else
#define SvPEEK(sv) ""
#endif

#define SvIMMORTAL(sv) (SvREADONLY(sv) && ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder))

#ifdef DEBUGGING
   /* exercise the immortal resurrection code in sv_free2() */
#  define SvREFCNT_IMMORTAL 1000
#else
#  define SvREFCNT_IMMORTAL ((~(U32)0)/2)
#endif

/*
=for apidoc Am|SV *|boolSV|bool b

Returns a true SV if C<b> is a true value, or a false SV if C<b> is 0.

See also C<PL_sv_yes> and C<PL_sv_no>.

=cut
*/

#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)

#define isGV(sv) (SvTYPE(sv) == SVt_PVGV)
/* If I give every macro argument a different name, then there won't be bugs
   where nested macros get confused. Been there, done that.  */
#define isGV_with_GP(pwadak) \
	(((SvFLAGS(pwadak) & (SVp_POK|SVpgv_GP)) == SVpgv_GP)	\
	&& (SvTYPE(pwadak) == SVt_PVGV || SvTYPE(pwadak) == SVt_PVLV))
#define isGV_with_GP_on(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) |= SVpgv_GP);				       \
    } STMT_END
#define isGV_with_GP_off(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) &= ~SVpgv_GP);				       \
    } STMT_END
#define isREGEXP(sv) \
    (SvTYPE(sv) == SVt_REGEXP				      \
     || (SvFLAGS(sv) & (SVTYPEMASK|SVp_POK|SVpgv_GP|SVf_FAKE)) \
	 == (SVt_PVLV|SVf_FAKE))


#ifdef PERL_ANY_COW
# define SvGROW(sv,len) \
	(SvIsCOW(sv) || SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#else
# define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#endif
#define SvGROW_mutable(sv,len) \
    (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX_mutable(sv))
#define Sv_Grow sv_grow

#define CLONEf_COPY_STACKS 1
#define CLONEf_KEEP_PTR_TABLE 2
#define CLONEf_CLONE_HOST 4
#define CLONEf_JOIN_IN 8

struct clone_params {
  AV* stashes;
  UV  flags;
  PerlInterpreter *proto_perl;
  PerlInterpreter *new_perl;
  AV *unreferenced;
};

/*
=for apidoc Am|SV*|newSVpvn_utf8|NULLOK const char* s|STRLEN len|U32 utf8

Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  If utf8 is true, calls
C<SvUTF8_on> on the new SV.  Implemented as a wrapper around C<newSVpvn_flags>.

=cut
*/

#define newSVpvn_utf8(s, len, u) newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

/*
=for apidoc Amx|SV*|newSVpadname|PADNAME *pn

Creates a new SV containing the pad name.  This is currently identical
to C<newSVsv>, but pad names may cease being SVs at some point, so
C<newSVpadname> is preferable.

=cut
*/

#define newSVpadname(pn) newSVsv(pn)

/*
=for apidoc Am|void|SvOOK_offset|NN SV*sv|STRLEN len

Reads into I<len> the offset from SvPVX back to the true start of the
allocated buffer, which will be non-zero if C<sv_chop> has been used to
efficiently remove characters from start of the buffer.  Implemented as a
macro, which takes the address of I<len>, which must be of type C<STRLEN>.
Evaluates I<sv> more than once.  Sets I<len> to 0 if C<SvOOK(sv)> is false.

=cut
*/

#ifdef DEBUGGING
/* Does the bot know something I don't?
10:28 <@Nicholas> metabatman
10:28 <+meta> Nicholas: crash
*/
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    const U8 *_crash = (U8*)SvPVX_const(sv);			\
	    (offset) = *--_crash;					\
	    if (!(offset)) {						\
		_crash -= sizeof(STRLEN);				\
		Copy(_crash, (U8 *)&(offset), sizeof(STRLEN), U8);	\
	    }								\
	    {								\
		/* Validate the preceding buffer's sentinels to		\
		   verify that no-one is using it.  */			\
		const U8 *const _bonk = (U8*)SvPVX_const(sv) - (offset);\
		while (_crash > _bonk) {				\
		    --_crash;						\
		    assert (*_crash == (U8)PTR2UV(_crash));		\
		}							\
	    }								\
	} else {							\
	    (offset) = 0;						\
	}								\
    } STMT_END
#else
    /* This is the same code, but avoids using any temporary variables:  */
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    (offset) = ((U8*)SvPVX_const(sv))[-1];			\
	    if (!(offset)) {						\
		Copy(SvPVX_const(sv) - 1 - sizeof(STRLEN),		\
		     (U8*)&(offset), sizeof(STRLEN), U8);		\
	    }								\
	} else {							\
	    (offset) = 0;						\
	}								\
    } STMT_END
#endif

#define newIO()	MUTABLE_IO(newSV_type(SVt_PVIO))

#define SV_CONST(name) \
	PL_sv_consts[SV_CONST_##name] \
		? PL_sv_consts[SV_CONST_##name] \
		: (PL_sv_consts[SV_CONST_##name] = newSVpv_share(#name, 0))

#define SV_CONST_TIESCALAR 0
#define SV_CONST_TIEARRAY 1
#define SV_CONST_TIEHASH 2
#define SV_CONST_TIEHANDLE 3

#define SV_CONST_FETCH 4
#define SV_CONST_FETCHSIZE 5
#define SV_CONST_STORE 6
#define SV_CONST_STORESIZE 7
#define SV_CONST_EXISTS 8

#define SV_CONST_PUSH 9
#define SV_CONST_POP 10
#define SV_CONST_SHIFT 11
#define SV_CONST_UNSHIFT 12
#define SV_CONST_SPLICE 13
#define SV_CONST_EXTEND 14

#define SV_CONST_FIRSTKEY 15
#define SV_CONST_NEXTKEY 16
#define SV_CONST_SCALAR 17

#define SV_CONST_OPEN 18
#define SV_CONST_WRITE 19
#define SV_CONST_PRINT 20
#define SV_CONST_PRINTF 21
#define SV_CONST_READ 22
#define SV_CONST_READLINE 23
#define SV_CONST_GETC 24
#define SV_CONST_SEEK 25
#define SV_CONST_TELL 26
#define SV_CONST_EOF 27
#define SV_CONST_BINMODE 28
#define SV_CONST_FILENO 29
#define SV_CONST_CLOSE 30

#define SV_CONST_DELETE 31
#define SV_CONST_CLEAR 32
#define SV_CONST_UNTIE 33
#define SV_CONST_DESTROY 34

#define SV_CONSTS_COUNT 35

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/thread.h                                                  0100644 0000000 0000000 00000027043 12744441327 017362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    thread.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if defined(USE_ITHREADS)

#if defined(VMS)
#include <builtins.h>
#endif

#ifdef WIN32
#  include <win32thread.h>
#else
#ifdef NETWARE
#  include <nw5thread.h>
#else
#  ifdef OLD_PTHREADS_API /* Here be dragons. */
#    define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach(&(t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END

#    define PERL_GET_CONTEXT	Perl_get_context()
#    define PERL_SET_CONTEXT(t)	Perl_set_context((void*)t)

#    define PTHREAD_GETSPECIFIC_INT
#    ifdef DJGPP
#      define pthread_addr_t any_t
#      define NEED_PTHREAD_INIT
#      define PTHREAD_CREATE_JOINABLE (1)
#    endif
#    ifdef OEMVS
#      define pthread_addr_t void *
#      define pthread_create(t,a,s,d)        pthread_create(t,&(a),s,d)
#      define pthread_keycreate              pthread_key_create
#    endif
#    ifdef VMS
#      define pthread_attr_init(a) pthread_attr_create(a)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_setdetach_np(a,s)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(__hpux) && defined(__ux_version) && __ux_version <= 1020
#      define pthread_attr_init(a) pthread_attr_create(a)
       /* XXX pthread_setdetach_np() missing in DCE threads on HP-UX 10.20 */
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s)	(0)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(DJGPP) || defined(OEMVS)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,&(s))
#      define YIELD pthread_yield(NULL)
#    endif
#  endif
#  if !defined(__hpux) || !defined(__ux_version) || __ux_version > 1020
#    define pthread_mutexattr_default NULL
#    define pthread_condattr_default  NULL
#  endif
#endif	/* NETWARE */
#endif

#ifndef PTHREAD_CREATE
/* You are not supposed to pass NULL as the 2nd arg of PTHREAD_CREATE(). */
#  define PTHREAD_CREATE(t,a,s,d) pthread_create(t,&(a),s,d)
#endif

#ifndef PTHREAD_ATTR_SETDETACHSTATE
#  define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,s)
#endif

#ifndef PTHREAD_CREATE_JOINABLE
#  ifdef OLD_PTHREAD_CREATE_JOINABLE
#    define PTHREAD_CREATE_JOINABLE OLD_PTHREAD_CREATE_JOINABLE
#  else
#    define PTHREAD_CREATE_JOINABLE 0 /* Panic?  No, guess. */
#  endif
#endif

#ifdef __VMS
  /* Default is 1024 on VAX, 8192 otherwise */
#  ifdef __ia64
#    define THREAD_CREATE_NEEDS_STACK (48*1024)
#  else
#    define THREAD_CREATE_NEEDS_STACK (32*1024)
#  endif
#endif

#ifdef I_MACH_CTHREADS

/* cthreads interface */

/* #include <mach/cthreads.h> is in perl.h #ifdef I_MACH_CTHREADS */

#define MUTEX_INIT(m) \
    STMT_START {						\
	*m = mutex_alloc();					\
	if (*m) {						\
	    mutex_init(*m);					\
	} else {						\
	    Perl_croak_nocontext("panic: MUTEX_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define MUTEX_LOCK(m)			mutex_lock(*m)
#define MUTEX_UNLOCK(m)			mutex_unlock(*m)
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	mutex_free(*m);						\
	*m = 0;							\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	*c = condition_alloc();					\
	if (*c) {						\
	    condition_init(*c);					\
	}							\
	else {							\
	    Perl_croak_nocontext("panic: COND_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define COND_SIGNAL(c)		condition_signal(*c)
#define COND_BROADCAST(c)	condition_broadcast(*c)
#define COND_WAIT(c, m)		condition_wait(*c, *m)
#define COND_DESTROY(c) \
    STMT_START {						\
	condition_free(*c);					\
	*c = 0;							\
    } STMT_END

#define THREAD_CREATE(thr, f)	(thr->self = cthread_fork(f, thr), 0)
#define THREAD_POST_CREATE(thr)

#define THREAD_RET_TYPE		any_t
#define THREAD_RET_CAST(x)	((any_t) x)

#define DETACH(t)		cthread_detach(t->self)
#define JOIN(t, avp)		(*(avp) = MUTABLE_AV(cthread_join(t->self)))

#define PERL_SET_CONTEXT(t)	cthread_set_data(cthread_self(), t)
#define PERL_GET_CONTEXT	cthread_data(cthread_self())

#define INIT_THREADS		cthread_init()
#define YIELD			cthread_yield()
#define ALLOC_THREAD_KEY	NOOP
#define FREE_THREAD_KEY		NOOP
#define SET_THREAD_SELF(thr)	(thr->self = cthread_self())

#endif /* I_MACH_CTHREADS */

#ifndef YIELD
#  ifdef SCHED_YIELD
#    define YIELD SCHED_YIELD
#  else
#    ifdef HAS_SCHED_YIELD
#      define YIELD sched_yield()
#    else
#      ifdef HAS_PTHREAD_YIELD
    /* pthread_yield(NULL) platforms are expected
     * to have #defined YIELD for themselves. */
#        define YIELD pthread_yield()
#      endif
#    endif
#  endif
#endif

#ifdef __hpux
#  define MUTEX_INIT_NEEDS_MUTEX_ZEROED
#endif

#ifndef MUTEX_INIT

#  ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
    /* Temporary workaround, true bug is deeper. --jhi 1999-02-25 */
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	Zero((m), 1, perl_mutex);                               \
 	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  else
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  endif

#  define MUTEX_LOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_lock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_LOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_UNLOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_unlock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_DESTROY(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_destroy((m))))		\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* MUTEX_INIT */

#ifndef COND_INIT
#  define COND_INIT(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_init((c), pthread_condattr_default)))	\
	    Perl_croak_nocontext("panic: COND_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_SIGNAL(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_signal((c))))			\
	    Perl_croak_nocontext("panic: COND_SIGNAL (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_BROADCAST(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_broadcast((c))))		\
	    Perl_croak_nocontext("panic: COND_BROADCAST (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_WAIT(c, m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_wait((c), (m))))		\
	    Perl_croak_nocontext("panic: COND_WAIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_DESTROY(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_destroy((c))))			\
	    Perl_croak_nocontext("panic: COND_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* COND_INIT */

/* DETACH(t) must only be called while holding t->mutex */
#ifndef DETACH
#  define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach((t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END
#endif /* DETACH */

#ifndef JOIN
#  define JOIN(t, avp) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_join((t)->self, (void**)(avp))))	\
	    Perl_croak_nocontext("panic: pthread_join (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* JOIN */

/* Use an unchecked fetch of thread-specific data instead of a checked one.
 * It would fail if the key were bogus, but if the key were bogus then
 * Really Bad Things would be happening anyway. --dan */
#if (defined(__ALPHA) && (__VMS_VER >= 70000000)) || \
    (defined(__alpha) && defined(__osf__) && !defined(__GNUC__)) /* Available only on >= 4.0 */
#  define HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP /* Configure test needed */
#endif

#ifdef HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP
#  define PTHREAD_GETSPECIFIC(key) pthread_unchecked_getspecific_np(key)
#else
#    define PTHREAD_GETSPECIFIC(key) pthread_getspecific(key)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT	PTHREAD_GETSPECIFIC(PL_thr_key)
#endif

#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_setspecific(PL_thr_key, (void *)(t))))	\
	    Perl_croak_nocontext("panic: pthread_setspecific (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* PERL_SET_CONTEXT */

#ifndef INIT_THREADS
#  ifdef NEED_PTHREAD_INIT
#    define INIT_THREADS pthread_init()
#  endif
#endif

#ifndef ALLOC_THREAD_KEY
#  define ALLOC_THREAD_KEY \
    STMT_START {						\
	if (pthread_key_create(&PL_thr_key, 0)) {		\
            PERL_UNUSED_RESULT(write(2, STR_WITH_LEN("panic: pthread_key_create failed\n"))); \
	    exit(1);						\
	}							\
    } STMT_END
#endif

#ifndef FREE_THREAD_KEY
#  define FREE_THREAD_KEY \
    STMT_START {						\
	pthread_key_delete(PL_thr_key);				\
    } STMT_END
#endif

#ifndef PTHREAD_ATFORK
#  ifdef HAS_PTHREAD_ATFORK
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	pthread_atfork(prepare,parent,child)
#  else
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	NOOP
#  endif
#endif

#ifndef THREAD_RET_TYPE
#  define THREAD_RET_TYPE	void *
#  define THREAD_RET_CAST(p)	((void *)(p))
#endif /* THREAD_RET */

#  define LOCK_DOLLARZERO_MUTEX		MUTEX_LOCK(&PL_dollarzero_mutex)
#  define UNLOCK_DOLLARZERO_MUTEX	MUTEX_UNLOCK(&PL_dollarzero_mutex)

#endif /* USE_ITHREADS */

#ifndef MUTEX_LOCK
#  define MUTEX_LOCK(m)
#endif

#ifndef MUTEX_UNLOCK
#  define MUTEX_UNLOCK(m)
#endif

#ifndef MUTEX_INIT
#  define MUTEX_INIT(m)
#endif

#ifndef MUTEX_DESTROY
#  define MUTEX_DESTROY(m)
#endif

#ifndef COND_INIT
#  define COND_INIT(c)
#endif

#ifndef COND_SIGNAL
#  define COND_SIGNAL(c)
#endif

#ifndef COND_BROADCAST
#  define COND_BROADCAST(c)
#endif

#ifndef COND_WAIT
#  define COND_WAIT(c, m)
#endif

#ifndef COND_DESTROY
#  define COND_DESTROY(c)
#endif

#ifndef LOCK_DOLLARZERO_MUTEX
#  define LOCK_DOLLARZERO_MUTEX
#endif

#ifndef UNLOCK_DOLLARZERO_MUTEX
#  define UNLOCK_DOLLARZERO_MUTEX
#endif

/* THR, SET_THR, and dTHR are there for compatibility with old versions */
#ifndef THR
#  define THR		PERL_GET_THX
#endif

#ifndef SET_THR
#  define SET_THR(t)	PERL_SET_THX(t)
#endif

#ifndef dTHR
#  define dTHR dNOOP
#endif

#ifndef INIT_THREADS
#  define INIT_THREADS NOOP
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/time64.h                                                  0100644 0000000 0000000 00000003104 12744441327 017213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <time.h>
#include "time64_config.h"

#ifndef TIME64_H
#    define TIME64_H


/* Set our custom types */
typedef INT_64_T        Int64;
typedef Int64           Time64_T;
typedef I32             Year;


/* A copy of the tm struct but with a 64 bit year */
struct TM64 {
        int     tm_sec;
        int     tm_min;
        int     tm_hour;
        int     tm_mday;
        int     tm_mon;
        Year    tm_year;
        int     tm_wday;
        int     tm_yday;
        int     tm_isdst;

#ifdef HAS_TM_TM_GMTOFF
        long    tm_gmtoff;
#endif

#ifdef HAS_TM_TM_ZONE
/* If glibc is defined or we are on QNX, use const.
 * Otherwise, if we are on android, use const but
 * not with g++.
 */
#  if defined(__GLIBC__) || (defined(__ANDROID__) && !defined(__cplusplus)) || defined(__QNX__)
        const
#  endif
        char    *tm_zone;
#endif
};


/* Decide which tm struct to use */
#ifdef USE_TM64
#define TM      TM64
#else
#define TM      tm
#endif


/* Declare functions */
static struct TM *S_gmtime64_r    (const Time64_T *, struct TM *);
static struct TM *S_localtime64_r (const Time64_T *, struct TM *);
static Time64_T   S_timegm64      (struct TM *);


/* Not everyone has gm/localtime_r(), provide a replacement */
#ifdef HAS_LOCALTIME_R
#    define LOCALTIME_R(clock, result) (L_R_TZSET localtime_r(clock, result))
#else
#    define LOCALTIME_R(clock, result) (L_R_TZSET S_localtime_r(clock, result))
#endif
#ifdef HAS_GMTIME_R
#    define GMTIME_R(clock, result)    gmtime_r(clock, result)
#else
#    define GMTIME_R(clock, result)    S_gmtime_r(clock, result)
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/time64_config.h                                           0100644 0000000 0000000 00000003756 12744441327 020555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef TIME64_CONFIG_H
#    define TIME64_CONFIG_H

/* Configuration
   -------------
   Define as appropriate for your system.
   Sensible defaults provided.
*/

/* Debugging
   TIME_64_DEBUG
   Define if you want debugging messages
*/
/* #define TIME_64_DEBUG */


/* INT_64_T
   A numeric type to store time and others. 
   Must be defined.
*/
#define INT_64_T                NV


/* USE_TM64
   Should we use a 64 bit safe replacement for tm?  This will
   let you go past year 2 billion but the struct will be incompatible
   with tm.  Conversion functions will be provided.
*/
#define USE_TM64


/* Availability of system functions.

   HAS_GMTIME_R
   Define if your system has gmtime_r()

   HAS_LOCALTIME_R
   Define if your system has localtime_r()

   HAS_TIMEGM
   Define if your system has timegm(), a GNU extension.
*/
/* Set in config.h */


/* Details of non-standard tm struct elements.

   HAS_TM_TM_GMTOFF
   True if your tm struct has a "tm_gmtoff" element.
   A BSD extension.

   HAS_TM_TM_ZONE
   True if your tm struct has a "tm_zone" element.
   A BSD extension.
*/
/* Set in config.h */


/* USE_SYSTEM_LOCALTIME
   USE_SYSTEM_GMTIME
   Should we use the system functions if the time is inside their range?
   Your system localtime() is probably more accurate, but our gmtime() is
   fast and safe.  Except on VMS, where we need the homegrown gmtime()
   override to shift between UTC and local for the vmsish 'time' pragma.
*/
#define USE_SYSTEM_LOCALTIME
#ifdef VMS
#  define USE_SYSTEM_GMTIME
#endif


/* SYSTEM_LOCALTIME_MAX
   SYSTEM_LOCALTIME_MIN
   SYSTEM_GMTIME_MAX
   SYSTEM_GMTIME_MIN
   Maximum and minimum values your system's gmtime() and localtime()
   can handle.  We will use your system functions if the time falls
   inside these ranges.
*/
#define SYSTEM_LOCALTIME_MAX    CAT2(LOCALTIME_MAX,.0)
#define SYSTEM_LOCALTIME_MIN    CAT2(LOCALTIME_MIN,.0)
#define SYSTEM_GMTIME_MAX       CAT2(GMTIME_MAX,.0)
#define SYSTEM_GMTIME_MIN       CAT2(GMTIME_MIN,.0)

#endif /* TIME64_CONFIG_H */
                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/uconfig.h                                                 0100644 0000000 0000000 00000440336 12744441327 017551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* This file was produced by running the config_h.SH script, which
 * gets its values from uconfig.sh, which is generally produced by
 * running Configure.
 *
 * Feel free to modify any of this as the need arises.  Note, however,
 * that running config_h.SH again will wipe out any changes you've made.
 * For a more permanent change edit uconfig.sh and rerun config_h.SH.
 */

/* Package name      : perl5
 * Source directory  : .
 * Configuration time: Thu Jan  1 00:00:00 GMT 1970
 * Configured by     : root@localhost
 * Target system     : unknown
 */

#ifndef _config_h_
#define _config_h_

/* LOC_SED:
 *	This symbol holds the complete pathname to the sed program.
 */
#define LOC_SED 	""	/**/

/* HAS_ALARM:
 *	This symbol, if defined, indicates that the alarm routine is
 *	available.
 */
/*#define HAS_ALARM		/ **/

/* HAS_BCMP:
 *	This symbol is defined if the bcmp() routine is available to
 *	compare blocks of memory.
 */
/*#define HAS_BCMP	/ **/

/* HAS_BCOPY:
 *	This symbol is defined if the bcopy() routine is available to
 *	copy blocks of memory.
 */
/*#define HAS_BCOPY	/ **/

/* HAS_BZERO:
 *	This symbol is defined if the bzero() routine is available to
 *	set a memory block to 0.
 */
/*#define HAS_BZERO	/ **/

/* HAS_CHOWN:
 *	This symbol, if defined, indicates that the chown routine is
 *	available.
 */
/*#define HAS_CHOWN		/ **/

/* HAS_CHROOT:
 *	This symbol, if defined, indicates that the chroot routine is
 *	available.
 */
/*#define HAS_CHROOT		/ **/

/* HAS_CHSIZE:
 *	This symbol, if defined, indicates that the chsize routine is available
 *	to truncate files.  You might need a -lx to get this routine.
 */
/*#define	HAS_CHSIZE		/ **/

/* HAS_CRYPT:
 *	This symbol, if defined, indicates that the crypt routine is available
 *	to encrypt passwords and the like.
 */
/*#define HAS_CRYPT		/ **/

/* HAS_CTERMID:
 *	This symbol, if defined, indicates that the ctermid routine is
 *	available to generate filename for terminal.
 */
/*#define HAS_CTERMID		/ **/

/* HAS_CUSERID:
 *	This symbol, if defined, indicates that the cuserid routine is
 *	available to get character login names.
 */
/*#define HAS_CUSERID		/ **/

/* HAS_DBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol DBL_DIG, which is the number
 *	of significant digits in a double precision number.  If this
 *	symbol is not defined, a guess of 15 is usually pretty good.
 */
/*#define HAS_DBL_DIG 	/ **/

/* HAS_DIFFTIME:
 *	This symbol, if defined, indicates that the difftime routine is
 *	available.
 */
/*#define HAS_DIFFTIME		/ **/

/* HAS_DLERROR:
 *	This symbol, if defined, indicates that the dlerror routine is
 *	available to return a string describing the last error that
 *	occurred from a call to dlopen(), dlclose() or dlsym().
 */
/*#define HAS_DLERROR	/ **/

/* HAS_DUP2:
 *	This symbol, if defined, indicates that the dup2 routine is
 *	available to duplicate file descriptors.
 */
/*#define HAS_DUP2	/ **/

/* HAS_FCHMOD:
 *	This symbol, if defined, indicates that the fchmod routine is available
 *	to change mode of opened files.  If unavailable, use chmod().
 */
/*#define HAS_FCHMOD		/ **/

/* HAS_FCHOWN:
 *	This symbol, if defined, indicates that the fchown routine is available
 *	to change ownership of opened files.  If unavailable, use chown().
 */
/*#define HAS_FCHOWN		/ **/

/* HAS_FCNTL:
 *	This symbol, if defined, indicates to the C program that
 *	the fcntl() function exists.
 */
/*#define HAS_FCNTL		/ **/

/* HAS_FGETPOS:
 *	This symbol, if defined, indicates that the fgetpos routine is
 *	available to get the file position indicator, similar to ftell().
 */
/*#define HAS_FGETPOS	/ **/

/* HAS_FLOCK:
 *	This symbol, if defined, indicates that the flock routine is
 *	available to do file locking.
 */
/*#define HAS_FLOCK		/ **/

/* HAS_FORK:
 *	This symbol, if defined, indicates that the fork routine is
 *	available.
 */
#define HAS_FORK		/**/

/* HAS_FSETPOS:
 *	This symbol, if defined, indicates that the fsetpos routine is
 *	available to set the file position indicator, similar to fseek().
 */
/*#define HAS_FSETPOS	/ **/

/* HAS_GETTIMEOFDAY:
 *	This symbol, if defined, indicates that the gettimeofday() system
 *	call is available for a sub-second accuracy clock. Usually, the file
 *	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
 *	The type "Timeval" should be used to refer to "struct timeval".
 */
/*#define HAS_GETTIMEOFDAY	/ **/
#ifdef HAS_GETTIMEOFDAY
#define Timeval struct timeval	/* Structure used by gettimeofday() */
#endif

/* HAS_GETGROUPS:
 *	This symbol, if defined, indicates that the getgroups() routine is
 *	available to get the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_GETGROUPS		/ **/

/* HAS_GETLOGIN:
 *	This symbol, if defined, indicates that the getlogin routine is
 *	available to get the login name.
 */
/*#define HAS_GETLOGIN		/ **/

/* HAS_GETPGID:
 *	This symbol, if defined, indicates to the C program that 
 *	the getpgid(pid) function is available to get the
 *	process group id.
 */
/*#define HAS_GETPGID		/ **/

/* HAS_GETPGRP2:
 *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
 *	routine is available to get the current process group.
 */
/*#define HAS_GETPGRP2		/ **/

/* HAS_GETPPID:
 *	This symbol, if defined, indicates that the getppid routine is
 *	available to get the parent process ID.
 */
/*#define HAS_GETPPID		/ **/

/* HAS_GETPRIORITY:
 *	This symbol, if defined, indicates that the getpriority routine is
 *	available to get a process's priority.
 */
/*#define HAS_GETPRIORITY		/ **/

/* HAS_INET_ATON:
 *	This symbol, if defined, indicates to the C program that the
 *	inet_aton() function is available to parse IP address "dotted-quad"
 *	strings.
 */
/*#define HAS_INET_ATON		/ **/

/* HAS_KILLPG:
 *	This symbol, if defined, indicates that the killpg routine is available
 *	to kill process groups.  If unavailable, you probably should use kill
 *	with a negative process number.
 */
/*#define HAS_KILLPG	/ **/

/* HAS_LINK:
 *	This symbol, if defined, indicates that the link routine is
 *	available to create hard links.
 */
/*#define HAS_LINK	/ **/

/* HAS_LOCALECONV:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available for numeric and monetary formatting conventions.
 */
/*#define HAS_LOCALECONV	/ **/

/* HAS_LOCKF:
 *	This symbol, if defined, indicates that the lockf routine is
 *	available to do file locking.
 */
/*#define HAS_LOCKF		/ **/

/* HAS_LSTAT:
 *	This symbol, if defined, indicates that the lstat routine is
 *	available to do file stats on symbolic links.
 */
/*#define HAS_LSTAT		/ **/

/* HAS_MBLEN:
 *	This symbol, if defined, indicates that the mblen routine is available
 *	to find the number of bytes in a multibye character.
 */
/*#define HAS_MBLEN		/ **/

/* HAS_MBSTOWCS:
 *	This symbol, if defined, indicates that the mbstowcs routine is
 *	available to covert a multibyte string into a wide character string.
 */
/*#define	HAS_MBSTOWCS		/ **/

/* HAS_MBTOWC:
 *	This symbol, if defined, indicates that the mbtowc routine is available
 *	to covert a multibyte to a wide character.
 */
/*#define HAS_MBTOWC		/ **/

/* HAS_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	to compare blocks of memory.
 */
#define HAS_MEMCMP	/**/

/* HAS_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy blocks of memory.
 */
#define HAS_MEMCPY	/**/

/* HAS_MEMMOVE:
 *	This symbol, if defined, indicates that the memmove routine is available
 *	to copy potentially overlapping blocks of memory. This should be used
 *	only when HAS_SAFE_BCOPY is not defined. If neither is there, roll your
 *	own version.
 */
/*#define HAS_MEMMOVE	/ **/

/* HAS_MEMSET:
 *	This symbol, if defined, indicates that the memset routine is available
 *	to set blocks of memory.
 */
#define HAS_MEMSET	/**/

/* HAS_MKDIR:
 *	This symbol, if defined, indicates that the mkdir routine is available
 *	to create directories.  Otherwise you should fork off a new process to
 *	exec /bin/mkdir.
 */
/*#define HAS_MKDIR		/ **/

/* HAS_MKFIFO:
 *	This symbol, if defined, indicates that the mkfifo routine is
 *	available to create FIFOs. Otherwise, mknod should be able to
 *	do it for you. However, if mkfifo is there, mknod might require
 *	super-user privileges which mkfifo will not.
 */
/*#define HAS_MKFIFO		/ **/

/* HAS_MKTIME:
 *	This symbol, if defined, indicates that the mktime routine is
 *	available.
 */
/*#define HAS_MKTIME		/ **/

/* HAS_MSYNC:
 *	This symbol, if defined, indicates that the msync system call is
 *	available to synchronize a mapped file.
 */
/*#define HAS_MSYNC		/ **/

/* HAS_MUNMAP:
 *	This symbol, if defined, indicates that the munmap system call is
 *	available to unmap a region, usually mapped by mmap().
 */
/*#define HAS_MUNMAP		/ **/

/* HAS_NICE:
 *	This symbol, if defined, indicates that the nice routine is
 *	available.
 */
/*#define HAS_NICE		/ **/

/* HAS_PATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given filename.
 */
/* HAS_FPATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given open file descriptor.
 */
/*#define HAS_PATHCONF		/ **/
/*#define HAS_FPATHCONF		/ **/

/* HAS_PAUSE:
 *	This symbol, if defined, indicates that the pause routine is
 *	available to suspend a process until a signal is received.
 */
/*#define HAS_PAUSE		/ **/

/* HAS_PIPE:
 *	This symbol, if defined, indicates that the pipe routine is
 *	available to create an inter-process channel.
 */
/*#define HAS_PIPE		/ **/

/* HAS_POLL:
 *	This symbol, if defined, indicates that the poll routine is
 *	available to poll active file descriptors.  Please check I_POLL and
 *	I_SYS_POLL to know which header should be included as well.
 */
/*#define HAS_POLL		/ **/

/* HAS_READDIR:
 *	This symbol, if defined, indicates that the readdir routine is
 *	available to read directory entries. You may have to include
 *	<dirent.h>. See I_DIRENT.
 */
#define HAS_READDIR		/**/

/* HAS_SEEKDIR:
 *	This symbol, if defined, indicates that the seekdir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_SEEKDIR		/ **/

/* HAS_TELLDIR:
 *	This symbol, if defined, indicates that the telldir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_TELLDIR		/ **/

/* HAS_REWINDDIR:
 *	This symbol, if defined, indicates that the rewinddir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_REWINDDIR		/ **/

/* HAS_READLINK:
 *	This symbol, if defined, indicates that the readlink routine is
 *	available to read the value of a symbolic link.
 */
/*#define HAS_READLINK		/ **/

/* HAS_RENAME:
 *	This symbol, if defined, indicates that the rename routine is available
 *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
 *	trick.
 */
#define HAS_RENAME	/**/

/* HAS_RMDIR:
 *	This symbol, if defined, indicates that the rmdir routine is
 *	available to remove directories. Otherwise you should fork off a
 *	new process to exec /bin/rmdir.
 */
/*#define HAS_RMDIR		/ **/

/* HAS_SELECT:
 *	This symbol, if defined, indicates that the select routine is
 *	available to select active file descriptors. If the timeout field
 *	is used, <sys/time.h> may need to be included.
 */
/*#define HAS_SELECT	/ **/

/* HAS_SETEGID:
 *	This symbol, if defined, indicates that the setegid routine is available
 *	to change the effective gid of the current program.
 */
/*#define HAS_SETEGID		/ **/

/* HAS_SETEUID:
 *	This symbol, if defined, indicates that the seteuid routine is available
 *	to change the effective uid of the current program.
 */
/*#define HAS_SETEUID		/ **/

/* HAS_SETGROUPS:
 *	This symbol, if defined, indicates that the setgroups() routine is
 *	available to set the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_SETGROUPS		/ **/

/* HAS_SETLINEBUF:
 *	This symbol, if defined, indicates that the setlinebuf routine is
 *	available to change stderr or stdout from block-buffered or unbuffered
 *	to a line-buffered mode.
 */
/*#define HAS_SETLINEBUF		/ **/

/* HAS_SETLOCALE:
 *	This symbol, if defined, indicates that the setlocale routine is
 *	available to handle locale-specific ctype implementations.
 */
/*#define HAS_SETLOCALE	/ **/

/* HAS_SETPGID:
 *	This symbol, if defined, indicates that the setpgid(pid, gpid)
 *	routine is available to set process group ID.
 */
/*#define HAS_SETPGID	/ **/

/* HAS_SETPGRP2:
 *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
 *	routine is available to set the current process group.
 */
/*#define HAS_SETPGRP2		/ **/

/* HAS_SETPRIORITY:
 *	This symbol, if defined, indicates that the setpriority routine is
 *	available to set a process's priority.
 */
/*#define HAS_SETPRIORITY		/ **/

/* HAS_SETREGID:
 *	This symbol, if defined, indicates that the setregid routine is
 *	available to change the real and effective gid of the current
 *	process.
 */
/* HAS_SETRESGID:
 *	This symbol, if defined, indicates that the setresgid routine is
 *	available to change the real, effective and saved gid of the current
 *	process.
 */
/*#define HAS_SETREGID		/ **/
/*#define HAS_SETRESGID		/ **/

/* HAS_SETREUID:
 *	This symbol, if defined, indicates that the setreuid routine is
 *	available to change the real and effective uid of the current
 *	process.
 */
/* HAS_SETRESUID:
 *	This symbol, if defined, indicates that the setresuid routine is
 *	available to change the real, effective and saved uid of the current
 *	process.
 */
/*#define HAS_SETREUID		/ **/
/*#define HAS_SETRESUID		/ **/

/* HAS_SETRGID:
 *	This symbol, if defined, indicates that the setrgid routine is available
 *	to change the real gid of the current program.
 */
/*#define HAS_SETRGID		/ **/

/* HAS_SETRUID:
 *	This symbol, if defined, indicates that the setruid routine is available
 *	to change the real uid of the current program.
 */
/*#define HAS_SETRUID		/ **/

/* HAS_SETSID:
 *	This symbol, if defined, indicates that the setsid routine is
 *	available to set the process group ID.
 */
/*#define HAS_SETSID	/ **/

/* HAS_STRCHR:
 *	This symbol is defined to indicate that the strchr()/strrchr()
 *	functions are available for string searching. If not, try the
 *	index()/rindex() pair.
 */
/* HAS_INDEX:
 *	This symbol is defined to indicate that the index()/rindex()
 *	functions are available for string searching.
 */
/*#define HAS_STRCHR	/ **/
/*#define HAS_INDEX	/ **/

/* HAS_STRCOLL:
 *	This symbol, if defined, indicates that the strcoll routine is
 *	available to compare strings using collating information.
 */
/*#define HAS_STRCOLL	/ **/

/* HAS_STRTOD:
 *	This symbol, if defined, indicates that the strtod routine is
 *	available to provide better numeric string conversion than atof().
 */
/*#define HAS_STRTOD	/ **/

/* HAS_STRTOL:
 *	This symbol, if defined, indicates that the strtol routine is available
 *	to provide better numeric string conversion than atoi() and friends.
 */
#define HAS_STRTOL	/**/

/* HAS_STRXFRM:
 *	This symbol, if defined, indicates that the strxfrm() routine is
 *	available to transform strings.
 */
/*#define HAS_STRXFRM	/ **/

/* HAS_SYMLINK:
 *	This symbol, if defined, indicates that the symlink routine is available
 *	to create symbolic links.
 */
/*#define HAS_SYMLINK	/ **/

/* HAS_SYSCALL:
 *	This symbol, if defined, indicates that the syscall routine is
 *	available to call arbitrary system calls. If undefined, that's tough.
 */
/*#define HAS_SYSCALL	/ **/

/* HAS_SYSCONF:
 *	This symbol, if defined, indicates that sysconf() is available
 *	to determine system related limits and options.
 */
/*#define HAS_SYSCONF	/ **/

/* HAS_SYSTEM:
 *	This symbol, if defined, indicates that the system routine is
 *	available to issue a shell command.
 */
/*#define HAS_SYSTEM	/ **/

/* HAS_TCGETPGRP:
 *	This symbol, if defined, indicates that the tcgetpgrp routine is
 *	available to get foreground process group ID.
 */
/*#define HAS_TCGETPGRP		/ **/

/* HAS_TCSETPGRP:
 *	This symbol, if defined, indicates that the tcsetpgrp routine is
 *	available to set foreground process group ID.
 */
/*#define HAS_TCSETPGRP		/ **/

/* HAS_TRUNCATE:
 *	This symbol, if defined, indicates that the truncate routine is
 *	available to truncate files.
 */
/*#define HAS_TRUNCATE	/ **/

/* HAS_TZNAME:
 *	This symbol, if defined, indicates that the tzname[] array is
 *	available to access timezone names.
 */
/*#define HAS_TZNAME		/ **/

/* HAS_UMASK:
 *	This symbol, if defined, indicates that the umask routine is
 *	available to set and get the value of the file creation mask.
 */
/*#define HAS_UMASK		/ **/

/* HAS_USLEEP:
 *	This symbol, if defined, indicates that the usleep routine is
 *	available to let the process sleep on a sub-second accuracy.
 */
/*#define HAS_USLEEP		/ **/

/* HAS_WAIT4:
 *	This symbol, if defined, indicates that wait4() exists.
 */
/*#define HAS_WAIT4	/ **/

/* HAS_WAITPID:
 *	This symbol, if defined, indicates that the waitpid routine is
 *	available to wait for child process.
 */
/*#define HAS_WAITPID	/ **/

/* HAS_WCSTOMBS:
 *	This symbol, if defined, indicates that the wcstombs routine is
 *	available to convert wide character strings to multibyte strings.
 */
/*#define HAS_WCSTOMBS	/ **/

/* HAS_WCTOMB:
 *	This symbol, if defined, indicates that the wctomb routine is available
 *	to covert a wide character to a multibyte.
 */
/*#define HAS_WCTOMB		/ **/

/* Groups_t:
 *	This symbol holds the type used for the second argument to
 *	getgroups() and setgroups().  Usually, this is the same as
 *	gidtype (gid_t) , but sometimes it isn't.
 *	It can be int, ushort, gid_t, etc... 
 *	It may be necessary to include <sys/types.h> to get any 
 *	typedef'ed information.  This is only required if you have
 *	getgroups() or setgroups()..
 */
#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#define Groups_t int	/* Type for 2nd arg to [sg]etgroups() */
#endif

/* I_ARPA_INET:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <arpa/inet.h> to get inet_addr and friends declarations.
 */
/*#define	I_ARPA_INET		/ **/

/* I_DBM:
 *	This symbol, if defined, indicates that <dbm.h> exists and should
 *	be included.
 */
/* I_RPCSVC_DBM:
 *	This symbol, if defined, indicates that <rpcsvc/dbm.h> exists and
 *	should be included.
 */
/*#define I_DBM	/ **/
/*#define I_RPCSVC_DBM	/ **/

/* I_DLFCN:
 *	This symbol, if defined, indicates that <dlfcn.h> exists and should
 *	be included.
 */
/*#define I_DLFCN		/ **/

/* I_FCNTL:
 *	This manifest constant tells the C program to include <fcntl.h>.
 */
/*#define I_FCNTL	/ **/

/* I_FLOAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <float.h> to get definition of symbols like DBL_MAX or
 *	DBL_MIN, i.e. machine dependent floating point values.
 */
/*#define I_FLOAT		/ **/

/* I_GDBM:
 *	This symbol, if defined, indicates that <gdbm.h> exists and should
 *	be included.
 */
/*#define I_GDBM	/ **/

/* I_LIMITS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <limits.h> to get definition of symbols like WORD_BIT or
 *	LONG_MAX, i.e. machine dependant limitations.
 */
/*#define I_LIMITS		/ **/

/* I_LOCALE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <locale.h>.
 */
/*#define	I_LOCALE		/ **/

/* I_MATH:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <math.h>.
 */
#define I_MATH		/**/

/* I_MEMORY:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <memory.h>.
 */
/*#define I_MEMORY		/ **/

/* I_NETINET_IN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <netinet/in.h>. Otherwise, you may try <sys/in.h>.
 */
/*#define I_NETINET_IN	/ **/

/* I_STDDEF:
 *	This symbol, if defined, indicates that <stddef.h> exists and should
 *	be included.
 */
#define I_STDDEF	/**/

/* I_STDLIB:
 *	This symbol, if defined, indicates that <stdlib.h> exists and should
 *	be included.
 */
#define I_STDLIB		/**/

/* I_STRING:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
 */
#define I_STRING		/**/

/* I_SYS_DIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/dir.h>.
 */
/*#define I_SYS_DIR		/ **/

/* I_SYS_FILE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/file.h> to get definition of R_OK and friends.
 */
/*#define I_SYS_FILE		/ **/

/* I_SYS_IOCTL:
 *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
 *	be included. Otherwise, include <sgtty.h> or <termio.h>.
 */
/* I_SYS_SOCKIO:
 *	This symbol, if defined, indicates the <sys/sockio.h> should be included
 *	to get socket ioctl options, like SIOCATMARK.
 */
/*#define	I_SYS_IOCTL		/ **/
/*#define I_SYS_SOCKIO	/ **/

/* I_SYS_NDIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/ndir.h>.
 */
/*#define I_SYS_NDIR	/ **/

/* I_SYS_PARAM:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/param.h>.
 */
/*#define I_SYS_PARAM		/ **/

/* I_SYS_POLL:
 *	This symbol, if defined, indicates that the program may include
 *	<sys/poll.h>.  When I_POLL is also defined, it's probably safest
 *	to only include <poll.h>.
 */
/*#define I_SYS_POLL	/ **/

/* I_SYS_RESOURCE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/resource.h>.
 */
/*#define I_SYS_RESOURCE		/ **/

/* I_SYS_SELECT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/select.h> in order to get definition of struct timeval.
 */
/*#define I_SYS_SELECT	/ **/

/* I_SYS_STAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/stat.h>.
 */
#define	I_SYS_STAT		/**/

/* I_SYS_TIMES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/times.h>.
 */
/*#define	I_SYS_TIMES		/ **/

/* I_SYS_TYPES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/types.h>.
 */
/*#define	I_SYS_TYPES		/ **/

/* I_SYS_UN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/un.h> to get UNIX domain socket definitions.
 */
/*#define I_SYS_UN		/ **/

/* I_SYS_WAIT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/wait.h>.
 */
/*#define I_SYS_WAIT	/ **/

/* I_UNISTD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <unistd.h>.
 */
/*#define I_UNISTD		/ **/

/* I_UTIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <utime.h>.
 */
/*#define I_UTIME		/ **/

/* I_VALUES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <values.h> to get definition of symbols like MINFLOAT or
 *	MAXLONG, i.e. machine dependant limitations.  Probably, you
 *	should use <limits.h> instead, if it is available.
 */
/*#define I_VALUES		/ **/

/* I_VFORK:
 *	This symbol, if defined, indicates to the C program that it should
 *	include vfork.h.
 */
/*#define I_VFORK	/ **/

/* CAN_VAPROTO:
 *	This variable is defined on systems supporting prototype declaration
 *	of functions with a variable number of arguments.
 */
/* _V:
 *	This macro is used to declare function parameters in prototypes for
 *	functions with a variable number of parameters. Use double parentheses.
 *	For example:
 *
 *		int printf _V((char *fmt, ...));
 *
 *	Remember to use the plain simple _() macro when declaring a function
 *	with no variable number of arguments, since it might be possible to
 *	have a non-effect _V() macro and still get prototypes via _().
 */
/*#define CAN_VAPROTO	/ **/
#ifdef CAN_VAPROTO
#define	_V(args) args
#else
#define	_V(args) ()
#endif

/* OSNAME:
 *	This symbol contains the name of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
/* OSVERS:
 *	This symbol contains the version of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
#define OSNAME "unknown"		/**/
#define OSVERS "unknown"		/**/

/* MULTIARCH:
 *	This symbol, if defined, signifies that the build
 *	process will produce some binary files that are going to be
 *	used in a cross-platform environment.  This is the case for
 *	example with the NeXT "fat" binaries that contain executables
 *	for several CPUs.
 */
/*#define MULTIARCH		/ **/

/* MEM_ALIGNBYTES:
 *	This symbol contains the number of bytes required to align a
 *	double, or a long double when applicable. Usual values are 2,
 *	4 and 8. The default is eight, for safety.  For cross-compiling
 *  	or multiarch support, Configure will set a minimum of 8.
 */
#define MEM_ALIGNBYTES 4

/* ARCHLIB:
 *	This variable, if defined, holds the name of the directory in
 *	which the user wants to put architecture-dependent public
 *	library files for perl5.  It is most often a local directory
 *	such as /usr/local/lib.  Programs using this variable must be
 *	prepared to deal with filename expansion.  If ARCHLIB is the
 *	same as PRIVLIB, it is not defined, since presumably the
 *	program already searches PRIVLIB.
 */
/* ARCHLIB_EXP:
 *	This symbol contains the ~name expanded version of ARCHLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define ARCHLIB "/usr/local/lib/perl5/5.20/unknown"		/ **/
/*#define ARCHLIB_EXP "/usr/local/lib/perl5/5.20/unknown"		/ **/

/* ARCHNAME:
 *	This symbol holds a string representing the architecture name.
 *	It may be used to construct an architecture-dependant pathname
 *	where library files may be held under a private library, for
 *	instance.
 */
#define ARCHNAME "unknown"		/**/

/* BIN:
 *	This symbol holds the path of the bin directory where the package will
 *	be installed. Program must be prepared to deal with ~name substitution.
 */
/* BIN_EXP:
 *	This symbol is the filename expanded version of the BIN symbol, for
 *	programs that do not want to deal with that at run-time.
 */
/* PERL_RELOCATABLE_INC:
 *	This symbol, if defined, indicates that we'd like to relocate entries
 *	in @INC at run time based on the location of the perl binary.
 */
#define BIN "/usr/local/bin"	/**/
#define BIN_EXP "/usr/local/bin"	/**/
#define PERL_RELOCATABLE_INC "undef" 		/**/

/* INTSIZE:
 *	This symbol contains the value of sizeof(int) so that the C
 *	preprocessor can make decisions based on it.
 */
/* LONGSIZE:
 *	This symbol contains the value of sizeof(long) so that the C
 *	preprocessor can make decisions based on it.
 */
/* SHORTSIZE:
 *	This symbol contains the value of sizeof(short) so that the C
 *	preprocessor can make decisions based on it.
 */
#define INTSIZE 4		/**/
#define LONGSIZE 4		/**/
#define SHORTSIZE 2		/**/

/* BYTEORDER:
 *	This symbol holds the hexadecimal constant defined in byteorder,
 *	in a UV, i.e. 0x1234 or 0x4321 or 0x12345678, etc...
 *	If the compiler supports cross-compiling or multiple-architecture
 *	binaries (e.g. on NeXT systems), use compiler-defined macros to
 *	determine the byte order.
 *	On NeXT 3.2 (and greater), you can build "Fat" Multiple Architecture
 *	Binaries (MAB) on either big endian or little endian machines.
 *	The endian-ness is available at compile-time.  This only matters
 *	for perl, where the config.h can be generated and installed on
 *	one system, and used by a different architecture to build an
 *	extension.  Older versions of NeXT that might not have
 *	defined either *_ENDIAN__ were all on Motorola 680x0 series,
 *	so the default case (for NeXT) is big endian to catch them.
 *	This might matter for NeXT 3.0.
 */
#if defined(MULTIARCH)
#  ifdef __LITTLE_ENDIAN__
#    if LONGSIZE == 4
#      define BYTEORDER 0x1234
#    else
#      if LONGSIZE == 8
#        define BYTEORDER 0x12345678
#      endif
#    endif
#  else
#    ifdef __BIG_ENDIAN__
#      if LONGSIZE == 4
#        define BYTEORDER 0x4321
#      else
#        if LONGSIZE == 8
#          define BYTEORDER 0x87654321
#        endif
#      endif
#    endif
#  endif
#  if !defined(BYTEORDER) && (defined(NeXT) || defined(__NeXT__))
#    define BYTEORDER 0x4321
#  endif
#else
#define BYTEORDER 0x1234	/* large digits for MSB */
#endif /* NeXT */

/* CHARBITS:
 *	This symbol contains the size of a char, so that the C preprocessor
 *	can make decisions based on it.
 */
#define CHARBITS 8		/**/

/* CAT2:
 *	This macro concatenates 2 tokens together.
 */
/* STRINGIFY:
 *	This macro surrounds its token with double quotes.
 */
#if 42 == 1
#define CAT2(a,b)	a/**/b
#define STRINGIFY(a)	"a"
#endif
#if 42 == 42
#define PeRl_CaTiFy(a, b)	a ## b
#define PeRl_StGiFy(a)	#a
#define CAT2(a,b)	PeRl_CaTiFy(a,b)
#define StGiFy(a)	PeRl_StGiFy(a)
#define STRINGIFY(a)	PeRl_StGiFy(a)
#endif
#if 42 != 1 && 42 != 42
#include "Bletch: How does this C preprocessor concatenate tokens?"
#endif

/* CPPSTDIN:
 *	This symbol contains the first part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.	 Typical value of "cc -E" or "/lib/cpp", but it can also
 *	call a wrapper. See CPPRUN.
 */
/* CPPMINUS:
 *	This symbol contains the second part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
 *	to specify standard input, otherwise the value is "".
 */
/* CPPRUN:
 *	This symbol contains the string which will invoke a C preprocessor on
 *	the standard input and produce to standard output. It needs to end
 *	with CPPLAST, after all other preprocessor flags have been specified.
 *	The main difference with CPPSTDIN is that this program will never be a
 *	pointer to a shell wrapper, i.e. it will be empty if no preprocessor is
 *	available directly to the user. Note that it may well be different from
 *	the preprocessor used to compile the C program.
 */
/* CPPLAST:
 *	This symbol is intended to be used along with CPPRUN in the same manner
 *	symbol CPPMINUS is used with CPPSTDIN. It contains either "-" or "".
 */
#define CPPSTDIN "cc -E"
#define CPPMINUS "-"
#define CPPRUN "cc -E"
#define CPPLAST "-"

/* HAS_ACCESS:
 *	This manifest constant lets the C program know that the access()
 *	system call is available to check for accessibility using real UID/GID.
 *	(always present on UNIX.)
 */
/*#define HAS_ACCESS		/ **/

/* HAS_ACCESSX:
 *	This symbol, if defined, indicates that the accessx routine is
 *	available to do extended access checks.
 */
/*#define HAS_ACCESSX		/ **/

/* HAS_ASCTIME_R:
 *	This symbol, if defined, indicates that the asctime_r routine
 *	is available to asctime re-entrantly.
 */
/* ASCTIME_R_PROTO:
 *	This symbol encodes the prototype of asctime_r.
 *	It is zero if d_asctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_asctime_r
 *	is defined.
 */
/*#define HAS_ASCTIME_R	   / **/
#define ASCTIME_R_PROTO 0	   /**/

/* HASATTRIBUTE_FORMAT:
 *	Can we handle GCC attribute for checking printf-style formats
 */
/* PRINTF_FORMAT_NULL_OK:
 *	Allows __printf__ format to be null when checking printf-style
 */
/* HASATTRIBUTE_MALLOC:
 *	Can we handle GCC attribute for malloc-style functions.
 */
/* HASATTRIBUTE_NONNULL:
 *	Can we handle GCC attribute for nonnull function parms.
 */
/* HASATTRIBUTE_NORETURN:
 *	Can we handle GCC attribute for functions that do not return
 */
/* HASATTRIBUTE_PURE:
 *	Can we handle GCC attribute for pure functions
 */
/* HASATTRIBUTE_UNUSED:
 *	Can we handle GCC attribute for unused variables and arguments
 */
/* HASATTRIBUTE_DEPRECATED:
 *	Can we handle GCC attribute for marking deprecated APIs
 */
/* HASATTRIBUTE_WARN_UNUSED_RESULT:
 *	Can we handle GCC attribute for warning on unused results
 */
/*#define HASATTRIBUTE_DEPRECATED	/ **/
/*#define HASATTRIBUTE_FORMAT	/ **/
/*#define PRINTF_FORMAT_NULL_OK	/ **/
/*#define HASATTRIBUTE_NORETURN	/ **/
/*#define HASATTRIBUTE_MALLOC	/ **/
/*#define HASATTRIBUTE_NONNULL	/ **/
/*#define HASATTRIBUTE_PURE	/ **/
/*#define HASATTRIBUTE_UNUSED	/ **/
/*#define HASATTRIBUTE_WARN_UNUSED_RESULT	/ **/

/* CASTI32:
 *	This symbol is defined if the C compiler can cast negative
 *	or large floating point numbers to 32-bit ints.
 */
/*#define	CASTI32		/ **/

/* CASTNEGFLOAT:
 *	This symbol is defined if the C compiler can cast negative
 *	numbers to unsigned longs, ints and shorts.
 */
/* CASTFLAGS:
 *	This symbol contains flags that say what difficulties the compiler
 *	has casting odd floating values to unsigned long:
 *		0 = ok
 *		1 = couldn't cast < 0
 *		2 = couldn't cast >= 0x80000000
 *		4 = couldn't cast in argument expression list
 */
/*#define	CASTNEGFLOAT		/ **/
#define CASTFLAGS 0		/**/

/* VOID_CLOSEDIR:
 *	This symbol, if defined, indicates that the closedir() routine
 *	does not return a value.
 */
/*#define VOID_CLOSEDIR		/ **/

/* HASCONST:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the const type. There is no need to actually test for that symbol
 *	within your programs. The mere use of the "const" keyword will
 *	trigger the necessary tests.
 */
/*#define HASCONST	/ **/
#ifndef HASCONST
#define const
#endif

/* HAS_CRYPT_R:
 *	This symbol, if defined, indicates that the crypt_r routine
 *	is available to crypt re-entrantly.
 */
/* CRYPT_R_PROTO:
 *	This symbol encodes the prototype of crypt_r.
 *	It is zero if d_crypt_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_crypt_r
 *	is defined.
 */
/*#define HAS_CRYPT_R	   / **/
#define CRYPT_R_PROTO 0	   /**/

/* HAS_CSH:
 *	This symbol, if defined, indicates that the C-shell exists.
 */
/* CSH:
 *	This symbol, if defined, contains the full pathname of csh.
 */
/*#define HAS_CSH		/ **/
#ifdef HAS_CSH
#define CSH ""	/**/
#endif

/* HAS_CTERMID_R:
 *	This symbol, if defined, indicates that the ctermid_r routine
 *	is available to ctermid re-entrantly.
 */
/* CTERMID_R_PROTO:
 *	This symbol encodes the prototype of ctermid_r.
 *	It is zero if d_ctermid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctermid_r
 *	is defined.
 */
/*#define HAS_CTERMID_R	   / **/
#define CTERMID_R_PROTO 0	   /**/

/* HAS_CTIME_R:
 *	This symbol, if defined, indicates that the ctime_r routine
 *	is available to ctime re-entrantly.
 */
/* CTIME_R_PROTO:
 *	This symbol encodes the prototype of ctime_r.
 *	It is zero if d_ctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctime_r
 *	is defined.
 */
/*#define HAS_CTIME_R	   / **/
#define CTIME_R_PROTO 0	   /**/

/* SETUID_SCRIPTS_ARE_SECURE_NOW:
 *	This symbol, if defined, indicates that the bug that prevents
 *	setuid scripts from being secure is not present in this kernel.
 */
/* DOSUID:
 *	This symbol, if defined, indicates that the C program should
 *	check the script that it is executing for setuid/setgid bits, and
 *	attempt to emulate setuid/setgid on systems that have disabled
 *	setuid #! scripts because the kernel can't do it securely.
 *	It is up to the package designer to make sure that this emulation
 *	is done securely.  Among other things, it should do an fstat on
 *	the script it just opened to make sure it really is a setuid/setgid
 *	script, it should make sure the arguments passed correspond exactly
 *	to the argument on the #! line, and it should not trust any
 *	subprocesses to which it must pass the filename rather than the
 *	file descriptor of the script to be executed.
 */
/*#define SETUID_SCRIPTS_ARE_SECURE_NOW	/ **/
/*#define DOSUID		/ **/

/* HAS_DRAND48_R:
 *	This symbol, if defined, indicates that the drand48_r routine
 *	is available to drand48 re-entrantly.
 */
/* DRAND48_R_PROTO:
 *	This symbol encodes the prototype of drand48_r.
 *	It is zero if d_drand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_drand48_r
 *	is defined.
 */
/*#define HAS_DRAND48_R	   / **/
#define DRAND48_R_PROTO 0	   /**/

/* HAS_DRAND48_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the drand48() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern double drand48(void);
 */
/*#define	HAS_DRAND48_PROTO	/ **/

/* HAS_EACCESS:
 *	This symbol, if defined, indicates that the eaccess routine is
 *	available to do extended access checks.
 */
/*#define HAS_EACCESS		/ **/

/* HAS_ENDGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the group database.
 */
/*#define HAS_ENDGRENT		/ **/

/* HAS_ENDGRENT_R:
 *	This symbol, if defined, indicates that the endgrent_r routine
 *	is available to endgrent re-entrantly.
 */
/* ENDGRENT_R_PROTO:
 *	This symbol encodes the prototype of endgrent_r.
 *	It is zero if d_endgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endgrent_r
 *	is defined.
 */
/*#define HAS_ENDGRENT_R	   / **/
#define ENDGRENT_R_PROTO 0	   /**/

/* HAS_ENDHOSTENT:
 *	This symbol, if defined, indicates that the endhostent() routine is
 *	available to close whatever was being used for host queries.
 */
/*#define HAS_ENDHOSTENT		/ **/

/* HAS_ENDHOSTENT_R:
 *	This symbol, if defined, indicates that the endhostent_r routine
 *	is available to endhostent re-entrantly.
 */
/* ENDHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of endhostent_r.
 *	It is zero if d_endhostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endhostent_r
 *	is defined.
 */
/*#define HAS_ENDHOSTENT_R	   / **/
#define ENDHOSTENT_R_PROTO 0	   /**/

/* HAS_ENDNETENT:
 *	This symbol, if defined, indicates that the endnetent() routine is
 *	available to close whatever was being used for network queries.
 */
/*#define HAS_ENDNETENT		/ **/

/* HAS_ENDNETENT_R:
 *	This symbol, if defined, indicates that the endnetent_r routine
 *	is available to endnetent re-entrantly.
 */
/* ENDNETENT_R_PROTO:
 *	This symbol encodes the prototype of endnetent_r.
 *	It is zero if d_endnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endnetent_r
 *	is defined.
 */
/*#define HAS_ENDNETENT_R	   / **/
#define ENDNETENT_R_PROTO 0	   /**/

/* HAS_ENDPROTOENT:
 *	This symbol, if defined, indicates that the endprotoent() routine is
 *	available to close whatever was being used for protocol queries.
 */
/*#define HAS_ENDPROTOENT		/ **/

/* HAS_ENDPROTOENT_R:
 *	This symbol, if defined, indicates that the endprotoent_r routine
 *	is available to endprotoent re-entrantly.
 */
/* ENDPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of endprotoent_r.
 *	It is zero if d_endprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endprotoent_r
 *	is defined.
 */
/*#define HAS_ENDPROTOENT_R	   / **/
#define ENDPROTOENT_R_PROTO 0	   /**/

/* HAS_ENDPWENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the passwd database.
 */
/*#define HAS_ENDPWENT		/ **/

/* HAS_ENDPWENT_R:
 *	This symbol, if defined, indicates that the endpwent_r routine
 *	is available to endpwent re-entrantly.
 */
/* ENDPWENT_R_PROTO:
 *	This symbol encodes the prototype of endpwent_r.
 *	It is zero if d_endpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endpwent_r
 *	is defined.
 */
/*#define HAS_ENDPWENT_R	   / **/
#define ENDPWENT_R_PROTO 0	   /**/

/* HAS_ENDSERVENT:
 *	This symbol, if defined, indicates that the endservent() routine is
 *	available to close whatever was being used for service queries.
 */
/*#define HAS_ENDSERVENT		/ **/

/* HAS_ENDSERVENT_R:
 *	This symbol, if defined, indicates that the endservent_r routine
 *	is available to endservent re-entrantly.
 */
/* ENDSERVENT_R_PROTO:
 *	This symbol encodes the prototype of endservent_r.
 *	It is zero if d_endservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endservent_r
 *	is defined.
 */
/*#define HAS_ENDSERVENT_R	   / **/
#define ENDSERVENT_R_PROTO 0	   /**/

/* HAS_FD_SET:
 *	This symbol, when defined, indicates presence of the fd_set typedef
 *	in <sys/types.h>
 */
/*#define HAS_FD_SET	/ **/

/* FLEXFILENAMES:
 *	This symbol, if defined, indicates that the system supports filenames
 *	longer than 14 characters.
 */
/*#define	FLEXFILENAMES		/ **/

/* Gconvert:
 *	This preprocessor macro is defined to convert a floating point
 *	number to a string without a trailing decimal point.  This
 *	emulates the behavior of sprintf("%g"), but is sometimes much more
 *	efficient.  If gconvert() is not available, but gcvt() drops the
 *	trailing decimal point, then gcvt() is used.  If all else fails,
 *	a macro using sprintf("%g") is used. Arguments for the Gconvert
 *	macro are: value, number of digits, whether trailing zeros should
 *	be retained, and the output buffer.
 *	The usual values are:
 *		d_Gconvert='gconvert((x),(n),(t),(b))'
 *		d_Gconvert='gcvt((x),(n),(b))'
 *		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
 *	The last two assume trailing zeros should not be kept.
 */
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))

/* HAS_GETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for sequential access of the group database.
 */
/*#define HAS_GETGRENT		/ **/

/* HAS_GETGRENT_R:
 *	This symbol, if defined, indicates that the getgrent_r routine
 *	is available to getgrent re-entrantly.
 */
/* GETGRENT_R_PROTO:
 *	This symbol encodes the prototype of getgrent_r.
 *	It is zero if d_getgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrent_r
 *	is defined.
 */
/*#define HAS_GETGRENT_R	   / **/
#define GETGRENT_R_PROTO 0	   /**/

/* HAS_GETGRGID_R:
 *	This symbol, if defined, indicates that the getgrgid_r routine
 *	is available to getgrgid re-entrantly.
 */
/* GETGRGID_R_PROTO:
 *	This symbol encodes the prototype of getgrgid_r.
 *	It is zero if d_getgrgid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrgid_r
 *	is defined.
 */
/*#define HAS_GETGRGID_R	   / **/
#define GETGRGID_R_PROTO 0	   /**/

/* HAS_GETGRNAM_R:
 *	This symbol, if defined, indicates that the getgrnam_r routine
 *	is available to getgrnam re-entrantly.
 */
/* GETGRNAM_R_PROTO:
 *	This symbol encodes the prototype of getgrnam_r.
 *	It is zero if d_getgrnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrnam_r
 *	is defined.
 */
/*#define HAS_GETGRNAM_R	   / **/
#define GETGRNAM_R_PROTO 0	   /**/

/* HAS_GETHOSTBYADDR:
 *	This symbol, if defined, indicates that the gethostbyaddr() routine is
 *	available to look up hosts by their IP addresses.
 */
/*#define HAS_GETHOSTBYADDR		/ **/

/* HAS_GETHOSTBYNAME:
 *	This symbol, if defined, indicates that the gethostbyname() routine is
 *	available to look up host names in some data base or other.
 */
/*#define HAS_GETHOSTBYNAME		/ **/

/* HAS_GETHOSTENT:
 *	This symbol, if defined, indicates that the gethostent() routine is
 *	available to look up host names in some data base or another.
 */
/*#define HAS_GETHOSTENT		/ **/

/* HAS_GETHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	gethostname() routine to derive the host name.  See also HAS_UNAME
 *	and PHOSTNAME.
 */
/* HAS_UNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and PHOSTNAME.
 */
/* PHOSTNAME:
 *	This symbol, if defined, indicates the command to feed to the
 *	popen() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and HAS_UNAME.	Note that the command uses a fully qualified path,
 *	so that it is safe even if used by a process with super-user
 *	privileges.
 */
/* HAS_PHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	contents of PHOSTNAME as a command to feed to the popen() routine
 *	to derive the host name.
 */
/*#define HAS_GETHOSTNAME	/ **/
/*#define HAS_UNAME		/ **/
/*#define HAS_PHOSTNAME	/ **/
#ifdef HAS_PHOSTNAME
#define PHOSTNAME "/bin/hostname"	/* How to get the host name */
#endif

/* HAS_GETHOSTBYADDR_R:
 *	This symbol, if defined, indicates that the gethostbyaddr_r routine
 *	is available to gethostbyaddr re-entrantly.
 */
/* GETHOSTBYADDR_R_PROTO:
 *	This symbol encodes the prototype of gethostbyaddr_r.
 *	It is zero if d_gethostbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyaddr_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYADDR_R	   / **/
#define GETHOSTBYADDR_R_PROTO 0	   /**/

/* HAS_GETHOSTBYNAME_R:
 *	This symbol, if defined, indicates that the gethostbyname_r routine
 *	is available to gethostbyname re-entrantly.
 */
/* GETHOSTBYNAME_R_PROTO:
 *	This symbol encodes the prototype of gethostbyname_r.
 *	It is zero if d_gethostbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyname_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYNAME_R	   / **/
#define GETHOSTBYNAME_R_PROTO 0	   /**/

/* HAS_GETHOSTENT_R:
 *	This symbol, if defined, indicates that the gethostent_r routine
 *	is available to gethostent re-entrantly.
 */
/* GETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of gethostent_r.
 *	It is zero if d_gethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostent_r
 *	is defined.
 */
/*#define HAS_GETHOSTENT_R	   / **/
#define GETHOSTENT_R_PROTO 0	   /**/

/* HAS_GETHOST_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for gethostent(), gethostbyname(), and
 *	gethostbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETHOST_PROTOS	/ **/

/* HAS_GETLOGIN_R:
 *	This symbol, if defined, indicates that the getlogin_r routine
 *	is available to getlogin re-entrantly.
 */
/* GETLOGIN_R_PROTO:
 *	This symbol encodes the prototype of getlogin_r.
 *	It is zero if d_getlogin_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getlogin_r
 *	is defined.
 */
/*#define HAS_GETLOGIN_R	   / **/
#define GETLOGIN_R_PROTO 0	   /**/

/* HAS_GETNETBYADDR:
 *	This symbol, if defined, indicates that the getnetbyaddr() routine is
 *	available to look up networks by their IP addresses.
 */
/*#define HAS_GETNETBYADDR		/ **/

/* HAS_GETNETBYNAME:
 *	This symbol, if defined, indicates that the getnetbyname() routine is
 *	available to look up networks by their names.
 */
/*#define HAS_GETNETBYNAME		/ **/

/* HAS_GETNETENT:
 *	This symbol, if defined, indicates that the getnetent() routine is
 *	available to look up network names in some data base or another.
 */
/*#define HAS_GETNETENT		/ **/

/* HAS_GETNETBYADDR_R:
 *	This symbol, if defined, indicates that the getnetbyaddr_r routine
 *	is available to getnetbyaddr re-entrantly.
 */
/* GETNETBYADDR_R_PROTO:
 *	This symbol encodes the prototype of getnetbyaddr_r.
 *	It is zero if d_getnetbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyaddr_r
 *	is defined.
 */
/*#define HAS_GETNETBYADDR_R	   / **/
#define GETNETBYADDR_R_PROTO 0	   /**/

/* HAS_GETNETBYNAME_R:
 *	This symbol, if defined, indicates that the getnetbyname_r routine
 *	is available to getnetbyname re-entrantly.
 */
/* GETNETBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getnetbyname_r.
 *	It is zero if d_getnetbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyname_r
 *	is defined.
 */
/*#define HAS_GETNETBYNAME_R	   / **/
#define GETNETBYNAME_R_PROTO 0	   /**/

/* HAS_GETNETENT_R:
 *	This symbol, if defined, indicates that the getnetent_r routine
 *	is available to getnetent re-entrantly.
 */
/* GETNETENT_R_PROTO:
 *	This symbol encodes the prototype of getnetent_r.
 *	It is zero if d_getnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetent_r
 *	is defined.
 */
/*#define HAS_GETNETENT_R	   / **/
#define GETNETENT_R_PROTO 0	   /**/

/* HAS_GETNET_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getnetent(), getnetbyname(), and
 *	getnetbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETNET_PROTOS	/ **/

/* HAS_GETPAGESIZE:
 *	This symbol, if defined, indicates that the getpagesize system call
 *	is available to get system page size, which is the granularity of
 *	many memory management calls.
 */
/*#define HAS_GETPAGESIZE		/ **/

/* HAS_GETPROTOENT:
 *	This symbol, if defined, indicates that the getprotoent() routine is
 *	available to look up protocols in some data base or another.
 */
/*#define HAS_GETPROTOENT		/ **/

/* HAS_GETPGRP:
 *	This symbol, if defined, indicates that the getpgrp routine is
 *	available to get the current process group.
 */
/* USE_BSD_GETPGRP:
 *	This symbol, if defined, indicates that getpgrp needs one
 *	arguments whereas USG one needs none.
 */
/*#define HAS_GETPGRP		/ **/
/*#define USE_BSD_GETPGRP	/ **/

/* HAS_GETPROTOBYNAME:
 *	This symbol, if defined, indicates that the getprotobyname()
 *	routine is available to look up protocols by their name.
 */
/* HAS_GETPROTOBYNUMBER:
 *	This symbol, if defined, indicates that the getprotobynumber()
 *	routine is available to look up protocols by their number.
 */
/*#define HAS_GETPROTOBYNAME		/ **/
/*#define HAS_GETPROTOBYNUMBER		/ **/

/* HAS_GETPROTOBYNAME_R:
 *	This symbol, if defined, indicates that the getprotobyname_r routine
 *	is available to getprotobyname re-entrantly.
 */
/* GETPROTOBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getprotobyname_r.
 *	It is zero if d_getprotobyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobyname_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNAME_R	   / **/
#define GETPROTOBYNAME_R_PROTO 0	   /**/

/* HAS_GETPROTOBYNUMBER_R:
 *	This symbol, if defined, indicates that the getprotobynumber_r routine
 *	is available to getprotobynumber re-entrantly.
 */
/* GETPROTOBYNUMBER_R_PROTO:
 *	This symbol encodes the prototype of getprotobynumber_r.
 *	It is zero if d_getprotobynumber_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobynumber_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNUMBER_R	   / **/
#define GETPROTOBYNUMBER_R_PROTO 0	   /**/

/* HAS_GETPROTOENT_R:
 *	This symbol, if defined, indicates that the getprotoent_r routine
 *	is available to getprotoent re-entrantly.
 */
/* GETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of getprotoent_r.
 *	It is zero if d_getprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotoent_r
 *	is defined.
 */
/*#define HAS_GETPROTOENT_R	   / **/
#define GETPROTOENT_R_PROTO 0	   /**/

/* HAS_GETPROTO_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getprotoent(), getprotobyname(), and
 *	getprotobyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETPROTO_PROTOS	/ **/

/* HAS_GETPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for sequential access of the passwd database.
 *	If this is not available, the older getpw() function may be available.
 */
/*#define HAS_GETPWENT		/ **/

/* HAS_GETPWENT_R:
 *	This symbol, if defined, indicates that the getpwent_r routine
 *	is available to getpwent re-entrantly.
 */
/* GETPWENT_R_PROTO:
 *	This symbol encodes the prototype of getpwent_r.
 *	It is zero if d_getpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwent_r
 *	is defined.
 */
/*#define HAS_GETPWENT_R	   / **/
#define GETPWENT_R_PROTO 0	   /**/

/* HAS_GETPWNAM_R:
 *	This symbol, if defined, indicates that the getpwnam_r routine
 *	is available to getpwnam re-entrantly.
 */
/* GETPWNAM_R_PROTO:
 *	This symbol encodes the prototype of getpwnam_r.
 *	It is zero if d_getpwnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwnam_r
 *	is defined.
 */
/*#define HAS_GETPWNAM_R	   / **/
#define GETPWNAM_R_PROTO 0	   /**/

/* HAS_GETPWUID_R:
 *	This symbol, if defined, indicates that the getpwuid_r routine
 *	is available to getpwuid re-entrantly.
 */
/* GETPWUID_R_PROTO:
 *	This symbol encodes the prototype of getpwuid_r.
 *	It is zero if d_getpwuid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwuid_r
 *	is defined.
 */
/*#define HAS_GETPWUID_R	   / **/
#define GETPWUID_R_PROTO 0	   /**/

/* HAS_GETSERVENT:
 *	This symbol, if defined, indicates that the getservent() routine is
 *	available to look up network services in some data base or another.
 */
/*#define HAS_GETSERVENT		/ **/

/* HAS_GETSERVBYNAME_R:
 *	This symbol, if defined, indicates that the getservbyname_r routine
 *	is available to getservbyname re-entrantly.
 */
/* GETSERVBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getservbyname_r.
 *	It is zero if d_getservbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyname_r
 *	is defined.
 */
/*#define HAS_GETSERVBYNAME_R	   / **/
#define GETSERVBYNAME_R_PROTO 0	   /**/

/* HAS_GETSERVBYPORT_R:
 *	This symbol, if defined, indicates that the getservbyport_r routine
 *	is available to getservbyport re-entrantly.
 */
/* GETSERVBYPORT_R_PROTO:
 *	This symbol encodes the prototype of getservbyport_r.
 *	It is zero if d_getservbyport_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyport_r
 *	is defined.
 */
/*#define HAS_GETSERVBYPORT_R	   / **/
#define GETSERVBYPORT_R_PROTO 0	   /**/

/* HAS_GETSERVENT_R:
 *	This symbol, if defined, indicates that the getservent_r routine
 *	is available to getservent re-entrantly.
 */
/* GETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of getservent_r.
 *	It is zero if d_getservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservent_r
 *	is defined.
 */
/*#define HAS_GETSERVENT_R	   / **/
#define GETSERVENT_R_PROTO 0	   /**/

/* HAS_GETSERV_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getservent(), getservbyname(), and
 *	getservbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETSERV_PROTOS	/ **/

/* HAS_GETSPNAM_R:
 *	This symbol, if defined, indicates that the getspnam_r routine
 *	is available to getspnam re-entrantly.
 */
/* GETSPNAM_R_PROTO:
 *	This symbol encodes the prototype of getspnam_r.
 *	It is zero if d_getspnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getspnam_r
 *	is defined.
 */
/*#define HAS_GETSPNAM_R	   / **/
#define GETSPNAM_R_PROTO 0	   /**/

/* HAS_GETSERVBYNAME:
 *	This symbol, if defined, indicates that the getservbyname()
 *	routine is available to look up services by their name.
 */
/* HAS_GETSERVBYPORT:
 *	This symbol, if defined, indicates that the getservbyport()
 *	routine is available to look up services by their port.
 */
/*#define HAS_GETSERVBYNAME		/ **/
/*#define HAS_GETSERVBYPORT		/ **/

/* HAS_GMTIME_R:
 *	This symbol, if defined, indicates that the gmtime_r routine
 *	is available to gmtime re-entrantly.
 */
/* GMTIME_R_PROTO:
 *	This symbol encodes the prototype of gmtime_r.
 *	It is zero if d_gmtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gmtime_r
 *	is defined.
 */
/*#define HAS_GMTIME_R	   / **/
#define GMTIME_R_PROTO 0	   /**/

/* HAS_GNULIBC:
 *	This symbol, if defined, indicates to the C program that
 *	the GNU C library is being used.  A better check is to use
 *	the __GLIBC__ and __GLIBC_MINOR__ symbols supplied with glibc.
 */
/*#define HAS_GNULIBC  	/ **/
#if defined(HAS_GNULIBC) && !defined(_GNU_SOURCE)
#   define _GNU_SOURCE
#endif

/* HAS_HTONL:
 *	This symbol, if defined, indicates that the htonl() routine (and
 *	friends htons() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_HTONS:
 *	This symbol, if defined, indicates that the htons() routine (and
 *	friends htonl() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHL:
 *	This symbol, if defined, indicates that the ntohl() routine (and
 *	friends htonl() htons() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHS:
 *	This symbol, if defined, indicates that the ntohs() routine (and
 *	friends htonl() htons() ntohl()) are available to do network
 *	order byte swapping.
 */
/*#define HAS_HTONL		/ **/
/*#define HAS_HTONS		/ **/
/*#define HAS_NTOHL		/ **/
/*#define HAS_NTOHS		/ **/

/* HAS_ISASCII:
 *	This manifest constant lets the C program know that isascii
 *	is available.
 */
/*#define HAS_ISASCII		/ **/

/* HAS_LCHOWN:
 *	This symbol, if defined, indicates that the lchown routine is
 *	available to operate on a symbolic link (instead of following the
 *	link).
 */
/*#define HAS_LCHOWN		/ **/

/* HAS_LOCALTIME_R:
 *	This symbol, if defined, indicates that the localtime_r routine
 *	is available to localtime re-entrantly.
 */
/* LOCALTIME_R_NEEDS_TZSET:
 *	Many libc's localtime_r implementations do not call tzset,
 *	making them differ from localtime(), and making timezone
 *	changes using $ENV{TZ} without explicitly calling tzset
 *	impossible. This symbol makes us call tzset before localtime_r
 */
/*#define LOCALTIME_R_NEEDS_TZSET / **/
#ifdef LOCALTIME_R_NEEDS_TZSET
#define L_R_TZSET tzset(),
#else
#define L_R_TZSET
#endif

/* LOCALTIME_R_PROTO:
 *	This symbol encodes the prototype of localtime_r.
 *	It is zero if d_localtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_localtime_r
 *	is defined.
 */
/*#define HAS_LOCALTIME_R	   / **/
#define LOCALTIME_R_PROTO 0	   /**/

/* HAS_LONG_DOUBLE:
 *	This symbol will be defined if the C compiler supports long
 *	doubles.
 */
/* LONG_DOUBLESIZE:
 *	This symbol contains the size of a long double, so that the
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long doubles.
 */
/*#define HAS_LONG_DOUBLE		/ **/
#ifdef HAS_LONG_DOUBLE
#define LONG_DOUBLESIZE 8		/**/
#endif

/* HAS_LONG_LONG:
 *	This symbol will be defined if the C compiler supports long long.
 */
/* LONGLONGSIZE:
 *	This symbol contains the size of a long long, so that the
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long long.
 */
/*#define HAS_LONG_LONG		/ **/
#ifdef HAS_LONG_LONG
#define LONGLONGSIZE 8		/**/
#endif

/* HAS_LSEEK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the lseek() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern off_t lseek(int, off_t, int);
 */
/*#define	HAS_LSEEK_PROTO	/ **/

/* HAS_MEMCHR:
 *	This symbol, if defined, indicates that the memchr routine is available
 *	to locate characters within a C string.
 */
#define HAS_MEMCHR	/**/

/* HAS_MKSTEMP:
 *	This symbol, if defined, indicates that the mkstemp routine is
 *	available to exclusively create and open a uniquely named
 *	temporary file.
 */
/*#define HAS_MKSTEMP		/ **/

/* HAS_MMAP:
 *	This symbol, if defined, indicates that the mmap system call is
 *	available to map a file into memory.
 */
/* Mmap_t:
 *	This symbol holds the return type of the mmap() system call
 *	(and simultaneously the type of the first argument).
 *	Usually set to 'void *' or 'caddr_t'.
 */
/*#define HAS_MMAP		/ **/
#define Mmap_t void *	/**/

/* HAS_MSG:
 *	This symbol, if defined, indicates that the entire msg*(2) library is
 *	supported (IPC mechanism based on message queues).
 */
/*#define HAS_MSG		/ **/

/* HAS_OPEN3:
 *	This manifest constant lets the C program know that the three
 *	argument form of open(2) is available.
 */
/*#define HAS_OPEN3		/ **/

/* OLD_PTHREAD_CREATE_JOINABLE:
 *	This symbol, if defined, indicates how to create pthread
 *	in joinable (aka undetached) state.  NOTE: not defined
 *	if pthread.h already has defined PTHREAD_CREATE_JOINABLE
 *	(the new version of the constant).
 *	If defined, known values are PTHREAD_CREATE_UNDETACHED
 *	and __UNDETACHED.
 */
/*#define OLD_PTHREAD_CREATE_JOINABLE  / **/

/* HAS_PTHREAD_ATFORK:
 *	This symbol, if defined, indicates that the pthread_atfork routine
 *	is available to setup fork handlers.
 */
/*#define HAS_PTHREAD_ATFORK		/ **/

/* HAS_PTHREAD_YIELD:
 *	This symbol, if defined, indicates that the pthread_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/* SCHED_YIELD:
 *	This symbol defines the way to yield the execution of
 *	the current thread.  Known ways are sched_yield,
 *	pthread_yield, and pthread_yield with NULL.
 */
/* HAS_SCHED_YIELD:
 *	This symbol, if defined, indicates that the sched_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/*#define HAS_PTHREAD_YIELD	/ **/
#define SCHED_YIELD	sched_yield()	/**/
/*#define HAS_SCHED_YIELD	/ **/

/* HAS_RANDOM_R:
 *	This symbol, if defined, indicates that the random_r routine
 *	is available to random re-entrantly.
 */
/* RANDOM_R_PROTO:
 *	This symbol encodes the prototype of random_r.
 *	It is zero if d_random_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_random_r
 *	is defined.
 */
/*#define HAS_RANDOM_R	   / **/
#define RANDOM_R_PROTO 0	   /**/

/* HAS_READDIR64_R:
 *	This symbol, if defined, indicates that the readdir64_r routine
 *	is available to readdir64 re-entrantly.
 */
/* READDIR64_R_PROTO:
 *	This symbol encodes the prototype of readdir64_r.
 *	It is zero if d_readdir64_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir64_r
 *	is defined.
 */
/*#define HAS_READDIR64_R	   / **/
#define READDIR64_R_PROTO 0	   /**/

/* HAS_READDIR_R:
 *	This symbol, if defined, indicates that the readdir_r routine
 *	is available to readdir re-entrantly.
 */
/* READDIR_R_PROTO:
 *	This symbol encodes the prototype of readdir_r.
 *	It is zero if d_readdir_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir_r
 *	is defined.
 */
/*#define HAS_READDIR_R	   / **/
#define READDIR_R_PROTO 0	   /**/

/* HAS_SAFE_BCOPY:
 *	This symbol, if defined, indicates that the bcopy routine is available
 *	to copy potentially overlapping memory blocks. Normally, you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_BCOPY	/ **/

/* HAS_SAFE_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy potentially overlapping memory blocks.  If you need to
 *	copy overlapping memory blocks, you should check HAS_MEMMOVE and
 *	use memmove() instead, if available.
 */
/*#define HAS_SAFE_MEMCPY	/ **/

/* HAS_SANE_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	and can be used to compare relative magnitudes of chars with their high
 *	bits set.  If it is not defined, roll your own version.
 */
/*#define HAS_SANE_MEMCMP	/ **/

/* HAS_SEM:
 *	This symbol, if defined, indicates that the entire sem*(2) library is
 *	supported.
 */
/*#define HAS_SEM		/ **/

/* HAS_SETGRENT:
 *	This symbol, if defined, indicates that the setgrent routine is
 *	available for initializing sequential access of the group database.
 */
/*#define HAS_SETGRENT		/ **/

/* HAS_SETGRENT_R:
 *	This symbol, if defined, indicates that the setgrent_r routine
 *	is available to setgrent re-entrantly.
 */
/* SETGRENT_R_PROTO:
 *	This symbol encodes the prototype of setgrent_r.
 *	It is zero if d_setgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setgrent_r
 *	is defined.
 */
/*#define HAS_SETGRENT_R	   / **/
#define SETGRENT_R_PROTO 0	   /**/

/* HAS_SETHOSTENT:
 *	This symbol, if defined, indicates that the sethostent() routine is
 *	available.
 */
/*#define HAS_SETHOSTENT		/ **/

/* HAS_SETHOSTENT_R:
 *	This symbol, if defined, indicates that the sethostent_r routine
 *	is available to sethostent re-entrantly.
 */
/* SETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of sethostent_r.
 *	It is zero if d_sethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_sethostent_r
 *	is defined.
 */
/*#define HAS_SETHOSTENT_R	   / **/
#define SETHOSTENT_R_PROTO 0	   /**/

/* HAS_SETLOCALE_R:
 *	This symbol, if defined, indicates that the setlocale_r routine
 *	is available to setlocale re-entrantly.
 */
/* SETLOCALE_R_PROTO:
 *	This symbol encodes the prototype of setlocale_r.
 *	It is zero if d_setlocale_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setlocale_r
 *	is defined.
 */
/*#define HAS_SETLOCALE_R	   / **/
#define SETLOCALE_R_PROTO 0	   /**/

/* HAS_SETNETENT:
 *	This symbol, if defined, indicates that the setnetent() routine is
 *	available.
 */
/*#define HAS_SETNETENT		/ **/

/* HAS_SETNETENT_R:
 *	This symbol, if defined, indicates that the setnetent_r routine
 *	is available to setnetent re-entrantly.
 */
/* SETNETENT_R_PROTO:
 *	This symbol encodes the prototype of setnetent_r.
 *	It is zero if d_setnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setnetent_r
 *	is defined.
 */
/*#define HAS_SETNETENT_R	   / **/
#define SETNETENT_R_PROTO 0	   /**/

/* HAS_SETPROTOENT:
 *	This symbol, if defined, indicates that the setprotoent() routine is
 *	available.
 */
/*#define HAS_SETPROTOENT		/ **/

/* HAS_SETPGRP:
 *	This symbol, if defined, indicates that the setpgrp routine is
 *	available to set the current process group.
 */
/* USE_BSD_SETPGRP:
 *	This symbol, if defined, indicates that setpgrp needs two
 *	arguments whereas USG one needs none.  See also HAS_SETPGID
 *	for a POSIX interface.
 */
/*#define HAS_SETPGRP		/ **/
/*#define USE_BSD_SETPGRP	/ **/

/* HAS_SETPROTOENT_R:
 *	This symbol, if defined, indicates that the setprotoent_r routine
 *	is available to setprotoent re-entrantly.
 */
/* SETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of setprotoent_r.
 *	It is zero if d_setprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setprotoent_r
 *	is defined.
 */
/*#define HAS_SETPROTOENT_R	   / **/
#define SETPROTOENT_R_PROTO 0	   /**/

/* HAS_SETPWENT:
 *	This symbol, if defined, indicates that the setpwent routine is
 *	available for initializing sequential access of the passwd database.
 */
/*#define HAS_SETPWENT		/ **/

/* HAS_SETPWENT_R:
 *	This symbol, if defined, indicates that the setpwent_r routine
 *	is available to setpwent re-entrantly.
 */
/* SETPWENT_R_PROTO:
 *	This symbol encodes the prototype of setpwent_r.
 *	It is zero if d_setpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setpwent_r
 *	is defined.
 */
/*#define HAS_SETPWENT_R	   / **/
#define SETPWENT_R_PROTO 0	   /**/

/* HAS_SETSERVENT:
 *	This symbol, if defined, indicates that the setservent() routine is
 *	available.
 */
/*#define HAS_SETSERVENT		/ **/

/* HAS_SETSERVENT_R:
 *	This symbol, if defined, indicates that the setservent_r routine
 *	is available to setservent re-entrantly.
 */
/* SETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of setservent_r.
 *	It is zero if d_setservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setservent_r
 *	is defined.
 */
/*#define HAS_SETSERVENT_R	   / **/
#define SETSERVENT_R_PROTO 0	   /**/

/* HAS_SETVBUF:
 *	This symbol, if defined, indicates that the setvbuf routine is
 *	available to change buffering on an open stdio stream.
 *	to a line-buffered mode.
 */
/*#define HAS_SETVBUF		/ **/

/* HAS_SHM:
 *	This symbol, if defined, indicates that the entire shm*(2) library is
 *	supported.
 */
/*#define HAS_SHM		/ **/

/* Shmat_t:
 *	This symbol holds the return type of the shmat() system call.
 *	Usually set to 'void *' or 'char *'.
 */
/* HAS_SHMAT_PROTOTYPE:
 *	This symbol, if defined, indicates that the sys/shm.h includes
 *	a prototype for shmat().  Otherwise, it is up to the program to
 *	guess one.  Shmat_t shmat(int, Shmat_t, int) is a good guess,
 *	but not always right so it should be emitted by the program only
 *	when HAS_SHMAT_PROTOTYPE is not defined to avoid conflicting defs.
 */
#define Shmat_t void *	/**/
/*#define HAS_SHMAT_PROTOTYPE	/ **/

/* HAS_SIGACTION:
 *	This symbol, if defined, indicates that Vr4's sigaction() routine
 *	is available.
 */
/*#define HAS_SIGACTION	/ **/

/* HAS_SIGSETJMP:
 *	This variable indicates to the C program that the sigsetjmp()
 *	routine is available to save the calling process's registers
 *	and stack environment for later use by siglongjmp(), and
 *	to optionally save the process's signal mask.  See
 *	Sigjmp_buf, Sigsetjmp, and Siglongjmp.
 */
/* Sigjmp_buf:
 *	This is the buffer type to be used with Sigsetjmp and Siglongjmp.
 */
/* Sigsetjmp:
 *	This macro is used in the same way as sigsetjmp(), but will invoke
 *	traditional setjmp() if sigsetjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/* Siglongjmp:
 *	This macro is used in the same way as siglongjmp(), but will invoke
 *	traditional longjmp() if siglongjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/*#define HAS_SIGSETJMP	/ **/
#ifdef HAS_SIGSETJMP
#define Sigjmp_buf sigjmp_buf
#define Sigsetjmp(buf,save_mask) sigsetjmp((buf),(save_mask))
#define Siglongjmp(buf,retval) siglongjmp((buf),(retval))
#else
#define Sigjmp_buf jmp_buf
#define Sigsetjmp(buf,save_mask) setjmp((buf))
#define Siglongjmp(buf,retval) longjmp((buf),(retval))
#endif

/* HAS_SOCKET:
 *	This symbol, if defined, indicates that the BSD socket interface is
 *	supported.
 */
/* HAS_SOCKETPAIR:
 *	This symbol, if defined, indicates that the BSD socketpair() call is
 *	supported.
 */
/* HAS_MSG_CTRUNC:
 *	This symbol, if defined, indicates that the MSG_CTRUNC is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_DONTROUTE:
 *	This symbol, if defined, indicates that the MSG_DONTROUTE is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_OOB:
 *	This symbol, if defined, indicates that the MSG_OOB is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PEEK:
 *	This symbol, if defined, indicates that the MSG_PEEK is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PROXY:
 *	This symbol, if defined, indicates that the MSG_PROXY is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_SCM_RIGHTS:
 *	This symbol, if defined, indicates that the SCM_RIGHTS is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_SOCKADDR_SA_LEN:
 *	This symbol, if defined, indicates that the struct sockaddr
 *	structure has a member called sa_len, indicating the length of
 *	the structure.
 */
/* HAS_SOCKADDR_IN6:
 *	This symbol, if defined, indicates the availability of
 *	struct sockaddr_in6;
 */
/* HAS_SIN6_SCOPE_ID:
 *	This symbol, if defined, indicates that the struct sockaddr_in6
 *	structure has a member called sin6_scope_id.
 */
/* HAS_IP_MREQ:
 *	This symbol, if defined, indicates the availability of
 *	struct ip_mreq;
 */
/* HAS_IP_MREQ_SOURCE:
 *	This symbol, if defined, indicates the availability of
 *	struct ip_mreq_source;
 */
/* HAS_IPV6_MREQ:
 *	This symbol, if defined, indicates the availability of
 *	struct ipv6_mreq;
 */
/* HAS_IPV6_MREQ_SOURCE:
 *	This symbol, if defined, indicates the availability of
 *	struct ipv6_mreq_source;
 */
/*#define	HAS_SOCKET		/ **/
/*#define	HAS_SOCKETPAIR	/ **/
/*#define	HAS_SOCKADDR_SA_LEN	/ **/
/*#define	HAS_MSG_CTRUNC	/ **/
/*#define	HAS_MSG_DONTROUTE	/ **/
/*#define	HAS_MSG_OOB	/ **/
/*#define	HAS_MSG_PEEK	/ **/
/*#define	HAS_MSG_PROXY	/ **/
/*#define	HAS_SCM_RIGHTS	/ **/
/*#define	HAS_SOCKADDR_IN6	/ **/
/*#define	HAS_SIN6_SCOPE_ID	/ **/
/*#define	HAS_IP_MREQ	/ **/
/*#define	HAS_IP_MREQ_SOURCE	/ **/
/*#define	HAS_IPV6_MREQ	/ **/
/*#define	HAS_IPV6_MREQ_SOURCE	/ **/

/* HAS_SRAND48_R:
 *	This symbol, if defined, indicates that the srand48_r routine
 *	is available to srand48 re-entrantly.
 */
/* SRAND48_R_PROTO:
 *	This symbol encodes the prototype of srand48_r.
 *	It is zero if d_srand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srand48_r
 *	is defined.
 */
/*#define HAS_SRAND48_R	   / **/
#define SRAND48_R_PROTO 0	   /**/

/* HAS_SRANDOM_R:
 *	This symbol, if defined, indicates that the srandom_r routine
 *	is available to srandom re-entrantly.
 */
/* SRANDOM_R_PROTO:
 *	This symbol encodes the prototype of srandom_r.
 *	It is zero if d_srandom_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srandom_r
 *	is defined.
 */
/*#define HAS_SRANDOM_R	   / **/
#define SRANDOM_R_PROTO 0	   /**/

/* USE_STAT_BLOCKS:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_blksize and st_blocks.
 */
#ifndef USE_STAT_BLOCKS
/*#define USE_STAT_BLOCKS 	/ **/
#endif

/* HAS_STATIC_INLINE:
 *	This symbol, if defined, indicates that the C compiler supports
 *	C99-style static inline.  That is, the function can't be called
 *	from another translation unit.
 */
/* PERL_STATIC_INLINE:
 *	This symbol gives the best-guess incantation to use for static
 *	inline functions.  If HAS_STATIC_INLINE is defined, this will
 *	give C99-style inline.  If HAS_STATIC_INLINE is not defined,
 *	this will give a plain 'static'.  It will always be defined
 *	to something that gives static linkage.
 *	Possibilities include
 *		static inline       (c99)
 *		static __inline__   (gcc -ansi)
 *		static __inline     (MSVC)
 *		static _inline      (older MSVC)
 *		static              (c89 compilers)
 */
/*#define HAS_STATIC_INLINE				/ **/
#define PERL_STATIC_INLINE static	/**/

/* USE_STDIO_PTR:
 *	This symbol is defined if the _ptr and _cnt fields (or similar)
 *	of the stdio FILE structure can be used to access the stdio buffer
 *	for a file handle.  If this is defined, then the FILE_ptr(fp)
 *	and FILE_cnt(fp) macros will also be defined and should be used
 *	to access these fields.
 */
/* FILE_ptr:
 *	This macro is used to access the _ptr field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_PTR_LVALUE:
 *	This symbol is defined if the FILE_ptr macro can be used as an
 *	lvalue.
 */
/* FILE_cnt:
 *	This macro is used to access the _cnt field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_CNT_LVALUE:
 *	This symbol is defined if the FILE_cnt macro can be used as an
 *	lvalue.
 */
/* STDIO_PTR_LVAL_SETS_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n has the side effect of decreasing the
 *	value of File_cnt(fp) by n.
 */
/* STDIO_PTR_LVAL_NOCHANGE_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n leaves File_cnt(fp) unchanged.
 */
/*#define USE_STDIO_PTR 	/ **/
#ifdef USE_STDIO_PTR
#define FILE_ptr(fp)	((fp)->_IO_read_ptr)
/*#define STDIO_PTR_LVALUE 		/ **/
#define FILE_cnt(fp)	((fp)->_IO_read_end - (fp)->_IO_read_ptr)
/*#define STDIO_CNT_LVALUE 		/ **/
/*#define STDIO_PTR_LVAL_SETS_CNT	/ **/
/*#define STDIO_PTR_LVAL_NOCHANGE_CNT	/ **/
#endif

/* USE_STDIO_BASE:
 *	This symbol is defined if the _base field (or similar) of the
 *	stdio FILE structure can be used to access the stdio buffer for
 *	a file handle.  If this is defined, then the FILE_base(fp) macro
 *	will also be defined and should be used to access this field.
 *	Also, the FILE_bufsiz(fp) macro will be defined and should be used
 *	to determine the number of bytes in the buffer.  USE_STDIO_BASE
 *	will never be defined unless USE_STDIO_PTR is.
 */
/* FILE_base:
 *	This macro is used to access the _base field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_BASE is defined.
 */
/* FILE_bufsiz:
 *	This macro is used to determine the number of bytes in the I/O
 *	buffer pointed to by _base field (or equivalent) of the FILE
 *	structure pointed to its argument. This macro will always be defined
 *	if USE_STDIO_BASE is defined.
 */
/*#define USE_STDIO_BASE 	/ **/
#ifdef USE_STDIO_BASE
#define FILE_base(fp)	((fp)->_IO_read_base)
#define FILE_bufsiz(fp)	((fp)->_IO_read_end - (fp)->_IO_read_base)
#endif

/* USE_STRUCT_COPY:
 *	This symbol, if defined, indicates that this C compiler knows how
 *	to copy structures.  If undefined, you'll need to use a block copy
 *	routine of some sort instead.
 */
/*#define	USE_STRUCT_COPY	/ **/

/* HAS_STRERROR:
 *	This symbol, if defined, indicates that the strerror routine is
 *	available to translate error numbers to strings. See the writeup
 *	of Strerror() in this file before you try to define your own.
 */
/* HAS_SYS_ERRLIST:
 *	This symbol, if defined, indicates that the sys_errlist array is
 *	available to translate error numbers to strings. The extern int
 *	sys_nerr gives the size of that table.
 */
/* Strerror:
 *	This preprocessor symbol is defined as a macro if strerror() is
 *	not available to translate error numbers to strings but sys_errlist[]
 *	array is there.
 */
/*#define HAS_STRERROR		/ **/
/*#define HAS_SYS_ERRLIST	/ **/
#define Strerror(e) strerror(e)

/* HAS_STRERROR_R:
 *	This symbol, if defined, indicates that the strerror_r routine
 *	is available to strerror re-entrantly.
 */
/* STRERROR_R_PROTO:
 *	This symbol encodes the prototype of strerror_r.
 *	It is zero if d_strerror_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_strerror_r
 *	is defined.
 */
/*#define HAS_STRERROR_R	   / **/
#define STRERROR_R_PROTO 0	   /**/

/* HAS_STRTOUL:
 *	This symbol, if defined, indicates that the strtoul routine is
 *	available to provide conversion of strings to unsigned long.
 */
#define HAS_STRTOUL	/**/

/* HAS_TIME:
 *	This symbol, if defined, indicates that the time() routine exists.
 */
/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define HAS_TIME		/**/
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 * use getrusage(). It may be necessary to include <sys/times.h>.
 */
/*#define HAS_TIMES		/ **/

/* HAS_TMPNAM_R:
 *	This symbol, if defined, indicates that the tmpnam_r routine
 *	is available to tmpnam re-entrantly.
 */
/* TMPNAM_R_PROTO:
 *	This symbol encodes the prototype of tmpnam_r.
 *	It is zero if d_tmpnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_tmpnam_r
 *	is defined.
 */
/*#define HAS_TMPNAM_R	   / **/
#define TMPNAM_R_PROTO 0	   /**/

/* HAS_TTYNAME_R:
 *	This symbol, if defined, indicates that the ttyname_r routine
 *	is available to ttyname re-entrantly.
 */
/* TTYNAME_R_PROTO:
 *	This symbol encodes the prototype of ttyname_r.
 *	It is zero if d_ttyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ttyname_r
 *	is defined.
 */
/*#define HAS_TTYNAME_R	   / **/
#define TTYNAME_R_PROTO 0	   /**/

/* HAS_UNION_SEMUN:
 *	This symbol, if defined, indicates that the union semun is
 *	defined by including <sys/sem.h>.  If not, the user code
 *	probably needs to define it as:
 *	union semun {
 *	    int val;
 *	    struct semid_ds *buf;
 *	    unsigned short *array;
 *	}
 */
/* USE_SEMCTL_SEMUN:
 *	This symbol, if defined, indicates that union semun is
 *	used for semctl IPC_STAT.
 */
/* USE_SEMCTL_SEMID_DS:
 *	This symbol, if defined, indicates that struct semid_ds * is
 *	used for semctl IPC_STAT.
 */
/*#define HAS_UNION_SEMUN	/ **/
/*#define USE_SEMCTL_SEMUN	/ **/
/*#define USE_SEMCTL_SEMID_DS	/ **/

/* HAS_VFORK:
 *	This symbol, if defined, indicates that vfork() exists.
 */
/*#define HAS_VFORK	/ **/

/* HAS_PSEUDOFORK:
 *	This symbol, if defined, indicates that an emulation of the
 *	fork routine is available.
 */
/*#define HAS_PSEUDOFORK	/ **/

/* Signal_t:
 *	This symbol's value is either "void" or "int", corresponding to the
 *	appropriate return type of a signal handler.  Thus, you can declare
 *	a signal handler using "Signal_t (*handler)()", and define the
 *	handler using "Signal_t handler(sig)".
 */
#define Signal_t int	/* Signal handler's return type */

/* HASVOLATILE:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the volatile declaration.
 */
/*#define	HASVOLATILE	/ **/
#ifndef HASVOLATILE
#define volatile
#endif

/* HAS_VPRINTF:
 *	This symbol, if defined, indicates that the vprintf routine is available
 *	to printf with a pointer to an argument list.  If unavailable, you
 *	may need to write your own, probably in terms of _doprnt().
 */
/* USE_CHAR_VSPRINTF:
 *	This symbol is defined if this system has vsprintf() returning type
 *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
 *	is up to the package author to declare vsprintf correctly based on the
 *	symbol.
 */
#define HAS_VPRINTF	/**/
/*#define USE_CHAR_VSPRINTF 	/ **/

/* DOUBLESIZE:
 *	This symbol contains the size of a double, so that the C preprocessor
 *	can make decisions based on it.
 */
#define DOUBLESIZE 8		/**/

/* EBCDIC:
 *	This symbol, if defined, indicates that this system uses
 *	EBCDIC encoding.
 */
/* BOOTSTRAP_CHARSET:
 *	This symbol, if defined, indicates that this system needs
 *	converting various files to the native character set before
 *	bringing up perl on a system that has a non-ASCII character
 *	set and no working perl.
 */
/*#define	EBCDIC 		/ **/
/*#define	BOOTSTRAP_CHARSET	/ **/

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t int		/* File position type */

/* Gid_t_f:
 *	This symbol defines the format string used for printing a Gid_t.
 */
#define	Gid_t_f		"lu"		/**/

/* Gid_t_sign:
 *	This symbol holds the signedness of a Gid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Gid_t_sign	1		/* GID sign */

/* Gid_t_size:
 *	This symbol holds the size of a Gid_t in bytes.
 */
#define Gid_t_size 4		/* GID size */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	gid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t int		/* Type for getgid(), etc... */

/* I_DIRENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <dirent.h>. Using this symbol also triggers the definition
 *	of the Direntry_t define which ends up being 'struct dirent' or
 *	'struct direct' depending on the availability of <dirent.h>.
 */
/* DIRNAMLEN:
 *	This symbol, if defined, indicates to the C program that the length
 *	of directory entry names is provided by a d_namlen field.  Otherwise
 *	you need to do strlen() on the d_name field.
 */
/* Direntry_t:
 *	This symbol is set to 'struct direct' or 'struct dirent' depending on
 *	whether dirent is available or not. You should use this pseudo type to
 *	portably declare your directory entries.
 */
#define I_DIRENT		/**/
/*#define DIRNAMLEN	/ **/
#define Direntry_t struct dirent

/* I_GRP:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <grp.h>.
 */
/* GRPASSWD:
 *	This symbol, if defined, indicates to the C program that struct group
 *	in <grp.h> contains gr_passwd.
 */
/*#define I_GRP		/ **/
/*#define GRPASSWD	/ **/

/* I_MACH_CTHREADS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <mach/cthreads.h>.
 */
/*#define   I_MACH_CTHREADS	/ **/

/* I_NDBM:
 *	This symbol, if defined, indicates that <ndbm.h> exists and should
 *	be included.
 */
/* I_GDBMNDBM:
 *	This symbol, if defined, indicates that <gdbm/ndbm.h> exists and should
 *	be included.  This was the location of the ndbm.h compatibility file
 *	in RedHat 7.1.
 */
/* I_GDBM_NDBM:
 *	This symbol, if defined, indicates that <gdbm-ndbm.h> exists and should
 *	be included.  This is the location of the ndbm.h compatibility file
 *	in Debian 4.0.
 */
/* NDBM_H_USES_PROTOTYPES:
 *	This symbol, if defined, indicates that <ndbm.h> uses real ANSI C
 *	prototypes instead of K&R style function declarations without any
 *	parameter information. While ANSI C prototypes are supported in C++,
 *	K&R style function declarations will yield errors.
 */
/* GDBMNDBM_H_USES_PROTOTYPES:
 *	This symbol, if defined, indicates that <gdbm/ndbm.h> uses real ANSI C
 *	prototypes instead of K&R style function declarations without any
 *	parameter information. While ANSI C prototypes are supported in C++,
 *	K&R style function declarations will yield errors.
 */
/* GDBM_NDBM_H_USES_PROTOTYPES:
 *	This symbol, if defined, indicates that <gdbm-ndbm.h> uses real ANSI C
 *	prototypes instead of K&R style function declarations without any
 *	parameter information. While ANSI C prototypes are supported in C++,
 *	K&R style function declarations will yield errors.
 */
/*#define I_NDBM	/ **/
/*#define I_GDBMNDBM	/ **/
/*#define I_GDBM_NDBM	/ **/
/*#define NDBM_H_USES_PROTOTYPES	/ **/
/*#define GDBMNDBM_H_USES_PROTOTYPES	/ **/
/*#define GDBM_NDBM_H_USES_PROTOTYPES	/ **/

/* I_NETDB:
 *	This symbol, if defined, indicates that <netdb.h> exists and
 *	should be included.
 */
/*#define I_NETDB		/ **/

/* I_NET_ERRNO:
 *	This symbol, if defined, indicates that <net/errno.h> exists and
 *	should be included.
 */
/*#define I_NET_ERRNO		/ **/

/* I_PTHREAD:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <pthread.h>.
 */
/*#define   I_PTHREAD	/ **/

/* I_PWD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pwd.h>.
 */
/* PWQUOTA:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_quota.
 */
/* PWAGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_age.
 */
/* PWCHANGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_change.
 */
/* PWCLASS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_class.
 */
/* PWEXPIRE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_expire.
 */
/* PWCOMMENT:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_comment.
 */
/* PWGECOS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_gecos.
 */
/* PWPASSWD:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_passwd.
 */
/*#define I_PWD		/ **/
/*#define PWQUOTA	/ **/
/*#define PWAGE	/ **/
/*#define PWCHANGE	/ **/
/*#define PWCLASS	/ **/
/*#define PWEXPIRE	/ **/
/*#define PWCOMMENT	/ **/
/*#define PWGECOS	/ **/
/*#define PWPASSWD	/ **/

/* I_SYS_ACCESS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/access.h>.
 */
/*#define   I_SYS_ACCESS                / **/

/* I_SYS_SECURITY:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/security.h>.
 */
/*#define   I_SYS_SECURITY	/ **/

/* I_SYSUIO:
 *	This symbol, if defined, indicates that <sys/uio.h> exists and
 *	should be included.
 */
/*#define	I_SYSUIO		/ **/

/* I_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <time.h>.
 */
/* I_SYS_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h>.
 */
/* I_SYS_TIME_KERNEL:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h> with KERNEL defined.
 */
/* HAS_TM_TM_ZONE:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_zone field.
 */
/* HAS_TM_TM_GMTOFF:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_gmtoff field.
 */
#define I_TIME		/**/
/*#define I_SYS_TIME		/ **/
/*#define I_SYS_TIME_KERNEL		/ **/
/*#define HAS_TM_TM_ZONE		/ **/
/*#define HAS_TM_TM_GMTOFF		/ **/

/* I_STDARG:
 *	This symbol, if defined, indicates that <stdarg.h> exists and should
 *	be included.
 */
/* I_VARARGS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <varargs.h>.
 */
#define I_STDARG		/**/
/*#define I_VARARGS	/ **/

/* PERL_INC_VERSION_LIST:
 *	This variable specifies the list of subdirectories in over
 *	which perl.c:incpush() and lib/lib.pm will automatically
 *	search when adding directories to @INC, in a format suitable
 *	for a C initialization string.  See the inc_version_list entry
 *	in Porting/Glossary for more details.
 */
/*#define PERL_INC_VERSION_LIST NULL		/ **/

/* INSTALL_USR_BIN_PERL:
 *	This symbol, if defined, indicates that Perl is to be installed
 * 	also as /usr/bin/perl.
 */
/*#define INSTALL_USR_BIN_PERL	/ **/

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
/* LSEEKSIZE:
 *	This symbol holds the number of bytes used by the Off_t.
 */
/* Off_t_size:
 *	This symbol holds the number of bytes used by the Off_t.
 */
#define Off_t int		/* <offset> type */
#define LSEEKSIZE 4		/* <offset> size */
#define Off_t_size 4	/* <offset> size */

/* Free_t:
 *	This variable contains the return type of free().  It is usually
 * void, but occasionally int.
 */
/* Malloc_t:
 *	This symbol is the type of pointer returned by malloc and realloc.
 */
#define Malloc_t void *			/**/
#define Free_t void			/**/

/* PERL_MALLOC_WRAP:
 *	This symbol, if defined, indicates that we'd like malloc wrap checks.
 */
/*#define PERL_MALLOC_WRAP		/ **/

/* MYMALLOC:
 *	This symbol, if defined, indicates that we're using our own malloc.
 */
/*#define MYMALLOC			/ **/

/* Mode_t:
 *	This symbol holds the type used to declare file modes
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t int	 /* file mode parameter for system calls */

/* VAL_O_NONBLOCK:
 *	This symbol is to be used during open() or fcntl(F_SETFL) to turn on
 *	non-blocking I/O for the file descriptor. Note that there is no way
 *	back, i.e. you cannot turn it blocking again this way. If you wish to
 *	alternatively switch between blocking and non-blocking, use the
 *	ioctl(FIOSNBIO) call instead, but that is not supported by all devices.
 */
/* VAL_EAGAIN:
 *	This symbol holds the errno error code set by read() when no data was
 *	present on the non-blocking file descriptor.
 */
/* RD_NODATA:
 *	This symbol holds the return code from read() when no data is present
 *	on the non-blocking file descriptor. Be careful! If EOF_NONBLOCK is
 *	not defined, then you can't distinguish between no data and EOF by
 *	issuing a read(). You'll have to find another way to tell for sure!
 */
/* EOF_NONBLOCK:
 *	This symbol, if defined, indicates to the C program that a read() on
 *	a non-blocking file descriptor will return 0 on EOF, and not the value
 *	held in RD_NODATA (-1 usually, in that case!).
 */
#define VAL_O_NONBLOCK O_NONBLOCK
#define VAL_EAGAIN EAGAIN
#define RD_NODATA -1
#undef EOF_NONBLOCK

/* Netdb_host_t:
 *	This symbol holds the type used for the 1st argument
 *	to gethostbyaddr().
 */
/* Netdb_hlen_t:
 *	This symbol holds the type used for the 2nd argument
 *	to gethostbyaddr().
 */
/* Netdb_name_t:
 *	This symbol holds the type used for the argument to
 *	gethostbyname().
 */
/* Netdb_net_t:
 *	This symbol holds the type used for the 1st argument to
 *	getnetbyaddr().
 */
#define Netdb_host_t		const char * /**/
#define Netdb_hlen_t		int /**/
#define Netdb_name_t		const char * /**/
#define Netdb_net_t		unsigned long /**/

/* PERL_OTHERLIBDIRS:
 *	This variable contains a colon-separated set of paths for the perl
 *	binary to search for additional library files or modules.
 *	These directories will be tacked to the end of @INC.
 *	Perl will automatically search below each path for version-
 *	and architecture-specific directories.  See PERL_INC_VERSION_LIST
 *	for more details.
 */
/*#define PERL_OTHERLIBDIRS " "		/ **/

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t int		/* PID type */

/* PRIVLIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 */
/* PRIVLIB_EXP:
 *	This symbol contains the ~name expanded version of PRIVLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define PRIVLIB "/usr/local/lib/perl5/5.20"		/**/
#define PRIVLIB_EXP "/usr/local/lib/perl5/5.20"		/**/

/* CAN_PROTOTYPE:
 *	If defined, this macro indicates that the C compiler can handle
 *	function prototypes.
 */
/* _:
 *	This macro is used to declare function parameters for folks who want
 *	to make declarations with prototypes using a different style than
 *	the above macros.  Use double parentheses.  For example:
 *
 *		int main _((int argc, char *argv[]));
 */
/*#define	CAN_PROTOTYPE	/ **/
#ifdef CAN_PROTOTYPE
#define	_(args) args
#else
#define	_(args) ()
#endif

/* PTRSIZE:
 *	This symbol contains the size of a pointer, so that the C preprocessor
 *	can make decisions based on it.  It will be sizeof(void *) if
 *	the compiler supports (void *); otherwise it will be
 *	sizeof(char *).
 */
#define PTRSIZE 4		/**/

/* HAS_QUAD:
 *	This symbol, if defined, tells that there's a 64-bit integer type,
 *	Quad_t, and its unsigned counterpart, Uquad_t. QUADKIND will be one
 *	of QUAD_IS_INT, QUAD_IS_LONG, QUAD_IS_LONG_LONG, QUAD_IS_INT64_T,
 *	or QUAD_IS___INT64.
 */
/*#define HAS_QUAD	/ **/
#ifdef HAS_QUAD
#   define Quad_t int64_t	/**/
#   define Uquad_t uint64_t	/**/
#   define QUADKIND 4	/**/
#   define QUAD_IS_INT	1
#   define QUAD_IS_LONG	2
#   define QUAD_IS_LONG_LONG	3
#   define QUAD_IS_INT64_T	4
#   define QUAD_IS___INT64	5
#endif

/* Drand01:
 *	This macro is to be used to generate uniformly distributed
 *	random numbers over the range [0., 1.[.  You may have to supply
 *	an 'extern double drand48();' in your program since SunOS 4.1.3
 *	doesn't provide you with anything relevant in its headers.
 *	See HAS_DRAND48_PROTO.
 */
/* Rand_seed_t:
 *	This symbol defines the type of the argument of the
 *	random seed function.
 */
/* seedDrand01:
 *	This symbol defines the macro to be used in seeding the
 *	random number generator (see Drand01).
 */
/* RANDBITS:
 *	This symbol indicates how many bits are produced by the
 *	function used to generate normalized random numbers.
 *	Values include 15, 16, 31, and 48.
 */
#define Drand01()		Perl_drand48()		/**/
#define Rand_seed_t		U32		/**/
#define seedDrand01(x)	Perl_drand48_init((Rand_seed_t)x)	/**/
#define RANDBITS		48		/**/

/* Select_fd_set_t:
 *	This symbol holds the type used for the 2nd, 3rd, and 4th
 *	arguments to select.  Usually, this is 'fd_set *', if HAS_FD_SET
 *	is defined, and 'int *' otherwise.  This is only useful if you
 *	have select(), of course.
 */
#define Select_fd_set_t 	int	/**/

/* SH_PATH:
 *	This symbol contains the full pathname to the shell used on this
 *	on this system to execute Bourne shell scripts.  Usually, this will be
 *	/bin/sh, though it's possible that some systems will have /bin/ksh,
 *	/bin/pdksh, /bin/ash, /bin/bash, or even something such as
 *	D:/bin/sh.exe.
 */
#define SH_PATH "/bin/sh"  /**/

/* SIG_NAME:
 *	This symbol contains a list of signal names in order of
 *	signal number. This is intended
 *	to be used as a static array initialization, like this:
 *		char *sig_name[] = { SIG_NAME };
 *	The signals in the list are separated with commas, and each signal
 *	is surrounded by double quotes. There is no leading SIG in the signal
 *	name, i.e. SIGQUIT is known as "QUIT".
 *	Gaps in the signal numbers (up to NSIG) are filled in with NUMnn,
 *	etc., where nn is the actual signal number (e.g. NUM37).
 *	The signal number for sig_name[i] is stored in sig_num[i].
 *	The last element is 0 to terminate the list with a NULL.  This
 *	corresponds to the 0 at the end of the sig_name_init list.
 *	Note that this variable is initialized from the sig_name_init,
 *	not from sig_name (which is unused).
 */
/* SIG_NUM:
 *	This symbol contains a list of signal numbers, in the same order as the
 *	SIG_NAME list. It is suitable for static array initialization, as in:
 *		int sig_num[] = { SIG_NUM };
 *	The signals in the list are separated with commas, and the indices
 *	within that list and the SIG_NAME list match, so it's easy to compute
 *	the signal name from a number or vice versa at the price of a small
 *	dynamic linear lookup.
 *	Duplicates are allowed, but are moved to the end of the list.
 *	The signal number corresponding to sig_name[i] is sig_number[i].
 *	if (i < NSIG) then sig_number[i] == i.
 *	The last element is 0, corresponding to the 0 at the end of
 *	the sig_name_init list.
 *	Note that this variable is initialized from the sig_num_init,
 *	not from sig_num (which is unused).
 */
/* SIG_SIZE:
 *	This variable contains the number of elements of the SIG_NAME
 *	and SIG_NUM arrays, excluding the final NULL entry.
 */
#define SIG_NAME 0		/**/
#define SIG_NUM  0		/**/
#define SIG_SIZE 1			/**/

/* SITEARCH:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-dependent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITEARCH_EXP:
 *	This symbol contains the ~name expanded version of SITEARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define SITEARCH "/usr/local/lib/perl5/5.20/unknown"		/ **/
/*#define SITEARCH_EXP "/usr/local/lib/perl5/5.20/unknown"		/ **/

/* SITELIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-independent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITELIB_EXP:
 *	This symbol contains the ~name expanded version of SITELIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* SITELIB_STEM:
 *	This define is SITELIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
#define SITELIB "/usr/local/lib/perl5/5.20"		/**/
#define SITELIB_EXP "/usr/local/lib/perl5/5.20"		/**/
#define SITELIB_STEM "/usr/local/lib/perl5"		/**/

/* Size_t_size:
 *	This symbol holds the size of a Size_t in bytes.
 */
#define Size_t_size 4		/**/

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length parameter for string functions */

/* Sock_size_t:
 *	This symbol holds the type used for the size argument of
 *	various socket calls (just the base type, not the pointer-to).
 */
#define Sock_size_t		int /**/

/* SSize_t:
 *	This symbol holds the type used by functions that return
 *	a count of bytes or an error condition.  It must be a signed type.
 *	It is usually ssize_t, but may be long or int, etc.
 *	It may be necessary to include <sys/types.h> or <unistd.h>
 *	to get any typedef'ed information.
 *	We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
 */
#define SSize_t int	 /* signed count of bytes */

/* STDCHAR:
 *	This symbol is defined to be the type of char used in stdio.h.
 *	It has the values "unsigned char" or "char".
 */
#define STDCHAR char	/**/

/* Uid_t_f:
 *	This symbol defines the format string used for printing a Uid_t.
 */
#define	Uid_t_f		"lu"		/**/

/* Uid_t_sign:
 *	This symbol holds the signedness of a Uid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Uid_t_sign	1		/* UID sign */

/* Uid_t_size:
 *	This symbol holds the size of a Uid_t in bytes.
 */
#define Uid_t_size 4		/* UID size */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t int		/* UID type */

/* USE_ITHREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the interpreter-based threading implementation.
 */
/* USE_5005THREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the 5.005-based threading implementation.
 *	Only valid up to 5.8.x.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/* USE_REENTRANT_API:
 *	This symbol, if defined, indicates that Perl should
 *	try to use the various _r versions of library functions.
 *	This is extremely experimental.
 */
/*#define	USE_5005THREADS		/ **/
/*#define	USE_ITHREADS		/ **/
#if defined(USE_5005THREADS) && !defined(USE_ITHREADS)
#define		USE_THREADS		/* until src is revised*/
#endif
/*#define	OLD_PTHREADS_API		/ **/
/*#define	USE_REENTRANT_API	/ **/

/* PERL_VENDORARCH:
 *	If defined, this symbol contains the name of a private library.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.
 *	It may have a ~ on the front.
 *	The standard distribution will put nothing in this directory.
 *	Vendors who distribute perl may wish to place their own
 *	architecture-dependent modules and extensions in this directory with
 *		MakeMaker Makefile.PL INSTALLDIRS=vendor
 *	or equivalent.  See INSTALL for details.
 */
/* PERL_VENDORARCH_EXP:
 *	This symbol contains the ~name expanded version of PERL_VENDORARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define PERL_VENDORARCH ""		/ **/
/*#define PERL_VENDORARCH_EXP ""		/ **/

/* PERL_VENDORLIB_EXP:
 *	This symbol contains the ~name expanded version of VENDORLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* PERL_VENDORLIB_STEM:
 *	This define is PERL_VENDORLIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
/*#define PERL_VENDORLIB_EXP ""		/ **/
/*#define PERL_VENDORLIB_STEM ""		/ **/

/* I_TERMIO:
 *	This symbol, if defined, indicates that the program should include
 *	<termio.h> rather than <sgtty.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/* I_TERMIOS:
 *	This symbol, if defined, indicates that the program should include
 *	the POSIX termios.h rather than sgtty.h or termio.h.
 *	There are also differences in the ioctl() calls that depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/ **/
/*#define I_TERMIOS		/ **/
/*#define I_SGTTY		/ **/

/* USE_CROSS_COMPILE:
 *	This symbol, if defined, indicates that Perl is being cross-compiled.
 */
/* PERL_TARGETARCH:
 *	This symbol, if defined, indicates the target architecture
 *	Perl has been cross-compiled to.  Undefined if not a cross-compile.
 */
#ifndef USE_CROSS_COMPILE
/*#define	USE_CROSS_COMPILE	/ **/
#define	PERL_TARGETARCH	""	/**/
#endif

/* PERL_USE_DEVEL:
 *	This symbol, if defined, indicates that Perl was configured with
 *	-Dusedevel, to enable development features.  This should not be
 *	done for production builds.
 */
/*#define	PERL_USE_DEVEL		/ **/

/* HAS_ATOLF:
 *	This symbol, if defined, indicates that the atolf routine is
 *	available to convert strings into long doubles.
 */
/*#define HAS_ATOLF		/ **/

/* HAS_ATOLL:
 *	This symbol, if defined, indicates that the atoll routine is
 *	available to convert strings into long longs.
 */
/*#define HAS_ATOLL		/ **/

/* HAS__FWALK:
 *	This symbol, if defined, indicates that the _fwalk system call is
 *	available to apply a function to all the file handles.
 */
/*#define HAS__FWALK		/ **/

/* HAS_AINTL:
 *	This symbol, if defined, indicates that the aintl routine is
 *	available.  If copysignl is also present we can emulate modfl.
 */
/*#define HAS_AINTL		/ **/

/* HAS_BUILTIN_CHOOSE_EXPR:
 *	Can we handle GCC builtin for compile-time ternary-like expressions
 */
/* HAS_BUILTIN_EXPECT:
 *	Can we handle GCC builtin for telling that certain values are more
 *	likely
 */
/*#define HAS_BUILTIN_EXPECT	/ **/
/*#define HAS_BUILTIN_CHOOSE_EXPR	/ **/

/* HAS_C99_VARIADIC_MACROS:
 *	If defined, the compiler supports C99 variadic macros.
 */
/*#define	HAS_C99_VARIADIC_MACROS	/ **/

/* HAS_CLASS:
 *	This symbol, if defined, indicates that the class routine is
 *	available to classify doubles.  Available for example in AIX.
 *	The returned values are defined in <float.h> and are:
 *
 *	FP_PLUS_NORM	Positive normalized, nonzero
 *	FP_MINUS_NORM	Negative normalized, nonzero
 *	FP_PLUS_DENORM	Positive denormalized, nonzero
 *	FP_MINUS_DENORM	Negative denormalized, nonzero
 *	FP_PLUS_ZERO	+0.0
 *	FP_MINUS_ZERO	-0.0
 *	FP_PLUS_INF	+INF
 *	FP_MINUS_INF	-INF
 *	FP_NANS		Signaling Not a Number (NaNS)
 *	FP_NANQ		Quiet Not a Number (NaNQ)
 */
/*#define HAS_CLASS		/ **/

/* HAS_CLEARENV:
 *	This symbol, if defined, indicates that the clearenv () routine is
 *	available for use.
 */
/*#define HAS_CLEARENV		/ **/

/* HAS_STRUCT_CMSGHDR:
 *	This symbol, if defined, indicates that the struct cmsghdr
 *	is supported.
 */
/*#define HAS_STRUCT_CMSGHDR	/ **/

/* HAS_COPYSIGNL:
 *	This symbol, if defined, indicates that the copysignl routine is
 *	available.  If aintl is also present we can emulate modfl.
 */
/*#define HAS_COPYSIGNL		/ **/

/* USE_CPLUSPLUS:
 *	This symbol, if defined, indicates that a C++ compiler was
 *	used to compiled Perl and will be used to compile extensions.
 */
/*#define USE_CPLUSPLUS		/ **/

/* HAS_DBMINIT_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the dbminit() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int dbminit(char *);
 */
/*#define	HAS_DBMINIT_PROTO	/ **/

/* HAS_DIR_DD_FD:
 *	This symbol, if defined, indicates that the the DIR* dirstream
 *	structure contains a member variable named dd_fd.
 */
/*#define HAS_DIR_DD_FD		/ **/

/* HAS_DIRFD:
 *	This manifest constant lets the C program know that dirfd
 *	is available.
 */
/*#define HAS_DIRFD		/ **/

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/ **/

/* HAS_FAST_STDIO:
 *	This symbol, if defined, indicates that the "fast stdio"
 *	is available to manipulate the stdio buffers directly.
 */
/*#define HAS_FAST_STDIO		/ **/

/* HAS_FCHDIR:
 *	This symbol, if defined, indicates that the fchdir routine is
 *	available to change directory using a file descriptor.
 */
/*#define HAS_FCHDIR		/ **/

/* FCNTL_CAN_LOCK:
 *	This symbol, if defined, indicates that fcntl() can be used
 *	for file locking.  Normally on Unix systems this is defined.
 *	It may be undefined on VMS.
 */
/*#define FCNTL_CAN_LOCK		/ **/

/* HAS_FINITE:
 *	This symbol, if defined, indicates that the finite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_FINITE		/ **/

/* HAS_FINITEL:
 *	This symbol, if defined, indicates that the finitel routine is
 *	available to check whether a long double is finite
 *	(non-infinity non-NaN).
 */
/*#define HAS_FINITEL		/ **/

/* HAS_FLOCK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the flock() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int flock(int, int);
 */
/*#define	HAS_FLOCK_PROTO	/ **/

/* HAS_FP_CLASS:
 *	This symbol, if defined, indicates that the fp_class routine is
 *	available to classify doubles.  Available for example in Digital UNIX.
 *	The returned values are defined in <math.h> and are:
 *
 *	FP_SNAN           Signaling NaN (Not-a-Number)
 *	FP_QNAN           Quiet NaN (Not-a-Number)
 *	FP_POS_INF        +infinity
 *	FP_NEG_INF        -infinity
 *	FP_POS_NORM       Positive normalized
 *	FP_NEG_NORM       Negative normalized
 *	FP_POS_DENORM     Positive denormalized
 *	FP_NEG_DENORM     Negative denormalized
 *	FP_POS_ZERO       +0.0 (positive zero)
 *	FP_NEG_ZERO       -0.0 (negative zero)
 */
/*#define HAS_FP_CLASS		/ **/

/* HAS_FPCLASS:
 *	This symbol, if defined, indicates that the fpclass routine is
 *	available to classify doubles.  Available for example in Solaris/SVR4.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASS		/ **/

/* HAS_FPCLASSIFY:
 *	This symbol, if defined, indicates that the fpclassify routine is
 *	available to classify doubles.  Available for example in HP-UX.
 *	The returned values are defined in <math.h> and are
 *
 *           FP_NORMAL     Normalized
 *           FP_ZERO       Zero
 *           FP_INFINITE   Infinity
 *           FP_SUBNORMAL  Denormalized
 *           FP_NAN        NaN
 *
 */
/*#define HAS_FPCLASSIFY		/ **/

/* HAS_FPCLASSL:
 *	This symbol, if defined, indicates that the fpclassl routine is
 *	available to classify long doubles.  Available for example in IRIX.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASSL		/ **/

/* HAS_FPOS64_T:
 *	This symbol will be defined if the C compiler supports fpos64_t.
 */
/*#define	HAS_FPOS64_T    	/ **/

/* HAS_FREXPL:
 *	This symbol, if defined, indicates that the frexpl routine is
 *	available to break a long double floating-point number into
 *	a normalized fraction and an integral power of 2.
 */
/*#define HAS_FREXPL		/ **/

/* HAS_STRUCT_FS_DATA:
 *	This symbol, if defined, indicates that the struct fs_data
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_FS_DATA	/ **/

/* HAS_FSEEKO:
 *	This symbol, if defined, indicates that the fseeko routine is
 *	available to fseek beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FSEEKO		/ **/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATFS		/ **/

/* HAS_FSYNC:
 *	This symbol, if defined, indicates that the fsync routine is
 *	available to write a file's modified data and attributes to
 *	permanent storage.
 */
/*#define HAS_FSYNC		/ **/

/* HAS_FTELLO:
 *	This symbol, if defined, indicates that the ftello routine is
 *	available to ftell beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FTELLO		/ **/

/* HAS_FUTIMES:
 *	This symbol, if defined, indicates that the futimes routine is
 *	available to change file descriptor time stamps with struct timevals.
 */
/*#define HAS_FUTIMES		/ **/

/* HAS_GETADDRINFO:
 *	This symbol, if defined, indicates that the getaddrinfo() function
 *	is available for use.
 */
/*#define HAS_GETADDRINFO		/ **/

/* HAS_GETCWD:
 *	This symbol, if defined, indicates that the getcwd routine is
 *	available to get the current working directory.
 */
/*#define HAS_GETCWD		/ **/

/* HAS_GETESPWNAM:
 *	This symbol, if defined, indicates that the getespwnam system call is
 *	available to retrieve enhanced (shadow) password entries by name.
 */
/*#define HAS_GETESPWNAM		/ **/

/* HAS_GETFSSTAT:
 *	This symbol, if defined, indicates that the getfsstat routine is
 *	available to stat filesystems in bulk.
 */
/*#define HAS_GETFSSTAT		/ **/

/* HAS_GETITIMER:
 *	This symbol, if defined, indicates that the getitimer routine is
 *	available to return interval timers.
 */
/*#define HAS_GETITIMER		/ **/

/* HAS_GETMNT:
 *	This symbol, if defined, indicates that the getmnt routine is
 *	available to get filesystem mount info by filename.
 */
/*#define HAS_GETMNT		/ **/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to iterate through mounted file systems to get their info.
 */
/*#define HAS_GETMNTENT		/ **/

/* HAS_GETNAMEINFO:
 *	This symbol, if defined, indicates that the getnameinfo() function
 *	is available for use.
 */
/*#define HAS_GETNAMEINFO		/ **/

/* HAS_GETPRPWNAM:
 *	This symbol, if defined, indicates that the getprpwnam system call is
 *	available to retrieve protected (shadow) password entries by name.
 */
/*#define HAS_GETPRPWNAM		/ **/

/* HAS_GETSPNAM:
 *	This symbol, if defined, indicates that the getspnam system call is
 *	available to retrieve SysV shadow password entries by name.
 */
/*#define HAS_GETSPNAM		/ **/

/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query the mount options of file systems.
 */
/*#define HAS_HASMNTOPT		/ **/

/* HAS_ILOGBL:
 *	This symbol, if defined, indicates that the ilogbl routine is
 *	available.  If scalbnl is also present we can emulate frexpl.
 */
/*#define HAS_ILOGBL		/ **/

/* HAS_INETNTOP:
 *	This symbol, if defined, indicates that the inet_ntop() function
 *	is available to parse IPv4 and IPv6 strings.
 */
/*#define HAS_INETNTOP		/ **/

/* HAS_INETPTON:
 *	This symbol, if defined, indicates that the inet_pton() function
 *	is available to parse IPv4 and IPv6 strings.
 */
/*#define HAS_INETPTON		/ **/

/* HAS_INT64_T:
 *     This symbol will defined if the C compiler supports int64_t.
 *     Usually the <inttypes.h> needs to be included, but sometimes
 *	<sys/types.h> is enough.
 */
/*#define     HAS_INT64_T               / **/

/* HAS_ISBLANK:
 *	This manifest constant lets the C program know that isblank
 *	is available.
 */
/*#define HAS_ISBLANK		/ **/

/* HAS_ISFINITE:
 *	This symbol, if defined, indicates that the isfinite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_ISFINITE		/ **/

/* HAS_ISINF:
 *	This symbol, if defined, indicates that the isinf routine is
 *	available to check whether a double is an infinity.
 */
/*#define HAS_ISINF		/ **/

/* HAS_ISNAN:
 *	This symbol, if defined, indicates that the isnan routine is
 *	available to check whether a double is a NaN.
 */
/*#define HAS_ISNAN		/ **/

/* HAS_ISNANL:
 *	This symbol, if defined, indicates that the isnanl routine is
 *	available to check whether a long double is a NaN.
 */
/*#define HAS_ISNANL		/ **/

/* HAS_LDBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol LDBL_DIG, which is the number
 *	of significant digits in a long double precision number. Unlike
 *	for DBL_DIG, there's no good guess for LDBL_DIG if it is undefined.
 */
/*#define HAS_LDBL_DIG 	/ * */

/* LIBM_LIB_VERSION:
 *	This symbol, if defined, indicates that libm exports _LIB_VERSION
 *	and that math.h defines the enum to manipulate it.
 */
/*#define LIBM_LIB_VERSION		/ **/

/* HAS_MADVISE:
 *	This symbol, if defined, indicates that the madvise system call is
 *	available to map a file into memory.
 */
/*#define HAS_MADVISE		/ **/

/* HAS_MALLOC_SIZE:
 *	This symbol, if defined, indicates that the malloc_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_SIZE		/ **/

/* HAS_MALLOC_GOOD_SIZE:
 *	This symbol, if defined, indicates that the malloc_good_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_GOOD_SIZE	/ **/

/* HAS_MKDTEMP:
 *	This symbol, if defined, indicates that the mkdtemp routine is
 *	available to exclusively create a uniquely named temporary directory.
 */
/*#define HAS_MKDTEMP		/ **/

/* HAS_MKSTEMPS:
 *	This symbol, if defined, indicates that the mkstemps routine is
 *	available to exclusively create and open a uniquely named
 *	(with a suffix) temporary file.
 */
/*#define HAS_MKSTEMPS		/ **/

/* HAS_MODFL:
 *	This symbol, if defined, indicates that the modfl routine is
 *	available to split a long double x into a fractional part f and
 *	an integer part i such that |f| < 1.0 and (f + i) = x.
 */
/* HAS_MODFL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the modfl() function.  Otherwise, it is up
 *	to the program to supply one.
 */
/* HAS_MODFL_POW32_BUG:
 *	This symbol, if defined, indicates that the modfl routine is
 *	broken for long doubles >= pow(2, 32).
 *	For example from 4294967303.150000 one would get 4294967302.000000
 *	and 1.150000.  The bug has been seen in certain versions of glibc,
 *	release 2.2.2 is known to be okay.
 */
/*#define HAS_MODFL		/ **/
/*#define HAS_MODFL_PROTO		/ **/
/*#define HAS_MODFL_POW32_BUG		/ **/

/* HAS_MPROTECT:
 *	This symbol, if defined, indicates that the mprotect system call is
 *	available to modify the access protection of a memory mapped file.
 */
/*#define HAS_MPROTECT		/ **/

/* HAS_STRUCT_MSGHDR:
 *	This symbol, if defined, indicates that the struct msghdr
 *	is supported.
 */
/*#define HAS_STRUCT_MSGHDR	/ **/

/* HAS_NL_LANGINFO:
 *	This symbol, if defined, indicates that the nl_langinfo routine is
 *	available to return local data.  You will also need <langinfo.h>
 *	and therefore I_LANGINFO.
 */
/*#define HAS_NL_LANGINFO		/ **/

/* HAS_OFF64_T:
 *	This symbol will be defined if the C compiler supports off64_t.
 */
/*#define	HAS_OFF64_T    		/ **/

/* HAS_PRCTL:
 *	This symbol, if defined, indicates that the prctl routine is
 *	available to set process title.
 */
/* HAS_PRCTL_SET_NAME:
 *	This symbol, if defined, indicates that the prctl routine is
 *	available to set process title and supports PR_SET_NAME.
 */
/*#define HAS_PRCTL		/ **/
/*#define HAS_PRCTL_SET_NAME		/ **/

/* HAS_PROCSELFEXE:
 *	This symbol is defined if PROCSELFEXE_PATH is a symlink
 *	to the absolute pathname of the executing program.
 */
/* PROCSELFEXE_PATH:
 *	If HAS_PROCSELFEXE is defined this symbol is the filename
 *	of the symbolic link pointing to the absolute pathname of
 *	the executing program.
 */
/*#define HAS_PROCSELFEXE	/ **/
#if defined(HAS_PROCSELFEXE) && !defined(PROCSELFEXE_PATH)
#define PROCSELFEXE_PATH		/**/
#endif

/* HAS_PTHREAD_ATTR_SETSCOPE:
 *	This symbol, if defined, indicates that the pthread_attr_setscope
 *	system call is available to set the contention scope attribute of
 *	a thread attribute object.
 */
/*#define HAS_PTHREAD_ATTR_SETSCOPE		/ **/

/* HAS_READV:
 *	This symbol, if defined, indicates that the readv routine is
 *	available to do gather reads.  You will also need <sys/uio.h>
 *	and there I_SYSUIO.
 */
/*#define HAS_READV		/ **/

/* HAS_RECVMSG:
 *	This symbol, if defined, indicates that the recvmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_RECVMSG		/ **/

/* HAS_SBRK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sbrk() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern void* sbrk(int);
 *		extern void* sbrk(size_t);
 */
/*#define	HAS_SBRK_PROTO	/ **/

/* HAS_SCALBNL:
 *	This symbol, if defined, indicates that the scalbnl routine is
 *	available.  If ilogbl is also present we can emulate frexpl.
 */
/*#define HAS_SCALBNL		/ **/

/* HAS_SENDMSG:
 *	This symbol, if defined, indicates that the sendmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_SENDMSG		/ **/

/* HAS_SETITIMER:
 *	This symbol, if defined, indicates that the setitimer routine is
 *	available to set interval timers.
 */
/*#define HAS_SETITIMER		/ **/

/* HAS_SETPROCTITLE:
 *	This symbol, if defined, indicates that the setproctitle routine is
 *	available to set process title.
 */
/*#define HAS_SETPROCTITLE		/ **/

/* HAS_SIGNBIT:
 *	This symbol, if defined, indicates that the signbit routine is
 *	available to check if the given number has the sign bit set.
 *	This should include correct testing of -0.0.  This will only be set
 *	if the signbit() routine is safe to use with the NV type used internally
 *	in perl.  Users should call Perl_signbit(), which will be #defined to
 *	the system's signbit() function or macro if this symbol is defined.
 */
/*#define HAS_SIGNBIT		/ **/

/* HAS_SIGPROCMASK:
 *	This symbol, if defined, indicates that the sigprocmask
 *	system call is available to examine or change the signal mask
 *	of the calling process.
 */
/*#define HAS_SIGPROCMASK		/ **/

/* USE_SITECUSTOMIZE:
 *	This symbol, if defined, indicates that sitecustomize should
 *	be used.
 */
#ifndef USE_SITECUSTOMIZE
/*#define	USE_SITECUSTOMIZE		/ **/
#endif

/* HAS_SNPRINTF:
 *	This symbol, if defined, indicates that the snprintf () library
 *	function is available for use.
 */
/* HAS_VSNPRINTF:
 *	This symbol, if defined, indicates that the vsnprintf () library
 *	function is available for use.
 */
/*#define HAS_SNPRINTF	/ **/
/*#define HAS_VSNPRINTF	/ **/

/* HAS_SOCKATMARK:
 *	This symbol, if defined, indicates that the sockatmark routine is
 *	available to test whether a socket is at the out-of-band mark.
 */
/*#define HAS_SOCKATMARK		/ **/

/* HAS_SOCKATMARK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sockatmark() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int sockatmark(int);
 */
/*#define	HAS_SOCKATMARK_PROTO	/ **/

/* HAS_SOCKS5_INIT:
 *	This symbol, if defined, indicates that the socks5_init routine is
 *	available to initialize SOCKS 5.
 */
/*#define HAS_SOCKS5_INIT		/ **/

/* SPRINTF_RETURNS_STRLEN:
 *	This variable defines whether sprintf returns the length of the string
 *	(as per the ANSI spec). Some C libraries retain compatibility with
 *	pre-ANSI C and return a pointer to the passed in buffer; for these
 *	this variable will be undef.
 */
/*#define SPRINTF_RETURNS_STRLEN	/ **/

/* HAS_SQRTL:
 *	This symbol, if defined, indicates that the sqrtl routine is
 *	available to do long double square roots.
 */
/*#define HAS_SQRTL		/ **/

/* HAS_SETRESGID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresgid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESGID_PROTO	/ **/

/* HAS_SETRESUID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresuid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESUID_PROTO	/ **/

/* HAS_STRUCT_STATFS_F_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs
 *	does have the f_flags member containing the mount flags of
 *	the filesystem containing the file.
 *	This kind of struct statfs is coming from <sys/mount.h> (BSD 4.3),
 *	not from <sys/statfs.h> (SYSV).  Older BSDs (like Ultrix) do not
 *	have statfs() and struct statfs, they have ustat() and getmnt()
 *	with struct ustat and struct fs_data.
 */
/*#define HAS_STRUCT_STATFS_F_FLAGS		/ **/

/* HAS_STRUCT_STATFS:
 *	This symbol, if defined, indicates that the struct statfs
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_STATFS	/ **/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATVFS		/ **/

/* HAS_STRFTIME:
 *	This symbol, if defined, indicates that the strftime routine is
 *	available to do time formatting.
 */
/*#define HAS_STRFTIME		/ **/

/* HAS_STRLCAT:
 *	This symbol, if defined, indicates that the strlcat () routine is
 *	available to do string concatenation.
 */
/*#define HAS_STRLCAT		/ **/

/* HAS_STRLCPY:
 *	This symbol, if defined, indicates that the strlcpy () routine is
 *	available to do string copying.
 */
/*#define HAS_STRLCPY		/ **/

/* HAS_STRTOLD:
 *	This symbol, if defined, indicates that the strtold routine is
 *	available to convert strings to long doubles.
 */
/*#define HAS_STRTOLD		/ **/

/* HAS_STRTOLL:
 *	This symbol, if defined, indicates that the strtoll routine is
 *	available to convert strings to long longs.
 */
/*#define HAS_STRTOLL		/ **/

/* HAS_STRTOQ:
 *	This symbol, if defined, indicates that the strtoq routine is
 *	available to convert strings to long longs (quads).
 */
/*#define HAS_STRTOQ		/ **/

/* HAS_STRTOULL:
 *	This symbol, if defined, indicates that the strtoull routine is
 *	available to convert strings to unsigned long longs.
 */
/*#define HAS_STRTOULL		/ **/

/* HAS_STRTOUQ:
 *	This symbol, if defined, indicates that the strtouq routine is
 *	available to convert strings to unsigned long longs (quads).
 */
/*#define HAS_STRTOUQ		/ **/

/* HAS_SYSCALL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the syscall() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int syscall(int,  ...);
 *		extern int syscall(long, ...);
 */
/*#define	HAS_SYSCALL_PROTO	/ **/

/* HAS_TELLDIR_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the telldir() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern long telldir(DIR*);
 */
/*#define	HAS_TELLDIR_PROTO	/ **/

/* HAS_CTIME64:
 *	This symbol, if defined, indicates that the ctime64 () routine is
 *	available to do the 64bit variant of ctime ()
 */
/* HAS_LOCALTIME64:
 *	This symbol, if defined, indicates that the localtime64 () routine is
 *	available to do the 64bit variant of localtime ()
 */
/* HAS_GMTIME64:
 *	This symbol, if defined, indicates that the gmtime64 () routine is
 *	available to do the 64bit variant of gmtime ()
 */
/* HAS_MKTIME64:
 *	This symbol, if defined, indicates that the mktime64 () routine is
 *	available to do the 64bit variant of mktime ()
 */
/* HAS_DIFFTIME64:
 *	This symbol, if defined, indicates that the difftime64 () routine is
 *	available to do the 64bit variant of difftime ()
 */
/* HAS_ASCTIME64:
 *	This symbol, if defined, indicates that the asctime64 () routine is
 *	available to do the 64bit variant of asctime ()
 */
/*#define	HAS_CTIME64		/ **/
/*#define	HAS_LOCALTIME64		/ **/
/*#define	HAS_GMTIME64		/ **/
/*#define	HAS_MKTIME64		/ **/
/*#define	HAS_DIFFTIME64		/ **/
/*#define	HAS_ASCTIME64		/ **/

/* HAS_TIMEGM:
 *	This symbol, if defined, indicates that the timegm routine is
 *	available to do the opposite of gmtime ()
 */
/*#define HAS_TIMEGM		/ **/

/* U32_ALIGNMENT_REQUIRED:
 *	This symbol, if defined, indicates that you must access
 *	character data through U32-aligned pointers.
 */
#ifndef U32_ALIGNMENT_REQUIRED
#define U32_ALIGNMENT_REQUIRED	/**/
#endif

/* HAS_UALARM:
 *	This symbol, if defined, indicates that the ualarm routine is
 *	available to do alarms with microsecond granularity.
 */
/*#define HAS_UALARM		/ **/

/* HAS_UNORDERED:
 *	This symbol, if defined, indicates that the unordered routine is
 *	available to check whether two doubles are unordered
 *	(effectively: whether either of them is NaN)
 */
/*#define HAS_UNORDERED		/ **/

/* HAS_UNSETENV:
 *	This symbol, if defined, indicates that the unsetenv () routine is
 *	available for use.
 */
/*#define HAS_UNSETENV		/ **/

/* HAS_USLEEP_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the usleep() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int usleep(useconds_t);
 */
/*#define	HAS_USLEEP_PROTO	/ **/

/* HAS_USTAT:
 *	This symbol, if defined, indicates that the ustat system call is
 *	available to query file system statistics by dev_t.
 */
/*#define HAS_USTAT		/ **/

/* HAS_WRITEV:
 *	This symbol, if defined, indicates that the writev routine is
 *	available to do scatter writes.
 */
/*#define HAS_WRITEV		/ **/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
/*#define USE_DYNAMIC_LOADING		/ **/

/* FFLUSH_NULL:
 *	This symbol, if defined, tells that fflush(NULL) correctly
 *	flushes all pending stdio output without side effects. In
 *	particular, on some platforms calling fflush(NULL) *still*
 *	corrupts STDIN if it is a pipe.
 */
/* FFLUSH_ALL:
 *	This symbol, if defined, tells that to flush
 *	all pending stdio output one must loop through all
 *	the stdio file handles stored in an array and fflush them.
 *	Note that if fflushNULL is defined, fflushall will not
 *	even be probed for and will be left undefined.
 */
/*#define	FFLUSH_NULL 		/ **/
/*#define	FFLUSH_ALL 		/ **/

/* I_ASSERT:
 *	This symbol, if defined, indicates that <assert.h> exists and
 *	could be included by the C program to get the assert() macro.
 */
#define	I_ASSERT		/**/

/* I_CRYPT:
 *	This symbol, if defined, indicates that <crypt.h> exists and
 *	should be included.
 */
/*#define	I_CRYPT		/ **/

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
/* DB_VERSION_MAJOR_CFG:
 *	This symbol, if defined, defines the major version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 */
/* DB_VERSION_MINOR_CFG:
 *	This symbol, if defined, defines the minor version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
/* DB_VERSION_PATCH_CFG:
 *	This symbol, if defined, defines the patch version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
#define DB_Hash_t	u_int32_t		/**/
#define DB_Prefix_t	size_t  	/**/
#define DB_VERSION_MAJOR_CFG	0  	/**/
#define DB_VERSION_MINOR_CFG	0  	/**/
#define DB_VERSION_PATCH_CFG	0  	/**/

/* I_FP:
 *	This symbol, if defined, indicates that <fp.h> exists and
 *	should be included.
 */
/*#define	I_FP		/ **/

/* I_FP_CLASS:
 *	This symbol, if defined, indicates that <fp_class.h> exists and
 *	should be included.
 */
/*#define	I_FP_CLASS		/ **/

/* I_IEEEFP:
 *	This symbol, if defined, indicates that <ieeefp.h> exists and
 *	should be included.
 */
/*#define	I_IEEEFP		/ **/

/* I_INTTYPES:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <inttypes.h>.
 */
/*#define   I_INTTYPES                / **/

/* I_LANGINFO:
 *	This symbol, if defined, indicates that <langinfo.h> exists and
 *	should be included.
 */
/*#define	I_LANGINFO		/ **/

/* I_LIBUTIL:
 *	This symbol, if defined, indicates that <libutil.h> exists and
 *	should be included.
 */
/*#define	I_LIBUTIL		/ **/

/* I_MALLOCMALLOC:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <malloc/malloc.h>.
 */
/*#define I_MALLOCMALLOC		/ **/

/* I_MNTENT:
 *	This symbol, if defined, indicates that <mntent.h> exists and
 *	should be included.
 */
/*#define	I_MNTENT		/ **/

/* I_NETINET_TCP:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <netinet/tcp.h>.
 */
/*#define   I_NETINET_TCP                / **/

/* I_POLL:
 *	This symbol, if defined, indicates that <poll.h> exists and
 *	should be included. (see also HAS_POLL)
 */
/*#define	I_POLL		/ **/

/* I_PROT:
 *	This symbol, if defined, indicates that <prot.h> exists and
 *	should be included.
 */
/*#define	I_PROT		/ **/

/* I_SHADOW:
 *	This symbol, if defined, indicates that <shadow.h> exists and
 *	should be included.
 */
/*#define	I_SHADOW		/ **/

/* I_SOCKS:
 *	This symbol, if defined, indicates that <socks.h> exists and
 *	should be included.
 */
/*#define	I_SOCKS		/ **/

/* I_STDBOOL:
 *	This symbol, if defined, indicates that <stdbool.h> exists and
 *	can be included.
 */
/*#define	I_STDBOOL		/ **/

/* I_SUNMATH:
 *	This symbol, if defined, indicates that <sunmath.h> exists and
 *	should be included.
 */
/*#define	I_SUNMATH		/ **/

/* I_SYSLOG:
 *	This symbol, if defined, indicates that <syslog.h> exists and
 *	should be included.
 */
/*#define	I_SYSLOG		/ **/

/* I_SYSMODE:
 *	This symbol, if defined, indicates that <sys/mode.h> exists and
 *	should be included.
 */
/*#define	I_SYSMODE		/ **/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates that <sys/mount.h> exists and
 *	should be included.
 */
/*#define	I_SYS_MOUNT		/ **/

/* I_SYS_STATFS:
 *	This symbol, if defined, indicates that <sys/statfs.h> exists.
 */
/*#define	I_SYS_STATFS		/ **/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates that <sys/statvfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_STATVFS		/ **/

/* I_SYSUTSNAME:
 *	This symbol, if defined, indicates that <sys/utsname.h> exists and
 *	should be included.
 */
/*#define	I_SYSUTSNAME		/ **/

/* I_SYS_VFS:
 *	This symbol, if defined, indicates that <sys/vfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_VFS		/ **/

/* I_USTAT:
 *	This symbol, if defined, indicates that <ustat.h> exists and
 *	should be included.
 */
/*#define	I_USTAT		/ **/

/* PERL_PRIfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for output.
 */
/* PERL_PRIgldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'g') for output.
 */
/* PERL_PRIeldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'e') for output.
 */
/* PERL_SCNfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for input.
 */
/*#define PERL_PRIfldbl	"llf"	/ **/
/*#define PERL_PRIgldbl	"llg"	/ **/
/*#define PERL_PRIeldbl	"lle"	/ **/
/*#define PERL_SCNfldbl	"llf"	/ **/

/* PERL_MAD:
 *	This symbol, if defined, indicates that the Misc Attribution
 *	Declaration code should be conditionally compiled.
 */
/*#define	PERL_MAD		/ **/

/* NEED_VA_COPY:
 *	This symbol, if defined, indicates that the system stores
 *	the variable argument list datatype, va_list, in a format
 *	that cannot be copied by simple assignment, so that some
 *	other means must be used when copying is required.
 *	As such systems vary in their provision (or non-provision)
 *	of copying mechanisms, handy.h defines a platform-
 *	independent macro, Perl_va_copy(src, dst), to do the job.
 */
#define	NEED_VA_COPY		/**/

/* IVTYPE:
 *	This symbol defines the C type used for Perl's IV.
 */
/* UVTYPE:
 *	This symbol defines the C type used for Perl's UV.
 */
/* I8TYPE:
 *	This symbol defines the C type used for Perl's I8.
 */
/* U8TYPE:
 *	This symbol defines the C type used for Perl's U8.
 */
/* I16TYPE:
 *	This symbol defines the C type used for Perl's I16.
 */
/* U16TYPE:
 *	This symbol defines the C type used for Perl's U16.
 */
/* I32TYPE:
 *	This symbol defines the C type used for Perl's I32.
 */
/* U32TYPE:
 *	This symbol defines the C type used for Perl's U32.
 */
/* I64TYPE:
 *	This symbol defines the C type used for Perl's I64.
 */
/* U64TYPE:
 *	This symbol defines the C type used for Perl's U64.
 */
/* NVTYPE:
 *	This symbol defines the C type used for Perl's NV.
 */
/* IVSIZE:
 *	This symbol contains the sizeof(IV).
 */
/* UVSIZE:
 *	This symbol contains the sizeof(UV).
 */
/* I8SIZE:
 *	This symbol contains the sizeof(I8).
 */
/* U8SIZE:
 *	This symbol contains the sizeof(U8).
 */
/* I16SIZE:
 *	This symbol contains the sizeof(I16).
 */
/* U16SIZE:
 *	This symbol contains the sizeof(U16).
 */
/* I32SIZE:
 *	This symbol contains the sizeof(I32).
 */
/* U32SIZE:
 *	This symbol contains the sizeof(U32).
 */
/* I64SIZE:
 *	This symbol contains the sizeof(I64).
 */
/* U64SIZE:
 *	This symbol contains the sizeof(U64).
 */
/* NVSIZE:
 *	This symbol contains the sizeof(NV).
 */
/* NV_PRESERVES_UV:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	can preserve all the bits of a variable of type UVTYPE.
 */
/* NV_PRESERVES_UV_BITS:
 *	This symbol contains the number of bits a variable of type NVTYPE
 *	can preserve of a variable of type UVTYPE.
 */
/* NV_OVERFLOWS_INTEGERS_AT:
 *	This symbol gives the largest integer value that NVs can hold. This
 *	value + 1.0 cannot be stored accurately. It is expressed as constant
 *	floating point expression to reduce the chance of decimal/binary
 *	conversion issues. If it can not be determined, the value 0 is given.
 */
/* NV_ZERO_IS_ALLBITS_ZERO:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	stores 0.0 in memory as all bits zero.
 */
#define	IVTYPE		long		/**/
#define	UVTYPE		unsigned long		/**/
#define	I8TYPE		signed char		/**/
#define	U8TYPE		unsigned char		/**/
#define	I16TYPE		short	/**/
#define	U16TYPE		unsigned short	/**/
#define	I32TYPE		long	/**/
#define	U32TYPE		unsigned long	/**/
#ifdef HAS_QUAD
#define	I64TYPE		int64_t	/**/
#define	U64TYPE		uint64_t	/**/
#endif
#define	NVTYPE		double		/**/
#define	IVSIZE		4		/**/
#define	UVSIZE		4		/**/
#define	I8SIZE		1		/**/
#define	U8SIZE		1		/**/
#define	I16SIZE		2	/**/
#define	U16SIZE		2	/**/
#define	I32SIZE		4	/**/
#define	U32SIZE		4	/**/
#ifdef HAS_QUAD
#define	I64SIZE		8	/**/
#define	U64SIZE		8	/**/
#endif
#define	NVSIZE		8		/**/
#undef	NV_PRESERVES_UV
#define	NV_PRESERVES_UV_BITS	0
#define	NV_OVERFLOWS_INTEGERS_AT	256.0*256.0*256.0*256.0*256.0*256.0*2.0*2.0*2.0*2.0*2.0
#undef	NV_ZERO_IS_ALLBITS_ZERO
#if UVSIZE == 8
#   ifdef BYTEORDER
#       if BYTEORDER == 0x1234
#           undef BYTEORDER
#           define BYTEORDER 0x12345678
#       else
#           if BYTEORDER == 0x4321
#               undef BYTEORDER
#               define BYTEORDER 0x87654321
#           endif
#       endif
#   endif
#endif

/* IVdf:
 *	This symbol defines the format string used for printing a Perl IV
 *	as a signed decimal integer.
 */
/* UVuf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned decimal integer.
 */
/* UVof:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned octal integer.
 */
/* UVxf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in lowercase abcdef.
 */
/* UVXf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in uppercase ABCDEF.
 */
/* NVef:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %e-ish floating point format.
 */
/* NVff:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %f-ish floating point format.
 */
/* NVgf:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %g-ish floating point format.
 */
#define	IVdf		"ld"		/**/
#define	UVuf		"lu"		/**/
#define	UVof		"lo"		/**/
#define	UVxf		"lx"		/**/
#define	UVXf		"lX"		/**/
#define	NVef		"e"		/**/
#define	NVff		"f"		/**/
#define	NVgf		"g"		/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	32	/**/

/* ST_INO_SIZE:
 *	This variable contains the size of struct stat's st_ino in bytes.
 */
/* ST_INO_SIGN:
 *	This symbol holds the signedness of struct stat's st_ino.
 *	1 for unsigned, -1 for signed.
 */
#define ST_INO_SIGN 1	/* st_ino sign */
#define ST_INO_SIZE 4	/* st_ino size */

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL "#!perl"		/**/

/* HAS_STDIO_STREAM_ARRAY:
 *	This symbol, if defined, tells that there is an array
 *	holding the stdio streams.
 */
/* STDIO_STREAM_ARRAY:
 *	This symbol tells the name of the array holding the stdio streams.
 *	Usual values include _iob, __iob, and __sF.
 */
/*#define	HAS_STDIO_STREAM_ARRAY	/ **/
#ifdef HAS_STDIO_STREAM_ARRAY
#define STDIO_STREAM_ARRAY	
#endif

/* GMTIME_MAX:
 *	This symbol contains the maximum value for the time_t offset that
 *	the system function gmtime () accepts, and defaults to 0
 */
/* GMTIME_MIN:
 *	This symbol contains the minimum value for the time_t offset that
 *	the system function gmtime () accepts, and defaults to 0
 */
/* LOCALTIME_MAX:
 *	This symbol contains the maximum value for the time_t offset that
 *	the system function localtime () accepts, and defaults to 0
 */
/* LOCALTIME_MIN:
 *	This symbol contains the minimum value for the time_t offset that
 *	the system function localtime () accepts, and defaults to 0
 */
#define GMTIME_MAX		2147483647	/**/
#define GMTIME_MIN		0	/**/
#define LOCALTIME_MAX	2147483647	/**/
#define LOCALTIME_MIN	0	/**/

/* USE_64_BIT_INT:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be employed (be they 32 or 64 bits).  The minimal possible
 *	64-bitness is used, just enough to get 64-bit integers into Perl.
 *	This may mean using for example "long longs", while your memory
 *	may still be limited to 2 gigabytes.
 */
/* USE_64_BIT_ALL:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be used (be they 32 or 64 bits).  The maximal possible
 *	64-bitness is employed: LP64 or ILP64, meaning that you will
 *	be able to use more than 2 gigabytes of memory.  This mode is
 *	even more binary incompatible than USE_64_BIT_INT. You may not
 *	be able to run the resulting executable in a 32-bit CPU at all or
 *	you may need at least to reboot your OS to 64-bit mode.
 */
#ifndef USE_64_BIT_INT
/*#define	USE_64_BIT_INT		/ **/
#endif
#ifndef USE_64_BIT_ALL
/*#define	USE_64_BIT_ALL		/ **/
#endif

/* USE_DTRACE:
 *	This symbol, if defined, indicates that Perl should
 *	be built with support for DTrace.
 */
/*#define USE_DTRACE		/ **/

/* USE_FAST_STDIO:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use 'fast stdio'.
 *	Defaults to define in Perls 5.8 and earlier, to undef later.
 */
#ifndef USE_FAST_STDIO
/*#define	USE_FAST_STDIO		/ **/
#endif

/* USE_KERN_PROC_PATHNAME:
 *	This symbol, if defined, indicates that we can use sysctl with
 *	KERN_PROC_PATHNAME to get a full path for the executable, and hence
 * 	convert $^X to an absolute path.
 */
/*#define USE_KERN_PROC_PATHNAME	/ **/

/* USE_LARGE_FILES:
 *	This symbol, if defined, indicates that large file support
 *	should be used when available.
 */
#ifndef USE_LARGE_FILES
/*#define	USE_LARGE_FILES		/ **/
#endif

/* USE_LONG_DOUBLE:
 *	This symbol, if defined, indicates that long doubles should
 *	be used when available.
 */
#ifndef USE_LONG_DOUBLE
/*#define	USE_LONG_DOUBLE		/ **/
#endif

/* USE_MORE_BITS:
 *	This symbol, if defined, indicates that 64-bit interfaces and
 *	long doubles should be used when available.
 */
#ifndef USE_MORE_BITS
/*#define	USE_MORE_BITS		/ **/
#endif

/* MULTIPLICITY:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use multiplicity.
 */
#ifndef MULTIPLICITY
/*#define	MULTIPLICITY		/ **/
#endif

/* USE_NSGETEXECUTABLEPATH:
 *	This symbol, if defined, indicates that we can use _NSGetExecutablePath
 *	and realpath to get a full path for the executable, and hence convert
 *	$^X to an absolute path.
 */
/*#define USE_NSGETEXECUTABLEPATH	/ **/

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
#ifndef USE_PERLIO
/*#define	USE_PERLIO		/ **/
#endif

/* USE_SOCKS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use socks.
 */
#ifndef USE_SOCKS
/*#define	USE_SOCKS		/ **/
#endif

#endif

/* Generated from:
 * 7557e985de18f71e80f627226b454bc8eaf20477dcf0c45b5b2c51ec792f5c89 config_h.SH
 * dbc8d38ba52ae23e5423418bb3f56b1b6fcdaa82cf71ba0be3463e8221bfe0c0 uconfig.sh
 * ex: set ro: */
                                                                                                                                                                                                                                                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/unicode_constants.h                                       0100644 0000000 0000000 00000004176 12744441327 021637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/unicode_constants.pl from Unicode data.
 * Any changes made here will be lost!
 */


#ifndef H_UNICODE_CONSTANTS   /* Guard against nested #includes */
#define H_UNICODE_CONSTANTS   1

/* This file contains #defines for various Unicode code points.  The values
 * the macros expand to are the native Unicode code point, or all or portions
 * of the UTF-8 encoding for the code point.  In the former case, the macro
 * name has the suffix "_NATIVE"; otherwise, the suffix "_UTF8".
 *
 * The macros that have the suffix "_UTF8" may have further suffixes, as
 * follows:
 *  "_FIRST_BYTE" if the value is just the first byte of the UTF-8
 *                representation; the value will be a numeric constant.
 *  "_TAIL"       if instead it represents all but the first byte.  This, and
 *                with no additional suffix are both string constants */

#define LATIN_SMALL_LETTER_LONG_S_UTF8  "\xC5\xBF"    /* U+017F */

#define COMBINING_GRAVE_ACCENT_UTF8  "\xCC\x80"    /* U+0300 */

#define GREEK_CAPITAL_LETTER_IOTA_UTF8  "\xCE\x99"    /* U+0399 */
#define GREEK_SMALL_LETTER_MU_UTF8  "\xCE\xBC"    /* U+03BC */

#define LATIN_CAPITAL_LETTER_SHARP_S_UTF8  "\xE1\xBA\x9E"    /* U+1E9E */

#define LATIN_SMALL_LIGATURE_LONG_S_T_UTF8  "\xEF\xAC\x85"    /* U+FB05 */
#define LATIN_SMALL_LIGATURE_ST_UTF8  "\xEF\xAC\x86"    /* U+FB06 */

#define HYPHEN_UTF8  "\xE2\x80\x90"    /* U+2010 */
#define FIRST_SURROGATE_UTF8_FIRST_BYTE  0xED    /* U+D800 */
#define BOM_UTF8_FIRST_BYTE  0xEF    /* U+FEFF */
#define BOM_UTF8_TAIL  "\xBB\xBF"    /* U+FEFF */

#define DEL_NATIVE  0x7F    /* U+007F */
#define CR_NATIVE  0x0D    /* U+000D */
#define LF_NATIVE  0x0A    /* U+000A */
#define LATIN_SMALL_LETTER_SHARP_S_NATIVE  0xDF    /* U+00DF */
#define LATIN_SMALL_LETTER_A_WITH_RING_ABOVE_NATIVE  0xE5    /* U+00E5 */
#define LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE_NATIVE  0xC5    /* U+00C5 */
#define LATIN_SMALL_LETTER_Y_WITH_DIAERESIS_NATIVE  0xFF    /* U+00FF */
#define MICRO_SIGN_NATIVE  0xB5    /* U+00B5 */

#endif /* H_UNICODE_CONSTANTS */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/unixish.h                                                 0100644 0000000 0000000 00000010754 12744441327 017603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    unixish.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002,
 *    2003, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * The following symbols are defined if your operating system supports
 * functions by that name.  All Unixes I know of support them, thus they
 * are not checked by the configuration script, but are directly defined
 * here.
 */

#ifndef PERL_MICRO

/* HAS_IOCTL:
 *	This symbol, if defined, indicates that the ioctl() routine is
 *	available to set I/O characteristics
 */
#define	HAS_IOCTL		/**/
 
/* HAS_UTIME:
 *	This symbol, if defined, indicates that the routine utime() is
 *	available to update the access and modification times of files.
 */
#define HAS_UTIME		/**/

/* HAS_GROUP
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
 */
#define HAS_GROUP		/**/

/* HAS_PASSWD
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
 */
#define HAS_PASSWD		/**/

#define HAS_KILL
#define HAS_WAIT

#endif /* !PERL_MICRO */
  
/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#define Stat_t struct stat

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* UNLINK_ALL_VERSIONS:
 *	This symbol, if defined, indicates that the program should arrange
 *	to remove all versions of a file if unlink() is called.  This is
 *	probably only relevant for VMS.
 */
/* #define UNLINK_ALL_VERSIONS		/ **/

/* VMS:
 *	This symbol, if defined, indicates that the program is running under
 *	VMS.  It is currently automatically set by cpps running under VMS,
 *	and is included here for completeness only.
 */
/* #define VMS		/ **/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if it finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
/* #define ALTERNATE_SHEBANG "#!" / **/

# include <signal.h>

#ifndef SIGABRT
#    define SIGABRT SIGILL
#endif
#ifndef SIGILL
#    define SIGILL 6         /* blech */
#endif
#define ABORT() kill(PerlProc_getpid(),SIGABRT);

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define Stat(fname,bufptr) stat((fname),(bufptr))
#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#define Fflush(fp)         fflush(fp)
#define Mkdir(path,mode)   mkdir((path),(mode))

#ifndef PERL_SYS_INIT_BODY
#  define PERL_SYS_INIT_BODY(c,v)					\
	MALLOC_CHECK_TAINT2(*c,*v) PERL_FPU_INIT; PERLIO_INIT; MALLOC_INIT
#endif

#ifndef PERL_SYS_TERM_BODY
#  define PERL_SYS_TERM_BODY() \
    HINTS_REFCNT_TERM; OP_CHECK_MUTEX_TERM; \
    OP_REFCNT_TERM; PERLIO_TERM; MALLOC_TERM;

#endif

#define BIT_BUCKET "/dev/null"

#define dXSUB_SYS

#ifndef NO_ENVIRON_ARRAY
#define USE_ENVIRON_ARRAY
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                    usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/utf8.h                                                    0100644 0000000 0000000 00000072462 12744441327 017006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    utf8.h
 *
 * This file contains definitions for use with the UTF-8 encoding.  It
 * actually also works with the variant UTF-8 encoding called UTF-EBCDIC, and
 * hides almost all of the differences between these from the caller.  In other
 * words, someone should #include this file, and if the code is being compiled
 * on an EBCDIC platform, things should mostly just work.
 *
 *    Copyright (C) 2000, 2001, 2002, 2005, 2006, 2007, 2009,
 *    2010, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef H_UTF8      /* Guard against recursive inclusion */
#define H_UTF8 1

/* Use UTF-8 as the default script encoding?
 * Turning this on will break scripts having non-UTF-8 binary
 * data (such as Latin-1) in string literals. */
#ifdef USE_UTF8_SCRIPTS
#    define USE_UTF8_IN_NAMES (!IN_BYTES)
#else
#    define USE_UTF8_IN_NAMES (PL_hints & HINT_UTF8)
#endif

#include "regcharclass.h"
#include "unicode_constants.h"

/* For to_utf8_fold_flags, q.v. */
#define FOLD_FLAGS_LOCALE 0x1
#define FOLD_FLAGS_FULL   0x2
#define FOLD_FLAGS_NOMIX_ASCII 0x4

/* For _core_swash_init(), internal core use only */
#define _CORE_SWASH_INIT_USER_DEFINED_PROPERTY 0x1
#define _CORE_SWASH_INIT_RETURN_IF_UNDEF       0x2
#define _CORE_SWASH_INIT_ACCEPT_INVLIST        0x4

#define uvchr_to_utf8(a,b)          uvchr_to_utf8_flags(a,b,0)
#define uvchr_to_utf8_flags(d,uv,flags)                                        \
                            uvoffuni_to_utf8_flags(d,NATIVE_TO_UNI(uv),flags)
#define utf8_to_uvchr_buf(s, e, lenp)                                          \
                     utf8n_to_uvchr(s, (U8*)(e) - (U8*)(s), lenp,              \
                                    ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY)

#define to_uni_fold(c, p, lenp) _to_uni_fold_flags(c, p, lenp, FOLD_FLAGS_FULL)
#define to_utf8_fold(c, p, lenp) _to_utf8_fold_flags(c, p, lenp, FOLD_FLAGS_FULL)
#define to_utf8_lower(a,b,c) _to_utf8_lower_flags(a,b,c,0)
#define to_utf8_upper(a,b,c) _to_utf8_upper_flags(a,b,c,0)
#define to_utf8_title(a,b,c) _to_utf8_title_flags(a,b,c,0)

/* Source backward compatibility. */
#define is_utf8_string_loc(s, len, ep)	is_utf8_string_loclen(s, len, ep, 0)

#define foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2) \
		    foldEQ_utf8_flags(s1, pe1, l1, u1, s2, pe2, l2, u2, 0)
#define FOLDEQ_UTF8_NOMIX_ASCII   (1 << 0)
#define FOLDEQ_LOCALE             (1 << 1)
#define FOLDEQ_S1_ALREADY_FOLDED  (1 << 2)
#define FOLDEQ_S2_ALREADY_FOLDED  (1 << 3)

/*
=for apidoc ibcmp_utf8

This is a synonym for (! foldEQ_utf8())

=cut
*/
#define ibcmp_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2) \
		    cBOOL(! foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2))

#ifdef EBCDIC
/* The equivalent of these macros but implementing UTF-EBCDIC
   are in the following header file:
 */

#include "utfebcdic.h"

#else	/* ! EBCDIC */
START_EXTERN_C

#ifdef DOINIT
EXTCONST unsigned char PL_utf8skip[] = {
/* 0x00 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x10 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x20 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x30 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x40 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x50 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x60 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x70 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x80 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0x90 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0xA0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0xB0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0xC0 */ 2,2,				    /* overlong */
/* 0xC2 */ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,     /* U+0080 to U+03FF */
/* 0xD0 */ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* U+0400 to U+07FF */
/* 0xE0 */ 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, /* U+0800 to U+FFFF */
/* 0xF0 */ 4,4,4,4,4,4,4,4,5,5,5,5,6,6,	    /* above BMP to 2**31 - 1 */
/* 0xFE */ 7,13, /* Perl extended (never was official UTF-8).  Up to 72bit
		    allowed (64-bit + reserved). */
};
#else
EXTCONST unsigned char PL_utf8skip[];
#endif

END_EXTERN_C

/* Native character to/from iso-8859-1.  Are the identity functions on ASCII
 * platforms */
#define NATIVE_TO_LATIN1(ch)     (ch)
#define LATIN1_TO_NATIVE(ch)     (ch)

/* I8 is an intermediate version of UTF-8 used only in UTF-EBCDIC.  We thus
 * consider it to be identical to UTF-8 on ASCII platforms.  Strictly speaking
 * UTF-8 and UTF-EBCDIC are two different things, but we often conflate them
 * because they are 8-bit encodings that serve the same purpose in Perl, and
 * rarely do we need to distinguish them.  The term "NATIVE_UTF8" applies to
 * whichever one is applicable on the current platform */
#define NATIVE_UTF8_TO_I8(ch) (ch)
#define I8_TO_NATIVE_UTF8(ch) (ch)

/* Transforms in wide UV chars */
#define UNI_TO_NATIVE(ch)        (ch)
#define NATIVE_TO_UNI(ch)        (ch)

/*

 The following table is from Unicode 3.2.

 Code Points		1st Byte  2nd Byte  3rd Byte  4th Byte

   U+0000..U+007F	00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF	E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       ED        A0..BF    80..BF  (surrogates)
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF	F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF	F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF	F4        80..8F    80..BF    80..BF
    Below are non-Unicode code points
 U+110000..U+13FFFF	F4        90..BF    80..BF    80..BF
 U+110000..U+1FFFFF	F5..F7    80..BF    80..BF    80..BF
 U+200000..:            F8..    * 88..BF    80..BF    80..BF    80..BF

Note the gaps before several of the byte entries above marked by '*'.  These are
caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).  The non-shortest ones are called 'overlongs'.

 */

/*
 Another way to look at it, as bits:

                  Code Points      1st Byte   2nd Byte   3rd Byte   4th Byte

                        0aaa aaaa  0aaa aaaa
              0000 0bbb bbaa aaaa  110b bbbb  10aa aaaa
              cccc bbbb bbaa aaaa  1110 cccc  10bb bbbb  10aa aaaa
 00 000d ddcc cccc bbbb bbaa aaaa  1111 0ddd  10cc cccc  10bb bbbb  10aa aaaa

As you can see, the continuation bytes all begin with C<10>, and the
leading bits of the start byte tell how many bytes there are in the
encoded character.

Perl's extended UTF-8 means we can have start bytes up to FF.

*/

/* Is the representation of the Unicode code point 'c' the same regardless of
 * being encoded in UTF-8 or not? */
#define UNI_IS_INVARIANT(c)		(((UV)c) <  0x80)

/* Is the UTF8-encoded byte 'c' part of a variant sequence in UTF-8?  This is
 * the inverse of UTF8_IS_INVARIANT */
#define UTF8_IS_CONTINUED(c) 		(((U8)c) &  0x80)

/* Is the byte 'c' the first byte of a multi-byte UTF8-8 encoded sequence?
 * This doesn't catch invariants (they are single-byte).  It also excludes the
 * illegal overlong sequences that begin with C0 and C1. */
#define UTF8_IS_START(c)		(((U8)c) >= 0xc2)

/* Is the byte 'c' part of a multi-byte UTF8-8 encoded sequence, and not the
 * first byte thereof?  */
#define UTF8_IS_CONTINUATION(c)		((((U8)c) & 0xC0) == 0x80)

/* Is the UTF8-encoded byte 'c' the first byte of a two byte sequence?  Use
 * UTF8_IS_NEXT_CHAR_DOWNGRADEABLE() instead if the input isn't known to
 * be well-formed.  Masking with 0xfe allows the low bit to be 0 or 1; thus
 * this matches 0xc[23]. */
#define UTF8_IS_DOWNGRADEABLE_START(c)	(((U8)(c) & 0xfe) == 0xc2)

/* Is the UTF8-encoded byte 'c' the first byte of a sequence of bytes that
 * represent a code point > 255? */
#define UTF8_IS_ABOVE_LATIN1(c)	((U8)(c) >= 0xc4)

/* This defines the 1-bits that are to be in the first byte of a multi-byte
 * UTF-8 encoded character that give the number of bytes that comprise the
 * character. 'len' is the number of bytes in the multi-byte sequence. */
#define UTF_START_MARK(len) (((len) >  7) ? 0xFF : (0xFF & (0xFE << (7-(len)))))

/* Masks out the initial one bits in a start byte, leaving the real data ones.
 * Doesn't work on an invariant byte.  'len' is the number of bytes in the
 * multi-byte sequence that comprises the character. */
#define UTF_START_MASK(len) (((len) >= 7) ? 0x00 : (0x1F >> ((len)-2)))

/* This defines the bits that are to be in the continuation bytes of a multi-byte
 * UTF-8 encoded character that indicate it is a continuation byte. */
#define UTF_CONTINUATION_MARK		0x80

/* This is the number of low-order bits a continuation byte in a UTF-8 encoded
 * sequence contributes to the specification of the code point.  In the bit
 * maps above, you see that the first 2 bits are a constant '10', leaving 6 of
 * real information */
#define UTF_ACCUMULATION_SHIFT		6

/* 2**UTF_ACCUMULATION_SHIFT - 1 */
#define UTF_CONTINUATION_MASK		((U8)0x3f)

/* If a value is anded with this, and the result is non-zero, then using the
 * original value in UTF8_ACCUMULATE will overflow, shifting bits off the left
 * */
#define UTF_ACCUMULATION_OVERFLOW_MASK					\
    (((UV) UTF_CONTINUATION_MASK) << ((sizeof(UV) * CHARBITS)           \
           - UTF_ACCUMULATION_SHIFT))

#if UVSIZE >= 8
#  define UTF8_QUAD_MAX UINT64_C(0x1000000000)

/* Input is a true Unicode (not-native) code point */
#define OFFUNISKIP(uv) ( (uv) < 0x80        ? 1 : \
		      (uv) < 0x800          ? 2 : \
		      (uv) < 0x10000        ? 3 : \
		      (uv) < 0x200000       ? 4 : \
		      (uv) < 0x4000000      ? 5 : \
		      (uv) < 0x80000000     ? 6 : \
                      (uv) < UTF8_QUAD_MAX ? 7 : 13 )
#else
/* No, I'm not even going to *TRY* putting #ifdef inside a #define */
#define OFFUNISKIP(uv) ( (uv) < 0x80        ? 1 : \
		      (uv) < 0x800          ? 2 : \
		      (uv) < 0x10000        ? 3 : \
		      (uv) < 0x200000       ? 4 : \
		      (uv) < 0x4000000      ? 5 : \
		      (uv) < 0x80000000     ? 6 : 7 )
#endif

/* How wide can a single UTF-8 encoded character become in bytes. */
/* NOTE: Strictly speaking Perl's UTF-8 should not be called UTF-8 since UTF-8
 * is an encoding of Unicode, and Unicode's upper limit, 0x10FFFF, can be
 * expressed with 4 bytes.  However, Perl thinks of UTF-8 as a way to encode
 * non-negative integers in a binary format, even those above Unicode */
#define UTF8_MAXBYTES 13

/* The maximum number of UTF-8 bytes a single Unicode character can
 * uppercase/lowercase/fold into.  Unicode guarantees that the maximum
 * expansion is 3 characters.  On ASCIIish platforms, the highest Unicode
 * character occupies 4 bytes, therefore this number would be 12, but this is
 * smaller than the maximum width a single above-Unicode character can occupy,
 * so use that instead */
#if UTF8_MAXBYTES < 12
#error UTF8_MAXBYTES must be at least 12
#endif

#define MAX_UTF8_TWO_BYTE 0x7FF

#define UTF8_MAXBYTES_CASE	UTF8_MAXBYTES

#endif /* EBCDIC vs ASCII */

/* Rest of these are attributes of Unicode and perl's internals rather than the
 * encoding, or happen to be the same in both ASCII and EBCDIC (at least at
 * this level; the macros that some of these call may have different
 * definitions in the two encodings */

/* In domain restricted to ASCII, these may make more sense to the reader than
 * the ones with Latin1 in the name */
#define NATIVE_TO_ASCII(ch)      NATIVE_TO_LATIN1(ch)
#define ASCII_TO_NATIVE(ch)      LATIN1_TO_NATIVE(ch)

/* More or less misleadingly-named defines, retained for back compat */
#define NATIVE_TO_UTF(ch)        NATIVE_UTF8_TO_I8(ch)
#define NATIVE_TO_I8(ch)         NATIVE_UTF8_TO_I8(ch)
#define UTF_TO_NATIVE(ch)        I8_TO_NATIVE_UTF8(ch)
#define I8_TO_NATIVE(ch)         I8_TO_NATIVE_UTF8(ch)
#define NATIVE8_TO_UNI(ch)       NATIVE_TO_LATIN1(ch)

/* Adds a UTF8 continuation byte 'new' of information to a running total code
 * point 'old' of all the continuation bytes so far.  This is designed to be
 * used in a loop to convert from UTF-8 to the code point represented.  Note
 * that this is asymmetric on EBCDIC platforms, in that the 'new' parameter is
 * the UTF-EBCDIC byte, whereas the 'old' parameter is a Unicode (not EBCDIC)
 * code point in process of being generated */
#define UTF8_ACCUMULATE(old, new) (((old) << UTF_ACCUMULATION_SHIFT)           \
                                   | ((NATIVE_UTF8_TO_I8((U8)new))             \
                                       & UTF_CONTINUATION_MASK))

/* This works in the face of malformed UTF-8. */
#define UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(s, e) (UTF8_IS_DOWNGRADEABLE_START(*s) \
                                               && ( (e) - (s) > 1)             \
                                               && UTF8_IS_CONTINUATION(*((s)+1)))

/* Number of bytes a code point occupies in UTF-8. */
#define NATIVE_SKIP(uv) OFFUNISKIP(NATIVE_TO_UNI(uv))

/* Most code which says UNISKIP is really thinking in terms of native code
 * points (0-255) plus all those beyond.  This is an imprecise term, but having
 * it means existing code continues to work.  For precision, use NATIVE_SKIP
 * and OFFUNISKIP */
#define UNISKIP(uv)   NATIVE_SKIP(uv)

/* Convert a two (not one) byte utf8 character to a native code point value.
 * Needs just one iteration of accumulate.  Should not be used unless it is
 * known that the two bytes are legal: 1) two-byte start, and 2) continuation.
 * Note that the result can be larger than 255 if the input character is not
 * downgradable */
#define TWO_BYTE_UTF8_TO_NATIVE(HI, LO) \
     UNI_TO_NATIVE(UTF8_ACCUMULATE((NATIVE_UTF8_TO_I8(HI) & UTF_START_MASK(2)), \
                                   (LO)))

/* Should never be used, and be deprecated */
#define TWO_BYTE_UTF8_TO_UNI(HI, LO) NATIVE_TO_UNI(TWO_BYTE_UTF8_TO_NATIVE(HI, LO))

/* How many bytes in the UTF-8 encoded character whose first (perhaps only)
 * byte is pointed to by 's' */
#define UTF8SKIP(s) PL_utf8skip[*(const U8*)(s)]

/* Is the byte 'c' the same character when encoded in UTF-8 as when not.  This
 * works on both UTF-8 encoded strings and non-encoded, as it returns TRUE in
 * each for the exact same set of bit patterns.  (And it works on any byte in a
 * UTF-8 encoded string) */
#define UTF8_IS_INVARIANT(c)		UNI_IS_INVARIANT(NATIVE_UTF8_TO_I8(c))

/* Like the above, but its name implies a non-UTF8 input, and is implemented
 * differently (for no particular reason) */
#define NATIVE_BYTE_IS_INVARIANT(c)	UNI_IS_INVARIANT(NATIVE_TO_LATIN1(c))

/* Like the above, but accepts any UV as input */
#define UVCHR_IS_INVARIANT(uv)          UNI_IS_INVARIANT(NATIVE_TO_UNI(uv))

#define MAX_PORTABLE_UTF8_TWO_BYTE 0x3FF    /* constrained by EBCDIC */

/* The macros in the next 4 sets are used to generate the two utf8 or utfebcdic
 * bytes from an ordinal that is known to fit into exactly two (not one) bytes;
 * it must be less than 0x3FF to work across both encodings. */

/* These two are helper macros for the other three sets, and should not be used
 * directly anywhere else.  'translate_function' is either NATIVE_TO_LATIN1
 * (which works for code points up to 0xFF) or NATIVE_TO_UNI which works for any
 * code point */
#define __BASE_TWO_BYTE_HI(c, translate_function)                               \
            I8_TO_NATIVE_UTF8((translate_function(c) >> UTF_ACCUMULATION_SHIFT) \
                              | UTF_START_MARK(2))
#define __BASE_TWO_BYTE_LO(c, translate_function)                               \
              I8_TO_NATIVE_UTF8((translate_function(c) & UTF_CONTINUATION_MASK) \
                                 | UTF_CONTINUATION_MARK)

/* The next two macros should not be used.  They were designed to be usable as
 * the case label of a switch statement, but this doesn't work for EBCDIC.  Use
 * regen/unicode_constants.pl instead */
#define UTF8_TWO_BYTE_HI_nocast(c)  __BASE_TWO_BYTE_HI(c, NATIVE_TO_UNI)
#define UTF8_TWO_BYTE_LO_nocast(c)  __BASE_TWO_BYTE_LO(c, NATIVE_TO_UNI)

/* The next two macros are used when the source should be a single byte
 * character; checked for under DEBUGGING */
#define UTF8_EIGHT_BIT_HI(c) (__ASSERT_(FITS_IN_8_BITS(c))                    \
                             ((U8) __BASE_TWO_BYTE_HI(c, NATIVE_TO_LATIN1)))
#define UTF8_EIGHT_BIT_LO(c) (__ASSERT_(FITS_IN_8_BITS(c))                    \
                             ((U8) __BASE_TWO_BYTE_LO(c, NATIVE_TO_LATIN1)))

/* These final two macros in the series are used when the source can be any
 * code point whose UTF-8 is known to occupy 2 bytes; they are less efficient
 * than the EIGHT_BIT versions on EBCDIC platforms.  We use the logical '~'
 * operator instead of "<=" to avoid getting compiler warnings.
 * MAX_PORTABLE_UTF8_TWO_BYTE should be exactly all one bits in the lower few
 * places, so the ~ works */
#define UTF8_TWO_BYTE_HI(c)                                                    \
       (__ASSERT_((sizeof(c) ==  1)                                            \
                  || !(((WIDEST_UTYPE)(c)) & ~MAX_PORTABLE_UTF8_TWO_BYTE))     \
        ((U8) __BASE_TWO_BYTE_HI(c, NATIVE_TO_LATIN1)))
#define UTF8_TWO_BYTE_LO(c)                                                    \
       (__ASSERT_((sizeof(c) ==  1)                                            \
                  || !(((WIDEST_UTYPE)(c)) & ~MAX_PORTABLE_UTF8_TWO_BYTE))     \
        ((U8) __BASE_TWO_BYTE_LO(c, NATIVE_TO_LATIN1)))

/* This is illegal in any well-formed UTF-8 in both EBCDIC and ASCII
 * as it is only in overlongs. */
#define ILLEGAL_UTF8_BYTE   I8_TO_NATIVE_UTF8(0xC1)

/*
 * 'UTF' is whether or not p is encoded in UTF8.  The names 'foo_lazy_if' stem
 * from an earlier version of these macros in which they didn't call the
 * foo_utf8() macros (i.e. were 'lazy') unless they decided that *p is the
 * beginning of a utf8 character.  Now that foo_utf8() determines that itself,
 * no need to do it again here
 */
#define isIDFIRST_lazy_if(p,UTF) ((IN_BYTES || !UTF ) \
				 ? isIDFIRST(*(p)) \
				 : isIDFIRST_utf8((const U8*)p))
#define isWORDCHAR_lazy_if(p,UTF)   ((IN_BYTES || (!UTF )) \
				 ? isWORDCHAR(*(p)) \
				 : isWORDCHAR_utf8((const U8*)p))
#define isALNUM_lazy_if(p,UTF)   isWORDCHAR_lazy_if(p,UTF)

#define UTF8_MAXLEN UTF8_MAXBYTES

/* A Unicode character can fold to up to 3 characters */
#define UTF8_MAX_FOLD_CHAR_EXPAND 3

#define IN_BYTES (CopHINTS_get(PL_curcop) & HINT_BYTES)
#define DO_UTF8(sv) (SvUTF8(sv) && !IN_BYTES)
#define IN_UNI_8_BIT \
	    (CopHINTS_get(PL_curcop) & (HINT_UNI_8_BIT|HINT_LOCALE_NOT_CHARS) \
	     && ! IN_LOCALE_RUNTIME && ! IN_BYTES)


#define UTF8_ALLOW_EMPTY		0x0001	/* Allow a zero length string */

/* Allow first byte to be a continuation byte */
#define UTF8_ALLOW_CONTINUATION		0x0002

/* Allow second... bytes to be non-continuation bytes */
#define UTF8_ALLOW_NON_CONTINUATION	0x0004

/* expecting more bytes than were available in the string */
#define UTF8_ALLOW_SHORT		0x0008

/* Overlong sequence; i.e., the code point can be specified in fewer bytes. */
#define UTF8_ALLOW_LONG                 0x0010

#define UTF8_DISALLOW_SURROGATE		0x0020	/* Unicode surrogates */
#define UTF8_WARN_SURROGATE		0x0040

#define UTF8_DISALLOW_NONCHAR           0x0080	/* Unicode non-character */
#define UTF8_WARN_NONCHAR               0x0100	/*  code points */

#define UTF8_DISALLOW_SUPER		0x0200	/* Super-set of Unicode: code */
#define UTF8_WARN_SUPER		        0x0400	/* points above the legal max */

/* Code points which never were part of the original UTF-8 standard, the first
 * byte of which is a FE or FF on ASCII platforms. If the first byte is FF, it
 * will overflow a 32-bit word.  If the first byte is FE, it will overflow a
 * signed 32-bit word. */
#define UTF8_DISALLOW_FE_FF		0x0800
#define UTF8_WARN_FE_FF		        0x1000

#define UTF8_CHECK_ONLY			0x2000

/* For backwards source compatibility.  They do nothing, as the default now
 * includes what they used to mean.  The first one's meaning was to allow the
 * just the single non-character 0xFFFF */
#define UTF8_ALLOW_FFFF 0
#define UTF8_ALLOW_SURROGATE 0

#define UTF8_DISALLOW_ILLEGAL_INTERCHANGE (UTF8_DISALLOW_SUPER|UTF8_DISALLOW_NONCHAR|UTF8_DISALLOW_SURROGATE|UTF8_DISALLOW_FE_FF)
#define UTF8_WARN_ILLEGAL_INTERCHANGE \
	(UTF8_WARN_SUPER|UTF8_WARN_NONCHAR|UTF8_WARN_SURROGATE|UTF8_WARN_FE_FF)
#define UTF8_ALLOW_ANY \
	    (~(UTF8_DISALLOW_ILLEGAL_INTERCHANGE|UTF8_WARN_ILLEGAL_INTERCHANGE))
#define UTF8_ALLOW_ANYUV                                                        \
         (UTF8_ALLOW_EMPTY                                                      \
	  & ~(UTF8_DISALLOW_ILLEGAL_INTERCHANGE|UTF8_WARN_ILLEGAL_INTERCHANGE))
#define UTF8_ALLOW_DEFAULT		(ckWARN(WARN_UTF8) ? 0 : \
					 UTF8_ALLOW_ANYUV)

/* Surrogates, non-character code points and above-Unicode code points are
 * problematic in some contexts.  This allows code that needs to check for
 * those to to quickly exclude the vast majority of code points it will
 * encounter */
#define UTF8_FIRST_PROBLEMATIC_CODE_POINT_FIRST_BYTE \
                                    FIRST_SURROGATE_UTF8_FIRST_BYTE

#define UTF8_IS_SURROGATE(s) cBOOL(is_SURROGATE_utf8(s))
#define UTF8_IS_REPLACEMENT(s, send) cBOOL(is_REPLACEMENT_utf8_safe(s,send))

/*		  ASCII		     EBCDIC I8
 * U+10FFFF: \xF4\x8F\xBF\xBF	\xF9\xA1\xBF\xBF\xBF	max legal Unicode
 * U+110000: \xF4\x90\x80\x80	\xF9\xA2\xA0\xA0\xA0
 * U+110001: \xF4\x90\x80\x81	\xF9\xA2\xA0\xA0\xA1
 */
#ifdef EBCDIC /* Both versions assume well-formed UTF8 */
#   define UTF8_IS_SUPER(s) (NATIVE_UTF8_TO_I8(* (U8*) (s)) >= 0xF9             \
                         && (NATIVE_UTF8_TO_I8(* (U8*) (s)) > 0xF9              \
                             || (NATIVE_UTF8_TO_I8(* ((U8*) (s) + 1)) >= 0xA2)))
#else
#   define UTF8_IS_SUPER(s) (*(U8*) (s) >= 0xF4                                 \
                            && (*(U8*) (s) > 0xF4 || (*((U8*) (s) + 1) >= 0x90)))
#endif

/* These are now machine generated, and the 'given' clause is no longer
 * applicable */
#define UTF8_IS_NONCHAR_GIVEN_THAT_NON_SUPER_AND_GE_PROBLEMATIC(s)             \
                                                    cBOOL(is_NONCHAR_utf8(s))
#define UTF8_IS_NONCHAR_(s)                                                    \
                    UTF8_IS_NONCHAR_GIVEN_THAT_NON_SUPER_AND_GE_PROBLEMATIC(s)

#define UNICODE_SURROGATE_FIRST		0xD800
#define UNICODE_SURROGATE_LAST		0xDFFF
#define UNICODE_REPLACEMENT		0xFFFD
#define UNICODE_BYTE_ORDER_MARK		0xFEFF

/* Though our UTF-8 encoding can go beyond this,
 * let's be conservative and do as Unicode says. */
#define PERL_UNICODE_MAX	0x10FFFF

#define UNICODE_WARN_SURROGATE     0x0001	/* UTF-16 surrogates */
#define UNICODE_WARN_NONCHAR       0x0002	/* Non-char code points */
#define UNICODE_WARN_SUPER         0x0004	/* Above 0x10FFFF */
#define UNICODE_WARN_FE_FF         0x0008	/* Above 0x10FFFF */
#define UNICODE_DISALLOW_SURROGATE 0x0010
#define UNICODE_DISALLOW_NONCHAR   0x0020
#define UNICODE_DISALLOW_SUPER     0x0040
#define UNICODE_DISALLOW_FE_FF     0x0080
#define UNICODE_WARN_ILLEGAL_INTERCHANGE                                      \
            (UNICODE_WARN_SURROGATE|UNICODE_WARN_NONCHAR|UNICODE_WARN_SUPER)
#define UNICODE_DISALLOW_ILLEGAL_INTERCHANGE                                  \
 (UNICODE_DISALLOW_SURROGATE|UNICODE_DISALLOW_NONCHAR|UNICODE_DISALLOW_SUPER)

/* For backward source compatibility, as are now the default */
#define UNICODE_ALLOW_SURROGATE 0
#define UNICODE_ALLOW_SUPER	0
#define UNICODE_ALLOW_ANY	0

#define UNICODE_IS_SURROGATE(c)		((c) >= UNICODE_SURROGATE_FIRST && \
					 (c) <= UNICODE_SURROGATE_LAST)
#define UNICODE_IS_REPLACEMENT(c)	((c) == UNICODE_REPLACEMENT)
#define UNICODE_IS_BYTE_ORDER_MARK(c)	((c) == UNICODE_BYTE_ORDER_MARK)
#define UNICODE_IS_NONCHAR(c)		((c >= 0xFDD0 && c <= 0xFDEF) \
			/* The other noncharacters end in FFFE or FFFF, which  \
			 * the mask below catches both of, but beyond the last \
			 * official unicode code point, they aren't            \
			 * noncharacters, since those aren't Unicode           \
			 * characters at all */                                \
			|| ((((c & 0xFFFE) == 0xFFFE)) && ! UNICODE_IS_SUPER(c)))
#define UNICODE_IS_SUPER(c)		((c) > PERL_UNICODE_MAX)
#define UNICODE_IS_FE_FF(c)		((c) > 0x7FFFFFFF)

#define LATIN_SMALL_LETTER_SHARP_S      LATIN_SMALL_LETTER_SHARP_S_NATIVE
#define LATIN_SMALL_LETTER_Y_WITH_DIAERESIS                                  \
                                LATIN_SMALL_LETTER_Y_WITH_DIAERESIS_NATIVE
#define MICRO_SIGN      MICRO_SIGN_NATIVE
#define LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE                               \
                            LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE_NATIVE
#define LATIN_SMALL_LETTER_A_WITH_RING_ABOVE                                 \
                                LATIN_SMALL_LETTER_A_WITH_RING_ABOVE_NATIVE
#define UNICODE_GREEK_CAPITAL_LETTER_SIGMA	0x03A3
#define UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA	0x03C2
#define UNICODE_GREEK_SMALL_LETTER_SIGMA	0x03C3
#define GREEK_SMALL_LETTER_MU                   0x03BC
#define GREEK_CAPITAL_LETTER_MU                 0x039C	/* Upper and title case
                                                           of MICRON */
#define LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS   0x0178	/* Also is title case */
#define LATIN_CAPITAL_LETTER_SHARP_S	        0x1E9E
#define LATIN_SMALL_LETTER_LONG_S               0x017F
#define LATIN_SMALL_LIGATURE_LONG_S_T           0xFB05
#define LATIN_SMALL_LIGATURE_ST                 0xFB06
#define KELVIN_SIGN                             0x212A
#define ANGSTROM_SIGN                           0x212B

#define UNI_DISPLAY_ISPRINT	0x0001
#define UNI_DISPLAY_BACKSLASH	0x0002
#define UNI_DISPLAY_QQ		(UNI_DISPLAY_ISPRINT|UNI_DISPLAY_BACKSLASH)
#define UNI_DISPLAY_REGEX	(UNI_DISPLAY_ISPRINT|UNI_DISPLAY_BACKSLASH)

#define ANYOF_FOLD_SHARP_S(node, input, end)	\
	(ANYOF_BITMAP_TEST(node, LATIN_SMALL_LETTER_SHARP_S) && \
	 (ANYOF_NONBITMAP(node)) && \
	 (ANYOF_FLAGS(node) & ANYOF_LOC_NONBITMAP_FOLD) && \
	 ((end) > (input) + 1) && \
	 toFOLD((input)[0]) == 's' && \
	 toFOLD((input)[1]) == 's')
#define SHARP_S_SKIP 2

/* If you want to exclude surrogates, and beyond legal Unicode, see the blame
 * log for earlier versions which gave details for these */

#ifndef EBCDIC
/* This was generated by regen/regcharclass.pl, and then moved here.  The lines
 * that generated it were then commented out.  This was done solely because it
 * takes on the order of 10 minutes to generate, and is never going to change.
 * The EBCDIC equivalent hasn't been commented out in regcharclass.pl, so it
 * should generate and run the correct stuff */
/*
	UTF8_CHAR: Matches utf8 from 1 to 4 bytes

	0x0 - 0x1FFFFF
*/
/*** GENERATED CODE ***/
#define is_UTF8_CHAR_utf8_safe(s,e)                                         \
( ((e)-(s) > 3) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0x80 ) == 0x00 ) ? 1                                \
    : ( 0xC2 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xDF ) ?                      \
	( ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ? 2 : 0 )                      \
    : ( 0xE0 == ((U8*)s)[0] ) ?                                             \
	( ( ( ( ((U8*)s)[1] & 0xE0 ) == 0xA0 ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) ? 3 : 0 )\
    : ( 0xE1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xEF ) ?                      \
	( ( ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) ? 3 : 0 )\
    : ( 0xF0 == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x90 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0xBF ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[3] & 0xC0 ) == 0x80 ) ) ? 4 : 0 )\
    : ( ( ( ( 0xF1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xF7 ) && ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[3] & 0xC0 ) == 0x80 ) ) ? 4 : 0 )\
: ((e)-(s) > 2) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0x80 ) == 0x00 ) ? 1                                \
    : ( 0xC2 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xDF ) ?                      \
	( ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ? 2 : 0 )                      \
    : ( 0xE0 == ((U8*)s)[0] ) ?                                             \
	( ( ( ( ((U8*)s)[1] & 0xE0 ) == 0xA0 ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) ? 3 : 0 )\
    : ( ( ( 0xE1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xEF ) && ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0x80 ) == 0x00 ) ? 1                                \
    : ( ( 0xC2 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xDF ) && ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ) ? 2 : 0 )\
: ((e)-(s) > 0) ?                                                           \
    ( ( ((U8*)s)[0] & 0x80 ) == 0x00 )                                      \
: 0 )
#endif

/* IS_UTF8_CHAR(p) is strictly speaking wrong (not UTF-8) because it
 * (1) allows UTF-8 encoded UTF-16 surrogates
 * (2) it allows code points past U+10FFFF.
 * The Perl_is_utf8_char() full "slow" code will handle the Perl
 * "extended UTF-8". */
#define IS_UTF8_CHAR(p, n)      (is_UTF8_CHAR_utf8_safe(p, (p) + (n)) == n)

/* regen/regcharclass.pl generates is_UTF8_CHAR_utf8_safe() macros for up to
 * these number of bytes.  So this has to be coordinated with it */
#ifdef EBCDIC
#   define IS_UTF8_CHAR_FAST(n) ((n) <= 5)
#else
#   define IS_UTF8_CHAR_FAST(n) ((n) <= 4)
#endif

#endif /* H_UTF8 */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                              usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/utfebcdic.h                                               0100644 0000000 0000000 00000132176 12744441327 020047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    utfebcdic.h
 *
 *    Copyright (C) 2001, 2002, 2003, 2005, 2006, 2007, 2009,
 *    2010, 2011 by Larry Wall, Nick Ing-Simmons, and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Macros to implement UTF-EBCDIC as perl's internal encoding
 * Taken from version 7.1 of Unicode Technical Report #16:
 *  http://www.unicode.org/unicode/reports/tr16
 *
 * To summarize, the way it works is:
 * To convert an EBCDIC character to UTF-EBCDIC:
 *  1)	convert to Unicode.  The table in this file that does this for
 *	EBCDIC bytes is PL_e2a (with inverse PLa2e).  The 'a' stands for
 *	ASCIIish, meaning latin1.
 *  2)	convert that to a utf8-like string called I8 (I stands for
 *	intermediate) with variant characters occupying multiple bytes.  This
 *	step is similar to the utf8-creating step from Unicode, but the details
 *	are different.  This transformation is called UTF8-Mod.  There is a
 *	chart about the bit patterns in a comment later in this file.  But
 *	essentially here are the differences:
 *			    UTF8		I8
 *	invariant byte	    starts with 0	starts with 0 or 100
 *	continuation byte   starts with 10	starts with 101
 *	start byte	    same in both: if the code point requires N bytes,
 *			    then the leading N bits are 1, followed by a 0.  (No
 *			    trailing 0 for the very largest possible allocation
 *			    in I8, far beyond the current Unicode standard's
 *			    max, as shown in the comment later in this file.)
 *  3)	Use the table published in tr16 to convert each byte from step 2 into
 *	final UTF-EBCDIC.  That table is reproduced in this file as PL_utf2e,
 *	and its inverse is PL_e2utf.  They are constructed so that all EBCDIC
 *	invariants remain invariant, but no others do.  For example, the
 *	ordinal value of 'A' is 193 in EBCDIC, and also is 193 in UTF-EBCDIC.
 *	Step 1) converts it to 65, Step 2 leaves it at 65, and Step 3 converts
 *	it back to 193.  As an example of how a variant character works, take
 *	LATIN SMALL LETTER Y WITH DIAERESIS, which is typically 0xDF in
 *	EBCDIC.  Step 1 converts it to the Unicode value, 0xFF.  Step 2
 *	converts that to two bytes = 11000111 10111111 = C7 BF, and Step 3
 *	converts those to 0x8B 0x73.  The table is constructed so that the
 *	first byte of the final form of a variant will always have its upper
 *	bit set (at least in the encodings that Perl recognizes, and probably
 *	all).  But note that the upper bit of some invariants is also 1.
 *
 * If you're starting from Unicode, skip step 1.  For UTF-EBCDIC to straight
 * EBCDIC, reverse the steps.
 *
 * The EBCDIC invariants have been chosen to be those characters whose Unicode
 * equivalents have ordinal numbers less than 160, that is the same characters
 * that are expressible in ASCII, plus the C1 controls.  So there are 160
 * invariants instead of the 128 in UTF-8.  (My guess is that this is because
 * the C1 control NEL (and maybe others) is important in IBM.)
 *
 * The purpose of Step 3 is to make the encoding be invariant for the chosen
 * characters.  This messes up the convenient patterns found in step 2, so
 * generally, one has to undo step 3 into a temporary to use them.  However,
 * a "shadow", or parallel table, PL_utf8skip, has been constructed so that for
 * each byte, it says how long the sequence is if that byte were to begin it
 *
 * There are actually 3 slightly different UTF-EBCDIC encodings in this file,
 * one for each of the code pages recognized by Perl.  That means that there
 * are actually three different sets of tables, one for each code page.  (If
 * Perl is compiled on platforms using another EBCDIC code page, it may not
 * compile, or Perl may silently mistake it for one of the three.)
 *
 * EBCDIC characters above 0xFF are the same as Unicode in Perl's
 * implementation of all 3 encodings, so for those Step 1 is trivial.
 *
 * (Note that the entries for invariant characters are necessarily the same in
 * PL_e2a and PLe2f, and the same for their inverses.)
 *
 * UTF-EBCDIC strings are the same length or longer than UTF-8 representations
 * of the same string.  The maximum code point representable as 2 bytes in
 * UTF-EBCDIC is 0x3FFF, instead of 0x7FFF in UTF-8.
 */

START_EXTERN_C

#ifdef DOINIT
/* Indexed by encoded byte this table gives the length of the sequence.
   Adapted from the shadow flags table in tr16.
   The entries marked 9 in tr16 are continuation bytes and are marked
   as length 1 here so that we can recover.
*/
#if '^' == 95   /* if defined(__MVS__) || defined(??) (VM/ESA?) 1047 */
EXTCONST U8 PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,
2,2,2,2,2,2,2,3,3,3,3,3,3,1,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,4,4,4,4,
1,4,1,1,1,1,1,1,1,1,4,4,4,5,5,5,
1,1,1,1,1,1,1,1,1,1,5,6,6,7,7,1
};
#endif

#if '^' == 106  /* if defined(_OSD_POSIX) POSIX-BC */
U8 PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,3,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,3,1,1,1,1,1,1,1,1,2,2,2,3,2,2,
1,2,2,2,2,2,2,3,3,3,2,1,1,1,3,3,
4,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,4,6,4,4,
7,4,1,1,1,1,1,1,1,1,4,4,4,5,5,5,
1,1,1,1,1,1,1,1,1,1,5,1,6,1,7,1
};
#endif

#if '^' == 176  /* if defined(??) (OS/400?) 037 */
U8 PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,3,2,2,
1,2,2,2,2,2,2,3,3,3,1,1,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,4,4,4,4,
1,4,1,1,1,1,1,1,1,1,4,4,4,5,5,5,
1,1,1,1,1,1,1,1,1,1,5,6,6,7,7,1
};
#endif

/* Transform tables from tr16 applied after encoding to render encoding EBCDIC
 * like, meaning that all the invariants are actually invariant, eg, that 'A'
 * remains 'A' */

#if '^' == 95   /* if defined(__MVS__) || defined(??) (VM/ESA?) 1047 */
EXTCONST U8 PL_utf2e[] = { /* I8 to UTFEBCDIC (IBM-1047) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
 0x57, 0x58, 0x59, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x70, 0x71, 0x72, 0x73,
 0x74, 0x75, 0x76, 0x77, 0x78, 0x80, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x9A, 0x9B, 0x9C,
 0x9D, 0x9E, 0x9F, 0xA0, 0xAA, 0xAB, 0xAC, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xDA, 0xDB,
 0xDC, 0xDD, 0xDE, 0xDF, 0xE1, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE
};

EXTCONST U8 PL_e2utf[] = { /* UTFEBCDIC (IBM-1047) to I8 */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
 0x2D, 0x2F, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xC5, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB,
 0xCC, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
 0xD3, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xD4, 0xD5, 0xD6, 0x5B, 0xD7, 0xD8,
 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0x5D, 0xE6, 0xE7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3,
 0x5C, 0xF4, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x9F
};
#endif /* 1047 */

#if '^' == 106  /* if defined(_OSD_POSIX) POSIX-BC */
U8 PL_utf2e[] = { /* I8 to UTFEBCDIC (POSIX-BC) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBB, 0xBC, 0xBD, 0x6A, 0x6D,
 0x4A, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xFB, 0x4F, 0xFD, 0xFF, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0x5F,
 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xB0, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
 0x57, 0x58, 0x59, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xD0, 0x70, 0x71, 0x72, 0x73,
 0x74, 0x75, 0x76, 0x77, 0x78, 0x80, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x9A, 0x9B, 0x9C,
 0x9D, 0x9E, 0x9F, 0xA0, 0xAA, 0xAB, 0xAC, 0xAE, 0xAF, 0xBA, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
 0xB7, 0xB8, 0xB9, 0xAD, 0x79, 0xA1, 0xBE, 0xBF, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xDA, 0xDB,
 0xDC, 0xC0, 0xDE, 0xDF, 0xE1, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xFA, 0xDD, 0xFC, 0xE0, 0xFE
};

U8 PL_e2utf[] = { /* UTFEBCDIC (POSIX-BC) to I8 */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0x60, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x9F,
 0x2D, 0x2F, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0x5E, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xE4, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xC5, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB,
 0xCC, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
 0xD3, 0xE5, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xD4, 0xD5, 0xD6, 0xE3, 0xD7, 0xD8,
 0xA9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xD9, 0x5B, 0x5C, 0x5D, 0xE6, 0xE7,
 0xF1, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
 0xBB, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xEE, 0xEF, 0xF0, 0xFC, 0xF2, 0xF3,
 0xFE, 0xF4, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xFB, 0x7B, 0xFD, 0x7D, 0xFF, 0x7E
};
#endif /* POSIX-BC */

#if '^' == 176  /* if defined(??) (OS/400?) 037 */
U8 PL_utf2e[] = { /* I8 to UTFEBCDIC (IBM-037) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x25, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBA, 0xE0, 0xBB, 0xB0, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x15, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
 0x57, 0x58, 0x59, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x70, 0x71, 0x72, 0x73,
 0x74, 0x75, 0x76, 0x77, 0x78, 0x80, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x9A, 0x9B, 0x9C,
 0x9D, 0x9E, 0x9F, 0xA0, 0xAA, 0xAB, 0xAC, 0xAE, 0xAF, 0x5F, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
 0xB7, 0xB8, 0xB9, 0xAD, 0xBD, 0xBC, 0xBE, 0xBF, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xDA, 0xDB,
 0xDC, 0xDD, 0xDE, 0xDF, 0xE1, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE
};

U8 PL_e2utf[] = { /* UTFEBCDIC (IBM-037) to I8 */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x85, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x0A, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0xD9,
 0x2D, 0x2F, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xC5, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB,
 0xCC, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
 0xD3, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xD4, 0xD5, 0xD6, 0xE3, 0xD7, 0xD8,
 0x5E, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0x5B, 0x5D, 0xE5, 0xE4, 0xE6, 0xE7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3,
 0x5C, 0xF4, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x9F
};
#endif          /* 037 */

/* These tables moved from perl.h and converted to hex.
   They map platform code page from/to bottom 256 codes of Unicode (i.e. iso-8859-1).
*/

#if '^' == 95   /* if defined(__MVS__) || defined(??) (VM/ESA?) 1047 */
EXTCONST U8 PL_a2e[] = { /* ASCII (iso-8859-1) to EBCDIC (IBM-1047) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0xAA, 0x4A, 0xB1, 0x9F, 0xB2, 0x6A, 0xB5, 0xBB, 0xB4, 0x9A, 0x8A, 0xB0, 0xCA, 0xAF, 0xBC,
 0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3, 0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
 0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68, 0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
 0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF, 0x80, 0xFD, 0xFE, 0xFB, 0xFC, 0xBA, 0xAE, 0x59,
 0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48, 0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
 0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1, 0x70, 0xDD, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
};

EXTCONST U8 PL_e2a[] = { /* EBCDIC (IBM-1047) to ASCII (iso-8859-1) */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0xA2, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
 0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
 0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
 0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0x5B, 0xDE, 0xAE,
 0xAC, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0xDD, 0xA8, 0xAF, 0x5D, 0xB4, 0xD7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
 0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA, 0x9F
};

EXTCONST U8 PL_latin1_lc[] = {  /* lowercasing */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 0x60, 0x61, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 0x70, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 0x70, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9C, 0x9F,
 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0x8C, 0xAD, 0x8E, 0xAF,
 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0x8D, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 0xC0, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 0xD0, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
 0xE0, 0xE1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xEA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xDB, 0xDC, 0xDD, 0xDE, 0xFF
};

EXTCONST  U8 PL_mod_latin1_uc[] = {  /* uppercasing */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 0x40, 0x41, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 0x50, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0xDF, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 0x80, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 0x80, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0x8A, 0x8B, 0xAC, 0xBA, 0xAE, 0x8F,
 0x90, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0x9A, 0x9B, 0x9E, 0x9D, 0x9E, 0x9F,
 0xDF, 0xA1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

EXTCONST U8 PL_fold_latin1[] = { /* fast EBCDIC case folding table,
                                               'A' => 'a'; 'a' => 'A'; full
                                               0-255 range */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	98,	99,	100,	101,	102,	103,
	104,	105,	74,	75,	76,	77,	78,	79,
	80,	113,	114,	115,	116,	117,	118,	119,
	120,	89,	90,	91,	92,	93,	94,	95,
	96,	97,	66,	67,	68,	69,	70,	71,
	72,	73,	106,	107,	108,	109,	110,	111,
	128,	81,	82,	83,	84,	85,	86,	87,
	88,	121,	122,	123,	124,	125,	126,	127,
	112,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	138,	139,	172,	186,	174,	143,
	144,	'J',	'K',	'L',	'M',	'N',	'O',	'P',
	'Q',	'R',	154,	155,	158,	157,	156,	159,
	160,	161,	'S',	'T',	'U',	'V',	'W',	'X',
	'Y',	'Z',	170,	171,	140,	173,	142,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	141,	187,	188,	189,	190,	191,
	192,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	202,	235,	236,	237,	238,	239,
	208,	'j',	'k',	'l',	'm',	'n',	'o',	'p',
	'q',	'r',	218,	251,	252,	253,	254,	223,
	224,	225,	's',	't',	'u',	'v',	'w',	'x',
	'y',	'z',	234,	203,	204,	205,	206,	207,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	219,	220,	221,	222,	255
};
#endif /* 1047 */

#if '^' == 106  /* if defined(_OSD_POSIX) POSIX-BC */
EXTCONST U8 PL_a2e[] = { /* ASCII (ISO8859-1) to EBCDIC (POSIX-BC) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBB, 0xBC, 0xBD, 0x6A, 0x6D,
 0x4A, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xFB, 0x4F, 0xFD, 0xFF, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0x5F,
 0x41, 0xAA, 0xB0, 0xB1, 0x9F, 0xB2, 0xD0, 0xB5, 0x79, 0xB4, 0x9A, 0x8A, 0xBA, 0xCA, 0xAF, 0xA1,
 0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3, 0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
 0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68, 0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
 0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF, 0x80, 0xE0, 0xFE, 0xDD, 0xFC, 0xAD, 0xAE, 0x59,
 0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48, 0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
 0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1, 0x70, 0xC0, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
};

EXTCONST U8 PL_e2a[] = { /* EBCDIC (POSIX-BC) to ASCII (ISO8859-1) */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0x60, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x9F,
 0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0x5E, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0xA8, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
 0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
 0xB5, 0xAF, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,
 0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0xAC, 0x5B, 0x5C, 0x5D, 0xB4, 0xD7,
 0xF9, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
 0xA6, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xDB, 0xFA, 0xFF,
 0xD9, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0x7B, 0xDC, 0x7D, 0xDA, 0x7E
};

EXTCONST U8 PL_latin1_lc[] = {  /* lowercasing */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 0x60, 0x61, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 0x70, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 0x70, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9C, 0x9F,
 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0x8C, 0x8D, 0x8E, 0xAF,
 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 0xC0, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 0xD0, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0xDA, 0xDB, 0xDC, 0xDB, 0xDE, 0xDF,
 0xC0, 0xE1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xEA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xFD, 0xDE, 0xFF
};

EXTCONST  U8 PL_mod_latin1_uc[] = {  /* uppercasing */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 0x40, 0x41, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 0x50, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0xDF, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 0x80, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 0x80, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0x8A, 0x8B, 0xAC, 0xAD, 0xAE, 0x8F,
 0x90, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0x9A, 0x9B, 0x9E, 0x9D, 0x9E, 0x9F,
 0xDF, 0xA1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 0xE0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDD, 0xFC, 0xDD, 0xFE, 0xDF,
 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

EXTCONST U8 PL_fold_latin1[] = { /* fast EBCDIC case folding table,
                                               'A' => 'a'; 'a' => 'A'; full
                                               0-255 range */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	98,	99,	100,	101,	102,	103,
	104,	105,	74,	75,	76,	77,	78,	79,
	80,	113,	114,	115,	116,	117,	118,	119,
	120,	89,	90,	91,	92,	93,	94,	95,
	96,	97,	66,	67,	68,	69,	70,	71,
	72,	73,	106,	107,	108,	109,	110,	111,
	128,	81,	82,	83,	84,	85,	86,	87,
	88,	121,	122,	123,	124,	125,	126,	127,
	112,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	138,	139,	172,	173,	174,	143,
	144,	'J',	'K',	'L',	'M',	'N',	'O',	'P',
	'Q',	'R',	154,	155,	158,	157,	156,	159,
	160,	161,	'S',	'T',	'U',	'V',	'W',	'X',
	'Y',	'Z',	170,	171,	140,	141,	142,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	224,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	202,	235,	236,	237,	238,	239,
	208,	'j',	'k',	'l',	'm',	'n',	'o',	'p',
	'q',	'r',	218,	221,	252,	219,	254,	223,
	192,	225,	's',	't',	'u',	'v',	'w',	'x',
	'y',	'z',	234,	203,	204,	205,	206,	207,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	220,	253,	222,	255
};
#endif          /* POSIX-BC */

#if '^' == 176  /* if defined(??) (OS/400?) 037 */
EXTCONST U8 PL_a2e[] = { /* ASCII (ISO8859-1) to EBCDIC (IBM-037) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x25, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBA, 0xE0, 0xBB, 0xB0, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x15, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0xAA, 0x4A, 0xB1, 0x9F, 0xB2, 0x6A, 0xB5, 0xBD, 0xB4, 0x9A, 0x8A, 0x5F, 0xCA, 0xAF, 0xBC,
 0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3, 0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
 0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68, 0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
 0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF, 0x80, 0xFD, 0xFE, 0xFB, 0xFC, 0xAD, 0xAE, 0x59,
 0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48, 0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
 0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1, 0x70, 0xDD, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
};

EXTCONST U8 PL_e2a[] = { /* EBCDIC (IBM-037) to ASCII (ISO8859-1) */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x85, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x0A, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0xA2, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0xAC,
 0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
 0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
 0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,
 0x5E, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0x5B, 0x5D, 0xAF, 0xA8, 0xB4, 0xD7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
 0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA, 0x9F
};

EXTCONST U8 PL_latin1_lc[] = {  /* lowercasing */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 0x60, 0x61, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 0x70, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 0x70, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9C, 0x9F,
 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0x8C, 0x8D, 0x8E, 0xAF,
 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 0xC0, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 0xD0, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
 0xE0, 0xE1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xEA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xDB, 0xDC, 0xDD, 0xDE, 0xFF
};

EXTCONST  U8 PL_mod_latin1_uc[] = {  /* uppercasing */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 0x40, 0x41, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 0x50, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0xDF, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 0x80, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 0x80, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0x8A, 0x8B, 0xAC, 0xAD, 0xAE, 0x8F,
 0x90, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0x9A, 0x9B, 0x9E, 0x9D, 0x9E, 0x9F,
 0xDF, 0xA1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

EXTCONST U8 PL_fold_latin1[] = { /* fast EBCDIC case folding table,
                                               'A' => 'a'; 'a' => 'A'; full
                                               0-255 range */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	98,	99,	100,	101,	102,	103,
	104,	105,	74,	75,	76,	77,	78,	79,
	80,	113,	114,	115,	116,	117,	118,	119,
	120,	89,	90,	91,	92,	93,	94,	95,
	96,	97,	66,	67,	68,	69,	70,	71,
	72,	73,	106,	107,	108,	109,	110,	111,
	128,	81,	82,	83,	84,	85,	86,	87,
	88,	121,	122,	123,	124,	125,	126,	127,
	112,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	138,	139,	172,	173,	174,	143,
	144,	'J',	'K',	'L',	'M',	'N',	'O',	'P',
	'Q',	'R',	154,	155,	158,	157,	156,	159,
	160,	161,	'S',	'T',	'U',	'V',	'W',	'X',
	'Y',	'Z',	170,	171,	140,	141,	142,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	202,	235,	236,	237,	238,	239,
	208,	'j',	'k',	'l',	'm',	'n',	'o',	'p',
	'q',	'r',	218,	251,	252,	253,	254,	223,
	224,	225,	's',	't',	'u',	'v',	'w',	'x',
	'y',	'z',	234,	203,	204,	205,	206,	207,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	219,	220,	221,	222,	255
};
#endif          /* 037 */

/* This is the same in all code pages, as only A-Z, a-z are affected */
EXTCONST U8 PL_fold[] = { /* fast EBCDIC case folding table, 'A' =>
                                        'a'; 'a' => 'A' */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	66,	67,	68,	69,	70,	71,
	72,	73,	74,	75,	76,	77,	78,	79,
	80,	81,	82,	83,	84,	85,	86,	87,
	88,	89,	90,	91,	92,	93,	94,	95,
	96,	97,	98,	99,	100,	101,	102,	103,
	104,	105,	106,	107,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	118,	119,
	120,	121,	122,	123,	124,	125,	126,	127,
	128,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	138,	139,	140,	141,	142,	143,
	144,	'J',	'K',	'L',	'M',	'N',	'O',	'P',
	'Q',	'R',	154,	155,	156,	157,	158,	159,
	160,	161,	'S',	'T',	'U',	'V',	'W',	'X',
	'Y',	'Z',	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	202,	203,	204,	205,	206,	207,
	208,	'j',	'k',	'l',	'm',	'n',	'o',	'p',
	'q',	'r',	218,	219,	220,	221,	222,	223,
	224,	225,	's',	't',	'u',	'v',	'w',	'x',
	'y',	'z',	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};

#else
EXTCONST U8 PL_utf8skip[];
EXTCONST U8 PL_e2utf[];
EXTCONST U8 PL_utf2e[];
EXTCONST U8 PL_e2a[];
EXTCONST U8 PL_a2e[];
EXTCONST U8 PL_fold[];
EXTCONST U8 PL_fold_latin1[];
EXTCONST U8 PL_latin1_lc[];
EXTCONST U8 PL_mod_latin1_uc[];
#endif

END_EXTERN_C

/* EBCDIC-happy ways of converting native code to UTF-8 */

#define NATIVE_TO_LATIN1(ch)            PL_e2a[(U8)(ch)]
#define LATIN1_TO_NATIVE(ch)            PL_a2e[(U8)(ch)]

#define NATIVE_UTF8_TO_I8(ch)           PL_e2utf[(U8)(ch)]
#define I8_TO_NATIVE_UTF8(ch)           PL_utf2e[(U8)(ch)]

/* Transforms in wide UV chars */
#define NATIVE_TO_UNI(ch)        (((ch) > 255) ? (ch) : NATIVE_TO_LATIN1(ch))
#define UNI_TO_NATIVE(ch)        (((ch) > 255) ? (ch) : LATIN1_TO_NATIVE(ch))

/*
  The following table is adapted from tr16, it shows I8 encoding of Unicode code points.

        Unicode                             Bit pattern 1st Byte 2nd Byte 3rd Byte 4th Byte 5th Byte 6th Byte 7th byte
    U+0000..U+007F                     000000000xxxxxxx 0xxxxxxx
    U+0080..U+009F                     00000000100xxxxx 100xxxxx
    U+00A0..U+03FF                     000000yyyyyxxxxx 110yyyyy 101xxxxx
    U+0400..U+3FFF                     00zzzzyyyyyxxxxx 1110zzzz 101yyyyy 101xxxxx
    U+4000..U+3FFFF                 0wwwzzzzzyyyyyxxxxx 11110www 101zzzzz 101yyyyy 101xxxxx
   U+40000..U+3FFFFF            0vvwwwwwzzzzzyyyyyxxxxx 111110vv 101wwwww 101zzzzz 101yyyyy 101xxxxx
  U+400000..U+3FFFFFF       0uvvvvvwwwwwzzzzzyyyyyxxxxx 1111110u 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx
 U+4000000..U+7FFFFFFF 0tuuuuuvvvvvwwwwwzzzzzyyyyyxxxxx 1111111t 101uuuuu 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx

  Note: The I8 transformation is valid for UCS-4 values X'0' to
  X'7FFFFFFF' (the full extent of ISO/IEC 10646 coding space).

 */

/* Input is a true Unicode (not-native) code point */
#define OFFUNISKIP(uv) ( (uv) < 0xA0        ? 1 : \
		      (uv) < 0x400          ? 2 : \
		      (uv) < 0x4000         ? 3 : \
		      (uv) < 0x40000        ? 4 : \
		      (uv) < 0x400000       ? 5 : \
		      (uv) < 0x4000000      ? 6 : 7 )

#define UNI_IS_INVARIANT(c)		(((UV)(c)) <  0xA0)

/* UTF-EBCDIC semantic macros - transform back into I8 and then compare
 * Comments as to the meaning of each are given at their corresponding utf8.h
 * definitions */

#define UTF8_IS_START(c)		(NATIVE_UTF8_TO_I8(c) >= 0xC5     \
                                         && NATIVE_UTF8_TO_I8(c) != 0xE0)
#define UTF8_IS_CONTINUATION(c)		((NATIVE_UTF8_TO_I8(c) & 0xE0) == 0xA0)
#define UTF8_IS_CONTINUED(c) 		(NATIVE_UTF8_TO_I8(c) >= 0xA0)

#define UTF8_IS_DOWNGRADEABLE_START(c)	(NATIVE_UTF8_TO_I8(c) >= 0xC5     \
                                         && NATIVE_UTF8_TO_I8(c) <= 0xC7)
/* Saying it this way adds a runtime test, but removes 2 run-time lookups */
/*#define UTF8_IS_DOWNGRADEABLE_START(c)  ((c) == I8_TO_NATIVE_UTF8(0xC5)     \
                                         || (c) == I8_TO_NATIVE_UTF8(0xC6)  \
                                         || (c) == I8_TO_NATIVE_UTF8(0xC7))
*/
#define UTF8_IS_ABOVE_LATIN1(c)	(NATIVE_UTF8_TO_I8(c) >= 0xC8)

/* Can't exceed 7 on EBCDIC platforms */
#define UTF_START_MARK(len) (0xFF & (0xFE << (7-(len))))

#define UTF_START_MASK(len) (((len) >= 6) ? 0x01 : (0x1F >> ((len)-2)))
#define UTF_CONTINUATION_MARK		0xA0
#define UTF_CONTINUATION_MASK		((U8)0x1f)
#define UTF_ACCUMULATION_SHIFT		5

/* How wide can a single UTF-8 encoded character become in bytes. */
/* NOTE: Strictly speaking Perl's UTF-8 should not be called UTF-8 since UTF-8
 * is an encoding of Unicode, and Unicode's upper limit, 0x10FFFF, can be
 * expressed with 5 bytes.  However, Perl thinks of UTF-8 as a way to encode
 * non-negative integers in a binary format, even those above Unicode */
#define UTF8_MAXBYTES 7

/* The maximum number of UTF-8 bytes a single Unicode character can
 * uppercase/lowercase/fold into.  Unicode guarantees that the maximum
 * expansion is 3 characters.  On EBCDIC platforms, the highest Unicode
 * character occupies 5 bytes, therefore this number is 15 */
#define UTF8_MAXBYTES_CASE	15

#define MAX_UTF8_TWO_BYTE 0x3FF

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/util.h                                                    0100644 0000000 0000000 00000005042 12744441327 017063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    util.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1999, 2001, 2002, 2003, 2004, 2005,
 *    2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef VMS
#  define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || (strchr(f,':')						\
	     || ((*(f) == '[' || *(f) == '<')				\
		 && (isWORDCHAR((f)[1]) || strchr("$-_]>",(f)[1])))))

#else		/* !VMS */
#  if defined(WIN32) || defined(__CYGWIN__)
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/' || *(f) == '\\'		/* UNC/rooted path */	\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#  else		/* !WIN32 */
#  ifdef NETWARE
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(((f)[0] && (f)[1] == ':')		/* drive name */	\
	 || ((f)[0] == '\\' && (f)[1] == '\\')	/* UNC path */	\
	 ||	((f)[3] == ':'))				/* volume name, currently only sys */
#  else		/* !NETWARE */
#    if defined(DOSISH) || defined(__SYMBIAN32__)
#      define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#    else	/* NEITHER DOSISH NOR SYMBIANISH */
#      define PERL_FILE_IS_ABSOLUTE(f)	(*(f) == '/')
#    endif	/* DOSISH */
#   endif	/* NETWARE */
#  endif	/* WIN32 */
#endif		/* VMS */

/*
=for apidoc ibcmp

This is a synonym for (! foldEQ())

=for apidoc ibcmp_locale

This is a synonym for (! foldEQ_locale())

=cut
*/
#define ibcmp(s1, s2, len)         cBOOL(! foldEQ(s1, s2, len))
#define ibcmp_locale(s1, s2, len)  cBOOL(! foldEQ_locale(s1, s2, len))

/* outside the core, perl.h undefs HAS_QUAD if IV isn't 64-bit
   We can't swap this to HAS_QUAD, because the logic here affects the type of
   perl_drand48_t below, and that is visible outside of the core.  */
#if defined(U64TYPE) && !defined(USING_MSVC6)
/* use a faster implementation when quads are available,
 * but not with VC6 on Windows */
#    define PERL_DRAND48_QUAD
#endif

#ifdef PERL_DRAND48_QUAD

/* U64 is only defined under PERL_CORE, but this needs to be visible
 * elsewhere so the definition of PerlInterpreter is complete.
 */
typedef U64TYPE perl_drand48_t;

#else

struct PERL_DRAND48_T {
    U16 seed[3];
};

typedef struct PERL_DRAND48_T perl_drand48_t;

#endif

#define PL_RANDOM_STATE_TYPE perl_drand48_t

#define Perl_drand48_init(seed) (Perl_drand48_init_r(&PL_random_state, (seed)))
#define Perl_drand48() (Perl_drand48_r(&PL_random_state))

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/uudmap.h                                                  0100644 0000000 0000000 00000001610 12744441327 017376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
}
                                                                                                                        usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/vutil.h                                                   0100644 0000000 0000000 00000016102 12744441327 017250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* This file is part of the "version" CPAN distribution.  Please avoid
   editing it in the perl core. */

#ifndef PERL_CORE
#  include "ppport.h"
#endif

/* The MUTABLE_*() macros cast pointers to the types shown, in such a way
 * (compiler permitting) that casting away const-ness will give a warning;
 * e.g.:
 *
 * const SV *sv = ...;
 * AV *av1 = (AV*)sv;        <== BAD:  the const has been silently cast away
 * AV *av2 = MUTABLE_AV(sv); <== GOOD: it may warn
 */

#ifndef MUTABLE_PTR
#  if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define MUTABLE_PTR(p) ({ void *_p = (p); _p; })
#  else
#    define MUTABLE_PTR(p) ((void *) (p))
#  endif

#  define MUTABLE_AV(p)	((AV *)MUTABLE_PTR(p))
#  define MUTABLE_CV(p)	((CV *)MUTABLE_PTR(p))
#  define MUTABLE_GV(p)	((GV *)MUTABLE_PTR(p))
#  define MUTABLE_HV(p)	((HV *)MUTABLE_PTR(p))
#  define MUTABLE_IO(p)	((IO *)MUTABLE_PTR(p))
#  define MUTABLE_SV(p)	((SV *)MUTABLE_PTR(p))
#endif

#ifndef SvPVx_nolen_const
#  if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
#  else
#    define SvPVx_nolen_const(sv) (SvPV_nolen_const(sv))
#  endif
#endif

#ifndef PERL_ARGS_ASSERT_CK_WARNER
static void Perl_ck_warner(pTHX_ U32 err, const char* pat, ...);

#  ifdef vwarner
static
void
Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
{
  va_list args;

  PERL_UNUSED_ARG(err);
  if (ckWARN(err)) {
    va_list args;
    va_start(args, pat);
    vwarner(err, pat, &args);
    va_end(args);
  }
}
#  else
/* yes this replicates my_warner */
static
void
Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
{
  SV *sv;
  va_list args;

  PERL_UNUSED_ARG(err);

  va_start(args, pat);
  sv = vnewSVpvf(pat, &args);
  va_end(args);
  sv_2mortal(sv);
  warn("%s", SvPV_nolen(sv));
}
#  endif
#endif

#define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#define PERL_DECIMAL_VERSION \
	PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#define PERL_VERSION_LT(r,v,s) \
	(PERL_DECIMAL_VERSION < PERL_VERSION_DECIMAL(r,v,s))
#define PERL_VERSION_GE(r,v,s) \
	(PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))

#if PERL_VERSION_LT(5,15,4)
#  define ISA_VERSION_OBJ(v) (sv_isobject(v) && sv_derived_from(v,"version"))
#else
#  define ISA_VERSION_OBJ(v) (sv_isobject(v) && sv_derived_from_pvn(v,"version",7,0))
#endif


#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#if PERL_VERSION_GE(5,9,0) && !defined(PERL_CORE)

#  define VUTIL_REPLACE_CORE 1

const char * Perl_scan_version2(pTHX_ const char *s, SV *rv, bool qv);
SV * Perl_new_version2(pTHX_ SV *ver);
SV * Perl_upg_version2(pTHX_ SV *sv, bool qv);
SV * Perl_vstringify2(pTHX_ SV *vs);
SV * Perl_vverify2(pTHX_ SV *vs);
SV * Perl_vnumify2(pTHX_ SV *vs);
SV * Perl_vnormal2(pTHX_ SV *vs);
SV * Perl_vstringify2(pTHX_ SV *vs);
int Perl_vcmp2(pTHX_ SV *lsv, SV *rsv);
const char * Perl_prescan_version2(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha);

#  define SCAN_VERSION(a,b,c)	Perl_scan_version2(aTHX_ a,b,c)
#  define NEW_VERSION(a)	Perl_new_version2(aTHX_ a)
#  define UPG_VERSION(a,b)	Perl_upg_version2(aTHX_ a, b)
#  define VSTRINGIFY(a)		Perl_vstringify2(aTHX_ a)
#  define VVERIFY(a)		Perl_vverify2(aTHX_ a)
#  define VNUMIFY(a)		Perl_vnumify2(aTHX_ a)
#  define VNORMAL(a)		Perl_vnormal2(aTHX_ a)
#  define VCMP(a,b)		Perl_vcmp2(aTHX_ a,b)
#  define PRESCAN_VERSION(a,b,c,d,e,f,g)	Perl_prescan_version2(aTHX_ a,b,c,d,e,f,g)
#  undef is_LAX_VERSION
#  define is_LAX_VERSION(a,b) \
	(a != Perl_prescan_version2(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))
#  undef is_STRICT_VERSION
#  define is_STRICT_VERSION(a,b) \
	(a != Perl_prescan_version2(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))

#else

const char * Perl_scan_version(pTHX_ const char *s, SV *rv, bool qv);
SV * Perl_new_version(pTHX_ SV *ver);
SV * Perl_upg_version(pTHX_ SV *sv, bool qv);
SV * Perl_vverify(pTHX_ SV *vs);
SV * Perl_vnumify(pTHX_ SV *vs);
SV * Perl_vnormal(pTHX_ SV *vs);
SV * Perl_vstringify(pTHX_ SV *vs);
int Perl_vcmp(pTHX_ SV *lsv, SV *rsv);
const char * Perl_prescan_version(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha);

#  define SCAN_VERSION(a,b,c)	Perl_scan_version(aTHX_ a,b,c)
#  define NEW_VERSION(a)	Perl_new_version(aTHX_ a)
#  define UPG_VERSION(a,b)	Perl_upg_version(aTHX_ a, b)
#  define VSTRINGIFY(a)		Perl_vstringify(aTHX_ a)
#  define VVERIFY(a)		Perl_vverify(aTHX_ a)
#  define VNUMIFY(a)		Perl_vnumify(aTHX_ a)
#  define VNORMAL(a)		Perl_vnormal(aTHX_ a)
#  define VCMP(a,b)		Perl_vcmp(aTHX_ a,b)

#  define PRESCAN_VERSION(a,b,c,d,e,f,g)	Perl_prescan_version(aTHX_ a,b,c,d,e,f,g)
#  ifndef is_LAX_VERSION
#    define is_LAX_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))
#  endif
#  ifndef is_STRICT_VERSION
#    define is_STRICT_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))
#  endif

#endif

#if PERL_VERSION_LT(5,11,4)
#  define BADVERSION(a,b,c) \
	if (b) { \
	    *b = c; \
	} \
	return a;

#  define PERL_ARGS_ASSERT_PRESCAN_VERSION	\
	assert(s); assert(sqv); assert(ssaw_decimal);\
	assert(swidth); assert(salpha);

#  define PERL_ARGS_ASSERT_SCAN_VERSION	\
	assert(s); assert(rv)
#  define PERL_ARGS_ASSERT_NEW_VERSION	\
	assert(ver)
#  define PERL_ARGS_ASSERT_UPG_VERSION	\
	assert(ver)
#  define PERL_ARGS_ASSERT_VVERIFY	\
	assert(vs)
#  define PERL_ARGS_ASSERT_VNUMIFY	\
	assert(vs)
#  define PERL_ARGS_ASSERT_VNORMAL	\
	assert(vs)
#  define PERL_ARGS_ASSERT_VSTRINGIFY	\
	assert(vs)
#  define PERL_ARGS_ASSERT_VCMP	\
	assert(lhv); assert(rhv)
#  define PERL_ARGS_ASSERT_CK_WARNER      \
	assert(pat)
#endif


#if PERL_VERSION_LT(5,19,0)
# undef STORE_NUMERIC_LOCAL_SET_STANDARD
# undef RESTORE_NUMERIC_LOCAL
# ifdef USE_LOCALE
#  define STORE_NUMERIC_LOCAL_SET_STANDARD()\
	char *loc = savepv(setlocale(LC_NUMERIC, NULL)); \
	SAVEFREEPV(loc); \
	setlocale(LC_NUMERIC, "C");

#  define RESTORE_NUMERIC_LOCAL()\
	setlocale(LC_NUMERIC, loc);
# else
#  define STORE_NUMERIC_LOCAL_SET_STANDARD()
#  define RESTORE_NUMERIC_LOCAL()
# endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/warnings.h                                                0100644 0000000 0000000 00000011705 12744441327 017741  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/warnings.pl.
   Any changes made here will be lost!
 */


#define Off(x)			((x) / 8)
#define Bit(x)			(1 << ((x) % 8))
#define IsSet(a, x)		((a)[Off(x)] & Bit(x))


#define G_WARN_OFF		0 	/* $^W == 0 */
#define G_WARN_ON		1	/* -w flag and $^W != 0 */
#define G_WARN_ALL_ON		2	/* -W flag */
#define G_WARN_ALL_OFF		4	/* -X flag */
#define G_WARN_ONCE		8	/* set if 'once' ever enabled */
#define G_WARN_ALL_MASK		(G_WARN_ALL_ON|G_WARN_ALL_OFF)

#define pWARN_STD		NULL
#define pWARN_ALL		(((STRLEN*)0)+1)    /* use warnings 'all' */
#define pWARN_NONE		(((STRLEN*)0)+2)    /* no  warnings 'all' */

#define specialWARN(x)		((x) == pWARN_STD || (x) == pWARN_ALL ||	\
				 (x) == pWARN_NONE)

/* if PL_warnhook is set to this value, then warnings die */
#define PERL_WARNHOOK_FATAL	(&PL_sv_placeholder)

/* Warnings Categories added in Perl 5.008 */

#define WARN_ALL		 0
#define WARN_CLOSURE		 1
#define WARN_DEPRECATED		 2
#define WARN_EXITING		 3
#define WARN_GLOB		 4
#define WARN_IO			 5
#define WARN_CLOSED		 6
#define WARN_EXEC		 7
#define WARN_LAYER		 8
#define WARN_NEWLINE		 9
#define WARN_PIPE		 10
#define WARN_UNOPENED		 11
#define WARN_MISC		 12
#define WARN_NUMERIC		 13
#define WARN_ONCE		 14
#define WARN_OVERFLOW		 15
#define WARN_PACK		 16
#define WARN_PORTABLE		 17
#define WARN_RECURSION		 18
#define WARN_REDEFINE		 19
#define WARN_REGEXP		 20
#define WARN_SEVERE		 21
#define WARN_DEBUGGING		 22
#define WARN_INPLACE		 23
#define WARN_INTERNAL		 24
#define WARN_MALLOC		 25
#define WARN_SIGNAL		 26
#define WARN_SUBSTR		 27
#define WARN_SYNTAX		 28
#define WARN_AMBIGUOUS		 29
#define WARN_BAREWORD		 30
#define WARN_DIGIT		 31
#define WARN_PARENTHESIS	 32
#define WARN_PRECEDENCE		 33
#define WARN_PRINTF		 34
#define WARN_PROTOTYPE		 35
#define WARN_QW			 36
#define WARN_RESERVED		 37
#define WARN_SEMICOLON		 38
#define WARN_TAINT		 39
#define WARN_THREADS		 40
#define WARN_UNINITIALIZED	 41
#define WARN_UNPACK		 42
#define WARN_UNTIE		 43
#define WARN_UTF8		 44
#define WARN_VOID		 45

/* Warnings Categories added in Perl 5.011 */

#define WARN_IMPRECISION	 46
#define WARN_ILLEGALPROTO	 47

/* Warnings Categories added in Perl 5.013 */

#define WARN_NON_UNICODE	 48
#define WARN_NONCHAR		 49
#define WARN_SURROGATE		 50

/* Warnings Categories added in Perl 5.017 */

#define WARN_EXPERIMENTAL	 51
#define WARN_EXPERIMENTAL__LEXICAL_SUBS 52
#define WARN_EXPERIMENTAL__LEXICAL_TOPIC 53
#define WARN_EXPERIMENTAL__REGEX_SETS 54
#define WARN_EXPERIMENTAL__SMARTMATCH 55

/* Warnings Categories added in Perl 5.019 */

#define WARN_EXPERIMENTAL__AUTODEREF 56
#define WARN_EXPERIMENTAL__POSTDEREF 57
#define WARN_EXPERIMENTAL__SIGNATURES 58
#define WARN_SYSCALLS		 59

#define WARNsize		15
#define WARN_ALLstring		"\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125"
#define WARN_NONEstring		"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

#define isLEXWARN_on 	(PL_curcop->cop_warnings != pWARN_STD)
#define isLEXWARN_off	(PL_curcop->cop_warnings == pWARN_STD)
#define isWARN_ONCE	(PL_dowarn & (G_WARN_ON|G_WARN_ONCE))
#define isWARN_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)))
#define isWARNf_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)+1))

#define DUP_WARNINGS(p)		\
    (specialWARN(p) ? (STRLEN*)(p)	\
    : (STRLEN*)CopyD(p, PerlMemShared_malloc(sizeof(*p)+*p), sizeof(*p)+*p, \
		     			     char))

#define ckWARN(w)		Perl_ckwarn(aTHX_ packWARN(w))

/* The w1, w2 ... should be independent warnings categories; one shouldn't be
 * a subcategory of any other */

#define ckWARN2(w1,w2)		Perl_ckwarn(aTHX_ packWARN2(w1,w2))
#define ckWARN3(w1,w2,w3)	Perl_ckwarn(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4(w1,w2,w3,w4)	Perl_ckwarn(aTHX_ packWARN4(w1,w2,w3,w4))

#define ckWARN_d(w)		Perl_ckwarn_d(aTHX_ packWARN(w))
#define ckWARN2_d(w1,w2)	Perl_ckwarn_d(aTHX_ packWARN2(w1,w2))
#define ckWARN3_d(w1,w2,w3)	Perl_ckwarn_d(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4_d(w1,w2,w3,w4)	Perl_ckwarn_d(aTHX_ packWARN4(w1,w2,w3,w4))

#define WARNshift		8

#define packWARN(a)		(a                                      )

/* The a, b, ... should be independent warnings categories; one shouldn't be
 * a subcategory of any other */

#define packWARN2(a,b)		((a) | ((b)<<8)                         )
#define packWARN3(a,b,c)	((a) | ((b)<<8) | ((c)<<16)             )
#define packWARN4(a,b,c,d)	((a) | ((b)<<8) | ((c)<<16) | ((d) <<24))

#define unpackWARN1(x)		((x)        & 0xFF)
#define unpackWARN2(x)		(((x) >>8)  & 0xFF)
#define unpackWARN3(x)		(((x) >>16) & 0xFF)
#define unpackWARN4(x)		(((x) >>24) & 0xFF)

#define ckDEAD(x)							\
	   ( ! specialWARN(PL_curcop->cop_warnings) &&			\
	    ( isWARNf_on(PL_curcop->cop_warnings, WARN_ALL) || 		\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN1(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN2(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN3(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN4(x))))

/* end of file warnings.h */

/* ex: set ro: */
                                                           usr/lib/x86_64-linux-gnu/perl/5.20.2/Compress/                                                      0040755 0000000 0000000 00000000000 13077704254 017003  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/x86_64-linux-gnu/perl/5.20.2/Compress/Raw/                                                  0040755 0000000 0000000 00000000000 13077704254 017534  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/x86_64-linux-gnu/perl/5.20.2/Compress/Raw/Bzip2.pm                                          0100644 0000000 0000000 00000024701 12744441327 021060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package Compress::Raw::Bzip2;

use strict ;
use warnings ;

require 5.006 ;
require Exporter;
use Carp ;

use bytes ;
our ($VERSION, $XS_VERSION, @ISA, @EXPORT, $AUTOLOAD);

$VERSION = '2.064';
$XS_VERSION = $VERSION; 
$VERSION = eval $VERSION;

@ISA = qw(Exporter);
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
@EXPORT = qw(
		BZ_RUN
		BZ_FLUSH
		BZ_FINISH

		BZ_OK
		BZ_RUN_OK
		BZ_FLUSH_OK
		BZ_FINISH_OK
		BZ_STREAM_END
		BZ_SEQUENCE_ERROR
		BZ_PARAM_ERROR
		BZ_MEM_ERROR
		BZ_DATA_ERROR
		BZ_DATA_ERROR_MAGIC
		BZ_IO_ERROR
		BZ_UNEXPECTED_EOF
		BZ_OUTBUFF_FULL
		BZ_CONFIG_ERROR

    );

sub AUTOLOAD {
    my($constname);
    ($constname = $AUTOLOAD) =~ s/.*:://;
    my ($error, $val) = constant($constname);
    Carp::croak $error if $error;
    no strict 'refs';
    *{$AUTOLOAD} = sub { $val };
    goto &{$AUTOLOAD};

}

use constant FLAG_APPEND             => 1 ;
use constant FLAG_CRC                => 2 ;
use constant FLAG_ADLER              => 4 ;
use constant FLAG_CONSUME_INPUT      => 8 ;

eval {
    require XSLoader;
    XSLoader::load('Compress::Raw::Bzip2', $XS_VERSION);
    1;
} 
or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap Compress::Raw::Bzip2 $XS_VERSION ; 
};

#sub Compress::Raw::Bzip2::new
#{
#    my $class = shift ;
#    my ($ptr, $status) = _new(@_);
#    return wantarray ? (undef, $status) : undef
#        unless $ptr ;
#    my $obj = bless [$ptr], $class ;
#    return wantarray ? ($obj, $status) : $obj;
#}
#
#package Compress::Raw::Bunzip2 ;
#
#sub Compress::Raw::Bunzip2::new
#{
#    my $class = shift ;
#    my ($ptr, $status) = _new(@_);
#    return wantarray ? (undef, $status) : undef
#        unless $ptr ;
#    my $obj = bless [$ptr], $class ;
#    return wantarray ? ($obj, $status) : $obj;
#}

sub Compress::Raw::Bzip2::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Bzip2::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}

sub Compress::Raw::Bunzip2::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Bunzip2::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}


package Compress::Raw::Bzip2;

1;

__END__


=head1 NAME

Compress::Raw::Bzip2 - Low-Level Interface to bzip2 compression library

=head1 SYNOPSIS

    use Compress::Raw::Bzip2 ;

    my ($bz, $status) = new Compress::Raw::Bzip2 [OPTS]
        or die "Cannot create bzip2 object: $bzerno\n";
    
    $status = $bz->bzdeflate($input, $output);
    $status = $bz->bzflush($output);
    $status = $bz->bzclose($output);

    my ($bz, $status) = new Compress::Raw::Bunzip2 [OPTS]
        or die "Cannot create bunzip2 object: $bzerno\n";
    
    $status = $bz->bzinflate($input, $output);

    my $version = Compress::Raw::Bzip2::bzlibversion();

=head1 DESCRIPTION

C<Compress::Raw::Bzip2> provides an interface to the in-memory
compression/uncompression functions from the bzip2 compression library. 

Although the primary purpose for the existence of C<Compress::Raw::Bzip2>
is for use by the  C<IO::Compress::Bzip2> and C<IO::Compress::Bunzip2>
modules, it can be used on its own for simple compression/uncompression
tasks.

=head1 Compression

=head2 ($z, $status) = new Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;

Creates a new compression object. 

If successful, it will return the initialised compression object, C<$z>
and a C<$status> of C<BZ_OK> in a list context. In scalar context it
returns the deflation object, C<$z>, only.

If not successful, the returned compression object, C<$z>, will be
I<undef> and C<$status> will hold the a I<bzip2> error code.

Below is a list of the valid options:

=over 5

=item B<$appendOutput>

Controls whether the compressed data is appended to the output buffer in
the C<bzdeflate>, C<bzflush> and C<bzclose> methods.

Defaults to 1.

=item B<$blockSize100k>

To quote the bzip2 documentation

    blockSize100k specifies the block size to be used for compression. It
    should be a value between 1 and 9 inclusive, and the actual block size
    used is 100000 x this figure. 9 gives the best compression but takes
    most memory.

Defaults to 1.

=item B<$workfactor>

To quote the bzip2 documentation

    This parameter controls how the compression phase behaves when
    presented with worst case, highly repetitive, input data. If
    compression runs into difficulties caused by repetitive data, the
    library switches from the standard sorting algorithm to a fallback
    algorithm. The fallback is slower than the standard algorithm by
    perhaps a factor of three, but always behaves reasonably, no matter how
    bad the input.

    Lower values of workFactor reduce the amount of effort the standard
    algorithm will expend before resorting to the fallback. You should set
    this parameter carefully; too low, and many inputs will be handled by
    the fallback algorithm and so compress rather slowly, too high, and
    your average-to-worst case compression times can become very large. The
    default value of 30 gives reasonable behaviour over a wide range of
    circumstances.

    Allowable values range from 0 to 250 inclusive. 0 is a special case,
    equivalent to using the default value of 30.

Defaults to 0.

=back

=head2 $status = $bz->bzdeflate($input, $output);

Reads the contents of C<$input>, compresses it and writes the compressed
data to C<$output>.

Returns C<BZ_RUN_OK> on success and a C<bzip2> error code on failure.

If C<appendOutput> is enabled in the constructor for the bzip2 object, the
compressed data will be appended to C<$output>. If not enabled, C<$output>
will be truncated before the compressed data is written to it.

=head2 $status = $bz->bzflush($output);

Flushes any pending compressed data to C<$output>.

Returns C<BZ_RUN_OK> on success and a C<bzip2> error code on failure.

=head2 $status = $bz->bzclose($output);

Terminates the compressed data stream and flushes any pending compressed
data to C<$output>.

Returns C<BZ_STREAM_END> on success and a C<bzip2> error code on failure.

=head2 Example

=head1 Uncompression

=head2 ($z, $status) = new Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;

If successful, it will return the initialised uncompression object, C<$z>
and a C<$status> of C<BZ_OK> in a list context. In scalar context it
returns the deflation object, C<$z>, only.

If not successful, the returned uncompression object, C<$z>, will be
I<undef> and C<$status> will hold the a I<bzip2> error code.

Below is a list of the valid options:

=over 5

=item B<$appendOutput>

Controls whether the compressed data is appended to the output buffer in the
C<bzinflate>, C<bzflush> and C<bzclose> methods.

Defaults to 1.

=item B<$consumeInput>

=item B<$small>

To quote the bzip2 documentation

    If small is nonzero, the library will use an alternative decompression
    algorithm which uses less memory but at the cost of decompressing more
    slowly (roughly speaking, half the speed, but the maximum memory
    requirement drops to around 2300k). 

Defaults to 0.

=item B<$limitOutput>

The C<LimitOutput> option changes the behavior of the C<< $i->bzinflate >>
method so that the amount of memory used by the output buffer can be
limited. 

When C<LimitOutput> is used the size of the output buffer used will either
be the 16k or the amount of memory already allocated to C<$output>,
whichever is larger. Predicting the output size available is tricky, so
don't rely on getting an exact output buffer size.

When C<LimitOutout> is not specified C<< $i->bzinflate >> will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.

If C<LimitOutput> is enabled, the C<ConsumeInput> option will also be
enabled.

This option defaults to false.

=item B<$verbosity>

This parameter is ignored.

Defaults to 0.

=back

=head2 $status = $z->bzinflate($input, $output);

Uncompresses C<$input> and writes the uncompressed data to C<$output>. 

Returns C<BZ_OK> if the uncompression was successful, but the end of the
compressed data stream has not been reached. Returns C<BZ_STREAM_END> on
successful uncompression and the end of the compression stream has been
reached.

If C<consumeInput> is enabled in the constructor for the bunzip2 object,
C<$input> will have all compressed data removed from it after
uncompression. On C<BZ_OK> return this will mean that C<$input> will be an
empty string; when C<BZ_STREAM_END> C<$input> will either be an empty
string or will contain whatever data immediately followed the compressed
data stream.

If C<appendOutput> is enabled in the constructor for the bunzip2 object,
the uncompressed data will be appended to C<$output>. If not enabled,
C<$output> will be truncated before the uncompressed data is written to it.

=head1 Misc

=head2 my $version = Compress::Raw::Bzip2::bzlibversion();

Returns the version of the underlying bzip2 library.

=head1 Constants

The following bzip2 constants are exported by this module

		BZ_RUN
		BZ_FLUSH
		BZ_FINISH

		BZ_OK
		BZ_RUN_OK
		BZ_FLUSH_OK
		BZ_FINISH_OK
		BZ_STREAM_END
		BZ_SEQUENCE_ERROR
		BZ_PARAM_ERROR
		BZ_MEM_ERROR
		BZ_DATA_ERROR
		BZ_DATA_ERROR_MAGIC
		BZ_IO_ERROR
		BZ_UNEXPECTED_EOF
		BZ_OUTBUFF_FULL
		BZ_CONFIG_ERROR

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

The primary site for the bzip2 program is F<http://www.bzip.org>.

See the module L<Compress::Bzip2|Compress::Bzip2>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                               usr/lib/x86_64-linux-gnu/perl/5.20.2/Compress/Raw/Zlib.pm                                           0100644 0000000 0000000 00000134422 12744441327 020774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package Compress::Raw::Zlib;

require 5.006 ;
require Exporter;
use Carp ;

use strict ;
use warnings ;
use bytes ;
our ($VERSION, $XS_VERSION, @ISA, @EXPORT, %EXPORT_TAGS, @EXPORT_OK, $AUTOLOAD, %DEFLATE_CONSTANTS, @DEFLATE_CONSTANTS);

$VERSION = '2.065';
$XS_VERSION = $VERSION; 
$VERSION = eval $VERSION;

@ISA = qw(Exporter);
%EXPORT_TAGS = ( flush     => [qw{  
                                    Z_NO_FLUSH
                                    Z_PARTIAL_FLUSH
                                    Z_SYNC_FLUSH
                                    Z_FULL_FLUSH
                                    Z_FINISH
                                    Z_BLOCK
                              }],
                 level     => [qw{  
                                    Z_NO_COMPRESSION
                                    Z_BEST_SPEED
                                    Z_BEST_COMPRESSION
                                    Z_DEFAULT_COMPRESSION
                              }],
                 strategy  => [qw{  
                                    Z_FILTERED
                                    Z_HUFFMAN_ONLY
                                    Z_RLE
                                    Z_FIXED
                                    Z_DEFAULT_STRATEGY
                              }],
                 status   => [qw{  
                                    Z_OK
                                    Z_STREAM_END
                                    Z_NEED_DICT
                                    Z_ERRNO
                                    Z_STREAM_ERROR
                                    Z_DATA_ERROR  
                                    Z_MEM_ERROR   
                                    Z_BUF_ERROR 
                                    Z_VERSION_ERROR 
                              }],                              
              );

%DEFLATE_CONSTANTS = %EXPORT_TAGS;

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
@DEFLATE_CONSTANTS = 
@EXPORT = qw(
        ZLIB_VERSION
        ZLIB_VERNUM

        
        OS_CODE

        MAX_MEM_LEVEL
        MAX_WBITS

        Z_ASCII
        Z_BEST_COMPRESSION
        Z_BEST_SPEED
        Z_BINARY
        Z_BLOCK
        Z_BUF_ERROR
        Z_DATA_ERROR
        Z_DEFAULT_COMPRESSION
        Z_DEFAULT_STRATEGY
        Z_DEFLATED
        Z_ERRNO
        Z_FILTERED
        Z_FIXED
        Z_FINISH
        Z_FULL_FLUSH
        Z_HUFFMAN_ONLY
        Z_MEM_ERROR
        Z_NEED_DICT
        Z_NO_COMPRESSION
        Z_NO_FLUSH
        Z_NULL
        Z_OK
        Z_PARTIAL_FLUSH
        Z_RLE
        Z_STREAM_END
        Z_STREAM_ERROR
        Z_SYNC_FLUSH
        Z_TREES
        Z_UNKNOWN
        Z_VERSION_ERROR

        WANT_GZIP
        WANT_GZIP_OR_ZLIB
);

push @EXPORT, qw(crc32 adler32 DEF_WBITS);

use constant WANT_GZIP           => 16;
use constant WANT_GZIP_OR_ZLIB   => 32;

sub AUTOLOAD {
    my($constname);
    ($constname = $AUTOLOAD) =~ s/.*:://;
    my ($error, $val) = constant($constname);
    Carp::croak $error if $error;
    no strict 'refs';
    *{$AUTOLOAD} = sub { $val };
    goto &{$AUTOLOAD};
}

use constant FLAG_APPEND             => 1 ;
use constant FLAG_CRC                => 2 ;
use constant FLAG_ADLER              => 4 ;
use constant FLAG_CONSUME_INPUT      => 8 ;
use constant FLAG_LIMIT_OUTPUT       => 16 ;

eval {
    require XSLoader;
    XSLoader::load('Compress::Raw::Zlib', $XS_VERSION);
    1;
} 
or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap Compress::Raw::Zlib $XS_VERSION ; 
};
 

use constant Parse_any      => 0x01;
use constant Parse_unsigned => 0x02;
use constant Parse_signed   => 0x04;
use constant Parse_boolean  => 0x08;
#use constant Parse_string   => 0x10;
#use constant Parse_custom   => 0x12;

#use constant Parse_store_ref => 0x100 ;

use constant OFF_PARSED     => 0 ;
use constant OFF_TYPE       => 1 ;
use constant OFF_DEFAULT    => 2 ;
use constant OFF_FIXED      => 3 ;
use constant OFF_FIRST_ONLY => 4 ;
use constant OFF_STICKY     => 5 ;



sub ParseParameters
{
    my $level = shift || 0 ; 

    my $sub = (caller($level + 1))[3] ;
    #local $Carp::CarpLevel = 1 ;
    my $p = new Compress::Raw::Zlib::Parameters() ;
    $p->parse(@_)
        or croak "$sub: $p->{Error}" ;

    return $p;
}


sub Compress::Raw::Zlib::Parameters::new
{
    my $class = shift ;

    my $obj = { Error => '',
                Got   => {},
              } ;

    #return bless $obj, ref($class) || $class || __PACKAGE__ ;
    return bless $obj, 'Compress::Raw::Zlib::Parameters' ;
}

sub Compress::Raw::Zlib::Parameters::setError
{
    my $self = shift ;
    my $error = shift ;
    my $retval = @_ ? shift : undef ;

    $self->{Error} = $error ;
    return $retval;
}
          
#sub getError
#{
#    my $self = shift ;
#    return $self->{Error} ;
#}
          
sub Compress::Raw::Zlib::Parameters::parse
{
    my $self = shift ;

    my $default = shift ;

    my $got = $self->{Got} ;
    my $firstTime = keys %{ $got } == 0 ;

    my (@Bad) ;
    my @entered = () ;

    # Allow the options to be passed as a hash reference or
    # as the complete hash.
    if (@_ == 0) {
        @entered = () ;
    }
    elsif (@_ == 1) {
        my $href = $_[0] ;    
        return $self->setError("Expected even number of parameters, got 1")
            if ! defined $href or ! ref $href or ref $href ne "HASH" ;
 
        foreach my $key (keys %$href) {
            push @entered, $key ;
            push @entered, \$href->{$key} ;
        }
    }
    else {
        my $count = @_;
        return $self->setError("Expected even number of parameters, got $count")
            if $count % 2 != 0 ;
        
        for my $i (0.. $count / 2 - 1) {
            push @entered, $_[2* $i] ;
            push @entered, \$_[2* $i+1] ;
        }
    }


    while (my ($key, $v) = each %$default)
    {
        croak "need 4 params [@$v]"
            if @$v != 4 ;

        my ($first_only, $sticky, $type, $value) = @$v ;
        my $x ;
        $self->_checkType($key, \$value, $type, 0, \$x) 
            or return undef ;

        $key = lc $key;

        if ($firstTime || ! $sticky) {
            $got->{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
        }

        $got->{$key}[OFF_PARSED] = 0 ;
    }

    for my $i (0.. @entered / 2 - 1) {
        my $key = $entered[2* $i] ;
        my $value = $entered[2* $i+1] ;

        #print "Key [$key] Value [$value]" ;
        #print defined $$value ? "[$$value]\n" : "[undef]\n";

        $key =~ s/^-// ;
        my $canonkey = lc $key;
 
        if ($got->{$canonkey} && ($firstTime ||
                                  ! $got->{$canonkey}[OFF_FIRST_ONLY]  ))
        {
            my $type = $got->{$canonkey}[OFF_TYPE] ;
            my $s ;
            $self->_checkType($key, $value, $type, 1, \$s)
                or return undef ;
            #$value = $$value unless $type & Parse_store_ref ;
            $value = $$value ;
            $got->{$canonkey} = [1, $type, $value, $s] ;
        }
        else
          { push (@Bad, $key) }
    }
 
    if (@Bad) {
        my ($bad) = join(", ", @Bad) ;
        return $self->setError("unknown key value(s) @Bad") ;
    }

    return 1;
}

sub Compress::Raw::Zlib::Parameters::_checkType
{
    my $self = shift ;

    my $key   = shift ;
    my $value = shift ;
    my $type  = shift ;
    my $validate  = shift ;
    my $output  = shift;

    #local $Carp::CarpLevel = $level ;
    #print "PARSE $type $key $value $validate $sub\n" ;
#    if ( $type & Parse_store_ref)
#    {
#        #$value = $$value
#        #    if ref ${ $value } ;
#
#        $$output = $value ;
#        return 1;
#    }

    $value = $$value ;

    if ($type & Parse_any)
    {
        $$output = $value ;
        return 1;
    }
    elsif ($type & Parse_unsigned)
    {
        return $self->setError("Parameter '$key' must be an unsigned int, got 'undef'")
            if $validate && ! defined $value ;
        return $self->setError("Parameter '$key' must be an unsigned int, got '$value'")
            if $validate && $value !~ /^\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1;
    }
    elsif ($type & Parse_signed)
    {
        return $self->setError("Parameter '$key' must be a signed int, got 'undef'")
            if $validate && ! defined $value ;
        return $self->setError("Parameter '$key' must be a signed int, got '$value'")
            if $validate && $value !~ /^-?\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1 ;
    }
    elsif ($type & Parse_boolean)
    {
        return $self->setError("Parameter '$key' must be an int, got '$value'")
            if $validate && defined $value && $value !~ /^\d*$/;
        $$output =  defined $value ? $value != 0 : 0 ;    
        return 1;
    }
#    elsif ($type & Parse_string)
#    {
#        $$output = defined $value ? $value : "" ;    
#        return 1;
#    }

    $$output = $value ;
    return 1;
}



sub Compress::Raw::Zlib::Parameters::parsed
{
    my $self = shift ;
    my $name = shift ;

    return $self->{Got}{lc $name}[OFF_PARSED] ;
}

sub Compress::Raw::Zlib::Parameters::value
{
    my $self = shift ;
    my $name = shift ;

    if (@_)
    {
        $self->{Got}{lc $name}[OFF_PARSED]  = 1;
        $self->{Got}{lc $name}[OFF_DEFAULT] = $_[0] ;
        $self->{Got}{lc $name}[OFF_FIXED]   = $_[0] ;
    }

    return $self->{Got}{lc $name}[OFF_FIXED] ;
}

our $OPTIONS_deflate =   
    {
        'AppendOutput'  => [1, 1, Parse_boolean,  0],
        'CRC32'         => [1, 1, Parse_boolean,  0],
        'ADLER32'       => [1, 1, Parse_boolean,  0],
        'Bufsize'       => [1, 1, Parse_unsigned, 4096],

        'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
        'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
        'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
        'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
        'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
        'Dictionary'    => [1, 1, Parse_any,      ""],
    };

sub Compress::Raw::Zlib::Deflate::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0, $OPTIONS_deflate, @_);

    croak "Compress::Raw::Zlib::Deflate::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;

    my $windowBits =  $got->value('WindowBits');
    $windowBits += MAX_WBITS()
        if ($windowBits & MAX_WBITS()) == 0 ;

    _deflateInit($flags,
                $got->value('Level'), 
                $got->value('Method'), 
                $windowBits, 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                $got->value('Dictionary')) ;

}

sub Compress::Raw::Zlib::deflateStream::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Zlib::deflateStream::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}


our $OPTIONS_inflate = 
    {
        'AppendOutput'  => [1, 1, Parse_boolean,  0],
        'LimitOutput'   => [1, 1, Parse_boolean,  0],
        'CRC32'         => [1, 1, Parse_boolean,  0],
        'ADLER32'       => [1, 1, Parse_boolean,  0],
        'ConsumeInput'  => [1, 1, Parse_boolean,  1],
        'Bufsize'       => [1, 1, Parse_unsigned, 4096],
 
        'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
        'Dictionary'    => [1, 1, Parse_any,      ""],
    } ;

sub Compress::Raw::Zlib::Inflate::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0, $OPTIONS_inflate, @_);

    croak "Compress::Raw::Zlib::Inflate::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;
    $flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;
    $flags |= FLAG_LIMIT_OUTPUT if $got->value('LimitOutput') ;


    my $windowBits =  $got->value('WindowBits');
    $windowBits += MAX_WBITS()
        if ($windowBits & MAX_WBITS()) == 0 ;

    _inflateInit($flags, $windowBits, $got->value('Bufsize'), 
                 $got->value('Dictionary')) ;
}

sub Compress::Raw::Zlib::inflateStream::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Zlib::inflateStream::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}

sub Compress::Raw::Zlib::InflateScan::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0,
                    {
                        'CRC32'         => [1, 1, Parse_boolean,  0],
                        'ADLER32'       => [1, 1, Parse_boolean,  0],
                        'Bufsize'       => [1, 1, Parse_unsigned, 4096],
                 
                        'WindowBits'    => [1, 1, Parse_signed,   -MAX_WBITS()],
                        'Dictionary'    => [1, 1, Parse_any,      ""],
            }, @_) ;


    croak "Compress::Raw::Zlib::InflateScan::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    #$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;
    #$flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;

    _inflateScanInit($flags, $got->value('WindowBits'), $got->value('Bufsize'), 
                 '') ;
}

sub Compress::Raw::Zlib::inflateScanStream::createDeflateStream
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0,
            {
                'AppendOutput'  => [1, 1, Parse_boolean,  0],
                'CRC32'         => [1, 1, Parse_boolean,  0],
                'ADLER32'       => [1, 1, Parse_boolean,  0],
                'Bufsize'       => [1, 1, Parse_unsigned, 4096],
 
                'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
                'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
                'WindowBits'    => [1, 1, Parse_signed,   - MAX_WBITS()],
                'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
                'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
            }, @_) ;

    croak "Compress::Raw::Zlib::InflateScan::createDeflateStream: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;

    $pkg->_createDeflateStream($flags,
                $got->value('Level'), 
                $got->value('Method'), 
                $got->value('WindowBits'), 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                ) ;

}

sub Compress::Raw::Zlib::inflateScanStream::inflate
{
    my $self = shift ;
    my $buffer = $_[1];
    my $eof = $_[2];

    my $status = $self->scan(@_);

    if ($status == Z_OK() && $_[2]) {
        my $byte = ' ';
        
        $status = $self->scan(\$byte, $_[1]) ;
    }
    
    return $status ;
}

sub Compress::Raw::Zlib::deflateStream::deflateParams
{
    my $self = shift ;
    my ($got) = ParseParameters(0, {
                'Level'      => [1, 1, Parse_signed,   undef],
                'Strategy'   => [1, 1, Parse_unsigned, undef],
                'Bufsize'    => [1, 1, Parse_unsigned, undef],
                }, 
                @_) ;

    croak "Compress::Raw::Zlib::deflateParams needs Level and/or Strategy"
        unless $got->parsed('Level') + $got->parsed('Strategy') +
            $got->parsed('Bufsize');

    croak "Compress::Raw::Zlib::Inflate::deflateParams: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        if $got->parsed('Bufsize') && $got->value('Bufsize') <= 1;

    my $flags = 0;
    $flags |= 1 if $got->parsed('Level') ;
    $flags |= 2 if $got->parsed('Strategy') ;
    $flags |= 4 if $got->parsed('Bufsize') ;

    $self->_deflateParams($flags, $got->value('Level'), 
                          $got->value('Strategy'), $got->value('Bufsize'));

}


1;
__END__


=head1 NAME

Compress::Raw::Zlib - Low-Level Interface to zlib compression library

=head1 SYNOPSIS

    use Compress::Raw::Zlib ;

    ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
    $status = $d->deflate($input, $output) ;
    $status = $d->flush($output [, $flush_type]) ;
    $d->deflateReset() ;
    $d->deflateParams(OPTS) ;
    $d->deflateTune(OPTS) ;
    $d->dict_adler() ;
    $d->crc32() ;
    $d->adler32() ;
    $d->total_in() ;
    $d->total_out() ;
    $d->msg() ;
    $d->get_Strategy();
    $d->get_Level();
    $d->get_BufSize();

    ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
    $status = $i->inflate($input, $output [, $eof]) ;
    $status = $i->inflateSync($input) ;
    $i->inflateReset() ;
    $i->dict_adler() ;
    $d->crc32() ;
    $d->adler32() ;
    $i->total_in() ;
    $i->total_out() ;
    $i->msg() ;
    $d->get_BufSize();

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

    my $version = Compress::Raw::Zlib::zlib_version();
    my $flags = Compress::Raw::Zlib::zlibCompileFlags();

=head1 DESCRIPTION

The I<Compress::Raw::Zlib> module provides a Perl interface to the I<zlib>
compression library (see L</AUTHOR> for details about where to get
I<zlib>). 

=head1 Compress::Raw::Zlib::Deflate

This section defines an interface that allows in-memory compression using
the I<deflate> interface provided by zlib.

Here is a definition of the interface available:

=head2 B<($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) >

Initialises a deflation object. 

If you are familiar with the I<zlib> library, it combines the
features of the I<zlib> functions C<deflateInit>, C<deflateInit2>
and C<deflateSetDictionary>.

If successful, it will return the initialised deflation object, C<$d>
and a C<$status> of C<Z_OK> in a list context. In scalar context it
returns the deflation object, C<$d>, only.

If not successful, the returned deflation object, C<$d>, will be
I<undef> and C<$status> will hold the a I<zlib> error code.

The function optionally takes a number of named options specified as
C<< Name => value >> pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.

For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.

Below is a list of the valid options:

=over 5

=item B<-Level>

Defines the compression level. Valid values are 0 through 9,
C<Z_NO_COMPRESSION>, C<Z_BEST_SPEED>, C<Z_BEST_COMPRESSION>, and
C<Z_DEFAULT_COMPRESSION>.

The default is C<Z_DEFAULT_COMPRESSION>.

=item B<-Method>

Defines the compression method. The only valid value at present (and
the default) is C<Z_DEFLATED>.

=item B<-WindowBits>

To compress an RFC 1950 data stream, set C<WindowBits> to a positive
number between 8 and 15.

To compress an RFC 1951 data stream, set C<WindowBits> to C<-MAX_WBITS>.

To compress an RFC 1952 data stream (i.e. gzip), set C<WindowBits> to
C<WANT_GZIP>.

For a definition of the meaning and valid values for C<WindowBits>
refer to the I<zlib> documentation for I<deflateInit2>.

Defaults to C<MAX_WBITS>.

=item B<-MemLevel>

For a definition of the meaning and valid values for C<MemLevel>
refer to the I<zlib> documentation for I<deflateInit2>.

Defaults to MAX_MEM_LEVEL.

=item B<-Strategy>

Defines the strategy used to tune the compression. The valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED>, C<Z_RLE>, C<Z_FIXED> and
C<Z_HUFFMAN_ONLY>.

The default is C<Z_DEFAULT_STRATEGY>.

=item B<-Dictionary>

When a dictionary is specified I<Compress::Raw::Zlib> will automatically
call C<deflateSetDictionary> directly after calling C<deflateInit>. The
Adler32 value for the dictionary can be obtained by calling the method 
C<$d-E<gt>dict_adler()>.

The default is no dictionary.

=item B<-Bufsize>

Sets the initial size for the output buffer used by the C<$d-E<gt>deflate>
and C<$d-E<gt>flush> methods. If the buffer has to be
reallocated to increase the size, it will grow in increments of
C<Bufsize>.

The default buffer size is 4096.

=item B<-AppendOutput>

This option controls how data is written to the output buffer by the
C<$d-E<gt>deflate> and C<$d-E<gt>flush> methods.

If the C<AppendOutput> option is set to false, the output buffers in the
C<$d-E<gt>deflate> and C<$d-E<gt>flush>  methods will be truncated before
uncompressed data is written to them.

If the option is set to true, uncompressed data will be appended to the
output buffer in the C<$d-E<gt>deflate> and C<$d-E<gt>flush> methods.

This option defaults to false.

=item B<-CRC32>

If set to true, a crc32 checksum of the uncompressed data will be
calculated. Use the C<$d-E<gt>crc32> method to retrieve this value.

This option defaults to false.

=item B<-ADLER32>

If set to true, an adler32 checksum of the uncompressed data will be
calculated. Use the C<$d-E<gt>adler32> method to retrieve this value.

This option defaults to false.

=back

Here is an example of using the C<Compress::Raw::Zlib::Deflate> optional
parameter list to override the default buffer size and compression
level. All other options will take their default values.

    my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize => 300, 
                                               -Level   => Z_BEST_SPEED ) ;

=head2 B<$status = $d-E<gt>deflate($input, $output)>

Deflates the contents of C<$input> and writes the compressed data to
C<$output>.

The C<$input> and C<$output> parameters can be either scalars or scalar
references.

When finished, C<$input> will be completely processed (assuming there
were no errors). If the deflation was successful it writes the deflated
data to C<$output> and returns a status value of C<Z_OK>.

On error, it returns a I<zlib> error code.

If the C<AppendOutput> option is set to true in the constructor for
the C<$d> object, the compressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any compressed data is
written to it.

B<Note>: This method will not necessarily write compressed data to
C<$output> every time it is called. So do not assume that there has been
an error if the contents of C<$output> is empty on returning from
this method. As long as the return code from the method is C<Z_OK>,
the deflate has succeeded.

=head2 B<$status = $d-E<gt>flush($output [, $flush_type]) >

Typically used to finish the deflation. Any pending output will be
written to C<$output>.

Returns C<Z_OK> if successful.

Note that flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using C<Z_FINISH>) or
when you want to create a I<full flush point> (using C<Z_FULL_FLUSH>).

By default the C<flush_type> used is C<Z_FINISH>. Other valid values
for C<flush_type> are C<Z_NO_FLUSH>, C<Z_PARTIAL_FLUSH>, C<Z_SYNC_FLUSH>
and C<Z_FULL_FLUSH>. It is strongly recommended that you only set the
C<flush_type> parameter if you fully understand the implications of
what it does. See the C<zlib> documentation for details.

If the C<AppendOutput> option is set to true in the constructor for
the C<$d> object, the compressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any compressed data is
written to it.

=head2 B<$status = $d-E<gt>deflateReset() >

This method will reset the deflation object C<$d>. It can be used when you
are compressing multiple data streams and want to use the same object to
compress each of them. It should only be used once the previous data stream
has been flushed successfully, i.e. a call to C<< $d->flush(Z_FINISH) >> has
returned C<Z_OK>.

Returns C<Z_OK> if successful.

=head2 B<$status = $d-E<gt>deflateParams([OPT])>

Change settings for the deflate object C<$d>.

The list of the valid options is shown below. Options not specified
will remain unchanged.

=over 5

=item B<-Level>

Defines the compression level. Valid values are 0 through 9,
C<Z_NO_COMPRESSION>, C<Z_BEST_SPEED>, C<Z_BEST_COMPRESSION>, and
C<Z_DEFAULT_COMPRESSION>.

=item B<-Strategy>

Defines the strategy used to tune the compression. The valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED> and C<Z_HUFFMAN_ONLY>. 

=item B<-BufSize>

Sets the initial size for the output buffer used by the C<$d-E<gt>deflate>
and C<$d-E<gt>flush> methods. If the buffer has to be
reallocated to increase the size, it will grow in increments of
C<Bufsize>.

=back

=head2 B<$status = $d-E<gt>deflateTune($good_length, $max_lazy, $nice_length, $max_chain)>

Tune the internal settings for the deflate object C<$d>. This option is
only available if you are running zlib 1.2.2.3 or better.

Refer to the documentation in zlib.h for instructions on how to fly
C<deflateTune>.

=head2 B<$d-E<gt>dict_adler()>

Returns the adler32 value for the dictionary.

=head2 B<$d-E<gt>crc32()>

Returns the crc32 value for the uncompressed data to date. 

If the C<CRC32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$d-E<gt>adler32()>

Returns the adler32 value for the uncompressed data to date. 

=head2 B<$d-E<gt>msg()>

Returns the last error message generated by zlib.

=head2 B<$d-E<gt>total_in()>

Returns the total number of bytes uncompressed bytes input to deflate.

=head2 B<$d-E<gt>total_out()>

Returns the total number of compressed bytes output from deflate.

=head2 B<$d-E<gt>get_Strategy()>

Returns the deflation strategy currently used. Valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED> and C<Z_HUFFMAN_ONLY>. 

=head2 B<$d-E<gt>get_Level()>

Returns the compression level being used. 

=head2 B<$d-E<gt>get_BufSize()>

Returns the buffer size used to carry out the compression.

=head2 Example

Here is a trivial example of using C<deflate>. It simply reads standard
input, deflates it and writes it to standard output.

    use strict ;
    use warnings ;

    use Compress::Raw::Zlib ;

    binmode STDIN;
    binmode STDOUT;
    my $x = new Compress::Raw::Zlib::Deflate
       or die "Cannot create a deflation stream\n" ;

    my ($output, $status) ;
    while (<>)
    {
        $status = $x->deflate($_, $output) ;
    
        $status == Z_OK
            or die "deflation failed\n" ;
    
        print $output ;
    }
    
    $status = $x->flush($output) ;
    
    $status == Z_OK
        or die "deflation failed\n" ;
    
    print $output ;

=head1 Compress::Raw::Zlib::Inflate

This section defines an interface that allows in-memory uncompression using
the I<inflate> interface provided by zlib.

Here is a definition of the interface:

=head2 B< ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) >

Initialises an inflation object. 

In a list context it returns the inflation object, C<$i>, and the
I<zlib> status code (C<$status>). In a scalar context it returns the
inflation object only.

If successful, C<$i> will hold the inflation object and C<$status> will
be C<Z_OK>.

If not successful, C<$i> will be I<undef> and C<$status> will hold the
I<zlib> error code.

The function optionally takes a number of named options specified as
C<< -Name => value >> pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.

For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the C<< name=>value >> pairs.

Here is a list of the valid options:

=over 5

=item B<-WindowBits>

To uncompress an RFC 1950 data stream, set C<WindowBits> to a positive
number between 8 and 15.

To uncompress an RFC 1951 data stream, set C<WindowBits> to C<-MAX_WBITS>.

To uncompress an RFC 1952 data stream (i.e. gzip), set C<WindowBits> to
C<WANT_GZIP>.

To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e.
gzip), set C<WindowBits> to C<WANT_GZIP_OR_ZLIB>.

For a full definition of the meaning and valid values for C<WindowBits>
refer to the I<zlib> documentation for I<inflateInit2>.

Defaults to C<MAX_WBITS>.

=item B<-Bufsize>

Sets the initial size for the output buffer used by the C<$i-E<gt>inflate>
method. If the output buffer in this method has to be reallocated to
increase the size, it will grow in increments of C<Bufsize>.

Default is 4096.

=item B<-Dictionary>

The default is no dictionary.

=item B<-AppendOutput>

This option controls how data is written to the output buffer by the
C<$i-E<gt>inflate> method.

If the option is set to false, the output buffer in the C<$i-E<gt>inflate>
method will be truncated before uncompressed data is written to it.

If the option is set to true, uncompressed data will be appended to the
output buffer by the C<$i-E<gt>inflate> method.

This option defaults to false.

=item B<-CRC32>

If set to true, a crc32 checksum of the uncompressed data will be
calculated. Use the C<$i-E<gt>crc32> method to retrieve this value.

This option defaults to false.

=item B<-ADLER32>

If set to true, an adler32 checksum of the uncompressed data will be
calculated. Use the C<$i-E<gt>adler32> method to retrieve this value.

This option defaults to false.

=item B<-ConsumeInput>

If set to true, this option will remove compressed data from the input
buffer of the C<< $i->inflate >> method as the inflate progresses.

This option can be useful when you are processing compressed data that is
embedded in another file/buffer. In this case the data that immediately
follows the compressed stream will be left in the input buffer.

This option defaults to true.

=item B<-LimitOutput>

The C<LimitOutput> option changes the behavior of the C<< $i->inflate >>
method so that the amount of memory used by the output buffer can be
limited. 

When C<LimitOutput> is used the size of the output buffer used will either
be the value of the C<Bufsize> option or the amount of memory already
allocated to C<$output>, whichever is larger. Predicting the output size
available is tricky, so don't rely on getting an exact output buffer size.

When C<LimitOutout> is not specified C<< $i->inflate >> will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.

If C<LimitOutput> is enabled, the C<ConsumeInput> option will also be
enabled.

This option defaults to false.

See L</The LimitOutput option> for a discussion on why C<LimitOutput> is
needed and how to use it.

=back

Here is an example of using an optional parameter to override the default
buffer size.

    my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize => 300 ) ;

=head2 B< $status = $i-E<gt>inflate($input, $output [,$eof]) >

Inflates the complete contents of C<$input> and writes the uncompressed
data to C<$output>. The C<$input> and C<$output> parameters can either be
scalars or scalar references.

Returns C<Z_OK> if successful and C<Z_STREAM_END> if the end of the
compressed data has been successfully reached. 

If not successful C<$status> will hold the I<zlib> error code.

If the C<ConsumeInput> option has been set to true when the
C<Compress::Raw::Zlib::Inflate> object is created, the C<$input> parameter
is modified by C<inflate>. On completion it will contain what remains
of the input buffer after inflation. In practice, this means that when
the return status is C<Z_OK> the C<$input> parameter will contain an
empty string, and when the return status is C<Z_STREAM_END> the C<$input>
parameter will contains what (if anything) was stored in the input buffer
after the deflated data stream.

This feature is useful when processing a file format that encapsulates
a compressed data stream (e.g. gzip, zip) and there is useful data
immediately after the deflation stream.

If the C<AppendOutput> option is set to true in the constructor for
this object, the uncompressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any uncompressed data
is written to it.

The C<$eof> parameter needs a bit of explanation. 

Prior to version 1.2.0, zlib assumed that there was at least one trailing
byte immediately after the compressed data stream when it was carrying out
decompression. This normally isn't a problem because the majority of zlib
applications guarantee that there will be data directly after the
compressed data stream.  For example, both gzip (RFC 1950) and zip both
define trailing data that follows the compressed data stream.

The C<$eof> parameter only needs to be used if B<all> of the following
conditions apply

=over 5

=item 1 

You are either using a copy of zlib that is older than version 1.2.0 or you
want your application code to be able to run with as many different
versions of zlib as possible.

=item 2

You have set the C<WindowBits> parameter to C<-MAX_WBITS> in the constructor
for this object, i.e. you are uncompressing a raw deflated data stream
(RFC 1951).

=item 3

There is no data immediately after the compressed data stream.

=back

If B<all> of these are the case, then you need to set the C<$eof> parameter
to true on the final call (and only the final call) to C<$i-E<gt>inflate>. 

If you have built this module with zlib >= 1.2.0, the C<$eof> parameter is
ignored. You can still set it if you want, but it won't be used behind the
scenes.

=head2 B<$status = $i-E<gt>inflateSync($input)>

This method can be used to attempt to recover good data from a compressed
data stream that is partially corrupt.
It scans C<$input> until it reaches either a I<full flush point> or the
end of the buffer.

If a I<full flush point> is found, C<Z_OK> is returned and C<$input>
will be have all data up to the flush point removed. This data can then be
passed to the C<$i-E<gt>inflate> method to be uncompressed.

Any other return code means that a flush point was not found. If more
data is available, C<inflateSync> can be called repeatedly with more
compressed data until the flush point is found.

Note I<full flush points> are not present by default in compressed
data streams. They must have been added explicitly when the data stream
was created by calling C<Compress::Deflate::flush>  with C<Z_FULL_FLUSH>.

=head2 B<$status = $i-E<gt>inflateReset() >

This method will reset the inflation object C<$i>. It can be used when you
are uncompressing multiple data streams and want to use the same object to
uncompress each of them. 

Returns C<Z_OK> if successful.

=head2 B<$i-E<gt>dict_adler()>

Returns the adler32 value for the dictionary.

=head2 B<$i-E<gt>crc32()>

Returns the crc32 value for the uncompressed data to date.

If the C<CRC32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$i-E<gt>adler32()>

Returns the adler32 value for the uncompressed data to date.

If the C<ADLER32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$i-E<gt>msg()>

Returns the last error message generated by zlib.

=head2 B<$i-E<gt>total_in()>

Returns the total number of bytes compressed bytes input to inflate.

=head2 B<$i-E<gt>total_out()>

Returns the total number of uncompressed bytes output from inflate.

=head2 B<$d-E<gt>get_BufSize()>

Returns the buffer size used to carry out the decompression.

=head2 Examples

Here is an example of using C<inflate>.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x->inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

The next example show how to use the C<LimitOutput> option. Notice the use
of two nested loops in this case. The outer loop reads the data from the
input source - STDIN and the inner loop repeatedly calls C<inflate> until
C<$input> is exhausted, we get an error, or the end of the stream is
reached. One point worth remembering is by using the C<LimitOutput> option
you also get C<ConsumeInput> set as well - this makes the code below much
simpler.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput => 1)
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x->inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK && length $input);
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

=head1 CHECKSUM FUNCTIONS

Two functions are provided by I<zlib> to calculate checksums. For the
Perl interface, the order of the two parameters in both functions has
been reversed. This allows both running checksums and one off
calculations to be done.

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

The buffer parameters can either be a scalar or a scalar reference.

If the $crc parameters is C<undef>, the crc value will be reset.

If you have built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

These functions allow checksums to be merged.
Refer to the I<zlib> documentation for more details.

=head1 Misc

=head2 my $version = Compress::Raw::Zlib::zlib_version();

Returns the version of the zlib library.

=head2  my $flags = Compress::Raw::Zlib::zlibCompileFlags();

Returns the flags indicating compile-time options that were used to build 
the zlib library. See the zlib documentation for a description of the flags
returned by C<zlibCompileFlags>.

Note that when the zlib sources are built along with this module the
C<sprintf> flags (bits 24, 25 and 26) should be ignored.

If you are using zlib 1.2.0 or older, C<zlibCompileFlags> will return 0. 

=head1 The LimitOutput option.

By default C<< $i->inflate($input, $output) >> will uncompress I<all> data
in C<$input> and write I<all> of the uncompressed data it has generated to
C<$output>. This makes the interface to C<inflate> much simpler - if the
method has uncompressed C<$input> successfully I<all> compressed data in
C<$input> will have been dealt with. So if you are reading from an input
source and uncompressing as you go the code will look something like this

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x->inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

The points to note are 

=over 5

=item *

The main processing loop in the code handles reading of compressed data
from STDIN.

=item *

The status code returned from C<inflate> will only trigger termination of
the main processing loop if it isn't C<Z_OK>. When C<LimitOutput> has not
been used the C<Z_OK> status means that the end of the compressed
data stream has been reached or there has been an error in uncompression.

=item *

After the call to C<inflate> I<all> of the uncompressed data in C<$input>
will have been processed. This means the subsequent call to C<read> can
overwrite it's contents without any problem.

=back

For most use-cases the behavior described above is acceptable (this module
and it's predecessor, C<Compress::Zlib>, have used it for over 10 years
without an issue), but in a few very specific use-cases the amount of
memory required for C<$output> can prohibitively large. For example, if the
compressed data stream contains the same pattern repeated thousands of
times, a relatively small compressed data stream can uncompress into
hundreds of megabytes.  Remember C<inflate> will keep allocating memory
until I<all> the uncompressed data has been written to the output buffer -
the size of C<$output> is unbounded. 

The C<LimitOutput> option is designed to help with this use-case.

The main difference in your code when using C<LimitOutput> is having to
deal with cases where the C<$input> parameter still contains some
uncompressed data that C<inflate> hasn't processed yet. The status code
returned from C<inflate> will be C<Z_OK> if uncompression took place and
C<Z_BUF_ERROR> if the output buffer is full.

Below is typical code that shows how to use C<LimitOutput>.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput => 1)
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x->inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK && length $input);
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

Points to note this time:

=over 5

=item *

There are now two nested loops in the code: the outer loop for reading the
compressed data from STDIN, as before; and the inner loop to carry out the
uncompression.

=item *

There are two exit points from the inner uncompression loop.

Firstly when C<inflate> has returned a status other than C<Z_OK> or
C<Z_BUF_ERROR>.  This means that either the end of the compressed data
stream has been reached (C<Z_STREAM_END>) or there is an error in the
compressed data. In either of these cases there is no point in continuing
with reading the compressed data, so both loops are terminated.

The second exit point tests if there is any data left in the input buffer,
C<$input> - remember that the C<ConsumeInput> option is automatically
enabled when C<LimitOutput> is used.  When the input buffer has been
exhausted, the outer loop can run again and overwrite a now empty
C<$input>.

=back

=head1 ACCESSING ZIP FILES

Although it is possible (with some effort on your part) to use this module
to access .zip files, there are other perl modules available that will do
all the hard work for you. Check out C<Archive::Zip>,
C<Archive::Zip::SimpleZip>, C<IO::Compress::Zip> and
C<IO::Uncompress::Unzip>.

=head1 FAQ

=head2 Compatibility with Unix compress/uncompress.

This module is not compatible with Unix C<compress>.

If you have the C<uncompress> program available, you can use this to read
compressed files

    open F, "uncompress -c $filename |";
    while (<F>)
    {
        ...

Alternatively, if you have the C<gunzip> program available, you can use
this to read compressed files

    open F, "gunzip -c $filename |";
    while (<F>)
    {
        ...

and this to write compress files, if you have the C<compress> program
available

    open F, "| compress -c $filename ";
    print F "data";
    ...
    close F ;

=head2 Accessing .tar.Z files

See previous FAQ item.

If the C<Archive::Tar> module is installed and either the C<uncompress> or
C<gunzip> programs are available, you can use one of these workarounds to
read C<.tar.Z> files.

Firstly with C<uncompress>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "uncompress -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

and this with C<gunzip>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "gunzip -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

Similarly, if the C<compress> program is available, you can use this to
write a C<.tar.Z> file

    use strict;
    use warnings;
    use Archive::Tar;
    use IO::File;

    my $fh = new IO::File "| compress -c >$filename";
    my $tar = Archive::Tar->new();
    ...
    $tar->write($fh);
    $fh->close ;

=head2 Zlib Library Version Support

By default C<Compress::Raw::Zlib> will build with a private copy of version
1.2.5 of the zlib library. (See the F<README> file for details of
how to override this behaviour)

If you decide to use a different version of the zlib library, you need to be
aware of the following issues

=over 5

=item *

First off, you must have zlib 1.0.5 or better.

=item *

You need to have zlib 1.2.1 or better if you want to use the C<-Merge>
option with C<IO::Compress::Gzip>, C<IO::Compress::Deflate> and
C<IO::Compress::RawDeflate>.

=back

=head1 CONSTANTS

All the I<zlib> constants are automatically imported when you make use
of I<Compress::Raw::Zlib>.

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                              usr/lib/x86_64-linux-gnu/perl/5.20.2/Config.pod                                                     0100644 0000000 0000000 00000712535 12744441327 017132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

Config - access Perl configuration information

=head1 SYNOPSIS

    use Config;
    if ($Config{usethreads}) {
	print "has thread support\n"
    } 

    use Config qw(myconfig config_sh config_vars config_re);

    print myconfig();

    print config_sh();

    print config_re();

    config_vars(qw(osname archname));


=head1 DESCRIPTION

The Config module contains all the information that was available to
the C<Configure> program at Perl build time (over 900 values).

Shell variables from the F<config.sh> file (written by Configure) are
stored in the readonly-variable C<%Config>, indexed by their names.

Values stored in config.sh as 'undef' are returned as undefined
values.  The perl C<exists> function can be used to check if a
named variable exists.

For a description of the variables, please have a look at the
Glossary file, as written in the Porting folder, or use the url:
http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary

=over 4

=item myconfig()

Returns a textual summary of the major perl configuration values.
See also C<-V> in L<perlrun/Command Switches>.

=item config_sh()

Returns the entire perl configuration information in the form of the
original config.sh shell variable assignment script.

=item config_re($regex)

Like config_sh() but returns, as a list, only the config entries who's
names match the $regex.

=item config_vars(@names)

Prints to STDOUT the values of the named configuration variable. Each is
printed on a separate line in the form:

  name='value';

Names which are unknown are output as C<name='UNKNOWN';>.
See also C<-V:name> in L<perlrun/Command Switches>.

=item bincompat_options()

Returns a list of C pre-processor options used when compiling this F<perl>
binary, which affect its binary compatibility with extensions.
C<bincompat_options()> and C<non_bincompat_options()> are shown together in
the output of C<perl -V> as I<Compile-time options>.

=item non_bincompat_options()

Returns a list of C pre-processor options used when compiling this F<perl>
binary, which do not affect binary compatibility with extensions.

=item compile_date()

Returns the compile date (as a string), equivalent to what is shown by
C<perl -V>

=item local_patches()

Returns a list of the names of locally applied patches, equivalent to what
is shown by C<perl -V>.

=item header_files()

Returns a list of the header files that should be used as dependencies for
XS code, for this version of Perl on this platform.

=back

=head1 EXAMPLE

Here's a more sophisticated example of using %Config:

    use Config;
    use strict;

    my %sig_num;
    my @sig_name;
    unless($Config{sig_name} && $Config{sig_num}) {
	die "No sigs?";
    } else {
	my @names = split ' ', $Config{sig_name};
	@sig_num{@names} = split ' ', $Config{sig_num};
	foreach (@names) {
	    $sig_name[$sig_num{$_}] ||= $_;
	}   
    }

    print "signal #17 = $sig_name[17]\n";
    if ($sig_num{ALRM}) { 
	print "SIGALRM is $sig_num{ALRM}\n";
    }   

=head1 WARNING

Because this information is not stored within the perl executable
itself it is possible (but unlikely) that the information does not
relate to the actual perl binary which is being used to access it.

The Config module is installed into the architecture and version
specific library directory ($Config{installarchlib}) and it checks the
perl version number when loaded.

The values stored in config.sh may be either single-quoted or
double-quoted. Double-quoted strings are handy for those cases where you
need to include escape sequences in the strings. To avoid runtime variable
interpolation, any C<$> and C<@> characters are replaced by C<\$> and
C<\@>, respectively. This isn't foolproof, of course, so don't embed C<\$>
or C<\@> in double-quoted strings unless you're willing to deal with the
consequences. (The slashes will end up escaped and the C<$> or C<@> will
trigger variable interpolation)

=head1 GLOSSARY

Most C<Config> variables are determined by the C<Configure> script
on platforms supported by it (which is most UNIX platforms).  Some
platforms have custom-made C<Config> variables, and may thus not have
some of the variables described below, or may have extraneous variables
specific to that particular port.  See the port specific documentation
in such cases.

=cut

=head2 _

=over 4

=cut

=item C<_a>

From F<Unix.U>:

This variable defines the extension used for ordinary library files.
For unix, it is F<.a>.  The F<.> is included.  Other possible
values include F<.lib>.

=item C<_exe>

From F<Unix.U>:

This variable defines the extension used for executable files.
C<DJGPP>, Cygwin and F<OS/2> use F<.exe>.  Stratus C<VOS> uses F<.pm>.
On operating systems which do not require a specific extension
for executable files, this variable is empty.

=item C<_o>

From F<Unix.U>:

This variable defines the extension used for object files.
For unix, it is F<.o>.  The F<.> is included.  Other possible
values include F<.obj>.

=back

=cut

=head2 a

=over 4

=cut

=item C<afs>

From F<afs.U>:

This variable is set to C<true> if C<AFS> (Andrew File System) is used
on the system, C<false> otherwise.  It is possible to override this
with a hint value or command line option, but you'd better know
what you are doing.

=item C<afsroot>

From F<afs.U>:

This variable is by default set to F</afs>. In the unlikely case
this is not the correct root, it is possible to override this with
a hint value or command line option.  This will be used in subsequent
tests for AFSness in the configure and test process.

=item C<alignbytes>

From F<alignbytes.U>:

This variable holds the number of bytes required to align a
double-- or a long double when applicable. Usual values are
2, 4 and 8.  The default is eight, for safety.

=item C<ansi2knr>

From F<ansi2knr.U>:

This variable is set if the user needs to run ansi2knr.
Currently, this is not supported, so we just abort.

=item C<aphostname>

From F<d_gethname.U>:

This variable contains the command which can be used to compute the
host name. The command is fully qualified by its absolute path, to make
it safe when used by a process with super-user privileges.

=item C<api_revision>

From F<patchlevel.U>:

The three variables, api_revision, api_version, and
api_subversion, specify the version of the oldest perl binary
compatible with the present perl.  In a full version string
such as F<5.6.1>, api_revision is the C<5>.
Prior to 5.5.640, the format was a floating point number,
like 5.00563.

F<perl.c>:incpush() and F<lib/lib.pm> will automatically search in
F<$sitelib/.>. for older directories back to the limit specified
by these api_ variables.  This is only useful if you have a
perl library directory tree structured like the default one.
See C<INSTALL> for how this works.  The versioned site_perl
directory was introduced in 5.005, so that is the lowest
possible value.  The version list appropriate for the current
system is determined in F<inc_version_list.U>.

C<XXX> To do:  Since compatibility can depend on compile time
options (such as bincompat, longlong, etc.) it should
(perhaps) be set by Configure, but currently it isn't.
Currently, we read a hard-wired value from F<patchlevel.h>.
Perhaps what we ought to do is take the hard-wired value from
F<patchlevel.h> but then modify it if the current Configure
options warrant.  F<patchlevel.h> then would use an #ifdef guard.

=item C<api_subversion>

From F<patchlevel.U>:

The three variables, api_revision, api_version, and
api_subversion, specify the version of the oldest perl binary
compatible with the present perl.  In a full version string
such as F<5.6.1>, api_subversion is the C<1>.  See api_revision for
full details.

=item C<api_version>

From F<patchlevel.U>:

The three variables, api_revision, api_version, and
api_subversion, specify the version of the oldest perl binary
compatible with the present perl.  In a full version string
such as F<5.6.1>, api_version is the C<6>.  See api_revision for
full details.  As a special case, 5.5.0 is rendered in the
old-style as 5.005.  (In the 5.005_0x maintenance series,
this was the only versioned directory in $sitelib.)

=item C<api_versionstring>

From F<patchlevel.U>:

This variable combines api_revision, api_version, and
api_subversion in a format such as 5.6.1 (or 5_6_1) suitable
for use as a directory name.  This is filesystem dependent.

=item C<ar>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the ar program.  After Configure runs,
the value is reset to a plain C<ar> and is not useful.

=item C<archlib>

From F<archlib.U>:

This variable holds the name of the directory in which the user wants
to put architecture-dependent public library files for $package.
It is most often a local directory such as F</usr/local/lib>.
Programs using this variable must be prepared to deal
with filename expansion.

=item C<archlibexp>

From F<archlib.U>:

This variable is the same as the archlib variable, but is
filename expanded at configuration time, for convenient use.

=item C<archname>

From F<archname.U>:

This variable is a short name to characterize the current
architecture.  It is used mainly to construct the default archlib.

=item C<archname64>

From F<use64bits.U>:

This variable is used for the 64-bitness part of $archname.

=item C<archobjs>

From F<Unix.U>:

This variable defines any additional objects that must be linked
in with the program on this architecture.  On unix, it is usually
empty.  It is typically used to include emulations of unix calls
or other facilities.  For perl on F<OS/2>, for example, this would
include F<os2/os2.obj>.

=item C<asctime_r_proto>

From F<d_asctime_r.U>:

This variable encodes the prototype of asctime_r.
It is zero if d_asctime_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_asctime_r
is defined.

=item C<awk>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the awk program.  After Configure runs,
the value is reset to a plain C<awk> and is not useful.

=back

=cut

=head2 b

=over 4

=cut

=item C<baserev>

From F<baserev.U>:

The base revision level of this package, from the F<.package> file.

=item C<bash>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<bin>

From F<bin.U>:

This variable holds the name of the directory in which the user wants
to put publicly executable images for the package in question.  It
is most often a local directory such as F</usr/local/bin>. Programs using
this variable must be prepared to deal with F<~name> substitution.

=item C<bin_ELF>

From F<dlsrc.U>:

This variable saves the result from configure if generated binaries
are in C<ELF> format. Only set to defined when the test has actually
been performed, and the result was positive.

=item C<binexp>

From F<bin.U>:

This is the same as the bin variable, but is filename expanded at
configuration time, for use in your makefiles.

=item C<bison>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the bison program.  After Configure runs,
the value is reset to a plain C<bison> and is not useful.

=item C<bootstrap_charset>

From F<ebcdic.U>:

This variable conditionally defines C<BOOTSTRAP_CHARSET> if
this system uses non-C<ASCII> encoding.

=item C<byacc>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the byacc program.  After Configure runs,
the value is reset to a plain C<byacc> and is not useful.

=item C<byteorder>

From F<byteorder.U>:

This variable holds the byte order in a C<UV>. In the following,
larger digits indicate more significance.  The variable byteorder
is either 4321 on a big-endian machine, or 1234 on a little-endian,
or 87654321 on a Cray ... or 3412 with weird order !

=back

=cut

=head2 c

=over 4

=cut

=item C<c>

From F<n.U>:

This variable contains the \c string if that is what causes the echo
command to suppress newline.  Otherwise it is null.  Correct usage is
$echo $n "prompt for a question: $c".

=item C<castflags>

From F<d_castneg.U>:

This variable contains a flag that precise difficulties the
compiler has casting odd floating values to unsigned long:
0 = ok
1 = couldn't cast < 0
2 = couldn't cast >= 0x80000000
4 = couldn't cast in argument expression list

=item C<cat>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the cat program.  After Configure runs,
the value is reset to a plain C<cat> and is not useful.

=item C<cc>

From F<cc.U>:

This variable holds the name of a command to execute a C compiler which
can resolve multiple global references that happen to have the same
name.  Usual values are C<cc> and C<gcc>.
Fervent C<ANSI> compilers may be called C<c89>.  C<AIX> has xlc.

=item C<cccdlflags>

From F<dlsrc.U>:

This variable contains any special flags that might need to be
passed with C<cc -c> to compile modules to be used to create a shared
library that will be used for dynamic loading.  For hpux, this
should be +z.  It is up to the makefile to use it.

=item C<ccdlflags>

From F<dlsrc.U>:

This variable contains any special flags that might need to be
passed to cc to link with a shared library for dynamic loading.
It is up to the makefile to use it.  For sunos 4.1, it should
be empty.

=item C<ccflags>

From F<ccflags.U>:

This variable contains any additional C compiler flags desired by
the user.  It is up to the Makefile to use this.

=item C<ccflags_uselargefiles>

From F<uselfs.U>:

This variable contains the compiler flags needed by large file builds
and added to ccflags by hints files.

=item C<ccname>

From F<Checkcc.U>:

This can set either by hints files or by Configure.  If using
gcc, this is gcc, and if not, usually equal to cc, unimpressive, no?
Some platforms, however, make good use of this by storing the
flavor of the C compiler being used here.  For example if using
the Sun WorkShop suite, ccname will be C<workshop>.

=item C<ccsymbols>

From F<Cppsym.U>:

The variable contains the symbols defined by the C compiler alone.
The symbols defined by cpp or by cc when it calls cpp are not in
this list, see cppsymbols and cppccsymbols.
The list is a space-separated list of symbol=value tokens.

=item C<ccversion>

From F<Checkcc.U>:

This can set either by hints files or by Configure.  If using
a (non-gcc) vendor cc, this variable may contain a version for
the compiler.

=item C<cf_by>

From F<cf_who.U>:

Login name of the person who ran the Configure script and answered the
questions. This is used to tag both F<config.sh> and F<config_h.SH>.

=item C<cf_email>

From F<cf_email.U>:

Electronic mail address of the person who ran Configure. This can be
used by units that require the user's e-mail, like F<MailList.U>.

=item C<cf_time>

From F<cf_who.U>:

Holds the output of the C<date> command when the configuration file was
produced. This is used to tag both F<config.sh> and F<config_h.SH>.

=item C<charbits>

From F<charsize.U>:

This variable contains the value of the C<CHARBITS> symbol, which
indicates to the C program how many bits there are in a character.

=item C<charsize>

From F<charsize.U>:

This variable contains the value of the C<CHARSIZE> symbol, which
indicates to the C program how many bytes there are in a character.

=item C<chgrp>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<chmod>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the chmod program.  After Configure runs,
the value is reset to a plain C<chmod> and is not useful.

=item C<chown>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<clocktype>

From F<d_times.U>:

This variable holds the type returned by times(). It can be long,
or clock_t on C<BSD> sites (in which case <sys/types.h> should be
included).

=item C<comm>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the comm program.  After Configure runs,
the value is reset to a plain C<comm> and is not useful.

=item C<compress>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<config_arg0>

From F<Options.U>:

This variable contains the string used to invoke the Configure
command, as reported by the shell in the $0 variable.

=item C<config_argc>

From F<Options.U>:

This variable contains the number of command-line arguments
passed to Configure, as reported by the shell in the $# variable.
The individual arguments are stored as variables config_arg1,
config_arg2, etc.

=item C<config_args>

From F<Options.U>:

This variable contains a single string giving the command-line
arguments passed to Configure.	Spaces within arguments,
quotes, and escaped characters are not correctly preserved.
To reconstruct the command line, you must assemble the individual
command line pieces, given in config_arg[0-9]*.

=item C<contains>

From F<contains.U>:

This variable holds the command to do a grep with a proper return
status.  On most sane systems it is simply C<grep>.  On insane systems
it is a grep followed by a cat followed by a test.  This variable
is primarily for the use of other Configure units.

=item C<cp>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the cp program.  After Configure runs,
the value is reset to a plain C<cp> and is not useful.

=item C<cpio>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<cpp>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the cpp program.  After Configure runs,
the value is reset to a plain C<cpp> and is not useful.

=item C<cpp_stuff>

From F<cpp_stuff.U>:

This variable contains an identification of the concatenation mechanism
used by the C preprocessor.

=item C<cppccsymbols>

From F<Cppsym.U>:

The variable contains the symbols defined by the C compiler
when it calls cpp.  The symbols defined by the cc alone or cpp
alone are not in this list, see ccsymbols and cppsymbols.
The list is a space-separated list of symbol=value tokens.

=item C<cppflags>

From F<ccflags.U>:

This variable holds the flags that will be passed to the C pre-
processor. It is up to the Makefile to use it.

=item C<cpplast>

From F<cppstdin.U>:

This variable has the same functionality as cppminus, only it applies
to cpprun and not cppstdin.

=item C<cppminus>

From F<cppstdin.U>:

This variable contains the second part of the string which will invoke
the C preprocessor on the standard input and produce to standard
output.  This variable will have the value C<-> if cppstdin needs
a minus to specify standard input, otherwise the value is "".

=item C<cpprun>

From F<cppstdin.U>:

This variable contains the command which will invoke a C preprocessor
on standard input and put the output to stdout. It is guaranteed not
to be a wrapper and may be a null string if no preprocessor can be
made directly available. This preprocessor might be different from the
one used by the C compiler. Don't forget to append cpplast after the
preprocessor options.

=item C<cppstdin>

From F<cppstdin.U>:

This variable contains the command which will invoke the C
preprocessor on standard input and put the output to stdout.
It is primarily used by other Configure units that ask about
preprocessor symbols.

=item C<cppsymbols>

From F<Cppsym.U>:

The variable contains the symbols defined by the C preprocessor
alone.  The symbols defined by cc or by cc when it calls cpp are
not in this list, see ccsymbols and cppccsymbols.
The list is a space-separated list of symbol=value tokens.

=item C<crypt_r_proto>

From F<d_crypt_r.U>:

This variable encodes the prototype of crypt_r.
It is zero if d_crypt_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_crypt_r
is defined.

=item C<cryptlib>

From F<d_crypt.U>:

This variable holds -lcrypt or the path to a F<libcrypt.a> archive if
the crypt() function is not defined in the standard C library. It is
up to the Makefile to use this.

=item C<csh>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the csh program.  After Configure runs,
the value is reset to a plain C<csh> and is not useful.

=item C<ctermid_r_proto>

From F<d_ctermid_r.U>:

This variable encodes the prototype of ctermid_r.
It is zero if d_ctermid_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_ctermid_r
is defined.

=item C<ctime_r_proto>

From F<d_ctime_r.U>:

This variable encodes the prototype of ctime_r.
It is zero if d_ctime_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_ctime_r
is defined.

=back

=cut

=head2 d

=over 4

=cut

=item C<d__fwalk>

From F<d__fwalk.U>:

This variable conditionally defines C<HAS__FWALK> if _fwalk() is
available to apply a function to all the file handles.

=item C<d_access>

From F<d_access.U>:

This variable conditionally defines C<HAS_ACCESS> if the access() system
call is available to check for access permissions using real IDs.

=item C<d_accessx>

From F<d_accessx.U>:

This variable conditionally defines the C<HAS_ACCESSX> symbol, which
indicates to the C program that the accessx() routine is available.

=item C<d_aintl>

From F<d_aintl.U>:

This variable conditionally defines the C<HAS_AINTL> symbol, which
indicates to the C program that the aintl() routine is available.
If copysignl is also present we can emulate modfl.

=item C<d_alarm>

From F<d_alarm.U>:

This variable conditionally defines the C<HAS_ALARM> symbol, which
indicates to the C program that the alarm() routine is available.

=item C<d_archlib>

From F<archlib.U>:

This variable conditionally defines C<ARCHLIB> to hold the pathname
of architecture-dependent library files for $package.  If
$archlib is the same as $privlib, then this is set to undef.

=item C<d_asctime64>

From F<d_timefuncs64.U>:

This variable conditionally defines the HAS_ASCTIME64 symbol, which
indicates to the C program that the asctime64 () routine is available.

=item C<d_asctime_r>

From F<d_asctime_r.U>:

This variable conditionally defines the C<HAS_ASCTIME_R> symbol,
which indicates to the C program that the asctime_r()
routine is available.

=item C<d_atolf>

From F<atolf.U>:

This variable conditionally defines the C<HAS_ATOLF> symbol, which
indicates to the C program that the atolf() routine is available.

=item C<d_atoll>

From F<atoll.U>:

This variable conditionally defines the C<HAS_ATOLL> symbol, which
indicates to the C program that the atoll() routine is available.

=item C<d_attribute_deprecated>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_DEPRECATED>, which
indicates that C<GCC> can handle the attribute for marking deprecated
APIs

=item C<d_attribute_format>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_FORMAT>, which
indicates the C compiler can check for printf-like formats.

=item C<d_attribute_malloc>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_MALLOC>, which
indicates the C compiler can understand functions as having
malloc-like semantics.

=item C<d_attribute_nonnull>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_NONNULL>, which
indicates that the C compiler can know that certain arguments
must not be C<NULL>, and will check accordingly at compile time.

=item C<d_attribute_noreturn>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_NORETURN>, which
indicates that the C compiler can know that certain functions
are guaranteed never to return.

=item C<d_attribute_pure>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_PURE>, which
indicates that the C compiler can know that certain functions
are C<pure> functions, meaning that they have no side effects, and
only rely on function input F<and/or> global data for their results.

=item C<d_attribute_unused>

From F<d_attribut.U>:

This variable conditionally defines C<HASATTRIBUTE_UNUSED>, which
indicates that the C compiler can know that certain variables
and arguments may not always be used, and to not throw warnings
if they don't get used.

=item C<d_attribute_warn_unused_result>

From F<d_attribut.U>:

This variable conditionally defines
C<HASATTRIBUTE_WARN_UNUSED_RESULT>, which indicates that the C
compiler can know that certain functions have a return values
that must not be ignored, such as malloc() or open().

=item C<d_bcmp>

From F<d_bcmp.U>:

This variable conditionally defines the C<HAS_BCMP> symbol if
the bcmp() routine is available to compare strings.

=item C<d_bcopy>

From F<d_bcopy.U>:

This variable conditionally defines the C<HAS_BCOPY> symbol if
the bcopy() routine is available to copy strings.

=item C<d_bsd>

From F<Guess.U>:

This symbol conditionally defines the symbol C<BSD> when running on a
C<BSD> system.

=item C<d_bsdgetpgrp>

From F<d_getpgrp.U>:

This variable conditionally defines C<USE_BSD_GETPGRP> if
getpgrp needs one arguments whereas C<USG> one needs none.

=item C<d_bsdsetpgrp>

From F<d_setpgrp.U>:

This variable conditionally defines C<USE_BSD_SETPGRP> if
setpgrp needs two arguments whereas C<USG> one needs none.
See also d_setpgid for a C<POSIX> interface.

=item C<d_builtin_choose_expr>

From F<d_builtin.U>:

This conditionally defines C<HAS_BUILTIN_CHOOSE_EXPR>, which
indicates that the compiler supports __builtin_choose_expr(x,y,z).
This built-in function is analogous to the C<x?y:z> operator in C,
except that the expression returned has its type unaltered by
promotion rules. Also, the built-in function does not evaluate
the expression that was not chosen.

=item C<d_builtin_expect>

From F<d_builtin.U>:

This conditionally defines C<HAS_BUILTIN_EXPECT>, which indicates
that the compiler supports __builtin_expect(exp,c).  You may use
__builtin_expect to provide the compiler with branch prediction
information.

=item C<d_bzero>

From F<d_bzero.U>:

This variable conditionally defines the C<HAS_BZERO> symbol if
the bzero() routine is available to set memory to 0.

=item C<d_c99_variadic_macros>

From F<d_c99_variadic.U>:

This variable conditionally defines the HAS_C99_VARIADIC_MACROS
symbol, which indicates to the C program that C99 variadic macros
are available.

=item C<d_casti32>

From F<d_casti32.U>:

This variable conditionally defines CASTI32, which indicates
whether the C compiler can cast large floats to 32-bit ints.

=item C<d_castneg>

From F<d_castneg.U>:

This variable conditionally defines C<CASTNEG>, which indicates
whether the C compiler can cast negative float to unsigned.

=item C<d_charvspr>

From F<d_vprintf.U>:

This variable conditionally defines C<CHARVSPRINTF> if this system
has vsprintf returning type (char*).  The trend seems to be to
declare it as "int vsprintf()".

=item C<d_chown>

From F<d_chown.U>:

This variable conditionally defines the C<HAS_CHOWN> symbol, which
indicates to the C program that the chown() routine is available.

=item C<d_chroot>

From F<d_chroot.U>:

This variable conditionally defines the C<HAS_CHROOT> symbol, which
indicates to the C program that the chroot() routine is available.

=item C<d_chsize>

From F<d_chsize.U>:

This variable conditionally defines the C<CHSIZE> symbol, which
indicates to the C program that the chsize() routine is available
to truncate files.  You might need a -lx to get this routine.

=item C<d_class>

From F<d_class.U>:

This variable conditionally defines the C<HAS_CLASS> symbol, which
indicates to the C program that the class() routine is available.

=item C<d_clearenv>

From F<d_clearenv.U>:

This variable conditionally defines the C<HAS_CLEARENV> symbol, which
indicates to the C program that the clearenv () routine is available.

=item C<d_closedir>

From F<d_closedir.U>:

This variable conditionally defines C<HAS_CLOSEDIR> if closedir() is
available.

=item C<d_cmsghdr_s>

From F<d_cmsghdr_s.U>:

This variable conditionally defines the C<HAS_STRUCT_CMSGHDR> symbol,
which indicates that the struct cmsghdr is supported.

=item C<d_const>

From F<d_const.U>:

This variable conditionally defines the C<HASCONST> symbol, which
indicates to the C program that this C compiler knows about the
const type.

=item C<d_copysignl>

From F<d_copysignl.U>:

This variable conditionally defines the C<HAS_COPYSIGNL> symbol, which
indicates to the C program that the copysignl() routine is available.
If aintl is also present we can emulate modfl.

=item C<d_cplusplus>

From F<d_cplusplus.U>:

This variable conditionally defines the C<USE_CPLUSPLUS> symbol, which
indicates that a C++ compiler was used to compiled Perl and will be
used to compile extensions.

=item C<d_crypt>

From F<d_crypt.U>:

This variable conditionally defines the C<CRYPT> symbol, which
indicates to the C program that the crypt() routine is available
to encrypt passwords and the like.

=item C<d_crypt_r>

From F<d_crypt_r.U>:

This variable conditionally defines the C<HAS_CRYPT_R> symbol,
which indicates to the C program that the crypt_r()
routine is available.

=item C<d_csh>

From F<d_csh.U>:

This variable conditionally defines the C<CSH> symbol, which
indicates to the C program that the C-shell exists.

=item C<d_ctermid>

From F<d_ctermid.U>:

This variable conditionally defines C<CTERMID> if ctermid() is
available to generate filename for terminal.

=item C<d_ctermid_r>

From F<d_ctermid_r.U>:

This variable conditionally defines the C<HAS_CTERMID_R> symbol,
which indicates to the C program that the ctermid_r()
routine is available.

=item C<d_ctime64>

From F<d_timefuncs64.U>:

This variable conditionally defines the HAS_CTIME64 symbol, which
indicates to the C program that the ctime64 () routine is available.

=item C<d_ctime_r>

From F<d_ctime_r.U>:

This variable conditionally defines the C<HAS_CTIME_R> symbol,
which indicates to the C program that the ctime_r()
routine is available.

=item C<d_cuserid>

From F<d_cuserid.U>:

This variable conditionally defines the C<HAS_CUSERID> symbol, which
indicates to the C program that the cuserid() routine is available
to get character login names.

=item C<d_dbl_dig>

From F<d_dbl_dig.U>:

This variable conditionally defines d_dbl_dig if this system's
header files provide C<DBL_DIG>, which is the number of significant
digits in a double precision number.

=item C<d_dbminitproto>

From F<d_dbminitproto.U>:

This variable conditionally defines the C<HAS_DBMINIT_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the dbminit() function.  Otherwise, it is
up to the program to supply one.

=item C<d_difftime>

From F<d_difftime.U>:

This variable conditionally defines the C<HAS_DIFFTIME> symbol, which
indicates to the C program that the difftime() routine is available.

=item C<d_difftime64>

From F<d_timefuncs64.U>:

This variable conditionally defines the HAS_DIFFTIME64 symbol, which
indicates to the C program that the difftime64 () routine is available.

=item C<d_dir_dd_fd>

From F<d_dir_dd_fd.U>:

This variable conditionally defines the C<HAS_DIR_DD_FD> symbol, which
indicates that the C<DIR> directory stream type contains a member
variable called dd_fd.

=item C<d_dirfd>

From F<d_dirfd.U>:

This variable conditionally defines the C<HAS_DIRFD> constant,
which indicates to the C program that dirfd() is available
to return the file descriptor of a directory stream.

=item C<d_dirnamlen>

From F<i_dirent.U>:

This variable conditionally defines C<DIRNAMLEN>, which indicates
to the C program that the length of directory entry names is
provided by a d_namelen field.

=item C<d_dlerror>

From F<d_dlerror.U>:

This variable conditionally defines the C<HAS_DLERROR> symbol, which
indicates to the C program that the dlerror() routine is available.

=item C<d_dlopen>

From F<d_dlopen.U>:

This variable conditionally defines the C<HAS_DLOPEN> symbol, which
indicates to the C program that the dlopen() routine is available.

=item C<d_dlsymun>

From F<d_dlsymun.U>:

This variable conditionally defines C<DLSYM_NEEDS_UNDERSCORE>, which
indicates that we need to prepend an underscore to the symbol
name before calling dlsym().

=item C<d_dosuid>

From F<d_dosuid.U>:

This variable conditionally defines the symbol C<DOSUID>, which
tells the C program that it should insert setuid emulation code
on hosts which have setuid #! scripts disabled.

=item C<d_drand48_r>

From F<d_drand48_r.U>:

This variable conditionally defines the HAS_DRAND48_R symbol,
which indicates to the C program that the drand48_r()
routine is available.

=item C<d_drand48proto>

From F<d_drand48proto.U>:

This variable conditionally defines the HAS_DRAND48_PROTO symbol,
which indicates to the C program that the system provides
a prototype for the drand48() function.  Otherwise, it is
up to the program to supply one.

=item C<d_dup2>

From F<d_dup2.U>:

This variable conditionally defines HAS_DUP2 if dup2() is
available to duplicate file descriptors.

=item C<d_eaccess>

From F<d_eaccess.U>:

This variable conditionally defines the C<HAS_EACCESS> symbol, which
indicates to the C program that the eaccess() routine is available.

=item C<d_endgrent>

From F<d_endgrent.U>:

This variable conditionally defines the C<HAS_ENDGRENT> symbol, which
indicates to the C program that the endgrent() routine is available
for sequential access of the group database.

=item C<d_endgrent_r>

From F<d_endgrent_r.U>:

This variable conditionally defines the C<HAS_ENDGRENT_R> symbol,
which indicates to the C program that the endgrent_r()
routine is available.

=item C<d_endhent>

From F<d_endhent.U>:

This variable conditionally defines C<HAS_ENDHOSTENT> if endhostent() is
available to close whatever was being used for host queries.

=item C<d_endhostent_r>

From F<d_endhostent_r.U>:

This variable conditionally defines the C<HAS_ENDHOSTENT_R> symbol,
which indicates to the C program that the endhostent_r()
routine is available.

=item C<d_endnent>

From F<d_endnent.U>:

This variable conditionally defines C<HAS_ENDNETENT> if endnetent() is
available to close whatever was being used for network queries.

=item C<d_endnetent_r>

From F<d_endnetent_r.U>:

This variable conditionally defines the C<HAS_ENDNETENT_R> symbol,
which indicates to the C program that the endnetent_r()
routine is available.

=item C<d_endpent>

From F<d_endpent.U>:

This variable conditionally defines C<HAS_ENDPROTOENT> if endprotoent() is
available to close whatever was being used for protocol queries.

=item C<d_endprotoent_r>

From F<d_endprotoent_r.U>:

This variable conditionally defines the C<HAS_ENDPROTOENT_R> symbol,
which indicates to the C program that the endprotoent_r()
routine is available.

=item C<d_endpwent>

From F<d_endpwent.U>:

This variable conditionally defines the C<HAS_ENDPWENT> symbol, which
indicates to the C program that the endpwent() routine is available
for sequential access of the passwd database.

=item C<d_endpwent_r>

From F<d_endpwent_r.U>:

This variable conditionally defines the C<HAS_ENDPWENT_R> symbol,
which indicates to the C program that the endpwent_r()
routine is available.

=item C<d_endsent>

From F<d_endsent.U>:

This variable conditionally defines C<HAS_ENDSERVENT> if endservent() is
available to close whatever was being used for service queries.

=item C<d_endservent_r>

From F<d_endservent_r.U>:

This variable conditionally defines the C<HAS_ENDSERVENT_R> symbol,
which indicates to the C program that the endservent_r()
routine is available.

=item C<d_eofnblk>

From F<nblock_io.U>:

This variable conditionally defines C<EOF_NONBLOCK> if C<EOF> can be seen
when reading from a non-blocking I/O source.

=item C<d_eunice>

From F<Guess.U>:

This variable conditionally defines the symbols C<EUNICE> and C<VAX>, which
alerts the C program that it must deal with idiosyncrasies of C<VMS>.

=item C<d_faststdio>

From F<d_faststdio.U>:

This variable conditionally defines the C<HAS_FAST_STDIO> symbol,
which indicates to the C program that the "fast stdio" is available
to manipulate the stdio buffers directly.

=item C<d_fchdir>

From F<d_fchdir.U>:

This variable conditionally defines the C<HAS_FCHDIR> symbol, which
indicates to the C program that the fchdir() routine is available.

=item C<d_fchmod>

From F<d_fchmod.U>:

This variable conditionally defines the C<HAS_FCHMOD> symbol, which
indicates to the C program that the fchmod() routine is available
to change mode of opened files.

=item C<d_fchown>

From F<d_fchown.U>:

This variable conditionally defines the C<HAS_FCHOWN> symbol, which
indicates to the C program that the fchown() routine is available
to change ownership of opened files.

=item C<d_fcntl>

From F<d_fcntl.U>:

This variable conditionally defines the C<HAS_FCNTL> symbol, and indicates
whether the fcntl() function exists

=item C<d_fcntl_can_lock>

From F<d_fcntl_can_lock.U>:

This variable conditionally defines the C<FCNTL_CAN_LOCK> symbol
and indicates whether file locking with fcntl() works.

=item C<d_fd_macros>

From F<d_fd_set.U>:

This variable contains the eventual value of the C<HAS_FD_MACROS> symbol,
which indicates if your C compiler knows about the macros which
manipulate an fd_set.

=item C<d_fd_set>

From F<d_fd_set.U>:

This variable contains the eventual value of the C<HAS_FD_SET> symbol,
which indicates if your C compiler knows about the fd_set typedef.

=item C<d_fds_bits>

From F<d_fd_set.U>:

This variable contains the eventual value of the C<HAS_FDS_BITS> symbol,
which indicates if your fd_set typedef contains the fds_bits member.
If you have an fd_set typedef, but the dweebs who installed it did
a half-fast job and neglected to provide the macros to manipulate
an fd_set, C<HAS_FDS_BITS> will let us know how to fix the gaffe.

=item C<d_fgetpos>

From F<d_fgetpos.U>:

This variable conditionally defines C<HAS_FGETPOS> if fgetpos() is
available to get the file position indicator.

=item C<d_finite>

From F<d_finite.U>:

This variable conditionally defines the C<HAS_FINITE> symbol, which
indicates to the C program that the finite() routine is available.

=item C<d_finitel>

From F<d_finitel.U>:

This variable conditionally defines the C<HAS_FINITEL> symbol, which
indicates to the C program that the finitel() routine is available.

=item C<d_flexfnam>

From F<d_flexfnam.U>:

This variable conditionally defines the C<FLEXFILENAMES> symbol, which
indicates that the system supports filenames longer than 14 characters.

=item C<d_flock>

From F<d_flock.U>:

This variable conditionally defines C<HAS_FLOCK> if flock() is
available to do file locking.

=item C<d_flockproto>

From F<d_flockproto.U>:

This variable conditionally defines the C<HAS_FLOCK_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the flock() function.  Otherwise, it is
up to the program to supply one.

=item C<d_fork>

From F<d_fork.U>:

This variable conditionally defines the C<HAS_FORK> symbol, which
indicates to the C program that the fork() routine is available.

=item C<d_fp_class>

From F<d_fp_class.U>:

This variable conditionally defines the C<HAS_FP_CLASS> symbol, which
indicates to the C program that the fp_class() routine is available.

=item C<d_fpathconf>

From F<d_pathconf.U>:

This variable conditionally defines the C<HAS_FPATHCONF> symbol, which
indicates to the C program that the pathconf() routine is available
to determine file-system related limits and options associated
with a given open file descriptor.

=item C<d_fpclass>

From F<d_fpclass.U>:

This variable conditionally defines the C<HAS_FPCLASS> symbol, which
indicates to the C program that the fpclass() routine is available.

=item C<d_fpclassify>

From F<d_fpclassify.U>:

This variable conditionally defines the C<HAS_FPCLASSIFY> symbol, which
indicates to the C program that the fpclassify() routine is available.

=item C<d_fpclassl>

From F<d_fpclassl.U>:

This variable conditionally defines the C<HAS_FPCLASSL> symbol, which
indicates to the C program that the fpclassl() routine is available.

=item C<d_fpos64_t>

From F<d_fpos64_t.U>:

This symbol will be defined if the C compiler supports fpos64_t.

=item C<d_frexpl>

From F<d_frexpl.U>:

This variable conditionally defines the C<HAS_FREXPL> symbol, which
indicates to the C program that the frexpl() routine is available.

=item C<d_fs_data_s>

From F<d_fs_data_s.U>:

This variable conditionally defines the C<HAS_STRUCT_FS_DATA> symbol,
which indicates that the struct fs_data is supported.

=item C<d_fseeko>

From F<d_fseeko.U>:

This variable conditionally defines the C<HAS_FSEEKO> symbol, which
indicates to the C program that the fseeko() routine is available.

=item C<d_fsetpos>

From F<d_fsetpos.U>:

This variable conditionally defines C<HAS_FSETPOS> if fsetpos() is
available to set the file position indicator.

=item C<d_fstatfs>

From F<d_fstatfs.U>:

This variable conditionally defines the C<HAS_FSTATFS> symbol, which
indicates to the C program that the fstatfs() routine is available.

=item C<d_fstatvfs>

From F<d_statvfs.U>:

This variable conditionally defines the C<HAS_FSTATVFS> symbol, which
indicates to the C program that the fstatvfs() routine is available.

=item C<d_fsync>

From F<d_fsync.U>:

This variable conditionally defines the C<HAS_FSYNC> symbol, which
indicates to the C program that the fsync() routine is available.

=item C<d_ftello>

From F<d_ftello.U>:

This variable conditionally defines the C<HAS_FTELLO> symbol, which
indicates to the C program that the ftello() routine is available.

=item C<d_ftime>

From F<d_ftime.U>:

This variable conditionally defines the C<HAS_FTIME> symbol, which indicates
that the ftime() routine exists.  The ftime() routine is basically
a sub-second accuracy clock.

=item C<d_futimes>

From F<d_futimes.U>:

This variable conditionally defines the C<HAS_FUTIMES> symbol, which
indicates to the C program that the futimes() routine is available.

=item C<d_Gconvert>

From F<d_gconvert.U>:

This variable holds what Gconvert is defined as to convert
floating point numbers into strings.  By default, Configure
sets C<this> macro to use the first of gconvert, gcvt, or sprintf
that pass sprintf-%g-like behavior tests.  If perl is using
long doubles, the macro uses the first of the following
functions that pass Configure's tests: qgcvt, sprintf (if
Configure knows how to make sprintf format long doubles--see
sPRIgldbl), gconvert, gcvt, and sprintf (casting to double).
The gconvert_preference and gconvert_ld_preference variables
can be used to alter Configure's preferences, for doubles and
long doubles, respectively.  If present, they contain a
space-separated list of one or more of the above function
names in the order they should be tried.

d_Gconvert may be set to override Configure with a platform-
specific function.  If this function expects a double, a
different value may need to be set by the F<uselongdouble.cbu>
call-back unit so that long doubles can be formatted without
loss of precision.

=item C<d_gdbm_ndbm_h_uses_prototypes>

From F<i_ndbm.U>:

This variable conditionally defines the C<NDBM_H_USES_PROTOTYPES> symbol,
which indicates that the gdbm-F<ndbm.h> include file uses real C<ANSI> C
prototypes instead of K&R style function declarations. K&R style
declarations are unsupported in C++, so the include file requires
special handling when using a C++ compiler and this variable is
undefined. Consult the different d_*ndbm_h_uses_prototypes variables
to get the same information for alternative F<ndbm.h> include files.

=item C<d_gdbmndbm_h_uses_prototypes>

From F<i_ndbm.U>:

This variable conditionally defines the C<NDBM_H_USES_PROTOTYPES> symbol,
which indicates that the F<gdbm/ndbm.h> include file uses real C<ANSI> C
prototypes instead of K&R style function declarations. K&R style
declarations are unsupported in C++, so the include file requires
special handling when using a C++ compiler and this variable is
undefined. Consult the different d_*ndbm_h_uses_prototypes variables
to get the same information for alternative F<ndbm.h> include files.

=item C<d_getaddrinfo>

From F<d_getaddrinfo.U>:

This variable conditionally defines the C<HAS_GETADDRINFO> symbol,
which indicates to the C program that the getaddrinfo() function
is available.

=item C<d_getcwd>

From F<d_getcwd.U>:

This variable conditionally defines the C<HAS_GETCWD> symbol, which
indicates to the C program that the getcwd() routine is available
to get the current working directory.

=item C<d_getespwnam>

From F<d_getespwnam.U>:

This variable conditionally defines C<HAS_GETESPWNAM> if getespwnam() is
available to retrieve enhanced (shadow) password entries by name.

=item C<d_getfsstat>

From F<d_getfsstat.U>:

This variable conditionally defines the C<HAS_GETFSSTAT> symbol, which
indicates to the C program that the getfsstat() routine is available.

=item C<d_getgrent>

From F<d_getgrent.U>:

This variable conditionally defines the C<HAS_GETGRENT> symbol, which
indicates to the C program that the getgrent() routine is available
for sequential access of the group database.

=item C<d_getgrent_r>

From F<d_getgrent_r.U>:

This variable conditionally defines the C<HAS_GETGRENT_R> symbol,
which indicates to the C program that the getgrent_r()
routine is available.

=item C<d_getgrgid_r>

From F<d_getgrgid_r.U>:

This variable conditionally defines the C<HAS_GETGRGID_R> symbol,
which indicates to the C program that the getgrgid_r()
routine is available.

=item C<d_getgrnam_r>

From F<d_getgrnam_r.U>:

This variable conditionally defines the C<HAS_GETGRNAM_R> symbol,
which indicates to the C program that the getgrnam_r()
routine is available.

=item C<d_getgrps>

From F<d_getgrps.U>:

This variable conditionally defines the C<HAS_GETGROUPS> symbol, which
indicates to the C program that the getgroups() routine is available
to get the list of process groups.

=item C<d_gethbyaddr>

From F<d_gethbyad.U>:

This variable conditionally defines the C<HAS_GETHOSTBYADDR> symbol, which
indicates to the C program that the gethostbyaddr() routine is available
to look up hosts by their C<IP> addresses.

=item C<d_gethbyname>

From F<d_gethbynm.U>:

This variable conditionally defines the C<HAS_GETHOSTBYNAME> symbol, which
indicates to the C program that the gethostbyname() routine is available
to look up host names in some data base or other.

=item C<d_gethent>

From F<d_gethent.U>:

This variable conditionally defines C<HAS_GETHOSTENT> if gethostent() is
available to look up host names in some data base or another.

=item C<d_gethname>

From F<d_gethname.U>:

This variable conditionally defines the C<HAS_GETHOSTNAME> symbol, which
indicates to the C program that the gethostname() routine may be
used to derive the host name.

=item C<d_gethostbyaddr_r>

From F<d_gethostbyaddr_r.U>:

This variable conditionally defines the C<HAS_GETHOSTBYADDR_R> symbol,
which indicates to the C program that the gethostbyaddr_r()
routine is available.

=item C<d_gethostbyname_r>

From F<d_gethostbyname_r.U>:

This variable conditionally defines the C<HAS_GETHOSTBYNAME_R> symbol,
which indicates to the C program that the gethostbyname_r()
routine is available.

=item C<d_gethostent_r>

From F<d_gethostent_r.U>:

This variable conditionally defines the C<HAS_GETHOSTENT_R> symbol,
which indicates to the C program that the gethostent_r()
routine is available.

=item C<d_gethostprotos>

From F<d_gethostprotos.U>:

This variable conditionally defines the C<HAS_GETHOST_PROTOS> symbol,
which indicates to the C program that <netdb.h> supplies
prototypes for the various gethost*() functions.
See also F<netdbtype.U> for probing for various netdb types.

=item C<d_getitimer>

From F<d_getitimer.U>:

This variable conditionally defines the C<HAS_GETITIMER> symbol, which
indicates to the C program that the getitimer() routine is available.

=item C<d_getlogin>

From F<d_getlogin.U>:

This variable conditionally defines the C<HAS_GETLOGIN> symbol, which
indicates to the C program that the getlogin() routine is available
to get the login name.

=item C<d_getlogin_r>

From F<d_getlogin_r.U>:

This variable conditionally defines the C<HAS_GETLOGIN_R> symbol,
which indicates to the C program that the getlogin_r()
routine is available.

=item C<d_getmnt>

From F<d_getmnt.U>:

This variable conditionally defines the C<HAS_GETMNT> symbol, which
indicates to the C program that the getmnt() routine is available
to retrieve one or more mount info blocks by filename.

=item C<d_getmntent>

From F<d_getmntent.U>:

This variable conditionally defines the C<HAS_GETMNTENT> symbol, which
indicates to the C program that the getmntent() routine is available
to iterate through mounted files to get their mount info.

=item C<d_getnameinfo>

From F<d_getnameinfo.U>:

This variable conditionally defines the C<HAS_GETNAMEINFO> symbol,
which indicates to the C program that the getnameinfo() function
is available.

=item C<d_getnbyaddr>

From F<d_getnbyad.U>:

This variable conditionally defines the C<HAS_GETNETBYADDR> symbol, which
indicates to the C program that the getnetbyaddr() routine is available
to look up networks by their C<IP> addresses.

=item C<d_getnbyname>

From F<d_getnbynm.U>:

This variable conditionally defines the C<HAS_GETNETBYNAME> symbol, which
indicates to the C program that the getnetbyname() routine is available
to look up networks by their names.

=item C<d_getnent>

From F<d_getnent.U>:

This variable conditionally defines C<HAS_GETNETENT> if getnetent() is
available to look up network names in some data base or another.

=item C<d_getnetbyaddr_r>

From F<d_getnetbyaddr_r.U>:

This variable conditionally defines the C<HAS_GETNETBYADDR_R> symbol,
which indicates to the C program that the getnetbyaddr_r()
routine is available.

=item C<d_getnetbyname_r>

From F<d_getnetbyname_r.U>:

This variable conditionally defines the C<HAS_GETNETBYNAME_R> symbol,
which indicates to the C program that the getnetbyname_r()
routine is available.

=item C<d_getnetent_r>

From F<d_getnetent_r.U>:

This variable conditionally defines the C<HAS_GETNETENT_R> symbol,
which indicates to the C program that the getnetent_r()
routine is available.

=item C<d_getnetprotos>

From F<d_getnetprotos.U>:

This variable conditionally defines the C<HAS_GETNET_PROTOS> symbol,
which indicates to the C program that <netdb.h> supplies
prototypes for the various getnet*() functions.
See also F<netdbtype.U> for probing for various netdb types.

=item C<d_getpagsz>

From F<d_getpagsz.U>:

This variable conditionally defines C<HAS_GETPAGESIZE> if getpagesize()
is available to get the system page size.

=item C<d_getpbyname>

From F<d_getprotby.U>:

This variable conditionally defines the C<HAS_GETPROTOBYNAME>
symbol, which indicates to the C program that the
getprotobyname() routine is available to look up protocols
by their name.

=item C<d_getpbynumber>

From F<d_getprotby.U>:

This variable conditionally defines the C<HAS_GETPROTOBYNUMBER>
symbol, which indicates to the C program that the
getprotobynumber() routine is available to look up protocols
by their number.

=item C<d_getpent>

From F<d_getpent.U>:

This variable conditionally defines C<HAS_GETPROTOENT> if getprotoent() is
available to look up protocols in some data base or another.

=item C<d_getpgid>

From F<d_getpgid.U>:

This variable conditionally defines the C<HAS_GETPGID> symbol, which
indicates to the C program that the getpgid(pid) function
is available to get the process group id.

=item C<d_getpgrp>

From F<d_getpgrp.U>:

This variable conditionally defines C<HAS_GETPGRP> if getpgrp() is
available to get the current process group.

=item C<d_getpgrp2>

From F<d_getpgrp2.U>:

This variable conditionally defines the HAS_GETPGRP2 symbol, which
indicates to the C program that the getpgrp2() (as in F<DG/C<UX>>) routine
is available to get the current process group.

=item C<d_getppid>

From F<d_getppid.U>:

This variable conditionally defines the C<HAS_GETPPID> symbol, which
indicates to the C program that the getppid() routine is available
to get the parent process C<ID>.

=item C<d_getprior>

From F<d_getprior.U>:

This variable conditionally defines C<HAS_GETPRIORITY> if getpriority()
is available to get a process's priority.

=item C<d_getprotobyname_r>

From F<d_getprotobyname_r.U>:

This variable conditionally defines the C<HAS_GETPROTOBYNAME_R> symbol,
which indicates to the C program that the getprotobyname_r()
routine is available.

=item C<d_getprotobynumber_r>

From F<d_getprotobynumber_r.U>:

This variable conditionally defines the C<HAS_GETPROTOBYNUMBER_R> symbol,
which indicates to the C program that the getprotobynumber_r()
routine is available.

=item C<d_getprotoent_r>

From F<d_getprotoent_r.U>:

This variable conditionally defines the C<HAS_GETPROTOENT_R> symbol,
which indicates to the C program that the getprotoent_r()
routine is available.

=item C<d_getprotoprotos>

From F<d_getprotoprotos.U>:

This variable conditionally defines the C<HAS_GETPROTO_PROTOS> symbol,
which indicates to the C program that <netdb.h> supplies
prototypes for the various getproto*() functions.
See also F<netdbtype.U> for probing for various netdb types.

=item C<d_getprpwnam>

From F<d_getprpwnam.U>:

This variable conditionally defines C<HAS_GETPRPWNAM> if getprpwnam() is
available to retrieve protected (shadow) password entries by name.

=item C<d_getpwent>

From F<d_getpwent.U>:

This variable conditionally defines the C<HAS_GETPWENT> symbol, which
indicates to the C program that the getpwent() routine is available
for sequential access of the passwd database.

=item C<d_getpwent_r>

From F<d_getpwent_r.U>:

This variable conditionally defines the C<HAS_GETPWENT_R> symbol,
which indicates to the C program that the getpwent_r()
routine is available.

=item C<d_getpwnam_r>

From F<d_getpwnam_r.U>:

This variable conditionally defines the C<HAS_GETPWNAM_R> symbol,
which indicates to the C program that the getpwnam_r()
routine is available.

=item C<d_getpwuid_r>

From F<d_getpwuid_r.U>:

This variable conditionally defines the C<HAS_GETPWUID_R> symbol,
which indicates to the C program that the getpwuid_r()
routine is available.

=item C<d_getsbyname>

From F<d_getsrvby.U>:

This variable conditionally defines the C<HAS_GETSERVBYNAME>
symbol, which indicates to the C program that the
getservbyname() routine is available to look up services
by their name.

=item C<d_getsbyport>

From F<d_getsrvby.U>:

This variable conditionally defines the C<HAS_GETSERVBYPORT>
symbol, which indicates to the C program that the
getservbyport() routine is available to look up services
by their port.

=item C<d_getsent>

From F<d_getsent.U>:

This variable conditionally defines C<HAS_GETSERVENT> if getservent() is
available to look up network services in some data base or another.

=item C<d_getservbyname_r>

From F<d_getservbyname_r.U>:

This variable conditionally defines the C<HAS_GETSERVBYNAME_R> symbol,
which indicates to the C program that the getservbyname_r()
routine is available.

=item C<d_getservbyport_r>

From F<d_getservbyport_r.U>:

This variable conditionally defines the C<HAS_GETSERVBYPORT_R> symbol,
which indicates to the C program that the getservbyport_r()
routine is available.

=item C<d_getservent_r>

From F<d_getservent_r.U>:

This variable conditionally defines the C<HAS_GETSERVENT_R> symbol,
which indicates to the C program that the getservent_r()
routine is available.

=item C<d_getservprotos>

From F<d_getservprotos.U>:

This variable conditionally defines the C<HAS_GETSERV_PROTOS> symbol,
which indicates to the C program that <netdb.h> supplies
prototypes for the various getserv*() functions.
See also F<netdbtype.U> for probing for various netdb types.

=item C<d_getspnam>

From F<d_getspnam.U>:

This variable conditionally defines C<HAS_GETSPNAM> if getspnam() is
available to retrieve SysV shadow password entries by name.

=item C<d_getspnam_r>

From F<d_getspnam_r.U>:

This variable conditionally defines the C<HAS_GETSPNAM_R> symbol,
which indicates to the C program that the getspnam_r()
routine is available.

=item C<d_gettimeod>

From F<d_ftime.U>:

This variable conditionally defines the C<HAS_GETTIMEOFDAY> symbol, which
indicates that the gettimeofday() system call exists (to obtain a
sub-second accuracy clock). You should probably include <sys/resource.h>.

=item C<d_gmtime64>

From F<d_timefuncs64.U>:

This variable conditionally defines the HAS_GMTIME64 symbol, which
indicates to the C program that the gmtime64 () routine is available.

=item C<d_gmtime_r>

From F<d_gmtime_r.U>:

This variable conditionally defines the C<HAS_GMTIME_R> symbol,
which indicates to the C program that the gmtime_r()
routine is available.

=item C<d_gnulibc>

From F<d_gnulibc.U>:

Defined if we're dealing with the C<GNU> C Library.

=item C<d_grpasswd>

From F<i_grp.U>:

This variable conditionally defines C<GRPASSWD>, which indicates
that struct group in <grp.h> contains gr_passwd.

=item C<d_hasmntopt>

From F<d_hasmntopt.U>:

This variable conditionally defines the C<HAS_HASMNTOPT> symbol, which
indicates to the C program that the hasmntopt() routine is available
to query the mount options of file systems.

=item C<d_htonl>

From F<d_htonl.U>:

This variable conditionally defines C<HAS_HTONL> if htonl() and its
friends are available to do network order byte swapping.

=item C<d_ilogbl>

From F<d_ilogbl.U>:

This variable conditionally defines the C<HAS_ILOGBL> symbol, which
indicates to the C program that the ilogbl() routine is available.
If scalbnl is also present we can emulate frexpl.

=item C<d_inc_version_list>

From F<inc_version_list.U>:

This variable conditionally defines C<PERL_INC_VERSION_LIST>.
It is set to undef when C<PERL_INC_VERSION_LIST> is empty.

=item C<d_index>

From F<d_strchr.U>:

This variable conditionally defines C<HAS_INDEX> if index() and
rindex() are available for string searching.

=item C<d_inetaton>

From F<d_inetaton.U>:

This variable conditionally defines the C<HAS_INET_ATON> symbol, which
indicates to the C program that the inet_aton() function is available
to parse C<IP> address C<dotted-quad> strings.

=item C<d_inetntop>

From F<d_inetntop.U>:

This variable conditionally defines the C<HAS_INETNTOP> symbol,
which indicates to the C program that the inet_ntop() function
is available.

=item C<d_inetpton>

From F<d_inetpton.U>:

This variable conditionally defines the C<HAS_INETPTON> symbol,
which indicates to the C program that the inet_pton() function
is available.

=item C<d_int64_t>

From F<d_int64_t.U>:

This symbol will be defined if the C compiler supports int64_t.

=item C<d_ip_mreq>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_IP_MREQ> symbol, which
indicates the availability of a struct ip_mreq.

=item C<d_ip_mreq_source>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_IP_MREQ_SOURCE> symbol,
which indicates the availability of a struct ip_mreq_source.

=item C<d_ipv6_mreq>

From F<d_socket.U>:

This variable conditionally defines the HAS_IPV6_MREQ symbol, which
indicates the availability of a struct ipv6_mreq.

=item C<d_ipv6_mreq_source>

From F<d_socket.U>:

This variable conditionally defines the HAS_IPV6_MREQ_SOURCE symbol,
which indicates the availability of a struct ipv6_mreq_source.

=item C<d_isascii>

From F<d_isascii.U>:

This variable conditionally defines the C<HAS_ISASCII> constant,
which indicates to the C program that isascii() is available.

=item C<d_isblank>

From F<d_isblank.U>:

This variable conditionally defines the C<HAS_ISBLANK> constant,
which indicates to the C program that isblank() is available.

=item C<d_isfinite>

From F<d_isfinite.U>:

This variable conditionally defines the C<HAS_ISFINITE> symbol, which
indicates to the C program that the isfinite() routine is available.

=item C<d_isinf>

From F<d_isinf.U>:

This variable conditionally defines the C<HAS_ISINF> symbol, which
indicates to the C program that the isinf() routine is available.

=item C<d_isnan>

From F<d_isnan.U>:

This variable conditionally defines the C<HAS_ISNAN> symbol, which
indicates to the C program that the isnan() routine is available.

=item C<d_isnanl>

From F<d_isnanl.U>:

This variable conditionally defines the C<HAS_ISNANL> symbol, which
indicates to the C program that the isnanl() routine is available.

=item C<d_killpg>

From F<d_killpg.U>:

This variable conditionally defines the C<HAS_KILLPG> symbol, which
indicates to the C program that the killpg() routine is available
to kill process groups.

=item C<d_lchown>

From F<d_lchown.U>:

This variable conditionally defines the C<HAS_LCHOWN> symbol, which
indicates to the C program that the lchown() routine is available
to operate on a symbolic link (instead of following the link).

=item C<d_ldbl_dig>

From F<d_ldbl_dig.U>:

This variable conditionally defines d_ldbl_dig if this system's
header files provide C<LDBL_DIG>, which is the number of significant
digits in a long double precision number.

=item C<d_libm_lib_version>

From F<d_libm_lib_version.U>:

This variable conditionally defines the C<LIBM_LIB_VERSION> symbol,
which indicates to the C program that F<math.h> defines C<_LIB_VERSION>
being available in libm

=item C<d_libname_unique>

From F<so.U>:

This variable is defined if the target system insists on unique
basenames for shared library files. This is currently true on Android,
false everywhere else we know of.
Defaults to C<undef>.

=item C<d_link>

From F<d_link.U>:

This variable conditionally defines C<HAS_LINK> if link() is
available to create hard links.

=item C<d_localtime64>

From F<d_timefuncs64.U>:

This variable conditionally defines the HAS_LOCALTIME64 symbol, which
indicates to the C program that the localtime64 () routine is available.

=item C<d_localtime_r>

From F<d_localtime_r.U>:

This variable conditionally defines the C<HAS_LOCALTIME_R> symbol,
which indicates to the C program that the localtime_r()
routine is available.

=item C<d_localtime_r_needs_tzset>

From F<d_localtime_r.U>:

This variable conditionally defines the C<LOCALTIME_R_NEEDS_TZSET>
symbol, which makes us call tzset before localtime_r()

=item C<d_locconv>

From F<d_locconv.U>:

This variable conditionally defines C<HAS_LOCALECONV> if localeconv() is
available for numeric and monetary formatting conventions.

=item C<d_lockf>

From F<d_lockf.U>:

This variable conditionally defines C<HAS_LOCKF> if lockf() is
available to do file locking.

=item C<d_longdbl>

From F<d_longdbl.U>:

This variable conditionally defines C<HAS_LONG_DOUBLE> if
the long double type is supported.

=item C<d_longlong>

From F<d_longlong.U>:

This variable conditionally defines C<HAS_LONG_LONG> if
the long long type is supported.

=item C<d_lseekproto>

From F<d_lseekproto.U>:

This variable conditionally defines the C<HAS_LSEEK_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the lseek() function.  Otherwise, it is
up to the program to supply one.

=item C<d_lstat>

From F<d_lstat.U>:

This variable conditionally defines C<HAS_LSTAT> if lstat() is
available to do file stats on symbolic links.

=item C<d_madvise>

From F<d_madvise.U>:

This variable conditionally defines C<HAS_MADVISE> if madvise() is
available to map a file into memory.

=item C<d_malloc_good_size>

From F<d_malloc_size.U>:

This symbol, if defined, indicates that the malloc_good_size
routine is available for use.

=item C<d_malloc_size>

From F<d_malloc_size.U>:

This symbol, if defined, indicates that the malloc_size
routine is available for use.

=item C<d_mblen>

From F<d_mblen.U>:

This variable conditionally defines the C<HAS_MBLEN> symbol, which
indicates to the C program that the mblen() routine is available
to find the number of bytes in a multibye character.

=item C<d_mbstowcs>

From F<d_mbstowcs.U>:

This variable conditionally defines the C<HAS_MBSTOWCS> symbol, which
indicates to the C program that the mbstowcs() routine is available
to convert a multibyte string into a wide character string.

=item C<d_mbtowc>

From F<d_mbtowc.U>:

This variable conditionally defines the C<HAS_MBTOWC> symbol, which
indicates to the C program that the mbtowc() routine is available
to convert multibyte to a wide character.

=item C<d_memchr>

From F<d_memchr.U>:

This variable conditionally defines the C<HAS_MEMCHR> symbol, which
indicates to the C program that the memchr() routine is available
to locate characters within a C string.

=item C<d_memcmp>

From F<d_memcmp.U>:

This variable conditionally defines the C<HAS_MEMCMP> symbol, which
indicates to the C program that the memcmp() routine is available
to compare blocks of memory.

=item C<d_memcpy>

From F<d_memcpy.U>:

This variable conditionally defines the C<HAS_MEMCPY> symbol, which
indicates to the C program that the memcpy() routine is available
to copy blocks of memory.

=item C<d_memmove>

From F<d_memmove.U>:

This variable conditionally defines the C<HAS_MEMMOVE> symbol, which
indicates to the C program that the memmove() routine is available
to copy potentially overlapping blocks of memory.

=item C<d_memset>

From F<d_memset.U>:

This variable conditionally defines the C<HAS_MEMSET> symbol, which
indicates to the C program that the memset() routine is available
to set blocks of memory.

=item C<d_mkdir>

From F<d_mkdir.U>:

This variable conditionally defines the C<HAS_MKDIR> symbol, which
indicates to the C program that the mkdir() routine is available
to create F<directories.>.

=item C<d_mkdtemp>

From F<d_mkdtemp.U>:

This variable conditionally defines the C<HAS_MKDTEMP> symbol, which
indicates to the C program that the mkdtemp() routine is available
to exclusively create a uniquely named temporary directory.

=item C<d_mkfifo>

From F<d_mkfifo.U>:

This variable conditionally defines the C<HAS_MKFIFO> symbol, which
indicates to the C program that the mkfifo() routine is available.

=item C<d_mkstemp>

From F<d_mkstemp.U>:

This variable conditionally defines the C<HAS_MKSTEMP> symbol, which
indicates to the C program that the mkstemp() routine is available
to exclusively create and open a uniquely named temporary file.

=item C<d_mkstemps>

From F<d_mkstemps.U>:

This variable conditionally defines the C<HAS_MKSTEMPS> symbol, which
indicates to the C program that the mkstemps() routine is available
to exclusively create and open a uniquely named (with a suffix)
temporary file.

=item C<d_mktime>

From F<d_mktime.U>:

This variable conditionally defines the C<HAS_MKTIME> symbol, which
indicates to the C program that the mktime() routine is available.

=item C<d_mktime64>

From F<d_timefuncs64.U>:

This variable conditionally defines the HAS_MKTIME64 symbol, which
indicates to the C program that the mktime64 () routine is available.

=item C<d_mmap>

From F<d_mmap.U>:

This variable conditionally defines C<HAS_MMAP> if mmap() is
available to map a file into memory.

=item C<d_modfl>

From F<d_modfl.U>:

This variable conditionally defines the C<HAS_MODFL> symbol, which
indicates to the C program that the modfl() routine is available.

=item C<d_modfl_pow32_bug>

From F<d_modfl.U>:

This variable conditionally defines the HAS_MODFL_POW32_BUG symbol,
which indicates that modfl() is broken for long doubles >= pow(2, 32).
For example from 4294967303.150000 one would get 4294967302.000000
and 1.150000.  The bug has been seen in certain versions of glibc,
release 2.2.2 is known to be okay.

=item C<d_modflproto>

From F<d_modfl.U>:

This symbol, if defined, indicates that the system provides
a prototype for the modfl() function.  Otherwise, it is up
to the program to supply one.  C99 says it should be
long double modfl(long double, long double *);

=item C<d_mprotect>

From F<d_mprotect.U>:

This variable conditionally defines C<HAS_MPROTECT> if mprotect() is
available to modify the access protection of a memory mapped file.

=item C<d_msg>

From F<d_msg.U>:

This variable conditionally defines the C<HAS_MSG> symbol, which
indicates that the entire msg*(2) library is present.

=item C<d_msg_ctrunc>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_MSG_CTRUNC> symbol,
which indicates that the C<MSG_CTRUNC> is available.  #ifdef is
not enough because it may be an enum, glibc has been known to do this.

=item C<d_msg_dontroute>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_MSG_DONTROUTE> symbol,
which indicates that the C<MSG_DONTROUTE> is available.  #ifdef is
not enough because it may be an enum, glibc has been known to do this.

=item C<d_msg_oob>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_MSG_OOB> symbol,
which indicates that the C<MSG_OOB> is available.  #ifdef is
not enough because it may be an enum, glibc has been known to do this.

=item C<d_msg_peek>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_MSG_PEEK> symbol,
which indicates that the C<MSG_PEEK> is available.  #ifdef is
not enough because it may be an enum, glibc has been known to do this.

=item C<d_msg_proxy>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_MSG_PROXY> symbol,
which indicates that the C<MSG_PROXY> is available.  #ifdef is
not enough because it may be an enum, glibc has been known to do this.

=item C<d_msgctl>

From F<d_msgctl.U>:

This variable conditionally defines the C<HAS_MSGCTL> symbol, which
indicates to the C program that the msgctl() routine is available.

=item C<d_msgget>

From F<d_msgget.U>:

This variable conditionally defines the C<HAS_MSGGET> symbol, which
indicates to the C program that the msgget() routine is available.

=item C<d_msghdr_s>

From F<d_msghdr_s.U>:

This variable conditionally defines the C<HAS_STRUCT_MSGHDR> symbol,
which indicates that the struct msghdr is supported.

=item C<d_msgrcv>

From F<d_msgrcv.U>:

This variable conditionally defines the C<HAS_MSGRCV> symbol, which
indicates to the C program that the msgrcv() routine is available.

=item C<d_msgsnd>

From F<d_msgsnd.U>:

This variable conditionally defines the C<HAS_MSGSND> symbol, which
indicates to the C program that the msgsnd() routine is available.

=item C<d_msync>

From F<d_msync.U>:

This variable conditionally defines C<HAS_MSYNC> if msync() is
available to synchronize a mapped file.

=item C<d_munmap>

From F<d_munmap.U>:

This variable conditionally defines C<HAS_MUNMAP> if munmap() is
available to unmap a region mapped by mmap().

=item C<d_mymalloc>

From F<mallocsrc.U>:

This variable conditionally defines C<MYMALLOC> in case other parts
of the source want to take special action if C<MYMALLOC> is used.
This may include different sorts of profiling or error detection.

=item C<d_ndbm>

From F<i_ndbm.U>:

This variable conditionally defines the C<HAS_NDBM> symbol, which
indicates that both the F<ndbm.h> include file and an appropriate ndbm
library exist.  Consult the different i_*ndbm variables
to find out the actual include location.  Sometimes, a system has the
header file but not the library.  This variable will only be set if
the system has both.

=item C<d_ndbm_h_uses_prototypes>

From F<i_ndbm.U>:

This variable conditionally defines the C<NDBM_H_USES_PROTOTYPES> symbol,
which indicates that the F<ndbm.h> include file uses real C<ANSI> C
prototypes instead of K&R style function declarations. K&R style
declarations are unsupported in C++, so the include file requires
special handling when using a C++ compiler and this variable is
undefined. Consult the different d_*ndbm_h_uses_prototypes variables
to get the same information for alternative F<ndbm.h> include files.

=item C<d_nice>

From F<d_nice.U>:

This variable conditionally defines the C<HAS_NICE> symbol, which
indicates to the C program that the nice() routine is available.

=item C<d_nl_langinfo>

From F<d_nl_langinfo.U>:

This variable conditionally defines the C<HAS_NL_LANGINFO> symbol, which
indicates to the C program that the nl_langinfo() routine is available.

=item C<d_nv_preserves_uv>

From F<perlxv.U>:

This variable indicates whether a variable of type nvtype
can preserve all the bits a variable of type uvtype.

=item C<d_nv_zero_is_allbits_zero>

From F<perlxv.U>:

This variable indicates whether a variable of type nvtype
stores 0.0 in memory as all bits zero.

=item C<d_off64_t>

From F<d_off64_t.U>:

This symbol will be defined if the C compiler supports off64_t.

=item C<d_old_pthread_create_joinable>

From F<d_pthrattrj.U>:

This variable conditionally defines pthread_create_joinable.
undef if F<pthread.h> defines C<PTHREAD_CREATE_JOINABLE>.

=item C<d_oldpthreads>

From F<usethreads.U>:

This variable conditionally defines the C<OLD_PTHREADS_API> symbol,
and indicates that Perl should be built to use the old
draft C<POSIX> threads C<API>.  This is only potentially meaningful if
usethreads is set.

=item C<d_oldsock>

From F<d_socket.U>:

This variable conditionally defines the C<OLDSOCKET> symbol, which
indicates that the C<BSD> socket interface is based on 4.1c and not 4.2.

=item C<d_open3>

From F<d_open3.U>:

This variable conditionally defines the HAS_OPEN3 manifest constant,
which indicates to the C program that the 3 argument version of
the open(2) function is available.

=item C<d_pathconf>

From F<d_pathconf.U>:

This variable conditionally defines the C<HAS_PATHCONF> symbol, which
indicates to the C program that the pathconf() routine is available
to determine file-system related limits and options associated
with a given filename.

=item C<d_pause>

From F<d_pause.U>:

This variable conditionally defines the C<HAS_PAUSE> symbol, which
indicates to the C program that the pause() routine is available
to suspend a process until a signal is received.

=item C<d_perl_otherlibdirs>

From F<otherlibdirs.U>:

This variable conditionally defines C<PERL_OTHERLIBDIRS>, which
contains a colon-separated set of paths for the perl binary to
include in @C<INC>.  See also otherlibdirs.

=item C<d_phostname>

From F<d_gethname.U>:

This variable conditionally defines the C<HAS_PHOSTNAME> symbol, which
contains the shell command which, when fed to popen(), may be
used to derive the host name.

=item C<d_pipe>

From F<d_pipe.U>:

This variable conditionally defines the C<HAS_PIPE> symbol, which
indicates to the C program that the pipe() routine is available
to create an inter-process channel.

=item C<d_poll>

From F<d_poll.U>:

This variable conditionally defines the C<HAS_POLL> symbol, which
indicates to the C program that the poll() routine is available
to poll active file descriptors.

=item C<d_portable>

From F<d_portable.U>:

This variable conditionally defines the C<PORTABLE> symbol, which
indicates to the C program that it should not assume that it is
running on the machine it was compiled on.

=item C<d_prctl>

From F<d_prctl.U>:

This variable conditionally defines the C<HAS_PRCTL> symbol, which
indicates to the C program that the prctl() routine is available.

=item C<d_prctl_set_name>

From F<d_prctl.U>:

This variable conditionally defines the C<HAS_PRCTL_SET_NAME> symbol,
which indicates to the C program that the prctl() routine supports
the C<PR_SET_NAME> option.

=item C<d_PRId64>

From F<quadfio.U>:

This variable conditionally defines the PERL_PRId64 symbol, which
indicates that stdio has a symbol to print 64-bit decimal numbers.

=item C<d_PRIeldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to print long doubles.

=item C<d_PRIEUldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to print long doubles.
The C<U> in the name is to separate this from d_PRIeldbl so that even
case-blind systems can see the difference.

=item C<d_PRIfldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to print long doubles.

=item C<d_PRIFUldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to print long doubles.
The C<U> in the name is to separate this from d_PRIfldbl so that even
case-blind systems can see the difference.

=item C<d_PRIgldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to print long doubles.

=item C<d_PRIGUldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to print long doubles.
The C<U> in the name is to separate this from d_PRIgldbl so that even
case-blind systems can see the difference.

=item C<d_PRIi64>

From F<quadfio.U>:

This variable conditionally defines the PERL_PRIi64 symbol, which
indicates that stdio has a symbol to print 64-bit decimal numbers.

=item C<d_printf_format_null>

From F<d_attribut.U>:

This variable conditionally defines C<PRINTF_FORMAT_NULL_OK>, which
indicates the C compiler allows printf-like formats to be null.

=item C<d_PRIo64>

From F<quadfio.U>:

This variable conditionally defines the PERL_PRIo64 symbol, which
indicates that stdio has a symbol to print 64-bit octal numbers.

=item C<d_PRIu64>

From F<quadfio.U>:

This variable conditionally defines the PERL_PRIu64 symbol, which
indicates that stdio has a symbol to print 64-bit unsigned decimal
numbers.

=item C<d_PRIx64>

From F<quadfio.U>:

This variable conditionally defines the PERL_PRIx64 symbol, which
indicates that stdio has a symbol to print 64-bit hexadecimal numbers.

=item C<d_PRIXU64>

From F<quadfio.U>:

This variable conditionally defines the PERL_PRIXU64 symbol, which
indicates that stdio has a symbol to print 64-bit hExADECimAl numbers.
The C<U> in the name is to separate this from d_PRIx64 so that even
case-blind systems can see the difference.

=item C<d_procselfexe>

From F<d_procselfexe.U>:

Defined if $procselfexe is symlink to the absolute
pathname of the executing program.

=item C<d_pseudofork>

From F<d_vfork.U>:

This variable conditionally defines the C<HAS_PSEUDOFORK> symbol,
which indicates that an emulation of the fork routine is available.

=item C<d_pthread_atfork>

From F<d_pthread_atfork.U>:

This variable conditionally defines the C<HAS_PTHREAD_ATFORK> symbol,
which indicates to the C program that the pthread_atfork()
routine is available.

=item C<d_pthread_attr_setscope>

From F<d_pthread_attr_ss.U>:

This variable conditionally defines C<HAS_PTHREAD_ATTR_SETSCOPE> if
pthread_attr_setscope() is available to set the contention scope
attribute of a thread attribute object.

=item C<d_pthread_yield>

From F<d_pthread_y.U>:

This variable conditionally defines the C<HAS_PTHREAD_YIELD>
symbol if the pthread_yield routine is available to yield
the execution of the current thread.

=item C<d_pwage>

From F<i_pwd.U>:

This variable conditionally defines C<PWAGE>, which indicates
that struct passwd contains pw_age.

=item C<d_pwchange>

From F<i_pwd.U>:

This variable conditionally defines C<PWCHANGE>, which indicates
that struct passwd contains pw_change.

=item C<d_pwclass>

From F<i_pwd.U>:

This variable conditionally defines C<PWCLASS>, which indicates
that struct passwd contains pw_class.

=item C<d_pwcomment>

From F<i_pwd.U>:

This variable conditionally defines C<PWCOMMENT>, which indicates
that struct passwd contains pw_comment.

=item C<d_pwexpire>

From F<i_pwd.U>:

This variable conditionally defines C<PWEXPIRE>, which indicates
that struct passwd contains pw_expire.

=item C<d_pwgecos>

From F<i_pwd.U>:

This variable conditionally defines C<PWGECOS>, which indicates
that struct passwd contains pw_gecos.

=item C<d_pwpasswd>

From F<i_pwd.U>:

This variable conditionally defines C<PWPASSWD>, which indicates
that struct passwd contains pw_passwd.

=item C<d_pwquota>

From F<i_pwd.U>:

This variable conditionally defines C<PWQUOTA>, which indicates
that struct passwd contains pw_quota.

=item C<d_qgcvt>

From F<d_qgcvt.U>:

This variable conditionally defines the C<HAS_QGCVT> symbol, which
indicates to the C program that the qgcvt() routine is available.

=item C<d_quad>

From F<quadtype.U>:

This variable, if defined, tells that there's a 64-bit integer type,
quadtype.

=item C<d_random_r>

From F<d_random_r.U>:

This variable conditionally defines the C<HAS_RANDOM_R> symbol,
which indicates to the C program that the random_r()
routine is available.

=item C<d_readdir>

From F<d_readdir.U>:

This variable conditionally defines C<HAS_READDIR> if readdir() is
available to read directory entries.

=item C<d_readdir64_r>

From F<d_readdir64_r.U>:

This variable conditionally defines the HAS_READDIR64_R symbol,
which indicates to the C program that the readdir64_r()
routine is available.

=item C<d_readdir_r>

From F<d_readdir_r.U>:

This variable conditionally defines the C<HAS_READDIR_R> symbol,
which indicates to the C program that the readdir_r()
routine is available.

=item C<d_readlink>

From F<d_readlink.U>:

This variable conditionally defines the C<HAS_READLINK> symbol, which
indicates to the C program that the readlink() routine is available
to read the value of a symbolic link.

=item C<d_readv>

From F<d_readv.U>:

This variable conditionally defines the C<HAS_READV> symbol, which
indicates to the C program that the readv() routine is available.

=item C<d_recvmsg>

From F<d_recvmsg.U>:

This variable conditionally defines the C<HAS_RECVMSG> symbol, which
indicates to the C program that the recvmsg() routine is available.

=item C<d_rename>

From F<d_rename.U>:

This variable conditionally defines the C<HAS_RENAME> symbol, which
indicates to the C program that the rename() routine is available
to rename files.

=item C<d_rewinddir>

From F<d_readdir.U>:

This variable conditionally defines C<HAS_REWINDDIR> if rewinddir() is
available.

=item C<d_rmdir>

From F<d_rmdir.U>:

This variable conditionally defines C<HAS_RMDIR> if rmdir() is
available to remove directories.

=item C<d_safebcpy>

From F<d_safebcpy.U>:

This variable conditionally defines the C<HAS_SAFE_BCOPY> symbol if
the bcopy() routine can do overlapping copies.  Normally, you
should probably use memmove().

=item C<d_safemcpy>

From F<d_safemcpy.U>:

This variable conditionally defines the C<HAS_SAFE_MEMCPY> symbol if
the memcpy() routine can do overlapping copies.
For overlapping copies, memmove() should be used, if available.

=item C<d_sanemcmp>

From F<d_sanemcmp.U>:

This variable conditionally defines the C<HAS_SANE_MEMCMP> symbol if
the memcpy() routine is available and can be used to compare relative
magnitudes of chars with their high bits set.

=item C<d_sbrkproto>

From F<d_sbrkproto.U>:

This variable conditionally defines the C<HAS_SBRK_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the sbrk() function.  Otherwise, it is
up to the program to supply one.

=item C<d_scalbnl>

From F<d_scalbnl.U>:

This variable conditionally defines the C<HAS_SCALBNL> symbol, which
indicates to the C program that the scalbnl() routine is available.
If ilogbl is also present we can emulate frexpl.

=item C<d_sched_yield>

From F<d_pthread_y.U>:

This variable conditionally defines the C<HAS_SCHED_YIELD>
symbol if the sched_yield routine is available to yield
the execution of the current thread.

=item C<d_scm_rights>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_SCM_RIGHTS> symbol,
which indicates that the C<SCM_RIGHTS> is available.  #ifdef is
not enough because it may be an enum, glibc has been known to do this.

=item C<d_SCNfldbl>

From F<longdblfio.U>:

This variable conditionally defines the PERL_PRIfldbl symbol, which
indicates that stdio has a symbol to scan long doubles.

=item C<d_seekdir>

From F<d_readdir.U>:

This variable conditionally defines C<HAS_SEEKDIR> if seekdir() is
available.

=item C<d_select>

From F<d_select.U>:

This variable conditionally defines C<HAS_SELECT> if select() is
available to select active file descriptors. A <sys/time.h>
inclusion may be necessary for the timeout field.

=item C<d_sem>

From F<d_sem.U>:

This variable conditionally defines the C<HAS_SEM> symbol, which
indicates that the entire sem*(2) library is present.

=item C<d_semctl>

From F<d_semctl.U>:

This variable conditionally defines the C<HAS_SEMCTL> symbol, which
indicates to the C program that the semctl() routine is available.

=item C<d_semctl_semid_ds>

From F<d_union_semun.U>:

This variable conditionally defines C<USE_SEMCTL_SEMID_DS>, which
indicates that struct semid_ds * is to be used for semctl C<IPC_STAT>.

=item C<d_semctl_semun>

From F<d_union_semun.U>:

This variable conditionally defines C<USE_SEMCTL_SEMUN>, which
indicates that union semun is to be used for semctl C<IPC_STAT>.

=item C<d_semget>

From F<d_semget.U>:

This variable conditionally defines the C<HAS_SEMGET> symbol, which
indicates to the C program that the semget() routine is available.

=item C<d_semop>

From F<d_semop.U>:

This variable conditionally defines the C<HAS_SEMOP> symbol, which
indicates to the C program that the semop() routine is available.

=item C<d_sendmsg>

From F<d_sendmsg.U>:

This variable conditionally defines the C<HAS_SENDMSG> symbol, which
indicates to the C program that the sendmsg() routine is available.

=item C<d_setegid>

From F<d_setegid.U>:

This variable conditionally defines the C<HAS_SETEGID> symbol, which
indicates to the C program that the setegid() routine is available
to change the effective gid of the current program.

=item C<d_seteuid>

From F<d_seteuid.U>:

This variable conditionally defines the C<HAS_SETEUID> symbol, which
indicates to the C program that the seteuid() routine is available
to change the effective uid of the current program.

=item C<d_setgrent>

From F<d_setgrent.U>:

This variable conditionally defines the C<HAS_SETGRENT> symbol, which
indicates to the C program that the setgrent() routine is available
for initializing sequential access to the group database.

=item C<d_setgrent_r>

From F<d_setgrent_r.U>:

This variable conditionally defines the C<HAS_SETGRENT_R> symbol,
which indicates to the C program that the setgrent_r()
routine is available.

=item C<d_setgrps>

From F<d_setgrps.U>:

This variable conditionally defines the C<HAS_SETGROUPS> symbol, which
indicates to the C program that the setgroups() routine is available
to set the list of process groups.

=item C<d_sethent>

From F<d_sethent.U>:

This variable conditionally defines C<HAS_SETHOSTENT> if sethostent() is
available.

=item C<d_sethostent_r>

From F<d_sethostent_r.U>:

This variable conditionally defines the C<HAS_SETHOSTENT_R> symbol,
which indicates to the C program that the sethostent_r()
routine is available.

=item C<d_setitimer>

From F<d_setitimer.U>:

This variable conditionally defines the C<HAS_SETITIMER> symbol, which
indicates to the C program that the setitimer() routine is available.

=item C<d_setlinebuf>

From F<d_setlnbuf.U>:

This variable conditionally defines the C<HAS_SETLINEBUF> symbol, which
indicates to the C program that the setlinebuf() routine is available
to change stderr or stdout from block-buffered or unbuffered to a
line-buffered mode.

=item C<d_setlocale>

From F<d_setlocale.U>:

This variable conditionally defines C<HAS_SETLOCALE> if setlocale() is
available to handle locale-specific ctype implementations.

=item C<d_setlocale_r>

From F<d_setlocale_r.U>:

This variable conditionally defines the C<HAS_SETLOCALE_R> symbol,
which indicates to the C program that the setlocale_r()
routine is available.

=item C<d_setnent>

From F<d_setnent.U>:

This variable conditionally defines C<HAS_SETNETENT> if setnetent() is
available.

=item C<d_setnetent_r>

From F<d_setnetent_r.U>:

This variable conditionally defines the C<HAS_SETNETENT_R> symbol,
which indicates to the C program that the setnetent_r()
routine is available.

=item C<d_setpent>

From F<d_setpent.U>:

This variable conditionally defines C<HAS_SETPROTOENT> if setprotoent() is
available.

=item C<d_setpgid>

From F<d_setpgid.U>:

This variable conditionally defines the C<HAS_SETPGID> symbol if the
setpgid(pid, gpid) function is available to set process group C<ID>.

=item C<d_setpgrp>

From F<d_setpgrp.U>:

This variable conditionally defines C<HAS_SETPGRP> if setpgrp() is
available to set the current process group.

=item C<d_setpgrp2>

From F<d_setpgrp2.U>:

This variable conditionally defines the HAS_SETPGRP2 symbol, which
indicates to the C program that the setpgrp2() (as in F<DG/C<UX>>) routine
is available to set the current process group.

=item C<d_setprior>

From F<d_setprior.U>:

This variable conditionally defines C<HAS_SETPRIORITY> if setpriority()
is available to set a process's priority.

=item C<d_setproctitle>

From F<d_setproctitle.U>:

This variable conditionally defines the C<HAS_SETPROCTITLE> symbol,
which indicates to the C program that the setproctitle() routine
is available.

=item C<d_setprotoent_r>

From F<d_setprotoent_r.U>:

This variable conditionally defines the C<HAS_SETPROTOENT_R> symbol,
which indicates to the C program that the setprotoent_r()
routine is available.

=item C<d_setpwent>

From F<d_setpwent.U>:

This variable conditionally defines the C<HAS_SETPWENT> symbol, which
indicates to the C program that the setpwent() routine is available
for initializing sequential access to the passwd database.

=item C<d_setpwent_r>

From F<d_setpwent_r.U>:

This variable conditionally defines the C<HAS_SETPWENT_R> symbol,
which indicates to the C program that the setpwent_r()
routine is available.

=item C<d_setregid>

From F<d_setregid.U>:

This variable conditionally defines C<HAS_SETREGID> if setregid() is
available to change the real and effective gid of the current
process.

=item C<d_setresgid>

From F<d_setregid.U>:

This variable conditionally defines C<HAS_SETRESGID> if setresgid() is
available to change the real, effective and saved gid of the current
process.

=item C<d_setresuid>

From F<d_setreuid.U>:

This variable conditionally defines C<HAS_SETREUID> if setresuid() is
available to change the real, effective and saved uid of the current
process.

=item C<d_setreuid>

From F<d_setreuid.U>:

This variable conditionally defines C<HAS_SETREUID> if setreuid() is
available to change the real and effective uid of the current
process.

=item C<d_setrgid>

From F<d_setrgid.U>:

This variable conditionally defines the C<HAS_SETRGID> symbol, which
indicates to the C program that the setrgid() routine is available
to change the real gid of the current program.

=item C<d_setruid>

From F<d_setruid.U>:

This variable conditionally defines the C<HAS_SETRUID> symbol, which
indicates to the C program that the setruid() routine is available
to change the real uid of the current program.

=item C<d_setsent>

From F<d_setsent.U>:

This variable conditionally defines C<HAS_SETSERVENT> if setservent() is
available.

=item C<d_setservent_r>

From F<d_setservent_r.U>:

This variable conditionally defines the C<HAS_SETSERVENT_R> symbol,
which indicates to the C program that the setservent_r()
routine is available.

=item C<d_setsid>

From F<d_setsid.U>:

This variable conditionally defines C<HAS_SETSID> if setsid() is
available to set the process group C<ID>.

=item C<d_setvbuf>

From F<d_setvbuf.U>:

This variable conditionally defines the C<HAS_SETVBUF> symbol, which
indicates to the C program that the setvbuf() routine is available
to change buffering on an open stdio stream.

=item C<d_shm>

From F<d_shm.U>:

This variable conditionally defines the C<HAS_SHM> symbol, which
indicates that the entire shm*(2) library is present.

=item C<d_shmat>

From F<d_shmat.U>:

This variable conditionally defines the C<HAS_SHMAT> symbol, which
indicates to the C program that the shmat() routine is available.

=item C<d_shmatprototype>

From F<d_shmat.U>:

This variable conditionally defines the C<HAS_SHMAT_PROTOTYPE>
symbol, which indicates that F<sys/shm.h> has a prototype for
shmat.

=item C<d_shmctl>

From F<d_shmctl.U>:

This variable conditionally defines the C<HAS_SHMCTL> symbol, which
indicates to the C program that the shmctl() routine is available.

=item C<d_shmdt>

From F<d_shmdt.U>:

This variable conditionally defines the C<HAS_SHMDT> symbol, which
indicates to the C program that the shmdt() routine is available.

=item C<d_shmget>

From F<d_shmget.U>:

This variable conditionally defines the C<HAS_SHMGET> symbol, which
indicates to the C program that the shmget() routine is available.

=item C<d_sigaction>

From F<d_sigaction.U>:

This variable conditionally defines the C<HAS_SIGACTION> symbol, which
indicates that the Vr4 sigaction() routine is available.

=item C<d_signbit>

From F<d_signbit.U>:

This variable conditionally defines the C<HAS_SIGNBIT> symbol, which
indicates to the C program that the signbit() routine is available
and safe to use with perl's intern C<NV> type.

=item C<d_sigprocmask>

From F<d_sigprocmask.U>:

This variable conditionally defines C<HAS_SIGPROCMASK>
if sigprocmask() is available to examine or change the signal mask
of the calling process.

=item C<d_sigsetjmp>

From F<d_sigsetjmp.U>:

This variable conditionally defines the C<HAS_SIGSETJMP> symbol,
which indicates that the sigsetjmp() routine is available to
call setjmp() and optionally save the process's signal mask.

=item C<d_sin6_scope_id>

From F<d_socket.U>:

This variable conditionally defines the HAS_SIN6_SCOPE_ID symbol, which
indicates that a struct sockaddr_in6 structure has the sin6_scope_id
member.

=item C<d_sitearch>

From F<sitearch.U>:

This variable conditionally defines C<SITEARCH> to hold the pathname
of architecture-dependent library files for $package.  If
$sitearch is the same as $archlib, then this is set to undef.

=item C<d_snprintf>

From F<d_snprintf.U>:

This variable conditionally defines the C<HAS_SNPRINTF> symbol, which
indicates to the C program that the snprintf () library function
is available.

=item C<d_sockaddr_in6>

From F<d_socket.U>:

This variable conditionally defines the HAS_SOCKADDR_IN6 symbol, which
indicates the availability of a struct sockaddr_in6.

=item C<d_sockaddr_sa_len>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_SOCKADDR_SA_LEN> symbol,
which indicates that a struct sockaddr structure has the sa_len
member.

=item C<d_sockatmark>

From F<d_sockatmark.U>:

This variable conditionally defines the C<HAS_SOCKATMARK> symbol, which
indicates to the C program that the sockatmark() routine is available.

=item C<d_sockatmarkproto>

From F<d_sockatmarkproto.U>:

This variable conditionally defines the C<HAS_SOCKATMARK_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the sockatmark() function.  Otherwise, it is
up to the program to supply one.

=item C<d_socket>

From F<d_socket.U>:

This variable conditionally defines C<HAS_SOCKET>, which indicates
that the C<BSD> socket interface is supported.

=item C<d_socklen_t>

From F<d_socklen_t.U>:

This symbol will be defined if the C compiler supports socklen_t.

=item C<d_sockpair>

From F<d_socket.U>:

This variable conditionally defines the C<HAS_SOCKETPAIR> symbol, which
indicates that the C<BSD> socketpair() is supported.

=item C<d_socks5_init>

From F<d_socks5_init.U>:

This variable conditionally defines the HAS_SOCKS5_INIT symbol, which
indicates to the C program that the socks5_init() routine is available.

=item C<d_sprintf_returns_strlen>

From F<d_sprintf_len.U>:

This variable defines whether sprintf returns the length of the string
(as per the C<ANSI> spec). Some C libraries retain compatibility with
pre-C<ANSI> C and return a pointer to the passed in buffer; for these
this variable will be undef.

=item C<d_sqrtl>

From F<d_sqrtl.U>:

This variable conditionally defines the C<HAS_SQRTL> symbol, which
indicates to the C program that the sqrtl() routine is available.

=item C<d_srand48_r>

From F<d_srand48_r.U>:

This variable conditionally defines the HAS_SRAND48_R symbol,
which indicates to the C program that the srand48_r()
routine is available.

=item C<d_srandom_r>

From F<d_srandom_r.U>:

This variable conditionally defines the C<HAS_SRANDOM_R> symbol,
which indicates to the C program that the srandom_r()
routine is available.

=item C<d_sresgproto>

From F<d_sresgproto.U>:

This variable conditionally defines the C<HAS_SETRESGID_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the setresgid() function.  Otherwise, it is
up to the program to supply one.

=item C<d_sresuproto>

From F<d_sresuproto.U>:

This variable conditionally defines the C<HAS_SETRESUID_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the setresuid() function.  Otherwise, it is
up to the program to supply one.

=item C<d_statblks>

From F<d_statblks.U>:

This variable conditionally defines C<USE_STAT_BLOCKS>
if this system has a stat structure declaring
st_blksize and st_blocks.

=item C<d_statfs_f_flags>

From F<d_statfs_f_flags.U>:

This variable conditionally defines the C<HAS_STRUCT_STATFS_F_FLAGS>
symbol, which indicates to struct statfs from has f_flags member.
This kind of struct statfs is coming from F<sys/mount.h> (C<BSD>),
not from F<sys/statfs.h> (C<SYSV>).

=item C<d_statfs_s>

From F<d_statfs_s.U>:

This variable conditionally defines the C<HAS_STRUCT_STATFS> symbol,
which indicates that the struct statfs is supported.

=item C<d_static_inline>

From F<d_static_inline.U>:

This variable conditionally defines the C<HAS_STATIC_INLINE> symbol,
which indicates that the C compiler supports C99-style static
inline.  That is, the function can't be called from another
translation unit.

=item C<d_statvfs>

From F<d_statvfs.U>:

This variable conditionally defines the C<HAS_STATVFS> symbol, which
indicates to the C program that the statvfs() routine is available.

=item C<d_stdio_cnt_lval>

From F<d_stdstdio.U>:

This variable conditionally defines C<STDIO_CNT_LVALUE> if the
C<FILE_cnt> macro can be used as an lvalue.

=item C<d_stdio_ptr_lval>

From F<d_stdstdio.U>:

This variable conditionally defines C<STDIO_PTR_LVALUE> if the
C<FILE_ptr> macro can be used as an lvalue.

=item C<d_stdio_ptr_lval_nochange_cnt>

From F<d_stdstdio.U>:

This symbol is defined if using the C<FILE_ptr> macro as an lvalue
to increase the pointer by n leaves File_cnt(fp) unchanged.

=item C<d_stdio_ptr_lval_sets_cnt>

From F<d_stdstdio.U>:

This symbol is defined if using the C<FILE_ptr> macro as an lvalue
to increase the pointer by n has the side effect of decreasing the
value of File_cnt(fp) by n.

=item C<d_stdio_stream_array>

From F<stdio_streams.U>:

This variable tells whether there is an array holding
the stdio streams.

=item C<d_stdiobase>

From F<d_stdstdio.U>:

This variable conditionally defines C<USE_STDIO_BASE> if this system
has a C<FILE> structure declaring a usable _base field (or equivalent)
in F<stdio.h>.

=item C<d_stdstdio>

From F<d_stdstdio.U>:

This variable conditionally defines C<USE_STDIO_PTR> if this system
has a C<FILE> structure declaring usable _ptr and _cnt fields (or
equivalent) in F<stdio.h>.

=item C<d_strchr>

From F<d_strchr.U>:

This variable conditionally defines C<HAS_STRCHR> if strchr() and
strrchr() are available for string searching.

=item C<d_strcoll>

From F<d_strcoll.U>:

This variable conditionally defines C<HAS_STRCOLL> if strcoll() is
available to compare strings using collating information.

=item C<d_strctcpy>

From F<d_strctcpy.U>:

This variable conditionally defines the C<USE_STRUCT_COPY> symbol, which
indicates to the C program that this C compiler knows how to copy
structures.

=item C<d_strerrm>

From F<d_strerror.U>:

This variable holds what Strerror is defined as to translate an error
code condition into an error message string. It could be C<strerror>
or a more C<complex> macro emulating strerror with sys_errlist[], or the
C<unknown> string when both strerror and sys_errlist are missing.

=item C<d_strerror>

From F<d_strerror.U>:

This variable conditionally defines C<HAS_STRERROR> if strerror() is
available to translate error numbers to strings.

=item C<d_strerror_r>

From F<d_strerror_r.U>:

This variable conditionally defines the C<HAS_STRERROR_R> symbol,
which indicates to the C program that the strerror_r()
routine is available.

=item C<d_strftime>

From F<d_strftime.U>:

This variable conditionally defines the C<HAS_STRFTIME> symbol, which
indicates to the C program that the strftime() routine is available.

=item C<d_strlcat>

From F<d_strlcat.U>:

This variable conditionally defines the C<HAS_STRLCAT> symbol, which
indicates to the C program that the strlcat () routine is available.

=item C<d_strlcpy>

From F<d_strlcpy.U>:

This variable conditionally defines the C<HAS_STRLCPY> symbol, which
indicates to the C program that the strlcpy () routine is available.

=item C<d_strtod>

From F<d_strtod.U>:

This variable conditionally defines the C<HAS_STRTOD> symbol, which
indicates to the C program that the strtod() routine is available
to provide better numeric string conversion than atof().

=item C<d_strtol>

From F<d_strtol.U>:

This variable conditionally defines the C<HAS_STRTOL> symbol, which
indicates to the C program that the strtol() routine is available
to provide better numeric string conversion than atoi() and friends.

=item C<d_strtold>

From F<d_strtold.U>:

This variable conditionally defines the C<HAS_STRTOLD> symbol, which
indicates to the C program that the strtold() routine is available.

=item C<d_strtoll>

From F<d_strtoll.U>:

This variable conditionally defines the C<HAS_STRTOLL> symbol, which
indicates to the C program that the strtoll() routine is available.

=item C<d_strtoq>

From F<d_strtoq.U>:

This variable conditionally defines the C<HAS_STRTOQ> symbol, which
indicates to the C program that the strtoq() routine is available.

=item C<d_strtoul>

From F<d_strtoul.U>:

This variable conditionally defines the C<HAS_STRTOUL> symbol, which
indicates to the C program that the strtoul() routine is available
to provide conversion of strings to unsigned long.

=item C<d_strtoull>

From F<d_strtoull.U>:

This variable conditionally defines the C<HAS_STRTOULL> symbol, which
indicates to the C program that the strtoull() routine is available.

=item C<d_strtouq>

From F<d_strtouq.U>:

This variable conditionally defines the C<HAS_STRTOUQ> symbol, which
indicates to the C program that the strtouq() routine is available.

=item C<d_strxfrm>

From F<d_strxfrm.U>:

This variable conditionally defines C<HAS_STRXFRM> if strxfrm() is
available to transform strings.

=item C<d_suidsafe>

From F<d_dosuid.U>:

This variable conditionally defines C<SETUID_SCRIPTS_ARE_SECURE_NOW>
if setuid scripts can be secure.  This test looks in F</dev/fd/>.

=item C<d_symlink>

From F<d_symlink.U>:

This variable conditionally defines the C<HAS_SYMLINK> symbol, which
indicates to the C program that the symlink() routine is available
to create symbolic links.

=item C<d_syscall>

From F<d_syscall.U>:

This variable conditionally defines C<HAS_SYSCALL> if syscall() is
available call arbitrary system calls.

=item C<d_syscallproto>

From F<d_syscallproto.U>:

This variable conditionally defines the C<HAS_SYSCALL_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the syscall() function.  Otherwise, it is
up to the program to supply one.

=item C<d_sysconf>

From F<d_sysconf.U>:

This variable conditionally defines the C<HAS_SYSCONF> symbol, which
indicates to the C program that the sysconf() routine is available
to determine system related limits and options.

=item C<d_sysernlst>

From F<d_strerror.U>:

This variable conditionally defines C<HAS_SYS_ERRNOLIST> if sys_errnolist[]
is available to translate error numbers to the symbolic name.

=item C<d_syserrlst>

From F<d_strerror.U>:

This variable conditionally defines C<HAS_SYS_ERRLIST> if sys_errlist[] is
available to translate error numbers to strings.

=item C<d_system>

From F<d_system.U>:

This variable conditionally defines C<HAS_SYSTEM> if system() is
available to issue a shell command.

=item C<d_tcgetpgrp>

From F<d_tcgtpgrp.U>:

This variable conditionally defines the C<HAS_TCGETPGRP> symbol, which
indicates to the C program that the tcgetpgrp() routine is available.
to get foreground process group C<ID>.

=item C<d_tcsetpgrp>

From F<d_tcstpgrp.U>:

This variable conditionally defines the C<HAS_TCSETPGRP> symbol, which
indicates to the C program that the tcsetpgrp() routine is available
to set foreground process group C<ID>.

=item C<d_telldir>

From F<d_readdir.U>:

This variable conditionally defines C<HAS_TELLDIR> if telldir() is
available.

=item C<d_telldirproto>

From F<d_telldirproto.U>:

This variable conditionally defines the C<HAS_TELLDIR_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the telldir() function.  Otherwise, it is
up to the program to supply one.

=item C<d_time>

From F<d_time.U>:

This variable conditionally defines the C<HAS_TIME> symbol, which indicates
that the time() routine exists.  The time() routine is normally
provided on C<UNIX> systems.

=item C<d_timegm>

From F<d_timegm.U>:

This variable conditionally defines the C<HAS_TIMEGM> symbol, which
indicates to the C program that the timegm () routine is available.

=item C<d_times>

From F<d_times.U>:

This variable conditionally defines the C<HAS_TIMES> symbol, which indicates
that the times() routine exists.  The times() routine is normally
provided on C<UNIX> systems. You may have to include <sys/times.h>.

=item C<d_tm_tm_gmtoff>

From F<i_time.U>:

This variable conditionally defines C<HAS_TM_TM_GMTOFF>, which indicates
indicates to the C program that the struct tm has the tm_gmtoff field.

=item C<d_tm_tm_zone>

From F<i_time.U>:

This variable conditionally defines C<HAS_TM_TM_ZONE>, which indicates
indicates to the C program that the struct tm has the tm_zone field.

=item C<d_tmpnam_r>

From F<d_tmpnam_r.U>:

This variable conditionally defines the C<HAS_TMPNAM_R> symbol,
which indicates to the C program that the tmpnam_r()
routine is available.

=item C<d_truncate>

From F<d_truncate.U>:

This variable conditionally defines C<HAS_TRUNCATE> if truncate() is
available to truncate files.

=item C<d_ttyname_r>

From F<d_ttyname_r.U>:

This variable conditionally defines the C<HAS_TTYNAME_R> symbol,
which indicates to the C program that the ttyname_r()
routine is available.

=item C<d_tzname>

From F<d_tzname.U>:

This variable conditionally defines C<HAS_TZNAME> if tzname[] is
available to access timezone names.

=item C<d_u32align>

From F<d_u32align.U>:

This variable tells whether you must access character data
through U32-aligned pointers.

=item C<d_ualarm>

From F<d_ualarm.U>:

This variable conditionally defines the C<HAS_UALARM> symbol, which
indicates to the C program that the ualarm() routine is available.

=item C<d_umask>

From F<d_umask.U>:

This variable conditionally defines the C<HAS_UMASK> symbol, which
indicates to the C program that the umask() routine is available.
to set and get the value of the file creation mask.

=item C<d_uname>

From F<d_gethname.U>:

This variable conditionally defines the C<HAS_UNAME> symbol, which
indicates to the C program that the uname() routine may be
used to derive the host name.

=item C<d_union_semun>

From F<d_union_semun.U>:

This variable conditionally defines C<HAS_UNION_SEMUN> if the
union semun is defined by including <sys/sem.h>.

=item C<d_unordered>

From F<d_unordered.U>:

This variable conditionally defines the C<HAS_UNORDERED> symbol, which
indicates to the C program that the unordered() routine is available.

=item C<d_unsetenv>

From F<d_unsetenv.U>:

This variable conditionally defines the C<HAS_UNSETENV> symbol, which
indicates to the C program that the unsetenv () routine is available.

=item C<d_usleep>

From F<d_usleep.U>:

This variable conditionally defines C<HAS_USLEEP> if usleep() is
available to do high granularity sleeps.

=item C<d_usleepproto>

From F<d_usleepproto.U>:

This variable conditionally defines the C<HAS_USLEEP_PROTO> symbol,
which indicates to the C program that the system provides
a prototype for the usleep() function.  Otherwise, it is
up to the program to supply one.

=item C<d_ustat>

From F<d_ustat.U>:

This variable conditionally defines C<HAS_USTAT> if ustat() is
available to query file system statistics by dev_t.

=item C<d_vendorarch>

From F<vendorarch.U>:

This variable conditionally defined C<PERL_VENDORARCH>.

=item C<d_vendorbin>

From F<vendorbin.U>:

This variable conditionally defines C<PERL_VENDORBIN>.

=item C<d_vendorlib>

From F<vendorlib.U>:

This variable conditionally defines C<PERL_VENDORLIB>.

=item C<d_vendorscript>

From F<vendorscript.U>:

This variable conditionally defines C<PERL_VENDORSCRIPT>.

=item C<d_vfork>

From F<d_vfork.U>:

This variable conditionally defines the C<HAS_VFORK> symbol, which
indicates the vfork() routine is available.

=item C<d_void_closedir>

From F<d_closedir.U>:

This variable conditionally defines C<VOID_CLOSEDIR> if closedir()
does not return a value.

=item C<d_voidsig>

From F<d_voidsig.U>:

This variable conditionally defines C<VOIDSIG> if this system
declares "void (*signal(...))()" in F<signal.h>.  The old way was to
declare it as "int (*signal(...))()".

=item C<d_voidtty>

From F<i_sysioctl.U>:

This variable conditionally defines C<USE_IOCNOTTY> to indicate that the
ioctl() call with C<TIOCNOTTY> should be used to void tty association.
Otherwise (on C<USG> probably), it is enough to close the standard file
descriptors and do a setpgrp().

=item C<d_volatile>

From F<d_volatile.U>:

This variable conditionally defines the C<HASVOLATILE> symbol, which
indicates to the C program that this C compiler knows about the
volatile declaration.

=item C<d_vprintf>

From F<d_vprintf.U>:

This variable conditionally defines the C<HAS_VPRINTF> symbol, which
indicates to the C program that the vprintf() routine is available
to printf with a pointer to an argument list.

=item C<d_vsnprintf>

From F<d_snprintf.U>:

This variable conditionally defines the C<HAS_VSNPRINTF> symbol, which
indicates to the C program that the vsnprintf () library function
is available.

=item C<d_wait4>

From F<d_wait4.U>:

This variable conditionally defines the HAS_WAIT4 symbol, which
indicates the wait4() routine is available.

=item C<d_waitpid>

From F<d_waitpid.U>:

This variable conditionally defines C<HAS_WAITPID> if waitpid() is
available to wait for child process.

=item C<d_wcstombs>

From F<d_wcstombs.U>:

This variable conditionally defines the C<HAS_WCSTOMBS> symbol, which
indicates to the C program that the wcstombs() routine is available
to convert wide character strings to multibyte strings.

=item C<d_wctomb>

From F<d_wctomb.U>:

This variable conditionally defines the C<HAS_WCTOMB> symbol, which
indicates to the C program that the wctomb() routine is available
to convert a wide character to a multibyte.

=item C<d_writev>

From F<d_writev.U>:

This variable conditionally defines the C<HAS_WRITEV> symbol, which
indicates to the C program that the writev() routine is available.

=item C<d_xenix>

From F<Guess.U>:

This variable conditionally defines the symbol C<XENIX>, which alerts
the C program that it runs under Xenix.

=item C<date>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the date program.  After Configure runs,
the value is reset to a plain C<date> and is not useful.

=item C<db_hashtype>

From F<i_db.U>:

This variable contains the type of the hash structure element
in the <db.h> header file.  In older versions of C<DB>, it was
int, while in newer ones it is u_int32_t.

=item C<db_prefixtype>

From F<i_db.U>:

This variable contains the type of the prefix structure element
in the <db.h> header file.  In older versions of C<DB>, it was
int, while in newer ones it is size_t.

=item C<db_version_major>

From F<i_db.U>:

This variable contains the major version number of
Berkeley C<DB> found in the <db.h> header file.

=item C<db_version_minor>

From F<i_db.U>:

This variable contains the minor version number of
Berkeley C<DB> found in the <db.h> header file.
For C<DB> version 1 this is always 0.

=item C<db_version_patch>

From F<i_db.U>:

This variable contains the patch version number of
Berkeley C<DB> found in the <db.h> header file.
For C<DB> version 1 this is always 0.

=item C<direntrytype>

From F<i_dirent.U>:

This symbol is set to C<struct direct> or C<struct dirent> depending on
whether dirent is available or not. You should use this pseudo type to
portably declare your directory entries.

=item C<dlext>

From F<dlext.U>:

This variable contains the extension that is to be used for the
dynamically loaded modules that perl generates.

=item C<dlsrc>

From F<dlsrc.U>:

This variable contains the name of the dynamic loading file that
will be used with the package.

=item C<doublesize>

From F<doublesize.U>:

This variable contains the value of the C<DOUBLESIZE> symbol, which
indicates to the C program how many bytes there are in a double.

=item C<drand01>

From F<randfunc.U>:

Indicates the macro to be used to generate normalized
random numbers.  Uses randfunc, often divided by
(double) (((unsigned long) 1 << randbits)) in order to
normalize the result.
In C programs, the macro C<Drand01> is mapped to drand01.

=item C<drand48_r_proto>

From F<d_drand48_r.U>:

This variable encodes the prototype of drand48_r.
It is zero if d_drand48_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_drand48_r
is defined.

=item C<dtrace>

From F<usedtrace.U>:

This variable holds the location of the dtrace executable.

=item C<dynamic_ext>

From F<Extensions.U>:

This variable holds a list of C<XS> extension files we want to
link dynamically into the package.  It is used by Makefile.

=back

=cut

=head2 e

=over 4

=cut

=item C<eagain>

From F<nblock_io.U>:

This variable bears the symbolic errno code set by read() when no
data is present on the file and non-blocking I/O was enabled (otherwise,
read() blocks naturally).

=item C<ebcdic>

From F<ebcdic.U>:

This variable conditionally defines C<EBCDIC> if this
system uses C<EBCDIC> encoding.

=item C<echo>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the echo program.  After Configure runs,
the value is reset to a plain C<echo> and is not useful.

=item C<egrep>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the egrep program.  After Configure runs,
the value is reset to a plain C<egrep> and is not useful.

=item C<emacs>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<endgrent_r_proto>

From F<d_endgrent_r.U>:

This variable encodes the prototype of endgrent_r.
It is zero if d_endgrent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_endgrent_r
is defined.

=item C<endhostent_r_proto>

From F<d_endhostent_r.U>:

This variable encodes the prototype of endhostent_r.
It is zero if d_endhostent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_endhostent_r
is defined.

=item C<endnetent_r_proto>

From F<d_endnetent_r.U>:

This variable encodes the prototype of endnetent_r.
It is zero if d_endnetent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_endnetent_r
is defined.

=item C<endprotoent_r_proto>

From F<d_endprotoent_r.U>:

This variable encodes the prototype of endprotoent_r.
It is zero if d_endprotoent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_endprotoent_r
is defined.

=item C<endpwent_r_proto>

From F<d_endpwent_r.U>:

This variable encodes the prototype of endpwent_r.
It is zero if d_endpwent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_endpwent_r
is defined.

=item C<endservent_r_proto>

From F<d_endservent_r.U>:

This variable encodes the prototype of endservent_r.
It is zero if d_endservent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_endservent_r
is defined.

=item C<eunicefix>

From F<Init.U>:

When running under Eunice this variable contains a command which will
convert a shell script to the proper form of text file for it to be
executable by the shell.  On other systems it is a no-op.

=item C<exe_ext>

From F<Unix.U>:

This is an old synonym for _exe.

=item C<expr>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the expr program.  After Configure runs,
the value is reset to a plain C<expr> and is not useful.

=item C<extensions>

From F<Extensions.U>:

This variable holds a list of all extension files (both C<XS> and
non-xs) installed with the package.  It is propagated to F<Config.pm>
and is typically used to test whether a particular extension
is available.

=item C<extern_C>

From F<Csym.U>:

C<ANSI> C requires C<extern> where C++ requires 'extern C<C>'. This
variable can be used in Configure to do the right thing.

=item C<extras>

From F<Extras.U>:

This variable holds a list of extra modules to install.

=back

=cut

=head2 f

=over 4

=cut

=item C<fflushall>

From F<fflushall.U>:

This symbol, if defined, tells that to flush
all pending stdio output one must loop through all
the stdio file handles stored in an array and fflush them.
Note that if fflushNULL is defined, fflushall will not
even be probed for and will be left undefined.

=item C<fflushNULL>

From F<fflushall.U>:

This symbol, if defined, tells that fflush(C<NULL>) correctly
flushes all pending stdio output without side effects. In
particular, on some platforms calling fflush(C<NULL>) *still*
corrupts C<STDIN> if it is a pipe.

=item C<find>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<firstmakefile>

From F<Unix.U>:

This variable defines the first file searched by make.  On unix,
it is makefile (then Makefile).  On case-insensitive systems,
it might be something else.  This is only used to deal with
convoluted make depend tricks.

=item C<flex>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<fpossize>

From F<fpossize.U>:

This variable contains the size of a fpostype in bytes.

=item C<fpostype>

From F<fpostype.U>:

This variable defines Fpos_t to be something like fpos_t, long,
uint, or whatever type is used to declare file positions in libc.

=item C<freetype>

From F<mallocsrc.U>:

This variable contains the return type of free().  It is usually
void, but occasionally int.

=item C<from>

From F<Cross.U>:

This variable contains the command used by Configure
to copy files from the target host.  Useful and available
only during Perl build.
The string C<:> if not cross-compiling.

=item C<full_ar>

From F<Loc_ar.U>:

This variable contains the full pathname to C<ar>, whether or
not the user has specified C<portability>.  This is only used
in the F<Makefile.SH>.

=item C<full_csh>

From F<d_csh.U>:

This variable contains the full pathname to C<csh>, whether or
not the user has specified C<portability>.  This is only used
in the compiled C program, and we assume that all systems which
can share this executable will have the same full pathname to
F<csh.>

=item C<full_sed>

From F<Loc_sed.U>:

This variable contains the full pathname to C<sed>, whether or
not the user has specified C<portability>.  This is only used
in the compiled C program, and we assume that all systems which
can share this executable will have the same full pathname to
F<sed.>

=back

=cut

=head2 g

=over 4

=cut

=item C<gccansipedantic>

From F<gccvers.U>:

If C<GNU> cc (gcc) is used, this variable will enable (if set) the
-ansi and -pedantic ccflags for building core files (through
cflags script). (See F<Porting/pumpkin.pod> for full description).

=item C<gccosandvers>

From F<gccvers.U>:

If C<GNU> cc (gcc) is used, this variable holds the operating system
and version used to compile gcc.  It is set to '' if not gcc,
or if nothing useful can be parsed as the os version.

=item C<gccversion>

From F<gccvers.U>:

If C<GNU> cc (gcc) is used, this variable holds C<1> or C<2> to
indicate whether the compiler is version 1 or 2.  This is used in
setting some of the default cflags.  It is set to '' if not gcc.

=item C<getgrent_r_proto>

From F<d_getgrent_r.U>:

This variable encodes the prototype of getgrent_r.
It is zero if d_getgrent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getgrent_r
is defined.

=item C<getgrgid_r_proto>

From F<d_getgrgid_r.U>:

This variable encodes the prototype of getgrgid_r.
It is zero if d_getgrgid_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getgrgid_r
is defined.

=item C<getgrnam_r_proto>

From F<d_getgrnam_r.U>:

This variable encodes the prototype of getgrnam_r.
It is zero if d_getgrnam_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getgrnam_r
is defined.

=item C<gethostbyaddr_r_proto>

From F<d_gethostbyaddr_r.U>:

This variable encodes the prototype of gethostbyaddr_r.
It is zero if d_gethostbyaddr_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_gethostbyaddr_r
is defined.

=item C<gethostbyname_r_proto>

From F<d_gethostbyname_r.U>:

This variable encodes the prototype of gethostbyname_r.
It is zero if d_gethostbyname_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_gethostbyname_r
is defined.

=item C<gethostent_r_proto>

From F<d_gethostent_r.U>:

This variable encodes the prototype of gethostent_r.
It is zero if d_gethostent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_gethostent_r
is defined.

=item C<getlogin_r_proto>

From F<d_getlogin_r.U>:

This variable encodes the prototype of getlogin_r.
It is zero if d_getlogin_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getlogin_r
is defined.

=item C<getnetbyaddr_r_proto>

From F<d_getnetbyaddr_r.U>:

This variable encodes the prototype of getnetbyaddr_r.
It is zero if d_getnetbyaddr_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getnetbyaddr_r
is defined.

=item C<getnetbyname_r_proto>

From F<d_getnetbyname_r.U>:

This variable encodes the prototype of getnetbyname_r.
It is zero if d_getnetbyname_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getnetbyname_r
is defined.

=item C<getnetent_r_proto>

From F<d_getnetent_r.U>:

This variable encodes the prototype of getnetent_r.
It is zero if d_getnetent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getnetent_r
is defined.

=item C<getprotobyname_r_proto>

From F<d_getprotobyname_r.U>:

This variable encodes the prototype of getprotobyname_r.
It is zero if d_getprotobyname_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getprotobyname_r
is defined.

=item C<getprotobynumber_r_proto>

From F<d_getprotobynumber_r.U>:

This variable encodes the prototype of getprotobynumber_r.
It is zero if d_getprotobynumber_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getprotobynumber_r
is defined.

=item C<getprotoent_r_proto>

From F<d_getprotoent_r.U>:

This variable encodes the prototype of getprotoent_r.
It is zero if d_getprotoent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getprotoent_r
is defined.

=item C<getpwent_r_proto>

From F<d_getpwent_r.U>:

This variable encodes the prototype of getpwent_r.
It is zero if d_getpwent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getpwent_r
is defined.

=item C<getpwnam_r_proto>

From F<d_getpwnam_r.U>:

This variable encodes the prototype of getpwnam_r.
It is zero if d_getpwnam_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getpwnam_r
is defined.

=item C<getpwuid_r_proto>

From F<d_getpwuid_r.U>:

This variable encodes the prototype of getpwuid_r.
It is zero if d_getpwuid_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getpwuid_r
is defined.

=item C<getservbyname_r_proto>

From F<d_getservbyname_r.U>:

This variable encodes the prototype of getservbyname_r.
It is zero if d_getservbyname_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getservbyname_r
is defined.

=item C<getservbyport_r_proto>

From F<d_getservbyport_r.U>:

This variable encodes the prototype of getservbyport_r.
It is zero if d_getservbyport_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getservbyport_r
is defined.

=item C<getservent_r_proto>

From F<d_getservent_r.U>:

This variable encodes the prototype of getservent_r.
It is zero if d_getservent_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getservent_r
is defined.

=item C<getspnam_r_proto>

From F<d_getspnam_r.U>:

This variable encodes the prototype of getspnam_r.
It is zero if d_getspnam_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_getspnam_r
is defined.

=item C<gidformat>

From F<gidf.U>:

This variable contains the format string used for printing a Gid_t.

=item C<gidsign>

From F<gidsign.U>:

This variable contains the signedness of a gidtype.
1 for unsigned, -1 for signed.

=item C<gidsize>

From F<gidsize.U>:

This variable contains the size of a gidtype in bytes.

=item C<gidtype>

From F<gidtype.U>:

This variable defines Gid_t to be something like gid_t, int,
ushort, or whatever type is used to declare the return type
of getgid().  Typically, it is the type of group ids in the kernel.

=item C<glibpth>

From F<libpth.U>:

This variable holds the general path (space-separated) used to
find libraries.  It may contain directories that do not exist on
this platform, libpth is the cleaned-up version.

=item C<gmake>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the gmake program.  After Configure runs,
the value is reset to a plain C<gmake> and is not useful.

=item C<gmtime_r_proto>

From F<d_gmtime_r.U>:

This variable encodes the prototype of gmtime_r.
It is zero if d_gmtime_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_gmtime_r
is defined.

=item C<gnulibc_version>

From F<d_gnulibc.U>:

This variable contains the version number of the C<GNU> C library.
It is usually something like F<2.2.5>.  It is a plain '' if this
is not the C<GNU> C library, or if the version is unknown.

=item C<grep>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the grep program.  After Configure runs,
the value is reset to a plain C<grep> and is not useful.

=item C<groupcat>

From F<nis.U>:

This variable contains a command that produces the text of the
F</etc/group> file.  This is normally "cat F</etc/group>", but can be
"ypcat group" when C<NIS> is used.
On some systems, such as os390, there may be no equivalent
command, in which case this variable is unset.

=item C<groupstype>

From F<groupstype.U>:

This variable defines Groups_t to be something like gid_t, int,
ushort, or whatever type is used for the second argument to
getgroups() and setgroups().  Usually, this is the same as
gidtype (gid_t), but sometimes it isn't.

=item C<gzip>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the gzip program.  After Configure runs,
the value is reset to a plain C<gzip> and is not useful.

=back

=cut

=head2 h

=over 4

=cut

=item C<h_fcntl>

From F<h_fcntl.U>:

This is variable gets set in various places to tell i_fcntl that
<fcntl.h> should be included.

=item C<h_sysfile>

From F<h_sysfile.U>:

This is variable gets set in various places to tell i_sys_file that
<sys/file.h> should be included.

=item C<hint>

From F<Oldconfig.U>:

Gives the type of hints used for previous answers. May be one of
C<default>, C<recommended> or C<previous>.

=item C<hostperl>

From F<Cross.U>:

This variable contains the path to a miniperl binary that can be
run on the host C<OS> when cross-compiling.  Useful and available only
during Perl build.
Empty string '' if not cross-compiling.

=item C<hostgenerate>

From F<Cross.U>:

This variable contains the path to a generate_uudmap binary that
can be run on the host C<OS> when cross-compiling.  Useful and
available only during Perl build.
Empty string '' if not cross-compiling.

=item C<hostosname>

From F<Cross.U>:

This variable contains the original value of C<$^O> for hostperl
when cross-compiling.  This is useful to pick the proper tools
when running build code in the host.
Empty string '' if not cross-compiling.

=item C<hostcat>

From F<nis.U>:

This variable contains a command that produces the text of the
F</etc/hosts> file.  This is normally "cat F</etc/hosts>", but can be
"ypcat hosts" when C<NIS> is used.
On some systems, such as os390, there may be no equivalent
command, in which case this variable is unset.

=item C<html1dir>

From F<html1dir.U>:

This variable contains the name of the directory in which html
source pages are to be put.  This directory is for pages
that describe whole programs, not libraries or modules.  It
is intended to correspond roughly to section 1 of the Unix
manuals.

=item C<html1direxp>

From F<html1dir.U>:

This variable is the same as the html1dir variable, but is filename
expanded at configuration time, for convenient use in makefiles.

=item C<html3dir>

From F<html3dir.U>:

This variable contains the name of the directory in which html
source pages are to be put.  This directory is for pages
that describe libraries or modules.  It is intended to
correspond roughly to section 3 of the Unix manuals.

=item C<html3direxp>

From F<html3dir.U>:

This variable is the same as the html3dir variable, but is filename
expanded at configuration time, for convenient use in makefiles.

=back

=cut

=head2 i

=over 4

=cut

=item C<i16size>

From F<perlxv.U>:

This variable is the size of an I16 in bytes.

=item C<i16type>

From F<perlxv.U>:

This variable contains the C type used for Perl's I16.

=item C<i32size>

From F<perlxv.U>:

This variable is the size of an I32 in bytes.

=item C<i32type>

From F<perlxv.U>:

This variable contains the C type used for Perl's I32.

=item C<i64size>

From F<perlxv.U>:

This variable is the size of an I64 in bytes.

=item C<i64type>

From F<perlxv.U>:

This variable contains the C type used for Perl's I64.

=item C<i8size>

From F<perlxv.U>:

This variable is the size of an I8 in bytes.

=item C<i8type>

From F<perlxv.U>:

This variable contains the C type used for Perl's I8.

=item C<i_arpainet>

From F<i_arpainet.U>:

This variable conditionally defines the C<I_ARPA_INET> symbol,
and indicates whether a C program should include <arpa/inet.h>.

=item C<i_assert>

From F<i_assert.U>:

This variable conditionally defines the C<I_ASSERT> symbol, which
indicates to the C program that <assert.h> exists and could be
included.

=item C<i_bsdioctl>

From F<i_sysioctl.U>:

This variable conditionally defines the C<I_SYS_BSDIOCTL> symbol, which
indicates to the C program that <sys/bsdioctl.h> exists and should
be included.

=item C<i_crypt>

From F<i_crypt.U>:

This variable conditionally defines the C<I_CRYPT> symbol, and indicates
whether a C program should include <crypt.h>.

=item C<i_db>

From F<i_db.U>:

This variable conditionally defines the C<I_DB> symbol, and indicates
whether a C program may include Berkeley's C<DB> include file <db.h>.

=item C<i_dbm>

From F<i_dbm.U>:

This variable conditionally defines the C<I_DBM> symbol, which
indicates to the C program that <dbm.h> exists and should
be included.

=item C<i_dirent>

From F<i_dirent.U>:

This variable conditionally defines C<I_DIRENT>, which indicates
to the C program that it should include <dirent.h>.

=item C<i_dlfcn>

From F<i_dlfcn.U>:

This variable conditionally defines the C<I_DLFCN> symbol, which
indicates to the C program that <dlfcn.h> exists and should
be included.

=item C<i_fcntl>

From F<i_fcntl.U>:

This variable controls the value of C<I_FCNTL> (which tells
the C program to include <fcntl.h>).

=item C<i_float>

From F<i_float.U>:

This variable conditionally defines the C<I_FLOAT> symbol, and indicates
whether a C program may include <float.h> to get symbols like C<DBL_MAX>
or C<DBL_MIN>, F<i.e>. machine dependent floating point values.

=item C<i_fp>

From F<i_fp.U>:

This variable conditionally defines the C<I_FP> symbol, and indicates
whether a C program should include <fp.h>.

=item C<i_fp_class>

From F<i_fp_class.U>:

This variable conditionally defines the C<I_FP_CLASS> symbol, and indicates
whether a C program should include <fp_class.h>.

=item C<i_gdbm>

From F<i_gdbm.U>:

This variable conditionally defines the C<I_GDBM> symbol, which
indicates to the C program that <gdbm.h> exists and should
be included.

=item C<i_gdbm_ndbm>

From F<i_ndbm.U>:

This variable conditionally defines the C<I_GDBM_NDBM> symbol, which
indicates to the C program that <gdbm-F<ndbm.h>> exists and should
be included.  This is the location of the F<ndbm.h> compatibility file
in Debian 4.0.

=item C<i_gdbmndbm>

From F<i_ndbm.U>:

This variable conditionally defines the C<I_GDBMNDBM> symbol, which
indicates to the C program that <gdbm/ndbm.h> exists and should
be included.  This was the location of the F<ndbm.h> compatibility file
in RedHat 7.1.

=item C<i_grp>

From F<i_grp.U>:

This variable conditionally defines the C<I_GRP> symbol, and indicates
whether a C program should include <grp.h>.

=item C<i_ieeefp>

From F<i_ieeefp.U>:

This variable conditionally defines the C<I_IEEEFP> symbol, and indicates
whether a C program should include <ieeefp.h>.

=item C<i_inttypes>

From F<i_inttypes.U>:

This variable conditionally defines the C<I_INTTYPES> symbol,
and indicates whether a C program should include <inttypes.h>.

=item C<i_langinfo>

From F<i_langinfo.U>:

This variable conditionally defines the C<I_LANGINFO> symbol,
and indicates whether a C program should include <langinfo.h>.

=item C<i_libutil>

From F<i_libutil.U>:

This variable conditionally defines the C<I_LIBUTIL> symbol, and indicates
whether a C program should include <libutil.h>.

=item C<i_limits>

From F<i_limits.U>:

This variable conditionally defines the C<I_LIMITS> symbol, and indicates
whether a C program may include <limits.h> to get symbols like C<WORD_BIT>
and friends.

=item C<i_locale>

From F<i_locale.U>:

This variable conditionally defines the C<I_LOCALE> symbol,
and indicates whether a C program should include <locale.h>.

=item C<i_machcthr>

From F<i_machcthr.U>:

This variable conditionally defines the C<I_MACH_CTHREADS> symbol,
and indicates whether a C program should include <mach/cthreads.h>.

=item C<i_malloc>

From F<i_malloc.U>:

This variable conditionally defines the C<I_MALLOC> symbol, and indicates
whether a C program should include <malloc.h>.

=item C<i_mallocmalloc>

From F<i_mallocmalloc.U>:

This variable conditionally defines the C<I_MALLOCMALLOC> symbol,
and indicates whether a C program should include <malloc/malloc.h>.

=item C<i_math>

From F<i_math.U>:

This variable conditionally defines the C<I_MATH> symbol, and indicates
whether a C program may include <math.h>.

=item C<i_memory>

From F<i_memory.U>:

This variable conditionally defines the C<I_MEMORY> symbol, and indicates
whether a C program should include <memory.h>.

=item C<i_mntent>

From F<i_mntent.U>:

This variable conditionally defines the C<I_MNTENT> symbol, and indicates
whether a C program should include <mntent.h>.

=item C<i_ndbm>

From F<i_ndbm.U>:

This variable conditionally defines the C<I_NDBM> symbol, which
indicates to the C program that <ndbm.h> exists and should
be included.

=item C<i_netdb>

From F<i_netdb.U>:

This variable conditionally defines the C<I_NETDB> symbol, and indicates
whether a C program should include <netdb.h>.

=item C<i_neterrno>

From F<i_neterrno.U>:

This variable conditionally defines the C<I_NET_ERRNO> symbol, which
indicates to the C program that <net/errno.h> exists and should
be included.

=item C<i_netinettcp>

From F<i_netinettcp.U>:

This variable conditionally defines the C<I_NETINET_TCP> symbol,
and indicates whether a C program should include <netinet/tcp.h>.

=item C<i_niin>

From F<i_niin.U>:

This variable conditionally defines C<I_NETINET_IN>, which indicates
to the C program that it should include <netinet/in.h>. Otherwise,
you may try <sys/in.h>.

=item C<i_poll>

From F<i_poll.U>:

This variable conditionally defines the C<I_POLL> symbol, and indicates
whether a C program should include <poll.h>.

=item C<i_prot>

From F<i_prot.U>:

This variable conditionally defines the C<I_PROT> symbol, and indicates
whether a C program should include <prot.h>.

=item C<i_pthread>

From F<i_pthread.U>:

This variable conditionally defines the C<I_PTHREAD> symbol,
and indicates whether a C program should include <pthread.h>.

=item C<i_pwd>

From F<i_pwd.U>:

This variable conditionally defines C<I_PWD>, which indicates
to the C program that it should include <pwd.h>.

=item C<i_rpcsvcdbm>

From F<i_dbm.U>:

This variable conditionally defines the C<I_RPCSVC_DBM> symbol, which
indicates to the C program that <rpcsvc/dbm.h> exists and should
be included.  Some System V systems might need this instead of <dbm.h>.

=item C<i_sgtty>

From F<i_termio.U>:

This variable conditionally defines the C<I_SGTTY> symbol, which
indicates to the C program that it should include <sgtty.h> rather
than <termio.h>.

=item C<i_shadow>

From F<i_shadow.U>:

This variable conditionally defines the C<I_SHADOW> symbol, and indicates
whether a C program should include <shadow.h>.

=item C<i_socks>

From F<i_socks.U>:

This variable conditionally defines the C<I_SOCKS> symbol, and indicates
whether a C program should include <socks.h>.

=item C<i_stdarg>

From F<i_varhdr.U>:

This variable conditionally defines the C<I_STDARG> symbol, which
indicates to the C program that <stdarg.h> exists and should
be included.

=item C<i_stdbool>

From F<i_stdbool.U>:

This variable conditionally defines the C<I_STDBOOL> symbol, which
indicates to the C program that <stdbool.h> exists and should
be included.

=item C<i_stddef>

From F<i_stddef.U>:

This variable conditionally defines the C<I_STDDEF> symbol, which
indicates to the C program that <stddef.h> exists and should
be included.

=item C<i_stdlib>

From F<i_stdlib.U>:

This variable conditionally defines the C<I_STDLIB> symbol, which
indicates to the C program that <stdlib.h> exists and should
be included.

=item C<i_string>

From F<i_string.U>:

This variable conditionally defines the C<I_STRING> symbol, which
indicates that <string.h> should be included rather than <strings.h>.

=item C<i_sunmath>

From F<i_sunmath.U>:

This variable conditionally defines the C<I_SUNMATH> symbol, and indicates
whether a C program should include <sunmath.h>.

=item C<i_sysaccess>

From F<i_sysaccess.U>:

This variable conditionally defines the C<I_SYS_ACCESS> symbol,
and indicates whether a C program should include <sys/access.h>.

=item C<i_sysdir>

From F<i_sysdir.U>:

This variable conditionally defines the C<I_SYS_DIR> symbol, and indicates
whether a C program should include <sys/dir.h>.

=item C<i_sysfile>

From F<i_sysfile.U>:

This variable conditionally defines the C<I_SYS_FILE> symbol, and indicates
whether a C program should include <sys/file.h> to get C<R_OK> and friends.

=item C<i_sysfilio>

From F<i_sysioctl.U>:

This variable conditionally defines the C<I_SYS_FILIO> symbol, which
indicates to the C program that <sys/filio.h> exists and should
be included in preference to <sys/ioctl.h>.

=item C<i_sysin>

From F<i_niin.U>:

This variable conditionally defines C<I_SYS_IN>, which indicates
to the C program that it should include <sys/in.h> instead of
<netinet/in.h>.

=item C<i_sysioctl>

From F<i_sysioctl.U>:

This variable conditionally defines the C<I_SYS_IOCTL> symbol, which
indicates to the C program that <sys/ioctl.h> exists and should
be included.

=item C<i_syslog>

From F<i_syslog.U>:

This variable conditionally defines the C<I_SYSLOG> symbol,
and indicates whether a C program should include <syslog.h>.

=item C<i_sysmman>

From F<i_sysmman.U>:

This variable conditionally defines the C<I_SYS_MMAN> symbol, and
indicates whether a C program should include <sys/mman.h>.

=item C<i_sysmode>

From F<i_sysmode.U>:

This variable conditionally defines the C<I_SYSMODE> symbol,
and indicates whether a C program should include <sys/mode.h>.

=item C<i_sysmount>

From F<i_sysmount.U>:

This variable conditionally defines the C<I_SYSMOUNT> symbol,
and indicates whether a C program should include <sys/mount.h>.

=item C<i_sysndir>

From F<i_sysndir.U>:

This variable conditionally defines the C<I_SYS_NDIR> symbol, and indicates
whether a C program should include <sys/ndir.h>.

=item C<i_sysparam>

From F<i_sysparam.U>:

This variable conditionally defines the C<I_SYS_PARAM> symbol, and indicates
whether a C program should include <sys/param.h>.

=item C<i_syspoll>

From F<i_syspoll.U>:

This variable conditionally defines the C<I_SYS_POLL> symbol, which
indicates to the C program that it should include <sys/poll.h>.

=item C<i_sysresrc>

From F<i_sysresrc.U>:

This variable conditionally defines the C<I_SYS_RESOURCE> symbol,
and indicates whether a C program should include <sys/resource.h>.

=item C<i_syssecrt>

From F<i_syssecrt.U>:

This variable conditionally defines the C<I_SYS_SECURITY> symbol,
and indicates whether a C program should include <sys/security.h>.

=item C<i_sysselct>

From F<i_sysselct.U>:

This variable conditionally defines C<I_SYS_SELECT>, which indicates
to the C program that it should include <sys/select.h> in order to
get the definition of struct timeval.

=item C<i_syssockio>

From F<i_sysioctl.U>:

This variable conditionally defines C<I_SYS_SOCKIO> to indicate to the
C program that socket ioctl codes may be found in <sys/sockio.h>
instead of <sys/ioctl.h>.

=item C<i_sysstat>

From F<i_sysstat.U>:

This variable conditionally defines the C<I_SYS_STAT> symbol,
and indicates whether a C program should include <sys/stat.h>.

=item C<i_sysstatfs>

From F<i_sysstatfs.U>:

This variable conditionally defines the C<I_SYSSTATFS> symbol,
and indicates whether a C program should include <sys/statfs.h>.

=item C<i_sysstatvfs>

From F<i_sysstatvfs.U>:

This variable conditionally defines the C<I_SYSSTATVFS> symbol,
and indicates whether a C program should include <sys/statvfs.h>.

=item C<i_systime>

From F<i_time.U>:

This variable conditionally defines C<I_SYS_TIME>, which indicates
to the C program that it should include <sys/time.h>.

=item C<i_systimek>

From F<i_time.U>:

This variable conditionally defines C<I_SYS_TIME_KERNEL>, which
indicates to the C program that it should include <sys/time.h>
with C<KERNEL> defined.

=item C<i_systimes>

From F<i_systimes.U>:

This variable conditionally defines the C<I_SYS_TIMES> symbol, and indicates
whether a C program should include <sys/times.h>.

=item C<i_systypes>

From F<i_systypes.U>:

This variable conditionally defines the C<I_SYS_TYPES> symbol,
and indicates whether a C program should include <sys/types.h>.

=item C<i_sysuio>

From F<i_sysuio.U>:

This variable conditionally defines the C<I_SYSUIO> symbol, and indicates
whether a C program should include <sys/uio.h>.

=item C<i_sysun>

From F<i_sysun.U>:

This variable conditionally defines C<I_SYS_UN>, which indicates
to the C program that it should include <sys/un.h> to get C<UNIX>
domain socket definitions.

=item C<i_sysutsname>

From F<i_sysutsname.U>:

This variable conditionally defines the C<I_SYSUTSNAME> symbol,
and indicates whether a C program should include <sys/utsname.h>.

=item C<i_sysvfs>

From F<i_sysvfs.U>:

This variable conditionally defines the C<I_SYSVFS> symbol,
and indicates whether a C program should include <sys/vfs.h>.

=item C<i_syswait>

From F<i_syswait.U>:

This variable conditionally defines C<I_SYS_WAIT>, which indicates
to the C program that it should include <sys/wait.h>.

=item C<i_termio>

From F<i_termio.U>:

This variable conditionally defines the C<I_TERMIO> symbol, which
indicates to the C program that it should include <termio.h> rather
than <sgtty.h>.

=item C<i_termios>

From F<i_termio.U>:

This variable conditionally defines the C<I_TERMIOS> symbol, which
indicates to the C program that the C<POSIX> <termios.h> file is
to be included.

=item C<i_time>

From F<i_time.U>:

This variable conditionally defines C<I_TIME>, which indicates
to the C program that it should include <time.h>.

=item C<i_unistd>

From F<i_unistd.U>:

This variable conditionally defines the C<I_UNISTD> symbol, and indicates
whether a C program should include <unistd.h>.

=item C<i_ustat>

From F<i_ustat.U>:

This variable conditionally defines the C<I_USTAT> symbol, and indicates
whether a C program should include <ustat.h>.

=item C<i_utime>

From F<i_utime.U>:

This variable conditionally defines the C<I_UTIME> symbol, and indicates
whether a C program should include <utime.h>.

=item C<i_values>

From F<i_values.U>:

This variable conditionally defines the C<I_VALUES> symbol, and indicates
whether a C program may include <values.h> to get symbols like C<MAXLONG>
and friends.

=item C<i_varargs>

From F<i_varhdr.U>:

This variable conditionally defines C<I_VARARGS>, which indicates
to the C program that it should include <varargs.h>.

=item C<i_varhdr>

From F<i_varhdr.U>:

Contains the name of the header to be included to get va_dcl definition.
Typically one of F<varargs.h> or F<stdarg.h>.

=item C<i_vfork>

From F<i_vfork.U>:

This variable conditionally defines the C<I_VFORK> symbol, and indicates
whether a C program should include F<vfork.h>.

=item C<ignore_versioned_solibs>

From F<libs.U>:

This variable should be non-empty if non-versioned shared
libraries (F<libfoo.so.x.y>) are to be ignored (because they
cannot be linked against).

=item C<inc_version_list>

From F<inc_version_list.U>:

This variable specifies the list of subdirectories in over
which F<perl.c>:incpush() and F<lib/lib.pm> will automatically
search when adding directories to @C<INC>.  The elements in
the list are separated by spaces.  This is only useful
if you have a perl library directory tree structured like the
default one.  See C<INSTALL> for how this works.  The versioned
site_perl directory was introduced in 5.005, so that is the
lowest possible value.

This list includes architecture-dependent directories back to
version $api_versionstring (e.g. 5.5.640) and
architecture-independent directories all the way back to
5.005.

=item C<inc_version_list_init>

From F<inc_version_list.U>:

This variable holds the same list as inc_version_list, but
each item is enclosed in double quotes and separated by commas,
suitable for use in the C<PERL_INC_VERSION_LIST> initialization.

=item C<incpath>

From F<usrinc.U>:

This variable must precede the normal include path to get the
right one, as in F<$incpath/usr/include> or F<$incpath/usr/lib>.
Value can be "" or F</bsd43> on mips.

=item C<incpth>

From F<libpth.U>:

This variable must precede the normal include path to get the
right one, as in F<$incpath/usr/include> or F<$incpath/usr/lib>.
Value can be "" or F</bsd43> on mips.

=item C<inews>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<initialinstalllocation>

From F<bin.U>:

When userelocatableinc is true, this variable holds the location
that make install should copy the perl binary to, with all the
run-time relocatable paths calculated from this at install time.
When used, it is initialized to the original value of binexp, and
then binexp is set to F<.../>, as the other binaries are found
relative to the perl binary.

=item C<installarchlib>

From F<archlib.U>:

This variable is really the same as archlibexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installbin>

From F<bin.U>:

This variable is the same as binexp unless C<AFS> is running in which case
the user is explicitly prompted for it. This variable should always
be used in your makefiles for maximum portability.

=item C<installhtml1dir>

From F<html1dir.U>:

This variable is really the same as html1direxp, unless you are
using a different installprefix.  For extra portability, you
should only use this variable within your makefiles.

=item C<installhtml3dir>

From F<html3dir.U>:

This variable is really the same as html3direxp, unless you are
using a different installprefix.  For extra portability, you
should only use this variable within your makefiles.

=item C<installman1dir>

From F<man1dir.U>:

This variable is really the same as man1direxp, unless you are using
C<AFS> in which case it points to the read/write location whereas
man1direxp only points to the read-only access location. For extra
portability, you should only use this variable within your makefiles.

=item C<installman3dir>

From F<man3dir.U>:

This variable is really the same as man3direxp, unless you are using
C<AFS> in which case it points to the read/write location whereas
man3direxp only points to the read-only access location. For extra
portability, you should only use this variable within your makefiles.

=item C<installprefix>

From F<installprefix.U>:

This variable holds the name of the directory below which
"make install" will install the package.  For most users, this
is the same as prefix.  However, it is useful for
installing the software into a different (usually temporary)
location after which it can be bundled up and moved somehow
to the final location specified by prefix.

=item C<installprefixexp>

From F<installprefix.U>:

This variable holds the full absolute path of installprefix
with all F<~>-expansion done.

=item C<installprivlib>

From F<privlib.U>:

This variable is really the same as privlibexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installscript>

From F<scriptdir.U>:

This variable is usually the same as scriptdirexp, unless you are on
a system running C<AFS>, in which case they may differ slightly. You
should always use this variable within your makefiles for portability.

=item C<installsitearch>

From F<sitearch.U>:

This variable is really the same as sitearchexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installsitebin>

From F<sitebin.U>:

This variable is usually the same as sitebinexp, unless you are on
a system running C<AFS>, in which case they may differ slightly. You
should always use this variable within your makefiles for portability.

=item C<installsitehtml1dir>

From F<sitehtml1dir.U>:

This variable is really the same as sitehtml1direxp, unless you are using
C<AFS> in which case it points to the read/write location whereas
html1direxp only points to the read-only access location. For extra
portability, you should only use this variable within your makefiles.

=item C<installsitehtml3dir>

From F<sitehtml3dir.U>:

This variable is really the same as sitehtml3direxp, unless you are using
C<AFS> in which case it points to the read/write location whereas
html3direxp only points to the read-only access location. For extra
portability, you should only use this variable within your makefiles.

=item C<installsitelib>

From F<sitelib.U>:

This variable is really the same as sitelibexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installsiteman1dir>

From F<siteman1dir.U>:

This variable is really the same as siteman1direxp, unless you are using
C<AFS> in which case it points to the read/write location whereas
man1direxp only points to the read-only access location. For extra
portability, you should only use this variable within your makefiles.

=item C<installsiteman3dir>

From F<siteman3dir.U>:

This variable is really the same as siteman3direxp, unless you are using
C<AFS> in which case it points to the read/write location whereas
man3direxp only points to the read-only access location. For extra
portability, you should only use this variable within your makefiles.

=item C<installsitescript>

From F<sitescript.U>:

This variable is usually the same as sitescriptexp, unless you are on
a system running C<AFS>, in which case they may differ slightly. You
should always use this variable within your makefiles for portability.

=item C<installstyle>

From F<installstyle.U>:

This variable describes the C<style> of the perl installation.
This is intended to be useful for tools that need to
manipulate entire perl distributions.  Perl itself doesn't use
this to find its libraries -- the library directories are
stored directly in F<Config.pm>.  Currently, there are only two
styles:  C<lib> and F<lib/perl5>.  The default library locations
(e.g. privlib, sitelib) are either F<$prefix/lib> or
F<$prefix/lib/perl5>.  The former is useful if $prefix is a
directory dedicated to perl (e.g. F</opt/perl>), while the latter
is useful if $prefix is shared by many packages, e.g. if
$prefix=F</usr/local>.

Unfortunately, while this C<style> variable is used to set
defaults for all three directory hierarchies (core, vendor, and
site), there is no guarantee that the same style is actually
appropriate for all those directories.  For example, $prefix
might be F</opt/perl>, but $siteprefix might be F</usr/local>.
(Perhaps, in retrospect, the C<lib> style should never have been
supported, but it did seem like a nice idea at the time.)

The situation is even less clear for tools such as MakeMaker
that can be used to install additional modules into
non-standard places.  For example, if a user intends to install
a module into a private directory (perhaps by setting C<PREFIX> on
the F<Makefile.PL> command line), then there is no reason to
assume that the Configure-time $installstyle setting will be
relevant for that C<PREFIX>.

This may later be extended to include other information, so
be careful with pattern-matching on the results.

For compatibility with F<perl5.005> and earlier, the default
setting is based on whether or not $prefix contains the string
C<perl>.

=item C<installusrbinperl>

From F<instubperl.U>:

This variable tells whether Perl should be installed also as
F</usr/bin/perl> in addition to
F<$installbin/perl>

=item C<installvendorarch>

From F<vendorarch.U>:

This variable is really the same as vendorarchexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorbin>

From F<vendorbin.U>:

This variable is really the same as vendorbinexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorhtml1dir>

From F<vendorhtml1dir.U>:

This variable is really the same as vendorhtml1direxp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorhtml3dir>

From F<vendorhtml3dir.U>:

This variable is really the same as vendorhtml3direxp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorlib>

From F<vendorlib.U>:

This variable is really the same as vendorlibexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorman1dir>

From F<vendorman1dir.U>:

This variable is really the same as vendorman1direxp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorman3dir>

From F<vendorman3dir.U>:

This variable is really the same as vendorman3direxp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<installvendorscript>

From F<vendorscript.U>:

This variable is really the same as vendorscriptexp but may differ on
those systems using C<AFS>. For extra portability, only this variable
should be used in makefiles.

=item C<intsize>

From F<intsize.U>:

This variable contains the value of the C<INTSIZE> symbol, which
indicates to the C program how many bytes there are in an int.

=item C<issymlink>

From F<issymlink.U>:

This variable holds the test command to test for a symbolic link
(if they are supported).  Typical values include C<test -h> and
C<test -L>.

=item C<ivdformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<IV> as a signed decimal integer.

=item C<ivsize>

From F<perlxv.U>:

This variable is the size of an C<IV> in bytes.

=item C<ivtype>

From F<perlxv.U>:

This variable contains the C type used for Perl's C<IV>.

=back

=cut

=head2 k

=over 4

=cut

=item C<known_extensions>

From F<Extensions.U>:

This variable holds a list of all extensions (both C<XS> and non-xs)
included in the package source distribution.  This information is
only really of use during the Perl build, as the list makes no
distinction between extensions which were build and installed, and
those which where not.  See C<extensions> for the list of extensions
actually built and available.

=item C<ksh>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=back

=cut

=head2 l

=over 4

=cut

=item C<ld>

From F<dlsrc.U>:

This variable indicates the program to be used to link
libraries for dynamic loading.  On some systems, it is C<ld>.
On C<ELF> systems, it should be $cc.  Mostly, we'll try to respect
the hint file setting.

=item C<ld_can_script>

From F<dlsrc.U>:

This variable shows if the loader accepts scripts in the form of
-Wl,--version-script=F<ld.script>. This is currently only supported
for C<GNU> ld on C<ELF> in dynamic loading builds.

=item C<lddlflags>

From F<dlsrc.U>:

This variable contains any special flags that might need to be
passed to $ld to create a shared library suitable for dynamic
loading.  It is up to the makefile to use it.  For hpux, it
should be C<-b>.  For sunos 4.1, it is empty.

=item C<ldflags>

From F<ccflags.U>:

This variable contains any additional C loader flags desired by
the user.  It is up to the Makefile to use this.

=item C<ldflags_uselargefiles>

From F<uselfs.U>:

This variable contains the loader flags needed by large file builds
and added to ldflags by hints files.

=item C<ldlibpthname>

From F<libperl.U>:

This variable holds the name of the shared library
search path, often C<LD_LIBRARY_PATH>.  To get an empty
string, the hints file must set this to C<none>.

=item C<less>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the less program.  After Configure runs,
the value is reset to a plain C<less> and is not useful.

=item C<lib_ext>

From F<Unix.U>:

This is an old synonym for _a.

=item C<libc>

From F<libc.U>:

This variable contains the location of the C library.

=item C<libperl>

From F<libperl.U>:

The perl executable is obtained by linking F<perlmain.c> with
libperl, any static extensions (usually just DynaLoader),
and any other libraries needed on this system.  libperl
is usually F<libperl.a>, but can also be F<libperl.so.xxx> if
the user wishes to build a perl executable with a shared
library.

=item C<libpth>

From F<libpth.U>:

This variable holds the general path (space-separated) used to find
libraries. It is intended to be used by other units.

=item C<libs>

From F<libs.U>:

This variable holds the additional libraries we want to use.
It is up to the Makefile to deal with it.  The list can be empty.

=item C<libsdirs>

From F<libs.U>:

This variable holds the directory names aka dirnames of the libraries
we found and accepted, duplicates are removed.

=item C<libsfiles>

From F<libs.U>:

This variable holds the filenames aka basenames of the libraries
we found and accepted.

=item C<libsfound>

From F<libs.U>:

This variable holds the full pathnames of the libraries
we found and accepted.

=item C<libspath>

From F<libs.U>:

This variable holds the directory names probed for libraries.

=item C<libswanted>

From F<Myinit.U>:

This variable holds a list of all the libraries we want to
search.  The order is chosen to pick up the c library
ahead of ucb or bsd libraries for SVR4.

=item C<libswanted_uselargefiles>

From F<uselfs.U>:

This variable contains the libraries needed by large file builds
and added to ldflags by hints files.  It is a space separated list
of the library names without the C<lib> prefix or any suffix, just
like F<libswanted.>.

=item C<line>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<lint>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<lkflags>

From F<ccflags.U>:

This variable contains any additional C partial linker flags desired by
the user.  It is up to the Makefile to use this.

=item C<ln>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the ln program.  After Configure runs,
the value is reset to a plain C<ln> and is not useful.

=item C<lns>

From F<lns.U>:

This variable holds the name of the command to make
symbolic links (if they are supported).  It can be used
in the Makefile. It is either C<ln -s> or C<ln>

=item C<localtime_r_proto>

From F<d_localtime_r.U>:

This variable encodes the prototype of localtime_r.
It is zero if d_localtime_r is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if d_localtime_r
is defined.

=item C<locincpth>

From F<ccflags.U>:

This variable contains a list of additional directories to be
searched by the compiler.  The appropriate C<-I> directives will
be added to ccflags.  This is intended to simplify setting
local directories from the Configure command line.
It's not much, but it parallels the loclibpth stuff in F<libpth.U>.

=item C<loclibpth>

From F<libpth.U>:

This variable holds the paths (space-separated) used to find local
libraries.  It is prepended to libpth, and is intended to be easily
set from the command line.

=item C<longdblsize>

From F<d_longdbl.U>:

This variable contains the value of the C<LONG_DOUBLESIZE> symbol, which
indicates to the C program how many bytes there are in a long double,
if this system supports long doubles.

=item C<longlongsize>

From F<d_longlong.U>:

This variable contains the value of the C<LONGLONGSIZE> symbol, which
indicates to the C program how many bytes there are in a long long,
if this system supports long long.

=item C<longsize>

From F<intsize.U>:

This variable contains the value of the C<LONGSIZE> symbol, which
indicates to the C program how many bytes there are in a long.

=item C<lp>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<lpr>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<ls>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the ls program.  After Configure runs,
the value is reset to a plain C<ls> and is not useful.

=item C<lseeksize>

From F<lseektype.U>:

This variable defines lseektype to be something like off_t, long,
or whatever type is used to declare lseek offset's type in the
kernel (which also appears to be lseek's return type).

=item C<lseektype>

From F<lseektype.U>:

This variable defines lseektype to be something like off_t, long,
or whatever type is used to declare lseek offset's type in the
kernel (which also appears to be lseek's return type).

=back

=cut

=head2 m

=over 4

=cut

=item C<mad>

From F<mad.U>:

This variable indicates that the Misc Attribute Definition code is to
be compiled.

=item C<madlyh>

From F<mad.U>:

If the Misc Attribute Decoration is to be compiled, this variable is
set to the name of the extra header files to be used, else it is ''

=item C<madlyobj>

From F<mad.U>:

If the Misc Attribute Decoration is to be compiled, this variable is
set to the name of the extra object files to be used, else it is ''

=item C<madlysrc>

From F<mad.U>:

If the Misc Attribute Decoration is to be compiled, this variable is
set to the name of the extra C source files to be used, else it is ''

=item C<mail>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<mailx>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<make>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the make program.  After Configure runs,
the value is reset to a plain C<make> and is not useful.

=item C<make_set_make>

From F<make.U>:

Some versions of C<make> set the variable C<MAKE>.  Others do not.
This variable contains the string to be included in F<Makefile.SH>
so that C<MAKE> is set if needed, and not if not needed.
Possible values are:

make_set_make=C<#>		# If your make program handles this for you,

make_set_make=C<MAKE=$make>	# if it doesn't.

This uses a comment character so that we can distinguish a
C<set> value (from a previous F<config.sh> or Configure C<-D> option)
from an uncomputed value.

=item C<mallocobj>

From F<mallocsrc.U>:

This variable contains the name of the F<malloc.o> that this package
generates, if that F<malloc.o> is preferred over the system malloc.
Otherwise the value is null.  This variable is intended for generating
Makefiles.  See mallocsrc.

=item C<mallocsrc>

From F<mallocsrc.U>:

This variable contains the name of the F<malloc.c> that comes with
the package, if that F<malloc.c> is preferred over the system malloc.
Otherwise the value is null.  This variable is intended for generating
Makefiles.

=item C<malloctype>

From F<mallocsrc.U>:

This variable contains the kind of ptr returned by malloc and realloc.

=item C<man1dir>

From F<man1dir.U>:

This variable contains the name of the directory in which manual
source pages are to be put.  It is the responsibility of the
F<Makefile.SH> to get the value of this into the proper command.
You must be prepared to do the F<~name> expansion yourself.

=item C<man1direxp>

From F<man1dir.U>:

This variable is the same as the man1dir variable, but is filename
expanded at configuration time, for convenient use in makefiles.

=item C<man1ext>

From F<man1dir.U>:

This variable contains the extension that the manual page should
have: one of C<n>, C<l>, or C<1>.  The Makefile must supply the F<.>.
See man1dir.

=item C<man3dir>

From F<man3dir.U>:

This variable contains the name of the directory in which manual
source pages are to be put.  It is the responsibility of the
F<Makefile.SH> to get the value of this into the proper command.
You must be prepared to do the F<~name> expansion yourself.

=item C<man3direxp>

From F<man3dir.U>:

This variable is the same as the man3dir variable, but is filename
expanded at configuration time, for convenient use in makefiles.

=item C<man3ext>

From F<man3dir.U>:

This variable contains the extension that the manual page should
have: one of C<n>, C<l>, or C<3>.  The Makefile must supply the F<.>.
See man3dir.

=item C<mips_type>

From F<usrinc.U>:

This variable holds the environment type for the mips system.
Possible values are "BSD 4.3" and "System V".

=item C<mistrustnm>

From F<Csym.U>:

This variable can be used to establish a fallthrough for the cases
where nm fails to find a symbol.  If usenm is false or usenm is true
and mistrustnm is false, this variable has no effect.  If usenm is true
and mistrustnm is C<compile>, a test program will be compiled to try to
find any symbol that can't be located via nm lookup.  If mistrustnm is
C<run>, the test program will be run as well as being compiled.

=item C<mkdir>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the mkdir program.  After Configure runs,
the value is reset to a plain C<mkdir> and is not useful.

=item C<mmaptype>

From F<d_mmap.U>:

This symbol contains the type of pointer returned by mmap()
(and simultaneously the type of the first argument).
It can be C<void *> or C<caddr_t>.

=item C<modetype>

From F<modetype.U>:

This variable defines modetype to be something like mode_t,
int, unsigned short, or whatever type is used to declare file
modes for system calls.

=item C<more>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the more program.  After Configure runs,
the value is reset to a plain C<more> and is not useful.

=item C<multiarch>

From F<multiarch.U>:

This variable conditionally defines the C<MULTIARCH> symbol
which signifies the presence of multiplatform files.
This is normally set by hints files.

=item C<mv>

From F<Loc.U>:

This variable is defined but not used by Configure.
The value is the empty string and is not useful.

=item C<myarchname>

From F<archname.U>:

This variable holds the architecture name computed by Configure in
a previous run. It is not intended to be perused by any user and
should never be set in a hint file.

=item C<mydomain>

From F<myhostname.U>:

This variable contains the eventual value of the C<MYDOMAIN> symbol,
which is the domain of the host the program is going to run on.
The domain must be appended to myhostname to form a complete host name.
The dot comes with mydomain, and need not be supplied by the program.

=item C<myhostname>

From F<myhostname.U>:

This variable contains the eventual value of the C<MYHOSTNAME> symbol,
which is the name of the host the program is going to run on.
The domain is not kept with hostname, but must be gotten from mydomain.
The dot comes with mydomain, and need not be supplied by the program.

=item C<myuname>

From F<Oldconfig.U>:

The output of C<uname -a> if available, otherwise the hostname.
The whole thing is then lower-cased and slashes and single quotes are
removed.

=back

=cut

=head2 n

=over 4

=cut

=item C<n>

From F<n.U>:

This variable contains the C<-n> flag if that is what causes the echo
command to suppress newline.  Otherwise it is null.  Correct usage is
$echo $n "prompt for a question: $c".

=item C<need_va_copy>

From F<need_va_copy.U>:

This symbol, if defined, indicates that the system stores
the variable argument list datatype, va_list, in a format
that cannot be copied by simple assignment, so that some
other means must be used when copying is required.
As such systems vary in their provision (or non-provision)
of copying mechanisms, F<handy.h> defines a platform-
C<independent> macro, Perl_va_copy(src, dst), to do the job.

=item C<netdb_hlen_type>

From F<netdbtype.U>:

This variable holds the type used for the 2nd argument to
gethostbyaddr().  Usually, this is int or size_t or unsigned.
This is only useful if you have gethostbyaddr(), naturally.

=item C<netdb_host_type>

From F<netdbtype.U>:

This variable holds the type used for the 1st argument to
gethostbyaddr().  Usually, this is char * or void *,  possibly
with or without a const prefix.
This is only useful if you have gethostbyaddr(), naturally.

=item C<netdb_name_type>

From F<netdbtype.U>:

This variable holds the type used for the argument to
gethostbyname().  Usually, this is char * or const char *.
This is only useful if you have gethostbyname(), naturally.

=item C<netdb_net_type>

From F<netdbtype.U>:

This variable holds the type used for the 1st argument to
getnetbyaddr().  Usually, this is int or long.
This is only useful if you have getnetbyaddr(), naturally.

=item C<nm>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the nm program.  After Configure runs,
the value is reset to a plain C<nm> and is not useful.

=item C<nm_opt>

From F<usenm.U>:

This variable holds the options that may be necessary for nm.

=item C<nm_so_opt>

From F<usenm.U>:

This variable holds the options that may be necessary for nm
to work on a shared library but that can not be used on an
archive library.  Currently, this is only used by Linux, where
nm --dynamic is *required* to get symbols from an C<ELF> library which
has been stripped, but nm --dynamic is *fatal* on an archive library.
Maybe Linux should just always set usenm=false.

=item C<nonxs_ext>

From F<Extensions.U>:

This variable holds a list of all non-xs extensions built and
installed by the package.  By default, all non-xs extensions
distributed will be built, with the exception of platform-specific
extensions (currently only one C<VMS> specific extension).

=item C<nroff>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the nroff program.  After Configure runs,
the value is reset to a plain C<nroff> and is not useful.

=item C<nv_overflows_integers_at>

From F<perlxv.U>:

This variable gives the largest integer value that NVs can hold
as a constant floating point expression.
If it could not be determined, it holds the value 0.

=item C<nv_preserves_uv_bits>

From F<perlxv.U>:

This variable indicates how many of bits type uvtype
a variable nvtype can preserve.

=item C<nveformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<NV> using %e-ish floating point format.

=item C<nvEUformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<NV> using %E-ish floating point format.

=item C<nvfformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<NV> using %f-ish floating point format.

=item C<nvFUformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<NV> using %F-ish floating point format.

=item C<nvgformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<NV> using %g-ish floating point format.

=item C<nvGUformat>

From F<perlxvf.U>:

This variable contains the format string used for printing
a Perl C<NV> using %G-ish floating point format.

=item C<nvsize>

From F<perlxv.U>:

This variable is the size of an C<NV> in bytes.

=item C<nvtype>

From F<perlxv.U>:

This variable contains the C type used for Perl's C<NV>.

=back

=cut

=head2 o

=over 4

=cut

=item C<o_nonblock>

From F<nblock_io.U>:

This variable bears the symbol value to be used during open() or fcntl()
to turn on non-blocking I/O for a file descriptor. If you wish to switch
between blocking and non-blocking, you may try ioctl(C<FIOSNBIO>) instead,
but that is only supported by some devices.

=item C<obj_ext>

From F<Unix.U>:

This is an old synonym for _o.

=item C<old_pthread_create_joinable>

From F<d_pthrattrj.U>:

This variable defines the constant to use for creating joinable
(aka undetached) pthreads.  Unused if F<pthread.h> defines
C<PTHREAD_CREATE_JOINABLE>.  If used, possible values are
C<PTHREAD_CREATE_UNDETACHED> and C<__UNDETACHED>.

=item C<optimize>

From F<ccflags.U>:

This variable contains any F<optimizer/debugger> flag that should be used.
It is up to the Makefile to use it.

=item C<orderlib>

From F<orderlib.U>:

This variable is C<true> if the components of libraries must be ordered
(with `lorder $* | tsort`) before placing them in an archive.  Set to
C<false> if ranlib or ar can generate random libraries.

=item C<osname>

From F<Oldconfig.U>:

This variable contains the operating system name (e.g. sunos,
solaris, hpux, etc.).  It can be useful later on for setting
defaults.  Any spaces are replaced with underscores.  It is set
to a null string if we can't figure it out.

=item C<osvers>

From F<Oldconfig.U>:

This variable contains the operating system version (e.g.
4.1.3, 5.2, etc.).  It is primarily used for helping select
an appropriate hints file, but might be useful elsewhere for
setting defaults.  It is set to '' if we can't figure it out.
We try to be flexible about how much of the version number
to keep, e.g. if 4.1.1, 4.1.2, and 4.1.3 are essentially the
same for this package, hints files might just be F<os_4.0> or
F<os_4.1>, etc., not keeping separate files for each little release.

=item C<otherlibdirs>

From F<otherlibdirs.U>:

This variable contains a colon-separated set of paths for the perl
binary to search for additional library files or modules.
These directories will be tacked to the end of @C<INC>.
Perl will automatically search below each path for version-
and architecture-specific directories.  See inc_version_list
for more details.
A value of C< > means C<none> and is used to preserve this value
for the next run through Configure.

=back

=cut

=head2 p

=over 4

=cut

=item C<package>

From F<package.U>:

This variable contains the name of the package being constructed.
It is primarily intended for the use of later Configure units.

=item C<pager>

From F<pager.U>:

This variable contains the name of the preferred pager on the system.
Usual values are (the full pathnames of) more, less, pg, or cat.

=item C<passcat>

From F<nis.U>:

This variable contains a command that produces the text of the
F</etc/passwd> file.  This is normally "cat F</etc/passwd>", but can be
"ypcat passwd" when C<NIS> is used.
On some systems, such as os390, there may be no equivalent
command, in which case this variable is unset.

=item C<patchlevel>

From F<patchlevel.U>:

The patchlevel level of this package.
The value of patchlevel comes from the F<patchlevel.h> file.
In a version number such as 5.6.1, this is the C<6>.
In F<patchlevel.h>, this is referred to as C<PERL_VERSION>.

=item C<path_sep>

From F<Unix.U>:

This is an old synonym for p_ in F<Head.U>, the character
used to separate elements in the command shell search C<PATH>.

=item C<perl>

From F<Loc.U>:

This variable is used internally by Configure to determine the
full pathname (if any) of the perl program.  After Configure runs,
the value is reset to a plain C<perl> and is not useful.

=item C<perl5>

From F<perl5.U>:

This variable contains the full path (if any) to a previously
installed F<perl5.005> or later suitable for running the script
to determine inc_version_list.

=back

=cut

=head2 P

=over 4

=cut

=item C<PERL_API_REVISION>

From F<patchlevel.h>:

This number describes the earliest compatible C<PERL_REVISION> of
Perl (C<compatibility> here being defined as sufficient F<binary/C<API>>
compatibility to run C<XS> code built with the older version).
Normally this does not change across maintenance releases.
Please read the comment in F<patchlevel.h>.

=item C<PERL_API_SUBVERSION>

From F<patchlevel.h>:

This number describes the earliest compatible C<PERL_SUBVERSION> of
Perl (C<compatibility> here being defined as sufficient F<binary/C<API>>
compatibility to run C<XS> code built with the older version).
Normally this does not change across maintenance releases.
Please read the comment in F<patchlevel.h>.

=item C<PERL_API_VERSION>

From F<patchlevel.h>:

This number describes the earliest compatible C<PERL_VERSION> of
Perl (C<compatibility> here being defined as sufficient F<binary/C<API>>
compatibili