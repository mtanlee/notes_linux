S,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_var.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET6_IN6_VAR_H_
#define	_NETINET6_IN6_VAR_H_
#include <sys/appleapiopts.h>

#include <netinet6/scope6_var.h>
#include <sys/kern_event.h>
#include <net/ethernet.h>

/*
 * pltime/vltime are just for future reference (required to implements 2
 * hour rule for hosts).  they should never be modified by nd6_timeout or
 * anywhere else.
 *	userland -> kernel: accept pltime/vltime
 *	kernel -> userland: throw up everything
 *	in kernel: modify preferred/expire only
 */
struct in6_addrlifetime {
	time_t ia6t_expire;	/* valid lifetime expiration time */
	time_t ia6t_preferred;	/* preferred lifetime expiration time */
	u_int32_t ia6t_vltime;	/* valid lifetime */
	u_int32_t ia6t_pltime;	/* prefix lifetime */
};


/* control structure to manage address selection policy */
struct in6_addrpolicy {
	struct sockaddr_in6 addr; /* prefix address */
	struct sockaddr_in6 addrmask; /* prefix mask */
	int preced;		/* precedence */
	int label;		/* matching label */
	u_quad_t use;		/* statistics */
};

/*
 * IPv6 interface statistics, as defined in RFC2465 Ipv6IfStatsEntry (p12).
 */
struct in6_ifstat {
	u_quad_t ifs6_in_receive;	/* # of total input datagram */
	u_quad_t ifs6_in_hdrerr;	/* # of datagrams with invalid hdr */
	u_quad_t ifs6_in_toobig;	/* # of datagrams exceeded MTU */
	u_quad_t ifs6_in_noroute;	/* # of datagrams with no route */
	u_quad_t ifs6_in_addrerr;	/* # of datagrams with invalid dst */
	u_quad_t ifs6_in_protounknown;	/* # of datagrams with unknown proto */
					/* NOTE: increment on final dst if */
	u_quad_t ifs6_in_truncated;	/* # of truncated datagrams */
	u_quad_t ifs6_in_discard;	/* # of discarded datagrams */
					/* NOTE: fragment timeout is not here */
	u_quad_t ifs6_in_deliver;	/* # of datagrams delivered to ULP */
					/* NOTE: increment on final dst if */
	u_quad_t ifs6_out_forward;	/* # of datagrams forwarded */
					/* NOTE: increment on outgoing if */
	u_quad_t ifs6_out_request;	/* # of outgoing datagrams from ULP */
					/* NOTE: does not include forwrads */
	u_quad_t ifs6_out_discard;	/* # of discarded datagrams */
	u_quad_t ifs6_out_fragok;	/* # of datagrams fragmented */
	u_quad_t ifs6_out_fragfail;	/* # of datagrams failed on fragment */
	u_quad_t ifs6_out_fragcreat;	/* # of fragment datagrams */
					/* NOTE: this is # after fragment */
	u_quad_t ifs6_reass_reqd;	/* # of incoming fragmented packets */
					/* NOTE: increment on final dst if */
	u_quad_t ifs6_reass_ok;		/* # of reassembled packets */
					/* NOTE: this is # after reass */
					/* NOTE: increment on final dst if */
	u_quad_t ifs6_reass_fail;	/* # of reass failures */
					/* NOTE: may not be packet count */
					/* NOTE: increment on final dst if */
	u_quad_t ifs6_in_mcast;		/* # of inbound multicast datagrams */
	u_quad_t ifs6_out_mcast;	/* # of outbound multicast datagrams */
};

/*
 * ICMPv6 interface statistics, as defined in RFC2466 Ipv6IfIcmpEntry.
 * XXX: I'm not sure if this file is the right place for this structure...
 */
struct icmp6_ifstat {
	/*
	 * Input statistics
	 */
	/* ipv6IfIcmpInMsgs, total # of input messages */
	u_quad_t ifs6_in_msg;
	/* ipv6IfIcmpInErrors, # of input error messages */
	u_quad_t ifs6_in_error;
	/* ipv6IfIcmpInDestUnreachs, # of input dest unreach errors */
	u_quad_t ifs6_in_dstunreach;
	/* ipv6IfIcmpInAdminProhibs, # of input admin. prohibited errs */
	u_quad_t ifs6_in_adminprohib;
	/* ipv6IfIcmpInTimeExcds, # of input time exceeded errors */
	u_quad_t ifs6_in_timeexceed;
	/* ipv6IfIcmpInParmProblems, # of input parameter problem errors */
	u_quad_t ifs6_in_paramprob;
	/* ipv6IfIcmpInPktTooBigs, # of input packet too big errors */
	u_quad_t ifs6_in_pkttoobig;
	/* ipv6IfIcmpInEchos, # of input echo requests */
	u_quad_t ifs6_in_echo;
	/* ipv6IfIcmpInEchoReplies, # of input echo replies */
	u_quad_t ifs6_in_echoreply;
	/* ipv6IfIcmpInRouterSolicits, # of input router solicitations */
	u_quad_t ifs6_in_routersolicit;
	/* ipv6IfIcmpInRouterAdvertisements, # of input router advertisements */
	u_quad_t ifs6_in_routeradvert;
	/* ipv6IfIcmpInNeighborSolicits, # of input neighbor solicitations */
	u_quad_t ifs6_in_neighborsolicit;
	/* ipv6IfIcmpInNeighborAdvertisements, # of input neighbor advs. */
	u_quad_t ifs6_in_neighboradvert;
	/* ipv6IfIcmpInRedirects, # of input redirects */
	u_quad_t ifs6_in_redirect;
	/* ipv6IfIcmpInGroupMembQueries, # of input MLD queries */
	u_quad_t ifs6_in_mldquery;
	/* ipv6IfIcmpInGroupMembResponses, # of input MLD reports */
	u_quad_t ifs6_in_mldreport;
	/* ipv6IfIcmpInGroupMembReductions, # of input MLD done */
	u_quad_t ifs6_in_mlddone;

	/*
	 * Output statistics. We should solve unresolved routing problem...
	 */
	/* ipv6IfIcmpOutMsgs, total # of output messages */
	u_quad_t ifs6_out_msg;
	/* ipv6IfIcmpOutErrors, # of output error messages */
	u_quad_t ifs6_out_error;
	/* ipv6IfIcmpOutDestUnreachs, # of output dest unreach errors */
	u_quad_t ifs6_out_dstunreach;
	/* ipv6IfIcmpOutAdminProhibs, # of output admin. prohibited errs */
	u_quad_t ifs6_out_adminprohib;
	/* ipv6IfIcmpOutTimeExcds, # of output time exceeded errors */
	u_quad_t ifs6_out_timeexceed;
	/* ipv6IfIcmpOutParmProblems, # of output parameter problem errors */
	u_quad_t ifs6_out_paramprob;
	/* ipv6IfIcmpOutPktTooBigs, # of output packet too big errors */
	u_quad_t ifs6_out_pkttoobig;
	/* ipv6IfIcmpOutEchos, # of output echo requests */
	u_quad_t ifs6_out_echo;
	/* ipv6IfIcmpOutEchoReplies, # of output echo replies */
	u_quad_t ifs6_out_echoreply;
	/* ipv6IfIcmpOutRouterSolicits, # of output router solicitations */
	u_quad_t ifs6_out_routersolicit;
	/* ipv6IfIcmpOutRouterAdvertisements, # of output router advs. */
	u_quad_t ifs6_out_routeradvert;
	/* ipv6IfIcmpOutNeighborSolicits, # of output neighbor solicitations */
	u_quad_t ifs6_out_neighborsolicit;
	/* ipv6IfIcmpOutNeighborAdvertisements, # of output neighbor advs. */
	u_quad_t ifs6_out_neighboradvert;
	/* ipv6IfIcmpOutRedirects, # of output redirects */
	u_quad_t ifs6_out_redirect;
	/* ipv6IfIcmpOutGroupMembQueries, # of output MLD queries */
	u_quad_t ifs6_out_mldquery;
	/* ipv6IfIcmpOutGroupMembResponses, # of output MLD reports */
	u_quad_t ifs6_out_mldreport;
	/* ipv6IfIcmpOutGroupMembReductions, # of output MLD done */
	u_quad_t ifs6_out_mlddone;
};

struct in6_ifreq {
	char	ifr_name[IFNAMSIZ];
	union {
		struct	sockaddr_in6 ifru_addr;
		struct	sockaddr_in6 ifru_dstaddr;
		int	ifru_flags;
		int	ifru_flags6;
		int	ifru_metric;
		int	ifru_intval;
		caddr_t	ifru_data;
		struct in6_addrlifetime ifru_lifetime;
		struct in6_ifstat ifru_stat;
		struct icmp6_ifstat ifru_icmp6stat;
		u_int32_t ifru_scope_id[SCOPE6_ID_MAX];
	} ifr_ifru;
};

struct in6_aliasreq {
	char	ifra_name[IFNAMSIZ];
	struct	sockaddr_in6 ifra_addr;
	struct	sockaddr_in6 ifra_dstaddr;
	struct	sockaddr_in6 ifra_prefixmask;
	int	ifra_flags;
	struct in6_addrlifetime ifra_lifetime;
};



/* prefix type macro */
#define	IN6_PREFIX_ND	1
#define	IN6_PREFIX_RR	2

/*
 * prefix related flags passed between kernel(NDP related part) and
 * user land command(ifconfig) and daemon(rtadvd).
 */
struct in6_prflags {
	struct prf_ra {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
	} prf_ra;
	u_char prf_reserved1;
	u_short prf_reserved2;
	/* want to put this on 4byte offset */
	struct prf_rr {
		u_char decrvalid : 1;
		u_char decrprefd : 1;
		u_char reserved : 6;
	} prf_rr;
	u_char prf_reserved3;
	u_short prf_reserved4;
};

struct  in6_prefixreq {
	char	ipr_name[IFNAMSIZ];
	u_char	ipr_origin;
	u_char	ipr_plen;
	u_int32_t ipr_vltime;
	u_int32_t ipr_pltime;
	struct in6_prflags ipr_flags;
	struct	sockaddr_in6 ipr_prefix;
};

#define	PR_ORIG_RA	0
#define	PR_ORIG_RR	1
#define	PR_ORIG_STATIC	2
#define	PR_ORIG_KERNEL	3

#define	ipr_raf_onlink		ipr_flags.prf_ra.onlink
#define	ipr_raf_auto		ipr_flags.prf_ra.autonomous

#define	ipr_statef_onlink	ipr_flags.prf_state.onlink

#define	ipr_rrf_decrvalid	ipr_flags.prf_rr.decrvalid
#define	ipr_rrf_decrprefd	ipr_flags.prf_rr.decrprefd

struct in6_rrenumreq {
	char	irr_name[IFNAMSIZ];
	u_char	irr_origin;
	u_char	irr_m_len;	/* match len for matchprefix */
	u_char	irr_m_minlen;	/* minlen for matching prefix */
	u_char	irr_m_maxlen;	/* maxlen for matching prefix */
	u_char	irr_u_uselen;	/* uselen for adding prefix */
	u_char	irr_u_keeplen;	/* keeplen from matching prefix */
	struct irr_raflagmask {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
	} irr_raflagmask;
	u_int32_t irr_vltime;
	u_int32_t irr_pltime;
	struct in6_prflags irr_flags;
	struct	sockaddr_in6 irr_matchprefix;
	struct	sockaddr_in6 irr_useprefix;
};

#define	irr_raf_mask_onlink	irr_raflagmask.onlink
#define	irr_raf_mask_auto	irr_raflagmask.autonomous
#define	irr_raf_mask_reserved	irr_raflagmask.reserved

#define	irr_raf_onlink		irr_flags.prf_ra.onlink
#define	irr_raf_auto		irr_flags.prf_ra.autonomous

#define	irr_statef_onlink	irr_flags.prf_state.onlink

#define	irr_rrf			irr_flags.prf_rr
#define	irr_rrf_decrvalid	irr_flags.prf_rr.decrvalid
#define	irr_rrf_decrprefd	irr_flags.prf_rr.decrprefd

/*
 * Event data, inet6 style.
 */
struct kev_in6_addrlifetime {
	u_int32_t ia6t_expire;
	u_int32_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};

struct kev_in6_data {
	struct net_event_data link_data;
	struct sockaddr_in6 ia_addr;	/* interface address */
	struct sockaddr_in6 ia_net;	/* network number of interface */
	struct sockaddr_in6 ia_dstaddr; /* space for destination addr */
	struct sockaddr_in6 ia_prefixmask; /* prefix mask */
	u_int32_t ia_plen;		/* prefix length */
	u_int32_t ia6_flags;		/* address flags from in6_ifaddr */
	struct kev_in6_addrlifetime ia_lifetime; /* address life info */
	uint8_t	ia_mac[ETHER_ADDR_LEN];
};

/*
 * Define inet6 event subclass and specific inet6 events.
 */
#define	KEV_INET6_SUBCLASS		6 /* inet6 subclass identifier */

#define	KEV_INET6_NEW_USER_ADDR		1 /* Userland configured IPv6 address */
#define	KEV_INET6_CHANGED_ADDR		2 /* Address changed event (future) */
#define	KEV_INET6_ADDR_DELETED		3 /* IPv6 address was deleted */
#define	KEV_INET6_NEW_LL_ADDR		4 /* Autoconf LL address appeared */
#define	KEV_INET6_NEW_RTADV_ADDR	5 /* Autoconf address has appeared */
#define	KEV_INET6_DEFROUTER		6 /* Default router detected */


#define	SIOCSIFADDR_IN6		 _IOW('i', 12, struct in6_ifreq)
#define	SIOCGIFADDR_IN6		_IOWR('i', 33, struct in6_ifreq)

/*
 * SIOCSxxx ioctls should be unused (see comments in in6.c), but
 * we do not shift numbers for binary compatibility.
 */
#define	SIOCSIFDSTADDR_IN6	_IOW('i', 14, struct in6_ifreq)
#define	SIOCSIFNETMASK_IN6	_IOW('i', 22, struct in6_ifreq)

#define	SIOCGIFDSTADDR_IN6	_IOWR('i', 34, struct in6_ifreq)
#define	SIOCGIFNETMASK_IN6	_IOWR('i', 37, struct in6_ifreq)

#define	SIOCDIFADDR_IN6		_IOW('i', 25, struct in6_ifreq)
#define	SIOCAIFADDR_IN6		_IOW('i', 26, struct in6_aliasreq)

#define	SIOCSIFPHYADDR_IN6	_IOW('i', 62, struct in6_aliasreq)
#define	SIOCGIFPSRCADDR_IN6	_IOWR('i', 63, struct in6_ifreq)
#define	SIOCGIFPDSTADDR_IN6	_IOWR('i', 64, struct in6_ifreq)
#define	SIOCGIFAFLAG_IN6	_IOWR('i', 73, struct in6_ifreq)

#define	SIOCGDRLST_IN6		_IOWR('i', 74, struct in6_drlist)

#define	SIOCGPRLST_IN6		_IOWR('i', 75, struct in6_prlist)

#define	OSIOCGIFINFO_IN6	_IOWR('i', 108, struct in6_ondireq)
#define	SIOCGIFINFO_IN6		_IOWR('i', 76, struct in6_ondireq)
#define	SIOCSNDFLUSH_IN6	_IOWR('i', 77, struct in6_ifreq)

#define	SIOCGNBRINFO_IN6	_IOWR('i', 78, struct in6_nbrinfo)

#define	SIOCSPFXFLUSH_IN6	_IOWR('i', 79, struct in6_ifreq)
#define	SIOCSRTRFLUSH_IN6	_IOWR('i', 80, struct in6_ifreq)

#define	SIOCGIFALIFETIME_IN6	_IOWR('i', 81, struct in6_ifreq)
#define	SIOCSIFALIFETIME_IN6	_IOWR('i', 82, struct in6_ifreq)
#define	SIOCGIFSTAT_IN6		_IOWR('i', 83, struct in6_ifreq)
#define	SIOCGIFSTAT_ICMP6	_IOWR('i', 84, struct in6_ifreq)

#define	SIOCSDEFIFACE_IN6	_IOWR('i', 85, struct in6_ndifreq)
#define	SIOCGDEFIFACE_IN6	_IOWR('i', 86, struct in6_ndifreq)

#define	SIOCSIFINFO_FLAGS	_IOWR('i', 87, struct in6_ndireq) /* XXX */

/* N.B.: These 3 ioctls are deprecated and won't work */
#define	SIOCSSCOPE6		_IOW('i', 88, struct in6_ifreq)
#define	SIOCGSCOPE6		_IOWR('i', 89, struct in6_ifreq)
#define	SIOCGSCOPE6DEF		_IOWR('i', 90, struct in6_ifreq)

#define	SIOCSIFPREFIX_IN6	_IOW('i', 100, struct in6_prefixreq) /* set */
#define	SIOCGIFPREFIX_IN6	_IOWR('i', 101, struct in6_prefixreq) /* get */
#define	SIOCDIFPREFIX_IN6	_IOW('i', 102, struct in6_prefixreq) /* del */
#define	SIOCAIFPREFIX_IN6	_IOW('i', 103, struct in6_rrenumreq) /* add */

/* change */
#define	SIOCCIFPREFIX_IN6	_IOW('i', 104, struct in6_rrenumreq)

/* set global */
#define	SIOCSGIFPREFIX_IN6	_IOW('i', 105, struct in6_rrenumreq)

/*
 * multicast routing, get s/g pkt cnt, pkt cnt per interface.
 */
#define	SIOCGETSGCNT_IN6	_IOWR('u', 28, struct sioc_sg_req6)
#define	SIOCGETMIFCNT_IN6	_IOWR('u', 107, struct sioc_mif_req6)

#define	SIOCAADDRCTL_POLICY	_IOW('u', 108, struct in6_addrpolicy)
#define	SIOCDADDRCTL_POLICY	_IOW('u', 109, struct in6_addrpolicy)


#define	IN6_IFF_ANYCAST		0x0001	/* anycast address */
#define	IN6_IFF_TENTATIVE	0x0002	/* tentative address */
#define	IN6_IFF_DUPLICATED	0x0004	/* DAD detected duplicate */
#define	IN6_IFF_DETACHED	0x0008	/* may be detached from the link */
#define	IN6_IFF_DEPRECATED	0x0010	/* deprecated address */

/* don't perform DAD on this address (used only at first SIOC* call) */
#define	IN6_IFF_NODAD		0x0020

#define	IN6_IFF_AUTOCONF	0x0040	/* autoconfigurable address. */
#define	IN6_IFF_TEMPORARY	0x0080	/* temporary (anonymous) address. */
#define	IN6_IFF_DYNAMIC		0x0100	/* assigned by DHCPv6 service */
#define	IN6_IFF_OPTIMISTIC	0x0200	/* optimistic DAD, i.e. RFC 4429 */
#define	IN6_IFF_SECURED		0x0400	/* cryptographically generated */
#define	IN6_IFF_NOPFX		0x8000	/* Depreciated. Don't use. */

/* Duplicate Address Detection [DAD] in progress. */
#define	IN6_IFF_DADPROGRESS	(IN6_IFF_TENTATIVE|IN6_IFF_OPTIMISTIC)

/* do not input/output */
#define	IN6_IFF_NOTREADY	(IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED)


#endif /* _NETINET6_IN6_VAR_H_ */
                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netinet6/ipcomp.h                                   0100644 0001750 0001750 00000004402 12567450751 022770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*	$FreeBSD: src/sys/netinet6/ipcomp.h,v 1.1.2.2 2001/07/03 11:01:54 ume Exp $	*/
/*	$KAME: ipcomp.h,v 1.8 2000/09/26 07:55:14 itojun Exp $	*/

/*
 * Copyright (C) 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * RFC2393 IP payload compression protocol (IPComp).
 */

#ifndef _NETINET6_IPCOMP_H_
#define _NETINET6_IPCOMP_H_
#include <sys/appleapiopts.h>
#include <netinet6/ipsec.h>

struct ipcomp {
	u_int8_t comp_nxt;	/* Next Header */
	u_int8_t comp_flags;	/* reserved, must be zero */
	u_int16_t comp_cpi;	/* Compression parameter index */
};

/* well-known algorithm number (in CPI), from RFC2409 */
#define IPCOMP_OUI	1	/* vendor specific */
#define IPCOMP_DEFLATE	2	/* RFC2394 */
#define IPCOMP_LZS	3	/* RFC2395 */
#define IPCOMP_MAX	4

#define IPCOMP_CPI_NEGOTIATE_MIN	256


#endif /* _NETINET6_IPCOMP_H_ */
                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netinet6/ipsec.h                                    0100644 0001750 0001750 00000013604 12567450751 022610  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*	$FreeBSD: src/sys/netinet6/ipsec.h,v 1.4.2.2 2001/07/03 11:01:54 ume Exp $	*/
/*	$KAME: ipsec.h,v 1.44 2001/03/23 08:08:47 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * IPsec controller part.
 */

#ifndef _NETINET6_IPSEC_H_
#define _NETINET6_IPSEC_H_
#include <sys/cdefs.h>
#include <sys/appleapiopts.h>

#include <net/pfkeyv2.h>

/* according to IANA assignment, port 0x0000 and proto 0xff are reserved. */
#define IPSEC_PORT_ANY		0
#define IPSEC_ULPROTO_ANY	255
#define IPSEC_PROTO_ANY		255

/* mode of security protocol */
/* NOTE: DON'T use IPSEC_MODE_ANY at SPD.  It's only use in SAD */
#define	IPSEC_MODE_ANY		0	/* i.e. wildcard. */
#define	IPSEC_MODE_TRANSPORT	1
#define	IPSEC_MODE_TUNNEL	2

/*
 * Direction of security policy.
 * NOTE: Since INVALID is used just as flag.
 * The other are used for loop counter too.
 */
#define IPSEC_DIR_ANY		0
#define IPSEC_DIR_INBOUND	1
#define IPSEC_DIR_OUTBOUND	2
#define IPSEC_DIR_MAX		3
#define IPSEC_DIR_INVALID	4

/* Policy level */
/*
 * IPSEC, ENTRUST and BYPASS are allowed for setsockopt() in PCB,
 * DISCARD, IPSEC and NONE are allowed for setkey() in SPD.
 * DISCARD and NONE are allowed for system default.
 */
#define IPSEC_POLICY_DISCARD	0	/* discarding packet */
#define IPSEC_POLICY_NONE	1	/* through IPsec engine */
#define IPSEC_POLICY_IPSEC	2	/* do IPsec */
#define IPSEC_POLICY_ENTRUST	3	/* consulting SPD if present. */
#define IPSEC_POLICY_BYPASS	4	/* only for privileged socket. */
#define IPSEC_POLICY_GENERATE   5       /* same as discard - IKE daemon can override with generated policy */

/* Security protocol level */
#define	IPSEC_LEVEL_DEFAULT	0	/* reference to system default */
#define	IPSEC_LEVEL_USE		1	/* use SA if present. */
#define	IPSEC_LEVEL_REQUIRE	2	/* require SA. */
#define	IPSEC_LEVEL_UNIQUE	3	/* unique SA. */

#define IPSEC_MANUAL_REQID_MAX	0x3fff
				/*
				 * if security policy level == unique, this id
				 * indicate to a relative SA for use, else is
				 * zero.
				 * 1 - 0x3fff are reserved for manual keying.
				 * 0 are reserved for above reason.  Others is
				 * for kernel use.
				 * Note that this id doesn't identify SA
				 * by only itself.
				 */
#define IPSEC_REPLAYWSIZE  32

/* statistics for ipsec processing */
struct ipsecstat {
	u_quad_t in_success __attribute__ ((aligned (8))); /* succeeded inbound process */
	u_quad_t in_polvio __attribute__ ((aligned (8)));
			/* security policy violation for inbound process */
	u_quad_t in_nosa __attribute__ ((aligned (8)));     /* inbound SA is unavailable */
	u_quad_t in_inval __attribute__ ((aligned (8)));    /* inbound processing failed due to EINVAL */
	u_quad_t in_nomem __attribute__ ((aligned (8)));    /* inbound processing failed due to ENOBUFS */
	u_quad_t in_badspi __attribute__ ((aligned (8)));   /* failed getting a SPI */
	u_quad_t in_ahreplay __attribute__ ((aligned (8))); /* AH replay check failed */
	u_quad_t in_espreplay __attribute__ ((aligned (8))); /* ESP replay check failed */
	u_quad_t in_ahauthsucc __attribute__ ((aligned (8))); /* AH authentication success */
	u_quad_t in_ahauthfail __attribute__ ((aligned (8))); /* AH authentication failure */
	u_quad_t in_espauthsucc __attribute__ ((aligned (8))); /* ESP authentication success */
	u_quad_t in_espauthfail __attribute__ ((aligned (8))); /* ESP authentication failure */
	u_quad_t in_esphist[256] __attribute__ ((aligned (8)));
	u_quad_t in_ahhist[256] __attribute__ ((aligned (8)));
	u_quad_t in_comphist[256] __attribute__ ((aligned (8)));
	u_quad_t out_success __attribute__ ((aligned (8))); /* succeeded outbound process */
	u_quad_t out_polvio __attribute__ ((aligned (8)));
			/* security policy violation for outbound process */
	u_quad_t out_nosa __attribute__ ((aligned (8)));    /* outbound SA is unavailable */
	u_quad_t out_inval __attribute__ ((aligned (8)));   /* outbound process failed due to EINVAL */
	u_quad_t out_nomem __attribute__ ((aligned (8)));    /* inbound processing failed due to ENOBUFS */
	u_quad_t out_noroute __attribute__ ((aligned (8))); /* there is no route */
	u_quad_t out_esphist[256] __attribute__ ((aligned (8)));
	u_quad_t out_ahhist[256] __attribute__ ((aligned (8)));
	u_quad_t out_comphist[256] __attribute__ ((aligned (8)));
};


__BEGIN_DECLS
extern caddr_t ipsec_set_policy(char *, int);
extern int ipsec_get_policylen(caddr_t);
extern char *ipsec_dump_policy(caddr_t, char *);

extern const char *ipsec_strerror(void);
__END_DECLS

#endif /* _NETINET6_IPSEC_H_ */
                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netinet6/nd6.h                                      0100644 0001750 0001750 00000015767 12567450752 022211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _NETINET6_ND6_H_
#define	_NETINET6_ND6_H_
#include <sys/appleapiopts.h>

/* see net/route.h, or net/if_inarp.h */
#ifndef RTF_ANNOUNCE
#define	RTF_ANNOUNCE	RTF_PROTO2
#endif

#include <sys/queue.h>


#define	ND6_LLINFO_PURGE	-3
#define	ND6_LLINFO_NOSTATE	-2
/*
 * We don't need the WAITDELETE state any more, but we keep the definition
 * in a comment line instead of removing it. This is necessary to avoid
 * unintentionally reusing the value for another purpose, which might
 * affect backward compatibility with old applications.
 * (20000711 jinmei@kame.net)
 */
/* #define	ND6_LLINFO_WAITDELETE	-1 */
#define	ND6_LLINFO_INCOMPLETE	0
#define	ND6_LLINFO_REACHABLE	1
#define	ND6_LLINFO_STALE	2
#define	ND6_LLINFO_DELAY	3
#define	ND6_LLINFO_PROBE	4


struct nd_ifinfo {
	u_int32_t linkmtu;		/* LinkMTU */
	u_int32_t maxmtu;		/* Upper bound of LinkMTU */
	u_int32_t basereachable;	/* BaseReachableTime */
	u_int32_t reachable;		/* Reachable Time */
	u_int32_t retrans;		/* Retrans Timer */
	u_int32_t flags;		/* Flags */
	int recalctm;			/* BaseReacable re-calculation timer */
	u_int8_t chlim;			/* CurHopLimit */
	u_int8_t receivedra;
	/* the following 3 members are for privacy extension for addrconf */
	u_int8_t randomseed0[8]; /* upper 64 bits of SHA1 digest */
	u_int8_t randomseed1[8]; /* lower 64 bits (usually the EUI64 IFID) */
	u_int8_t randomid[8];	/* current random ID */
};

#define	ND6_IFF_PERFORMNUD		0x1
#define	ND6_IFF_PROXY_PREFIXES		0x20
#define	ND6_IFF_IGNORE_NA		0x40
#define	ND6_IFF_REPLICATED		0x100	/* sleep proxy registered */

struct in6_nbrinfo {
	char ifname[IFNAMSIZ];	/* if name, e.g. "en0" */
	struct in6_addr addr;	/* IPv6 address of the neighbor */
	long	asked;		/* # of queries already sent for this addr */
	int	isrouter;	/* if it acts as a router */
	int	state;		/* reachability state */
	int	expire;		/* lifetime for NDP state transition */
};


#define	DRLSTSIZ 10
#define	PRLSTSIZ 10

struct	in6_drlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr rtaddr;
		u_char	flags;
		u_short	rtlifetime;
		u_long	expire;
		u_short if_index;
	} defrouter[DRLSTSIZ];
};


/* valid values for stateflags */
#define	NDDRF_INSTALLED	0x1	/* installed in the routing table */
#define	NDDRF_IFSCOPE	0x2	/* installed as a scoped route */
#define	NDDRF_STATIC	0x4	/* for internal use only */

struct	in6_defrouter {
	struct	sockaddr_in6 rtaddr;
	u_char	flags;
	u_char	stateflags;
	u_short	rtlifetime;
	u_long	expire;
	u_short if_index;
};


struct	in6_prlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr prefix;
		struct prf_ra raflags;
		u_char	prefixlen;
		u_char	origin;
		u_long	vltime;
		u_long	pltime;
		u_long	expire;
		u_short if_index;
		u_short advrtrs; /* number of advertisement routers */
		struct	in6_addr advrtr[DRLSTSIZ]; /* XXX: explicit limit */
	} prefix[PRLSTSIZ];
};


struct in6_prefix {
	struct	sockaddr_in6 prefix;
	struct prf_ra raflags;
	u_char	prefixlen;
	u_char	origin;
	u_long	vltime;
	u_long	pltime;
	u_long	expire;
	u_int32_t flags;
	int refcnt;
	u_short if_index;
	u_short advrtrs; /* number of advertisement routers */
	/* struct sockaddr_in6 advrtr[] */
};


struct	in6_ondireq {
	char ifname[IFNAMSIZ];
	struct {
		u_int32_t linkmtu;	/* LinkMTU */
		u_int32_t maxmtu;	/* Upper bound of LinkMTU */
		u_int32_t basereachable; /* BaseReachableTime */
		u_int32_t reachable;	/* Reachable Time */
		u_int32_t retrans;	/* Retrans Timer */
		u_int32_t flags;	/* Flags */
		int recalctm;		/* BaseReacable re-calculation timer */
		u_int8_t chlim;		/* CurHopLimit */
		u_int8_t receivedra;
	} ndi;
};

struct	in6_ndireq {
	char ifname[IFNAMSIZ];
	struct nd_ifinfo ndi;
};

struct	in6_ndifreq {
	char ifname[IFNAMSIZ];
	u_long ifindex;
};

#define	MAX_RTR_SOLICITATION_DELAY	1	/* 1sec */
#define	RTR_SOLICITATION_INTERVAL	4	/* 4sec */


/* Prefix status */
#define	NDPRF_ONLINK		0x1
#define	NDPRF_DETACHED		0x2
#define	NDPRF_STATIC		0x100
#define	NDPRF_IFSCOPE		0x1000
#define	NDPRF_PRPROXY		0x2000

/* protocol constants */
#define	MAX_RTR_SOLICITATION_DELAY	1	/* 1sec */
#define	RTR_SOLICITATION_INTERVAL	4	/* 4sec */
#define	MAX_RTR_SOLICITATIONS		3

#define	ND6_INFINITE_LIFETIME		0xffffffff
#define	ND6_MAX_LIFETIME		0x7fffffff





/* nd6_send.c */
#endif /* _NETINET6_ND6_H_ */
         osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netinet6/raw_ip6.h                                  0100644 0001750 0001750 00000007071 12567450751 023055  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*	$FreeBSD: src/sys/netinet6/raw_ip6.h,v 1.1.2.1 2001/07/03 11:01:55 ume Exp $	*/
/*	$KAME: raw_ip6.h,v 1.2 2001/05/27 13:28:35 itojun Exp $	*/

/*
 * Copyright (C) 2001 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _NETINET6_RAW_IP6_H_
#define _NETINET6_RAW_IP6_H_
#include <sys/appleapiopts.h>

/*
 * ICMPv6 stat is counted separately.  see netinet/icmp6.h
 */
struct rip6stat {
	u_quad_t rip6s_ipackets;	/* total input packets */
	u_quad_t rip6s_isum;		/* input checksum computations */
	u_quad_t rip6s_badsum;		/* of above, checksum error */
	u_quad_t rip6s_nosock;		/* no matching socket */
	u_quad_t rip6s_nosockmcast;	/* of above, arrived as multicast */
	u_quad_t rip6s_fullsock;	/* not delivered, input socket full */

	u_quad_t rip6s_opackets;	/* total output packets */
};

#endif /* _NETINET6_RAW_IP6_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netinet6/scope6_var.h                               0100644 0001750 0001750 00000006144 12567450751 023555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Copyright (C) 2000 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _NETINET6_SCOPE6_VAR_H_
#define _NETINET6_SCOPE6_VAR_H_
#include <sys/appleapiopts.h>

/*
 * 16 is correspondent to 4bit multicast scope field.
 * i.e. from node-local to global with some reserved/unassigned types.
 */
#define	SCOPE6_ID_MAX   16

#endif /* _NETINET6_SCOPE6_VAR_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netkey/                                             0040755 0001750 0001750 00000000000 12612224753 021066  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/netkey/keysock.h                                    0100644 0001750 0001750 00000005477 12567450753 022733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*	$KAME: keysock.h,v 1.7 2000/03/25 07:24:14 sumikawa Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _NETKEY_KEYSOCK_H_
#define _NETKEY_KEYSOCK_H_
#include <sys/appleapiopts.h>

/* statistics for pfkey socket */
struct pfkeystat {
	/* kernel -> userland */
	u_quad_t out_total;		/* # of total calls */
	u_quad_t out_bytes;		/* total bytecount */
	u_quad_t out_msgtype[256];	/* message type histogram */
	u_quad_t out_invlen;		/* invalid length field */
	u_quad_t out_invver;		/* invalid version field */
	u_quad_t out_invmsgtype;	/* invalid message type field */
	u_quad_t out_tooshort;		/* msg too short */
	u_quad_t out_nomem;		/* memory allocation failure */
	u_quad_t out_dupext;		/* duplicate extension */
	u_quad_t out_invexttype;	/* invalid extension type */
	u_quad_t out_invsatype;		/* invalid sa type */
	u_quad_t out_invaddr;		/* invalid address extension */
	/* userland -> kernel */
	u_quad_t in_total;		/* # of total calls */
	u_quad_t in_bytes;		/* total bytecount */
	u_quad_t in_msgtype[256];	/* message type histogram */
	u_quad_t in_msgtarget[3];	/* one/all/registered */
	u_quad_t in_nomem;		/* memory allocation failure */
	/* others */
	u_quad_t sockerr;		/* # of socket related errors */
};

#define KEY_SENDUP_ONE		0
#define KEY_SENDUP_ALL		1
#define KEY_SENDUP_REGISTERED	2


#endif /*_NETKEY_KEYSOCK_H_*/
                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/                                                0040755 0001750 0001750 00000000000 12612224753 020355  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/krpc.h                                          0100644 0001750 0001750 00000005260 12567450753 021477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */

#ifndef __NFS_KRPC_H__
#define __NFS_KRPC_H__

#include <sys/appleapiopts.h>

#include <sys/cdefs.h>

#ifdef __APPLE_API_PRIVATE
int krpc_call(struct sockaddr_in *sin, u_int sotype,
	u_int prog, u_int vers, u_int func,
	mbuf_t *data, struct sockaddr_in *from);

int krpc_portmap(struct sockaddr_in *sin,
	u_int prog, u_int vers, u_int proto, u_int16_t *portp);


/*
 * RPC definitions for the portmapper (portmap and rpcbind)
 */
#define	PMAPPORT		111
#define	PMAPPROG		100000
#define	PMAPVERS		2
#define	PMAPPROC_NULL		0
#define	PMAPPROC_SET		1
#define	PMAPPROC_UNSET		2
#define	PMAPPROC_GETPORT	3
#define	PMAPPROC_DUMP		4
#define	PMAPPROC_CALLIT		5

#define RPCBPROG		PMAPPROG
#define RPCBVERS3		3
#define RPCBVERS4		4
#define RPCBPROC_NULL		0
#define RPCBPROC_SET		1
#define RPCBPROC_UNSET		2
#define RPCBPROC_GETADDR	3
#define RPCBPROC_DUMP		4
#define RPCBPROC_CALLIT		5
#define RPCBPROC_BCAST		RPCBPROC_CALLIT
#define RPCBPROC_GETTIME	6
#define RPCBPROC_UADDR2TADDR	7
#define RPCBPROC_TADDR2UADDR	8
#define RPCBPROC_GETVERSADDR	9
#define RPCBPROC_INDIRECT	10
#define RPCBPROC_GETADDRLIST	11
#define RPCBPROC_GETSTAT	12


/*
 * RPC definitions for bootparamd
 */
#define	BOOTPARAM_PROG		100026
#define	BOOTPARAM_VERS		1
#define BOOTPARAM_WHOAMI	1
#define BOOTPARAM_GETFILE	2

#endif /* __APPLE_API_PRIVATE */
#endif /* __NFS_KRPC_H__ */
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfs.h                                           0100644 0001750 0001750 00000053173 12567450753 021334  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs.h	8.4 (Berkeley) 5/1/95
 * FreeBSD-Id: nfs.h,v 1.32 1997/10/12 20:25:38 phk Exp $
 */

#ifndef _NFS_NFS_H_
#define _NFS_NFS_H_

#include <sys/appleapiopts.h>
#include <sys/cdefs.h>

#ifdef __APPLE_API_PRIVATE
/*
 * Tunable constants for nfs
 */

#define NFS_TICKINTVL	5		/* Desired time for a tick (msec) */
#define NFS_HZ		(hz / nfs_ticks) /* Ticks/sec */
extern int nfs_ticks;
#define	NFS_TIMEO	(1 * NFS_HZ)	/* Default timeout = 1 second */
#define	NFS_MINTIMEO	(1 * NFS_HZ)	/* Min timeout to use */
#define	NFS_MAXTIMEO	(60 * NFS_HZ)	/* Max timeout to backoff to */
#define	NFS_MINIDEMTIMEO (5 * NFS_HZ)	/* Min timeout for non-idempotent ops*/
#define	NFS_MAXREXMIT	100		/* Stop counting after this many */
#define	NFS_RETRANS	10		/* Num of retrans for soft mounts */
#define	NFS_TRYLATERDEL	4		/* Initial try later delay (sec) */
#define	NFS_MAXGRPS	16U		/* Max. size of groups list */
#define	NFS_MINATTRTIMO 5		/* Attribute cache timeout in sec */
#define	NFS_MAXATTRTIMO 60
#define	NFS_MINDIRATTRTIMO 5		/* directory attribute cache timeout in sec */
#define	NFS_MAXDIRATTRTIMO 60
#define	NFS_IOSIZE	(1024 * 1024)	/* suggested I/O size */
#define	NFS_RWSIZE	32768		/* Def. read/write data size <= 32K */
#define	NFS_WSIZE	NFS_RWSIZE	/* Def. write data size <= 32K */
#define	NFS_RSIZE	NFS_RWSIZE	/* Def. read data size <= 32K */
#define	NFS_DGRAM_WSIZE	8192		/* UDP Def. write data size <= 8K */
#define	NFS_DGRAM_RSIZE	8192		/* UDP Def. read data size <= 8K */
#define NFS_READDIRSIZE	32768		/* Def. readdir size */
#define	NFS_DEFRAHEAD	16		/* Def. read ahead # blocks */
#define	NFS_MAXRAHEAD	128		/* Max. read ahead # blocks */
#define	NFS_DEFMAXASYNCWRITES 	128	/* Def. max # concurrent async write RPCs */
#define	NFS_DEFASYNCTHREAD 	16	/* Def. # nfsiod threads */
#define	NFS_MAXASYNCTHREAD 	64	/* max # nfsiod threads */
#define	NFS_ASYNCTHREADMAXIDLE	60	/* Seconds before idle nfsiods are reaped */
#define	NFS_DEFSTATFSRATELIMIT 	10	/* Def. max # statfs RPCs per second */
#define NFS_REQUESTDELAY	10	/* ms interval to check request queue */
#define NFSRV_MAXWGATHERDELAY	100	/* Max. write gather delay (msec) */
#ifndef NFSRV_WGATHERDELAY
#define NFSRV_WGATHERDELAY	1	/* Default write gather delay (msec) */
#endif
#define	NFS_DIRBLKSIZ	4096		/* size of NFS directory buffers */

/* default values for unresponsive mount timeouts */
#define NFS_TPRINTF_INITIAL_DELAY	12
#define NFS_TPRINTF_DELAY		30

/*
 * Oddballs
 */
#define NFS_CMPFH(n, f, s) \
	((n)->n_fhsize == (s) && !bcmp((caddr_t)(n)->n_fhp, (caddr_t)(f), (s)))
#define NFSRV_NDMAXDATA(n) \
		(((n)->nd_vers == NFS_VER3) ? (((n)->nd_nam2) ? \
		 NFS_MAXDGRAMDATA : NFSRV_MAXDATA) : NFS_V2MAXDATA)

/*
 * The IO_METASYNC flag should be implemented for local file systems.
 * (Until then, it is nothin at all.)
 */
#ifndef IO_METASYNC
#define IO_METASYNC	0
#endif

/*
 * Expected allocation sizes for major data structures. If the actual size
 * of the structure exceeds these sizes, then malloc() will be allocating
 * almost twice the memory required. This is used in nfs_init() to warn
 * the sysadmin that the size of a structure should be reduced.
 * (These sizes are always a power of 2. If the kernel malloc() changes
 *  to one that does not allocate space in powers of 2 size, then this all
 *  becomes bunk!).
 * Note that some of these structures come out of their own nfs zones.
 */
#define NFS_NODEALLOC	1024
#define NFS_MNTALLOC	1024
#define NFS_SVCALLOC	512

#define NFS_ARGSVERSION_XDR	88	/* NFS mount args are in XDR format */

#define NFS_XDRARGS_VERSION_0	0
#define NFS_MATTR_BITMAP_LEN	1		/* length of mount attributes bitmap */
#define NFS_MFLAG_BITMAP_LEN	1		/* length of mount flags bitmap */

/* NFS mount attributes */
#define NFS_MATTR_FLAGS			0	/* mount flags (NFS_MATTR_*) */
#define NFS_MATTR_NFS_VERSION		1	/* NFS protocol version */
#define NFS_MATTR_NFS_MINOR_VERSION	2	/* NFS protocol minor version */
#define NFS_MATTR_READ_SIZE		3	/* READ RPC size */
#define NFS_MATTR_WRITE_SIZE		4	/* WRITE RPC size */
#define NFS_MATTR_READDIR_SIZE		5	/* READDIR RPC size */
#define NFS_MATTR_READAHEAD		6	/* block readahead count */
#define NFS_MATTR_ATTRCACHE_REG_MIN	7	/* minimum attribute cache time */
#define NFS_MATTR_ATTRCACHE_REG_MAX	8	/* maximum attribute cache time */
#define NFS_MATTR_ATTRCACHE_DIR_MIN	9	/* minimum attribute cache time for dirs */
#define NFS_MATTR_ATTRCACHE_DIR_MAX	10	/* maximum attribute cache time for dirs */
#define NFS_MATTR_LOCK_MODE		11	/* advisory file locking mode (NFS_LOCK_MODE_*) */
#define NFS_MATTR_SECURITY		12	/* RPC security flavors to use */
#define NFS_MATTR_MAX_GROUP_LIST	13	/* max # of RPC AUTH_SYS groups */
#define NFS_MATTR_SOCKET_TYPE		14	/* socket transport type as a netid-like string */
#define NFS_MATTR_NFS_PORT		15	/* port # to use for NFS protocol */
#define NFS_MATTR_MOUNT_PORT		16	/* port # to use for MOUNT protocol */
#define NFS_MATTR_REQUEST_TIMEOUT	17	/* initial RPC request timeout value */
#define NFS_MATTR_SOFT_RETRY_COUNT	18	/* max RPC retransmissions for soft mounts */
#define NFS_MATTR_DEAD_TIMEOUT		19	/* how long until unresponsive mount is considered dead */
#define NFS_MATTR_FH			20	/* file handle for mount directory */
#define NFS_MATTR_FS_LOCATIONS		21	/* list of locations for the file system */
#define NFS_MATTR_MNTFLAGS		22	/* VFS mount flags (MNT_*) */
#define NFS_MATTR_MNTFROM		23	/* fixed string to use for "f_mntfromname" */
#define NFS_MATTR_REALM			24	/* Realm to authenticate with */
#define NFS_MATTR_PRINCIPAL		25	/* GSS principal to authenticate with */
#define NFS_MATTR_SVCPRINCIPAL		26	/* GSS principal to authenticate to, the server principal */
#define NFS_MATTR_NFS_VERSION_RANGE	27	/* Packed version range to try */

/* NFS mount flags */
#define NFS_MFLAG_SOFT			0	/* soft mount (requests fail if unresponsive) */
#define NFS_MFLAG_INTR			1	/* allow operations to be interrupted */
#define NFS_MFLAG_RESVPORT		2	/* use a reserved port */
#define NFS_MFLAG_NOCONNECT		3	/* don't connect the socket (UDP) */
#define NFS_MFLAG_DUMBTIMER		4	/* don't estimate RTT dynamically */
#define NFS_MFLAG_CALLUMNT		5	/* call MOUNTPROC_UMNT on unmount */
#define NFS_MFLAG_RDIRPLUS		6	/* request additional info when reading directories */
#define NFS_MFLAG_NONEGNAMECACHE	7	/* don't do negative name caching */
#define NFS_MFLAG_MUTEJUKEBOX		8	/* don't treat jukebox errors as unresponsive */
#define NFS_MFLAG_EPHEMERAL		9	/* ephemeral (mirror) mount */
#define NFS_MFLAG_NOCALLBACK		10	/* don't provide callback RPC service */
#define NFS_MFLAG_NONAMEDATTR		11	/* don't use named attributes */
#define NFS_MFLAG_NOACL			12	/* don't support ACLs */
#define NFS_MFLAG_ACLONLY		13	/* only support ACLs - not mode */
#define NFS_MFLAG_NFC			14	/* send NFC strings */
#define NFS_MFLAG_NOQUOTA		15	/* don't support QUOTA requests */
#define NFS_MFLAG_MNTUDP		16	/* MOUNT protocol should use UDP */
#define NFS_MFLAG_MNTQUICK		17	/* use short timeouts while mounting */

/* Macros for packing and unpacking packed versions */
#define PVER2MAJOR(M) ((uint32_t)(((M) >> 16) & 0xffff))
#define PVER2MINOR(m) ((uint32_t)((m) & 0xffff))
#define VER2PVER(M, m) ((uint32_t)((M) << 16) | ((m) & 0xffff))

/* NFS advisory file locking modes */
#define NFS_LOCK_MODE_ENABLED		0	/* advisory file locking enabled */
#define NFS_LOCK_MODE_DISABLED		1	/* do not support advisory file locking */
#define NFS_LOCK_MODE_LOCAL		2	/* perform advisory file locking locally */

/*
 * Old-style arguments to mount NFS
 */
#define NFS_ARGSVERSION	6		/* change when nfs_args changes */
struct nfs_args {
	int		version;	/* args structure version number */
	struct sockaddr	*addr;		/* file server address */
	int		addrlen;	/* length of address */
	int		sotype;		/* Socket type */
	int		proto;		/* and Protocol */
	u_char		*fh;		/* File handle to be mounted */
	int		fhsize;		/* Size, in bytes, of fh */
	int		flags;		/* flags */
	int		wsize;		/* write size in bytes */
	int		rsize;		/* read size in bytes */
	int		readdirsize;	/* readdir size in bytes */
	int		timeo;		/* initial timeout in .1 secs */
	int		retrans;	/* times to retry send */
	int		maxgrouplist;	/* Max. size of group list */
	int		readahead;	/* # of blocks to readahead */
	int		leaseterm;	/* obsolete: Term (sec) of lease */
	int		deadthresh;	/* obsolete: Retrans threshold */
	char		*hostname;	/* server's name */
	/* NFS_ARGSVERSION 3 ends here */
	int		acregmin;	/* reg file min attr cache timeout */
	int		acregmax;	/* reg file max attr cache timeout */
	int		acdirmin;	/* dir min attr cache timeout */
	int		acdirmax;	/* dir max attr cache timeout */
	/* NFS_ARGSVERSION 4 ends here */
	uint32_t	auth;		/* security mechanism flavor */
	/* NFS_ARGSVERSION 5 ends here */
	uint32_t	deadtimeout;	/* secs until unresponsive mount considered dead */
};

/* incremental size additions in each version of nfs_args */
#define NFS_ARGSVERSION4_INCSIZE	(4 * sizeof(int))
#define NFS_ARGSVERSION5_INCSIZE	(sizeof(uint32_t))
#define NFS_ARGSVERSION6_INCSIZE	(sizeof(uint32_t))


/*
 * Old-style NFS mount option flags
 */
#define	NFSMNT_SOFT		0x00000001  /* soft mount (hard is default) */
#define	NFSMNT_WSIZE		0x00000002  /* set write size */
#define	NFSMNT_RSIZE		0x00000004  /* set read size */
#define	NFSMNT_TIMEO		0x00000008  /* set initial timeout */
#define	NFSMNT_RETRANS		0x00000010  /* set number of request retries */
#define	NFSMNT_MAXGRPS		0x00000020  /* set maximum grouplist size */
#define	NFSMNT_INT		0x00000040  /* allow interrupts on hard mount */
#define	NFSMNT_NOCONN		0x00000080  /* Don't Connect the socket */
#define	NFSMNT_NONEGNAMECACHE	0x00000100  /* Don't do negative name caching */
#define	NFSMNT_NFSV3		0x00000200  /* Use NFS Version 3 protocol */
#define	NFSMNT_NFSV4		0x00000400  /* Use NFS Version 4 protocol */
#define	NFSMNT_DUMBTIMR		0x00000800  /* Don't estimate rtt dynamically */
#define	NFSMNT_DEADTIMEOUT	0x00001000  /* unmount after a period of unresponsiveness */
#define	NFSMNT_READAHEAD	0x00002000  /* set read ahead */
#define	NFSMNT_CALLUMNT		0x00004000  /* call MOUNTPROC_UMNT on unmount */
#define	NFSMNT_RESVPORT		0x00008000  /* Allocate a reserved port */
#define	NFSMNT_RDIRPLUS		0x00010000  /* Use Readdirplus for V3 */
#define	NFSMNT_READDIRSIZE	0x00020000  /* Set readdir size */
#define	NFSMNT_NOLOCKS		0x00040000  /* don't support file locking */
#define	NFSMNT_LOCALLOCKS	0x00080000  /* do file locking locally on client */
#define	NFSMNT_ACREGMIN		0x00100000  /* reg min attr cache timeout */
#define	NFSMNT_ACREGMAX		0x00200000  /* reg max attr cache timeout */
#define	NFSMNT_ACDIRMIN		0x00400000  /* dir min attr cache timeout */
#define	NFSMNT_ACDIRMAX		0x00800000  /* dir max attr cache timeout */
#define	NFSMNT_SECFLAVOR	0x01000000  /* Use security flavor */
#define	NFSMNT_SECSYSOK		0x02000000  /* Server can support auth sys */
#define	NFSMNT_MUTEJUKEBOX	0x04000000  /* don't treat jukebox errors as unresponsive */
#define	NFSMNT_NOQUOTA		0x08000000  /* don't support QUOTA requests */


/*
 * fs.nfs sysctl(3) NFS_MOUNTINFO defines
 */
#define NFS_MOUNT_INFO_VERSION	0	/* nfsstat mount information version */
#define NFS_MIATTR_BITMAP_LEN	1	/* length of mount info attributes bitmap */
#define NFS_MIFLAG_BITMAP_LEN	1	/* length of mount info flags bitmap */

/* NFS mount info attributes */
#define NFS_MIATTR_FLAGS		0	/* mount info flags bitmap (MIFLAG_*) */
#define NFS_MIATTR_ORIG_ARGS		1	/* original mount args passed into mount call */
#define NFS_MIATTR_CUR_ARGS 		2	/* current mount args values */
#define NFS_MIATTR_CUR_LOC_INDEX	3	/* current fs location index */

/* NFS mount info flags */
#define NFS_MIFLAG_DEAD		0	/* mount is dead */
#define NFS_MIFLAG_NOTRESP	1	/* server is unresponsive */
#define NFS_MIFLAG_RECOVERY	2	/* mount in recovery */


/*
 * Structures for the nfssvc(2) syscall. Not that anyone but nfsd
 * should ever try and use it.
 */
struct nfsd_args {
	int	sock;		/* Socket to serve */
	caddr_t	name;		/* Client addr for connection based sockets */
	int	namelen;	/* Length of name */
};


/*
 * NFS Server File Handle structures
 */

/* NFS export handle identifies which NFS export */
#define	NFS_FH_VERSION	0x4e580000		/* 'NX00' */
struct nfs_exphandle {
	uint32_t	nxh_version;		/* data structure version */
	uint32_t	nxh_fsid;		/* File System Export ID */
	uint32_t	nxh_expid;		/* Export ID */
	uint16_t	nxh_flags;		/* export handle flags */
	uint8_t		nxh_reserved;		/* future use */
	uint8_t		nxh_fidlen;		/* length of File ID */
};

/* nxh_flags */
#define NXHF_INVALIDFH		0x0001		/* file handle is invalid */

#define	NFS_MAX_FID_SIZE	(NFS_MAX_FH_SIZE - sizeof(struct nfs_exphandle))
#define	NFSV4_MAX_FID_SIZE	(NFSV4_MAX_FH_SIZE - sizeof(struct nfs_exphandle))
#define	NFSV3_MAX_FID_SIZE	(NFSV3_MAX_FH_SIZE - sizeof(struct nfs_exphandle))
#define	NFSV2_MAX_FID_SIZE	(NFSV2_MAX_FH_SIZE - sizeof(struct nfs_exphandle))

/* NFS server internal view of fhandle_t */
/* The first sizeof(fhandle_t) bytes must match what goes into fhandle_t. */
/* (fhp is used to allow use of an external buffer) */
struct nfs_filehandle {
	uint32_t		nfh_len;	/* total length of file handle */
	struct nfs_exphandle	nfh_xh;		/* export handle */
	unsigned char		nfh_fid[NFS_MAX_FID_SIZE]; /* File ID */
	unsigned char		*nfh_fhp;	/* pointer to file handle */
};

/*
 * NFS export data structures
 */

/* Structure to hold an array of security flavors */
#define NX_MAX_SEC_FLAVORS 5
struct nfs_sec {
	int count;
	uint32_t flavors[NX_MAX_SEC_FLAVORS];
}; 

struct nfs_export_net_args {
	uint32_t		nxna_flags;	/* export flags */
	struct xucred		nxna_cred;	/* mapped credential for root/all user */
	struct sockaddr_storage	nxna_addr;	/* net address to which exported */
	struct sockaddr_storage	nxna_mask;	/* mask for net address */
	struct nfs_sec		nxna_sec;	/* security mechanism flavors */
};

struct nfs_export_args {
	uint32_t		nxa_fsid;	/* export FS ID */
	uint32_t		nxa_expid;	/* export ID */
	char			*nxa_fspath;	/* export FS path */
	char			*nxa_exppath;	/* export sub-path */
	uint32_t		nxa_flags;	/* export arg flags */
	uint32_t		nxa_netcount;	/* #entries in ex_nets array */
	struct nfs_export_net_args *nxa_nets;	/* array of net args */
};


/* nfs export arg flags */
#define NXA_DELETE		0x0001	/* delete the specified export(s) */
#define NXA_ADD			0x0002	/* add the specified export(s) */
#define NXA_REPLACE		0x0003	/* delete and add the specified export(s) */
#define NXA_DELETE_ALL		0x0004	/* delete all exports */
#define NXA_OFFLINE		0x0008	/* export is offline */
#define NXA_CHECK		0x0010	/* check if exportable */

/* export option flags */
#define NX_READONLY		0x0001	/* exported read-only */
#define NX_DEFAULTEXPORT	0x0002	/* exported to the world */
#define NX_MAPROOT		0x0004	/* map root access to anon credential */
#define NX_MAPALL		0x0008	/* map all access to anon credential */
#define NX_32BITCLIENTS		0x0020	/* restrict directory cookies to 32 bits */
#define NX_OFFLINE		0x0040	/* export is offline */
#define NX_MANGLEDNAMES		0x0080	/* export will return mangled names for names > 255 bytes */

/*
 * fs.nfs sysctl(3) export stats record structures
 */
#define NFS_EXPORT_STAT_REC_VERSION 1	/* export stat record version */
#define NFS_USER_STAT_REC_VERSION 1     /* active user list record version */

/* descriptor describing following records */
struct nfs_export_stat_desc
{
	uint32_t rec_vers;		/* version of export stat records */
	uint32_t rec_count;		/* total record count */
}__attribute__((__packed__));

/* export stat record containing path and stat counters */
struct nfs_export_stat_rec {
	char     path[RPCMNT_PATHLEN + 1];
	uint64_t ops;		/* Count of NFS Requests received for this export */
	uint64_t bytes_read;	/* Count of bytes read from this export */
	uint64_t bytes_written;	/* Count of bytes written to this export */
}__attribute__((__packed__));

/* Active user list stat buffer descriptor */
struct nfs_user_stat_desc
{
	uint32_t rec_vers;	/* version of active user stat records */
	uint32_t rec_count;	/* total record count */
}__attribute__((__packed__));

/* Active user list user stat record format */
struct nfs_user_stat_user_rec {
	u_char			rec_type;
	uid_t			uid;
	struct sockaddr_storage	sock;
	uint64_t		ops;
	uint64_t		bytes_read;
	uint64_t		bytes_written;
	uint32_t		tm_start;
	uint32_t		tm_last;
}__attribute__((__packed__));

/* Active user list path record format */
struct nfs_user_stat_path_rec {
	u_char	rec_type;
	char	path[RPCMNT_PATHLEN + 1];
}__attribute__((__packed__));

/* Defines for rec_type field of
 * nfs_user_stat_rec & nfs_user_stat_rec
 * data structures
 */
#define NFS_USER_STAT_USER_REC  0
#define NFS_USER_STAT_PATH_REC  1



/*
 * XXX to allow amd to include nfs.h without nfsproto.h
 */
#ifdef NFS_NPROCS
/*
 * Stats structure
 */
struct nfsstats {
	uint64_t	attrcache_hits;
	uint64_t	attrcache_misses;
	uint64_t	lookupcache_hits;
	uint64_t	lookupcache_misses;
	uint64_t	direofcache_hits;
	uint64_t	direofcache_misses;
	uint64_t	biocache_reads;
	uint64_t	read_bios;
	uint64_t	read_physios;
	uint64_t	biocache_writes;
	uint64_t	write_bios;
	uint64_t	write_physios;
	uint64_t	biocache_readlinks;
	uint64_t	readlink_bios;
	uint64_t	biocache_readdirs;
	uint64_t	readdir_bios;
	uint64_t	rpccnt[NFS_NPROCS];
	uint64_t	rpcretries;
	uint64_t	srvrpccnt[NFS_NPROCS];
	uint64_t	srvrpc_errs;
	uint64_t	srv_errs;
	uint64_t	rpcrequests;
	uint64_t	rpctimeouts;
	uint64_t	rpcunexpected;
	uint64_t	rpcinvalid;
	uint64_t	srvcache_inproghits;
	uint64_t	srvcache_idemdonehits;
	uint64_t	srvcache_nonidemdonehits;
	uint64_t	srvcache_misses;
	uint64_t	srvvop_writes;
	uint64_t	pageins;
	uint64_t	pageouts;
};
#endif

/*
 * Flags for nfssvc() system call.
 */
#define	NFSSVC_NFSD	0x004
#define	NFSSVC_ADDSOCK	0x008
#define	NFSSVC_EXPORT	0x200

/*
 * Flags for nfsclnt() system call.
 */
#define NFSCLNT_LOCKDANS	0x200
#define NFSCLNT_LOCKDNOTIFY	0x400
#define NFSCLNT_TESTIDMAP	0x001

#include <sys/_types/_guid_t.h> /* for guid_t below */
#define MAXIDNAMELEN		1024
struct nfs_testmapid {
	uint32_t		ntm_name2id;	/* lookup name 2 id or id 2 name */
	uint32_t		ntm_grpflag;	/* Is this a group or user maping */
	uint32_t		ntm_id;		/* id to map or return */
	uint32_t		pad;	
	guid_t			ntm_guid;	/* intermidiate guid used in conversion */
	char			ntm_name[MAXIDNAMELEN]; /* name to map or return */
};
	
/*
 * fs.nfs sysctl(3) identifiers
 */
#define NFS_NFSSTATS	1	/* struct: struct nfsstats */
#define NFS_EXPORTSTATS 3	/* gets exported directory stats */
#define NFS_USERSTATS	4	/* gets exported directory active user stats */
#define NFS_USERCOUNT	5	/* gets current count of active nfs users */
#define NFS_MOUNTINFO	6	/* gets information about an NFS mount */

#ifndef NFS_WDELAYHASHSIZ
#define	NFS_WDELAYHASHSIZ 16	/* and with this */
#endif

#endif /* __APPLE_API_PRIVATE */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfs_gss.h                                       0100644 0001750 0001750 00000023013 12567450754 022177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2007-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _NFS_NFS_GSS_H_
#define _NFS_NFS_GSS_H_

#include <gssd/gssd_mach.h>
#include <sys/param.h>
#include <nfs/nfs_ioctl.h>
#include <libkern/crypto/des.h>

#define RPCSEC_GSS			6
#define	RPCSEC_GSS_VERS_1		1

enum rpcsec_gss_proc {
	RPCSEC_GSS_DATA			= 0,
	RPCSEC_GSS_INIT			= 1,
	RPCSEC_GSS_CONTINUE_INIT	= 2,
	RPCSEC_GSS_DESTROY		= 3
};

enum rpcsec_gss_service {
	RPCSEC_GSS_SVC_NONE		= 1,	// sec=krb5
	RPCSEC_GSS_SVC_INTEGRITY	= 2,	// sec=krb5i
	RPCSEC_GSS_SVC_PRIVACY		= 3,	// sec=krb5p
};

/* encoded krb5 OID */
extern u_char krb5_mech[11];

/*
 * GSS-API things
 */
typedef uint32_t OM_uint32;

#define GSS_S_COMPLETE			0
#define GSS_S_CONTINUE_NEEDED		1

/*
 * Some "helper" definitions to make the status code macros obvious.
 * From gssapi.h:
 */
#define GSS_C_CALLING_ERROR_OFFSET 24
#define GSS_C_ROUTINE_ERROR_OFFSET 16
#define GSS_C_SUPPLEMENTARY_OFFSET 0
#define GSS_C_CALLING_ERROR_MASK ((OM_uint32) 0377ul)
#define GSS_C_ROUTINE_ERROR_MASK ((OM_uint32) 0377ul)
#define GSS_C_SUPPLEMENTARY_MASK ((OM_uint32) 0177777ul)

/*
 * The macros that test status codes for error conditions.  Note that the
 * GSS_ERROR() macro has changed slightly from the V1 GSSAPI so that it now
 * evaluates its argument only once.
 */
#define GSS_CALLING_ERROR(x) \
	((x) & (GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET))
#define GSS_ROUTINE_ERROR(x) \
	((x) & (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET))
#define GSS_SUPPLEMENTARY_INFO(x) \
	((x) & (GSS_C_SUPPLEMENTARY_MASK << GSS_C_SUPPLEMENTARY_OFFSET))
#define GSS_ERROR(x) \
	((x) & ((GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET) | \
		(GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET)))

#define GSS_MAXSEQ			0x80000000	// The biggest sequence number
#define GSS_SVC_MAXCONTEXTS		500000		// Max contexts supported
#define GSS_SVC_SEQWINDOW		256		// Server's sequence window
#define GSS_CLNT_SEQLISTMAX		32		// Max length of req seq num list

#define SKEYLEN	8			// length of DES key
#define SKEYLEN3 24			// length of DES3 keyboard
#define MAX_SKEYLEN	SKEYLEN3

#define GSS_MAX_NEG_CACHE_ENTRIES 16
#define GSS_NEG_CACHE_TO 3
#define GSS_PRINT_DELAY	 (8 * 3600)	// Wait day before printing the same error message

typedef struct {
	uint32_t type; 		// See defines below
	uint32_t keybytes; 	// Session key length bytes;
	uint32_t hash_len;
	u_char   skey[MAX_SKEYLEN];	   	// Session key;
	union {
		struct {
			des_cblock  *key;
			des_cbc_key_schedule gss_sched;
			des_cbc_key_schedule gss_sched_Ke;
		} des;
		struct {
			des_cblock		(*key)[3];
			des_cblock		ckey[3];
			des3_cbc_key_schedule	gss_sched;
		} des3;
	} ks_u;
} gss_key_info;

#define NFS_GSS_0DES	0 // Not DES or uninitialized
#define NFS_GSS_1DES	1 // Single DES with DES_MAC_MD5
#define NFS_GSS_3DES	2 // Triple EDE DES KD with SHA1

/*
 * The client's RPCSEC_GSS context information
 */
struct nfs_gss_clnt_ctx {
	lck_mtx_t		*gss_clnt_mtx;
	thread_t		gss_clnt_thread;	// Thread creating context
	TAILQ_ENTRY(nfs_gss_clnt_ctx)	gss_clnt_entries;
	uint32_t		gss_clnt_flags;		// Flag bits - see below
	int32_t			gss_clnt_refcnt;	// Reference count
	kauth_cred_t		gss_clnt_cred;		// Owner of this context
	uint8_t			*gss_clnt_principal;	// Principal to use for this credential
	uint32_t		gss_clnt_prinlen;	// Length of principal
	gssd_nametype		gss_clnt_prinnt;	// Name type of principal
	char			*gss_clnt_display;	// display name of principal
	uint32_t		gss_clnt_proc;		// Current GSS proc for cred
	uint32_t		gss_clnt_seqnum;	// GSS sequence number
	uint32_t		gss_clnt_service;	// Indicates krb5, krb5i or krb5p
	uint8_t			*gss_clnt_handle;	// Identifies server context
	uint32_t		gss_clnt_handle_len;	// Size of server's ctx handle
	time_t			gss_clnt_nctime;	// When context was put in the negative cache
	uint32_t		gss_clnt_seqwin;	// Server's seq num window
	uint32_t		*gss_clnt_seqbits;	// Bitmap to track seq numbers in use
	mach_port_t		gss_clnt_mport;		// Mach port for gssd upcall
	uint8_t			*gss_clnt_verf;		// RPC verifier from server
	uint8_t			*gss_clnt_svcname;	// Service name e.g. "nfs/big.apple.com"
	uint32_t		gss_clnt_svcnamlen;	// Service name length
	gssd_nametype		gss_clnt_svcnt;		// Service name type
	gssd_cred		gss_clnt_cred_handle;	// Opaque cred handle from gssd
	gssd_ctx		gss_clnt_context;	// Opaque context handle from gssd
	uint8_t			*gss_clnt_token;	// GSS token exchanged via gssd & server
	uint32_t		gss_clnt_tokenlen;	// Length of token
	gss_key_info		*gss_clnt_kinfo;		// GSS key info
	uint32_t		gss_clnt_gssd_flags;	// Special flag bits to gssd
	uint32_t		gss_clnt_major;		// GSS major result from gssd or server
	uint32_t		gss_clnt_minor;		// GSS minor result from gssd or server
	time_t			gss_clnt_ptime;		// When last error message was printed
};

/*
 * gss_clnt_flags
 */
#define GSS_CTX_COMPLETE	0x00000001	// Context is complete
#define GSS_CTX_INVAL		0x00000002	// Context is invalid
#define GSS_CTX_STICKY		0x00000004	// Context has been set by user
#define GSS_NEEDSEQ		0x00000008	// Need a sequence number
#define GSS_NEEDCTX		0x00000010	// Need the context
#define GSS_CTX_DESTROY		0x00000020	// Context is being destroyed, don't cache

/*
 * The server's RPCSEC_GSS context information
 */
struct nfs_gss_svc_ctx {
	lck_mtx_t		*gss_svc_mtx;
	LIST_ENTRY(nfs_gss_svc_ctx)	gss_svc_entries;
	uint32_t		gss_svc_handle;		// Identifies server context to client
	uint32_t		gss_svc_refcnt;		// Reference count
	uint32_t		gss_svc_proc;		// Current GSS proc from cred
	uid_t			gss_svc_uid;		// UID of this user
	gid_t			gss_svc_gids[NGROUPS];	// GIDs of this user
	uint32_t		gss_svc_ngroups;	// Count of gids
	uint64_t		gss_svc_incarnation;	// Delete ctx if we exceed this + ttl value
	uint32_t		gss_svc_seqmax;		// Current max GSS sequence number
	uint32_t		gss_svc_seqwin;		// GSS sequence number window
	uint32_t		*gss_svc_seqbits;	// Bitmap to track seq numbers
	gssd_cred		gss_svc_cred_handle;	// Opaque cred handle from gssd
	gssd_ctx		gss_svc_context;	// Opaque context handle from gssd
	u_char			*gss_svc_token;		// GSS token exchanged via gssd & client
	uint32_t		gss_svc_tokenlen;	// Length of token
	gss_key_info		gss_svc_kinfo;		// Session key info
	uint32_t		gss_svc_major;		// GSS major result from gssd
	uint32_t		gss_svc_minor;		// GSS minor result from gssd
};

#define SVC_CTX_HASHSZ	64
#define SVC_CTX_HASH(handle)	((handle) % SVC_CTX_HASHSZ)
LIST_HEAD(nfs_gss_svc_ctx_hashhead, nfs_gss_svc_ctx);

/*
 * Macros to manipulate bits in the sequence window
 */
#define win_getbit(bits, bit)      ((bits[(bit) / 32] &   (1 << (bit) % 32)) != 0)
#define win_setbit(bits, bit)   do { bits[(bit) / 32] |=  (1 << (bit) % 32); } while (0)
#define win_resetbit(bits, bit) do { bits[(bit) / 32] &= ~(1 << (bit) % 32); } while (0)

/*
 * Server context stale times
 */
#define GSS_CTX_PEND		5 		// seconds
#define GSS_CTX_EXPIRE		(8 * 3600)	// seconds
#define GSS_CTX_TTL_MIN		1		// seconds
#define GSS_TIMER_PERIOD	300		// seconds
#define MSECS_PER_SEC		1000

#define auth_is_kerberized(auth) \
	(auth == RPCAUTH_KRB5 || \
	 auth == RPCAUTH_KRB5I || \
	 auth == RPCAUTH_KRB5P)

__BEGIN_DECLS

void	nfs_gss_init(void);
uid_t	nfs_cred_getasid2uid(kauth_cred_t);
int	nfs_gss_clnt_cred_put(struct nfsreq *, struct nfsm_chain *, mbuf_t);
int	nfs_gss_clnt_verf_get(struct nfsreq *, struct nfsm_chain *,
		uint32_t, uint32_t, uint32_t *);
void	nfs_gss_clnt_rpcdone(struct nfsreq *);
int	nfs_gss_clnt_args_restore(struct nfsreq *);
int	nfs_gss_clnt_ctx_renew(struct nfsreq *);
void	nfs_gss_clnt_ctx_ref(struct nfsreq *, struct nfs_gss_clnt_ctx *);
void	nfs_gss_clnt_ctx_unref(struct nfsreq *);
void	nfs_gss_clnt_ctx_unmount(struct nfsmount *);
int	nfs_gss_clnt_ctx_remove(struct nfsmount *, kauth_cred_t);
int	nfs_gss_clnt_ctx_set_principal(struct nfsmount *, vfs_context_t, uint8_t *, uint32_t, uint32_t);
int	nfs_gss_clnt_ctx_get_principal(struct nfsmount *, vfs_context_t, struct user_nfs_gss_principal *);
int	nfs_gss_svc_cred_get(struct nfsrv_descript *, struct nfsm_chain *);
int	nfs_gss_svc_verf_put(struct nfsrv_descript *, struct nfsm_chain *);
int	nfs_gss_svc_ctx_init(struct nfsrv_descript *, struct nfsrv_sock *, mbuf_t *);
int	nfs_gss_svc_prepare_reply(struct nfsrv_descript *, struct nfsm_chain *);
int	nfs_gss_svc_protect_reply(struct nfsrv_descript *, mbuf_t);
void	nfs_gss_svc_ctx_deref(struct nfs_gss_svc_ctx *);
void	nfs_gss_svc_cleanup(void);

__END_DECLS
#endif /* _NFS_NFS_GSS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfs_ioctl.h                                     0100644 0001750 0001750 00000004461 12567450754 022523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2012,2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Header file to export nfs defined ioctls for nfs_vnop_ioctls
 */

#ifndef _NFS_NFS_IOCTL_H_
#define _NFS_NFS_IOCTL_H_
#include <sys/ioccom.h>

/*
 * fsctl (vnop_ioctl) to detroy the callers credentials associated with the vnode's mount
 */
#define NFS_IOC_DESTROY_CRED		_IO('n', 1)
#define NFS_FSCTL_DESTROY_CRED		IOCBASECMD(NFS_IOC_DESTROY_CRED)
/*
 * fsclt (vnop_ioctl) to set the callers credentials associated with the vnode's mount
 */


struct nfs_gss_principal
{
	uint32_t	princlen;	/* length of data */
	uint32_t	nametype;	/* nametype of data */
	uint8_t		*principal;
	uint32_t	flags;		/* Return flags */
};


/* If no credential was found returned NFS_IOC_NO_CRED_FLAG in the flags field. */
#define NFS_IOC_NO_CRED_FLAG		1	/* No credential was found */

#define NFS_IOC_SET_CRED		_IOW('n', 2, struct nfs_gss_principal)
#define NFS_FSCTL_SET_CRED		IOCBASECMD(NFS_IOC_SET_CRED)

#define NFS_IOC_GET_CRED		_IOWR('n', 3, struct nfs_gss_principal)
#define NFS_FSCTL_GET_CRED		IOCBASECMD(NFS_IOC_GET_CRED)
#endif
                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfs_lock.h                                      0100644 0001750 0001750 00000013654 12567450754 022345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2002-2010 Apple Inc.  All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1998 Berkeley Software Design, Inc. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Berkeley Software Design Inc's name may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN INC ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN INC BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      from nfs_lock.h,v 2.2 1998/04/28 19:38:41 don Exp
 * $FreeBSD$
 */

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

/*
 * lockd uses the nfsclnt system call for the unique kernel services it needs.
 * It passes in a request structure with a version number at the start.
 * This prevents libc from needing to change if the information passed
 * between lockd and the kernel needs to change.
 *
 * If a structure changes, you must bump the version number.
 */

#include <sys/mount.h>

/*
 * The structure that the kernel hands lockd for each lock request.
 */
#define LOCKD_MSG_VERSION	3
typedef struct nfs_lock_msg {
	int			lm_version;		/* LOCKD_MSG version */
	int			lm_flags;		/* request flags */
	u_int64_t		lm_xid;			/* unique message transaction ID */
	struct flock		lm_fl;			/* The lock request. */
	struct sockaddr_storage lm_addr;		/* The address. */
	int			lm_fh_len;		/* The file handle length. */
	struct xucred		lm_cred;		/* user cred for lock req */
	u_int8_t		lm_fh[NFSV3_MAX_FH_SIZE]; /* The file handle. */
} LOCKD_MSG;

/* lm_flags */
#define LOCKD_MSG_BLOCK		0x0001	/* a blocking request */
#define LOCKD_MSG_TEST		0x0002	/* just a lock test */
#define LOCKD_MSG_NFSV3		0x0004  /* NFSv3 request */
#define LOCKD_MSG_CANCEL	0x0008  /* cancelling blocked request */
#define LOCKD_MSG_DENIED_GRACE	0x0010	/* lock denied due to grace period */
#define LOCKD_MSG_RECLAIM	0x0020  /* lock reclaim request */
#define LOCKD_MSG_TCP		0x0040  /* (try to) use TCP for request */

/* The structure used to maintain the pending request queue */
typedef struct nfs_lock_msg_request {
	TAILQ_ENTRY(nfs_lock_msg_request) lmr_next;	/* in-kernel pending request list */
	int			lmr_answered;		/* received an answer? */
	int			lmr_errno;		/* return status */
	int			lmr_saved_errno;	/* original return status */
	LOCKD_MSG		lmr_msg;		/* the message */
} LOCKD_MSG_REQUEST;

TAILQ_HEAD(nfs_lock_msg_queue, nfs_lock_msg_request);
typedef struct nfs_lock_msg_queue LOCKD_MSG_QUEUE;


/*
 * The structure that lockd hands the kernel for each lock answer.
 */
#define LOCKD_ANS_VERSION	2
struct lockd_ans {
	int		la_version;		/* lockd_ans version */
	int		la_errno;		/* return status */
	u_int64_t	la_xid;			/* unique message transaction ID */
	int		la_flags;		/* answer flags */
	pid_t		la_pid;			/* pid of lock requester/owner */
	off_t		la_start;		/* lock starting offset */
	off_t		la_len;			/* lock length */
	int 		la_fh_len;		/* The file handle length. */
	u_int8_t	la_fh[NFSV3_MAX_FH_SIZE];/* The file handle. */
};

/* la_flags */
#define LOCKD_ANS_GRANTED	0x0001	/* NLM_GRANTED request */
#define LOCKD_ANS_LOCK_INFO	0x0002	/* lock info valid */
#define LOCKD_ANS_LOCK_EXCL	0x0004	/* lock is exclusive */
#define LOCKD_ANS_DENIED_GRACE	0x0008	/* lock denied due to grace period */


/*
 * The structure that lockd hands the kernel for each notify.
 */
#define LOCKD_NOTIFY_VERSION	1
struct lockd_notify {
	int			ln_version;		/* lockd_notify version */
	int			ln_flags;		/* notify flags */
	int			ln_pad;			/* (for alignment) */
	int			ln_addrcount;		/* # of addresss */
	struct sockaddr_storage	ln_addr[1];		/* List of addresses. */
};


#endif /* __APPLE_API_PRIVATE */
                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfsdiskless.h                                   0100644 0001750 0001750 00000010241 12567450753 023063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsdiskless.h	8.2 (Berkeley) 3/30/95
 * FreeBSD-Id: nfsdiskless.h,v 1.10 1997/09/07 12:56:46 bde Exp $
 */


#ifndef _NFS_NFSDISKLESS_H_
#define _NFS_NFSDISKLESS_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

struct nfs_dlmount {
	struct sockaddr_in ndm_saddr;  		/* Address of file server */
	char		ndm_host[MAXHOSTNAMELEN];/* Host name for mount pt */
	char		*ndm_path; 		/* path name for mount pt */
	char		*ndm_mntfrom; 		/* mntfromname for mount pt */
	u_int32_t		ndm_nfsv3;		/* NFSv3 or NFSv2? */
	u_int32_t		ndm_sotype;		/* SOCK_STREAM or SOCK_DGRAM? */
	u_int32_t		ndm_fhlen;		/* length of file handle */
	u_char		ndm_fh[NFSX_V3FHMAX];	/* The file's file handle */
};

struct nfs_diskless {
	struct nfs_dlmount nd_root; 	/* Mount info for root */
	struct nfs_dlmount nd_private; 	/* Mount info for private */
};

#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_NFSDISKLESS_H_ */
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfsm_subs.h                                     0100644 0001750 0001750 00000061362 12567450753 022544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsm_subs.h	8.2 (Berkeley) 3/30/95
 * FreeBSD-Id: nfsm_subs.h,v 1.13 1997/07/16 09:06:30 dfr Exp $
 */


#ifndef _NFS_NFSM_SUBS_H_
#define _NFS_NFSM_SUBS_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

int nfsm_rpchead(struct nfsreq *, mbuf_t, u_int64_t *, mbuf_t *);
int nfsm_rpchead2(struct nfsmount *, int, int, int, int, int, kauth_cred_t, struct nfsreq *, mbuf_t, u_int64_t *, mbuf_t *);

int nfsm_chain_new_mbuf(struct nfsm_chain *, size_t);
int nfsm_chain_add_opaque_f(struct nfsm_chain *, const u_char *, uint32_t);
int nfsm_chain_add_opaque_nopad_f(struct nfsm_chain *, const u_char *, uint32_t);
int nfsm_chain_add_uio(struct nfsm_chain *, uio_t, uint32_t);
int nfsm_chain_add_fattr4_f(struct nfsm_chain *, struct vnode_attr *, struct nfsmount *);
int nfsm_chain_add_v2sattr_f(struct nfsm_chain *, struct vnode_attr *, uint32_t);
int nfsm_chain_add_v3sattr_f(struct nfsm_chain *, struct vnode_attr *);
int nfsm_chain_add_string_nfc(struct nfsm_chain *, const uint8_t *, uint32_t);

int nfsm_chain_advance(struct nfsm_chain *, uint32_t);
int nfsm_chain_offset(struct nfsm_chain *);
int nfsm_chain_reverse(struct nfsm_chain *, uint32_t);
int nfsm_chain_get_opaque_pointer_f(struct nfsm_chain *, uint32_t, u_char **);
int nfsm_chain_get_opaque_f(struct nfsm_chain *, uint32_t, u_char *);
int nfsm_chain_get_uio(struct nfsm_chain *, uint32_t, uio_t);
int nfsm_chain_get_fh_attr(struct nfsm_chain *, nfsnode_t,
	vfs_context_t, int, uint64_t *, fhandle_t *, struct nfs_vattr *);
int nfsm_chain_get_wcc_data_f(struct nfsm_chain *, nfsnode_t, struct timespec *, int *, u_int64_t *);
int nfsm_chain_get_secinfo(struct nfsm_chain *, uint32_t *, int *);

#if NFSSERVER
void nfsm_adj(mbuf_t, int, int);
int nfsm_mbuf_get_list(size_t, mbuf_t *, int *);

int nfsm_chain_add_fattr(struct nfsrv_descript *, struct nfsm_chain *, struct vnode_attr *);
int nfsm_chain_add_wcc_data_f(struct nfsrv_descript *, struct nfsm_chain *, int,
	struct vnode_attr *, int, struct vnode_attr *);
int nfsm_chain_get_path_namei(struct nfsm_chain *, uint32_t, struct nameidata *);
int nfsm_chain_get_sattr(struct nfsrv_descript *, struct nfsm_chain *, struct vnode_attr *);
int nfsm_chain_trim_data(struct nfsm_chain *, int, int *);
#endif /* NFSSERVER */

/* check name length */
#define nfsm_name_len_check(E, ND, LEN) \
	do { \
		if (E) break; \
		if (((ND)->nd_vers == NFS_VER2) && ((LEN) > NFS_MAXNAMLEN)) \
			(E) = NFSERR_NAMETOL; \
		if ((LEN) <= 0) \
			error = EBADRPC; \
	} while (0)

#define nfsm_assert(E, COND, ERR) \
	do { \
		if (E) break; \
		if (!(COND)) \
			(E) = (ERR); \
	} while (0)

/* Initialize a vnode_attr to retrieve attributes for the NFS server. */
#define nfsm_srv_vattr_init(VAP, VERS) \
	do { \
		VATTR_INIT(VAP); \
		VATTR_WANTED((VAP), va_type); \
		VATTR_WANTED((VAP), va_mode); \
		VATTR_WANTED((VAP), va_nlink); \
		VATTR_WANTED((VAP), va_uid); \
		VATTR_WANTED((VAP), va_gid); \
		VATTR_WANTED((VAP), va_data_size); \
		VATTR_WANTED((VAP), va_data_alloc); \
		VATTR_WANTED((VAP), va_rdev); \
		VATTR_WANTED((VAP), va_fsid); \
		VATTR_WANTED((VAP), va_fileid); \
		VATTR_WANTED((VAP), va_access_time); \
		VATTR_WANTED((VAP), va_modify_time); \
		VATTR_WANTED((VAP), va_change_time); \
		if ((VERS) == NFS_VER2) \
			VATTR_WANTED((VAP), va_iosize); \
	} while (0)

/* Initialize a vnode_attr to retrieve pre-operation attributes for the NFS server. */
#define nfsm_srv_pre_vattr_init(VAP) \
	do { \
		VATTR_INIT(VAP); \
		VATTR_WANTED((VAP), va_data_size); \
		VATTR_WANTED((VAP), va_modify_time); \
		VATTR_WANTED((VAP), va_change_time); \
	} while (0)

/* round up to a multiple of 4 */
#define nfsm_rndup(a)	(((a)+3)&(~0x3))

#define nfsm_pad(a)	(nfsm_rndup(a) - (a))

/*
 * control flow macros:
 * go to the appropriate label on condition
 */
#define nfsmout_if(E)	do { if (E) goto nfsmout; } while (0)
#define nfsmerr_if(E)	do { if (E) goto nfsmerr; } while (0)

/*
 * For NFS v2 errors and EBADRPC, the reply contains only the error.
 * This macro is used to skip any reply building code and go straight
 * to nfsmout instead.
 */
#define nfsmout_on_status(ND, E) \
	do { \
		if (((ND)->nd_repstat == EBADRPC) || \
		    ((ND)->nd_repstat && ((ND)->nd_vers == NFS_VER2))) { \
			(E) = 0; \
			goto nfsmout; \
		} \
	} while (0)

/* initialize an mbuf chain */
#define nfsm_chain_null(NMC) \
	do { \
		(NMC)->nmc_mhead = (NMC)->nmc_mcur = NULL; \
		(NMC)->nmc_ptr = NULL; \
	} while (0)

/* cleanup an mbuf chain */
#define nfsm_chain_cleanup(NMC) \
	do { \
		if (!(NMC)->nmc_mhead) break; \
		mbuf_freem((NMC)->nmc_mhead); \
		nfsm_chain_null(NMC); \
	} while (0)

/* get an mbuf given a size hint */
#define nfsm_mbuf_get(E, MBP, SIZEHINT) \
	do { \
		*(MBP) = NULL; \
		if ((size_t)(SIZEHINT) >= nfs_mbuf_minclsize) \
			(E) = mbuf_mclget(MBUF_WAITOK, MBUF_TYPE_DATA, (MBP)); \
		else \
			(E) = mbuf_get(MBUF_WAITOK, MBUF_TYPE_DATA, (MBP)); \
	} while (0)


/*
 * macros for building NFS mbuf chains
 */

/* prepare an mbuf chain for building starting with the given mbuf */
#define nfsm_chain_init(NMC, MB) \
	do { \
		(NMC)->nmc_mhead = (MB); \
		(NMC)->nmc_mcur = (NMC)->nmc_mhead; \
		(NMC)->nmc_ptr = mbuf_data((NMC)->nmc_mcur); \
		(NMC)->nmc_left = mbuf_trailingspace((NMC)->nmc_mcur); \
		(NMC)->nmc_flags = 0; \
	} while (0)

/* prepare an mbuf chain for building starting with a newly allocated mbuf */
#define nfsm_chain_build_alloc_init(E, NMC, SIZEHINT) \
	do { \
		mbuf_t ncbimb; \
		nfsm_mbuf_get((E), &ncbimb, (SIZEHINT)); \
		if (E) break; \
		nfsm_chain_init((NMC), ncbimb); \
	} while (0)

/* done building an mbuf chain */
#define nfsm_chain_build_done(E, NMC) \
	do { \
		if ((E) || !(NMC)->nmc_mcur) break; \
		/* cap off current mbuf */ \
		mbuf_setlen((NMC)->nmc_mcur, \
			(NMC)->nmc_ptr - (caddr_t)mbuf_data((NMC)->nmc_mcur)); \
	} while (0)

/*
 *  set the TCP record mark at the head of an mbuf chain -
 *  assumes 4 bytes are already allocated in the head mbuf
 */
#define nfsm_chain_set_recmark(E, NMC, VAL) \
	do { \
		if (E) break; \
		*((uint32_t*)mbuf_data((NMC)->nmc_mhead)) \
			= txdr_unsigned(VAL); \
	} while (0)

/* make sure there's room for size bytes in current mbuf */
#define nfsm_chain_check_size(E, NMC, SIZE) \
	do { \
		if (E) break; \
		if ((NMC)->nmc_left < (SIZE)) { \
			(E) = nfsm_chain_new_mbuf((NMC), (SIZE)); \
			if (!(E) && ((NMC)->nmc_left < (SIZE))) \
				(E) = ENOMEM; \
		} \
	} while (0)

/* add a 32bit value to an mbuf chain extending if necessary */
#define nfsm_chain_add_32(E, NMC, VAL) \
	do { \
		nfsm_chain_check_size((E), (NMC), NFSX_UNSIGNED); \
		if (E) break; \
		*((uint32_t*)(NMC)->nmc_ptr) = txdr_unsigned(VAL); \
		(NMC)->nmc_ptr += NFSX_UNSIGNED; \
		(NMC)->nmc_left -= NFSX_UNSIGNED; \
	} while (0)

/* add a 64bit value to an mbuf chain */
#define nfsm_chain_add_64(E, NMC, VAL) \
	do { \
		uint64_t __tmp64; \
		nfsm_chain_check_size((E), (NMC), 2 * NFSX_UNSIGNED); \
		if (E) break; \
		__tmp64 = (VAL); \
		txdr_hyper(&__tmp64, (NMC)->nmc_ptr); \
		(NMC)->nmc_ptr += 2 * NFSX_UNSIGNED; \
		(NMC)->nmc_left -= 2 * NFSX_UNSIGNED; \
	} while (0)

/* zero the last 4 bytes for a range of opaque */
/* data to make sure any pad bytes will be zero. */
#define nfsm_chain_zero_opaque_pad(BUF, LEN) \
	*(((uint32_t*)(BUF))+((nfsm_rndup(LEN)>>2)-1)) = 0

/* add buffer of opaque data to an mbuf chain */
#define nfsm_chain_add_opaque(E, NMC, BUF, LEN) \
	do { \
		uint32_t rndlen = nfsm_rndup(LEN); \
		if (E) break; \
		if ((NMC)->nmc_left < rndlen) { \
			(E) = nfsm_chain_add_opaque_f((NMC), (const u_char*)(BUF), (LEN)); \
			break; \
		} \
		nfsm_chain_zero_opaque_pad((NMC)->nmc_ptr, (LEN)); \
		bcopy((BUF), (NMC)->nmc_ptr, (LEN)); \
		(NMC)->nmc_ptr += rndlen; \
		(NMC)->nmc_left -= rndlen; \
	} while (0)

/* add buffer of opaque data to an mbuf chain without padding */
#define nfsm_chain_add_opaque_nopad(E, NMC, BUF, LEN) \
	do { \
		if (E) break; \
		if ((NMC)->nmc_left < (uint32_t) (LEN)) { \
			(E) = nfsm_chain_add_opaque_nopad_f((NMC), (const u_char*)(BUF), (LEN)); \
			break; \
		} \
		bcopy((BUF), (NMC)->nmc_ptr, (LEN)); \
		(NMC)->nmc_ptr += (LEN); \
		(NMC)->nmc_left -= (LEN); \
	} while (0)

/* finish an mbuf in a chain to allow subsequent insertion */
#define nfsm_chain_finish_mbuf(E, NMC) \
	do { \
		if (E) break; \
		mbuf_setlen((NMC)->nmc_mcur, \
			(NMC)->nmc_ptr - (caddr_t)mbuf_data((NMC)->nmc_mcur)); \
		(NMC)->nmc_left = 0; \
	} while (0)

/* add a file handle to an mbuf chain */
#define nfsm_chain_add_fh(E, NMC, VERS, FHP, FHLEN) \
	do { \
		if (E) break; \
		if ((VERS) != NFS_VER2) \
			nfsm_chain_add_32((E), (NMC), (FHLEN)); \
		nfsm_chain_add_opaque((E), (NMC), (FHP), (FHLEN)); \
	} while (0)

/* add a string to an mbuf chain */
#define nfsm_chain_add_string(E, NMC, STR, LEN) \
	do { \
		nfsm_chain_add_32((E), (NMC), (LEN)); \
		nfsm_chain_add_opaque((E), (NMC), (STR), (LEN)); \
	} while (0)

/* add a name to an mbuf chain */
#define nfsm_chain_add_name(E, NMC, STR, LEN, NMP) \
	do { \
		if (E) break; \
		if (NMFLAG((NMP), NFC)) \
			(E) = nfsm_chain_add_string_nfc((NMC), (const uint8_t*)(STR), (LEN)); \
		else \
			nfsm_chain_add_string((E), (NMC), (STR), (LEN)); \
	} while (0)

/* add an NFSv2 time to an mbuf chain */
#define nfsm_chain_add_v2time(E, NMC, TVP) \
	do { \
		if (TVP) { \
			nfsm_chain_add_32((E), (NMC), (TVP)->tv_sec); \
			nfsm_chain_add_32((E), (NMC), ((TVP)->tv_nsec != -1) ? \
				((uint32_t)(TVP)->tv_nsec / 1000) : 0xffffffff); \
		} else { \
			/* no time... use -1 */ \
			nfsm_chain_add_32((E), (NMC), -1); \
			nfsm_chain_add_32((E), (NMC), -1); \
		} \
	} while (0)

/* add an NFSv3 time to an mbuf chain */
#define nfsm_chain_add_v3time(E, NMC, TVP) \
	do { \
		nfsm_chain_add_32((E), (NMC), (TVP)->tv_sec); \
		nfsm_chain_add_32((E), (NMC), (TVP)->tv_nsec); \
	} while (0)

/* add an NFS v2 or v3 time to an mbuf chain */
#define nfsm_chain_add_time(E, NMC, VERS, TVP) \
	do { \
		if ((VERS) == NFS_VER2) { \
			nfsm_chain_add_v2time((E), (NMC), (TVP)); \
		} else { \
			nfsm_chain_add_v3time((E), (NMC), (TVP)); \
		} \
	} while (0)

/* add an NFSv3 postop file handle to an mbuf chain */
#define nfsm_chain_add_postop_fh(E, NMC, FHP, FHLEN) \
	do { \
		nfsm_chain_add_32((E), (NMC), TRUE); \
		nfsm_chain_add_fh((E), (NMC), NFS_VER3, (FHP), (FHLEN)); \
	} while (0)

/* add NFSv3 postop attributes to an mbuf chain */
#define nfsm_chain_add_postop_attr(E, ND, NMC, ATTRERR, VAP) \
	do { \
		if (E) break; \
		if (ATTRERR) { \
			nfsm_chain_add_32((E), (NMC), FALSE); \
			break; \
		} \
		nfsm_chain_add_32((E), (NMC), TRUE); \
		if (E) break; \
		(E) = nfsm_chain_add_fattr((ND), (NMC), (VAP)); \
	} while (0)

/* Add an NFSv2 "sattr" structure to an mbuf chain */
#define nfsm_chain_add_v2sattr(E, NMC, VAP, SZRDEV) \
	do { \
		if (E) break; \
		(E) = nfsm_chain_add_v2sattr_f((NMC), (VAP), (SZRDEV)); \
	} while (0)

/* Add an NFSv3 "sattr" structure to an mbuf chain */
#define nfsm_chain_add_v3sattr(E, NMC, VAP) \
	do { \
		if (E) break; \
		(E) = nfsm_chain_add_v3sattr_f((NMC), (VAP)); \
	} while (0)

/* Add an NFSv4 "fattr" structure to an mbuf chain */
#define nfsm_chain_add_fattr4(E, NMC, VAP, NMP) \
	do { \
		if (E) break; \
		(E) = nfsm_chain_add_fattr4_f((NMC), (VAP), (NMP)); \
	} while (0)

/* add NFSv3 WCC data to an mbuf chain */
#define nfsm_chain_add_wcc_data(E, ND, NMC, PREERR, PREVAP, POSTERR, POSTVAP) \
	do { \
		if (E) break; \
		(E) = nfsm_chain_add_wcc_data_f((ND), (NMC), \
			(PREERR), (PREVAP), (POSTERR), (POSTVAP)); \
	} while (0)

/* add NFSv4 COMPOUND header */
#define NFS4_TAG_LENGTH	12
#define nfsm_chain_add_compound_header(E, NMC, TAG, MINOR, NUMOPS) \
	do { \
		if ((TAG) && strlen(TAG)) { \
			/* put tags into a fixed-length space-padded field */ \
			char __nfstag[NFS4_TAG_LENGTH+1]; \
			snprintf(__nfstag, sizeof(__nfstag), "%-*s", NFS4_TAG_LENGTH, (TAG)); \
			nfsm_chain_add_32((E), (NMC), NFS4_TAG_LENGTH); \
			nfsm_chain_add_opaque((E), (NMC), __nfstag, NFS4_TAG_LENGTH); \
		} else { \
			nfsm_chain_add_32((E), (NMC), 0); \
		} \
		nfsm_chain_add_32((E), (NMC), (MINOR)); /*minorversion*/ \
		nfsm_chain_add_32((E), (NMC), (NUMOPS)); \
	} while (0)

/* add NFSv4 attr bitmap */
#define nfsm_chain_add_bitmap(E, NMC, B, LEN) \
	do { \
		int __i; \
		nfsm_chain_add_32((E), (NMC), (LEN)); \
		for (__i=0; __i < (LEN); __i++) \
			nfsm_chain_add_32((E), (NMC), (B)[__i]); \
	} while (0)

/* add NFSv4 attr bitmap masked with the given mask */
#define nfsm_chain_add_bitmap_masked(E, NMC, B, LEN, MASK) \
	do { \
		int __i; \
		nfsm_chain_add_32((E), (NMC), (LEN)); \
		for (__i=0; __i < (LEN); __i++) \
			nfsm_chain_add_32((E), (NMC), ((B)[__i] & (MASK)[__i])); \
	} while (0)

/* add NFSv4 attr bitmap masked with the supported attributes for this mount/node */
#define nfsm_chain_add_bitmap_supported(E, NMC, B, NMP, NP) \
	do { \
		uint32_t __bitmap[NFS_ATTR_BITMAP_LEN], *__bmp = (B); \
		int __nonamedattr = 0, __noacl = 0, __nomode = 0; \
		if (!((NMP)->nm_fsattr.nfsa_flags & NFS_FSFLAG_NAMED_ATTR) || \
		    ((NP) && (((nfsnode_t)(NP))->n_flag & (NISDOTZFS|NISDOTZFSCHILD)))) \
			__nonamedattr = 1; \
		if (!((NMP)->nm_fsattr.nfsa_flags & NFS_FSFLAG_ACL)) \
			__noacl = 1; \
		if (NMFLAG((NMP), ACLONLY)) \
			__nomode = 1; \
		if (__nonamedattr || __noacl || __nomode) { \
			/* don't ask for attrs we're not supporting */ \
			/* some ".zfs" directories can't handle being asked for some attributes */ \
			int __ii; \
			NFS_CLEAR_ATTRIBUTES(__bitmap); \
			for (__ii=0; __ii < NFS_ATTR_BITMAP_LEN; __ii++) \
				__bitmap[__ii] = (B)[__ii]; \
			if (__nonamedattr) \
				NFS_BITMAP_CLR(__bitmap, NFS_FATTR_NAMED_ATTR); \
			if (__noacl) \
				NFS_BITMAP_CLR(__bitmap, NFS_FATTR_ACL); \
			if (__nomode) \
				NFS_BITMAP_CLR(__bitmap, NFS_FATTR_MODE); \
			__bmp = __bitmap; \
		} \
		nfsm_chain_add_bitmap_masked((E), (NMC), __bmp, NFS_ATTR_BITMAP_LEN, (NMP)->nm_fsattr.nfsa_supp_attr); \
	} while (0)

/* Add an NFSv4 "stateid" structure to an mbuf chain */
#define nfsm_chain_add_stateid(E, NMC, SID) \
	do { \
		nfsm_chain_add_32((E), (NMC), (SID)->seqid); \
		nfsm_chain_add_32((E), (NMC), (SID)->other[0]); \
		nfsm_chain_add_32((E), (NMC), (SID)->other[1]); \
		nfsm_chain_add_32((E), (NMC), (SID)->other[2]); \
	} while (0)

/* add an NFSv4 lock owner structure to an mbuf chain */
#define nfsm_chain_add_lock_owner4(E, NMC, NMP, NLOP) \
	do { \
		nfsm_chain_add_64((E), (NMC), (NMP)->nm_clientid); \
		nfsm_chain_add_32((E), (NMC), 5*NFSX_UNSIGNED); \
		nfsm_chain_add_32((E), (NMC), (NLOP)->nlo_name); \
		nfsm_chain_add_32((E), (NMC), (NLOP)->nlo_pid); \
		nfsm_chain_add_64((E), (NMC), (NLOP)->nlo_pid_start.tv_sec); \
		nfsm_chain_add_32((E), (NMC), (NLOP)->nlo_pid_start.tv_usec); \
	} while (0)

/*
 * macros for dissecting NFS mbuf chains
 */

/* prepare an mbuf chain for dissection starting with the given mbuf */
#define nfsm_chain_dissect_init(E, NMC, H) \
	do { \
		if (!(H)) { \
			(E) = EINVAL; \
			break; \
		} \
		(NMC)->nmc_mcur = (NMC)->nmc_mhead = (H); \
		(NMC)->nmc_ptr = mbuf_data(H); \
		(NMC)->nmc_left = mbuf_len(H); \
	} while (0)

/* skip a number of bytes in an mbuf chain */
#define nfsm_chain_adv(E, NMC, LEN) \
	do { \
		if (E) break; \
		if ((NMC)->nmc_left >= (uint32_t)(LEN)) { \
			(NMC)->nmc_left -= (LEN); \
			(NMC)->nmc_ptr += (LEN); \
		} else { \
			(E) = nfsm_chain_advance((NMC), (LEN)); \
		} \
	} while (0)

/* get a 32bit value from an mbuf chain */
#define nfsm_chain_get_32(E, NMC, LVAL) \
	do { \
		uint32_t __tmp32, *__tmpptr; \
		if (E) break; \
		if ((NMC)->nmc_left >= NFSX_UNSIGNED) { \
			__tmpptr = (uint32_t*)(NMC)->nmc_ptr; \
			(NMC)->nmc_left -= NFSX_UNSIGNED; \
			(NMC)->nmc_ptr += NFSX_UNSIGNED; \
		} else { \
			__tmpptr = &__tmp32; \
			(E) = nfsm_chain_get_opaque_f((NMC), NFSX_UNSIGNED, (u_char*)__tmpptr); \
			if (E) break; \
		} \
		(LVAL) = fxdr_unsigned(uint32_t, *__tmpptr); \
	} while (0)

/* get a 64bit value from an mbuf chain */
#define nfsm_chain_get_64(E, NMC, LVAL) \
	do { \
		uint64_t __tmp64, *__tmpptr; \
		if (E) break; \
		if ((NMC)->nmc_left >= 2 * NFSX_UNSIGNED) { \
			__tmpptr = (uint64_t*)(NMC)->nmc_ptr; \
			(NMC)->nmc_left -= 2 * NFSX_UNSIGNED; \
			(NMC)->nmc_ptr += 2 * NFSX_UNSIGNED; \
		} else { \
			__tmpptr = &__tmp64; \
			(E) = nfsm_chain_get_opaque_f((NMC), 2 * NFSX_UNSIGNED, (u_char*)__tmpptr); \
			if (E) break; \
		} \
		fxdr_hyper(__tmpptr, &(LVAL)); \
	} while (0)

/* get a pointer to the next consecutive bytes in an mbuf chain */
#define nfsm_chain_get_opaque_pointer(E, NMC, LEN, PTR) \
	do { \
		uint32_t rndlen; \
		if (E) break; \
		rndlen = nfsm_rndup(LEN); \
		if ((NMC)->nmc_left >= rndlen) { \
			(PTR) = (void*)(NMC)->nmc_ptr; \
			(NMC)->nmc_left -= rndlen; \
			(NMC)->nmc_ptr += rndlen; \
		} else { \
			(E) = nfsm_chain_get_opaque_pointer_f((NMC), (LEN), (u_char**)&(PTR)); \
		} \
	} while (0)

/* copy the next consecutive bytes of opaque data from an mbuf chain */
#define nfsm_chain_get_opaque(E, NMC, LEN, PTR) \
	do { \
		uint32_t rndlen; \
		if (E) break; \
		rndlen = nfsm_rndup(LEN); \
		if ((NMC)->nmc_left >= rndlen) { \
			u_char *__tmpptr = (u_char*)(NMC)->nmc_ptr; \
			(NMC)->nmc_left -= rndlen; \
			(NMC)->nmc_ptr += rndlen; \
			bcopy(__tmpptr, (PTR), (LEN)); \
		} else { \
			(E) = nfsm_chain_get_opaque_f((NMC), (LEN), (u_char*)(PTR)); \
		} \
	} while (0)

/* get the size of and a pointer to a file handle in an mbuf chain */
#define nfsm_chain_get_fh_ptr(E, NMC, VERS, FHP, FHSIZE) \
	do { \
		if ((VERS) != NFS_VER2) \
			nfsm_chain_get_32((E), (NMC), (FHSIZE)); \
		else \
			(FHSIZE) = NFSX_V2FH;\
		nfsm_chain_get_opaque_pointer((E), (NMC), (FHSIZE), (FHP));\
	} while (0)

/* get the size of and data for a file handle in an mbuf chain */
#define nfsm_chain_get_fh(E, NMC, VERS, FHP) \
	do { \
		if ((VERS) != NFS_VER2) \
			nfsm_chain_get_32((E), (NMC), (FHP)->fh_len); \
		else \
			(FHP)->fh_len = NFSX_V2FH;\
		nfsm_chain_get_opaque((E), (NMC), (uint32_t)(FHP)->fh_len, (FHP)->fh_data);\
		if (E) \
			(FHP)->fh_len = 0;\
	} while (0)

/* get an NFS v2 or v3 time from an mbuf chain */
#define nfsm_chain_get_time(E, NMC, VERS, TSEC, TNSEC) \
	do { \
		nfsm_chain_get_32((E), (NMC), (TSEC)); \
		nfsm_chain_get_32((E), (NMC), (TNSEC)); \
		if ((E) || ((VERS) != NFS_VER2)) break; \
		if ((uint32_t)(TNSEC) == 0xffffffff) \
			(TNSEC) = 0; \
		else \
			(TNSEC) *= 1000; \
	} while (0)

/* get postop attributes from an mbuf chain */
#define nfsm_chain_postop_attr_get(E, NMC, F, VAP) \
	do { \
		(F) = 0; \
		if ((E) || !(NMC)->nmc_mhead) break; \
		nfsm_chain_get_32((E), (NMC), (F)); \
		if ((E) || !(F)) break; \
		if (((E) = nfs_parsefattr((NMC), NFS_VER3, (VAP)))) \
			(F) = 0; \
	} while (0)

/* update a node's attribute cache with postop attributes from an mbuf chain */
/* (F returns whether the attributes were updated or not) */
#define nfsm_chain_postop_attr_update_flag(E, NMC, NP, F, X) \
	do { \
		struct nfs_vattr ttvattr; \
		nfsm_chain_postop_attr_get((E), (NMC), (F), &ttvattr); \
		if ((E) || !(F)) break; \
		if (((E) = nfs_loadattrcache((NP), &ttvattr, (X), 1))) { \
			(F) = 0; \
			break; \
		} \
		if (*(X) == 0) \
			(F) = 0; \
	} while (0)

/* update a node's attribute cache with postop attributes from an mbuf chain */
#define nfsm_chain_postop_attr_update(E, NMC, NP, X) \
	do { \
		int __dummy_flag = 0; \
		nfsm_chain_postop_attr_update_flag((E), (NMC), (NP), __dummy_flag, (X)); \
	} while (0)

/* get and process NFSv3 WCC data from an mbuf chain */
#define nfsm_chain_get_wcc_data(E, NMC, NP, PREMTIME, NEWPOSTATTR, X) \
	do { \
		if (E) break; \
		(E) = nfsm_chain_get_wcc_data_f((NMC), (NP), (PREMTIME), (NEWPOSTATTR), (X)); \
	} while (0)

/* update a node's attribute cache with attributes from an mbuf chain */
#define nfsm_chain_loadattr(E, NMC, NP, VERS, X) \
	do { \
		struct nfs_vattr ttvattr; \
		if (E) break; \
		if ((VERS) == NFS_VER4) { \
			(E) = nfs4_parsefattr((NMC), NULL, &ttvattr, NULL, NULL, NULL); \
		} else { \
			(E) = nfs_parsefattr((NMC), (VERS), &ttvattr); \
		} \
		if (!(E) && (NP)) \
			(E) = nfs_loadattrcache((NP), &ttvattr, (X), 0); \
		NVATTR_CLEANUP(&ttvattr); \
	} while (0)

/* get NFSv4 attr bitmap */
#define nfsm_chain_get_bitmap(E, NMC, B, LEN) \
	do { \
		uint32_t __len = 0, __i; \
		nfsm_chain_get_32((E), (NMC), __len); \
		if (E) break; \
		for (__i=0; __i < MIN(__len, (LEN)); __i++) \
			nfsm_chain_get_32((E), (NMC), (B)[__i]); \
		if (E) break; \
		for (; __i < __len; __i++) \
			nfsm_chain_adv((E), (NMC), NFSX_UNSIGNED); \
		for (; __i < (LEN); __i++) \
			(B)[__i] = 0; \
		(LEN) = __len; \
	} while (0)

/* get an NFSv4 "stateid" structure from an mbuf chain */
#define nfsm_chain_get_stateid(E, NMC, SID) \
	do { \
		nfsm_chain_get_32((E), (NMC), (SID)->seqid); \
		nfsm_chain_get_32((E), (NMC), (SID)->other[0]); \
		nfsm_chain_get_32((E), (NMC), (SID)->other[1]); \
		nfsm_chain_get_32((E), (NMC), (SID)->other[2]); \
	} while (0)

#define nfsm_chain_skip_tag(E, NMC) \
	do { \
		uint32_t __val = 0; \
		nfsm_chain_get_32((E), (NMC), __val); \
		nfsm_chain_adv((E), (NMC), nfsm_rndup(__val)); \
	} while (0)

#define nfsm_chain_op_check(E, NMC, OP) \
	do { \
		uint32_t __val = 0; \
		nfsm_chain_get_32((E), (NMC), __val); \
		/* [sigh] some implementations return the "illegal" op for unsupported ops */ \
		nfsm_assert((E), ((__val == (OP)) || (__val == NFS_OP_ILLEGAL)), EBADRPC); \
		nfsm_chain_get_32((E), (NMC), __val); \
		nfsm_assert((E), (__val == NFS_OK), __val); \
	} while (0)

#define nfsm_chain_check_change_info(E, NMC, DNP) \
	do { \
		uint64_t __ci_before, __ci_after; \
		uint32_t __ci_atomic = 0; \
		nfsm_chain_get_32((E), (NMC), __ci_atomic); \
		nfsm_chain_get_64((E), (NMC), __ci_before); \
		nfsm_chain_get_64((E), (NMC), __ci_after); \
		if ((E) || !(DNP)) break; \
		if (__ci_atomic && (__ci_before == (DNP)->n_ncchange)) { \
			(DNP)->n_ncchange = __ci_after; \
		} else { \
			cache_purge(NFSTOV(DNP)); \
			(DNP)->n_ncgen++; \
		} \
	} while (0)

#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_NFSM_SUBS_H_ */
                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfsmount.h                                      0100644 0001750 0001750 00000047645 12567450753 022426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsmount.h	8.3 (Berkeley) 3/30/95
 * FreeBSD-Id: nfsmount.h,v 1.13 1997/08/16 19:16:05 wollman Exp $
 */


#ifndef _NFS_NFSMOUNT_H_
#define _NFS_NFSMOUNT_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

/*
 * NFS mount file system attributes
 */
struct nfs_fsattr {
	uint32_t	nfsa_flags;		/* file system flags */
	uint32_t	nfsa_lease;		/* lease time in seconds */
	uint32_t	nfsa_maxname;		/* maximum filename size */
	uint32_t	nfsa_maxlink;		/* maximum # links */
	uint32_t	nfsa_bsize;		/* block size */
	uint32_t	nfsa_pad;		/* UNUSED */
	uint64_t	nfsa_maxfilesize;	/* maximum file size */
	uint64_t	nfsa_maxread;		/* maximum read size */
	uint64_t	nfsa_maxwrite;		/* maximum write size */
	uint64_t	nfsa_files_avail;	/* file slots available */
	uint64_t	nfsa_files_free;	/* file slots free */
	uint64_t	nfsa_files_total;	/* file slots total */
	uint64_t	nfsa_space_avail;	/* disk space available */
	uint64_t	nfsa_space_free;	/* disk space free */
	uint64_t	nfsa_space_total;	/* disk space total */
	uint32_t	nfsa_supp_attr[NFS_ATTR_BITMAP_LEN]; /* attributes supported on this file system */
	uint32_t	nfsa_bitmap[NFS_ATTR_BITMAP_LEN]; /* valid attributes */
};
#define NFS_FSFLAG_LINK			0x00000001
#define NFS_FSFLAG_SYMLINK		0x00000002
#define NFS_FSFLAG_UNIQUE_FH		0x00000004
#define NFS_FSFLAG_ACL			0x00000008
#define NFS_FSFLAG_SET_TIME		0x00000010
#define NFS_FSFLAG_CASE_INSENSITIVE	0x00000020
#define NFS_FSFLAG_CASE_PRESERVING	0x00000040
#define NFS_FSFLAG_CHOWN_RESTRICTED	0x00000080
#define NFS_FSFLAG_HOMOGENEOUS		0x00000100
#define NFS_FSFLAG_NO_TRUNC		0x00000200
#define NFS_FSFLAG_NAMED_ATTR		0x00000400
#define NFS_FSFLAG_FHTYPE_MASK		0xFF000000
#define NFS_FSFLAG_FHTYPE_SHIFT		24

/*
 * NFS file system location structures
 */
struct nfs_fs_server {
	char *			ns_name;		/* name of server */
	char **			ns_addresses;		/* array of addresses for server */
	uint32_t		ns_addrcount;		/* # of addresses */
};
struct nfs_fs_path {
	char **			np_components;		/* array of component pointers */
	uint32_t		np_compcount;		/* # components in path */
};
struct nfs_fs_location {
	struct nfs_fs_server **	nl_servers;		/* array of server pointers */
	struct nfs_fs_path	nl_path;		/* file system path */
	uint32_t		nl_servcount;		/* # of servers */
};

struct nfs_location_index {
	uint8_t 		nli_flags;		/* misc flags */
	uint8_t 		nli_loc;		/* location index */
	uint8_t 		nli_serv;		/* server index */
	uint8_t 		nli_addr;		/* address index */
};
#define NLI_VALID	0x01	/* index is valid */

struct nfs_fs_locations {
	struct nfs_fs_path	nl_root;		/* current server's root file system path */
	uint32_t		nl_numlocs;		/* # of locations */
	struct nfs_location_index nl_current;		/* index of current location/server/address */
	struct nfs_fs_location **nl_locations;		/* array of fs locations */
};

/*
 * RPC record marker parsing state
 */
struct nfs_rpc_record_state {
	mbuf_t			nrrs_m;			/* mbufs for current record */
	mbuf_t			nrrs_mlast;
	uint16_t		nrrs_lastfrag;		/* last fragment of record */
	uint16_t		nrrs_markerleft;	/* marker bytes remaining */
	uint32_t		nrrs_fragleft;		/* fragment bytes remaining */
	uint32_t		nrrs_reclen;		/* length of RPC record */
};

/*
 * NFS socket structures
 */
struct nfs_socket {
	lck_mtx_t		nso_lock;		/* nfs socket lock */
	TAILQ_ENTRY(nfs_socket)	nso_link;		/* list of sockets */
	struct sockaddr *	nso_saddr;		/* socket address */
	struct sockaddr *	nso_saddr2;		/* additional socket address */
	void *			nso_wake;		/* address to wake up */
	time_t			nso_timestamp;
	time_t			nso_reqtimestamp;	/* last request sent */
	socket_t		nso_so;			/* socket */
	uint8_t			nso_sotype;		/* Type of socket */
	uint16_t		nso_flags;		/* NSO_* flags */
	struct nfs_location_index nso_location;		/* location index */
	uint32_t		nso_protocol;		/* RPC protocol */
	uint32_t		nso_version;		/* RPC protocol version */
	uint32_t		nso_pingxid;		/* RPC XID of NULL ping request */
	uint32_t		nso_nfs_min_vers;	/* minimum nfs version for connecting sockets */
	uint32_t		nso_nfs_max_vers;	/* maximum nfs version for connecting sockets */
	int			nso_error;		/* saved error/status */
	struct nfs_rpc_record_state nso_rrs;		/* RPC record parsing state (TCP) */
};
TAILQ_HEAD(nfssocketlist, nfs_socket);
/* nso_flags */
#define NSO_UPCALL		0x0001			/* socket upcall in progress */
#define NSO_DEAD		0x0002			/* socket is dead */
#define NSO_CONNECTING		0x0004			/* socket is being connected */
#define NSO_CONNECTED		0x0008			/* socket connection complete */
#define NSO_PINGING		0x0010			/* socket is being tested */
#define NSO_VERIFIED		0x0020			/* socket appears functional */
#define NSO_DISCONNECTING	0x0040			/* socket is being disconnected */

/* NFS connect socket search state */
struct nfs_socket_search {
	struct nfs_location_index nss_startloc;		/* starting location index */
	struct nfs_location_index nss_nextloc;		/* next location index */
	struct nfssocketlist	nss_socklist;		/* list of active sockets */
	time_t			nss_timestamp;		/* search start time */
	time_t			nss_last;		/* timestamp of last socket */
	struct nfs_socket *	nss_sock;		/* found socket */
	uint8_t			nss_sotype;		/* TCP/UDP */
	uint8_t			nss_sockcnt;		/* # of active sockets */
	in_port_t		nss_port;		/* port # to connect to */
	uint32_t		nss_protocol;		/* RPC protocol */
	uint32_t		nss_version;		/* RPC protocol version */
	uint32_t		nss_flags;		/* (see below) */
	int			nss_addrcnt;		/* Number addresses to try or left */
	int			nss_timeo;		/* how long we are willing to wait */
	int			nss_error;		/* best error we've gotten so far */
};
/* nss_flags */
#define NSS_VERBOSE		0x00000001		/* OK to log info about socket search */
#define NSS_WARNED		0x00000002		/* logged warning about socket search taking a while */
#define NSS_FALLBACK2PMAP	0x00000004		/* Try V4 on NFS_PORT first, if that fails fall back to portmapper */

/*
 * function table for calling version-specific NFS functions
 */
struct nfs_funcs {
	int	(*nf_mount)(struct nfsmount *, vfs_context_t, nfsnode_t *);
	int	(*nf_update_statfs)(struct nfsmount *, vfs_context_t);
	int	(*nf_getquota)(struct nfsmount *, vfs_context_t, uid_t, int, struct dqblk *);
	int	(*nf_access_rpc)(nfsnode_t, u_int32_t *, int, vfs_context_t);
	int	(*nf_getattr_rpc)(nfsnode_t, mount_t, u_char *, size_t, int, vfs_context_t, struct nfs_vattr *, u_int64_t *);
	int	(*nf_setattr_rpc)(nfsnode_t, struct vnode_attr *, vfs_context_t);
	int	(*nf_read_rpc_async)(nfsnode_t, off_t, size_t, thread_t, kauth_cred_t, struct nfsreq_cbinfo *, struct nfsreq **);
	int	(*nf_read_rpc_async_finish)(nfsnode_t, struct nfsreq *, uio_t, size_t *, int *);
	int	(*nf_readlink_rpc)(nfsnode_t, char *, uint32_t *, vfs_context_t);
	int	(*nf_write_rpc_async)(nfsnode_t, uio_t, size_t, thread_t, kauth_cred_t, int, struct nfsreq_cbinfo *, struct nfsreq **);
	int	(*nf_write_rpc_async_finish)(nfsnode_t, struct nfsreq *, int *, size_t *, uint64_t *);
	int	(*nf_commit_rpc)(nfsnode_t, uint64_t, uint64_t, kauth_cred_t, uint64_t);
	int	(*nf_lookup_rpc_async)(nfsnode_t, char *, int, vfs_context_t, struct nfsreq **);
	int	(*nf_lookup_rpc_async_finish)(nfsnode_t, char *, int, vfs_context_t, struct nfsreq *, u_int64_t *, fhandle_t *, struct nfs_vattr *);
	int	(*nf_remove_rpc)(nfsnode_t, char *, int, thread_t, kauth_cred_t);
	int	(*nf_rename_rpc)(nfsnode_t, char *, int, nfsnode_t, char *, int, vfs_context_t);
	int	(*nf_setlock_rpc)(nfsnode_t, struct nfs_open_file *, struct nfs_file_lock *, int, int, thread_t, kauth_cred_t);
	int	(*nf_unlock_rpc)(nfsnode_t, struct nfs_lock_owner *, int, uint64_t, uint64_t, int, thread_t, kauth_cred_t);
	int	(*nf_getlock_rpc)(nfsnode_t, struct nfs_lock_owner *, struct flock *, uint64_t, uint64_t, vfs_context_t);
};

/*
 * The long form of the NFSv4 client ID.
 */
struct nfs_client_id {
	TAILQ_ENTRY(nfs_client_id)	nci_link;	/* list of client IDs */
	char				*nci_id;	/* client id buffer */
	int				nci_idlen;	/* length of client id buffer */
};
TAILQ_HEAD(nfsclientidlist, nfs_client_id);
extern struct nfsclientidlist nfsclientids;

/*
 * Mount structure.
 * One allocated on every NFS mount.
 * Holds NFS specific information for mount.
 */
struct nfsmount {
	lck_mtx_t nm_lock;		/* nfs mount lock */
	char *	nm_args;		/* NFS mount args (XDR) */
	uint32_t nm_mattrs[NFS_MATTR_BITMAP_LEN]; /* mount attributes in mount args */
	uint32_t nm_mflags_mask[NFS_MFLAG_BITMAP_LEN]; /* mount flags mask in mount args */
	uint32_t nm_mflags[NFS_MFLAG_BITMAP_LEN]; /* mount flags in mount args */
	uint32_t nm_flags[NFS_MFLAG_BITMAP_LEN]; /* current mount flags (soft, intr, etc...) */
	char *  nm_realm;		/* Kerberos realm to use */
	char *  nm_principal;		/* GSS principal to use on initial mount */
	char *	nm_sprinc;		/* Kerberos principal of the server */
	int	nm_ref;			/* Reference count on this mount */
	int	nm_state;		/* Internal state flags */
	int	nm_vers;		/* NFS version */
	uint32_t nm_minor_vers;		/* minor version of above */
	uint32_t nm_min_vers;		/* minimum packed version to try */
	uint32_t nm_max_vers;		/* maximum packed version to try */
	struct nfs_funcs *nm_funcs;	/* version-specific functions */
	kauth_cred_t nm_mcred;		/* credential used for the mount */
	mount_t	nm_mountp;		/* VFS structure for this filesystem */
	nfsnode_t nm_dnp;		/* root directory nfsnode pointer */
	struct nfs_fs_locations nm_locations; /* file system locations */
	uint32_t nm_numgrps;		/* Max. size of groupslist */
	TAILQ_HEAD(, nfs_gss_clnt_ctx) nm_gsscl;	/* GSS user contexts */
	uint32_t nm_ncentries;		/* GSS expired negative cache entries */
	int	nm_timeo;		/* Init timer for NFSMNT_DUMBTIMR */
	int	nm_retry;		/* Max retries */
	uint32_t nm_rsize;		/* Max size of read rpc */
	uint32_t nm_wsize;		/* Max size of write rpc */
	uint32_t nm_biosize;		/* buffer I/O size */
	uint32_t nm_readdirsize;	/* Size of a readdir rpc */
	uint32_t nm_readahead;		/* Num. of blocks to readahead */
	uint32_t nm_acregmin;		/* reg file min attr cache timeout */
	uint32_t nm_acregmax;		/* reg file max attr cache timeout */
	uint32_t nm_acdirmin;		/* dir min attr cache timeout */
	uint32_t nm_acdirmax;		/* dir max attr cache timeout */
	uint32_t nm_auth;		/* security mechanism flavor being used */
	uint32_t nm_writers;		/* Number of nodes open for writing */
	uint32_t nm_mappers;		/* Number of nodes that have mmapped */
	struct nfs_sec nm_sec;		/* acceptable security mechanism flavors */
	struct nfs_sec nm_servsec;	/* server's acceptable security mechanism flavors */
	fhandle_t *nm_fh;		/* initial file handle */
	uint8_t  nm_lockmode;		/* advisory file locking mode */
	/* mount info */
	uint32_t nm_fsattrstamp;	/* timestamp for fs attrs */
	struct nfs_fsattr nm_fsattr;	/* file system attributes */
	uint64_t nm_verf;		/* v3/v4 write verifier */
	union {
	    struct {			/* v2/v3 specific fields */
		TAILQ_ENTRY(nfsmount) ldlink; /* chain of mounts registered for lockd use */
		int udp_sent;		/* UDP request send count */
		int udp_cwnd;		/* UDP request congestion window */
		struct nfs_reqqhead udp_cwndq; /* requests waiting on cwnd */
		struct sockaddr *rqsaddr;/* cached rquota socket address */
		uint32_t rqsaddrstamp;	/* timestamp of rquota socket address */
	    } v3;
	    struct {			/* v4 specific fields */
		struct nfs_client_id *longid; /* client ID, long form */
		uint64_t mounttime;	/* used as client ID verifier */
		uint64_t clientid;	/* client ID, short form */
		thread_call_t renew_timer; /* RENEW timer call */
		nfs_fsid fsid;		/* NFS file system id */
		TAILQ_HEAD(, nfsnode) delegations; /* list of nodes with delegations */
		TAILQ_HEAD(, nfsnode) dreturnq; /* list of nodes with delegations to return */
		TAILQ_ENTRY(nfsmount) cblink; /* chain of mounts registered for callbacks */
		uint32_t cbid;		/* callback channel identifier */
		uint32_t cbrefs;	/* # callbacks using this mount */
	    } v4;
	} nm_un;
	/* common state */
	TAILQ_HEAD(, nfs_open_owner) nm_open_owners; /* list of open owners */
	uint32_t nm_stateinuse;		/* state in use counter */
	uint32_t nm_stategenid;		/* state generation counter */
	time_t	nm_recover_start;	/* recover start time */
 	LIST_HEAD(, nfsnode) nm_monlist; /* list of nodes being monitored */
	/* async I/O queue */
	struct nfs_reqqhead nm_resendq;	/* async I/O resend queue */
	struct nfs_reqqhead nm_iodq;	/* async I/O request queue */
	struct nfsiod *nm_niod;		/* nfsiod processing this mount */
	TAILQ_ENTRY(nfsmount) nm_iodlink; /* chain of mounts awaiting nfsiod */
	int	nm_asyncwrites;		/* outstanding async I/O writes */
	/* socket state */
	uint8_t	nm_sofamily;		/* (preferred) protocol family of socket */
	uint8_t	nm_sotype;		/* (preferred) type of socket */
	in_port_t	nm_nfsport;	/* NFS protocol port */
	in_port_t	nm_mountport;	/* MOUNT protocol port (v2/v3) */
	struct nfs_socket_search *nm_nss; /* current socket search structure */
	struct nfs_socket *nm_nso;	/* current socket */
	struct sockaddr	*nm_saddr;	/* Address of server */
	u_short nm_sockflags;		/* socket state flags */
	time_t	nm_deadto_start;	/* dead timeout start time */
	time_t	nm_reconnect_start;	/* reconnect start time */
	int	nm_tprintf_initial_delay;	/* delay first "server down" */
	int	nm_tprintf_delay;	/* delay between "server down" */
	int	nm_deadtimeout;		/* delay between first "server down" and dead set at mount time */
	int	nm_curdeadtimeout;	/* current dead timeout. Adjusted by mount state and mobility */
	int	nm_srtt[4];		/* Timers for RPCs */
	int	nm_sdrtt[4];
	int	nm_timeouts;		/* Request timeouts */
	int	nm_jbreqs;		/* # R_JBTPRINTFMSG requests */
	int	nm_mounterror;		/* status of mount connect */
	TAILQ_ENTRY(nfsmount) nm_pokeq;	/* mount poke queue chain */
	thread_t nm_sockthd;		/* socket thread for this mount */
};

/* macro for checking current mount flags */
#define NMFLAG(NMP, F)		NFS_BITMAP_ISSET((NMP)->nm_flags, NFS_MFLAG_ ## F)
/* macros for checking (original) mount attributes/flags */
#define NM_OMATTR_GIVEN(NMP, F)	NFS_BITMAP_ISSET((NMP)->nm_mattrs, NFS_MATTR_ ## F)
#define NM_OMFLAG_GIVEN(NMP, F)	NFS_BITMAP_ISSET((NMP)->nm_mflags_mask, NFS_MFLAG_ ## F)
#define NM_OMFLAG(NMP, F)	NFS_BITMAP_ISSET((NMP)->nm_mflags, NFS_MFLAG_ ## F)

/*
 * NFS mount state flags (nm_state)
 */
#define NFSSTA_MOUNT_THREAD	0x00000040  /* nfs_mount_connect_thread running */
#define NFSSTA_MONITOR_SCAN	0x00000080  /* scan of monitored nodes in progress */
#define NFSSTA_UNMOUNTING	0x00000100  /* an unmount attempt is in progress */
#define NFSSTA_NEEDSECINFO	0x00000200  /* need to fetch security info */
#define NFSSTA_CLIENTID		0x00000400  /* short client ID is valid */
#define NFSSTA_BIGCOOKIES	0x00000800  /* have seen >32bit dir cookies */
#define NFSSTA_JUKEBOXTIMEO	0x00001000  /* experienced a jukebox timeout */
#define NFSSTA_LOCKTIMEO	0x00002000  /* experienced a lock req timeout */
#define NFSSTA_MOUNTED		0x00004000  /* completely mounted */
#define NFSSTA_LOCKSWORK	0x00008000  /* lock ops have worked. */
#define NFSSTA_TIMEO		0x00010000  /* experienced a timeout. */
#define NFSSTA_FORCE		0x00020000  /* doing a forced unmount. */
#define NFSSTA_HASWRITEVERF	0x00040000  /* Has write verifier for V3 */
#define NFSSTA_GOTPATHCONF	0x00080000  /* Got the V3 pathconf info */
#define NFSSTA_GOTFSINFO	0x00100000  /* Got the V3 fsinfo */
#define NFSSTA_SENDING		0x00800000  /* Sending on socket */
#define NFSSTA_SNDLOCK		0x01000000  /* Send socket lock */
#define NFSSTA_WANTSND		0x02000000  /* Want above */
#define NFSSTA_DEAD		0x04000000  /* mount is dead */
#define NFSSTA_RECOVER		0x08000000  /* mount state needs to be recovered */
#define NFSSTA_RECOVER_EXPIRED	0x10000000  /* mount state expired */
#define NFSSTA_REVOKE		0x20000000  /* need to scan for revoked nodes */
#define	NFSSTA_SQUISHY		0x40000000  /* we can ask to be forcibly unmounted */
#define NFSSTA_MOUNT_DRAIN	0x80000000  /* mount is draining references */

/* flags for nm_sockflags */
#define NMSOCK_READY		0x0001	/* socket is ready for use */
#define NMSOCK_CONNECTING	0x0002	/* socket is being connect()ed */
#define NMSOCK_SETUP		0x0004	/* socket/connection is being set up */
#define NMSOCK_UNMOUNT		0x0008	/* unmounted, no more socket activity */
#define NMSOCK_HASCONNECTED	0x0010	/* socket has connected before */
#define NMSOCK_POKE		0x0020	/* socket needs to be poked */
#define NMSOCK_DISCONNECTING	0x0080	/* socket is being disconnected */

/* aliases for version-specific fields */
#define nm_ldlink	nm_un.v3.ldlink
#define nm_sent		nm_un.v3.udp_sent
#define nm_cwnd		nm_un.v3.udp_cwnd
#define nm_cwndq	nm_un.v3.udp_cwndq
#define nm_rqproto	nm_un.v3.rqproto
#define nm_rqsaddr	nm_un.v3.rqsaddr
#define nm_rqsaddrstamp	nm_un.v3.rqsaddrstamp
#define nm_longid	nm_un.v4.longid
#define nm_clientid	nm_un.v4.clientid
#define nm_mounttime	nm_un.v4.mounttime
#define nm_fsid		nm_un.v4.fsid
#define nm_renew_timer	nm_un.v4.renew_timer
#define nm_cbid		nm_un.v4.cbid
#define nm_cblink	nm_un.v4.cblink
#define nm_cbrefs	nm_un.v4.cbrefs
#define nm_delegations	nm_un.v4.delegations
#define nm_dreturnq	nm_un.v4.dreturnq


#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_NFSMOUNT_H_ */
                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfsnode.h                                       0100644 0001750 0001750 00000076563 12567450754 022213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsnode.h	8.9 (Berkeley) 5/14/95
 * FreeBSD-Id: nfsnode.h,v 1.24 1997/10/28 14:06:25 bde Exp $
 */


#ifndef _NFS_NFSNODE_H_
#define _NFS_NFSNODE_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE
#ifndef _NFS_NFS_H_
#include <nfs/nfs.h>
#endif
#include <sys/kauth.h>

/*
 * Silly rename structure that hangs off the nfsnode until the name
 * can be removed by nfs_vnop_inactive()
 */
struct nfs_sillyrename {
	kauth_cred_t	nsr_cred;
	struct nfsnode	*nsr_dnp;
	int		nsr_namlen;
	char		nsr_name[20];
};

/*
 * The nfsbuf is the nfs equivalent to a struct buf.
 */
struct nfsbuf {
	LIST_ENTRY(nfsbuf)	nb_hash;	/* hash chain */
	LIST_ENTRY(nfsbuf)	nb_vnbufs;	/* nfsnode's nfsbuf chain */
	TAILQ_ENTRY(nfsbuf)	nb_free;	/* free list position if not active. */
	volatile uint32_t	nb_flags;	/* NB_* flags. */
	volatile uint32_t	nb_lflags;	/* NBL_* flags. */
	volatile uint32_t	nb_refs;	/* outstanding references. */
	uint32_t		nb_bufsize;	/* buffer size */
	daddr64_t		nb_lblkno;	/* logical block number. */
	uint64_t		nb_verf;	/* V3 write verifier */
	int			nb_commitlevel;	/* lowest write commit level */
	time_t			nb_timestamp;	/* buffer timestamp */
	int			nb_error;	/* errno value. */
	u_int32_t		nb_valid;	/* valid pages in buf */
	u_int32_t		nb_dirty;	/* dirty pages in buf */
	int			nb_validoff;	/* offset in buffer of valid region. */
	int			nb_validend;	/* offset of end of valid region. */
	int			nb_dirtyoff;	/* offset in buffer of dirty region. */
	int			nb_dirtyend;	/* offset of end of dirty region. */
	int			nb_offio;	/* offset in buffer of I/O region. */
	int			nb_endio;	/* offset of end of I/O region. */
	int			nb_rpcs;	/* Count of RPCs remaining for this buffer. */
	caddr_t			nb_data;	/* mapped buffer */
	nfsnode_t		nb_np;		/* nfsnode buffer belongs to */
	kauth_cred_t		nb_rcred;	/* read credentials reference */
	kauth_cred_t		nb_wcred;	/* write credentials reference */
	void *			nb_pagelist;	/* upl */
};

#define NFS_MAXBSIZE	(32 * PAGE_SIZE)	/* valid/dirty page masks limit buffer size */

#define NFS_A_LOT_OF_NEEDCOMMITS	256			/* max# uncommitted buffers for a node */
#define NFS_A_LOT_OF_DELAYED_WRITES	MAX(nfsbufcnt/8,512)	/* max# "delwri" buffers in system */

/*
 * These flags are kept in b_lflags...
 * nfs_buf_mutex must be held before examining/updating
 */
#define	NBL_BUSY	0x00000001	/* I/O in progress. */
#define	NBL_WANTED	0x00000002	/* Process wants this buffer. */

/*
 * These flags are kept in nb_flags and they're (purposefully)
 * very similar to the B_* flags for struct buf.
 * nfs_buf_mutex is not needed to examine/update these.
 */
#define	NB_STALEWVERF	0x00000001	/* write verifier changed on us */
#define	NB_NEEDCOMMIT	0x00000002	/* buffer needs to be committed */
#define	NB_ASYNC	0x00000004	/* Start I/O, do not wait. */
#define	NB_CACHE	0x00000020	/* buffer data found in the cache */
#define	NB_STABLE	0x00000040	/* write FILESYNC not UNSTABLE */
#define	NB_DELWRI	0x00000080	/* delayed write: dirty range needs to be written */
#define	NB_DONE		0x00000200	/* I/O completed. */
#define	NB_EINTR	0x00000400	/* I/O was interrupted */
#define	NB_ERROR	0x00000800	/* I/O error occurred. */
#define	NB_INVAL	0x00002000	/* Does not contain valid info. */
#define	NB_NCRDAHEAD	0x00004000	/* "nocache readahead" data */
#define	NB_NOCACHE	0x00008000	/* Do not cache block after use. */
#define	NB_WRITE	0x00000000	/* Write buffer (pseudo flag). */
#define	NB_READ		0x00100000	/* Read buffer. */
#define	NB_MULTASYNCRPC	0x00200000	/* multiple async RPCs issued for buffer */
#define	NB_PAGELIST	0x00400000	/* Buffer describes pagelist I/O. */
#define	NB_WRITEINPROG	0x01000000	/* Write in progress. */
#define	NB_META		0x40000000	/* buffer contains meta-data. */

/* Flags for operation type in nfs_buf_get() */
#define	NBLK_READ	0x00000001	/* buffer for read */
#define	NBLK_WRITE	0x00000002	/* buffer for write */
#define	NBLK_META	0x00000004	/* buffer for metadata */
#define	NBLK_OPMASK	0x00000007	/* operation mask */
/* modifiers for above flags... */
#define NBLK_NOWAIT	0x40000000	/* don't wait on busy buffer */
#define NBLK_ONLYVALID	0x80000000	/* only return cached buffer */

/* These flags are used for nfsbuf iterating */
#define NBI_ITER		0x01	/* iteration in progress */
#define NBI_ITERWANT		0x02	/* waiting to iterate */
#define NBI_CLEAN		0x04	/* requesting clean buffers */
#define NBI_DIRTY		0x08	/* requesting dirty buffers */
#define NBI_NOWAIT		0x10	/* don't block on NBI_ITER */

/* Flags for nfs_buf_acquire */
#define NBAC_NOWAIT		0x01	/* Don't wait if buffer is busy */
#define NBAC_REMOVE		0x02	/* Remove from free list once buffer is acquired */

/* some convenience macros...  */
#define NBOFF(BP)			((off_t)(BP)->nb_lblkno * (off_t)(BP)->nb_bufsize)
#define NBPGVALID(BP,P)			(((BP)->nb_valid >> (P)) & 0x1)
#define NBPGDIRTY(BP,P)			(((BP)->nb_dirty >> (P)) & 0x1)
#define NBPGVALID_SET(BP,P)		((BP)->nb_valid |= (1 << (P)))
#define NBPGDIRTY_SET(BP,P)		((BP)->nb_dirty |= (1 << (P)))

#define NBUFSTAMPVALID(BP)		((BP)->nb_timestamp != ~0)
#define NBUFSTAMPINVALIDATE(BP)		((BP)->nb_timestamp = ~0)

#define NFS_BUF_MAP(BP) \
	do { \
		if (!(BP)->nb_data && nfs_buf_map(BP)) \
			panic("nfs_buf_map failed"); \
	} while (0)

LIST_HEAD(nfsbuflists, nfsbuf);
TAILQ_HEAD(nfsbuffreehead, nfsbuf);

extern lck_mtx_t *nfs_buf_mutex;
extern int nfsbufcnt, nfsbufmin, nfsbufmax, nfsbufmetacnt, nfsbufmetamax;
extern int nfsbuffreecnt, nfsbuffreemetacnt, nfsbufdelwricnt, nfsneedbuffer;
extern int nfs_nbdwrite;
extern struct nfsbuffreehead nfsbuffree, nfsbufdelwri;

#ifdef NFSBUFDEBUG
#define NFSBUFCNTCHK() \
	do { \
	if (	(nfsbufcnt < 0) || \
		(nfsbufcnt > nfsbufmax) || \
		(nfsbufmetacnt < 0) || \
		(nfsbufmetacnt > nfsbufmetamax) || \
		(nfsbufmetacnt > nfsbufcnt) || \
		(nfsbuffreecnt < 0) || \
		(nfsbuffreecnt > nfsbufmax) || \
		(nfsbuffreecnt > nfsbufcnt) || \
		(nfsbuffreemetacnt < 0) || \
		(nfsbuffreemetacnt > nfsbufmax) || \
		(nfsbuffreemetacnt > nfsbufcnt) || \
		(nfsbuffreemetacnt > nfsbufmetamax) || \
		(nfsbuffreemetacnt > nfsbufmetacnt) || \
		(nfsbufdelwricnt < 0) || \
		(nfsbufdelwricnt > nfsbufmax) || \
		(nfsbufdelwricnt > nfsbufcnt) || \
		(nfs_nbdwrite < 0) || \
		(nfs_nbdwrite > nfsbufcnt) || \
		0) \
		panic("nfsbuf count error: max %d meta %d cnt %d meta %d free %d meta %d delwr %d bdw %d\n", \
			nfsbufmax, nfsbufmetamax, nfsbufcnt, nfsbufmetacnt, nfsbuffreecnt, nfsbuffreemetacnt, \
			nfsbufdelwricnt, nfs_nbdwrite); \
	} while (0)
#else
#define NFSBUFCNTCHK()
#endif

/*
 * NFS directory buffer
 *
 * Each buffer for a directory consists of:
 *
 * - a small header
 * - a packed list of direntry structures
 *   (if RDIRPLUS is enabled, a file handle and attrstamp are
 *   packed after the direntry name.)
 * - free/unused space
 * - if RDIRPLUS is enabled, an array of attributes
 *   that is indexed backwards from the end of the buffer.
 */
struct nfs_dir_buf_header {
	uint16_t	ndbh_flags;	/* flags (see below) */
	uint16_t	ndbh_count;	/* # of entries */
	uint32_t	ndbh_entry_end;	/* end offset of direntry data */
	uint32_t	ndbh_ncgen;	/* name cache generation# */
	uint32_t	ndbh_pad;	/* reserved */
};
/* ndbh_flags */
#define NDB_FULL	0x0001	/* buffer has been filled */
#define NDB_EOF		0x0002	/* buffer contains EOF */
#define NDB_PLUS	0x0004	/* buffer contains RDIRPLUS data */

#define NFS_DIR_BUF_FIRST_DIRENTRY(BP) \
	((struct direntry*)((char*)((BP)->nb_data) + sizeof(*ndbhp)))
#define NFS_DIR_BUF_NVATTR(BP, IDX) \
	(&((struct nfs_vattr*)((char*)((BP)->nb_data) + (BP)->nb_bufsize))[-((IDX)+1)])
#define NFS_DIRENTRY_LEN(namlen) \
	((sizeof(struct direntry) + (namlen) - (MAXPATHLEN-1) + 7) & ~7)
#define NFS_DIRENT_LEN(namlen) \
	((sizeof(struct dirent) - (NAME_MAX+1)) + (((namlen) + 1 + 3) &~ 3))
#define NFS_DIRENTRY_NEXT(DP) \
	((struct direntry*)((char*)(DP) + (DP)->d_reclen))
#define NFS_DIR_COOKIE_POTENTIALLY_TRUNCATED(C) \
	((C) && ((((C) >> 32) == 0) || (((C) & 0x80000000ULL) && (((C) >> 32) == 0xffffffff))))
#define NFS_DIR_COOKIE_SAME32(C1, C2) \
	(((C1) & 0xffffffffULL) == ((C2) & 0xffffffffULL))

/*
 * NFS directory cookie cache
 *
 * This structure is used to cache cookie-to-buffer mappings for
 * cookies recently returned from READDIR.  The entries are kept in an
 * array.  The most-recently-used (MRU) list is headed by the entry at
 * index "mru".  The index of the next entry in the list is kept in the
 * "next" array.  (An index value of -1 marks an invalid entry.)
 */
#define NFSNUMCOOKIES		14
struct nfsdmap {
	int8_t		free;			/* next unused slot */
	int8_t		mru;			/* head of MRU list */
	int8_t		next[NFSNUMCOOKIES];	/* MRU list links */
	struct {
	    uint64_t	key;			/* cookie */
	    uint64_t	lbn;			/* lbn of buffer */
	} cookies[NFSNUMCOOKIES];		/* MRU list entries */
};

/*
 * NFS vnode attribute structure
 */
#define NFSTIME_ACCESS	0	/* time of last access */
#define NFSTIME_MODIFY	1	/* time of last modification */
#define NFSTIME_CHANGE	2	/* time file changed */
#define NFSTIME_CREATE	3	/* time file created */
#define NFSTIME_BACKUP	4	/* time of last backup */
#define NFSTIME_COUNT	5

#define NFS_COMPARE_MTIME(TVP, NVAP, CMP) \
	(((TVP)->tv_sec == (NVAP)->nva_timesec[NFSTIME_MODIFY]) ?	\
	 ((TVP)->tv_nsec CMP (NVAP)->nva_timensec[NFSTIME_MODIFY]) :	\
	 ((TVP)->tv_sec CMP (NVAP)->nva_timesec[NFSTIME_MODIFY]))
#define NFS_COPY_TIME(TVP, NVAP, WHICH) \
	do { \
	(TVP)->tv_sec = (NVAP)->nva_timesec[NFSTIME_##WHICH]; \
	(TVP)->tv_nsec = (NVAP)->nva_timensec[NFSTIME_##WHICH]; \
	} while (0)

struct nfs_vattr {
	enum vtype	nva_type;	/* vnode type (for create) */
	uint32_t	nva_mode;	/* file's access mode (and type) */
	uid_t		nva_uid;	/* owner user id */
	gid_t		nva_gid;	/* owner group id */
	guid_t		nva_uuuid;	/* owner user UUID */
	guid_t		nva_guuid;	/* owner group UUID */
	kauth_acl_t	nva_acl;	/* access control list */
	nfs_specdata	nva_rawdev;	/* device the special file represents */
	uint32_t	nva_flags;	/* file flags (see below) */
	uint32_t	nva_maxlink;	/* maximum # of links (v4) */
	uint64_t	nva_nlink;	/* number of references to file */
	uint64_t	nva_fileid;	/* file id */
	nfs_fsid	nva_fsid;	/* file system id */
	uint64_t	nva_size;	/* file size in bytes */
	uint64_t	nva_bytes;	/* bytes of disk space held by file */
	uint64_t	nva_change;	/* change attribute */
	int64_t		nva_timesec[NFSTIME_COUNT];
	int32_t		nva_timensec[NFSTIME_COUNT];
	uint32_t 	nva_bitmap[NFS_ATTR_BITMAP_LEN]; /* attributes that are valid */
};

/* nva_flags */
#define NFS_FFLAG_ARCHIVED		0x0001
#define NFS_FFLAG_HIDDEN		0x0002
#define NFS_FFLAG_HAS_NAMED_ATTRS	0x0004	/* file has named attributes */
#define NFS_FFLAG_TRIGGER		0x0008	/* node is a trigger/mirror mount point */
#define NFS_FFLAG_TRIGGER_REFERRAL	0x0010	/* trigger is a referral */
#define NFS_FFLAG_IS_ATTR		0x8000	/* file is a named attribute file/directory */

/* flags for nfs_getattr() */
#define NGA_CACHED	0x0001	/* use cached attributes (if still valid) */
#define NGA_UNCACHED	0x0002	/* fetch new attributes */
#define NGA_ACL		0x0004	/* fetch ACL */
#define NGA_MONITOR	0x0008	/* vnode monitor attr update poll */
#define NGA_SOFT	0x0010	/* use cached attributes if ETIMEOUT */

/* macros for initting/cleaning up nfs_vattr structures */
#define	NVATTR_INIT(NVAP) \
	do { \
		NFS_CLEAR_ATTRIBUTES((NVAP)->nva_bitmap); \
		(NVAP)->nva_flags = 0; \
		(NVAP)->nva_acl = NULL; \
	} while (0)
#define	NVATTR_CLEANUP(NVAP) \
	do { \
		NFS_CLEAR_ATTRIBUTES((NVAP)->nva_bitmap); \
		if ((NVAP)->nva_acl) { \
			kauth_acl_free((NVAP)->nva_acl); \
			(NVAP)->nva_acl = NULL; \
		} \
	} while (0)

/*
 * macros for detecting node changes
 *
 * These macros help us determine if a file has been changed on the server and
 * thus whether or not we need to invalidate any cached data.
 *
 * For NFSv2/v3, the modification time is used.
 * For NFSv4, the change attribute is used.
 */
#define NFS_CHANGED(VERS, NP, NVAP) \
		(((VERS) >= NFS_VER4) ? \
			((NP)->n_change != (NVAP)->nva_change) : \
			NFS_COMPARE_MTIME(&(NP)->n_mtime, (NVAP), !=))
#define NFS_CHANGED_NC(VERS, NP, NVAP) \
		(((VERS) >= NFS_VER4) ? \
			((NP)->n_ncchange != (NVAP)->nva_change) : \
			NFS_COMPARE_MTIME(&(NP)->n_ncmtime, (NVAP), !=))
#define NFS_CHANGED_UPDATE(VERS, NP, NVAP) \
	do { \
		if ((VERS) >= NFS_VER4) \
			(NP)->n_change = (NVAP)->nva_change; \
		else \
			NFS_COPY_TIME(&(NP)->n_mtime, (NVAP), MODIFY); \
	} while (0)
#define NFS_CHANGED_UPDATE_NC(VERS, NP, NVAP) \
	do { \
		if ((VERS) >= NFS_VER4) \
			(NP)->n_ncchange = (NVAP)->nva_change; \
		else \
			NFS_COPY_TIME(&(NP)->n_ncmtime, (NVAP), MODIFY); \
	} while (0)


extern lck_grp_t *nfs_open_grp;
extern uint32_t nfs_open_owner_seqnum, nfs_lock_owner_seqnum;

/*
 * NFSv4 open owner structure - one per cred per mount
 */
struct nfs_open_owner {
	TAILQ_ENTRY(nfs_open_owner)	noo_link;	/* List of open owners (on mount) */
	lck_mtx_t			noo_lock;	/* owner mutex */
	struct nfsmount *		noo_mount;	/* NFS mount */
	uint32_t			noo_refcnt;	/* # outstanding references */
	uint32_t			noo_flags;	/* see below */
	kauth_cred_t			noo_cred;	/* credentials of open owner */
	uint32_t			noo_name;	/* unique name used otw */
	uint32_t			noo_seqid;	/* client-side sequence ID */
	TAILQ_HEAD(,nfs_open_file)	noo_opens;	/* list of open files */
};
/* noo_flags */
#define NFS_OPEN_OWNER_LINK	0x1	/* linked into mount's open owner list */
#define NFS_OPEN_OWNER_BUSY	0x2	/* open state-modifying operation in progress */
#define NFS_OPEN_OWNER_WANT	0x4	/* someone else wants to mark busy */

/*
 * NFS open file structure - one per open owner per nfsnode
 */
struct nfs_open_file {
	lck_mtx_t			nof_lock;		/* open file mutex */
	TAILQ_ENTRY(nfs_open_file)	nof_link;		/* list of open files */
	TAILQ_ENTRY(nfs_open_file)	nof_oolink;		/* list of open owner's open files */
	struct nfs_open_owner *		nof_owner;		/* open owner */
	nfsnode_t			nof_np;			/* nfsnode this open is for */
	nfs_stateid			nof_stateid;		/* open stateid */
	thread_t			nof_creator;		/* thread that created file */
	uint32_t			nof_opencnt;		/* open file count */
	uint16_t			nof_flags;		/* see below */
	uint8_t				nof_access:4;		/* access mode for this open */
	uint8_t				nof_deny:4;		/* deny mode for this open */
	uint8_t				nof_mmap_access:4;	/* mmap open access mode */
	uint8_t				nof_mmap_deny:4;	/* mmap open deny mode */
	/* counts of access/deny mode open combinations */
	uint32_t			nof_r;			/* read opens (deny none) */
	uint32_t			nof_w;			/* write opens (deny none) */
	uint32_t			nof_rw;			/* read/write opens (deny none) */
	uint32_t			nof_r_dw;		/* read deny-write opens */
	/* the rest of the counts have a max of 2 (1 for open + 1 for mmap) */
	uint32_t			nof_w_dw:2;		/* write deny-write opens (max 2) */
	uint32_t			nof_rw_dw:2;		/* read/write deny-write opens (max 2) */
	uint32_t			nof_r_drw:2;		/* read deny-read/write opens (max 2) */
	uint32_t			nof_w_drw:2;		/* write deny-read/write opens (max 2) */
	uint32_t			nof_rw_drw:2;		/* read/write deny-read/write opens (max 2) */
	/* counts of DELEGATED access/deny mode open combinations */
	uint32_t			nof_d_w_dw:2;		/* write deny-write opens (max 2) */
	uint32_t			nof_d_rw_dw:2;		/* read/write deny-write opens (max 2) */
	uint32_t			nof_d_r_drw:2;		/* read deny-read/write opens (max 2) */
	uint32_t			nof_d_w_drw:2;		/* write deny-read/write opens (max 2) */
	uint32_t			nof_d_rw_drw:2;		/* read/write deny-read/write opens (max 2) */
	uint32_t			nof_d_r;		/* read opens (deny none) */
	uint32_t			nof_d_w;		/* write opens (deny none) */
	uint32_t			nof_d_rw;		/* read/write opens (deny none) */
	uint32_t			nof_d_r_dw;		/* read deny-write opens */
};
/* nof_flags */
#define NFS_OPEN_FILE_BUSY	0x0001	/* open state-modifying operation in progress */
#define NFS_OPEN_FILE_WANT	0x0002	/* someone else wants to mark busy */
#define NFS_OPEN_FILE_CREATE	0x0004	/* has an open(RW) from a "CREATE" call */
#define NFS_OPEN_FILE_NEEDCLOSE	0x0008	/* has an open(R) from an (unopen) VNOP_READ or VNOP_MMAP call */
#define NFS_OPEN_FILE_SETATTR	0x0020	/* has an open(W) to perform a SETATTR(size) */
#define NFS_OPEN_FILE_POSIXLOCK	0x0040	/* server supports POSIX locking semantics */
#define NFS_OPEN_FILE_LOST	0x0080	/* open state has been lost */
#define NFS_OPEN_FILE_REOPEN	0x0100	/* file needs to be reopened */
#define NFS_OPEN_FILE_REOPENING	0x0200	/* file is being reopened */

struct nfs_lock_owner;
/*
 * NFS file lock
 *
 * Each lock request (pending or granted) has an
 * nfs_file_lock structure representing its state.
 */
struct nfs_file_lock {
	TAILQ_ENTRY(nfs_file_lock)	nfl_link;	/* List of locks on nfsnode */
	TAILQ_ENTRY(nfs_file_lock)	nfl_lolink;	/* List of locks held by locker */
	struct nfs_lock_owner *		nfl_owner;	/* lock owner that holds this lock */
	uint64_t			nfl_start;	/* starting offset */
	uint64_t			nfl_end;	/* ending offset (inclusive) */
	uint32_t			nfl_blockcnt;	/* # locks blocked on this lock */
	uint16_t			nfl_flags;	/* see below */
	uint8_t				nfl_type;	/* lock type: read/write */
};
/* nfl_flags */
#define NFS_FILE_LOCK_ALLOC		0x01	/* lock was allocated */
#define NFS_FILE_LOCK_STYLE_POSIX	0x02	/* POSIX-style fcntl() lock */
#define NFS_FILE_LOCK_STYLE_FLOCK	0x04	/* flock(2)-style lock */
#define NFS_FILE_LOCK_STYLE_MASK	0x06	/* lock style mask */
#define NFS_FILE_LOCK_WAIT		0x08	/* may block on conflicting locks */
#define NFS_FILE_LOCK_BLOCKED		0x10	/* request is blocked */
#define NFS_FILE_LOCK_DEAD		0x20	/* lock (request) no longer exists */
#define NFS_FILE_LOCK_DELEGATED		0x40	/* lock acquired via delegation */

TAILQ_HEAD(nfs_file_lock_queue, nfs_file_lock);

/*
 * Calculate length of lock range given the endpoints.
 * Note that struct flock has "to EOF" reported as 0 but
 * the NFSv4 protocol has "to EOF" reported as UINT64_MAX.
 */
#define NFS_FLOCK_LENGTH(S, E)	(((E) == UINT64_MAX) ? 0 : ((E) - (S) + 1))
#define NFS_LOCK_LENGTH(S, E)	(((E) == UINT64_MAX) ? UINT64_MAX : ((E) - (S) + 1))

/*
 * NFSv4 lock owner structure - per open owner per process per nfsnode
 *
 * A lock owner is a process + an nfsnode.
 *
 * Note that flock(2) locks technically should have the lock owner be
 * an fglob pointer instead of a process.  However, implementing that
 * correctly would not be trivial.  So, for now, flock(2) locks are
 * essentially treated like whole-file POSIX locks.
 */
struct nfs_lock_owner {
	lck_mtx_t			nlo_lock;	/* owner mutex */
	TAILQ_ENTRY(nfs_lock_owner)	nlo_link;	/* List of lock owners (on nfsnode) */
	struct nfs_open_owner *		nlo_open_owner;	/* corresponding open owner */
	struct nfs_file_lock_queue	nlo_locks;	/* list of locks held */
	struct nfs_file_lock		nlo_alock;	/* most lockers will only ever have one */
	struct timeval			nlo_pid_start;	/* Start time of process id */
	pid_t				nlo_pid;	/* lock-owning process ID */
	uint32_t			nlo_refcnt;	/* # outstanding references */
	uint32_t			nlo_flags;	/* see below */
	uint32_t			nlo_name;	/* unique name used otw */
	uint32_t			nlo_seqid;	/* client-side sequence ID */
	uint32_t			nlo_stategenid;	/* mount state generation ID */
	nfs_stateid			nlo_stateid;	/* lock stateid */
};
/* nlo_flags */
#define NFS_LOCK_OWNER_LINK	0x1	/* linked into mount's lock owner list */
#define NFS_LOCK_OWNER_BUSY	0x2	/* lock state-modifying operation in progress */
#define NFS_LOCK_OWNER_WANT	0x4	/* someone else wants to mark busy */

/*
 * The nfsnode is the NFS equivalent of an inode.
 * There is a unique nfsnode for each NFS vnode.
 * An nfsnode is 'named' by its file handle. (nget/nfs_node.c)
 * NB: Hopefully the current order of the fields is such that everything will
 *     be well aligned and, therefore, tightly packed.
 */

#define NFS_ACCESS_CACHE_SIZE	3

struct nfsnode {
	lck_mtx_t		n_lock;		/* nfs node lock */
	lck_rw_t		n_datalock;	/* nfs node data lock */
	void			*n_datalockowner;/* nfs node data lock owner (exclusive) */
	LIST_ENTRY(nfsnode)	n_hash;		/* Hash chain */
	LIST_ENTRY(nfsnode)	n_monlink;	/* list of monitored nodes */
	u_quad_t		n_size;		/* Current size of file */
	u_quad_t		n_newsize;	/* new size of file (pending update) */
	u_int64_t		n_xid;		/* last xid to loadattr */
	struct nfs_vattr	n_vattr;	/* Vnode attribute cache */
	time_t			n_attrstamp;	/* Attr. cache timestamp */
	time_t			n_aclstamp;	/* ACL cache timestamp */
	time_t			n_evtstamp;	/* last vnode event timestamp */
	uint32_t		n_events;	/* pending vnode events */
	u_int8_t		n_access[NFS_ACCESS_CACHE_SIZE+1];	/* ACCESS cache */
	uid_t                   n_accessuid[NFS_ACCESS_CACHE_SIZE];	/* credentials having access */
	time_t                  n_accessstamp[NFS_ACCESS_CACHE_SIZE];	/* access cache timestamp */
	union {
	    struct {
		struct timespec	n3_mtime;	/* Prev modify time. */
		struct timespec	n3_ncmtime;	/* namecache modify time. */
	    } v3;
	    struct {
		uint64_t	n4_change;	/* prev change attribute */
		uint64_t	n4_ncchange;	/* namecache change attribute */
		u_char		*n4_attrdirfh;	/* associated attr directory fh */
		struct timeval	n4_lastio;	/* time of most recent I/O on attr */
	    } v4;
	} n_un4;
	vnode_t			n_parent;	/* this node's parent */
	u_char			*n_fhp;		/* NFS File Handle */
	vnode_t			n_vnode;	/* associated vnode */
	mount_t			n_mount;	/* associated mount (NHINIT) */
	int			n_error;	/* Save write error value */
	union {
		struct timespec	ns_atim;	/* Special file times */
		struct timespec nl_rltim;	/* Time of last readlink */
		daddr64_t	nf_lastread;	/* last block# read from (for readahead) */
		uint64_t	nd_cookieverf;	/* Cookie verifier (dir only) */
	} n_un1;
	union {
		struct timespec	ns_mtim;	/* Special file times */
		daddr64_t	nf_lastrahead;	/* last block# read ahead */
		uint64_t	nd_eofcookie;	/* Dir. EOF cookie cache */
	} n_un2;
	union {
		struct nfs_sillyrename *nf_silly;/* Ptr to silly rename struct */
		struct nfsdmap *nd_cookiecache; /* dir cookie cache */
	} n_un3;
	uint32_t		n_flag;		/* node flags */
	u_short			n_fhsize;	/* size in bytes, of fh */
	u_short			n_hflag;	/* node hash flags */
	u_short			n_bflag;	/* node buffer flags */
	u_short			n_mflag;	/* node mount flags */
	u_char			n_fh[NFS_SMALLFH];/* Small File Handle */
	uint32_t		n_auth;		/* security flavor used for this node */
	struct nfsbuflists	n_cleanblkhd;	/* clean blocklist head */
	struct nfsbuflists	n_dirtyblkhd;	/* dirty blocklist head */
	union {
		int		nf_wrbusy;	/* # threads in write/fsync */
		uint32_t	nd_ncgen;	/* dir name cache generation# */
	} n_un5;
	union {
		int		nf_needcommitcnt;/* # bufs that need committing */
		daddr64_t	nd_lastdbl;	/* last dir buf lookup block# */
	} n_un6;
	int			n_bufiterflags;	/* buf iterator flags */
	union {
		int		nf_numoutput;	/* write I/Os in progress */
		int		nd_trigseq;	/* vnode trigger seq# */
	} n_un7;
	/* open state */
	lck_mtx_t		n_openlock;	/* nfs node open lock */
	uint32_t		n_openflags;	/* open state flags */
	uint32_t		n_openrefcnt;	/* # non-file opens */
	TAILQ_HEAD(,nfs_open_file) n_opens;	/* list of open files */
	/* lock state */
	TAILQ_HEAD(, nfs_lock_owner) n_lock_owners; /* list of lock owners */
	struct nfs_file_lock_queue n_locks;	/* list of locks */
	/* delegation state */
	nfs_stateid		n_dstateid;	/* delegation stateid */
	TAILQ_ENTRY(nfsnode)	n_dlink;	/* delegation list link */
	TAILQ_ENTRY(nfsnode)	n_dreturn;	/* delegation return list link */
	struct kauth_ace	n_dace;		/* delegation ACE */
};

#define NFS_DATA_LOCK_SHARED	1
#define NFS_DATA_LOCK_EXCLUSIVE	2

#define nfstimespeccmp(tvp, uvp, cmp)		\
	(((tvp)->tv_sec == (uvp)->tv_sec) ?	\
	 ((tvp)->tv_nsec cmp (uvp)->tv_nsec) :	\
	 ((tvp)->tv_sec cmp (uvp)->tv_sec))

#define CHECK_NEEDCOMMITCNT(np) \
	do { \
		if ((np)->n_needcommitcnt < 0) { \
			printf("nfs: n_needcommitcnt negative\n"); \
			(np)->n_needcommitcnt = 0; \
		} \
	} while (0)

#define n_atim			n_un1.ns_atim
#define n_mtim			n_un2.ns_mtim
#define n_rltim			n_un1.nl_rltim
#define n_lastread		n_un1.nf_lastread
#define n_lastrahead		n_un2.nf_lastrahead
#define n_sillyrename		n_un3.nf_silly
#define n_wrbusy		n_un5.nf_wrbusy
#define n_needcommitcnt		n_un6.nf_needcommitcnt
#define n_numoutput		n_un7.nf_numoutput
#define n_cookieverf		n_un1.nd_cookieverf
#define n_eofcookie		n_un2.nd_eofcookie
#define n_cookiecache		n_un3.nd_cookiecache
#define n_ncgen			n_un5.nd_ncgen
#define n_lastdbl		n_un6.nd_lastdbl
#define n_trigseq		n_un7.nd_trigseq
#define n_mtime			n_un4.v3.n3_mtime
#define n_ncmtime		n_un4.v3.n3_ncmtime
#define n_change		n_un4.v4.n4_change
#define n_ncchange		n_un4.v4.n4_ncchange
#define n_attrdirfh		n_un4.v4.n4_attrdirfh
#define n_lastio		n_un4.v4.n4_lastio

/*
 * Flags for n_flag
 */
#define	NUPDATESIZE	0x00001	/* size of file needs updating */
#define	NREVOKE		0x00002	/* node revoked */
#define	NMODIFIED	0x00004	/* Might have a modified buffer in bio */
#define	NWRITEERR	0x00008	/* Flag write errors so close will know */
#define	NNEEDINVALIDATE	0x00010	/* need to call vinvalbuf() */
#define	NGETATTRINPROG	0x00020	/* GETATTR RPC in progress */
#define	NGETATTRWANT	0x00040	/* waiting for GETATTR RPC */
#define	NACC		0x00100	/* Special file accessed */
#define	NUPD		0x00200	/* Special file updated */
#define	NCHG		0x00400	/* Special file times changed */
#define	NNEGNCENTRIES	0x00800	/* directory has negative name cache entries */
#define	NBUSY		0x01000	/* node is busy */
#define	NBUSYWANT	0x02000	/* waiting on busy node */
#define NISDOTZFS	0x04000	/* a ".zfs" directory */
#define NISDOTZFSCHILD	0x08000	/* a child of a ".zfs" directory */
#define NISMAPPED	0x10000	/* node is mmapped   */
#define NREFRESH	0x20000 /* node's fh needs to be refreshed */
#define NREFRESHWANT	0x40000 /* Waiting for fh to be refreshed */

/*
 * Flags for n_hflag
 * Note: protected by nfs_node_hash_mutex
 */
#define NHHASHED	0x0001  /* node is in hash table */
#define NHINIT		0x0002  /* node is being initialized */
#define NHLOCKED	0x0004  /* node is locked (initting or deleting) */
#define NHLOCKWANT	0x0008  /* someone wants to lock */

/*
 * Flags for n_bflag
 * Note: protected by nfs_buf_mutex
 */
#define	NBFLUSHINPROG	0x0001	/* Avoid multiple calls to nfs_flush() */
#define	NBFLUSHWANT	0x0002	/* waiting for nfs_flush() to complete */
#define	NBINVALINPROG	0x0004	/* Avoid multiple calls to nfs_vinvalbuf() */
#define	NBINVALWANT	0x0008	/* waiting for nfs_vinvalbuf() to complete */

/*
 * Flags for n_mflag
 * Note: protected by nfsmount's nm_lock
 */
#define	NMMONSCANINPROG	0x0001	/* monitored node is currently updating attributes */
#define	NMMONSCANWANT	0x0002	/* waiting for attribute update to complete */

/*
 * n_openflags
 * Note: protected by n_openlock
 */
#define N_OPENBUSY		0x0001	/* open state is busy - being updated */
#define N_OPENWANT		0x0002	/* someone wants to mark busy */
#define N_DELEG_READ		0x0004	/* we have a read delegation */
#define N_DELEG_WRITE		0x0008	/* we have a write delegation */
#define N_DELEG_MASK		0x000c	/* delegation mask */
#define N_DELEG_RETURN		0x0010	/* delegation queued for return */
#define N_DELEG_RETURNING	0x0020	/* delegation being returned */

/* attr/access/ACL cache timestamp macros */
#define NATTRVALID(np)		((np)->n_attrstamp != ~0)
#define NATTRINVALIDATE(np)	((np)->n_attrstamp = ~0)
#define NACCESSVALID(np, slot)	(((slot) >= 0) && ((slot) < NFS_ACCESS_CACHE_SIZE) && ((np)->n_accessstamp[(slot)] != ~0))
#define NACCESSINVALIDATE(np) \
	do { \
		int __i; \
		for (__i=0; __i < NFS_ACCESS_CACHE_SIZE; __i++) \
			(np)->n_accessstamp[__i] = ~0; \
		(np)->n_access[NFS_ACCESS_CACHE_SIZE] = 0; \
	} while (0)
#define NACLVALID(np)		((np)->n_aclstamp != ~0)
#define NACLINVALIDATE(np)	((np)->n_aclstamp = ~0)

/*
 * NFS-specific flags for nfs_vinvalbuf/nfs_flush
 */
#define V_IGNORE_WRITEERR	0x8000

/*
 * Flags for nfs_nget()
 */
#define	NG_MARKROOT	0x0001	/* mark vnode as root of FS */
#define	NG_MAKEENTRY	0x0002	/* add name cache entry for vnode */
#define	NG_NOCREATE	0x0004	/* don't create a new node, return existing one */

/*
 * Convert between nfsnode pointers and vnode pointers
 */
#define VTONFS(vp)	((nfsnode_t)vnode_fsnode(vp))
#define NFSTOV(np)	((np)->n_vnode)

/* nfsnode hash table mutex */
extern lck_mtx_t *nfs_node_hash_mutex;

/*
 * printf-like helper macro that also outputs node name.
 */
#define NP(NP, FMT, ...) \
	do { \
		const char *__vname = (NP) ? vnode_getname(NFSTOV(NP)) : NULL; \
		printf(FMT " %s\n", ##__VA_ARGS__, __vname ? __vname : "???"); \
		if (__vname) vnode_putname(__vname); \
	} while (0)

/*
 * nfsiod structures
 */
struct nfsiod {
	TAILQ_ENTRY(nfsiod)	niod_link;	/* List of nfsiods */
	struct nfsmount *	niod_nmp;	/* mount point for this nfsiod */
};
TAILQ_HEAD(nfsiodlist, nfsiod);
TAILQ_HEAD(nfsiodmountlist, nfsmount);
extern struct nfsiodlist nfsiodfree, nfsiodwork;
extern struct nfsiodmountlist nfsiodmounts;
extern lck_mtx_t *nfsiod_mutex;


#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_NFSNODE_H_ */
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfsproto.h                                      0100644 0001750 0001750 00000070706 12567450754 022422  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsproto.h	8.2 (Berkeley) 3/30/95
 * FreeBSD-Id: nfsproto.h,v 1.3 1997/02/22 09:42:50 peter Exp $
 */

#ifndef _NFS_NFSPROTO_H_
#define _NFS_NFSPROTO_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

/*
 * NFS definitions per the various NFS protocol specs:
 * Version 2 (RFC 1094), Version 3 (RFC 1813), and Version 4 (RFC 3530)
 * and various protocol-related implementation definitions.
 */

/* Only define these if nfs_prot.h hasn't been included */
#ifndef NFS_PROGRAM

#define NFS_PORT	2049
#define	NFS_PROG	100003
#define NFS_VER2	2
#define	NFS_VER3	3
#define	NFS_VER4	4
#define NFS_V2MAXDATA	8192
#define	NFS_MAXDGRAMDATA 16384
#define	NFS_PREFDGRAMDATA 8192
#define	NFS_MAXDATA	(64*1024) // XXX not ready for >64K
#define	NFSRV_MAXDATA	(64*1024) // XXX not ready for >64K
#define	NFS_MAXPATHLEN	1024
#define	NFS_MAXNAMLEN	255
#define	NFS_MAXPACKET	(16*1024*1024)
#define	NFS_UDPSOCKBUF	(224*1024)
#define	NFS_FABLKSIZE	512	/* Size in bytes of a block wrt fa_blocks */

#define NFS4_CALLBACK_PROG		0x4E465343 /* "NFSC" */
#define NFS4_CALLBACK_PROG_VERSION	1

/* Stat numbers for NFS RPC returns */
#define NFS_OK				0
#define NFSERR_PERM			1
#define NFSERR_NOENT			2
#define NFSERR_IO			5
#define NFSERR_NXIO			6
#define NFSERR_ACCES			13
#define NFSERR_EXIST			17
#define NFSERR_XDEV			18	/* Version 3 only */
#define NFSERR_NODEV			19
#define NFSERR_NOTDIR			20
#define NFSERR_ISDIR			21
#define NFSERR_INVAL			22	/* Version 3 only */
#define NFSERR_FBIG			27
#define NFSERR_NOSPC			28
#define NFSERR_ROFS			30
#define NFSERR_MLINK			31	/* Version 3 only */
#define NFSERR_NAMETOL			63
#define NFSERR_NOTEMPTY			66
#define NFSERR_DQUOT			69
#define NFSERR_STALE			70
#define NFSERR_REMOTE			71	/* Version 3 only */
#define NFSERR_WFLUSH			99	/* Version 2 only */
#define NFSERR_BADHANDLE		10001	/* The rest Version 3 only */
#define NFSERR_NOT_SYNC			10002
#define NFSERR_BAD_COOKIE		10003
#define NFSERR_NOTSUPP			10004
#define NFSERR_TOOSMALL			10005
#define NFSERR_SERVERFAULT		10006
#define NFSERR_BADTYPE			10007
#define NFSERR_JUKEBOX			10008
#define NFSERR_TRYLATER			NFSERR_JUKEBOX
#define NFSERR_DELAY			NFSERR_JUKEBOX
#define NFSERR_SAME			10009	/* The rest Version 4 only */
#define NFSERR_DENIED			10010
#define NFSERR_EXPIRED			10011
#define NFSERR_LOCKED			10012
#define NFSERR_GRACE			10013
#define NFSERR_FHEXPIRED		10014
#define NFSERR_SHARE_DENIED		10015
#define NFSERR_WRONGSEC			10016
#define NFSERR_CLID_INUSE		10017
#define NFSERR_RESOURCE			10018
#define NFSERR_MOVED			10019
#define NFSERR_NOFILEHANDLE		10020
#define NFSERR_MINOR_VERS_MISMATCH	10021
#define NFSERR_STALE_CLIENTID		10022
#define NFSERR_STALE_STATEID		10023
#define NFSERR_OLD_STATEID		10024
#define NFSERR_BAD_STATEID		10025
#define NFSERR_BAD_SEQID		10026
#define NFSERR_NOT_SAME			10027
#define NFSERR_LOCK_RANGE		10028
#define NFSERR_SYMLINK			10029
#define NFSERR_RESTOREFH		10030
#define NFSERR_LEASE_MOVED		10031
#define NFSERR_ATTRNOTSUPP		10032
#define NFSERR_NO_GRACE			10033
#define NFSERR_RECLAIM_BAD		10034
#define NFSERR_RECLAIM_CONFLICT		10035
#define NFSERR_BADXDR			10036
#define NFSERR_LOCKS_HELD		10037
#define NFSERR_OPENMODE			10038
#define NFSERR_BADOWNER			10039
#define NFSERR_BADCHAR			10040
#define NFSERR_BADNAME			10041
#define NFSERR_BAD_RANGE		10042
#define NFSERR_LOCK_NOTSUPP		10043
#define NFSERR_OP_ILLEGAL		10044
#define NFSERR_DEADLOCK			10045
#define NFSERR_FILE_OPEN		10046
#define NFSERR_ADMIN_REVOKED		10047
#define NFSERR_CB_PATH_DOWN		10048

#define NFSERR_STALEWRITEVERF		30001	/* Fake return for nfs_commit() */
#define NFSERR_DIRBUFDROPPED		30002	/* Fake return for nfs*_readdir_rpc() */

/*
 * For gss we would like to return EAUTH when we don't have or can't get credentials,
 * but some callers don't know what to do with it, so we define our own version
 * of EAUTH to be EACCES
 */
#define NFSERR_EAUTH	EACCES

#define NFSERR_RETVOID		0x20000000 /* Return void, not error */
#define NFSERR_AUTHERR		0x40000000 /* Mark an authentication error */
#define NFSERR_RETERR		0x80000000 /* Mark an error return for V3 */

#endif /* !NFS_PROGRAM */

/* Sizes in bytes of various nfs rpc components */
#define	NFSX_UNSIGNED	4

/* specific to NFS Version 2 */
#define	NFSX_V2FH	32
#define	NFSX_V2FATTR	68
#define	NFSX_V2SATTR	32
#define	NFSX_V2COOKIE	4
#define NFSX_V2STATFS	20

/* specific to NFS Version 3 */
#define	NFSX_V3FHMAX		64	/* max. allowed by protocol */
#define NFSX_V3FATTR		84
#define NFSX_V3SATTR		60	/* max. all fields filled in */
#define NFSX_V3POSTOPATTR	(NFSX_V3FATTR + NFSX_UNSIGNED)
#define NFSX_V3WCCDATA		(NFSX_V3POSTOPATTR + 8 * NFSX_UNSIGNED)
#define NFSX_V3COOKIEVERF 	8
#define NFSX_V3WRITEVERF 	8
#define NFSX_V3CREATEVERF	8
#define NFSX_V3STATFS		52
#define NFSX_V3FSINFO		48
#define NFSX_V3PATHCONF		24

/* specific to NFS Version 4 */
#define NFS4_FHSIZE		128
#define NFS4_VERIFIER_SIZE	8
#define NFS4_OPAQUE_LIMIT	1024

/* variants for multiple versions */
#define NFSX_FH(V)		(((V) == NFS_VER2) ? NFSX_V2FH : (NFSX_UNSIGNED + \
				 (((V) == NFS_VER3) ? NFSX_V3FHMAX : NFS4_FHSIZE)))
#define NFSX_SRVFH(V,FH)	(((V) == NFS_VER2) ? NFSX_V2FH : (FH)->nfh_len)
#define	NFSX_FATTR(V)		(((V) == NFS_VER3) ? NFSX_V3FATTR : NFSX_V2FATTR)
#define NFSX_PREOPATTR(V)	(((V) == NFS_VER3) ? (7 * NFSX_UNSIGNED) : 0)
#define NFSX_POSTOPATTR(V)	(((V) == NFS_VER3) ? (NFSX_V3FATTR + NFSX_UNSIGNED) : 0)
#define NFSX_POSTOPORFATTR(V)	(((V) == NFS_VER3) ? (NFSX_V3FATTR + NFSX_UNSIGNED) : NFSX_V2FATTR)
#define NFSX_WCCDATA(V)		(((V) == NFS_VER3) ? NFSX_V3WCCDATA : 0)
#define NFSX_WCCORFATTR(V)	(((V) == NFS_VER3) ? NFSX_V3WCCDATA : NFSX_V2FATTR)
#define	NFSX_SATTR(V)		(((V) == NFS_VER3) ? NFSX_V3SATTR : NFSX_V2SATTR)
#define	NFSX_COOKIEVERF(V)	(((V) == NFS_VER3) ? NFSX_V3COOKIEVERF : 0)
#define	NFSX_WRITEVERF(V)	(((V) == NFS_VER3) ? NFSX_V3WRITEVERF : 0)
#define NFSX_READDIR(V)		(((V) == NFS_VER3) ? (5 * NFSX_UNSIGNED) : \
					(2 * NFSX_UNSIGNED))
#define	NFSX_STATFS(V)		(((V) == NFS_VER3) ? NFSX_V3STATFS : NFSX_V2STATFS)

/* Only define these if nfs_prot.h hasn't been included */
#ifndef NFS_PROGRAM

/* nfs rpc procedure numbers (before version mapping) */
#define	NFSPROC_NULL		0
#define	NFSPROC_GETATTR		1
#define	NFSPROC_SETATTR		2
#define	NFSPROC_LOOKUP		3
#define	NFSPROC_ACCESS		4
#define	NFSPROC_READLINK	5
#define	NFSPROC_READ		6
#define	NFSPROC_WRITE		7
#define	NFSPROC_CREATE		8
#define	NFSPROC_MKDIR		9
#define	NFSPROC_SYMLINK		10
#define	NFSPROC_MKNOD		11
#define	NFSPROC_REMOVE		12
#define	NFSPROC_RMDIR		13
#define	NFSPROC_RENAME		14
#define	NFSPROC_LINK		15
#define	NFSPROC_READDIR		16
#define	NFSPROC_READDIRPLUS	17
#define	NFSPROC_FSSTAT		18
#define	NFSPROC_FSINFO		19
#define	NFSPROC_PATHCONF	20
#define	NFSPROC_COMMIT		21

#endif /* !NFS_PROGRAM */

#define NFSPROC_NOOP		22
#define	NFS_NPROCS		23

/* Actual Version 2 procedure numbers */
#define	NFSV2PROC_NULL		0
#define	NFSV2PROC_GETATTR	1
#define	NFSV2PROC_SETATTR	2
#define	NFSV2PROC_NOOP		3
#define	NFSV2PROC_ROOT		NFSV2PROC_NOOP	/* Obsolete */
#define	NFSV2PROC_LOOKUP	4
#define	NFSV2PROC_READLINK	5
#define	NFSV2PROC_READ		6
#define	NFSV2PROC_WRITECACHE	NFSV2PROC_NOOP	/* Obsolete */
#define	NFSV2PROC_WRITE		8
#define	NFSV2PROC_CREATE	9
#define	NFSV2PROC_REMOVE	10
#define	NFSV2PROC_RENAME	11
#define	NFSV2PROC_LINK		12
#define	NFSV2PROC_SYMLINK	13
#define	NFSV2PROC_MKDIR		14
#define	NFSV2PROC_RMDIR		15
#define	NFSV2PROC_READDIR	16
#define	NFSV2PROC_STATFS	17

/*
 * Constants used by the Version 3 protocol for various RPCs
 */

#define NFSV3FSINFO_LINK		0x01
#define NFSV3FSINFO_SYMLINK		0x02
#define NFSV3FSINFO_HOMOGENEOUS		0x08
#define NFSV3FSINFO_CANSETTIME		0x10

/* time setting constants */
#define NFS_TIME_DONT_CHANGE		0
#define NFS_TIME_SET_TO_SERVER		1
#define NFS_TIME_SET_TO_CLIENT		2
#define NFS4_TIME_SET_TO_SERVER		0
#define NFS4_TIME_SET_TO_CLIENT		1

/* access() constants */
#define NFS_ACCESS_READ			0x01
#define NFS_ACCESS_LOOKUP		0x02
#define NFS_ACCESS_MODIFY		0x04
#define NFS_ACCESS_EXTEND		0x08
#define NFS_ACCESS_DELETE		0x10
#define NFS_ACCESS_EXECUTE		0x20
#define	NFS_ACCESS_ALL (NFS_ACCESS_READ | NFS_ACCESS_MODIFY		\
			 | NFS_ACCESS_EXTEND | NFS_ACCESS_EXECUTE	\
			 | NFS_ACCESS_DELETE | NFS_ACCESS_LOOKUP)

/* NFS WRITE how constants */
#define NFS_WRITE_UNSTABLE		0
#define NFS_WRITE_DATASYNC		1
#define NFS_WRITE_FILESYNC		2

/* NFS CREATE types */
#define NFS_CREATE_UNCHECKED		0
#define NFS_CREATE_GUARDED		1
#define NFS_CREATE_EXCLUSIVE		2

/* Only define these if nfs_prot.h hasn't been included */
#ifndef NFS_PROGRAM
/* NFS object types */
typedef enum { NFNON=0, NFREG=1, NFDIR=2, NFBLK=3, NFCHR=4, NFLNK=5,
	NFSOCK=6, NFFIFO=7, NFATTRDIR=8, NFNAMEDATTR=9 } nfstype;
#endif /* !NFS_PROGRAM */

/*
 * File Handle (32 bytes for version 2), variable up to 64 for version 3
 * and variable up to 128 bytes for version 4.
 * File Handles of up to NFS_SMALLFH in size are stored directly in the
 * nfs node, whereas larger ones are malloc'd. (This never happens when
 * NFS_SMALLFH is set to the largest size.)
 * NFS_SMALLFH should be in the range of 32 to 64 and be divisible by 4.
 */
#ifndef NFS_SMALLFH
#define NFS_SMALLFH	64
#endif

/*
 * NFS attribute management stuff
 */
#define NFS_ATTR_BITMAP_LEN	2
#define NFS_BITMAP_SET(B, I)	(((uint32_t *)(B))[(I)/32] |= 1<<((I)%32))
#define NFS_BITMAP_CLR(B, I)	(((uint32_t *)(B))[(I)/32] &= ~(1<<((I)%32)))
#define NFS_BITMAP_ISSET(B, I)	(((uint32_t *)(B))[(I)/32] & (1<<((I)%32)))
#define NFS_BITMAP_ZERO(B, L) \
	do { \
		int __i; \
		for (__i=0; __i < (L); __i++) \
			((uint32_t*)(B))[__i] = 0; \
	} while (0)

extern uint32_t nfs_fs_attr_bitmap[NFS_ATTR_BITMAP_LEN];
extern uint32_t nfs_object_attr_bitmap[NFS_ATTR_BITMAP_LEN];
extern uint32_t nfs_getattr_bitmap[NFS_ATTR_BITMAP_LEN];

#define NFS_CLEAR_ATTRIBUTES(A)	NFS_BITMAP_ZERO((A), NFS_ATTR_BITMAP_LEN)
#define NFS_COPY_ATTRIBUTES(SRC, DST) \
	do { \
	int __i; \
	for (__i=0; __i < NFS_ATTR_BITMAP_LEN; __i++) \
		((uint32_t*)(DST))[__i] = ((uint32_t*)(SRC))[__i]; \
	} while (0)

/* NFS attributes */
#define NFS_FATTR_SUPPORTED_ATTRS		0
#define NFS_FATTR_TYPE				1
#define NFS_FATTR_FH_EXPIRE_TYPE		2
#define NFS_FATTR_CHANGE			3
#define NFS_FATTR_SIZE				4
#define NFS_FATTR_LINK_SUPPORT			5
#define NFS_FATTR_SYMLINK_SUPPORT		6
#define NFS_FATTR_NAMED_ATTR			7
#define NFS_FATTR_FSID				8
#define NFS_FATTR_UNIQUE_HANDLES		9
#define NFS_FATTR_LEASE_TIME			10
#define NFS_FATTR_RDATTR_ERROR			11
#define NFS_FATTR_FILEHANDLE			19
#define NFS_FATTR_ACL				12
#define NFS_FATTR_ACLSUPPORT			13
#define NFS_FATTR_ARCHIVE			14
#define NFS_FATTR_CANSETTIME			15
#define NFS_FATTR_CASE_INSENSITIVE		16
#define NFS_FATTR_CASE_PRESERVING		17
#define NFS_FATTR_CHOWN_RESTRICTED		18
#define NFS_FATTR_FILEID			20
#define NFS_FATTR_FILES_AVAIL			21
#define NFS_FATTR_FILES_FREE			22
#define NFS_FATTR_FILES_TOTAL			23
#define NFS_FATTR_FS_LOCATIONS			24
#define NFS_FATTR_HIDDEN			25
#define NFS_FATTR_HOMOGENEOUS			26
#define NFS_FATTR_MAXFILESIZE			27
#define NFS_FATTR_MAXLINK			28
#define NFS_FATTR_MAXNAME			29
#define NFS_FATTR_MAXREAD			30
#define NFS_FATTR_MAXWRITE			31
#define NFS_FATTR_MIMETYPE			32
#define NFS_FATTR_MODE				33
#define NFS_FATTR_NO_TRUNC			34
#define NFS_FATTR_NUMLINKS			35
#define NFS_FATTR_OWNER				36
#define NFS_FATTR_OWNER_GROUP			37
#define NFS_FATTR_QUOTA_AVAIL_HARD		38
#define NFS_FATTR_QUOTA_AVAIL_SOFT		39
#define NFS_FATTR_QUOTA_USED			40
#define NFS_FATTR_RAWDEV			41
#define NFS_FATTR_SPACE_AVAIL			42
#define NFS_FATTR_SPACE_FREE			43
#define NFS_FATTR_SPACE_TOTAL			44
#define NFS_FATTR_SPACE_USED			45
#define NFS_FATTR_SYSTEM			46
#define NFS_FATTR_TIME_ACCESS			47
#define NFS_FATTR_TIME_ACCESS_SET		48
#define NFS_FATTR_TIME_BACKUP			49
#define NFS_FATTR_TIME_CREATE			50
#define NFS_FATTR_TIME_DELTA			51
#define NFS_FATTR_TIME_METADATA			52
#define NFS_FATTR_TIME_MODIFY			53
#define NFS_FATTR_TIME_MODIFY_SET		54
#define NFS_FATTR_MOUNTED_ON_FILEID		55

#define NFS4_ALL_ATTRIBUTES(A) \
	do { \
	/* required: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_SUPPORTED_ATTRS); \
	NFS_BITMAP_SET((A), NFS_FATTR_TYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FH_EXPIRE_TYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CHANGE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SIZE); \
	NFS_BITMAP_SET((A), NFS_FATTR_LINK_SUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_SYMLINK_SUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_NAMED_ATTR); \
	NFS_BITMAP_SET((A), NFS_FATTR_FSID); \
	NFS_BITMAP_SET((A), NFS_FATTR_UNIQUE_HANDLES); \
	NFS_BITMAP_SET((A), NFS_FATTR_LEASE_TIME); \
	NFS_BITMAP_SET((A), NFS_FATTR_RDATTR_ERROR); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILEHANDLE); \
	/* optional: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_ACL); \
	NFS_BITMAP_SET((A), NFS_FATTR_ACLSUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_ARCHIVE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CANSETTIME); \
	NFS_BITMAP_SET((A), NFS_FATTR_CASE_INSENSITIVE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CASE_PRESERVING); \
	NFS_BITMAP_SET((A), NFS_FATTR_CHOWN_RESTRICTED); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILEID); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_TOTAL); \
	NFS_BITMAP_SET((A), NFS_FATTR_FS_LOCATIONS); \
	NFS_BITMAP_SET((A), NFS_FATTR_HIDDEN); \
	NFS_BITMAP_SET((A), NFS_FATTR_HOMOGENEOUS); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXFILESIZE); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXLINK); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXNAME); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXREAD); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXWRITE); \
	NFS_BITMAP_SET((A), NFS_FATTR_MIMETYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_MODE); \
	NFS_BITMAP_SET((A), NFS_FATTR_NO_TRUNC); \
	NFS_BITMAP_SET((A), NFS_FATTR_NUMLINKS); \
	NFS_BITMAP_SET((A), NFS_FATTR_OWNER); \
	NFS_BITMAP_SET((A), NFS_FATTR_OWNER_GROUP); \
	NFS_BITMAP_SET((A), NFS_FATTR_QUOTA_AVAIL_HARD); \
	NFS_BITMAP_SET((A), NFS_FATTR_QUOTA_AVAIL_SOFT); \
	NFS_BITMAP_SET((A), NFS_FATTR_QUOTA_USED); \
	NFS_BITMAP_SET((A), NFS_FATTR_RAWDEV); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_TOTAL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_USED); \
	NFS_BITMAP_SET((A), NFS_FATTR_SYSTEM); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_ACCESS); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_ACCESS_SET); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_BACKUP); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_CREATE); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_DELTA); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_METADATA); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_MODIFY); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_MODIFY_SET); \
	NFS_BITMAP_SET((A), NFS_FATTR_MOUNTED_ON_FILEID); \
	} while (0)

#define NFS4_PER_OBJECT_ATTRIBUTES(A) \
	do { \
	/* required: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_TYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CHANGE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SIZE); \
	NFS_BITMAP_SET((A), NFS_FATTR_NAMED_ATTR); \
	NFS_BITMAP_SET((A), NFS_FATTR_FSID); \
	NFS_BITMAP_SET((A), NFS_FATTR_RDATTR_ERROR); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILEHANDLE); \
	/* optional: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_ACL); \
	NFS_BITMAP_SET((A), NFS_FATTR_ARCHIVE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILEID); \
	NFS_BITMAP_SET((A), NFS_FATTR_HIDDEN); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXLINK); \
	NFS_BITMAP_SET((A), NFS_FATTR_MIMETYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_MODE); \
	NFS_BITMAP_SET((A), NFS_FATTR_NUMLINKS); \
	NFS_BITMAP_SET((A), NFS_FATTR_OWNER); \
	NFS_BITMAP_SET((A), NFS_FATTR_OWNER_GROUP); \
	NFS_BITMAP_SET((A), NFS_FATTR_RAWDEV); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_USED); \
	NFS_BITMAP_SET((A), NFS_FATTR_SYSTEM); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_ACCESS); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_BACKUP); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_CREATE); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_METADATA); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_MODIFY); \
	NFS_BITMAP_SET((A), NFS_FATTR_MOUNTED_ON_FILEID); \
	} while (0)

#define NFS4_PER_FS_ATTRIBUTES(A) \
	do { \
	/* required: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_SUPPORTED_ATTRS); \
	NFS_BITMAP_SET((A), NFS_FATTR_FH_EXPIRE_TYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_LINK_SUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_SYMLINK_SUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_UNIQUE_HANDLES); \
	NFS_BITMAP_SET((A), NFS_FATTR_LEASE_TIME); \
	/* optional: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_ACLSUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_CANSETTIME); \
	NFS_BITMAP_SET((A), NFS_FATTR_CASE_INSENSITIVE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CASE_PRESERVING); \
	NFS_BITMAP_SET((A), NFS_FATTR_CHOWN_RESTRICTED); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_TOTAL); \
	NFS_BITMAP_SET((A), NFS_FATTR_FS_LOCATIONS); \
	NFS_BITMAP_SET((A), NFS_FATTR_HOMOGENEOUS); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXFILESIZE); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXNAME); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXREAD); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXWRITE); \
	NFS_BITMAP_SET((A), NFS_FATTR_NO_TRUNC); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_TOTAL); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_DELTA); \
	} while (0)

#define NFS4_DEFAULT_ATTRIBUTES(A) \
	do { \
	/* required: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_SUPPORTED_ATTRS); \
	NFS_BITMAP_SET((A), NFS_FATTR_TYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FH_EXPIRE_TYPE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CHANGE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SIZE); \
	NFS_BITMAP_SET((A), NFS_FATTR_LINK_SUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_SYMLINK_SUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_NAMED_ATTR); \
	NFS_BITMAP_SET((A), NFS_FATTR_FSID); \
	NFS_BITMAP_SET((A), NFS_FATTR_UNIQUE_HANDLES); \
	NFS_BITMAP_SET((A), NFS_FATTR_LEASE_TIME); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_RDATTR_ERROR); */ \
	/* NFS_BITMAP_SET((A), NFS_FATTR_FILEHANDLE); */ \
	/* optional: */ \
	/* NFS_BITMAP_SET((A), NFS_FATTR_ACL); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_ACLSUPPORT); \
	NFS_BITMAP_SET((A), NFS_FATTR_ARCHIVE); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_CANSETTIME); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_CASE_INSENSITIVE); \
	NFS_BITMAP_SET((A), NFS_FATTR_CASE_PRESERVING); \
	NFS_BITMAP_SET((A), NFS_FATTR_CHOWN_RESTRICTED); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILEID); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_TOTAL); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_FS_LOCATIONS); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_HIDDEN); \
	NFS_BITMAP_SET((A), NFS_FATTR_HOMOGENEOUS); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXFILESIZE); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXLINK); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXNAME); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXREAD); \
	NFS_BITMAP_SET((A), NFS_FATTR_MAXWRITE); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_MIMETYPE); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_MODE); \
	NFS_BITMAP_SET((A), NFS_FATTR_NO_TRUNC); \
	NFS_BITMAP_SET((A), NFS_FATTR_NUMLINKS); \
	NFS_BITMAP_SET((A), NFS_FATTR_OWNER); \
	NFS_BITMAP_SET((A), NFS_FATTR_OWNER_GROUP); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_QUOTA_AVAIL_HARD); */ \
	/* NFS_BITMAP_SET((A), NFS_FATTR_QUOTA_AVAIL_SOFT); */ \
	/* NFS_BITMAP_SET((A), NFS_FATTR_QUOTA_USED); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_RAWDEV); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_TOTAL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_USED); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_SYSTEM); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_ACCESS); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_TIME_ACCESS_SET); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_BACKUP); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_CREATE); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_TIME_DELTA); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_METADATA); \
	NFS_BITMAP_SET((A), NFS_FATTR_TIME_MODIFY); \
	/* NFS_BITMAP_SET((A), NFS_FATTR_TIME_MODIFY_SET); */ \
	NFS_BITMAP_SET((A), NFS_FATTR_MOUNTED_ON_FILEID); \
	} while (0)

/* attributes requested when we want to do a "statfs" */
#define NFS4_STATFS_ATTRIBUTES(A) \
	do { \
	/* optional: */ \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_FILES_TOTAL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_AVAIL); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_FREE); \
	NFS_BITMAP_SET((A), NFS_FATTR_SPACE_TOTAL); \
	} while (0)

/*
 * NFS OPEN constants
 */
/* open type */
#define NFS_OPEN_NOCREATE			0
#define NFS_OPEN_CREATE				1
/* delegation space limit */
#define NFS_LIMIT_SIZE				1
#define NFS_LIMIT_BLOCKS			2
/* access/deny modes */
#define NFS_OPEN_SHARE_ACCESS_NONE		0x00000000
#define NFS_OPEN_SHARE_ACCESS_READ		0x00000001
#define NFS_OPEN_SHARE_ACCESS_WRITE		0x00000002
#define NFS_OPEN_SHARE_ACCESS_BOTH		0x00000003
#define NFS_OPEN_SHARE_DENY_NONE		0x00000000
#define NFS_OPEN_SHARE_DENY_READ		0x00000001
#define NFS_OPEN_SHARE_DENY_WRITE		0x00000002
#define NFS_OPEN_SHARE_DENY_BOTH		0x00000003
/* delegation types */
#define NFS_OPEN_DELEGATE_NONE			0
#define NFS_OPEN_DELEGATE_READ			1
#define NFS_OPEN_DELEGATE_WRITE			2
/* delegation claim types */
#define NFS_CLAIM_NULL				0
#define NFS_CLAIM_PREVIOUS			1
#define NFS_CLAIM_DELEGATE_CUR			2
#define NFS_CLAIM_DELEGATE_PREV			3
/* open result flags */
#define NFS_OPEN_RESULT_CONFIRM			0x00000002
#define NFS_OPEN_RESULT_LOCKTYPE_POSIX		0x00000004
/* NFS lock types */
#define NFS_LOCK_TYPE_READ			1
#define NFS_LOCK_TYPE_WRITE			2
#define NFS_LOCK_TYPE_READW			3 /* "blocking" */
#define NFS_LOCK_TYPE_WRITEW			4 /* "blocking" */

/* NFSv4 RPC procedures */
#define NFSPROC4_NULL				0
#define NFSPROC4_COMPOUND			1
#define NFSPROC4_CB_NULL			0
#define NFSPROC4_CB_COMPOUND			1

/* NFSv4 opcodes */
#define NFS_OP_ACCESS				3
#define NFS_OP_CLOSE				4
#define NFS_OP_COMMIT				5
#define NFS_OP_CREATE				6
#define NFS_OP_DELEGPURGE			7
#define NFS_OP_DELEGRETURN			8
#define NFS_OP_GETATTR				9
#define NFS_OP_GETFH				10
#define NFS_OP_LINK				11
#define NFS_OP_LOCK				12
#define NFS_OP_LOCKT				13
#define NFS_OP_LOCKU				14
#define NFS_OP_LOOKUP				15
#define NFS_OP_LOOKUPP				16
#define NFS_OP_NVERIFY				17
#define NFS_OP_OPEN				18
#define NFS_OP_OPENATTR				19
#define NFS_OP_OPEN_CONFIRM			20
#define NFS_OP_OPEN_DOWNGRADE			21
#define NFS_OP_PUTFH				22
#define NFS_OP_PUTPUBFH				23
#define NFS_OP_PUTROOTFH			24
#define NFS_OP_READ				25
#define NFS_OP_READDIR				26
#define NFS_OP_READLINK				27
#define NFS_OP_REMOVE				28
#define NFS_OP_RENAME				29
#define NFS_OP_RENEW				30
#define NFS_OP_RESTOREFH			31
#define NFS_OP_SAVEFH				32
#define NFS_OP_SECINFO				33
#define NFS_OP_SETATTR				34
#define NFS_OP_SETCLIENTID			35
#define NFS_OP_SETCLIENTID_CONFIRM		36
#define NFS_OP_VERIFY				37
#define NFS_OP_WRITE				38
#define NFS_OP_RELEASE_LOCKOWNER		39
#define NFS_OP_ILLEGAL				10044
/* NFSv4 callback opcodes */
#define NFS_OP_CB_GETATTR			3
#define NFS_OP_CB_RECALL			4
#define NFS_OP_CB_ILLEGAL			10044

/* NFSv4 file handle type flags */
#define NFS_FH_PERSISTENT			0x00000000
#define NFS_FH_NOEXPIRE_WITH_OPEN		0x00000001
#define NFS_FH_VOLATILE_ANY			0x00000002
#define NFS_FH_VOL_MIGRATION			0x00000004
#define NFS_FH_VOL_RENAME			0x00000008

/*
 * NFSv4 ACL constants
 */
/* ACE support mask bits */
#define NFS_ACL_SUPPORT_ALLOW_ACL		0x00000001
#define NFS_ACL_SUPPORT_DENY_ACL		0x00000002
#define NFS_ACL_SUPPORT_AUDIT_ACL		0x00000004
#define NFS_ACL_SUPPORT_ALARM_ACL		0x00000008
/* ACE types */
#define NFS_ACE_ACCESS_ALLOWED_ACE_TYPE		0x00000000
#define NFS_ACE_ACCESS_DENIED_ACE_TYPE		0x00000001
#define NFS_ACE_SYSTEM_AUDIT_ACE_TYPE		0x00000002
#define NFS_ACE_SYSTEM_ALARM_ACE_TYPE		0x00000003
/* ACE flags */
#define NFS_ACE_FILE_INHERIT_ACE		0x00000001
#define NFS_ACE_DIRECTORY_INHERIT_ACE		0x00000002
#define NFS_ACE_NO_PROPAGATE_INHERIT_ACE	0x00000004
#define NFS_ACE_INHERIT_ONLY_ACE		0x00000008
#define NFS_ACE_SUCCESSFUL_ACCESS_ACE_FLAG	0x00000010
#define NFS_ACE_FAILED_ACCESS_ACE_FLAG		0x00000020
#define NFS_ACE_IDENTIFIER_GROUP		0x00000040
#define NFS_ACE_INHERITED_ACE			0x00000080
/* ACE mask flags */
#define NFS_ACE_READ_DATA			0x00000001
#define NFS_ACE_LIST_DIRECTORY			0x00000001
#define NFS_ACE_WRITE_DATA			0x00000002
#define NFS_ACE_ADD_FILE			0x00000002
#define NFS_ACE_APPEND_DATA			0x00000004
#define NFS_ACE_ADD_SUBDIRECTORY		0x00000004
#define NFS_ACE_READ_NAMED_ATTRS		0x00000008
#define NFS_ACE_WRITE_NAMED_ATTRS		0x00000010
#define NFS_ACE_EXECUTE				0x00000020
#define NFS_ACE_DELETE_CHILD			0x00000040
#define NFS_ACE_READ_ATTRIBUTES			0x00000080
#define NFS_ACE_WRITE_ATTRIBUTES		0x00000100
#define NFS_ACE_DELETE				0x00010000
#define NFS_ACE_READ_ACL			0x00020000
#define NFS_ACE_WRITE_ACL			0x00040000
#define NFS_ACE_WRITE_OWNER			0x00080000
#define NFS_ACE_SYNCHRONIZE			0x00100000
#define NFS_ACE_GENERIC_READ			0x00120081
#define NFS_ACE_GENERIC_WRITE			0x00160106
#define NFS_ACE_GENERIC_EXECUTE			0x001200A0


/*
 * Quads are defined as arrays of 2 32-bit values to ensure dense packing
 * for the protocol and to facilitate xdr conversion.
 */
struct nfs_uquad {
	u_int32_t	nfsuquad[2];
};
typedef	struct nfs_uquad	nfsuint64;

/*
 * Used to convert between two u_int32_ts and a u_quad_t.
 */
union nfs_quadconvert {
	u_int32_t		lval[2];
	u_quad_t	qval;
};
typedef union nfs_quadconvert	nfsquad_t;

/*
 * special data/attribute associated with NFBLK/NFCHR
 */
struct nfs_specdata {
	uint32_t specdata1;	/* major device number */
	uint32_t specdata2;	/* minor device number */
};
typedef struct nfs_specdata nfs_specdata;

/*
 * an "fsid" large enough to hold an NFSv4 fsid.
 */
struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};
typedef struct nfs_fsid nfs_fsid;

/*
 * NFSv4 stateid structure
 */
struct nfs_stateid {
	uint32_t	seqid;
	uint32_t	other[3];
};
typedef struct nfs_stateid nfs_stateid;

#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_NFSPROTO_H_ */
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/nfsrvcache.h                                    0100644 0001750 0001750 00000011537 12567450754 022667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsrvcache.h	8.3 (Berkeley) 3/30/95
 * FreeBSD-Id: nfsrvcache.h,v 1.9 1997/06/03 17:22:47 dfr Exp $
 */


#ifndef _NFS_NFSRVCACHE_H_
#define _NFS_NFSRVCACHE_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE
/*
 * Definitions for the server recent request cache
 */

/* Network address hash list element */
union nethostaddr {
	in_addr_t had_inetaddr;
	struct in6_addr had_inet6addr;
	mbuf_t had_nam;
};

#define	NFSRVCACHESIZ	64

struct nfsrvcache {
	TAILQ_ENTRY(nfsrvcache) rc_lru;		/* LRU chain */
	LIST_ENTRY(nfsrvcache) rc_hash;		/* Hash chain */
	u_int32_t	rc_xid;				/* rpc id number */
	union {
		mbuf_t ru_repmb;		/* Reply mbuf list OR */
		int ru_repstat;			/* Reply status */
	} rc_un;
	sa_family_t rc_family;			/* address family */
	union nethostaddr rc_haddr;		/* Host address */
	u_int32_t rc_proc;			/* rpc proc number */
	u_char	rc_state;		/* Current state of request */
	u_char	rc_flag;		/* Flag bits */
};

#define	rc_reply	rc_un.ru_repmb
#define	rc_status	rc_un.ru_repstat
#define	rc_inetaddr	rc_haddr.had_inetaddr
#define	rc_inet6addr	rc_haddr.had_inet6addr
#define	rc_nam		rc_haddr.had_nam

/* Cache entry states */
#define	RC_UNUSED	0
#define	RC_INPROG	1
#define	RC_DONE		2

/* Return values */
#define	RC_DROPIT	0
#define	RC_REPLY	1
#define	RC_DOIT		2
#define	RC_CHECKIT	3

/* Flag bits */
#define	RC_LOCKED	0x01
#define	RC_WANTED	0x02
#define	RC_REPSTATUS	0x04
#define	RC_REPMBUF	0x08
#define	RC_INETADDR	0x20
#define	RC_NAM		0x40

extern lck_grp_t *nfsrv_reqcache_lck_grp;
extern lck_mtx_t *nfsrv_reqcache_mutex;

#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_NFSRVCACHE_H_ */
                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/rpcv2.h                                         0100644 0001750 0001750 00000012721 12567450754 021575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)rpcv2.h	8.2 (Berkeley) 3/30/95
 * FreeBSD-Id: rpcv2.h,v 1.8 1997/05/11 18:05:39 tegge Exp $
 */


#ifndef _NFS_RPCV2_H_
#define _NFS_RPCV2_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE
/*
 * Definitions for Sun RPC Version 2, from
 * "RPC: Remote Procedure Call Protocol Specification" RFC1057
 */

/* Version # */
#define	RPC_VER2	2

/* Authentication */
#define	RPCAUTH_NULL	0
#define	RPCAUTH_NONE	RPCAUTH_NULL
#define	RPCAUTH_UNIX	1
#define RPCAUTH_SYS	RPCAUTH_UNIX
#define	RPCAUTH_SHORT	2
#define RPCAUTH_KERB4	4
#define RPCAUTH_KRB5	390003
#define RPCAUTH_KRB5I	390004
#define RPCAUTH_KRB5P	390005
#define RPCAUTH_INVALID	~0U
#define RPCAUTH_UNKNOWN	RPCAUTH_INVALID

#define	RPCAUTH_MAXSIZ	400
#define	RPCAUTH_UNIXGIDS 16

/*
 * Constants associated with authentication flavours.
 */
#define RPCAKN_FULLNAME	0
#define RPCAKN_NICKNAME	1

/* Rpc Constants */
#define	RPC_CALL	0
#define	RPC_REPLY	1
#define	RPC_MSGACCEPTED	0
#define	RPC_MSGDENIED	1
#define	RPC_SUCCESS	0
#define	RPC_PROGUNAVAIL	1
#define	RPC_PROGMISMATCH	2
#define	RPC_PROCUNAVAIL	3
#define	RPC_GARBAGE	4		/* I like this one */
#define	RPC_SYSTEM_ERR	5
#define	RPC_MISMATCH	0
#define	RPC_AUTHERR	1

/* Authentication failures */
#define	AUTH_BADCRED		1
#define	AUTH_REJECTCRED		2
#define	AUTH_BADVERF		3
#define	AUTH_REJECTVERF		4
#define	AUTH_TOOWEAK		5	/* Give em wheaties */
#define AUTH_INVALIDRESP	6
#define AUTH_FAILED		7
#define AUTH_KERB_GENERIC	8
#define AUTH_TIMEEXPIRE		9
#define AUTH_TKT_FILE		10
#define AUTH_DECODE		11
#define AUTH_NET_ADDR		12
#define RPCSEC_GSS_CREDPROBLEM	13
#define RPCSEC_GSS_CTXPROBLEM	14

/* Sizes of rpc header parts */
#define	RPC_SIZ		24
#define	RPC_REPLYSIZ	28

/* RPC Prog definitions */
#define	RPCPROG_MNT	100005
#define	RPCMNT_VER1	1
#define RPCMNT_VER3	3
#define	RPCMNT_MOUNT	1
#define	RPCMNT_DUMP	2
#define	RPCMNT_UMOUNT	3
#define	RPCMNT_UMNTALL	4
#define	RPCMNT_EXPORT	5
#define	RPCMNT_NAMELEN	255
#define	RPCMNT_PATHLEN	1024
#define	RPCPROG_NFS	100003

#define	RPCPROG_RQUOTA	100011
#define	RPCRQUOTA_VER		1
#define	RPCRQUOTA_EXT_VER	2
#define	RPCRQUOTA_GET		1
#define	RQUOTA_STAT_OK		1
#define	RQUOTA_STAT_NOQUOTA	2
#define	RQUOTA_STAT_EPERM	3

#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_RPCV2_H_ */
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nfs/xdr_subs.h                                      0100644 0001750 0001750 00000031550 12567450754 022373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *     The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed by the University of
 *     California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *     @(#)xdr_subs.h  8.3 (Berkeley) 3/30/95
 * FreeBSD-Id: xdr_subs.h,v 1.9 1997/02/22 09:42:53 peter Exp $
 */

#ifndef _NFS_XDR_SUBS_H_
#define _NFS_XDR_SUBS_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE
/*
 * Macros used for conversion to/from xdr representation by nfs...
 * These use the MACHINE DEPENDENT routines ntohl, htonl
 * As defined by "XDR: External Data Representation Standard" RFC1014
 *
 * To simplify the implementation, we use ntohl/htonl even on big-endian
 * machines, and count on them being `#define'd away.  Some of these
 * might be slightly more efficient as quad_t copies on a big-endian,
 * but we cannot count on their alignment anyway.
 */

#define	fxdr_unsigned(t, v)	((t)ntohl((uint32_t)(v)))
#define	txdr_unsigned(v)	(htonl((uint32_t)(v)))

#define	fxdr_hyper(f, t) { \
	((uint32_t *)(t))[_QUAD_HIGHWORD] = ntohl(((uint32_t *)(f))[0]); \
	((uint32_t *)(t))[_QUAD_LOWWORD] = ntohl(((uint32_t *)(f))[1]); \
}
#define	txdr_hyper(f, t) { \
	((uint32_t *)(t))[0] = htonl(((uint32_t *)(f))[_QUAD_HIGHWORD]); \
	((uint32_t *)(t))[1] = htonl(((uint32_t *)(f))[_QUAD_LOWWORD]); \
}


/*
 * xdrbuf
 *
 * generalized functionality for managing the building/dissecting of XDR data
 */
typedef enum xdrbuf_type { XDRBUF_BUFFER=1 } xdrbuf_type;

struct xdrbuf {
	union {
		struct {
			char *			xbb_base;	/* base address of buffer */
			uint32_t		xbb_size;	/* size of buffer */
			uint32_t		xbb_len;	/* length of data in buffer */
		} xb_buffer;
	} xb_u;
	char *		xb_ptr;		/* pointer to current position */
	size_t		xb_left;	/* bytes remaining in current buffer */
	size_t		xb_growsize;	/* bytes to allocate when growing */
	xdrbuf_type	xb_type;	/* type of xdr buffer */
	uint32_t	xb_flags;	/* XB_* (see below) */
};

#define XB_CLEANUP	0x0001	/* needs cleanup */

#define XDRWORD		4	/* the basic XDR building block is a 4 byte (32 bit) word */
#define xdr_rndup(a)	(((a)+3)&(~0x3))	/* round up to XDRWORD size */
#define xdr_pad(a)	(xdr_rndup(a) - (a))	/* calculate round up padding */

void xb_init(struct xdrbuf *, xdrbuf_type);
void xb_init_buffer(struct xdrbuf *, char *, size_t);
void xb_cleanup(struct xdrbuf *);
void *xb_malloc(size_t);
void xb_free(void *);
int xb_grow(struct xdrbuf *);
void xb_set_cur_buf_len(struct xdrbuf *);
char *xb_buffer_base(struct xdrbuf *);
int xb_advance(struct xdrbuf *, uint32_t);
int xb_offset(struct xdrbuf *);
int xb_seek(struct xdrbuf *, uint32_t);
int xb_add_bytes(struct xdrbuf *, const char *, uint32_t, int);
int xb_get_bytes(struct xdrbuf *, char *, uint32_t, int);

#ifdef _NFS_XDR_SUBS_FUNCS_

/*
 * basic initialization of xdrbuf structure
 */
void
xb_init(struct xdrbuf *xbp, xdrbuf_type type)
{
	bzero(xbp, sizeof(*xbp));
	xbp->xb_type = type;
	xbp->xb_flags |= XB_CLEANUP;
}

/*
 * initialize a single-buffer xdrbuf
 */
void
xb_init_buffer(struct xdrbuf *xbp, char *buf, size_t buflen)
{
	xb_init(xbp, XDRBUF_BUFFER);
	xbp->xb_u.xb_buffer.xbb_base = buf;
	xbp->xb_u.xb_buffer.xbb_size = buflen;
	xbp->xb_u.xb_buffer.xbb_len = buflen;
	xbp->xb_growsize = 512;
	xbp->xb_ptr = buf;
	xbp->xb_left = buflen;
	if (buf) /* when using an existing buffer, xb code should skip cleanup */
		xbp->xb_flags &= ~XB_CLEANUP;
}

/*
 * get the pointer to the single-buffer xdrbuf's buffer
 */
char *
xb_buffer_base(struct xdrbuf *xbp)
{
	return (xbp->xb_u.xb_buffer.xbb_base);
}

/*
 * clean up any resources held by an xdrbuf
 */
void
xb_cleanup(struct xdrbuf *xbp)
{
	if (!(xbp->xb_flags & XB_CLEANUP))
		return;
	switch (xbp->xb_type) {
	case XDRBUF_BUFFER:
		if (xbp->xb_u.xb_buffer.xbb_base)
			xb_free(xbp->xb_u.xb_buffer.xbb_base);
		break;
	}
	xbp->xb_flags &= ~XB_CLEANUP;
}

/*
 * set the length of valid data in the current buffer to
 * be up to the current location within the buffer
 */
void
xb_set_cur_buf_len(struct xdrbuf *xbp)
{
	switch (xbp->xb_type) {
	case XDRBUF_BUFFER:
		xbp->xb_u.xb_buffer.xbb_len = xbp->xb_ptr - xbp->xb_u.xb_buffer.xbb_base;
		break;
	}
}

/*
 * advance forward through existing data in xdrbuf
 */
int
xb_advance(struct xdrbuf *xbp, uint32_t len)
{
	uint32_t tlen;

	while (len) {
		if (xbp->xb_left <= 0)
			return (EBADRPC);
		tlen = MIN(xbp->xb_left, len);
		if (tlen) {
			xbp->xb_ptr += tlen;
			xbp->xb_left -= tlen;
			len -= tlen;
		}
	}
	return (0);
}

/*
 * Calculate the current offset in the XDR buffer.
 */
int
xb_offset(struct xdrbuf *xbp)
{
	uint32_t offset = 0;

	switch (xbp->xb_type) {
	case XDRBUF_BUFFER:
		offset = xbp->xb_ptr - xbp->xb_u.xb_buffer.xbb_base;
		break;
	}

	return (offset);
}

/*
 * Seek to the given offset in the existing data in the XDR buffer.
 */
int
xb_seek(struct xdrbuf *xbp, uint32_t offset)
{

	switch (xbp->xb_type) {
	case XDRBUF_BUFFER:
		xbp->xb_ptr = xbp->xb_u.xb_buffer.xbb_base + offset;
		xbp->xb_left = xbp->xb_u.xb_buffer.xbb_len - offset;
		break;
	}

	return (0);
}

/*
 * allocate memory
 */
void *
xb_malloc(size_t size)
{
	void *buf = NULL;

	buf = malloc(size);
	return (buf);
}
/*
 * free a chunk of memory allocated with xb_malloc()
 */
void
xb_free(void *buf)
{
	free(buf);
}

/*
 * Increase space available for new data in XDR buffer.
 */
int
xb_grow(struct xdrbuf *xbp)
{
	char *newbuf, *oldbuf;
	size_t newsize, oldsize;

	switch (xbp->xb_type) {
	case XDRBUF_BUFFER:
		oldsize = xbp->xb_u.xb_buffer.xbb_size;
		oldbuf = xbp->xb_u.xb_buffer.xbb_base;
		newsize = oldsize + xbp->xb_growsize;
		newbuf = xb_malloc(newsize);
		if (newbuf == NULL)
			return (ENOMEM);
		if (oldbuf != NULL) {
			bcopy(oldbuf, newbuf, oldsize);
			xb_free(oldbuf);
		}
		xbp->xb_u.xb_buffer.xbb_base = newbuf;
		xbp->xb_u.xb_buffer.xbb_size = newsize;
		xbp->xb_ptr = newbuf + oldsize;
		xbp->xb_left = xbp->xb_growsize;
		break;
	}

	return (0);
}

/*
 * xb_add_bytes()
 *
 * Add "count" bytes of opaque data pointed to by "buf" to the given XDR buffer.
 */
int
xb_add_bytes(struct xdrbuf *xbp, const char *buf, uint32_t count, int nopad)
{
	uint32_t len, tlen;
	int error;

	len = nopad ? count : xdr_rndup(count);

	/* copy in "count" bytes and zero out any pad bytes */
	while (len) {
		if (xbp->xb_left <= 0) {
			/* need more space */
			if ((error = xb_grow(xbp)))
				return (error);
			if (xbp->xb_left <= 0)
				return (ENOMEM);
		}
		tlen = MIN(xbp->xb_left, len);
		if (tlen) {
			if (count) {
				if (tlen > count)
					tlen = count;
				bcopy(buf, xbp->xb_ptr, tlen);
			} else {
				bzero(xbp->xb_ptr, tlen);
			}
			xbp->xb_ptr += tlen;
			xbp->xb_left -= tlen;
			len -= tlen;
			if (count) {
				buf += tlen;
				count -= tlen;
			}
		}
	}
	return (0);
}

/*
 * xb_get_bytes()
 *
 * Get "count" bytes of opaque data from the given XDR buffer.
 */
int
xb_get_bytes(struct xdrbuf *xbp, char *buf, uint32_t count, int nopad)
{
	uint32_t len, tlen;

	len = nopad ? count : xdr_rndup(count);

	/* copy in "count" bytes and zero out any pad bytes */
	while (len) {
		if (xbp->xb_left <= 0)
			return (ENOMEM);
		tlen = MIN(xbp->xb_left, len);
		if (tlen) {
			if (count) {
				if (tlen > count)
					tlen = count;
				bcopy(xbp->xb_ptr, buf, tlen);
			}
			xbp->xb_ptr += tlen;
			xbp->xb_left -= tlen;
			len -= tlen;
			if (count) {
				buf += tlen;
				count -= tlen;
			}
		}
	}
	return (0);
}

#endif /* _NFS_XDR_SUBS_FUNCS_ */


/*
 * macros for building XDR data
 */

/* finalize the data that has been added to the buffer */
#define xb_build_done(E, XB) \
	do { \
		if (E) break; \
		xb_set_cur_buf_len(XB); \
	} while (0)

/* add a 32-bit value */
#define xb_add_32(E, XB, VAL) \
	do { \
		uint32_t __tmp; \
		if (E) break; \
		__tmp = txdr_unsigned(VAL); \
		(E) = xb_add_bytes((XB), (void*)&__tmp, XDRWORD, 0); \
	} while (0)

/* add a 64-bit value */
#define xb_add_64(E, XB, VAL) \
	do { \
		uint64_t __tmp1, __tmp2; \
		if (E) break; \
		__tmp1 = (VAL); \
		txdr_hyper(&__tmp1, &__tmp2); \
		(E) = xb_add_bytes((XB), (char*)&__tmp2, 2 * XDRWORD, 0); \
	} while (0)

/* add an array of XDR words */
#define xb_add_word_array(E, XB, A, LEN) \
	do { \
		uint32_t __i; \
		xb_add_32((E), (XB), (LEN)); \
		for (__i=0; __i < (uint32_t)(LEN); __i++) \
			xb_add_32((E), (XB), (A)[__i]); \
	} while (0)
#define xb_add_bitmap(E, XB, B, LEN)	xb_add_word_array((E), (XB), (B), (LEN))

/* add a file handle */
#define xb_add_fh(E, XB, FHP, FHLEN) \
	do { \
		xb_add_32((E), (XB), (FHLEN)); \
		if (E) break; \
		(E) = xb_add_bytes((XB), (char*)(FHP), (FHLEN), 0); \
	} while (0)

/* add a string */
#define xb_add_string(E, XB, S, LEN) \
	do { \
		xb_add_32((E), (XB), (LEN)); \
		if (E) break; \
		(E) = xb_add_bytes((XB), (const char*)(S), (LEN), 0); \
	} while (0)


/*
 * macros for decoding XDR data
 */

/* skip past data in the buffer */
#define xb_skip(E, XB, LEN) \
	do { \
		if (E) break; \
		(E) = xb_advance((XB), (LEN)); \
	} while (0)

/* get a 32-bit value */
#define xb_get_32(E, XB, LVAL) \
	do { \
		uint32_t __tmp; \
		if (E) break; \
		(E) = xb_get_bytes((XB), (char*)&__tmp, XDRWORD, 0); \
		if (E) break; \
		(LVAL) = fxdr_unsigned(uint32_t, __tmp); \
	} while (0)

/* get a 64-bit value */
#define xb_get_64(E, XB, LVAL) \
	do { \
		uint64_t __tmp; \
		if (E) break; \
		(E) = xb_get_bytes((XB), (char*)&__tmp, 2 * XDRWORD, 0); \
		if (E) break; \
		fxdr_hyper(&__tmp, &(LVAL)); \
	} while (0)

/* get an array of XDR words (of a given expected/maximum length) */
#define xb_get_word_array(E, XB, A, LEN) \
	do { \
		uint32_t __len = 0, __i; \
		xb_get_32((E), (XB), __len); \
		if (E) break; \
		for (__i=0; __i < MIN(__len, (uint32_t)(LEN)); __i++) \
			xb_get_32((E), (XB), (A)[__i]); \
		if (E) break; \
		for (; __i < __len; __i++) \
			xb_skip((E), (XB), XDRWORD); \
		for (; __i < (uint32_t)(LEN); __i++) \
			(A)[__i] = 0; \
		(LEN) = __len; \
	} while (0)
#define xb_get_bitmap(E, XB, B, LEN)	xb_get_word_array((E), (XB), (B), (LEN))

#endif /* __APPLE_API_PRIVATE */
#endif /* _NFS_XDR_SUBS_H_ */
                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nl_types.h                                          0100644 0001750 0001750 00000006601 12566166136 021605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*	$NetBSD: nl_types.h,v 1.9 2000/10/03 19:53:32 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/include/nl_types.h,v 1.11 2005/02/27 16:20:53 phantom Exp $
 */

#ifndef _NL_TYPES_H_
#define _NL_TYPES_H_

#include <sys/cdefs.h>
#include <sys/types.h>
#include <_types.h>

#ifdef _NLS_PRIVATE
/*
 * MESSAGE CATALOG FILE FORMAT.
 *
 * The NetBSD/FreeBSD message catalog format is similar to the format used by
 * Svr4 systems.  The differences are:
 *   * fixed byte order (big endian)
 *   * fixed data field sizes
 *
 * A message catalog contains four data types: a catalog header, one
 * or more set headers, one or more message headers, and one or more
 * text strings.
 */

#define _NLS_MAGIC	0xff88ff89

struct _nls_cat_hdr {
	int32_t __magic;
	int32_t __nsets;
	int32_t __mem;
	int32_t __msg_hdr_offset;
	int32_t __msg_txt_offset;
} ;

struct _nls_set_hdr {
	int32_t __setno;	/* set number: 0 < x <= NL_SETMAX */
	int32_t __nmsgs;	/* number of messages in the set  */
	int32_t __index;	/* index of first msg_hdr in msg_hdr table */
} ;

struct _nls_msg_hdr {
	int32_t __msgno;	/* msg number: 0 < x <= NL_MSGMAX */
	int32_t __msglen;
	int32_t __offset;
} ;

#endif	/* _NLS_PRIVATE */

#define	NL_SETD		1
#define	NL_CAT_LOCALE	1

typedef struct __nl_cat_d {
	void	*__data;
	int	__size;
} *nl_catd;

#include <_types/_nl_item.h>

__BEGIN_DECLS
nl_catd  catopen(const char *, int);
char    *catgets(nl_catd, int, int, const char *)
	__attribute__((__format_arg__(4)));
int	 catclose(nl_catd);
__END_DECLS

#endif	/* _NL_TYPES_H_ */
                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/include/nlist.h                                             0100644 0001750 0001750 00000006552 12566166136 021106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nlist.h	8.2 (Berkeley) 1/21/94
 */

#ifndef _NLIST_H_
#define	_NLIST_H_

/*
 * Symbol table entry format.  The #ifdef's are so that programs including
 * nlist.h can initialize nlist structures statically.
 */
struct nlist {
#ifdef _AOUT_INCLUDE_
	union {
		char *n_name;	/* symbol name (in memory) */
		long n_strx;	/* file string table offset (on disk) */
	} n_un;
#else
	char *n_name;		/* symbol name (in memory) */
#endif

#define	N_UNDF	0x00		/* undefined */
#define	N_ABS	0x02		/* absolute address */
#define	N_TEXT	0x04		/* text segment */
#define	N_DATA	0x06		/* data segment */
#define	N_BSS	0x08		/* bss segment */
#define	N_COMM	0x12		/* common reference */
#define	N_FN	0x1e		/* file name */

#define	N_EXT	0x01		/* external (global) bit, OR'ed in */
#define	N_TYPE	0x1e		/* mask for all the type bits */
	unsigned char n_type;	/* type defines */

	char n_other;		/* spare */
#define	n_hash	n_desc		/* used internally by ld(1); XXX */
	short n_desc;		/* used by stab entries */
	unsigned long n_value;	/* address/value of the symbol */
};

#define	N_FORMAT	"%08x"	/* namelist value format; XXX */
#define	N_STAB		0x0e0	/* mask for debugger symbols -- stab(5) */

#include <sys/cdefs.h>

__BEGIN_DECLS
int nlist(const char *, struct nlist *);
__END_DECLS

#endif /* !_NLIST_H_ */
                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/notify.h                                            0100644 0001750 0001750 00000031456 12566166605 021267  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Portions Copyright (c) 2003-2010 Apple Inc.  All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __NOTIFICATION_H__
#define __NOTIFICATION_H__

#include <sys/cdefs.h>
#include <stdint.h>
#include <mach/message.h>
#include <Availability.h>
#ifdef __BLOCKS__
#include <dispatch/dispatch.h>
#endif /* __BLOCKS__ */

/*! @header
 * These routines allow processes to exchange stateless notification events.
 * Processes post notifications to a single system-wide notification server,
 * which then distributes notifications to client processes that have
 * registered to receive those notifications, including processes run by
 * other users.
 *
 * Notifications are associated with names in a namespace shared by all
 * clients of the system.  Clients may post notifications for names, and
 * may monitor names for posted notifications.  Clients may request
 * notification delivery by a number of different methods.
 *
 * Clients desiring to monitor names in the notification system must
 * register with the system, providing a name and other information
 * required for the desired notification delivery method.  Clients are
 * given an integer token representing the registration.
 *
 * Note that the kernel provides limited queues for mach message and file
 * descriptor messages.  It is important to make sure that clients read
 * mach ports and file descriptors frequently to prevent messages from
 * being lost due to resource limitations.  Clients that use signal-based
 * notification should be aware that signals are not delivered to
 * a process while it is running in a signal handler.  This may affect
 * the delivery of signals in close succession.
 *
 * Notifications may be coalesced in some cases.  Multiple events posted
 * for a name in rapid succession may result in a single notification sent
 * to clients registered for notification for that name.  Clients checking
 * for changes using the notify_check() routine cannot determine if
 * more than one event pas been posted since a previous call to 
 * notify_check() for that name.
 *
 * "False positives" may occur in notify_check() when used with a token
 * generated by notify_register_check() due to implementation constraints.
 * This behavior may vary in future releases.  
 *
 * Synchronization between two processes may be achieved using the
 * notify_set_state() and notify_get_state() routines.
 */

/*! @defineblock Status Codes
 * Status codes returned by the API.
 */
#define NOTIFY_STATUS_OK 0
#define NOTIFY_STATUS_INVALID_NAME 1
#define NOTIFY_STATUS_INVALID_TOKEN 2
#define NOTIFY_STATUS_INVALID_PORT 3
#define NOTIFY_STATUS_INVALID_FILE 4
#define NOTIFY_STATUS_INVALID_SIGNAL 5
#define NOTIFY_STATUS_INVALID_REQUEST 6
#define NOTIFY_STATUS_NOT_AUTHORIZED 7
#define NOTIFY_STATUS_FAILED 1000000
/*! @/defineblock */

/*!
 * Flag bits used for registration.
 */
#define NOTIFY_REUSE 0x00000001


/*!
 * Token values are zero or positive integers.
 * NOTIFY_TOKEN_INVALID is useful as an initial value for
 * a token value passed as an in/out parameter to one of
 * the registration routines below.
 */
#define NOTIFY_TOKEN_INVALID -1

__BEGIN_DECLS

/*!
 * Post a notification for a name.
 *
 * This is the only call that is required for a notification producer.
 * Returns status.
 */
uint32_t notify_post(const char *name);


#ifdef __BLOCKS__
typedef void (^notify_handler_t)(int token);

/*!
 * @function   notify_register
 * @abstract   Request notification delivery to a dispatch queue.
 * @discussion When notifications are received by the process, the notify
 *             subsystem will deliver the registered Block to the target
 *             dispatch queue.  Notification blocks are not re-entrant,
 *             and subsequent notification Blocks will not be delivered
 *             for the same registration until the previous Block has
 *             returned.
 * @param name (input) The notification name.
 * @param out_token (output) The registration token.
 * @param queue (input) The dispatch queue to which the Block is submitted.
 *              The dispatch queue is retained by the notify subsystem while
 *              the notification is registered, and will be released when
 *              notification is canceled.
 * @param block (input) The Block to invoke on the dispatch queue in response
 *              to a notification.  The notification token is passed to the
 *              Block as an argument so that the callee can modify the state
 *              of the notification or cancel the registration.
 * @result Returns status.
 */
uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_2);
#endif /* __BLOCKS__ */

/*!
 * Creates a registration token be used with notify_check(),
 * but no active notifications will be delivered.
 *
 * @param name
 *    (input) notification name
 * @param out_token
 *    (output) registration token
 * @result Returns status.
 */
uint32_t notify_register_check(const char *name, int *out_token);

/*!
 * Request notification delivery by UNIX signal.
 *
 * A client may request signal notification for multiple names.  After a signal
 * is delivered, the notify_check() routine may be called with each notification 
 * token to determine which name (if any) generated the signal notification.
 *
 * @param name (input) notification name
 * @param sig (input) signal number (see signal(3))
 * @param out_token (output) notification token
 * @result Returns status.
 */
uint32_t notify_register_signal(const char *name, int sig, int *out_token);

/*!
 * Request notification by mach message.  
 *
 * Notifications are delivered by an empty message sent to a mach port.
 * By default, a new port is allocated and a pointer to it is returned
 * as the value of "notify_port".  A mach port previously returned by a 
 * call to this routine may be used for notifications if a pointer to that
 * port is passed in to the routine and NOTIFY_REUSE is set in the flags
 * parameter.  The notification service must be able to extract send
 * rights to the port.
 *
 * Note that the kernel limits the size of the message queue for any port.
 * If it is important that notifications should not be lost due to queue
 * overflow, clients should service messages quickly, and be careful about
 * using the same port for notifications for more than one name.
 *
 * A notification message has an empty message body.  The msgh_id field
 * in the mach message header will have the value of the notification
 * token.  If a port is reused for multiple notification registrations,
 * the msgh_id value may be used to determine which name generated
 * the notification.
 *
 * @param name
 *     (input) notification name
 * @param  out_token
 *     (output) notification token
 * @param  notify_port
 *     (input/output) pointer to a mach port
 * @result Returns status.
 */
uint32_t notify_register_mach_port(const char *name, mach_port_t *notify_port, int flags, int *out_token);

/*
 * Request notification by a write to a file descriptor. 
 *
 * Notifications are delivered by a write to a file descriptor.
 * By default, a new file descriptor is created and a pointer to it
 * is returned as the value of "notify_fd".  A file descriptor created
 * by a previous call to this routine may be used for notifications if
 * a pointer to that file descriptor is passed in to the routine and
 * NOTIFY_REUSE is set in the flags parameter. 
 *
 * Note that the kernel limits the buffer space for queued writes on a
 * file descriptor.  If it is important that notifications should not be
 * lost due to queue overflow, clients should service messages quickly,
 * and be careful about using the same file descriptor for notifications
 * for more than one name.
 *
 * Notifications are delivered by an integer value written to the
 * file descriptor.  The value will match the notification token
 * for which the notification was generated.
 *
 * @param name
 *     (input) notification name
 * @param out_token
 *     (output) notification token
 * @param notify_fd
 *     (input/output) pointer to a file descriptor
 * @result Returns status.
 */
uint32_t notify_register_file_descriptor(const char *name, int *notify_fd, int flags, int *out_token);

/*!
 * Check if any notifications have been posted.
 *
 * Output parameter check is set to 0 for false, 1 for true.  Returns status.
 * check is set to true the first time notify_check is called for a token.
 * Subsequent calls set check to true when notifications have been posted for
 * the name associated with the notification token.  This routine is independent
 * of notify_post().  That is, check will be true if an application calls
 * notify_post() for a name and then calls notify_check() for a token associated
 * with that name.
 *
 * @param token
 *     (input)notification token
 * @param check
 *     (output) true/false indication
 * @result Returns status.
 */
uint32_t notify_check(int token, int *check);

/*!
 * Cancel notification and free resources associated with a notification
 * token.  Mach ports and file descriptor associated with a token are released 
 * (deallocated or closed) when all registration tokens associated with 
 * the port or file descriptor have been cancelled.
 *
 * @param token
 *     (input) notification token
 * @result Returns status.
 */
uint32_t notify_cancel(int token);

/*!
 * Suspend delivery of notifications for a token. Notifications for this token will be
 * pended and coalesced, then delivered following a matching call to notify_resume.
 * Calls to notify_suspend may be nested.  Notifications remain suspended until
 * an equal number of calls have been made to notify_resume.
 *
 * @param token
 *     (input) notification token
 * @result Returns status.
 */
uint32_t notify_suspend(int token)
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0);

/*!
 * Removes one level of suspension for a token previously suspended
 * by a call to notify_suspend.  Notifications will resume when a matching
 * call to notify_resume is made for each previous call to notify_suspend.
 * Notifications posted while a token is suspended are coalesced into
 * a single notification sent following a resumption.
 *
 * @param token
 *     (input) notification token
 * @result Returns status.
 */
uint32_t notify_resume(int token)
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0);

/*!
 * Set or get a state value associated with a notification token.
 * Each key in the notification namespace has an associated integer value available
 * for use by clients as for application-specific purposes.  A common usage is to 
 * allow two processes or threads to synchronize their activities.  For example, a
 * server process may need send a notification when a resource becomes available.
 * A client process can register for the notification, but when it starts up it will
 * not know whether the resource is available.  The server can set the state value,
 * and the client can check the value at startup time to synchronize with the server.
 *
 * Set the 64-bit integer state value.
 *
 * @param token
 *     (input) notification token
 * @param state64
 *     (input) 64-bit unsigned integer value
 * @result Returns status.
 */
uint32_t notify_set_state(int token, uint64_t state64)
__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);

/*!
 * Get the 64-bit integer state value.
 *
 * @param token
 *     (input) notification token
 * @param state64
 *     (output) 64-bit unsigned integer value
 * @result Returns status.
 */
uint32_t notify_get_state(int token, uint64_t *state64)
__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);

/*!
 * Determine if a token is valid (currently registered).
 * Negative integer values are always invalid.  Positive or
 * zero values are valid only if they are associated with an
 * existing registratiom.
 *
 * @param val
 *     (input) integer value
 * @result Returns true if the value is a valid token, false otherwise.
 */
bool notify_is_valid_token(int val)
__OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);

__END_DECLS

#endif /* __NOTIFICATION_H__ */
                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/include/notify_keys.h                                       0100644 0001750 0001750 00000006463 12566166605 022322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2007-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Portions Copyright (c) 2007-2009 Apple Inc.  All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This file lists notification keys that are posted using the 
 * notify_post() API by various Mac OS X system services.
 * The exact circumstances under which services post these
 * notifications is controlled by those services, and may change
 * in future software releases.
 */

/*
 * Directory Service notifications
 * These are posted by the DirectoryService daemon to advise clients that
 * cached data should be invalidated.
 */
#define kNotifyDSCacheInvalidation "com.apple.system.DirectoryService.InvalidateCache"
#define kNotifyDSCacheInvalidationGroup "com.apple.system.DirectoryService.InvalidateCache.group"
#define kNotifyDSCacheInvalidationHost "com.apple.system.DirectoryService.InvalidateCache.host"
#define kNotifyDSCacheInvalidationService "com.apple.system.DirectoryService.InvalidateCache.service"
#define kNotifyDSCacheInvalidationUser "com.apple.system.DirectoryService.InvalidateCache.user"

/*
 * File System notifications
 * These advise clients of various filesystem events.
 */
#define kNotifyVFSMount "com.apple.system.kernel.mount"
#define kNotifyVFSUnmount "com.apple.system.kernel.unmount"
#define kNotifyVFSUpdate "com.apple.system.kernel.mountupdate"
#define kNotifyVFSLowDiskSpace "com.apple.system.lowdiskspace"
#define kNotifyVFSLowDiskSpaceRootFS "com.apple.system.lowdiskspace.system"
#define kNotifyVFSLowDiskSpaceOtherFS "com.apple.system.lowdiskspace.user"

/*
 * System Configuration notifications
 * These advise clients of changes in the system configuration
 * managed by the system configuration server (configd).
 * Note that a much richer set of notifications are available to
 * clients using the SCDynamicStore API.
 */
#define kNotifySCHostNameChange "com.apple.system.hostname"
#define kNotifySCNetworkChange "com.apple.system.config.network_change"

/*
 * ASL notifications
 * Sent by syslogd to advise clients that new log messages have been
 * added to the ASL database.
 */
#define kNotifyASLDBUpdate "com.apple.system.logger.message"

/*
 * Time Zone change notification
 * Sent by notifyd when the system's timezone changes.
 */
#define kNotifyTimeZoneChange "com.apple.system.timezone"

/*
 * System clock change notification
 * Sent when a process modifies the system clock using the settimeofday system call.
 */
#define kNotifyClockSet "com.apple.system.clock_set"
                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/ntsid.h                                             0100644 0001750 0001750 00000002271 12566167025 021066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _NTSID_H_
#define _NTSID_H_

#include <sys/types.h>

#define NTSID_MAX_AUTHORITIES 16

typedef struct {
	u_int8_t		sid_kind;
	u_int8_t		sid_authcount;
	u_int8_t		sid_authority[6];
	u_int32_t		sid_authorities[NTSID_MAX_AUTHORITIES];
} nt_sid_t;

#endif /* !_NTSID_H_ */
                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/                                               0040755 0001750 0001750 00000000000 12612224753 020504  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/List.h                                         0100644 0001750 0001750 00000007012 12566174466 021602  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2002, 2005-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
    List.h
    Copyright 1988-1996 NeXT Software, Inc.

    DEFINED AS:	A common class
    HEADER FILES:	objc/List.h

*/

#ifndef _OBJC_LIST_H_
#define _OBJC_LIST_H_

#if __OBJC__  &&  !__OBJC2__  &&  !__cplusplus

#include <objc/Object.h>
#include <Availability.h>

DEPRECATED_ATTRIBUTE
@interface List : Object
{
@public
    id 		*dataPtr  DEPRECATED_ATTRIBUTE;	/* data of the List object */
    unsigned 	numElements  DEPRECATED_ATTRIBUTE;	/* Actual number of elements */
    unsigned 	maxElements  DEPRECATED_ATTRIBUTE;	/* Total allocated elements */
}

/* Creating, freeing */

- (id)free  DEPRECATED_ATTRIBUTE;
- (id)freeObjects  DEPRECATED_ATTRIBUTE;
- (id)copyFromZone:(void *)z  DEPRECATED_ATTRIBUTE;
  
/* Initializing */

- (id)init  DEPRECATED_ATTRIBUTE;
- (id)initCount:(unsigned)numSlots  DEPRECATED_ATTRIBUTE;

/* Comparing two lists */

- (BOOL)isEqual: anObject  DEPRECATED_ATTRIBUTE;
  
/* Managing the storage capacity */

- (unsigned)capacity  DEPRECATED_ATTRIBUTE;
- (id)setAvailableCapacity:(unsigned)numSlots  DEPRECATED_ATTRIBUTE;

/* Manipulating objects by index */

- (unsigned)count  DEPRECATED_ATTRIBUTE;
- (id)objectAt:(unsigned)index  DEPRECATED_ATTRIBUTE;
- (id)lastObject  DEPRECATED_ATTRIBUTE;
- (id)addObject:anObject  DEPRECATED_ATTRIBUTE;
- (id)insertObject:anObject at:(unsigned)index  DEPRECATED_ATTRIBUTE;
- (id)removeObjectAt:(unsigned)index  DEPRECATED_ATTRIBUTE;
- (id)removeLastObject  DEPRECATED_ATTRIBUTE;
- (id)replaceObjectAt:(unsigned)index with:newObject  DEPRECATED_ATTRIBUTE;
- (id)appendList: (List *)otherList  DEPRECATED_ATTRIBUTE;

/* Manipulating objects by id */

- (unsigned)indexOf:anObject  DEPRECATED_ATTRIBUTE;
- (id)addObjectIfAbsent:anObject  DEPRECATED_ATTRIBUTE;
- (id)removeObject:anObject  DEPRECATED_ATTRIBUTE;
- (id)replaceObject:anObject with:newObject  DEPRECATED_ATTRIBUTE;

/* Emptying the list */

- (id)empty  DEPRECATED_ATTRIBUTE;

/* Sending messages to elements of the list */

- (id)makeObjectsPerform:(SEL)aSelector  DEPRECATED_ATTRIBUTE;
- (id)makeObjectsPerform:(SEL)aSelector with:anObject  DEPRECATED_ATTRIBUTE;

/*
 * The following new... methods are now obsolete.  They remain in this 
 * interface file for backward compatibility only.  Use Object's alloc method 
 * and the init... methods defined in this class instead.
 */

+ (id)new  DEPRECATED_ATTRIBUTE;
+ (id)newCount:(unsigned)numSlots  DEPRECATED_ATTRIBUTE;

@end

typedef struct {
    @defs(List);
} NXListId  DEPRECATED_ATTRIBUTE;

#define NX_ADDRESS(x) (((NXListId *)(x))->dataPtr)

#define NX_NOT_IN_LIST	0xffffffff

#endif

#endif /* _OBJC_LIST_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/NSObjCRuntime.h                                0100644 0001750 0001750 00000001416 12566174466 023313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*	NSObjCRuntime.h
	Copyright (c) 1994-2012, Apple Inc. All rights reserved.
*/

#ifndef _OBJC_NSOBJCRUNTIME_H_
#define _OBJC_NSOBJCRUNTIME_H_

#include <TargetConditionals.h>
#include <objc/objc.h>

#if __LP64__ || (TARGET_OS_EMBEDDED && !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64
typedef long NSInteger;
typedef unsigned long NSUInteger;
#else
typedef int NSInteger;
typedef unsigned int NSUInteger;
#endif

#define NSIntegerMax    LONG_MAX
#define NSIntegerMin    LONG_MIN
#define NSUIntegerMax   ULONG_MAX

#define NSINTEGER_DEFINED 1

#ifndef NS_DESIGNATED_INITIALIZER
#if __has_attribute(objc_designated_initializer)
#define NS_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
#else
#define NS_DESIGNATED_INITIALIZER
#endif
#endif

#endif
                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/NSObject.h                                     0100644 0001750 0001750 00000006162 12566174466 022343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*	NSObject.h
	Copyright (c) 1994-2012, Apple Inc. All rights reserved.
*/

#ifndef _OBJC_NSOBJECT_H_
#define _OBJC_NSOBJECT_H_

#if __OBJC__

#include <objc/objc.h>
#include <objc/NSObjCRuntime.h>

@class NSString, NSMethodSignature, NSInvocation;

@protocol NSObject

- (BOOL)isEqual:(id)object;
@property (readonly) NSUInteger hash;

@property (readonly) Class superclass;
- (Class)class OBJC_SWIFT_UNAVAILABLE("use 'anObject.dynamicType' instead");
- (instancetype)self;

- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;

- (BOOL)isProxy;

- (BOOL)isKindOfClass:(Class)aClass;
- (BOOL)isMemberOfClass:(Class)aClass;
- (BOOL)conformsToProtocol:(Protocol *)aProtocol;

- (BOOL)respondsToSelector:(SEL)aSelector;

- (instancetype)retain OBJC_ARC_UNAVAILABLE;
- (oneway void)release OBJC_ARC_UNAVAILABLE;
- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;
- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;

- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;

@property (readonly, copy) NSString *description;
@optional
@property (readonly, copy) NSString *debugDescription;

@end


__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
OBJC_ROOT_CLASS
OBJC_EXPORT
@interface NSObject <NSObject> {
    Class isa  OBJC_ISA_AVAILABILITY;
}

+ (void)load;

+ (void)initialize;
- (instancetype)init
#if NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER
    NS_DESIGNATED_INITIALIZER
#endif
    ;

+ (instancetype)new OBJC_SWIFT_UNAVAILABLE("use object initializers instead");
+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE("use object initializers instead");
+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE("use object initializers instead");
- (void)dealloc OBJC_SWIFT_UNAVAILABLE("use 'deinit' to define a de-initializer");

- (void)finalize;

- (id)copy;
- (id)mutableCopy;

+ (id)copyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;
+ (id)mutableCopyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;

+ (BOOL)instancesRespondToSelector:(SEL)aSelector;
+ (BOOL)conformsToProtocol:(Protocol *)protocol;
- (IMP)methodForSelector:(SEL)aSelector;
+ (IMP)instanceMethodForSelector:(SEL)aSelector;
- (void)doesNotRecognizeSelector:(SEL)aSelector;

- (id)forwardingTargetForSelector:(SEL)aSelector __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE("");
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE("");

+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE("");

- (BOOL)allowsWeakReference UNAVAILABLE_ATTRIBUTE;
- (BOOL)retainWeakReference UNAVAILABLE_ATTRIBUTE;

+ (BOOL)isSubclassOfClass:(Class)aClass;

+ (BOOL)resolveClassMethod:(SEL)sel __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
+ (BOOL)resolveInstanceMethod:(SEL)sel __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

+ (NSUInteger)hash;
+ (Class)superclass;
+ (Class)class OBJC_SWIFT_UNAVAILABLE("use 'aClass.self' instead");
+ (NSString *)description;
+ (NSString *)debugDescription;

@end

#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/Object.h                                       0100644 0001750 0001750 00000007354 12566174466 022106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003, 2005-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
	Object.h
	Copyright 1988-1996 NeXT Software, Inc.
  
	DEFINED AS:	A common class
	HEADER FILES:	<objc/Object.h>

*/

#ifndef _OBJC_OBJECT_H_
#define _OBJC_OBJECT_H_

#include <stdarg.h>
#include <objc/objc-runtime.h>

#if __OBJC__  &&  !__OBJC2__

__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_NA)
OBJC_ROOT_CLASS
@interface Object
{
	Class isa;	/* A pointer to the instance's class structure */
}

/* Initializing classes and instances */

+ (id)initialize;
- (id)init;

/* Creating, copying, and freeing instances */

+ (id)new;
+ (id)free;
- (id)free;
+ (id)alloc;
- (id)copy;
+ (id)allocFromZone:(void *)zone;
- (id)copyFromZone:(void *)zone;
- (void *)zone;

/* Identifying classes */

+ (id)class;
+ (id)superclass;
+ (const char *) name;
- (id)class;
- (id)superclass;
- (const char *) name;

/* Identifying and comparing instances */

- (id)self;
- (unsigned int) hash;
- (BOOL) isEqual:anObject;

/* Testing inheritance relationships */

- (BOOL) isKindOf: aClassObject;
- (BOOL) isMemberOf: aClassObject;
- (BOOL) isKindOfClassNamed: (const char *)aClassName;
- (BOOL) isMemberOfClassNamed: (const char *)aClassName;

/* Testing class functionality */

+ (BOOL) instancesRespondTo:(SEL)aSelector;
- (BOOL) respondsTo:(SEL)aSelector;

/* Testing protocol conformance */

- (BOOL) conformsTo: (Protocol *)aProtocolObject;
+ (BOOL) conformsTo: (Protocol *)aProtocolObject;

/* Obtaining method descriptors from protocols */

- (struct objc_method_description *) descriptionForMethod:(SEL)aSel;
+ (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel;

/* Obtaining method handles */

- (IMP) methodFor:(SEL)aSelector;
+ (IMP) instanceMethodFor:(SEL)aSelector;

/* Sending messages determined at run time */

- (id)perform:(SEL)aSelector;
- (id)perform:(SEL)aSelector with:anObject;
- (id)perform:(SEL)aSelector with:object1 with:object2;

/* Posing */

+ (id)poseAs: aClassObject;

/* Enforcing intentions */
 
- (id)subclassResponsibility:(SEL)aSelector;
- (id)notImplemented:(SEL)aSelector;

/* Error handling */

- (id)doesNotRecognize:(SEL)aSelector;
- (id)error:(const char *)aString, ...;

/* Debugging */

- (void) printForDebugger:(void *)stream;

/* Archiving */

- (id)awake;
- (id)write:(void *)stream;
- (id)read:(void *)stream;
+ (int) version;
+ (id)setVersion: (int) aVersion;

/* Forwarding */

- (id)forward: (SEL)sel : (marg_list)args;
- (id)performv: (SEL)sel : (marg_list)args;

@end

/* Abstract Protocol for Archiving */

@interface Object (Archiving)

- (id)startArchiving: (void *)stream;
- (id)finishUnarchiving;

@end

/* Abstract Protocol for Dynamic Loading */

@interface Object (DynamicLoading)

//+ finishLoading:(headerType *)header;
struct mach_header;
+ (id)finishLoading:(struct mach_header *)header;
+ (id)startUnloading;

@end

#endif

#endif /* _OBJC_OBJECT_H_ */
                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/Protocol.h                                     0100644 0001750 0001750 00000004554 12566174466 022500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003, 2006-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
	Protocol.h
	Copyright 1991-1996 NeXT Software, Inc.
*/

#ifndef _OBJC_PROTOCOL_H_
#define _OBJC_PROTOCOL_H_

#if !__OBJC__

// typedef Protocol is here:
#include <objc/runtime.h>


#elif __OBJC2__

#include <objc/NSObject.h>

// All methods of class Protocol are unavailable. 
// Use the functions in objc/runtime.h instead.

__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
@interface Protocol : NSObject
@end


#else

#include <objc/Object.h>

__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
@interface Protocol : Object
{
@private
    char *protocol_name OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;
    struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;
    struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;
}

/* Obtaining attributes intrinsic to the protocol */

- (const char *)name OBJC2_UNAVAILABLE;

/* Testing protocol conformance */

- (BOOL) conformsTo: (Protocol *)aProtocolObject OBJC2_UNAVAILABLE;

/* Looking up information specific to a protocol */

- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);
- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel 
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);

@end

#endif

#endif /* _OBJC_PROTOCOL_H_ */
                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/hashtable.h                                    0100644 0001750 0001750 00000000036 12566174466 022621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <objc/hashtable2.h>

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/hashtable2.h                                   0100644 0001750 0001750 00000025223 12566174466 022710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
    hashtable2.h
    Scalable hash table.
    Copyright 1989-1996 NeXT Software, Inc.
*/

#ifndef _OBJC_LITTLE_HASHTABLE_H_
#define _OBJC_LITTLE_HASHTABLE_H_

#ifndef _OBJC_PRIVATE_H_
#   define OBJC_HASH_AVAILABILITY __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_1, __IPHONE_NA,__IPHONE_NA);
#else
#   define OBJC_HASH_AVAILABILITY
#endif

#include <objc/objc.h>
#include <stdint.h>
#include <TargetConditionals.h>

__BEGIN_DECLS

/*************************************************************************
 *	Hash tables of arbitrary data
 *************************************************************************/

/* This module allows hashing of arbitrary data.  Such data must be pointers or integers, and client is responsible for allocating/deallocating this data.  A deallocation call-back is provided.
The objective C class HashTable is preferred when dealing with (key, values) associations because it is easier to use in that situation.
As well-behaved scalable data structures, hash tables double in size when they start becoming full, thus guaranteeing both average constant time access and linear size. */

typedef struct {
    uintptr_t	(*hash)(const void *info, const void *data);
    int		(*isEqual)(const void *info, const void *data1, const void *data2);
    void	(*free)(const void *info, void *data);
    int		style; /* reserved for future expansion; currently 0 */
    } NXHashTablePrototype;
    
/* the info argument allows a certain generality, such as freeing according to some owner information */
/* invariants assumed by the implementation: 
	1 - data1 = data2 => hash(data1) = hash(data2)
	    when data varies over time, hash(data) must remain invariant
		    e.g. if data hashes over a string key, the string must not be changed
	2- isEqual (data1, data2) => data1= data2
 */

typedef struct {
    const NXHashTablePrototype	*prototype OBJC_HASH_AVAILABILITY;
    unsigned			count OBJC_HASH_AVAILABILITY;
    unsigned			nbBuckets OBJC_HASH_AVAILABILITY;
    void			*buckets OBJC_HASH_AVAILABILITY;
    const void			*info OBJC_HASH_AVAILABILITY;
   } NXHashTable OBJC_HASH_AVAILABILITY;
    /* private data structure; may change */
    
OBJC_EXPORT NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) OBJC_HASH_AVAILABILITY;
OBJC_EXPORT NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype, unsigned capacity, const void *info) OBJC_HASH_AVAILABILITY;
    /* if hash is 0, pointer hash is assumed */
    /* if isEqual is 0, pointer equality is assumed */
    /* if free is 0, elements are not freed */
    /* capacity is only a hint; 0 creates a small table */
    /* info allows call backs to be very general */

OBJC_EXPORT void NXFreeHashTable (NXHashTable *table) OBJC_HASH_AVAILABILITY;
    /* calls free for each data, and recovers table */
	
OBJC_EXPORT void NXEmptyHashTable (NXHashTable *table) OBJC_HASH_AVAILABILITY;
    /* does not deallocate table nor data; keeps current capacity */

OBJC_EXPORT void NXResetHashTable (NXHashTable *table) OBJC_HASH_AVAILABILITY;
    /* frees each entry; keeps current capacity */

OBJC_EXPORT BOOL NXCompareHashTables (NXHashTable *table1, NXHashTable *table2) OBJC_HASH_AVAILABILITY;
    /* Returns YES if the two sets are equal (each member of table1 in table2, and table have same size) */

OBJC_EXPORT NXHashTable *NXCopyHashTable (NXHashTable *table) OBJC_HASH_AVAILABILITY;
    /* makes a fresh table, copying data pointers, not data itself.  */
	
OBJC_EXPORT unsigned NXCountHashTable (NXHashTable *table) OBJC_HASH_AVAILABILITY;
    /* current number of data in table */
	
OBJC_EXPORT int NXHashMember (NXHashTable *table, const void *data) OBJC_HASH_AVAILABILITY;
    /* returns non-0 iff data is present in table.
    Example of use when the hashed data is a struct containing the key,
    and when the callee only has a key:
	MyStruct	pseudo;
	pseudo.key = myKey;
	return NXHashMember (myTable, &pseudo)
    */
	
OBJC_EXPORT void *NXHashGet (NXHashTable *table, const void *data) OBJC_HASH_AVAILABILITY;
    /* return original table data or NULL.
    Example of use when the hashed data is a struct containing the key,
    and when the callee only has a key:
	MyStruct	pseudo;
	MyStruct	*original;
	pseudo.key = myKey;
	original = NXHashGet (myTable, &pseudo)
    */
	
OBJC_EXPORT void *NXHashInsert (NXHashTable *table, const void *data) OBJC_HASH_AVAILABILITY;
    /* previous data or NULL is returned. */
	
OBJC_EXPORT void *NXHashInsertIfAbsent (NXHashTable *table, const void *data) OBJC_HASH_AVAILABILITY;
    /* If data already in table, returns the one in table
    else adds argument to table and returns argument. */

OBJC_EXPORT void *NXHashRemove (NXHashTable *table, const void *data) OBJC_HASH_AVAILABILITY;
    /* previous data or NULL is returned */
	
/* Iteration over all elements of a table consists in setting up an iteration state and then to progress until all entries have been visited.  An example of use for counting elements in a table is:
    unsigned	count = 0;
    MyData	*data;
    NXHashState	state = NXInitHashState(table);
    while (NXNextHashState(table, &state, &data)) {
	count++;
    }
*/

typedef struct {int i; int j;} NXHashState OBJC_HASH_AVAILABILITY;
    /* callers should not rely on actual contents of the struct */

OBJC_EXPORT NXHashState NXInitHashState(NXHashTable *table) OBJC_HASH_AVAILABILITY;

OBJC_EXPORT int NXNextHashState(NXHashTable *table, NXHashState *state, void **data) OBJC_HASH_AVAILABILITY;
    /* returns 0 when all elements have been visited */

/*************************************************************************
 *	Conveniences for writing hash, isEqual and free functions
 *	and common prototypes
 *************************************************************************/

OBJC_EXPORT uintptr_t NXPtrHash(const void *info, const void *data) OBJC_HASH_AVAILABILITY;
    /* scrambles the address bits; info unused */
OBJC_EXPORT uintptr_t NXStrHash(const void *info, const void *data) OBJC_HASH_AVAILABILITY;
    /* string hashing; info unused */
OBJC_EXPORT int NXPtrIsEqual(const void *info, const void *data1, const void *data2) OBJC_HASH_AVAILABILITY;
    /* pointer comparison; info unused */
OBJC_EXPORT int NXStrIsEqual(const void *info, const void *data1, const void *data2) OBJC_HASH_AVAILABILITY;
    /* string comparison; NULL ok; info unused */
OBJC_EXPORT void NXNoEffectFree(const void *info, void *data) OBJC_HASH_AVAILABILITY;
    /* no effect; info unused */
OBJC_EXPORT void NXReallyFree(const void *info, void *data) OBJC_HASH_AVAILABILITY;
    /* frees it; info unused */

/* The two following prototypes are useful for manipulating set of pointers or set of strings; For them free is defined as NXNoEffectFree */
OBJC_EXPORT const NXHashTablePrototype NXPtrPrototype OBJC_HASH_AVAILABILITY;
    /* prototype when data is a pointer (void *) */
OBJC_EXPORT const NXHashTablePrototype NXStrPrototype OBJC_HASH_AVAILABILITY;
    /* prototype when data is a string (char *) */

/* following prototypes help describe mappings where the key is the first element of a struct and is either a pointer or a string.
For example NXStrStructKeyPrototype can be used to hash pointers to Example, where Example is:
	typedef struct {
	    char	*key;
	    int		data1;
	    ...
	    } Example
    
For the following prototypes, free is defined as NXReallyFree.
 */
OBJC_EXPORT const NXHashTablePrototype NXPtrStructKeyPrototype OBJC_HASH_AVAILABILITY;
OBJC_EXPORT const NXHashTablePrototype NXStrStructKeyPrototype OBJC_HASH_AVAILABILITY;


#if !__OBJC2__  &&  !TARGET_OS_WIN32

/*************************************************************************
 *	Unique strings and buffers
 *************************************************************************/

/* Unique strings allows C users to enjoy the benefits of Lisp's atoms:
A unique string is a string that is allocated once for all (never de-allocated) and that has only one representant (thus allowing comparison with == instead of strcmp).  A unique string should never be modified (and in fact some memory protection is done to ensure that).  In order to more explicitly insist on the fact that the string has been uniqued, a synonym of (const char *) has been added, NXAtom. */

typedef const char *NXAtom OBJC_HASH_AVAILABILITY;

OBJC_EXPORT NXAtom NXUniqueString(const char *buffer) OBJC_HASH_AVAILABILITY;
    /* assumes that buffer is \0 terminated, and returns
     a previously created string or a new string that is a copy of buffer.
    If NULL is passed returns NULL.
    Returned string should never be modified.  To ensure this invariant,
    allocations are made in a special read only zone. */
	
OBJC_EXPORT NXAtom NXUniqueStringWithLength(const char *buffer, int length) OBJC_HASH_AVAILABILITY;
    /* assumes that buffer is a non NULL buffer of at least 
    length characters.  Returns a previously created string or 
    a new string that is a copy of buffer. 
    If buffer contains \0, string will be truncated.
    As for NXUniqueString, returned string should never be modified.  */
	
OBJC_EXPORT NXAtom NXUniqueStringNoCopy(const char *string) OBJC_HASH_AVAILABILITY;
    /* If there is already a unique string equal to string, returns the original.  
    Otherwise, string is entered in the table, without making a copy.  Argument should then never be modified.  */
	
OBJC_EXPORT char *NXCopyStringBuffer(const char *buffer) OBJC_HASH_AVAILABILITY;
    /* given a buffer, allocates a new string copy of buffer.  
    Buffer should be \0 terminated; returned string is \0 terminated. */

OBJC_EXPORT char *NXCopyStringBufferFromZone(const char *buffer, void *z) OBJC_HASH_AVAILABILITY;
    /* given a buffer, allocates a new string copy of buffer.  
    Buffer should be \0 terminated; returned string is \0 terminated. */

#endif

__END_DECLS

#endif /* _OBJC_LITTLE_HASHTABLE_H_ */
                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/message.h                                      0100644 0001750 0001750 00000027304 12566174466 022321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _OBJC_MESSAGE_H
#define _OBJC_MESSAGE_H

#pragma GCC system_header

#include <objc/objc.h>
#include <objc/runtime.h>

#pragma GCC system_header

#ifndef OBJC_SUPER
#define OBJC_SUPER

/// Specifies the superclass of an instance. 
struct objc_super {
    /// Specifies an instance of a class.
    __unsafe_unretained id receiver;

    /// Specifies the particular superclass of the instance to message. 
#if !defined(__cplusplus)  &&  !__OBJC2__
    /* For compatibility with old objc-runtime.h header */
    __unsafe_unretained Class class;
#else
    __unsafe_unretained Class super_class;
#endif
    /* super_class is the first class to search */
};
#endif


/* Basic Messaging Primitives
 *
 * On some architectures, use objc_msgSend_stret for some struct return types.
 * On some architectures, use objc_msgSend_fpret for some float return types.
 * On some architectures, use objc_msgSend_fp2ret for some float return types.
 *
 * These functions must be cast to an appropriate function pointer type 
 * before being called. 
 */
#if !OBJC_OLD_DISPATCH_PROTOTYPES
OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
#else
/** 
 * Sends a message with a simple return value to an instance of a class.
 * 
 * @param self A pointer to the instance of the class that is to receive the message.
 * @param op The selector of the method that handles the message.
 * @param ... 
 *   A variable argument list containing the arguments to the method.
 * 
 * @return The return value of the method.
 * 
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; 
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 */
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
/** 
 * Sends a message with a simple return value to the superclass of an instance of a class.
 * 
 * @param super A pointer to an \c objc_super data structure. Pass values identifying the
 *  context the message was sent to, including the instance of the class that is to receive the
 *  message and the superclass at which to start searching for the method implementation.
 * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.
 * @param ...
 *   A variable argument list containing the arguments to the method.
 * 
 * @return The return value of the method identified by \e op.
 * 
 * @see objc_msgSend
 */
OBJC_EXPORT id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
#endif


/* Struct-returning Messaging Primitives
 *
 * Use these functions to call methods that return structs on the stack. 
 * On some architectures, some structures are returned in registers. 
 * Consult your local function call ABI documentation for details.
 * 
 * These functions must be cast to an appropriate function pointer type 
 * before being called. 
 */
#if !OBJC_OLD_DISPATCH_PROTOTYPES
OBJC_EXPORT void objc_msgSend_stret(void /* id self, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARM64_UNAVAILABLE;
OBJC_EXPORT void objc_msgSendSuper_stret(void /* struct objc_super *super, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARM64_UNAVAILABLE;
#else
/** 
 * Sends a message with a data-structure return value to an instance of a class.
 * 
 * @see objc_msgSend
 */
OBJC_EXPORT void objc_msgSend_stret(id self, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARM64_UNAVAILABLE;

/** 
 * Sends a message with a data-structure return value to the superclass of an instance of a class.
 * 
 * @see objc_msgSendSuper
 */
OBJC_EXPORT void objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARM64_UNAVAILABLE;
#endif


/* Floating-point-returning Messaging Primitives
 * 
 * Use these functions to call methods that return floating-point values 
 * on the stack. 
 * Consult your local function call ABI documentation for details.
 * 
 * arm:    objc_msgSend_fpret not used
 * i386:   objc_msgSend_fpret used for `float`, `double`, `long double`.
 * x86-64: objc_msgSend_fpret used for `long double`.
 *
 * arm:    objc_msgSend_fp2ret not used
 * i386:   objc_msgSend_fp2ret not used
 * x86-64: objc_msgSend_fp2ret used for `_Complex long double`.
 *
 * These functions must be cast to an appropriate function pointer type 
 * before being called. 
 */
#if !OBJC_OLD_DISPATCH_PROTOTYPES

# if defined(__i386__)

OBJC_EXPORT void objc_msgSend_fpret(void /* id self, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);

# elif defined(__x86_64__)

OBJC_EXPORT void objc_msgSend_fpret(void /* id self, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT void objc_msgSend_fp2ret(void /* id self, SEL op, ... */ )
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

# endif

// !OBJC_OLD_DISPATCH_PROTOTYPES
#else
// OBJC_OLD_DISPATCH_PROTOTYPES
# if defined(__i386__)

/** 
 * Sends a message with a floating-point return value to an instance of a class.
 * 
 * @see objc_msgSend
 * @note On the i386 platform, the ABI for functions returning a floating-point value is
 *  incompatible with that for functions returning an integral type. On the i386 platform, therefore, 
 *  you must use \c objc_msgSend_fpret for functions returning non-integral type. For \c float or 
 *  \c long \c double return types, cast the function to an appropriate function pointer type first.
 */
OBJC_EXPORT double objc_msgSend_fpret(id self, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);

/* Use objc_msgSendSuper() for fp-returning messages to super. */
/* See also objc_msgSendv_fpret() below. */

# elif defined(__x86_64__)
/** 
 * Sends a message with a floating-point return value to an instance of a class.
 * 
 * @see objc_msgSend
 */
OBJC_EXPORT long double objc_msgSend_fpret(id self, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

#  if __STDC_VERSION__ >= 199901L
OBJC_EXPORT _Complex long double objc_msgSend_fp2ret(id self, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
#  else
OBJC_EXPORT void objc_msgSend_fp2ret(id self, SEL op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
#  endif

/* Use objc_msgSendSuper() for fp-returning messages to super. */
/* See also objc_msgSendv_fpret() below. */

# endif

// OBJC_OLD_DISPATCH_PROTOTYPES
#endif


/* Direct Method Invocation Primitives
 * Use these functions to call the implementation of a given Method.
 * This is faster than calling method_getImplementation() and method_getName().
 *
 * The receiver must not be nil.
 *
 * These functions must be cast to an appropriate function pointer type 
 * before being called. 
 */
#if !OBJC_OLD_DISPATCH_PROTOTYPES
OBJC_EXPORT void method_invoke(void /* id receiver, Method m, ... */ ) 
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT void method_invoke_stret(void /* id receiver, Method m, ... */ ) 
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0)
    OBJC_ARM64_UNAVAILABLE;
#else
OBJC_EXPORT id method_invoke(id receiver, Method m, ...) 
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT void method_invoke_stret(id receiver, Method m, ...) 
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0)
    OBJC_ARM64_UNAVAILABLE;
#endif


/* Message Forwarding Primitives
 * Use these functions to forward a message as if the receiver did not 
 * respond to it. 
 *
 * The receiver must not be nil.
 * 
 * class_getMethodImplementation() may return (IMP)_objc_msgForward.
 * class_getMethodImplementation_stret() may return (IMP)_objc_msgForward_stret
 * 
 * These functions must be cast to an appropriate function pointer type 
 * before being called. 
 *
 * Before Mac OS X 10.6, _objc_msgForward must not be called directly 
 * but may be compared to other IMP values.
 */
#if !OBJC_OLD_DISPATCH_PROTOTYPES
OBJC_EXPORT void _objc_msgForward(void /* id receiver, SEL sel, ... */ ) 
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
OBJC_EXPORT void _objc_msgForward_stret(void /* id receiver, SEL sel, ... */ ) 
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
    OBJC_ARM64_UNAVAILABLE;
#else
OBJC_EXPORT id _objc_msgForward(id receiver, SEL sel, ...) 
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
OBJC_EXPORT void _objc_msgForward_stret(id receiver, SEL sel, ...) 
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
    OBJC_ARM64_UNAVAILABLE;
#endif


/* Variable-argument Messaging Primitives
 *
 * Use these functions to call methods with a list of arguments, such 
 * as the one passed to forward:: .
 *
 * The contents of the argument list are architecture-specific. 
 * Consult your local function call ABI documentation for details.
 * 
 * These functions must be cast to an appropriate function pointer type 
 * before being called, except for objc_msgSendv_stret() which must not 
 * be cast to a struct-returning type.
 */

typedef void* marg_list;

OBJC_EXPORT id objc_msgSendv(id self, SEL op, size_t arg_size, marg_list arg_frame) OBJC2_UNAVAILABLE;
OBJC_EXPORT void objc_msgSendv_stret(void *stretAddr, id self, SEL op, size_t arg_size, marg_list arg_frame) OBJC2_UNAVAILABLE;
/* Note that objc_msgSendv_stret() does not return a structure type, 
 * and should not be cast to do so. This is unlike objc_msgSend_stret() 
 * and objc_msgSendSuper_stret().
 */
#if defined(__i386__)
OBJC_EXPORT double objc_msgSendv_fpret(id self, SEL op, unsigned arg_size, marg_list arg_frame) OBJC2_UNAVAILABLE;
#endif


/* The following marg_list macros are of marginal utility. They
 * are included for compatibility with the old objc-class.h header. */

#if !__OBJC2__

#define marg_prearg_size	0

#define marg_malloc(margs, method) \
	do { \
		margs = (marg_list *)malloc (marg_prearg_size + ((7 + method_getSizeOfArguments(method)) & ~7)); \
	} while (0)

#define marg_free(margs) \
	do { \
		free(margs); \
	} while (0)
	
#define marg_adjustedOffset(method, offset) \
	(marg_prearg_size + offset)

#define marg_getRef(margs, offset, type) \
	( (type *)((char *)margs + marg_adjustedOffset(method,offset) ) )

#define marg_getValue(margs, offset, type) \
	( *marg_getRef(margs, offset, type) )

#define marg_setValue(margs, offset, type, value) \
	( marg_getValue(margs, offset, type) = (value) )

#endif

#endif
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/module.map                                     0100644 0001750 0001750 00000001063 12566173263 022474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        module ObjectiveC [system] [extern_c] {
  umbrella "."
  export *
  module * { 
    export *
  }

  module NSObject {
    requires objc
    header "NSObject.h"
    export *
  }


  module List {
    // Uses @defs, which does not work in ObjC++ or non-ARC.
    requires objc, !objc_arc, !cplusplus
    header "List.h"
    export *
  }

  module Object {
    requires objc
    header "Object.h"
    export *
  }

  module Protocol {
    requires objc
    header "Protocol.h"
    export *
  }



  
  exclude header "hashtable.h"
  exclude header "hashtable2.h"

}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-api.h                                     0100644 0001750 0001750 00000014742 12566174466 022363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
// Copyright 1988-1996 NeXT Software, Inc.

#ifndef _OBJC_OBJC_API_H_
#define _OBJC_OBJC_API_H_

#include <Availability.h>
#include <AvailabilityMacros.h>
#include <TargetConditionals.h>

#ifndef __has_feature
#   define __has_feature(x) 0
#endif

#ifndef __has_extension
#   define __has_extension __has_feature
#endif

#ifndef __has_attribute
#   define __has_attribute(x) 0
#endif


/*
 * OBJC_API_VERSION 0 or undef: Tiger and earlier API only
 * OBJC_API_VERSION 2: Leopard and later API available
 */
#if !defined(OBJC_API_VERSION)
#   if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)  &&  __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_5
#       define OBJC_API_VERSION 0
#   else
#       define OBJC_API_VERSION 2
#   endif
#endif


/*
 * OBJC_NO_GC 1: GC is not supported
 * OBJC_NO_GC undef: GC is supported
 *
 * OBJC_NO_GC_API undef: Libraries must export any symbols that 
 *                       dual-mode code may links to.
 * OBJC_NO_GC_API 1: Libraries need not export GC-related symbols.
 */
#if TARGET_OS_EMBEDDED  ||  TARGET_OS_IPHONE  ||  TARGET_OS_WIN32
    /* GC is unsupported. GC API symbols are not exported. */
#   define OBJC_NO_GC 1
#   define OBJC_NO_GC_API 1
#elif TARGET_OS_MAC && __x86_64h__
    /* GC is unsupported. GC API symbols are exported. */
#   define OBJC_NO_GC 1
#   undef  OBJC_NO_GC_API
#else
    /* GC is supported. */
#   undef  OBJC_NO_GC
#   undef  OBJC_GC_API
#endif


/* NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER == 1 
 * marks -[NSObject init] as a designated initializer. */
#if !defined(NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER)
#   define NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER 1
#endif


/* OBJC_OLD_DISPATCH_PROTOTYPES == 0 enforces the rule that the dispatch 
 * functions must be cast to an appropriate function pointer type. */
#if !defined(OBJC_OLD_DISPATCH_PROTOTYPES)
#   define OBJC_OLD_DISPATCH_PROTOTYPES 1
#endif


/* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable 
 * in the future */
#if !defined(OBJC_ISA_AVAILABILITY)
#   if __OBJC2__
#       define OBJC_ISA_AVAILABILITY  __attribute__((deprecated))
#   else
#       define OBJC_ISA_AVAILABILITY  /* still available */
#   endif
#endif


/* OBJC2_UNAVAILABLE: unavailable in objc 2.0, deprecated in Leopard */
#if !defined(OBJC2_UNAVAILABLE)
#   if __OBJC2__
#       define OBJC2_UNAVAILABLE UNAVAILABLE_ATTRIBUTE
#   else
        /* plain C code also falls here, but this is close enough */
#       define OBJC2_UNAVAILABLE __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0)
#   endif
#endif

/* OBJC_ARC_UNAVAILABLE: unavailable with -fobjc-arc */
#if !defined(OBJC_ARC_UNAVAILABLE)
#   if __has_feature(objc_arc)
#       if __has_extension(attribute_unavailable_with_message)
#           define OBJC_ARC_UNAVAILABLE __attribute__((unavailable("not available in automatic reference counting mode")))
#       else
#           define OBJC_ARC_UNAVAILABLE __attribute__((unavailable))
#       endif
#   else
#       define OBJC_ARC_UNAVAILABLE
#   endif
#endif

/* OBJC_SWIFT_UNAVAILABLE: unavailable in Swift */
#if !defined(OBJC_SWIFT_UNAVAILABLE)
#   if __has_feature(attribute_availability_swift)
#       define OBJC_SWIFT_UNAVAILABLE(_msg) __attribute__((availability(swift, unavailable, message=_msg)))
#   else
#       define OBJC_SWIFT_UNAVAILABLE(_msg)
#   endif
#endif

/* OBJC_ARM64_UNAVAILABLE: unavailable on arm64 (i.e. stret dispatch) */
#if !defined(OBJC_ARM64_UNAVAILABLE)
#   if defined(__arm64__)
#       define OBJC_ARM64_UNAVAILABLE __attribute__((unavailable("not available in arm64")))
#   else
#       define OBJC_ARM64_UNAVAILABLE 
#   endif
#endif

/* OBJC_GC_UNAVAILABLE: unavailable with -fobjc-gc or -fobjc-gc-only */
#if !defined(OBJC_GC_UNAVAILABLE)
#   if __OBJC_GC__
#       if __has_extension(attribute_unavailable_with_message)
#           define OBJC_GC_UNAVAILABLE __attribute__((unavailable("not available in garbage collecting mode")))
#       else
#           define OBJC_GC_UNAVAILABLE __attribute__((unavailable))
#       endif
#   else
#       define OBJC_GC_UNAVAILABLE
#   endif
#endif

#if !defined(OBJC_EXTERN)
#   if defined(__cplusplus)
#       define OBJC_EXTERN extern "C" 
#   else
#       define OBJC_EXTERN extern
#   endif
#endif

#if !defined(OBJC_VISIBLE)
#   if TARGET_OS_WIN32
#       if defined(BUILDING_OBJC)
#           define OBJC_VISIBLE __declspec(dllexport)
#       else
#           define OBJC_VISIBLE __declspec(dllimport)
#       endif
#   else
#       define OBJC_VISIBLE  __attribute__((visibility("default")))
#   endif
#endif

#if !defined(OBJC_EXPORT)
#   define OBJC_EXPORT  OBJC_EXTERN OBJC_VISIBLE
#endif

#if !defined(OBJC_IMPORT)
#   define OBJC_IMPORT extern
#endif

#if !defined(OBJC_ROOT_CLASS)
#   if __has_attribute(objc_root_class)
#       define OBJC_ROOT_CLASS __attribute__((objc_root_class))
#   else
#       define OBJC_ROOT_CLASS
#   endif
#endif

#ifndef __DARWIN_NULL
#define __DARWIN_NULL NULL
#endif

#if !defined(OBJC_INLINE)
#   define OBJC_INLINE __inline
#endif

// Declares an enum type or option bits type as appropriate for each language.
#if (__cplusplus && __cplusplus >= 201103L && (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus && __has_feature(objc_fixed_enum))
#define OBJC_ENUM(_type, _name) enum _name : _type _name; enum _name : _type
#if (__cplusplus)
#define OBJC_OPTIONS(_type, _name) _type _name; enum : _type
#else
#define OBJC_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type
#endif
#else
#define OBJC_ENUM(_type, _name) _type _name; enum
#define OBJC_OPTIONS(_type, _name) _type _name; enum
#endif

#endif
                              osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-auto.h                                    0100644 0001750 0001750 00000031003 12566174466 022547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _OBJC_AUTO_H_
#define _OBJC_AUTO_H_

#pragma GCC system_header

#include <objc/objc.h>
#include <malloc/malloc.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <Availability.h>
#include <TargetConditionals.h>

#if !TARGET_OS_WIN32
#include <sys/types.h>
#include <libkern/OSAtomic.h>
#else
#   define WINVER 0x0501		// target Windows XP and later
#   define _WIN32_WINNT 0x0501	// target Windows XP and later
#   define WIN32_LEAN_AND_MEAN
// workaround: windef.h typedefs BOOL as int
#   define BOOL WINBOOL
#   include <windows.h>
#   undef BOOL
#endif


/* objc_collect() options */
enum {
    // choose one
    OBJC_RATIO_COLLECTION        = (0 << 0),  // run "ratio" generational collections, then a full
    OBJC_GENERATIONAL_COLLECTION = (1 << 0),  // run fast incremental collection
    OBJC_FULL_COLLECTION         = (2 << 0),  // run full collection.
    OBJC_EXHAUSTIVE_COLLECTION   = (3 << 0),  // run full collections until memory available stops improving
    
    OBJC_COLLECT_IF_NEEDED       = (1 << 3), // run collection only if needed (allocation threshold exceeded)
    OBJC_WAIT_UNTIL_DONE         = (1 << 4), // wait (when possible) for collection to end before returning (when collector is running on dedicated thread)
};

/* objc_clear_stack() options */
enum {
    OBJC_CLEAR_RESIDENT_STACK = (1 << 0)
};

#ifndef OBJC_NO_GC


/* GC declarations */

/* Collection utilities */

OBJC_EXPORT void objc_collect(unsigned long options)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);
OBJC_EXPORT BOOL objc_collectingEnabled(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);
OBJC_EXPORT malloc_zone_t *objc_collectableZone(void) 
    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/* GC configuration */

/* Tells collector to wait until specified bytes have been allocated before trying to collect again. */
OBJC_EXPORT void objc_setCollectionThreshold(size_t threshold)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);

/* Tells collector to run a full collection for every ratio generational collections. */
OBJC_EXPORT void objc_setCollectionRatio(size_t ratio)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);

// 
// GC-safe compare-and-swap
//

/* Atomic update, with write barrier. */
OBJC_EXPORT BOOL objc_atomicCompareAndSwapPtr(id predicate, id replacement, volatile id *objectLocation) 
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA) OBJC_ARC_UNAVAILABLE;
/* "Barrier" version also includes memory barrier. */
OBJC_EXPORT BOOL objc_atomicCompareAndSwapPtrBarrier(id predicate, id replacement, volatile id *objectLocation) 
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA) OBJC_ARC_UNAVAILABLE;

// atomic update of a global variable
OBJC_EXPORT BOOL objc_atomicCompareAndSwapGlobal(id predicate, id replacement, volatile id *objectLocation)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA) OBJC_ARC_UNAVAILABLE;
OBJC_EXPORT BOOL objc_atomicCompareAndSwapGlobalBarrier(id predicate, id replacement, volatile id *objectLocation)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA) OBJC_ARC_UNAVAILABLE;
// atomic update of an instance variable
OBJC_EXPORT BOOL objc_atomicCompareAndSwapInstanceVariable(id predicate, id replacement, volatile id *objectLocation)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA) OBJC_ARC_UNAVAILABLE;
OBJC_EXPORT BOOL objc_atomicCompareAndSwapInstanceVariableBarrier(id predicate, id replacement, volatile id *objectLocation)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA) OBJC_ARC_UNAVAILABLE;


// 
// Read and write barriers
// 

OBJC_EXPORT id objc_assign_strongCast(id val, id *dest)
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_NA);
OBJC_EXPORT id objc_assign_global(id val, id *dest)
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_NA);
OBJC_EXPORT id objc_assign_threadlocal(id val, id *dest)
    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);
OBJC_EXPORT id objc_assign_ivar(id value, id dest, ptrdiff_t offset)
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_NA);
OBJC_EXPORT void *objc_memmove_collectable(void *dst, const void *src, size_t size)
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_NA);

OBJC_EXPORT id objc_read_weak(id *location)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);
OBJC_EXPORT id objc_assign_weak(id value, id *location)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);


//
// Thread management
// 

/* Register the calling thread with the garbage collector. */
OBJC_EXPORT void objc_registerThreadWithCollector(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/* Unregisters the calling thread with the garbage collector. 
   Unregistration also happens automatically at thread exit. */
OBJC_EXPORT void objc_unregisterThreadWithCollector(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/* To be called from code which must only execute on a registered thread. */
/* If the calling thread is unregistered then an error message is emitted and the thread is implicitly registered. */
OBJC_EXPORT void objc_assertRegisteredThreadWithCollector(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/* Erases any stale references in unused parts of the stack. */
OBJC_EXPORT void objc_clear_stack(unsigned long options)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);


//
// Finalization
// 

/* Returns true if object has been scheduled for finalization.  Can be used to avoid operations that may lead to resurrection, which are fatal. */
OBJC_EXPORT BOOL objc_is_finalized(void *ptr)
    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_NA);

// Deprcated. Tells runtime to issue finalize calls on the main thread only.
OBJC_EXPORT void objc_finalizeOnMainThread(Class cls)
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_NA,__IPHONE_NA);


//
// Deprecated names. 
//

/* Deprecated. Use objc_collectingEnabled() instead. */
OBJC_EXPORT BOOL objc_collecting_enabled(void)
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_5, __IPHONE_NA,__IPHONE_NA);
/* Deprecated. Use objc_setCollectionThreshold() instead. */
OBJC_EXPORT void objc_set_collection_threshold(size_t threshold)
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_5, __IPHONE_NA,__IPHONE_NA);
/* Deprecated. Use objc_setCollectionRatio() instead. */
OBJC_EXPORT void objc_set_collection_ratio(size_t ratio)
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_5, __IPHONE_NA,__IPHONE_NA);
/* Deprecated. Use objc_startCollectorThread() instead. */
OBJC_EXPORT void objc_start_collector_thread(void)
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_5, __IPHONE_NA,__IPHONE_NA);
/* Deprecated. No replacement. Formerly told the collector to run using a dedicated background thread. */
OBJC_EXPORT void objc_startCollectorThread(void)
__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7, __IPHONE_NA,__IPHONE_NA);


/* Deprecated. Use class_createInstance() instead. */
OBJC_EXPORT id objc_allocate_object(Class cls, int extra)
__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_4, __IPHONE_NA,__IPHONE_NA);


/* !defined(OBJC_NO_GC) */
#else
/* defined(OBJC_NO_GC) */


/* Non-GC declarations */

static OBJC_INLINE void objc_collect(unsigned long options __unused) { }
static OBJC_INLINE BOOL objc_collectingEnabled(void) { return NO; }
#if TARGET_OS_MAC  &&  !TARGET_OS_EMBEDDED  &&  !TARGET_IPHONE_SIMULATOR
static OBJC_INLINE malloc_zone_t *objc_collectableZone(void) { return nil; }
#endif
static OBJC_INLINE void objc_setCollectionThreshold(size_t threshold __unused) { }
static OBJC_INLINE void objc_setCollectionRatio(size_t ratio __unused) { }
static OBJC_INLINE void objc_startCollectorThread(void) { }

#if __has_feature(objc_arc)

/* Covers for GC memory operations are unavailable in ARC */

#else

#if TARGET_OS_WIN32
static OBJC_INLINE BOOL objc_atomicCompareAndSwapPtr(id predicate, id replacement, volatile id *objectLocation) 
    { void *original = InterlockedCompareExchangePointer((void * volatile *)objectLocation, (void *)replacement, (void *)predicate); return (original == predicate); }

static OBJC_INLINE BOOL objc_atomicCompareAndSwapPtrBarrier(id predicate, id replacement, volatile id *objectLocation) 
    { void *original = InterlockedCompareExchangePointer((void * volatile *)objectLocation, (void *)replacement, (void *)predicate); return (original == predicate); }
#else
static OBJC_INLINE BOOL objc_atomicCompareAndSwapPtr(id predicate, id replacement, volatile id *objectLocation) 
    { return OSAtomicCompareAndSwapPtr((void *)predicate, (void *)replacement, (void * volatile *)objectLocation); }

static OBJC_INLINE BOOL objc_atomicCompareAndSwapPtrBarrier(id predicate, id replacement, volatile id *objectLocation) 
    { return OSAtomicCompareAndSwapPtrBarrier((void *)predicate, (void *)replacement, (void * volatile *)objectLocation); }
#endif

static OBJC_INLINE BOOL objc_atomicCompareAndSwapGlobal(id predicate, id replacement, volatile id *objectLocation) 
    { return objc_atomicCompareAndSwapPtr(predicate, replacement, objectLocation); }

static OBJC_INLINE BOOL objc_atomicCompareAndSwapGlobalBarrier(id predicate, id replacement, volatile id *objectLocation) 
    { return objc_atomicCompareAndSwapPtrBarrier(predicate, replacement, objectLocation); }

static OBJC_INLINE BOOL objc_atomicCompareAndSwapInstanceVariable(id predicate, id replacement, volatile id *objectLocation) 
    { return objc_atomicCompareAndSwapPtr(predicate, replacement, objectLocation); }

static OBJC_INLINE BOOL objc_atomicCompareAndSwapInstanceVariableBarrier(id predicate, id replacement, volatile id *objectLocation) 
    { return objc_atomicCompareAndSwapPtrBarrier(predicate, replacement, objectLocation); }


static OBJC_INLINE id objc_assign_strongCast(id val, id *dest) 
    { return (*dest = val); }

static OBJC_INLINE id objc_assign_global(id val, id *dest) 
    { return (*dest = val); }

static OBJC_INLINE id objc_assign_threadlocal(id val, id *dest) 
    { return (*dest = val); }

static OBJC_INLINE id objc_assign_ivar(id val, id dest, ptrdiff_t offset) 
    { return (*(id*)((char *)dest+offset) = val); }

static OBJC_INLINE id objc_read_weak(id *location) 
    { return *location; }

static OBJC_INLINE id objc_assign_weak(id value, id *location) 
    { return (*location = value); }

/* MRC */
#endif

static OBJC_INLINE void *objc_memmove_collectable(void *dst, const void *src, size_t size) 
    { return memmove(dst, src, size); }

static OBJC_INLINE void objc_finalizeOnMainThread(Class cls __unused) { }
static OBJC_INLINE BOOL objc_is_finalized(void *ptr __unused) { return NO; }
static OBJC_INLINE void objc_clear_stack(unsigned long options __unused) { }

static OBJC_INLINE BOOL objc_collecting_enabled(void) { return NO; }
static OBJC_INLINE void objc_set_collection_threshold(size_t threshold __unused) { } 
static OBJC_INLINE void objc_set_collection_ratio(size_t ratio __unused) { } 
static OBJC_INLINE void objc_start_collector_thread(void) { }

#if __has_feature(objc_arc)
extern id objc_allocate_object(Class cls, int extra) UNAVAILABLE_ATTRIBUTE;
#else
OBJC_EXPORT id class_createInstance(Class cls, size_t extraBytes)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
static OBJC_INLINE id objc_allocate_object(Class cls, int extra) 
    { return class_createInstance(cls, extra); }
#endif

static OBJC_INLINE void objc_registerThreadWithCollector() { }
static OBJC_INLINE void objc_unregisterThreadWithCollector() { }
static OBJC_INLINE void objc_assertRegisteredThreadWithCollector() { }

/* defined(OBJC_NO_GC) */
#endif


#if TARGET_OS_EMBEDDED
enum {
    OBJC_GENERATIONAL = (1 << 0)
};
static OBJC_INLINE void objc_collect_if_needed(unsigned long options) __attribute__((deprecated));
static OBJC_INLINE void objc_collect_if_needed(unsigned long options __unused) { }
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-class.h                                   0100644 0001750 0001750 00000000064 12566174466 022707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <objc/runtime.h>
#include <objc/message.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-exception.h                               0100644 0001750 0001750 00000010061 12566174466 023576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2002-2003, 2006-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __OBJC_EXCEPTION_H_
#define __OBJC_EXCEPTION_H_

#include <objc/objc.h>
#include <stdint.h>

#if !__OBJC2__

// compiler reserves a setjmp buffer + 4 words as localExceptionData

OBJC_EXPORT void objc_exception_throw(id exception)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);
OBJC_EXPORT void objc_exception_try_enter(void *localExceptionData)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);
OBJC_EXPORT void objc_exception_try_exit(void *localExceptionData)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);
OBJC_EXPORT id objc_exception_extract(void *localExceptionData)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);
OBJC_EXPORT int objc_exception_match(Class exceptionClass, id exception)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);


typedef struct {
    int version;
    void (*throw_exc)(id);		// version 0
    void (*try_enter)(void *);	// version 0
    void (*try_exit)(void *);	// version 0
    id	 (*extract)(void *);	// version 0
    int	(*match)(Class, id);	// version 0
} objc_exception_functions_t;

// get table; version tells how many
OBJC_EXPORT void objc_exception_get_functions(objc_exception_functions_t *table)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);

// set table
OBJC_EXPORT void objc_exception_set_functions(objc_exception_functions_t *table)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA);


// !__OBJC2__
#else
// __OBJC2__

typedef id (*objc_exception_preprocessor)(id exception);
typedef int (*objc_exception_matcher)(Class catch_type, id exception);
typedef void (*objc_uncaught_exception_handler)(id exception);
typedef void (*objc_exception_handler)(id unused, void *context);

/** 
 * Throw a runtime exception. This function is inserted by the compiler
 * where \c @throw would otherwise be.
 * 
 * @param exception The exception to be thrown.
 */
OBJC_EXPORT void objc_exception_throw(id exception)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT void objc_exception_rethrow(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT id objc_begin_catch(void *exc_buf)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT void objc_end_catch(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT void objc_terminate(void)
    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);

OBJC_EXPORT objc_exception_preprocessor objc_setExceptionPreprocessor(objc_exception_preprocessor fn)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT objc_exception_matcher objc_setExceptionMatcher(objc_exception_matcher fn)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

// Not for iOS.
OBJC_EXPORT uintptr_t objc_addExceptionHandler(objc_exception_handler fn, void *context)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);
OBJC_EXPORT void objc_removeExceptionHandler(uintptr_t token)
    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);

// __OBJC2__
#endif

#endif  // __OBJC_EXCEPTION_H_

                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-load.h                                    0100644 0001750 0001750 00000003351 12566174466 022523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2001, 2005-2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *	objc-load.h
 *	Copyright 1988-1996, NeXT Software, Inc.
 */

#ifndef _OBJC_LOAD_H_
#define _OBJC_LOAD_H_

#include <objc/objc-class.h>

#include <mach-o/loader.h>

/* dynamically loading Mach-O object files that contain Objective-C code */

OBJC_EXPORT long objc_loadModules (
	char *modlist[], 
	void *errStream,
	void (*class_callback) (Class, Category),
	/*headerType*/ struct mach_header **hdr_addr,
	char *debug_file
) OBJC2_UNAVAILABLE;
OBJC_EXPORT int objc_loadModule (
	char *	moduleName, 
	void	(*class_callback) (Class, Category),
	int *	errorCode
) OBJC2_UNAVAILABLE;
OBJC_EXPORT long objc_unloadModules(
	void *errorStream,				/* input (optional) */
	void (*unloadCallback)(Class, Category)		/* input (optional) */
) OBJC2_UNAVAILABLE;

#endif /* _OBJC_LOAD_H_ */
                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-runtime.h                                 0100644 0001750 0001750 00000000064 12566174466 023265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <objc/runtime.h>
#include <objc/message.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc-sync.h                                    0100644 0001750 0001750 00000004157 12566174466 022565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2002, 2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __OBJC_SNYC_H_
#define __OBJC_SNYC_H_

#include <objc/objc.h>


/** 
 * Begin synchronizing on 'obj'.  
 * Allocates recursive pthread_mutex associated with 'obj' if needed.
 * 
 * @param obj The object to begin synchronizing on.
 * 
 * @return OBJC_SYNC_SUCCESS once lock is acquired.  
 */
OBJC_EXPORT  int objc_sync_enter(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_2_0);

/** 
 * End synchronizing on 'obj'. 
 * 
 * @param obj The objet to end synchronizing on.
 * 
 * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR
 */
OBJC_EXPORT  int objc_sync_exit(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_2_0);

// The wait/notify functions have never worked correctly and no longer exist.
OBJC_EXPORT  int objc_sync_wait(id obj, long long milliSecondsMaxWait) 
    UNAVAILABLE_ATTRIBUTE;
OBJC_EXPORT  int objc_sync_notify(id obj) 
    UNAVAILABLE_ATTRIBUTE;
OBJC_EXPORT  int objc_sync_notifyAll(id obj) 
    UNAVAILABLE_ATTRIBUTE;

enum {
	OBJC_SYNC_SUCCESS                 = 0,
	OBJC_SYNC_NOT_OWNING_THREAD_ERROR = -1,
	OBJC_SYNC_TIMED_OUT               = -2,
	OBJC_SYNC_NOT_INITIALIZED         = -3		
};


#endif // __OBJC_SNYC_H_
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/objc.h                                         0100644 0001750 0001750 00000016362 12566174466 021614  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *	objc.h
 *	Copyright 1988-1996, NeXT Software, Inc.
 */

#ifndef _OBJC_OBJC_H_
#define _OBJC_OBJC_H_

#include <sys/types.h>      // for __DARWIN_NULL
#include <Availability.h>
#include <objc/objc-api.h>
#include <stdbool.h>

#if !OBJC_TYPES_DEFINED
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;

/// Represents an instance of a class.
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
#endif

/// An opaque type that represents a method selector.
typedef struct objc_selector *SEL;

/// A pointer to the function of a method implementation. 
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ ); 
#else
typedef id (*IMP)(id, SEL, ...); 
#endif

#define OBJC_BOOL_DEFINED

/// Type to represent a boolean value.
#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH
#define OBJC_BOOL_IS_BOOL 1
typedef bool BOOL;
#else
#define OBJC_BOOL_IS_CHAR 1
typedef signed char BOOL; 
// BOOL is explicitly signed so @encode(BOOL) == "c" rather than "C" 
// even if -funsigned-char is used.
#endif

#if __has_feature(objc_bool)
#define YES __objc_yes
#define NO  __objc_no
#else
#define YES ((BOOL)1)
#define NO  ((BOOL)0)
#endif

#ifndef Nil
# if __has_feature(cxx_nullptr)
#   define Nil nullptr
# else
#   define Nil __DARWIN_NULL
# endif
#endif

#ifndef nil
# if __has_feature(cxx_nullptr)
#   define nil nullptr
# else
#   define nil __DARWIN_NULL
# endif
#endif

#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
#define __strong /* empty */
#endif

#if !__has_feature(objc_arc)
#define __unsafe_unretained /* empty */
#define __autoreleasing /* empty */
#endif


/** 
 * Returns the name of the method specified by a given selector.
 * 
 * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
 * 
 * @return A C string indicating the name of the selector.
 */
OBJC_EXPORT const char *sel_getName(SEL sel)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Registers a method with the Objective-C runtime system, maps the method 
 * name to a selector, and returns the selector value.
 * 
 * @param str A pointer to a C string. Pass the name of the method you wish to register.
 * 
 * @return A pointer of type SEL specifying the selector for the named method.
 * 
 * @note You must register a method name with the Objective-C runtime system to obtain the
 *  method’s selector before you can add the method to a class definition. If the method name
 *  has already been registered, this function simply returns the selector.
 */
OBJC_EXPORT SEL sel_registerName(const char *str)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the class name of a given object.
 * 
 * @param obj An Objective-C object.
 * 
 * @return The name of the class of which \e obj is an instance.
 */
OBJC_EXPORT const char *object_getClassName(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns a pointer to any extra bytes allocated with an instance given object.
 * 
 * @param obj An Objective-C object.
 * 
 * @return A pointer to any extra bytes allocated with \e obj. If \e obj was
 *   not allocated with any extra bytes, then dereferencing the returned pointer is undefined.
 * 
 * @note This function returns a pointer to any extra bytes allocated with the instance
 *  (as specified by \c class_createInstance with extraBytes>0). This memory follows the
 *  object's ordinary ivars, but may not be adjacent to the last ivar.
 * @note The returned pointer is guaranteed to be pointer-size aligned, even if the area following
 *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
 *  guaranteed, even if the area following the object's last ivar is more aligned than that.
 * @note In a garbage-collected environment, the memory is scanned conservatively.
 */
OBJC_EXPORT void *object_getIndexedIvars(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Identifies a selector as being valid or invalid.
 * 
 * @param sel The selector you want to identify.
 * 
 * @return YES if selector is valid and has a function implementation, NO otherwise. 
 * 
 * @warning On some platforms, an invalid reference (to invalid memory addresses) can cause
 *  a crash. 
 */
OBJC_EXPORT BOOL sel_isMapped(SEL sel)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Registers a method name with the Objective-C runtime system.
 * 
 * @param str A pointer to a C string. Pass the name of the method you wish to register.
 * 
 * @return A pointer of type SEL specifying the selector for the named method.
 * 
 * @note The implementation of this method is identical to the implementation of \c sel_registerName.
 * @note Prior to OS X version 10.0, this method tried to find the selector mapped to the given name
 *  and returned \c NULL if the selector was not found. This was changed for safety, because it was
 *  observed that many of the callers of this function did not check the return value for \c NULL.
 */
OBJC_EXPORT SEL sel_getUid(const char *str)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);


// Obsolete ARC conversions. Deprecation forthcoming.
// Use CFBridgingRetain, CFBridgingRelease, and __bridge casts instead.

typedef const void* objc_objectptr_t;

#if __has_feature(objc_arc)
#   define objc_retainedObject(o) ((__bridge_transfer id)(objc_objectptr_t)(o))
#   define objc_unretainedObject(o) ((__bridge id)(objc_objectptr_t)(o))
#   define objc_unretainedPointer(o) ((__bridge objc_objectptr_t)(id)(o))
#else
#   define objc_retainedObject(o) ((id)(objc_objectptr_t)(o))
#   define objc_unretainedObject(o) ((id)(objc_objectptr_t)(o))
#   define objc_unretainedPointer(o) ((objc_objectptr_t)(id)(o))
#endif


#if !__OBJC2__

// The following declarations are provided here for source compatibility.

#if defined(__LP64__)
    typedef long arith_t;
    typedef unsigned long uarith_t;
#   define ARITH_SHIFT 32
#else
    typedef int arith_t;
    typedef unsigned uarith_t;
#   define ARITH_SHIFT 16
#endif

typedef char *STR;

#define ISSELECTOR(sel) sel_isMapped(sel)
#define SELNAME(sel)	sel_getName(sel)
#define SELUID(str)	sel_getUid(str)
#define NAMEOF(obj)     object_getClassName(obj)
#define IV(obj)         object_getIndexedIvars(obj)

#endif

#endif  /* _OBJC_OBJC_H_ */
                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/include/objc/runtime.h                                      0100644 0001750 0001750 00000211252 12566174466 022355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2007 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _OBJC_RUNTIME_H
#define _OBJC_RUNTIME_H

#include <objc/objc.h>
#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>
#include <Availability.h>
#include <TargetConditionals.h>

#if TARGET_OS_MAC
#include <sys/types.h>
#endif


/* Types */

#if !OBJC_TYPES_DEFINED

/// An opaque type that represents a method in a class definition.
typedef struct objc_method *Method;

/// An opaque type that represents an instance variable.
typedef struct objc_ivar *Ivar;

/// An opaque type that represents a category.
typedef struct objc_category *Category;

/// An opaque type that represents an Objective-C declared property.
typedef struct objc_property *objc_property_t;

struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */

#endif

#ifdef __OBJC__
@class Protocol;
#else
typedef struct objc_object Protocol;
#endif

/// Defines a method
struct objc_method_description {
	SEL name;               /**< The name of the method */
	char *types;            /**< The types of the method arguments */
};

/// Defines a property attribute
typedef struct {
    const char *name;           /**< The name of the attribute */
    const char *value;          /**< The value of the attribute (usually empty) */
} objc_property_attribute_t;


/* Functions */

/* Working with Instances */

/** 
 * Returns a copy of a given object.
 * 
 * @param obj An Objective-C object.
 * @param size The size of the object \e obj.
 * 
 * @return A copy of \e obj.
 */
OBJC_EXPORT id object_copy(id obj, size_t size)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARC_UNAVAILABLE;

/** 
 * Frees the memory occupied by a given object.
 * 
 * @param obj An Objective-C object.
 * 
 * @return nil
 */
OBJC_EXPORT id object_dispose(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARC_UNAVAILABLE;

/** 
 * Returns the class of an object.
 * 
 * @param obj The object you want to inspect.
 * 
 * @return The class object of which \e object is an instance, 
 *  or \c Nil if \e object is \c nil.
 */
OBJC_EXPORT Class object_getClass(id obj) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Sets the class of an object.
 * 
 * @param obj The object to modify.
 * @param cls A class object.
 * 
 * @return The previous value of \e object's class, or \c Nil if \e object is \c nil.
 */
OBJC_EXPORT Class object_setClass(id obj, Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);


/** 
 * Returns whether an object is a class object.
 * 
 * @param obj An Objective-C object.
 * 
 * @return true if the object is a class or metaclass, false otherwise.
 */
OBJC_EXPORT BOOL object_isClass(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0);


/** 
 * Returns the class name of a given object.
 * 
 * @param obj An Objective-C object.
 * 
 * @return The name of the class of which \e obj is an instance.
 */
OBJC_EXPORT const char *object_getClassName(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns a pointer to any extra bytes allocated with an instance given object.
 * 
 * @param obj An Objective-C object.
 * 
 * @return A pointer to any extra bytes allocated with \e obj. If \e obj was
 *   not allocated with any extra bytes, then dereferencing the returned pointer is undefined.
 * 
 * @note This function returns a pointer to any extra bytes allocated with the instance
 *  (as specified by \c class_createInstance with extraBytes>0). This memory follows the
 *  object's ordinary ivars, but may not be adjacent to the last ivar.
 * @note The returned pointer is guaranteed to be pointer-size aligned, even if the area following
 *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
 *  guaranteed, even if the area following the object's last ivar is more aligned than that.
 * @note In a garbage-collected environment, the memory is scanned conservatively.
 */
OBJC_EXPORT void *object_getIndexedIvars(id obj)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARC_UNAVAILABLE;

/** 
 * Reads the value of an instance variable in an object.
 * 
 * @param obj The object containing the instance variable whose value you want to read.
 * @param ivar The Ivar describing the instance variable whose value you want to read.
 * 
 * @return The value of the instance variable specified by \e ivar, or \c nil if \e object is \c nil.
 * 
 * @note \c object_getIvar is faster than \c object_getInstanceVariable if the Ivar
 *  for the instance variable is already known.
 */
OBJC_EXPORT id object_getIvar(id obj, Ivar ivar) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Sets the value of an instance variable in an object.
 * 
 * @param obj The object containing the instance variable whose value you want to set.
 * @param ivar The Ivar describing the instance variable whose value you want to set.
 * @param value The new value for the instance variable.
 * 
 * @note \c object_setIvar is faster than \c object_setInstanceVariable if the Ivar
 *  for the instance variable is already known.
 */
OBJC_EXPORT void object_setIvar(id obj, Ivar ivar, id value) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Changes the value of an instance variable of a class instance.
 * 
 * @param obj A pointer to an instance of a class. Pass the object containing
 *  the instance variable whose value you wish to modify.
 * @param name A C string. Pass the name of the instance variable whose value you wish to modify.
 * @param value The new value for the instance variable.
 * 
 * @return A pointer to the \c Ivar data structure that defines the type and 
 *  name of the instance variable specified by \e name.
 */
OBJC_EXPORT Ivar object_setInstanceVariable(id obj, const char *name, void *value)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARC_UNAVAILABLE;

/** 
 * Obtains the value of an instance variable of a class instance.
 * 
 * @param obj A pointer to an instance of a class. Pass the object containing
 *  the instance variable whose value you wish to obtain.
 * @param name A C string. Pass the name of the instance variable whose value you wish to obtain.
 * @param outValue On return, contains a pointer to the value of the instance variable.
 * 
 * @return A pointer to the \c Ivar data structure that defines the type and name of
 *  the instance variable specified by \e name.
 */
OBJC_EXPORT Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARC_UNAVAILABLE;


/* Obtaining Class Definitions */

/** 
 * Returns the class definition of a specified class.
 * 
 * @param name The name of the class to look up.
 * 
 * @return The Class object for the named class, or \c nil
 *  if the class is not registered with the Objective-C runtime.
 * 
 * @note \c objc_getClass is different from \c objc_lookUpClass in that if the class
 *  is not registered, \c objc_getClass calls the class handler callback and then checks
 *  a second time to see whether the class is registered. \c objc_lookUpClass does 
 *  not call the class handler callback.
 * 
 * @warning Earlier implementations of this function (prior to OS X v10.0)
 *  terminate the program if the class does not exist.
 */
OBJC_EXPORT Class objc_getClass(const char *name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the metaclass definition of a specified class.
 * 
 * @param name The name of the class to look up.
 * 
 * @return The \c Class object for the metaclass of the named class, or \c nil if the class
 *  is not registered with the Objective-C runtime.
 * 
 * @note If the definition for the named class is not registered, this function calls the class handler
 *  callback and then checks a second time to see if the class is registered. However, every class
 *  definition must have a valid metaclass definition, and so the metaclass definition is always returned,
 *  whether it’s valid or not.
 */
OBJC_EXPORT Class objc_getMetaClass(const char *name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the class definition of a specified class.
 * 
 * @param name The name of the class to look up.
 * 
 * @return The Class object for the named class, or \c nil if the class
 *  is not registered with the Objective-C runtime.
 * 
 * @note \c objc_getClass is different from this function in that if the class is not
 *  registered, \c objc_getClass calls the class handler callback and then checks a second
 *  time to see whether the class is registered. This function does not call the class handler callback.
 */
OBJC_EXPORT Class objc_lookUpClass(const char *name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the class definition of a specified class.
 * 
 * @param name The name of the class to look up.
 * 
 * @return The Class object for the named class.
 * 
 * @note This function is the same as \c objc_getClass, but kills the process if the class is not found.
 * @note This function is used by ZeroLink, where failing to find a class would be a compile-time link error without ZeroLink.
 */
OBJC_EXPORT Class objc_getRequiredClass(const char *name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Obtains the list of registered class definitions.
 * 
 * @param buffer An array of \c Class values. On output, each \c Class value points to
 *  one class definition, up to either \e bufferCount or the total number of registered classes,
 *  whichever is less. You can pass \c NULL to obtain the total number of registered class
 *  definitions without actually retrieving any class definitions.
 * @param bufferCount An integer value. Pass the number of pointers for which you have allocated space
 *  in \e buffer. On return, this function fills in only this number of elements. If this number is less
 *  than the number of registered classes, this function returns an arbitrary subset of the registered classes.
 * 
 * @return An integer value indicating the total number of registered classes.
 * 
 * @note The Objective-C runtime library automatically registers all the classes defined in your source code.
 *  You can create class definitions at runtime and register them with the \c objc_addClass function.
 * 
 * @warning You cannot assume that class objects you get from this function are classes that inherit from \c NSObject,
 *  so you cannot safely call any methods on such classes without detecting that the method is implemented first.
 */
OBJC_EXPORT int objc_getClassList(Class *buffer, int bufferCount)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Creates and returns a list of pointers to all registered class definitions.
 * 
 * @param outCount An integer pointer used to store the number of classes returned by
 *  this function in the list. It can be \c nil.
 * 
 * @return A nil terminated array of classes. It must be freed with \c free().
 * 
 * @see objc_getClassList
 */
OBJC_EXPORT Class *objc_copyClassList(unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_3_1);


/* Working with Classes */

/** 
 * Returns the name of a class.
 * 
 * @param cls A class object.
 * 
 * @return The name of the class, or the empty string if \e cls is \c Nil.
 */
OBJC_EXPORT const char *class_getName(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a Boolean value that indicates whether a class object is a metaclass.
 * 
 * @param cls A class object.
 * 
 * @return \c YES if \e cls is a metaclass, \c NO if \e cls is a non-meta class, 
 *  \c NO if \e cls is \c Nil.
 */
OBJC_EXPORT BOOL class_isMetaClass(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the superclass of a class.
 * 
 * @param cls A class object.
 * 
 * @return The superclass of the class, or \c Nil if
 *  \e cls is a root class, or \c Nil if \e cls is \c Nil.
 *
 * @note You should usually use \c NSObject's \c superclass method instead of this function.
 */
OBJC_EXPORT Class class_getSuperclass(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Sets the superclass of a given class.
 * 
 * @param cls The class whose superclass you want to set.
 * @param newSuper The new superclass for cls.
 * 
 * @return The old superclass for cls.
 * 
 * @warning You should not use this function.
 */
OBJC_EXPORT Class class_setSuperclass(Class cls, Class newSuper) 
     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);

/** 
 * Returns the version number of a class definition.
 * 
 * @param cls A pointer to a \c Class data structure. Pass
 *  the class definition for which you wish to obtain the version.
 * 
 * @return An integer indicating the version number of the class definition.
 *
 * @see class_setVersion
 */
OBJC_EXPORT int class_getVersion(Class cls)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Sets the version number of a class definition.
 * 
 * @param cls A pointer to an Class data structure. 
 *  Pass the class definition for which you wish to set the version.
 * @param version An integer. Pass the new version number of the class definition.
 *
 * @note You can use the version number of the class definition to provide versioning of the
 *  interface that your class represents to other classes. This is especially useful for object
 *  serialization (that is, archiving of the object in a flattened form), where it is important to
 *  recognize changes to the layout of the instance variables in different class-definition versions.
 * @note Classes derived from the Foundation framework \c NSObject class can set the class-definition
 *  version number using the \c setVersion: class method, which is implemented using the \c class_setVersion function.
 */
OBJC_EXPORT void class_setVersion(Class cls, int version)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the size of instances of a class.
 * 
 * @param cls A class object.
 * 
 * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.
 */
OBJC_EXPORT size_t class_getInstanceSize(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the \c Ivar for a specified instance variable of a given class.
 * 
 * @param cls The class whose instance variable you wish to obtain.
 * @param name The name of the instance variable definition to obtain.
 * 
 * @return A pointer to an \c Ivar data structure containing information about 
 *  the instance variable specified by \e name.
 */
OBJC_EXPORT Ivar class_getInstanceVariable(Class cls, const char *name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the Ivar for a specified class variable of a given class.
 * 
 * @param cls The class definition whose class variable you wish to obtain.
 * @param name The name of the class variable definition to obtain.
 * 
 * @return A pointer to an \c Ivar data structure containing information about the class variable specified by \e name.
 */
OBJC_EXPORT Ivar class_getClassVariable(Class cls, const char *name) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Describes the instance variables declared by a class.
 * 
 * @param cls The class to inspect.
 * @param outCount On return, contains the length of the returned array. 
 *  If outCount is NULL, the length is not returned.
 * 
 * @return An array of pointers of type Ivar describing the instance variables declared by the class. 
 *  Any instance variables declared by superclasses are not included. The array contains *outCount 
 *  pointers followed by a NULL terminator. You must free the array with free().
 * 
 *  If the class declares no instance variables, or cls is Nil, NULL is returned and *outCount is 0.
 */
OBJC_EXPORT Ivar *class_copyIvarList(Class cls, unsigned int *outCount) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a specified instance method for a given class.
 * 
 * @param cls The class you want to inspect.
 * @param name The selector of the method you want to retrieve.
 * 
 * @return The method that corresponds to the implementation of the selector specified by 
 *  \e name for the class specified by \e cls, or \c NULL if the specified class or its 
 *  superclasses do not contain an instance method with the specified selector.
 *
 * @note This function searches superclasses for implementations, whereas \c class_copyMethodList does not.
 */
OBJC_EXPORT Method class_getInstanceMethod(Class cls, SEL name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns a pointer to the data structure describing a given class method for a given class.
 * 
 * @param cls A pointer to a class definition. Pass the class that contains the method you want to retrieve.
 * @param name A pointer of type \c SEL. Pass the selector of the method you want to retrieve.
 * 
 * @return A pointer to the \c Method data structure that corresponds to the implementation of the 
 *  selector specified by aSelector for the class specified by aClass, or NULL if the specified 
 *  class or its superclasses do not contain an instance method with the specified selector.
 *
 * @note Note that this function searches superclasses for implementations, 
 *  whereas \c class_copyMethodList does not.
 */
OBJC_EXPORT Method class_getClassMethod(Class cls, SEL name)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns the function pointer that would be called if a 
 * particular message were sent to an instance of a class.
 * 
 * @param cls The class you want to inspect.
 * @param name A selector.
 * 
 * @return The function pointer that would be called if \c [object name] were called
 *  with an instance of the class, or \c NULL if \e cls is \c Nil.
 *
 * @note \c class_getMethodImplementation may be faster than \c method_getImplementation(class_getInstanceMethod(cls, name)).
 * @note The function pointer returned may be a function internal to the runtime instead of
 *  an actual method implementation. For example, if instances of the class do not respond to
 *  the selector, the function pointer returned will be part of the runtime's message forwarding machinery.
 */
OBJC_EXPORT IMP class_getMethodImplementation(Class cls, SEL name) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the function pointer that would be called if a particular 
 * message were sent to an instance of a class.
 * 
 * @param cls The class you want to inspect.
 * @param name A selector.
 * 
 * @return The function pointer that would be called if \c [object name] were called
 *  with an instance of the class, or \c NULL if \e cls is \c Nil.
 */
OBJC_EXPORT IMP class_getMethodImplementation_stret(Class cls, SEL name) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0)
     OBJC_ARM64_UNAVAILABLE;

/** 
 * Returns a Boolean value that indicates whether instances of a class respond to a particular selector.
 * 
 * @param cls The class you want to inspect.
 * @param sel A selector.
 * 
 * @return \c YES if instances of the class respond to the selector, otherwise \c NO.
 * 
 * @note You should usually use \c NSObject's \c respondsToSelector: or \c instancesRespondToSelector: 
 *  methods instead of this function.
 */
OBJC_EXPORT BOOL class_respondsToSelector(Class cls, SEL sel) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Describes the instance methods implemented by a class.
 * 
 * @param cls The class you want to inspect.
 * @param outCount On return, contains the length of the returned array. 
 *  If outCount is NULL, the length is not returned.
 * 
 * @return An array of pointers of type Method describing the instance methods 
 *  implemented by the class—any instance methods implemented by superclasses are not included. 
 *  The array contains *outCount pointers followed by a NULL terminator. You must free the array with free().
 * 
 *  If cls implements no instance methods, or cls is Nil, returns NULL and *outCount is 0.
 * 
 * @note To get the class methods of a class, use \c class_copyMethodList(object_getClass(cls), &count).
 * @note To get the implementations of methods that may be implemented by superclasses, 
 *  use \c class_getInstanceMethod or \c class_getClassMethod.
 */
OBJC_EXPORT Method *class_copyMethodList(Class cls, unsigned int *outCount) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a Boolean value that indicates whether a class conforms to a given protocol.
 * 
 * @param cls The class you want to inspect.
 * @param protocol A protocol.
 *
 * @return YES if cls conforms to protocol, otherwise NO.
 *
 * @note You should usually use NSObject's conformsToProtocol: method instead of this function.
 */
OBJC_EXPORT BOOL class_conformsToProtocol(Class cls, Protocol *protocol) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Describes the protocols adopted by a class.
 * 
 * @param cls The class you want to inspect.
 * @param outCount On return, contains the length of the returned array. 
 *  If outCount is NULL, the length is not returned.
 * 
 * @return An array of pointers of type Protocol* describing the protocols adopted 
 *  by the class. Any protocols adopted by superclasses or other protocols are not included. 
 *  The array contains *outCount pointers followed by a NULL terminator. You must free the array with free().
 * 
 *  If cls adopts no protocols, or cls is Nil, returns NULL and *outCount is 0.
 */
OBJC_EXPORT Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a property with a given name of a given class.
 * 
 * @param cls The class you want to inspect.
 * @param name The name of the property you want to inspect.
 * 
 * @return A pointer of type \c objc_property_t describing the property, or
 *  \c NULL if the class does not declare a property with that name, 
 *  or \c NULL if \e cls is \c Nil.
 */
OBJC_EXPORT objc_property_t class_getProperty(Class cls, const char *name)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Describes the properties declared by a class.
 * 
 * @param cls The class you want to inspect.
 * @param outCount On return, contains the length of the returned array. 
 *  If \e outCount is \c NULL, the length is not returned.        
 * 
 * @return An array of pointers of type \c objc_property_t describing the properties 
 *  declared by the class. Any properties declared by superclasses are not included. 
 *  The array contains \c *outCount pointers followed by a \c NULL terminator. You must free the array with \c free().
 * 
 *  If \e cls declares no properties, or \e cls is \c Nil, returns \c NULL and \c *outCount is \c 0.
 */
OBJC_EXPORT objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a description of the \c Ivar layout for a given class.
 * 
 * @param cls The class to inspect.
 * 
 * @return A description of the \c Ivar layout for \e cls.
 */
OBJC_EXPORT const uint8_t *class_getIvarLayout(Class cls)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a description of the layout of weak Ivars for a given class.
 * 
 * @param cls The class to inspect.
 * 
 * @return A description of the layout of the weak \c Ivars for \e cls.
 */
OBJC_EXPORT const uint8_t *class_getWeakIvarLayout(Class cls)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Adds a new method to a class with a given name and implementation.
 * 
 * @param cls The class to which to add a method.
 * @param name A selector that specifies the name of the method being added.
 * @param imp A function which is the implementation of the new method. The function must take at least two arguments—self and _cmd.
 * @param types An array of characters that describe the types of the arguments to the method. 
 * 
 * @return YES if the method was added successfully, otherwise NO 
 *  (for example, the class already contains a method implementation with that name).
 *
 * @note class_addMethod will add an override of a superclass's implementation, 
 *  but will not replace an existing implementation in this class. 
 *  To change an existing implementation, use method_setImplementation.
 */
OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, 
                                 const char *types) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Replaces the implementation of a method for a given class.
 * 
 * @param cls The class you want to modify.
 * @param name A selector that identifies the method whose implementation you want to replace.
 * @param imp The new implementation for the method identified by name for the class identified by cls.
 * @param types An array of characters that describe the types of the arguments to the method. 
 *  Since the function must take at least two arguments—self and _cmd, the second and third characters
 *  must be “@:” (the first character is the return type).
 * 
 * @return The previous implementation of the method identified by \e name for the class identified by \e cls.
 * 
 * @note This function behaves in two different ways:
 *  - If the method identified by \e name does not yet exist, it is added as if \c class_addMethod were called. 
 *    The type encoding specified by \e types is used as given.
 *  - If the method identified by \e name does exist, its \c IMP is replaced as if \c method_setImplementation were called.
 *    The type encoding specified by \e types is ignored.
 */
OBJC_EXPORT IMP class_replaceMethod(Class cls, SEL name, IMP imp, 
                                    const char *types) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Adds a new instance variable to a class.
 * 
 * @return YES if the instance variable was added successfully, otherwise NO 
 *         (for example, the class already contains an instance variable with that name).
 *
 * @note This function may only be called after objc_allocateClassPair and before objc_registerClassPair. 
 *       Adding an instance variable to an existing class is not supported.
 * @note The class must not be a metaclass. Adding an instance variable to a metaclass is not supported.
 * @note The instance variable's minimum alignment in bytes is 1<<align. The minimum alignment of an instance 
 *       variable depends on the ivar's type and the machine architecture. 
 *       For variables of any pointer type, pass log2(sizeof(pointer_type)).
 */
OBJC_EXPORT BOOL class_addIvar(Class cls, const char *name, size_t size, 
                               uint8_t alignment, const char *types) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Adds a protocol to a class.
 * 
 * @param cls The class to modify.
 * @param protocol The protocol to add to \e cls.
 * 
 * @return \c YES if the method was added successfully, otherwise \c NO 
 *  (for example, the class already conforms to that protocol).
 */
OBJC_EXPORT BOOL class_addProtocol(Class cls, Protocol *protocol) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Adds a property to a class.
 * 
 * @param cls The class to modify.
 * @param name The name of the property.
 * @param attributes An array of property attributes.
 * @param attributeCount The number of attributes in \e attributes.
 * 
 * @return \c YES if the property was added successfully, otherwise \c NO
 *  (for example, the class already has that property).
 */
OBJC_EXPORT BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Replace a property of a class. 
 * 
 * @param cls The class to modify.
 * @param name The name of the property.
 * @param attributes An array of property attributes.
 * @param attributeCount The number of attributes in \e attributes. 
 */
OBJC_EXPORT void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Sets the Ivar layout for a given class.
 * 
 * @param cls The class to modify.
 * @param layout The layout of the \c Ivars for \e cls.
 */
OBJC_EXPORT void class_setIvarLayout(Class cls, const uint8_t *layout)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Sets the layout for weak Ivars for a given class.
 * 
 * @param cls The class to modify.
 * @param layout The layout of the weak Ivars for \e cls.
 */
OBJC_EXPORT void class_setWeakIvarLayout(Class cls, const uint8_t *layout)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Used by CoreFoundation's toll-free bridging.
 * Return the id of the named class.
 * 
 * @return The id of the named class, or an uninitialized class
 *  structure that will be used for the class when and if it does 
 *  get loaded.
 * 
 * @warning Do not call this function yourself.
 */
OBJC_EXPORT Class objc_getFutureClass(const char *name) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0)
     OBJC_ARC_UNAVAILABLE;


/* Instantiating Classes */

/** 
 * Creates an instance of a class, allocating memory for the class in the 
 * default malloc memory zone.
 * 
 * @param cls The class that you wish to allocate an instance of.
 * @param extraBytes An integer indicating the number of extra bytes to allocate. 
 *  The additional bytes can be used to store additional instance variables beyond 
 *  those defined in the class definition.
 * 
 * @return An instance of the class \e cls.
 */
OBJC_EXPORT id class_createInstance(Class cls, size_t extraBytes)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
    OBJC_ARC_UNAVAILABLE;

/** 
 * Creates an instance of a class at the specific location provided.
 * 
 * @param cls The class that you wish to allocate an instance of.
 * @param bytes The location at which to allocate an instance of \e cls.
 *  Must point to at least \c class_getInstanceSize(cls) bytes of well-aligned,
 *  zero-filled memory.
 *
 * @return \e bytes on success, \c nil otherwise. (For example, \e cls or \e bytes
 *  might be \c nil)
 *
 * @see class_createInstance
 */
OBJC_EXPORT id objc_constructInstance(Class cls, void *bytes) 
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
    OBJC_ARC_UNAVAILABLE;

/** 
 * Destroys an instance of a class without freeing memory and removes any
 * associated references this instance might have had.
 * 
 * @param obj The class instance to destroy.
 * 
 * @return \e obj. Does nothing if \e obj is nil.
 * 
 * @warning GC does not call this. If you edit this, also edit finalize.
 *
 * @note CF and other clients do call this under GC.
 */
OBJC_EXPORT void *objc_destructInstance(id obj) 
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
    OBJC_ARC_UNAVAILABLE;


/* Adding Classes */

/** 
 * Creates a new class and metaclass.
 * 
 * @param superclass The class to use as the new class's superclass, or \c Nil to create a new root class.
 * @param name The string to use as the new class's name. The string will be copied.
 * @param extraBytes The number of bytes to allocate for indexed ivars at the end of 
 *  the class and metaclass objects. This should usually be \c 0.
 * 
 * @return The new class, or Nil if the class could not be created (for example, the desired name is already in use).
 * 
 * @note You can get a pointer to the new metaclass by calling \c object_getClass(newClass).
 * @note To create a new class, start by calling \c objc_allocateClassPair. 
 *  Then set the class's attributes with functions like \c class_addMethod and \c class_addIvar.
 *  When you are done building the class, call \c objc_registerClassPair. The new class is now ready for use.
 * @note Instance methods and instance variables should be added to the class itself. 
 *  Class methods should be added to the metaclass.
 */
OBJC_EXPORT Class objc_allocateClassPair(Class superclass, const char *name, 
                                         size_t extraBytes) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Registers a class that was allocated using \c objc_allocateClassPair.
 * 
 * @param cls The class you want to register.
 */
OBJC_EXPORT void objc_registerClassPair(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Used by Foundation's Key-Value Observing.
 * 
 * @warning Do not call this function yourself.
 */
OBJC_EXPORT Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Destroy a class and its associated metaclass. 
 * 
 * @param cls The class to be destroyed. It must have been allocated with 
 *  \c objc_allocateClassPair
 * 
 * @warning Do not call if instances of this class or a subclass exist.
 */
OBJC_EXPORT void objc_disposeClassPair(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);


/* Working with Methods */

/** 
 * Returns the name of a method.
 * 
 * @param m The method to inspect.
 * 
 * @return A pointer of type SEL.
 * 
 * @note To get the method name as a C string, call \c sel_getName(method_getName(method)).
 */
OBJC_EXPORT SEL method_getName(Method m) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the implementation of a method.
 * 
 * @param m The method to inspect.
 * 
 * @return A function pointer of type IMP.
 */
OBJC_EXPORT IMP method_getImplementation(Method m) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a string describing a method's parameter and return types.
 * 
 * @param m The method to inspect.
 * 
 * @return A C string. The string may be \c NULL.
 */
OBJC_EXPORT const char *method_getTypeEncoding(Method m) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the number of arguments accepted by a method.
 * 
 * @param m A pointer to a \c Method data structure. Pass the method in question.
 * 
 * @return An integer containing the number of arguments accepted by the given method.
 */
OBJC_EXPORT unsigned int method_getNumberOfArguments(Method m)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns a string describing a method's return type.
 * 
 * @param m The method to inspect.
 * 
 * @return A C string describing the return type. You must free the string with \c free().
 */
OBJC_EXPORT char *method_copyReturnType(Method m) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a string describing a single parameter type of a method.
 * 
 * @param m The method to inspect.
 * @param index The index of the parameter to inspect.
 * 
 * @return A C string describing the type of the parameter at index \e index, or \c NULL
 *  if method has no parameter index \e index. You must free the string with \c free().
 */
OBJC_EXPORT char *method_copyArgumentType(Method m, unsigned int index) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns by reference a string describing a method's return type.
 * 
 * @param m The method you want to inquire about. 
 * @param dst The reference string to store the description.
 * @param dst_len The maximum number of characters that can be stored in \e dst.
 *
 * @note The method's return type string is copied to \e dst.
 *  \e dst is filled as if \c strncpy(dst, parameter_type, dst_len) were called.
 */
OBJC_EXPORT void method_getReturnType(Method m, char *dst, size_t dst_len) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns by reference a string describing a single parameter type of a method.
 * 
 * @param m The method you want to inquire about. 
 * @param index The index of the parameter you want to inquire about.
 * @param dst The reference string to store the description.
 * @param dst_len The maximum number of characters that can be stored in \e dst.
 * 
 * @note The parameter type string is copied to \e dst. \e dst is filled as if \c strncpy(dst, parameter_type, dst_len) 
 *  were called. If the method contains no parameter with that index, \e dst is filled as
 *  if \c strncpy(dst, "", dst_len) were called.
 */
OBJC_EXPORT void method_getArgumentType(Method m, unsigned int index, 
                                        char *dst, size_t dst_len) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
OBJC_EXPORT struct objc_method_description *method_getDescription(Method m) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Sets the implementation of a method.
 * 
 * @param m The method for which to set an implementation.
 * @param imp The implemention to set to this method.
 * 
 * @return The previous implementation of the method.
 */
OBJC_EXPORT IMP method_setImplementation(Method m, IMP imp) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Exchanges the implementations of two methods.
 * 
 * @param m1 Method to exchange with second method.
 * @param m2 Method to exchange with first method.
 * 
 * @note This is an atomic version of the following:
 *  \code 
 *  IMP imp1 = method_getImplementation(m1);
 *  IMP imp2 = method_getImplementation(m2);
 *  method_setImplementation(m1, imp2);
 *  method_setImplementation(m2, imp1);
 *  \endcode
 */
OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);


/* Working with Instance Variables */

/** 
 * Returns the name of an instance variable.
 * 
 * @param v The instance variable you want to enquire about.
 * 
 * @return A C string containing the instance variable's name.
 */
OBJC_EXPORT const char *ivar_getName(Ivar v) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the type string of an instance variable.
 * 
 * @param v The instance variable you want to enquire about.
 * 
 * @return A C string containing the instance variable's type encoding.
 *
 * @note For possible values, see Objective-C Runtime Programming Guide > Type Encodings.
 */
OBJC_EXPORT const char *ivar_getTypeEncoding(Ivar v) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the offset of an instance variable.
 * 
 * @param v The instance variable you want to enquire about.
 * 
 * @return The offset of \e v.
 * 
 * @note For instance variables of type \c id or other object types, call \c object_getIvar
 *  and \c object_setIvar instead of using this offset to access the instance variable data directly.
 */
OBJC_EXPORT ptrdiff_t ivar_getOffset(Ivar v) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);


/* Working with Properties */

/** 
 * Returns the name of a property.
 * 
 * @param property The property you want to inquire about.
 * 
 * @return A C string containing the property's name.
 */
OBJC_EXPORT const char *property_getName(objc_property_t property) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the attribute string of a property.
 * 
 * @param property A property.
 *
 * @return A C string containing the property's attributes.
 * 
 * @note The format of the attribute string is described in Declared Properties in Objective-C Runtime Programming Guide.
 */
OBJC_EXPORT const char *property_getAttributes(objc_property_t property) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns an array of property attributes for a property. 
 * 
 * @param property The property whose attributes you want copied.
 * @param outCount The number of attributes returned in the array.
 * 
 * @return An array of property attributes; must be free'd() by the caller. 
 */
OBJC_EXPORT objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Returns the value of a property attribute given the attribute name.
 * 
 * @param property The property whose attribute value you are interested in.
 * @param attributeName C string representing the attribute name.
 *
 * @return The value string of the attribute \e attributeName if it exists in
 *  \e property, \c nil otherwise. 
 */
OBJC_EXPORT char *property_copyAttributeValue(objc_property_t property, const char *attributeName)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);


/* Working with Protocols */

/** 
 * Returns a specified protocol.
 * 
 * @param name The name of a protocol.
 * 
 * @return The protocol named \e name, or \c NULL if no protocol named \e name could be found.
 * 
 * @note This function acquires the runtime lock.
 */
OBJC_EXPORT Protocol *objc_getProtocol(const char *name)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns an array of all the protocols known to the runtime.
 * 
 * @param outCount Upon return, contains the number of protocols in the returned array.
 * 
 * @return A C array of all the protocols known to the runtime. The array contains \c *outCount
 *  pointers followed by a \c NULL terminator. You must free the list with \c free().
 * 
 * @note This function acquires the runtime lock.
 */
OBJC_EXPORT Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a Boolean value that indicates whether one protocol conforms to another protocol.
 * 
 * @param proto A protocol.
 * @param other A protocol.
 * 
 * @return \c YES if \e proto conforms to \e other, otherwise \c NO.
 * 
 * @note One protocol can incorporate other protocols using the same syntax 
 *  that classes use to adopt a protocol:
 *  \code
 *  @protocol ProtocolName < protocol list >
 *  \endcode
 *  All the protocols listed between angle brackets are considered part of the ProtocolName protocol.
 */
OBJC_EXPORT BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a Boolean value that indicates whether two protocols are equal.
 * 
 * @param proto A protocol.
 * @param other A protocol.
 * 
 * @return \c YES if \e proto is the same as \e other, otherwise \c NO.
 */
OBJC_EXPORT BOOL protocol_isEqual(Protocol *proto, Protocol *other)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the name of a protocol.
 * 
 * @param p A protocol.
 * 
 * @return The name of the protocol \e p as a C string.
 */
OBJC_EXPORT const char *protocol_getName(Protocol *p)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns a method description structure for a specified method of a given protocol.
 * 
 * @param p A protocol.
 * @param aSel A selector.
 * @param isRequiredMethod A Boolean value that indicates whether aSel is a required method.
 * @param isInstanceMethod A Boolean value that indicates whether aSel is an instance method.
 * 
 * @return An \c objc_method_description structure that describes the method specified by \e aSel,
 *  \e isRequiredMethod, and \e isInstanceMethod for the protocol \e p.
 *  If the protocol does not contain the specified method, returns an \c objc_method_description structure
 *  with the value \c {NULL, \c NULL}.
 * 
 * @note This function recursively searches any protocols that this protocol conforms to.
 */
OBJC_EXPORT struct objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns an array of method descriptions of methods meeting a given specification for a given protocol.
 * 
 * @param p A protocol.
 * @param isRequiredMethod A Boolean value that indicates whether returned methods should
 *  be required methods (pass YES to specify required methods).
 * @param isInstanceMethod A Boolean value that indicates whether returned methods should
 *  be instance methods (pass YES to specify instance methods).
 * @param outCount Upon return, contains the number of method description structures in the returned array.
 * 
 * @return A C array of \c objc_method_description structures containing the names and types of \e p's methods 
 *  specified by \e isRequiredMethod and \e isInstanceMethod. The array contains \c *outCount pointers followed
 *  by a \c NULL terminator. You must free the list with \c free().
 *  If the protocol declares no methods that meet the specification, \c NULL is returned and \c *outCount is 0.
 * 
 * @note Methods in other protocols adopted by this protocol are not included.
 */
OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the specified property of a given protocol.
 * 
 * @param proto A protocol.
 * @param name The name of a property.
 * @param isRequiredProperty A Boolean value that indicates whether name is a required property.
 * @param isInstanceProperty A Boolean value that indicates whether name is a required property.
 * 
 * @return The property specified by \e name, \e isRequiredProperty, and \e isInstanceProperty for \e proto,
 *  or \c NULL if none of \e proto's properties meets the specification.
 */
OBJC_EXPORT objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns an array of the properties declared by a protocol.
 * 
 * @param proto A protocol.
 * @param outCount Upon return, contains the number of elements in the returned array.
 * 
 * @return A C array of pointers of type \c objc_property_t describing the properties declared by \e proto.
 *  Any properties declared by other protocols adopted by this protocol are not included. The array contains
 *  \c *outCount pointers followed by a \c NULL terminator. You must free the array with \c free().
 *  If the protocol declares no properties, \c NULL is returned and \c *outCount is \c 0.
 */
OBJC_EXPORT objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns an array of the protocols adopted by a protocol.
 * 
 * @param proto A protocol.
 * @param outCount Upon return, contains the number of elements in the returned array.
 * 
 * @return A C array of protocols adopted by \e proto. The array contains \e *outCount pointers
 *  followed by a \c NULL terminator. You must free the array with \c free().
 *  If the protocol declares no properties, \c NULL is returned and \c *outCount is \c 0.
 */
OBJC_EXPORT Protocol * __unsafe_unretained *protocol_copyProtocolList(Protocol *proto, unsigned int *outCount)
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Creates a new protocol instance that cannot be used until registered with
 * \c objc_registerProtocol()
 * 
 * @param name The name of the protocol to create.
 *
 * @return The Protocol instance on success, \c nil if a protocol
 *  with the same name already exists. 
 * @note There is no dispose method for this. 
 */
OBJC_EXPORT Protocol *objc_allocateProtocol(const char *name) 
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Registers a newly constructed protocol with the runtime. The protocol
 * will be ready for use and is immutable after this.
 * 
 * @param proto The protocol you want to register.
 */
OBJC_EXPORT void objc_registerProtocol(Protocol *proto) 
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Adds a method to a protocol. The protocol must be under construction.
 * 
 * @param proto The protocol to add a method to.
 * @param name The name of the method to add.
 * @param types A C string that represents the method signature.
 * @param isRequiredMethod YES if the method is not an optional method.
 * @param isInstanceMethod YES if the method is an instance method. 
 */
OBJC_EXPORT void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod) 
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Adds an incorporated protocol to another protocol. The protocol being
 * added to must still be under construction, while the additional protocol
 * must be already constructed.
 * 
 * @param proto The protocol you want to add to, it must be under construction.
 * @param addition The protocol you want to incorporate into \e proto, it must be registered.
 */
OBJC_EXPORT void protocol_addProtocol(Protocol *proto, Protocol *addition) 
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Adds a property to a protocol. The protocol must be under construction. 
 * 
 * @param proto The protocol to add a property to.
 * @param name The name of the property.
 * @param attributes An array of property attributes.
 * @param attributeCount The number of attributes in \e attributes.
 * @param isRequiredProperty YES if the property (accessor methods) is not optional. 
 * @param isInstanceProperty YES if the property (accessor methods) are instance methods. 
 *  This is the only case allowed fo a property, as a result, setting this to NO will 
 *  not add the property to the protocol at all. 
 */
OBJC_EXPORT void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);


/* Working with Libraries */

/** 
 * Returns the names of all the loaded Objective-C frameworks and dynamic
 * libraries.
 * 
 * @param outCount The number of names returned.
 * 
 * @return An array of C strings of names. Must be free()'d by caller.
 */
OBJC_EXPORT const char **objc_copyImageNames(unsigned int *outCount) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the dynamic library name a class originated from.
 * 
 * @param cls The class you are inquiring about.
 * 
 * @return The name of the library containing this class.
 */
OBJC_EXPORT const char *class_getImageName(Class cls) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Returns the names of all the classes within a library.
 * 
 * @param image The library or framework you are inquiring about.
 * @param outCount The number of class names returned.
 * 
 * @return An array of C strings representing the class names.
 */
OBJC_EXPORT const char **objc_copyClassNamesForImage(const char *image, 
                                                     unsigned int *outCount) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);


/* Working with Selectors */

/** 
 * Returns the name of the method specified by a given selector.
 * 
 * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
 * 
 * @return A C string indicating the name of the selector.
 */
OBJC_EXPORT const char *sel_getName(SEL sel)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Registers a method name with the Objective-C runtime system.
 * 
 * @param str A pointer to a C string. Pass the name of the method you wish to register.
 * 
 * @return A pointer of type SEL specifying the selector for the named method.
 * 
 * @note The implementation of this method is identical to the implementation of \c sel_registerName.
 * @note Prior to OS X version 10.0, this method tried to find the selector mapped to the given name
 *  and returned \c NULL if the selector was not found. This was changed for safety, because it was
 *  observed that many of the callers of this function did not check the return value for \c NULL.
 */
OBJC_EXPORT SEL sel_getUid(const char *str)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Registers a method with the Objective-C runtime system, maps the method 
 * name to a selector, and returns the selector value.
 * 
 * @param str A pointer to a C string. Pass the name of the method you wish to register.
 * 
 * @return A pointer of type SEL specifying the selector for the named method.
 * 
 * @note You must register a method name with the Objective-C runtime system to obtain the
 *  method’s selector before you can add the method to a class definition. If the method name
 *  has already been registered, this function simply returns the selector.
 */
OBJC_EXPORT SEL sel_registerName(const char *str)
    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);

/** 
 * Returns a Boolean value that indicates whether two selectors are equal.
 * 
 * @param lhs The selector to compare with rhs.
 * @param rhs The selector to compare with lhs.
 * 
 * @return \c YES if \e rhs and \e rhs are equal, otherwise \c NO.
 * 
 * @note sel_isEqual is equivalent to ==.
 */
OBJC_EXPORT BOOL sel_isEqual(SEL lhs, SEL rhs) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);


/* Objective-C Language Features */

/** 
 * This function is inserted by the compiler when a mutation
 * is detected during a foreach iteration. It gets called 
 * when a mutation occurs, and the enumerationMutationHandler
 * is enacted if it is set up. A fatal error occurs if a handler is not set up.
 *
 * @param obj The object being mutated.
 * 
 */
OBJC_EXPORT void objc_enumerationMutation(id obj) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Sets the current mutation handler. 
 * 
 * @param handler Function pointer to the new mutation handler.
 */
OBJC_EXPORT void objc_setEnumerationMutationHandler(void (*handler)(id)) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Set the function to be called by objc_msgForward.
 * 
 * @param fwd Function to be jumped to by objc_msgForward.
 * @param fwd_stret Function to be jumped to by objc_msgForward_stret.
 * 
 * @see message.h::_objc_msgForward
 */
OBJC_EXPORT void objc_setForwardHandler(void *fwd, void *fwd_stret) 
     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/** 
 * Creates a pointer to a function that will call the block
 * when the method is called.
 * 
 * @param block The block that implements this method. Its signature should
 *  be: method_return_type ^(id self, method_args...). 
 *  The selector is not available as a parameter to this block.
 *  The block is copied with \c Block_copy().
 * 
 * @return The IMP that calls this block. Must be disposed of with
 *  \c imp_removeBlock.
 */
OBJC_EXPORT IMP imp_implementationWithBlock(id block)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Return the block associated with an IMP that was created using
 * \c imp_implementationWithBlock.
 * 
 * @param anImp The IMP that calls this block.
 * 
 * @return The block called by \e anImp.
 */
OBJC_EXPORT id imp_getBlock(IMP anImp)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * Disassociates a block from an IMP that was created using
 * \c imp_implementationWithBlock and releases the copy of the 
 * block that was created.
 * 
 * @param anImp An IMP that was created using \c imp_implementationWithBlock.
 * 
 * @return YES if the block was released successfully, NO otherwise. 
 *  (For example, the block might not have been used to create an IMP previously).
 */
OBJC_EXPORT BOOL imp_removeBlock(IMP anImp)
     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);

/** 
 * This loads the object referenced by a weak pointer and returns it, after
 * retaining and autoreleasing the object to ensure that it stays alive
 * long enough for the caller to use it. This function would be used
 * anywhere a __weak variable is used in an expression.
 * 
 * @param location The weak pointer address
 * 
 * @return The object pointed to by \e location, or \c nil if \e location is \c nil.
 */
OBJC_EXPORT id objc_loadWeak(id *location)
    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);

/** 
 * This function stores a new value into a __weak variable. It would
 * be used anywhere a __weak variable is the target of an assignment.
 * 
 * @param location The address of the weak pointer itself
 * @param obj The new object this weak ptr should now point to
 * 
 * @return The value stored into \e location, i.e. \e obj
 */
OBJC_EXPORT id objc_storeWeak(id *location, id obj) 
    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);


/* Associative References */

/**
 * Policies related to associative references.
 * These are options to objc_setAssociatedObject()
 */
typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};

/** 
 * Sets an associated value for a given object using a given key and association policy.
 * 
 * @param object The source object for the association.
 * @param key The key for the association.
 * @param value The value to associate with the key key for object. Pass nil to clear an existing association.
 * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.”
 * 
 * @see objc_setAssociatedObject
 * @see objc_removeAssociatedObjects
 */
OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);

/** 
 * Returns the value associated with a given object for a given key.
 * 
 * @param object The source object for the association.
 * @param key The key for the association.
 * 
 * @return The value associated with the key \e key for \e object.
 * 
 * @see objc_setAssociatedObject
 */
OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);

/** 
 * Removes all associations for a given object.
 * 
 * @param object An object that maintains associated objects.
 * 
 * @note The main purpose of this function is to make it easy to return an object 
 *  to a "pristine state”. You should not use this function for general removal of
 *  associations from objects, since it also removes associations that other clients
 *  may have added to the object. Typically you should use \c objc_setAssociatedObject 
 *  with a nil value to clear an association.
 * 
 * @see objc_setAssociatedObject
 * @see objc_getAssociatedObject
 */
OBJC_EXPORT void objc_removeAssociatedObjects(id object)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);


#define _C_ID       '@'
#define _C_CLASS    '#'
#define _C_SEL      ':'
#define _C_CHR      'c'
#define _C_UCHR     'C'
#define _C_SHT      's'
#define _C_USHT     'S'
#define _C_INT      'i'
#define _C_UINT     'I'
#define _C_LNG      'l'
#define _C_ULNG     'L'
#define _C_LNG_LNG  'q'
#define _C_ULNG_LNG 'Q'
#define _C_FLT      'f'
#define _C_DBL      'd'
#define _C_BFLD     'b'
#define _C_BOOL     'B'
#define _C_VOID     'v'
#define _C_UNDEF    '?'
#define _C_PTR      '^'
#define _C_CHARPTR  '*'
#define _C_ATOM     '%'
#define _C_ARY_B    '['
#define _C_ARY_E    ']'
#define _C_UNION_B  '('
#define _C_UNION_E  ')'
#define _C_STRUCT_B '{'
#define _C_STRUCT_E '}'
#define _C_VECTOR   '!'
#define _C_CONST    'r'


/* Obsolete types */

#if !__OBJC2__

#define CLS_GETINFO(cls,infomask)        ((cls)->info & (infomask))
#define CLS_SETINFO(cls,infomask)        ((cls)->info |= (infomask))

// class is not a metaclass
#define CLS_CLASS               0x1
// class is a metaclass
#define CLS_META                0x2
// class's +initialize method has completed
#define CLS_INITIALIZED         0x4
// class is posing
#define CLS_POSING              0x8
// unused
#define CLS_MAPPED              0x10
// class and subclasses need cache flush during image loading
#define CLS_FLUSH_CACHE         0x20
// method cache should grow when full
#define CLS_GROW_CACHE          0x40
// unused
#define CLS_NEED_BIND           0x80
// methodLists is array of method lists
#define CLS_METHOD_ARRAY        0x100
// the JavaBridge constructs classes with these markers
#define CLS_JAVA_HYBRID         0x200
#define CLS_JAVA_CLASS          0x400
// thread-safe +initialize
#define CLS_INITIALIZING        0x800
// bundle unloading
#define CLS_FROM_BUNDLE         0x1000
// C++ ivar support
#define CLS_HAS_CXX_STRUCTORS   0x2000
// Lazy method list arrays
#define CLS_NO_METHOD_ARRAY     0x4000
// +load implementation
#define CLS_HAS_LOAD_METHOD     0x8000
// objc_allocateClassPair API
#define CLS_CONSTRUCTING        0x10000
// class compiled with bigger class structure
#define CLS_EXT                 0x20000


struct objc_method_description_list {
        int count;
        struct objc_method_description list[1];
};


struct objc_protocol_list {
    struct objc_protocol_list *next;
    long count;
    Protocol *list[1];
};


struct objc_category {
    char *category_name                                      OBJC2_UNAVAILABLE;
    char *class_name                                         OBJC2_UNAVAILABLE;
    struct objc_method_list *instance_methods                OBJC2_UNAVAILABLE;
    struct objc_method_list *class_methods                   OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;


struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;

struct objc_ivar_list {
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;


struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp                                           OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;

struct objc_method_list {
    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;

    int method_count                                         OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;


typedef struct objc_symtab *Symtab                           OBJC2_UNAVAILABLE;

struct objc_symtab {
    unsigned long sel_ref_cnt                                OBJC2_UNAVAILABLE;
    SEL *refs                                                OBJC2_UNAVAILABLE;
    unsigned short cls_def_cnt                               OBJC2_UNAVAILABLE;
    unsigned short cat_def_cnt                               OBJC2_UNAVAILABLE;
    void *defs[1] /* variable size */                        OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;


typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;

#define CACHE_BUCKET_NAME(B)  ((B)->method_name)
#define CACHE_BUCKET_IMP(B)   ((B)->method_imp)
#define CACHE_BUCKET_VALID(B) (B)
#ifndef __LP64__
#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)>>2) & (mask))
#else
#define CACHE_HASH(sel, mask) (((unsigned int)((uintptr_t)(sel)>>3)) & (mask))
#endif
struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method buckets[1]                                        OBJC2_UNAVAILABLE;
};


typedef struct objc_module *Module                           OBJC2_UNAVAILABLE;

struct objc_module {
    unsigned long version                                    OBJC2_UNAVAILABLE;
    unsigned long size                                       OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    Symtab symtab                                            OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;

#else

struct objc_method_list;

#endif


/* Obsolete functions */

OBJC_EXPORT IMP class_lookupMethod(Class cls, SEL sel) 
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);
OBJC_EXPORT BOOL class_respondsToMethod(Class cls, SEL sel)
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);
OBJC_EXPORT void _objc_flush_caches(Class cls) 
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);

OBJC_EXPORT id object_copyFromZone(id anObject, size_t nBytes, void *z) 
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_NA,__IPHONE_NA)
    OBJC_ARC_UNAVAILABLE;
OBJC_EXPORT id object_realloc(id anObject, size_t nBytes)    OBJC2_UNAVAILABLE;
OBJC_EXPORT id object_reallocFromZone(id anObject, size_t nBytes, void *z) OBJC2_UNAVAILABLE;

#define OBSOLETE_OBJC_GETCLASSES 1
OBJC_EXPORT void *objc_getClasses(void)                      OBJC2_UNAVAILABLE;
OBJC_EXPORT void objc_addClass(Class myClass)                OBJC2_UNAVAILABLE;
OBJC_EXPORT void objc_setClassHandler(int (*)(const char *)) OBJC2_UNAVAILABLE;
OBJC_EXPORT void objc_setMultithreaded (BOOL flag)           OBJC2_UNAVAILABLE;

OBJC_EXPORT id class_createInstanceFromZone(Class, size_t idxIvars, void *z)  
    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5, __IPHONE_NA,__IPHONE_NA)
    OBJC_ARC_UNAVAILABLE;

OBJC_EXPORT void class_addMethods(Class, struct objc_method_list *) OBJC2_UNAVAILABLE;
OBJC_EXPORT void class_removeMethods(Class, struct objc_method_list *) OBJC2_UNAVAILABLE;
OBJC_EXPORT void _objc_resolve_categories_for_class(Class cls)  OBJC2_UNAVAILABLE;

OBJC_EXPORT Class class_poseAs(Class imposter, Class original) OBJC2_UNAVAILABLE;

OBJC_EXPORT unsigned int method_getSizeOfArguments(Method m) OBJC2_UNAVAILABLE;
OBJC_EXPORT unsigned method_getArgumentInfo(struct objc_method *m, int arg, const char **type, int *offset) OBJC2_UNAVAILABLE;

OBJC_EXPORT Class objc_getOrigClass(const char *name)        OBJC2_UNAVAILABLE;
#define OBJC_NEXT_METHOD_LIST 1
OBJC_EXPORT struct objc_method_list *class_nextMethodList(Class, void **) OBJC2_UNAVAILABLE;
// usage for nextMethodList
//
// void *iterator = 0;
// struct objc_method_list *mlist;
// while ( mlist = class_nextMethodList( cls, &iterator ) )
//    ;
 
OBJC_EXPORT id (*_alloc)(Class, size_t)                      OBJC2_UNAVAILABLE;
OBJC_EXPORT id (*_copy)(id, size_t)                          OBJC2_UNAVAILABLE;
OBJC_EXPORT id (*_realloc)(id, size_t)                       OBJC2_UNAVAILABLE;
OBJC_EXPORT id (*_dealloc)(id)                               OBJC2_UNAVAILABLE;
OBJC_EXPORT id (*_zoneAlloc)(Class, size_t, void *)          OBJC2_UNAVAILABLE;
OBJC_EXPORT id (*_zoneRealloc)(id, size_t, void *)           OBJC2_UNAVAILABLE;
OBJC_EXPORT id (*_zoneCopy)(id, size_t, void *)              OBJC2_UNAVAILABLE;
OBJC_EXPORT void (*_error)(id, const char *, va_list)        OBJC2_UNAVAILABLE;

#endif
                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/                                           0040755 0001750 0001750 00000000000 12612224753 021377  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odconnection.h                             0100644 0001750 0001750 00000015612 12566223340 024233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODCONNECTION_H)
#define __ODCONNECTION_H

__BEGIN_DECLS

/*!
 * @function odconnection_create
 *
 * @abstract
 * creates a new connection object
 *
 * @discussion
 * creates a new object to be used for later operations
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object associated with this connection
 *
 * @param name
 * is a CFStringRef to call the connection
 *
 * @param shared
 * is a boolean specifying if the connection is allowed to be shared
 *
 * @param timeout
 * is how many seconds before the connection should be closed
 *
 * @result
 * an od_connection_t object created or NULL on failure
 */
OD_WARN_RESULT OD_NOTHROW OD_RETURNS_RETAINED
od_connection_t
odconnection_create(od_moduleconfig_t moduleconfig, CFStringRef name, bool shared, uint64_t timeout);

/*!
 * @function odconnection_create_ext
 *
 * @abstract
 * creates a connection object that has not been established with an alternative credential and flags
 *
 * @discussion
 * creates a connection object that has not been established with an alternative credential and flags
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object associated with this connection
 *
 * @param request
 * is an od_request_t that has triggered this connection
 *
 * @param name
 * is a CFStringRef to call the connection (optional, NULL is allowed)
 *
 * @param guid
 * is a guid_t to assign to this connection (optional, NULL is allowed)
 *
 * @param credential
 * is an od_credential_t attached to this connection
 *
 * @param flags
 * requested for this connection
 *
 * @param timeout
 * is how many seconds before the connection should be closed
 *
 * @param info
 * is od_connection_info_t (callbacks, context info, etc.)
 *
 * @result
 * An od_connection_t object created or NULL on failure
 */
OD_WARN_RESULT OD_NOTHROW OD_RETURNS_RETAINED
od_connection_t
odconnection_create_ext(od_moduleconfig_t moduleconfig, od_request_t request, CFStringRef name, guid_t *guid,
                        od_credential_t credential, eODModuleConfigServerFlags flags, uint64_t timeout, od_connection_info_t *info);


/*!
 * @function odconnection_connect_if_necessary
 *
 * @abstract
 * Forces a connection if not already connected.
 *
 * @discussion
 *  * Forces a connection if not already connected.  Will block for the connection setup timeout.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @param request
 * A valid od_request_t object that triggered this activity (optional)
 *
 * @result
 * returns false if not connected or failed to reconnect
 */
bool
odconnection_connect_if_necessary(od_connection_t connection, od_request_t request);

/*!
 * @function odconnection_set_failed
 *
 * @abstract
 * Flags a connection as failed.
 *
 * @discussion
 * Flags a connection as failed.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @param request
 * A valid od_request_t object that triggered this activity (optional)
 */
void
odconnection_set_failed(od_connection_t connection, od_request_t request);

/*!
 * @function odconnection_disconnect
 *
 * @abstract
 * Forces the connection to disconnect, cancelling all inflight requests.
 *
 * @discussion
 * Forces the connection to disconnect, cancelling all inflight requests.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 */
void
odconnection_disconnect(od_connection_t connection);

/*!
 * @function odconnection_get_moduleconfig
 *
 * @abstract
 * Returns the moduleconfig associated with the connection.
 *
 * @discussion
 * Returns the moduleconfig associated with the connection.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @result
 * Returns a valid od_moduleconfig_t object.
 */
OD_WARN_RESULT OD_NOTHROW OD_RETURNS_NOT_RETAINED
od_moduleconfig_t
odconnection_get_moduleconfig(od_connection_t connection);


/*!
 * @function odconnection_set_context
 *
 * @abstract
 * Sets a context on the connection.
 *
 * @discussion
 * Sets a context on the connection.  Only one context can be present at any given time.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @param context
 * A pointer to data defined by the caller
 *
 * @param dealloc
 * An optional deallocation function for the context.
 *
 * @result
 * Returns a valid od_moduleconfig_t object.
 */
void
odconnection_set_context(od_connection_t connection, void *context, od_context_dealloc_fn_t dealloc);

/*!
 * @function odconnection_copy_destination
 *
 * @abstract
 * Returns a copy of the destination associated with the current connection.
 *
 * @discussion
 * Returns a copy of the destination associated with the current connection.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @result
 * Returns a valid CFStringRef if a destination is present.
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFStringRef
odconnection_copy_destination(od_connection_t connection);


/*!
 * @function odconnection_has_credentials
 *
 * @abstract
 * Returns a boolean signifying the presence of credentials associated with connection.
 *
 * @discussion
 * Returns a boolean signifying the presence of credentials associated with connection.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @result
 * Returns a true if the connection has credentials associated with it.
 */
bool
odconnection_has_credentials(od_connection_t connection);

void
odconnection_set_credential(od_connection_t connection, od_request_t request, od_credential_t credential);

/*!
 * @function odconnection_copy_credential
 *
 * @abstract
 * Returns a copy of the credentials attached to the connection.
 *
 * @discussion
 * Returns a copy of the credentials attached to the connection.
 *
 * @param connection
 * A valid od_connection_t object, must not be NULL
 *
 * @result
 * Returns a valid od_credential_t if present.
 */
OD_WARN_RESULT OD_NOTHROW OD_RETURNS_RETAINED
od_credential_t
odconnection_copy_credential(od_connection_t connection);


__END_DECLS

#endif
                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odconstants.h                              0100644 0001750 0001750 00000466575 12566223340 024132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODCONSTANTS_H)
#define __ODCONSTANTS_H

/*!
    @const      kODSessionProxyAddress
    @abstract   the address to connect to via proxy, used when making the options dictionary
    @discussion the address to connect to via proxy, used when making the options dictionary
*/
CF_EXPORT
const CFStringRef kODSessionProxyAddress __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const      kODSessionProxyPort
    @abstract   the port to connect to via proxy, used when making the options dictionary
    @discussion the port to connect to via proxy, used when making the options dictionary.  This parameter
                is optional and should not be passed normally.
*/
CF_EXPORT
const CFStringRef kODSessionProxyPort __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const      kODSessionProxyUsername
    @abstract   the username to connect with via proxy, used when making the options dictionary
    @discussion the username to connect with via proxy, used when making the options dictionary
*/
CF_EXPORT
const CFStringRef kODSessionProxyUsername __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const      kODSessionProxyPassword
    @abstract   the password to connect with via proxy, used when making the options dictionary
    @discussion the password to connect with via proxy, used when making the options dictionary
*/
CF_EXPORT
const CFStringRef kODSessionProxyPassword __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
 @const      kODModuleConfigOptionQueryTimeout
 @abstract   number of seconds before a query times out
 @discussion number of seconds before a query times out
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionQueryTimeout __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionConnectionSetupTimeout
 @abstract   number of seconds before a connection attempt times out
 @discussion number of seconds before a connection attempt times out
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionConnectionSetupTimeout __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionConnectionIdleDisconnect
 @abstract   number of seconds before a connection is idle disconnected
 @discussion number of seconds before a connection is idle disconnected
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionConnectionIdleDisconnect __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionPacketSigning
 @abstract   enable or disable packet signing
 @discussion number of seconds before a query times out
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionPacketSigning __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionPacketEncryption
 @abstract   enable or disable packet encryption
 @discussion enable or disable packet encryption
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionPacketEncryption __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionManInTheMiddle
 @abstract   enable or disable man-in-middle countermeasures
 @discussion enable or disable man-in-middle countermeasures
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionManInTheMiddle __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
	@enum		ODNodeType
	@abstract   Types of nodes that can be opened
	@discussion Various types of nodes that can be opened.
	@constant   kODNodeTypeAuthentication is a node type commonly used for all authentications or record lookups
	@constant   kODNodeTypeContacts is a node type commonly used for applications that deal with contact data
	@constant   kODNodeTypeNetwork is a node type used for looking for network resource type data
	@constant   kODNodeTypeLocalNodes is a node type that specifically looks at the local directory
	@constant   kODNodeTypeConfigure is a node type that refers to the configuration node within DS
*/
enum
{
	kODNodeTypeAuthentication			= 0x2201,
	kODNodeTypeContacts					= 0x2204,
	kODNodeTypeNetwork					= 0x2205, /* deprecated, behaves identically to kODNodeTypeAuthentication */
	
	kODNodeTypeLocalNodes				= 0x2200,
	kODNodeTypeConfigure   				= 0x2202
};
typedef uint32_t ODNodeType;

/*!
    @const      kODNodeOptionsQuerySkippedSubnode
    @abstract   Used with nodes that support options.
    @discussion Passed in an options dictionary where the value is a boolean (kCFBooleanTrue/kCFBooleanFalse).
                If a node supports the option it will notify the client when a subnode is skipped during queries.
                Supported options are listed in node details under kODAttributeTypeNodeOptions.  Node may fail to
                open if unsupported options are used.
 */
CF_EXPORT
const CFStringRef kODNodeOptionsQuerySkippedSubnode __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_NA);

/*!
	@enum   	ODMatchType
	@abstract   Are types of matching types used for doing searches.  Each type is self explanatory based on the name.
	@constant	kODMatchAny is used to search for any records (typically passed with nil search value)
	@constant	kODMatchEqualTo is searching values that are equal to the provided value
	@constant	kODMatchBeginsWith is searching values that begin with the provided value
	@constant	kODMatchContains is searching values that contain the provided value
	@constant	kODMatchEndsWith is searching values that end with the provided value
	@constant	kODMatchGreaterThan is searching values greater than the provided value
	@constant	kODMatchLessThan is searching values less than the provided value
 */
enum
{
	kODMatchAny						= 0x0001,
	
	kODMatchEqualTo					= 0x2001,
	kODMatchBeginsWith				= 0x2002,
	kODMatchContains				= 0x2004,
	kODMatchEndsWith				= 0x2003,
	
	kODMatchInsensitiveEqualTo    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2101,
	kODMatchInsensitiveBeginsWith __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2102,
	kODMatchInsensitiveContains   __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2104,
	kODMatchInsensitiveEndsWith   __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2103,
	
	kODMatchGreaterThan				= 0x2006,
	kODMatchLessThan				= 0x2007,
};
typedef uint32_t ODMatchType;

/*!
	@typedef	ODRecordType
	@abstract   is used to define a specific record type
	@discussion is used to define a specific record type common to DirectoryService.
				Records types are strings that have a prefix:
 
					Standard records	- "dsRecTypeStandard:"
					Native to the node	- "dsRecTypeNative:"
 
				The most commonly used Standard records are contained in this header.
 
				Note:  CFStringRef can be use interchangeably with ODRecordType for ease
				of use.
*/
#ifdef __OBJC__
#include <Foundation/Foundation.h>
typedef NSString *ODRecordType;
#else
typedef CFStringRef ODRecordType;
#endif

/*!
	@typedef	ODAttributeType
	@abstract   is used to define a specific attribute type
	@discussion is used to define a specific attribute type common to DirectoryService.
				Attribute types are strings that have a prefix:
 
					Standard attributes	- "dsAttrTypeStandard:"
					Native to the node	- "dsAttrTypeNative:"
 
				The most commonly used Standard attributes are contained in this header.
 
				Note:  CFStringRef can be use interchangeably with ODAttributeType for ease
				of use.
*/
#ifdef __OBJC__
typedef NSString *ODAttributeType;
#else
typedef CFStringRef ODAttributeType;
#endif

/*!
	@typedef	ODAuthenticationType
	@abstract   is used to define a specific credential method type
	@discussion is used to define a specific credential method type common to DirectoryService.
				Authentication types are strings that have a prefix:
 
					Standard attributes	- "dsAuthMethodStandard:"
					Native to the node	- "dsAuthMethodNative:"
 
				The most commonly used Standard authentications are contained in this header.
 
				Note:  CFStringRef can be use interchangeably with ODAuthenticationType for ease
				of use.
*/
#ifdef __OBJC__
typedef NSString *ODAuthenticationType;
#else
typedef CFStringRef ODAuthenticationType;
#endif

/*!
	@typedef	ODPolicyType
	@abstract   is used to modify policies on nodes or records
	@discussion is used to modify policies on nodes or records
*/
#ifdef __OBJC_
typedef NSString *ODPolicyType;
#else
typedef CFStringRef ODPolicyType;
#endif

// Compatibility
typedef ODRecordType _ODRecordType;
typedef ODAttributeType _ODAttributeType;
typedef ODAuthenticationType _ODAuthenticationType;

#pragma mark Record Types

/*!
    @const		kODRecordTypeAttributeTypes
    @abstract   Identifies records that represent each possible attribute type.
    @discussion Identifies records that represent each possible attribute type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAttributeTypes;

/*!
    @const		kODRecordTypeAFPServer
    @abstract   Record type of AFP server records.
    @discussion Record type of AFP server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAFPServer;

/*!
    @const		kODRecordTypeAliases
    @abstract   Used to represent alias records.
    @discussion Used to represent alias records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAliases;

/*!
    @const		kODRecordTypeAugments
    @abstract   Used to store augmented record data.
    @discussion Used to store augmented record data.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAugments;

/*!
    @const		kODRecordTypeAutomount
    @abstract   Used to store automount record data.
    @discussion Used to store automount record data.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAutomount;

/*!
    @const		kODRecordTypeAutomountMap
    @abstract   Used to store automountMap record data.
    @discussion Used to store automountMap record data.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAutomountMap;

/*!
    @const		kODRecordTypeAutoServerSetup
    @abstract   Used to discover automated server setup information.
    @discussion Used to discover automated server setup information.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAutoServerSetup;

/*!
    @const		kODRecordTypeBootp
    @abstract   Record in the local node for storing bootp info.
    @discussion Record in the local node for storing bootp info.
*/
CF_EXPORT
const ODRecordType kODRecordTypeBootp;

/*!
    @const		kODRecordTypeCertificateAuthorities
    @abstract   Record type that contains certificate authority information.
    @discussion Record type that contains certificate authority information.
*/
CF_EXPORT
const ODRecordType kODRecordTypeCertificateAuthorities;

/*!
    @const		kODRecordTypeComputerLists
    @abstract   Identifies computer list records.
    @discussion Identifies computer list records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeComputerLists;

/*!
    @const		kODRecordTypeComputerGroups
    @abstract   Identifies computer group records.
    @discussion Identifies computer group records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeComputerGroups;

/*!
    @const		kODRecordTypeComputers
    @abstract   Identifies computer records.
    @discussion Identifies computer records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeComputers;

/*!
    @const		kODRecordTypeConfiguration
    @abstract   Identifies configuration records.
    @discussion Identifies configuration records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeConfiguration;

/*!
    @const		kODRecordTypeEthernets
    @abstract   Record in the node for storing ethernets.
    @discussion Record in the node for storing ethernets.
*/
CF_EXPORT
const ODRecordType kODRecordTypeEthernets;

/*!
    @const		kODRecordTypeFileMakerServers
	@abstract   FileMaker servers record type. 
	@discussion FileMaker servers record type that describes available FileMaker servers, 
				used for service discovery.
*/
CF_EXPORT
const ODRecordType kODRecordTypeFileMakerServers;

/*!
    @const		kODRecordTypeFTPServer
    @abstract   Identifies ftp server records.
    @discussion Identifies ftp server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeFTPServer;

/*!
    @const		kODRecordTypeGroups
    @abstract   Identifies group records.
    @discussion Identifies group records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeGroups;

/*!
    @const		kODRecordTypeHostServices
    @abstract   Record in the local node for storing host services.
    @discussion Record in the local node for storing host services.
*/
CF_EXPORT
const ODRecordType kODRecordTypeHostServices;

/*!
    @const		kODRecordTypeHosts
    @abstract   Identifies host records.
    @discussion Identifies host records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeHosts;

/*!
    @const		kODRecordTypeLDAPServer
    @abstract   Identifies LDAP server records.
    @discussion Identifies LDAP server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeLDAPServer;

/*!
    @const		kODRecordTypeLocations
    @abstract   Location record type.
    @discussion Location record type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeLocations;

/*!
    @const		kODRecordTypeMounts
    @abstract   Identifies mount records.
    @discussion Identifies mount records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeMounts;

/*!
    @const		kODRecordTypeNFS
    @abstract   Identifies NFS records.
    @discussion Identifies NFS records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNFS;

/*!
    @const		kODRecordTypeNetDomains
    @abstract   Record in the local node for storing net domains.
    @discussion Record in the local node for storing net domains.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNetDomains;

/*!
    @const		kODRecordTypeNetGroups
    @abstract   Record in the local node for storing net groups.
    @discussion Record in the local node for storing net groups.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNetGroups;

/*!
    @const		kODRecordTypeNetworks
    @abstract   Identifies network records.
    @discussion Identifies network records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNetworks;

/*!
    @const		kODRecordTypePeople
    @abstract   Record type that contains "People" records used for contact information.
    @discussion Record type that contains "People" records used for contact information.
*/
CF_EXPORT
const ODRecordType kODRecordTypePeople;

/*!
    @const		kODRecordTypePresetComputers
    @abstract   The computer record type used for presets in record creation.
    @discussion The computer record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetComputers;

/*!
    @const		kODRecordTypePresetComputerGroups
    @abstract   The computer group record type used for presets in record creation.
    @discussion The computer group record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetComputerGroups;

/*!
    @const		kODRecordTypePresetComputerLists
    @abstract   The computer list record type used for presets in record creation.
    @discussion The computer list record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetComputerLists;

/*!
    @const		kODRecordTypePresetGroups
    @abstract   The group record type used for presets in record creation.
    @discussion The group record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetGroups;

/*!
    @const		kODRecordTypePresetUsers
    @abstract   The user record type used for presets in record creation.
    @discussion The user record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetUsers;

/*!
    @const		kODRecordTypePrintService
    @abstract   Identifies print service records.
    @discussion Identifies print service records.
*/
CF_EXPORT
const ODRecordType kODRecordTypePrintService;

/*!
    @const		kODRecordTypePrintServiceUser
    @abstract   Record in the local node for storing quota usage for a user.
    @discussion Record in the local node for storing quota usage for a user.
*/
CF_EXPORT
const ODRecordType kODRecordTypePrintServiceUser;

/*!
    @const		kODRecordTypePrinters
    @abstract   Identifies printer records.
    @discussion Identifies printer records.
*/
CF_EXPORT
const ODRecordType kODRecordTypePrinters;

/*!
    @const		kODRecordTypeProtocols
    @abstract   Identifies protocol records.
    @discussion Identifies protocol records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeProtocols;

/*!
    @const		kODRecordTypeQTSServer
    @abstract   Identifies quicktime streaming server records.
    @discussion Identifies quicktime streaming server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeQTSServer;

/*!
    @const		kODRecordTypeQueryInformation
    @abstract   Special query information record
    @discussion Specifically to return query information inline such as skipped nodes
 */
CF_EXPORT
const ODRecordType kODRecordTypeQueryInformation;

/*!
    @const		kODRecordTypeRecordTypes
    @abstract   Identifies records that represent each possible record type.
    @discussion Identifies records that represent each possible record type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeRecordTypes;

/*!
    @const		kODRecordTypeResources
    @abstract   Identifies resources used in group services.
    @discussion Identifies resources used in group services.
*/
CF_EXPORT
const ODRecordType kODRecordTypeResources;

/*!
    @const		kODRecordTypeRPC
    @abstract   Identifies remote procedure call records.
    @discussion Identifies remote procedure call records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeRPC;

/*!
    @const		kODRecordTypeSMBServer
    @abstract   Identifies SMB server records.
    @discussion Identifies SMB server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeSMBServer;

/*!
    @const		kODRecordTypeServer
    @abstract   Identifies generic server records.
    @discussion Identifies generic server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeServer;

/*!
    @const		kODRecordTypeServices
    @abstract   Identifies directory based service records.
    @discussion Identifies directory based service records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeServices;

/*!
    @const		kODRecordTypeSharePoints
    @abstract   Share point record type.
    @discussion Share point record type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeSharePoints;

/*!
    @const		kODRecordTypeUsers
    @abstract   Identifies user records.
    @discussion Identifies user records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeUsers;

/*!
    @const		kODRecordTypeWebServer
    @abstract   Identifies web server records.
    @discussion Identifies web server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeWebServer;

#pragma mark Attribute Types

/*!
    @const		kODAttributeTypeAllAttributes
    @abstract   Used in requesting all attribute types in a search.
    @discussion Used in requesting all attribute types in a search.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAllAttributes;

/*!
    @const		kODAttributeTypeStandardOnly
    @abstract   Used in requesting all standard attribute types in a query.
    @discussion Used in requesting all standard attribute types in a query.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeStandardOnly;

/*!
    @const		kODAttributeTypeNativeOnly
    @abstract   Used in requesting all native attribute types in a search.
    @discussion Used in requesting all native attribute types in a search.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNativeOnly;

/*!
    @const		kODAttributeTypeMetaAmbiguousName
    @abstract   Used to disambiguate a provided name.
    @discussion Searches a configured list of attributes; by default: RecordName, FullName, EMailAddress.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaAmbiguousName;

/*!
    @const		kODAttributeTypeMetaAugmentedAttributes
    @abstract   Attributes that have been augmented.
    @discussion Attributes that have been augmented.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaAugmentedAttributes;

/*!
    @const		kODAttributeTypeMetaRecordName
    @abstract   Native record name.
    @discussion Native record name, e.g. LDAP DN
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaRecordName;

/*!
    @const		kODAttributeTypeAdminLimits
    @abstract   XML plist indicating what an admin user can edit.
    @discussion XML plist indicating what an admin user can edit. Found in kODRecordTypeUsers records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAdminLimits;

/*!
	@const		kODAttributeTypeAltSecurityIdentities
	@abstract	Used to store alternate identities for the record
	@discussion Used to store alternate identities for the record. Values will have standardized form as
				specified by Microsoft LDAP schema (1.2.840.113556.1.4.867).

 				Kerberos:user\@REALM
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeAltSecurityIdentities __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const		kODAttributeTypeAuthenticationHint
    @abstract   Used to identify the authentication hint phrase.
    @discussion Used to identify the authentication hint phrase.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthenticationHint;

/*!
    @const		kODAttributeTypeAllTypes
    @abstract   Used to indicated recommended attribute types for a record type in the Config node.
    @discussion Used to indicated recommended attribute types for a record type in the Config node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAllTypes;

/*!
    @const		kODAttributeTypeAuthorityRevocationList
    @abstract   Attribute containing the binary of the authority revocation list
	@discussion Attribute containing the binary of the authority revocation list.
				A certificate revocation list that defines certificate authority certificates
				which are no longer trusted.  No user certificates are included in this list.
				Usually found in kODRecordTypeCertificateAuthorities records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthorityRevocationList;

/*!
    @const		kODAttributeTypeBirthday
    @abstract   Single-valued attribute that defines the user's birthday.
	@discussion Single-valued attribute that defines the user's birthday.
				Format is x.208 standard YYYYMMDDHHMMSSZ which we will require as GMT time.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBirthday;

/*!
    @const		kODAttributeTypeCACertificate
	@abstract   Attribute containing the binary of the certificate of a certificate authority.
	@discussion Attribute containing the binary of the certificate of a certificate authority.
				Its corresponding private key is used to sign certificates.
				Usually found in kODRecordTypeCertificateAuthority records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCACertificate;

/*!
    @const		kODAttributeTypeCapacity
    @abstract   Attribute type for the capacity of a resource. 
	@discussion Attribute type for the capacity of a resource. 
				found in resource records (kODRecordTypeResources). 
					Example: 50
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCapacity;

/*!
    @const		kODAttributeTypeCertificateRevocationList
    @abstract   Attribute containing the binary of the certificate revocation list.
	@discussion Attribute containing the binary of the certificate revocation list.
				This is a list of certificates which are no longer trusted.
				Usually found in kODRecordTypeCertificateAuthority records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCertificateRevocationList;

/*!
    @const		kODAttributeTypeComment
    @abstract   Attribute used for unformatted comment.
    @discussion Attribute used for unformatted comment.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeComment;

/*!
    @const		kODAttributeTypeContactGUID
	@abstract   Attribute type for the contact GUID of a group. 
	@discussion Attribute type for the contact GUID of a group. 
				Usually found in group records (kODRecordTypeGroups)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeContactGUID;

/*!
    @const		kODAttributeTypeContactPerson
	@abstract   Attribute type for the contact person of the machine. 
	@discussion Attribute type for the contact person of the machine. 
				Found in host or machine records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeContactPerson;

/*!
    @const		kODAttributeTypeCreationTimestamp
	@abstract   Attribute showing date/time of record creation.
	@discussion Attribute showing date/time of record creation.
				Format is x.208 standard YYYYMMDDHHMMSSZ which should be GMT time.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCreationTimestamp;

/*!
    @const		kODAttributeTypeCrossCertificatePair
	@abstract   Attribute containing the binary of a pair of certificates which 
				verify each other.
	@discussion Attribute containing the binary of a pair of certificates which 
				verify each other.  Both certificates have the same level of authority.
				Usually found in kODRecordTypeCertificateAuthority records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCrossCertificatePair;

/*!
    @const		kODAttributeTypeDataStamp
    @abstract   Attribute for checksum/meta data
    @discussion Attribute for checksum/meta data
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDataStamp;

/*!
    @const		kODAttributeTypeFullName
    @abstract   Full name of a record
    @discussion Full name of a record (e.g., "John Doe", "John Doe's Computer")
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFullName;

/*!
    @const		kODAttributeTypeDNSDomain
    @abstract   DNS Resolver domain attribute.
    @discussion DNS Resolver domain attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDNSDomain;

/*!
    @const		kODAttributeTypeDNSNameServer
    @abstract   DNS Resolver nameserver attribute.
    @discussion DNS Resolver nameserver attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDNSNameServer;

/*!
    @const		kODAttributeTypeENetAddress
	@abstract   Attribute for hardware Ethernet address (MAC address).
	@discussion Attribute for hardware Ethernet address (MAC address).
				Found in computer records (kODRecordTypeComputers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeENetAddress;

/*!
    @const		kODAttributeTypeExpire
    @abstract   Used for expiration date or time depending on association.
    @discussion Used for expiration date or time depending on association.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeExpire;

/*!
    @const		kODAttributeTypeFirstName
    @abstract   Used for first name of user or person record.
    @discussion Used for first name of user or person record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFirstName;

/*!
    @const		kODAttributeTypeGUID
	@abstract   Used for 36 character (128 bit) unique ID.
	@discussion Used for 36 character (128 bit) unique ID. An example value is
				"A579E95E-CDFE-4EBC-B7E7-F2158562170F". The standard format contains
				32 uppercase hex characters and four hyphen characters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGUID;

/*!
    @const      kODAttributeTypeHardwareUUID
    @abstract   Used to store hardware UUID in string form
    @discussion Used to store hardware UUID in string form for a record.  Typically found in
                kODRecordTypeComputers.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHardwareUUID __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const		kODAttributeTypeHomeDirectoryQuota
	@abstract   Represents the allowed usage for a user's home directory in bytes.
	@discussion Represents the allowed usage for a user's home directory in bytes.
				Found in user records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeDirectoryQuota;

/*!
    @const		kODAttributeTypeHomeDirectorySoftQuota
	@abstract   Used to define home directory size limit in bytes when user is notified
				that the hard limit is approaching.
	@discussion Used to define home directory size limit in bytes when user is notified
				that the hard limit is approaching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeDirectorySoftQuota;

/*!
    @const		kODAttributeTypeHomeLocOwner
	@abstract   Represents the owner of a workgroup's shared home directory.
	@discussion Represents the owner of a workgroup's shared home directory.
				Typically found in kODRecordTypeGroups records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeLocOwner;

/*!
    @const		kODAttributeTypeInternetAlias
    @abstract   Used to track internet alias.
    @discussion Used to track internet alias.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeInternetAlias;

/*!
    @const		kODAttributeTypeKDCConfigData
    @abstract   Contents of the kdc.conf file.
    @discussion Contents of the kdc.conf file.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKDCConfigData;

/*!
	@const		kODAttributeTypeKerberosServices
	@abstract	This is used to store the principals in host records (i.e., "host", "vnc", etc.)
	@discussion	This is used to store the principals in host records (i.e., "host", "vnc", etc.)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKerberosServices __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
    @const		kODAttributeTypeLastName
    @abstract   Used for the last name of user or person record.
    @discussion Used for the last name of user or person record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLastName;

/*!
    @const		kODAttributeTypeLDAPSearchBaseSuffix
    @abstract   Search base suffix for a LDAP server.
    @discussion Search base suffix for a LDAP server.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLDAPSearchBaseSuffix;

/*!
    @const		kODAttributeTypeLocation
	@abstract   Represents the location a service is available from (usually domain name)
	@discussion Represents the location a service is available from (usually domain name).
				Typically found in service record types including kODRecordTypeAFPServer,
				kODRecordTypeLDAPServer, and kODRecordTypeWebServer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocation;

/*!
    @const		kODAttributeTypeMapGUID
    @abstract   Represents the GUID for a record's map
    @discussion Represents the GUID for a record's map.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMapGUID;

/*!
    @const		kODAttributeTypeMCXFlags
    @abstract   Used by ManagedClient
    @discussion Used by ManagedClient.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMCXFlags;

/*!
    @const		kODAttributeTypeMCXSettings
    @abstract   Used by ManagedClient
    @discussion Used by ManagedClient.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMCXSettings;

/*!
    @const		kODAttributeTypeMailAttribute
    @abstract   Holds the mail account config data
    @discussion Holds the mail account config data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMailAttribute;

/*!
    @const		kODAttributeTypeMetaAutomountMap
	@abstract   Used to query for kODRecordTypeAutomount entries
	@discussion Used to query for kODRecordTypeAutomount entries associated with a specific 
				kODRecordTypeAutomountMap.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaAutomountMap;

/*!
    @const		kODAttributeTypeMiddleName
    @abstract   Used for the middle name of user or person record.
    @discussion Used for the middle name of user or person record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMiddleName;

/*!
    @const		kODAttributeTypeModificationTimestamp
	@abstract   Attribute showing date/time of record modification.
	@discussion Attribute showing date/time of record modification.
				Format is x.208 standard YYYYMMDDHHMMSSZ which is required as GMT time.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeModificationTimestamp;

/*!
    @const		kODAttributeTypeNFSHomeDirectory
    @abstract   Defines a user's home directory mount point on the local machine.
    @discussion Defines a user's home directory mount point on the local machine.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNFSHomeDirectory;

/*!
    @const		kODAttributeTypeNote
    @abstract   Note attribute.
    @discussion Note attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNote;

/*!
    @const		kODAttributeTypeOperatingSystem
    @abstract   Returns the operating system type where the daemon is running
    @discussion Returns the operating system type where the daemon is running,
				e.g., Mac OS X or Mac OS X Server
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOperatingSystem __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
	@const		kODAttributeTypeOperatingSystemVersion
	@abstract   Returns the operating system version where the daemon is running
	@discussion Returns the operating system version where the daemon is running,
				e.g., 10.6
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeOperatingSystemVersion __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const		kODAttributeTypeOwner
	@abstract   Attribute type for the owner of a record. 
	@discussion Attribute type for the owner of a record. 
				Typically the value is a LDAP distinguished name.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOwner;

/*!
    @const		kODAttributeTypeOwnerGUID
	@abstract   Attribute type for the owner GUID of a group. 
	@discussion Attribute type for the owner GUID of a group. 
				Found in group records (kODRecordTypeGroups). 
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOwnerGUID;

/*!
    @const		kODAttributeTypePassword
    @abstract   Holds the password or credential value.
    @discussion Holds the password or credential value.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePassword;

/*!
    @const		kODAttributeTypePasswordPlus
    @abstract   Holds marker data to indicate possible authentication redirection.
    @discussion Holds marker data to indicate possible authentication redirection.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordPlus;

/*!
    @const		kODAttributeTypePasswordPolicyOptions
	@abstract   Collection of password policy options in single attribute.
	@discussion Collection of password policy options in single attribute.
				Used in user presets record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordPolicyOptions;

/*!
    @const		kODAttributeTypePasswordServerList
    @abstract   Represents the attribute for storing the password server's replication information.
    @discussion Represents the attribute for storing the password server's replication information.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordServerList;

/*!
    @const		kODAttributeTypePasswordServerLocation
	@abstract   Specifies the IP address or domain name of the Password Server associated
				with a given directory node.
	@discussion Specifies the IP address or domain name of the Password Server associated
				with a given directory node. Found in a config record named PasswordServer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordServerLocation;

/*!
    @const		kODAttributeTypePicture
	@abstract   Represents the path of the picture for each user displayed in the login window.
	@discussion Represents the path of the picture for each user displayed in the login window.
				Found in user records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePicture;

/*!
    @const		kODAttributeTypePort
	@abstract   Represents the port number a service is available on.
	@discussion Represents the port number a service is available on.
				Typically found in service record types including kODRecordTypeAFPServer,
				kODRecordTypeLDAPServer, and kODRecordTypeWebServer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePort;

/*!
    @const		kODAttributeTypePresetUserIsAdmin
	@abstract   Flag to indicate whether users created from this preset are administrators
				by default.
	@discussion Flag to indicate whether users created from this preset are administrators
				by default. Found in kODRecordTypePresetUsers records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePresetUserIsAdmin;

/*!
    @const		kODAttributeTypePrimaryComputerGUID
	@abstract   An attribute that defines a primary computer of the computer group.  
	@discussion An attribute that defines a primary computer of the computer group.  
				Added to computer group record type (kODRecordTypeComputerGroups)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryComputerGUID;

/*!
    @const		kODAttributeTypePrimaryComputerList
    @abstract   The GUID of the computer list with which this computer record is associated.
    @discussion The GUID of the computer list with which this computer record is associated.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryComputerList;

/*!
    @const		kODAttributeTypePrimaryGroupID
	@abstract   This is the 32 bit unique ID that represents the primary group 
				a user is part of, or the ID of a group.
	@discussion This is the 32 bit unique ID that represents the primary group 
				a user is part of, or the ID of a group. Format is a signed 32 bit integer
				represented as a string.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryGroupID;

/*!
    @const		kODAttributeTypePrinter1284DeviceID
	@abstract   Attribute that defines the IEEE 1284 DeviceID of a printer.
	@discussion Attribute that defines the IEEE 1284 DeviceID of a printer.
				This is used when configuring a printer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinter1284DeviceID;

/*!
    @const		kODAttributeTypePrinterLPRHost
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterLPRHost;

/*!
    @const		kODAttributeTypePrinterLPRQueue
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterLPRQueue;

/*!
    @const		kODAttributeTypePrinterMakeAndModel
	@abstract   Attribute for definition of the Printer Make and Model.
	@discussion Attribute for definition of the Printer Make and Model.  An example
				value would be "HP LaserJet 2200".  This would be used to determine the proper PPD
				file to be used when configuring a printer from the Directory.  This attribute
				is based on the IPP Printing Specification RFC and IETF IPP-LDAP Printer Record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterMakeAndModel;

/*!
    @const		kODAttributeTypePrinterType
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterType;

/*!
    @const		kODAttributeTypePrinterURI
	@abstract   Attribute that defines the URI of a printer "ipp://address" or
				"smb://server/queue".
	@discussion Attribute that defines the URI of a printer "ipp://address" or
				"smb://server/queue".  This is used when configuring a printer. This attribute
				is based on the IPP Printing Specification RFC and IETF IPP-LDAP Printer Record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterURI;

/*!
    @const		kODAttributeTypePrinterXRISupported
	@abstract   Attribute that defines additional URIs supported by a printer.
	@discussion attribute that defines additional URIs supported by a printer.
				This is used when configuring a printer. This attribute is based on the IPP 
				Printing Specification RFC and IETF IPP-LDAP Printer Record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterXRISupported;

/*!
    @const		kODAttributeTypePrintServiceInfoText
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrintServiceInfoText;

/*!
    @const		kODAttributeTypePrintServiceInfoXML
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrintServiceInfoXML;

/*!
    @const		kODAttributeTypePrintServiceUserData
	@abstract   Attribute for print quota configuration or statistics (XML data).
	@discussion Attribute for print quota configuration or statistics (XML data).
				Found in user records (kODRecordTypeUsers) or print service
				statistics records (kODRecordTypePrintServiceUser).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrintServiceUserData;

/*!
    @const		kODAttributeTypeRealUserID
    @abstract   Used by Managed Client.
    @discussion Used by Managed Client
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRealUserID;

/*!
    @const		kODAttributeTypeRelativeDNPrefix
	@abstract   Used to map the first native LDAP attribute type required in the building of the
				Relative Distinguished Name for LDAP record creation.
	@discussion Used to map the first native LDAP attribute type required in the building of the
				Relative Distinguished Name for LDAP record creation.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRelativeDNPrefix;

/*!
    @const		kODAttributeTypeSMBAcctFlags
    @abstract   Account control flag.
    @discussion Account control flag.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBAcctFlags;

/*!
    @const		kODAttributeTypeSMBGroupRID
    @abstract   Constant for supporting PDC SMB interaction with DirectoryService.
    @discussion Constant for supporting PDC SMB interaction with DirectoryService.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBGroupRID;

/*!
    @const		kODAttributeTypeSMBHome
    @abstract   UNC address of Windows homedirectory mount point (\\server\\sharepoint).
    @discussion UNC address of Windows homedirectory mount point (\\server\\sharepoint).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBHome;

/*!
    @const		kODAttributeTypeSMBHomeDrive
    @abstract   Drive letter for homedirectory mount point.
    @discussion Drive letter for homedirectory mount point.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBHomeDrive;

/*!
    @const		kODAttributeTypeSMBKickoffTime
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBKickoffTime;

/*!
    @const		kODAttributeTypeSMBLogoffTime
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBLogoffTime;

/*!
    @const		kODAttributeTypeSMBLogonTime
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBLogonTime;

/*!
    @const		kODAttributeTypeSMBPrimaryGroupSID
	@abstract   SMB Primary Group Security ID, stored as a string attribute of
				up to 64 bytes.
	@discussion SMB Primary Group Security ID, stored as a string attribute of
				up to 64 bytes. Found in user, group, and computer records
				(kODRecordTypeUsers, kODRecordTypeGroups, kODRecordTypeComputers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBPrimaryGroupSID;

/*!
    @const		kODAttributeTypeSMBPWDLastSet
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBPWDLastSet;

/*!
    @const		kODAttributeTypeSMBProfilePath
    @abstract   Desktop management info (dock, desktop links, etc).
    @discussion Desktop management info (dock, desktop links, etc).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBProfilePath;

/*!
    @const		kODAttributeTypeSMBRID
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBRID;

/*!
    @const		kODAttributeTypeSMBScriptPath
    @abstract   Login script path.
    @discussion Login script path.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBScriptPath;

/*!
    @const		kODAttributeTypeSMBSID
	@abstract   SMB Security ID, stored as a string attribute of up to 64 bytes.
	@discussion SMB Security ID, stored as a string attribute of up to 64 bytes.
				Found in user, group, and computer records (kODRecordTypeUsers, 
				kODRecordTypeGroups, kODRecordTypeComputers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBSID;

/*!
    @const		kODAttributeTypeSMBUserWorkstations
    @abstract   List of workstations user can login from (machine account names).
    @discussion List of workstations user can login from (machine account names).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBUserWorkstations;

/*!
    @const		kODAttributeTypeServiceType
	@abstract   Represents the service type for the service.  This is the raw service type of the
				service.
	@discussion Represents the service type for the service.  This is the raw service type of the
				service.  For example a service record type of kODRecordTypeWebServer 
				might have a service type of "http" or "https".
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeServiceType;

/*!
    @const		kODAttributeTypeSetupAdvertising
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupAdvertising;

/*!
    @const		kODAttributeTypeSetupAutoRegister
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupAutoRegister;

/*!
    @const		kODAttributeTypeSetupLocation
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupLocation;

/*!
    @const		kODAttributeTypeSetupOccupation
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupOccupation;

/*!
    @const		kODAttributeTypeTimeToLive
	@abstract   Attribute recommending how long to cache the record's attribute values.
	@discussion Attribute recommending how long to cache the record's attribute values.
				Format is an unsigned 32 bit representing seconds. ie. 300 is 5 minutes.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTimeToLive;

/*!
	@const		kODAttributeTypeTrustInformation
	@abstract	Used to describe a node's trust information.
	@discussion	Used to describe a node's trust information.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTrustInformation;

/*!
    @const		kODAttributeTypeUniqueID
	@abstract   This is the 32 bit unique ID that represents the user in the legacy manner.
	@discussion This is the 32 bit unique ID that represents the user in the legacy manner.
				Format is a signed integer represented as a string.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUniqueID;

/*!
    @const		kODAttributeTypeUserCertificate
	@abstract   Attribute containing the binary of the user's certificate.
	@discussion Attribute containing the binary of the user's certificate.
				Usually found in user records. The certificate is data which identifies a user.
				This data is attested to by a known party, and can be independently verified 
				by a third party.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserCertificate;

/*!
    @const		kODAttributeTypeUserPKCS12Data
	@abstract   Attribute containing binary data in PKCS #12 format. 
	@discussion Attribute containing binary data in PKCS #12 format. 
				Usually found in user records. The value can contain keys, certificates,
				and other related information and is encrypted with a passphrase.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserPKCS12Data;

/*!
    @const		kODAttributeTypeUserShell
    @abstract   Used to represent the user's shell setting.
    @discussion Used to represent the user's shell setting.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserShell;

/*!
    @const		kODAttributeTypeUserSMIMECertificate
	@abstract   Attribute containing the binary of the user's SMIME certificate.
	@discussion Attribute containing the binary of the user's SMIME certificate.
				Usually found in user records. The certificate is data which identifies a user.
				This data is attested to by a known party, and can be independently verified 
				by a third party. SMIME certificates are often used for signed or encrypted
				emails.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserSMIMECertificate;

/*!
    @const		kODAttributeTypeVFSDumpFreq
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSDumpFreq;

/*!
    @const		kODAttributeTypeVFSLinkDir
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSLinkDir;

/*!
    @const		kODAttributeTypeVFSPassNo
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSPassNo;

/*!
    @const		kODAttributeTypeVFSType
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSType;

/*!
    @const		kODAttributeTypeWeblogURI
	@abstract   attribute that defines the URI of a user's weblog.
	@discussion attribute that defines the URI of a user's weblog.
				Usually found in user records (kODRecordTypeUsers). 
				Example: http://example.com/blog/jsmith
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeWeblogURI;

/*!
    @const		kODAttributeTypeXMLPlist
    @abstract   XML plist used.
    @discussion XML plist used.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeXMLPlist;

/*!
    @const		kODAttributeTypeProtocolNumber
	@abstract   Attribute that defines a protocol number.
	@discussion Attribute that defines a protocol number.  Usually found
				in protocol records (kODRecordTypeProtocols)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeProtocolNumber;

/*!
    @const		kODAttributeTypeRPCNumber
	@abstract   Attribute that defines an RPC number.
	@discussion Attribute that defines an RPC number.  Usually found
				in RPC records (kODRecordTypeRPC)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRPCNumber;

/*!
    @const		kODAttributeTypeNetworkNumber
	@abstract   Attribute that defines a network number.
	@discussion Attribute that defines a network number.  Usually found
				in network records (kODRecordTypeNetworks)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetworkNumber;

/*!
    @const		kODAttributeTypeAccessControlEntry
    @abstract   Attribute type which stores directory access control directives.
    @discussion Attribute type which stores directory access control directives.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAccessControlEntry;

/*!
    @const		kODAttributeTypeAddressLine1
    @abstract   Line one of multiple lines of address data for a user.
    @discussion Line one of multiple lines of address data for a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAddressLine1;

/*!
    @const		kODAttributeTypeAddressLine2
    @abstract   Line two of multiple lines of address data for a user.
    @discussion Line two of multiple lines of address data for a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAddressLine2;

/*!
    @const		kODAttributeTypeAddressLine3
    @abstract   Line three of multiple lines of address data for a user.
    @discussion Line three of multiple lines of address data for a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAddressLine3;

/*!
    @const		kODAttributeTypeAreaCode
    @abstract   Area code of a user's phone number.
    @discussion Area code of a user's phone number.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAreaCode;

/*!
    @const		kODAttributeTypeAuthenticationAuthority
	@abstract   Determines what mechanism is used to verify or set a user's password.
	@discussion Determines what mechanism is used to verify or set a user's password.
				If multiple values are present, the first attributes returned take precedence.
				Typically found in User records (kODRecordTypeUsers).
 
				Authentication authorities are a multi-part string separated by semi-colons.
				One component is the "type" of authority, such as those listed below:
 
					"basic"					- is a crypt password
					"ShadowHash"			- is a hashed password stored in a secure location
					"ApplePasswordServer"	- is a password server-based account
					"Kerberosv5"			- is a Kerberosv5 based
					"LocalCachedUser"		- is a cached account based on an account from another node, using a ShadowHash password
					"DisabledUser"			- is an account that has been disabled
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthenticationAuthority;

/*!
    @const		kODAttributeTypeAutomountInformation
	@abstract   Determines what mechanism is used to verify or set a user's password.
	@discussion Determines what mechanism is used to verify or set a user's password.
				If multiple values are present, the first attributes returned take precedence.
				Typically found in User records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAutomountInformation;

/*!
    @const		kODAttributeTypeBootParams
    @abstract   Attribute type in host or machine records for storing boot params.
    @discussion Attribute type in host or machine records for storing boot params.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBootParams;

/*!
    @const		kODAttributeTypeBuilding
	@abstract   Represents the building name for a user or person record.
	@discussion Represents the building name for a user or person record.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBuilding;

/*!
    @const		kODAttributeTypeServicesLocator
    @abstract   the URI for a record's calendar
    @discussion the URI for a record's calendar
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeServicesLocator;

/*!
    @const		kODAttributeTypeCity
	@abstract   Usually, city for a user or person record.
	@discussion Usually, city for a user or person record.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCity;

/*!
    @const		kODAttributeTypeCompany
	@abstract   attribute that defines the user's company.
	@discussion attribute that defines the user's company.
				Example: Apple Inc.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCompany;

/*!
    @const		kODAttributeTypeComputers
    @abstract   List of computers.
    @discussion List of computers.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeComputers;

/*!
    @const		kODAttributeTypeCountry
	@abstract   Represents country of a record entry.
	@discussion Represents country of a record entry.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCountry;

/*!
    @const		kODAttributeTypeDepartment
	@abstract   Represents the department name of a user or person.
	@discussion Represents the department name of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDepartment;

/*!
    @const		kODAttributeTypeDNSName
    @abstract   DNS Resolver nameserver attribute.
    @discussion DNS Resolver nameserver attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDNSName;

/*!
    @const		kODAttributeTypeEMailAddress
    @abstract   Email address of usually a user record.
    @discussion Email address of usually a user record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeEMailAddress;

/*!
    @const		kODAttributeTypeEMailContacts
	@abstract   Attribute that defines a record's custom email addresses.
	@discussion Attribute that defines a record's custom email addresses.
				found in user records (kODRecordTypeUsers). 
				Example: home:johndoe\@mymail.com
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeEMailContacts;

/*!
    @const		kODAttributeTypeFaxNumber
	@abstract   Represents the FAX numbers of a user or person.
	@discussion Represents the FAX numbers of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFaxNumber;

/*!
    @const		kODAttributeTypeGroup
    @abstract   List of groups.
    @discussion List of groups.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroup;

/*!
    @const		kODAttributeTypeGroupMembers
    @abstract   Attribute type in group records containing lists of GUID values for members other than groups.
    @discussion Attribute type in group records containing lists of GUID values for members other than groups.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroupMembers;

/*!
    @const		kODAttributeTypeGroupMembership
    @abstract   Usually a list of users that below to a given group record.
    @discussion Usually a list of users that below to a given group record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroupMembership;

/*!
    @const		kODAttributeTypeGroupServices
	@abstract   xml-plist attribute that defines a group's services.
	@discussion xml-plist attribute that defines a group's services.
				Found in group records (kODRecordTypeGroups). 
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroupServices;

/*!
    @const		kODAttributeTypeHomePhoneNumber
    @abstract   Home telephone number of a user or person.
    @discussion Home telephone number of a user or person.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomePhoneNumber;

/*!
    @const		kODAttributeTypeHTML
    @abstract   HTML location.
    @discussion HTML location.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHTML;

/*!
    @const		kODAttributeTypeHomeDirectory
    @abstract   Network home directory URL.
    @discussion Network home directory URL.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeDirectory;

/*!
    @const		kODAttributeTypeIMHandle
	@abstract   Represents the Instant Messaging handles of a user.
	@discussion Represents the Instant Messaging handles of a user.
				Values should be prefixed with the appropriate IM type
				(i.e., AIM:, Jabber:, MSN:, Yahoo:, or ICQ:).
				Usually found in user records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIMHandle;

/*!
    @const		kODAttributeTypeIPAddress
    @abstract   IP address expressed either as domain or IP notation.
    @discussion IP address expressed either as domain or IP notation.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIPAddress;

/*!
    @const		kODAttributeTypeIPAddressAndENetAddress
	@abstract   A pairing of IPv4 or IPv6 addresses with Ethernet addresses 
	@discussion A pairing of IPv4 or IPv6 addresses with Ethernet addresses 
				(e.g., "10.1.1.1/00:16:cb:92:56:41").  Usually found on kODRecordTypeComputers for use by 
				services that need specific pairing of the two values.  This should be in addition to 
				kODAttributeTypeIPAddress, kODAttributeTypeIPv6Address and kODAttributeTypeENetAddress. This is
				necessary because not all directories return attribute values in a guaranteed order.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIPAddressAndENetAddress;

/*!
    @const		kODAttributeTypeIPv6Address
	@abstract   IPv6 address expressed in the standard notation
	@discussion IPv6 address expressed in the standard notation (e.g., "fe80::236:caff:fcc2:5641")
				Usually found on kODRecordTypeComputers and kODRecordTypeHosts.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIPv6Address;

/*!
    @const		kODAttributeTypeJPEGPhoto
	@abstract   Used to store binary picture data in JPEG format. 
	@discussion Used to store binary picture data in JPEG format. 
				Usually found in user, people or group records (kODRecordTypeUsers, 
				kODRecordTypePeople, kODRecordTypeGroups).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeJPEGPhoto;

/*!
    @const		kODAttributeTypeJobTitle
	@abstract   Represents the job title of a user.
	@discussion Represents the job title of a user.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeJobTitle;

/*!
    @const		kODAttributeTypeKDCAuthKey
    @abstract   KDC master key RSA encrypted with realm public key.
    @discussion KDC master key RSA encrypted with realm public key.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKDCAuthKey;

/*!
    @const		kODAttributeTypeKeywords
    @abstract   Keywords using for searching capability.
    @discussion Keywords using for searching capability.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKeywords;

/*!
    @const		kODAttributeTypeLDAPReadReplicas
    @abstract   List of LDAP server URLs which can each be used to read directory data.
    @discussion List of LDAP server URLs which can each be used to read directory data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLDAPReadReplicas;

/*!
    @const		kODAttributeTypeLDAPWriteReplicas
    @abstract   List of LDAP server URLs which can each be used to write directory data.
    @discussion List of LDAP server URLs which can each be used to write directory data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLDAPWriteReplicas;

/*!
    @const		kODAttributeTypeMapCoordinates
	@abstract   attribute that defines coordinates for a user's location.
	@discussion attribute that defines coordinates for a user's location .
				found in user records (kODRecordTypeUsers) and resource records (kODRecordTypeResources).
				Example: 7.7,10.6
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMapCoordinates;

/*!
    @const		kODAttributeTypeMapURI
	@abstract   attribute that defines the URI of a user's location.
	@discussion attribute that defines the URI of a user's location.
				Usually found in user records (kODRecordTypeUsers). 
				Example: http://example.com/bldg1
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMapURI;

/*!
    @const		kODAttributeTypeMIME
    @abstract   Data contained in this attribute type is a fully qualified MIME Type. 
    @discussion Data contained in this attribute type is a fully qualified MIME Type. 
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMIME;

/*!
    @const		kODAttributeTypeMobileNumber
	@abstract   Represents the mobile numbers of a user or person.
	@discussion Represents the mobile numbers of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMobileNumber;

/*!
    @const		kODAttributeTypeNestedGroups
    @abstract   Attribute type in group records for the list of GUID values for nested groups.
    @discussion Attribute type in group records for the list of GUID values for nested groups.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNestedGroups;

/*!
    @const		kODAttributeTypeNetGroups
	@abstract   Attribute type that indicates which netgroups its record is a member of.
	@discussion Attribute type that indicates which netgroups its record is a member of.
				Found in user and host records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetGroups;

/*!
    @const		kODAttributeTypeNickName
	@abstract   Represents the nickname of a user or person.
	@discussion Represents the nickname of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNickName;

/*!
    @const		kODAttributeTypeOrganizationInfo
    @abstract   Usually the organization info of a user.
    @discussion Usually the organization info of a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOrganizationInfo;

/*!
    @const		kODAttributeTypeOrganizationName
    @abstract   Usually the organization of a user.
    @discussion Usually the organization of a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOrganizationName;

/*!
    @const		kODAttributeTypePagerNumber
	@abstract   Represents the pager numbers of a user or person.
	@discussion Represents the pager numbers of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePagerNumber;

/*!
    @const		kODAttributeTypePhoneContacts
	@abstract   attribute that defines a record's custom phone numbers.
	@discussion attribute that defines a record's custom phone numbers.
				found in user or people records.
					Example: home fax:408-555-4444
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePhoneContacts;

/*!
    @const		kODAttributeTypePhoneNumber
    @abstract   Telephone number of a user.
    @discussion Telephone number of a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePhoneNumber;

/*!
    @const		kODAttributeTypePGPPublicKey
    @abstract   Pretty Good Privacy public encryption key.
    @discussion Pretty Good Privacy public encryption key.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePGPPublicKey;

/*!
    @const		kODAttributeTypePostalAddress
    @abstract   The postal address usually excluding postal code.
    @discussion The postal address usually excluding postal code.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePostalAddress;

/*!
    @const		kODAttributeTypePostalAddressContacts
	@abstract   attribute that defines a record's alternate postal addresses.
	@discussion attribute that defines a record's alternate postal addresses.
				Found in user records (kODRecordTypeUsers) and resource records (kODRecordTypeResources).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePostalAddressContacts;

/*!
    @const		kODAttributeTypePostalCode
    @abstract   The postal code such as zip code in the USA.
    @discussion The postal code such as zip code in the USA.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePostalCode;

/*!
    @const		kODAttributeTypeNamePrefix
	@abstract   Represents the title prefix of a user or person.
	@discussion Represents the title prefix of a user or person.
				ie. Mr., Ms., Mrs., Dr., etc.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNamePrefix;

/*!
    @const      kODAttributeTypeProfiles
    @abstract   Profiles associated with the record.
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeProfiles __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODAttributeTypeProfilesTimestamp
    @abstract   Timestamp for the profiles associated with the record.
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeProfilesTimestamp __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const		kODAttributeTypeProtocols
    @abstract   List of protocols.
    @discussion List of protocols.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeProtocols;

/*!
    @const		kODAttributeTypeRecordName
    @abstract   List of names/keys for this record.
    @discussion List of names/keys for this record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecordName;

/*!
    @const		kODAttributeTypeRelationships
	@abstract   attribute that defines the relationship to the record type.
	@discussion attribute that defines the relationship to the record type.
				found in user records (kODRecordTypeUsers). 
					Example: brother:John
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRelationships;

/*!
    @const		kODAttributeTypeResourceInfo
    @abstract   attribute that defines a resource record's info.
    @discussion attribute that defines a resource record's info.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeResourceInfo;

/*!
    @const		kODAttributeTypeResourceType
	@abstract   Attribute type for the kind of resource. 
	@discussion Attribute type for the kind of resource. 
				found in resource records (kODRecordTypeResources). 
					Example: ConferenceRoom
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeResourceType;

/*!
    @const		kODAttributeTypeState
    @abstract   The state or province of a country.
    @discussion The state or province of a country.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeState;

/*!
    @const		kODAttributeTypeStreet
	@abstract   Represents the street address of a user or person.
	@discussion Represents the street address of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeStreet;

/*!
    @const		kODAttributeTypeNameSuffix
	@abstract   Represents the name suffix of a user or person.
	@discussion Represents the name suffix of a user or person.
				i.e., Jr., Sr., etc.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNameSuffix;

/*!
    @const		kODAttributeTypeURL
    @abstract   List of URLs.
    @discussion List of URLs.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeURL;

/*!
    @const		kODAttributeTypeVFSOpts
    @abstract   Used in support of mount records.
    @discussion Used in support of mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSOpts;

/*!
    @const		kODAttributeTypeAlias
    @abstract   Alias attribute, contain pointer to another node/record/attribute.
    @discussion Alias attribute, contain pointer to another node/record/attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAlias;

/*!
    @const		kODAttributeTypeAuthCredential
    @abstract   An authentication credential, to be used to authenticate to a Directory.
    @discussion An authentication credential, to be used to authenticate to a Directory.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthCredential;

/*!
    @const		kODAttributeTypeCopyTimestamp
    @abstract   Timestamp used in local account caching.
    @discussion Timestamp used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCopyTimestamp;

/*!
    @const		kODAttributeTypeDateRecordCreated
    @abstract   Date of record creation.
    @discussion Date of record creation.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDateRecordCreated;

/*!
    @const		kODAttributeTypeKerberosRealm
    @abstract   Supports Kerberized SMB Server services.
    @discussion Supports Kerberized SMB Server services.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKerberosRealm;

/*!
    @const		kODAttributeTypeNTDomainComputerAccount
    @abstract   Supports Kerberized SMB Server services.
    @discussion Supports Kerberized SMB Server services.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNTDomainComputerAccount;

/*!
    @const		kODAttributeTypeOriginalHomeDirectory
    @abstract   Home directory URL used in local account caching.
    @discussion Home directory URL used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOriginalHomeDirectory;

/*!
    @const		kODAttributeTypeOriginalNFSHomeDirectory
    @abstract   NFS home directory used in local account caching.
    @discussion NFS home directory used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOriginalNFSHomeDirectory;

/*!
    @const		kODAttributeTypeOriginalNodeName
    @abstract   Nodename used in local account caching.
    @discussion Nodename used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOriginalNodeName;

/*!
    @const		kODAttributeTypePrimaryNTDomain
    @abstract   Supports Kerberized SMB Server services.
    @discussion Supports Kerberized SMB Server services.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryNTDomain;

/*!
    @const		kODAttributeTypePwdAgingPolicy
    @abstract   Contains the password aging policy data for an authentication capable record.
    @discussion Contains the password aging policy data for an authentication capable record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePwdAgingPolicy;

/*!
    @const		kODAttributeTypeReadOnlyNode
	@abstract   Can be found using dsGetDirNodeInfo and will return one of
				ReadOnly, ReadWrite, or WriteOnly strings.
	@discussion Can be found using dsGetDirNodeInfo and will return one of
				ReadOnly, ReadWrite, or WriteOnly strings.
				Note that ReadWrite does not imply fully readable or writable
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeReadOnlyNode;

/*!
    @const		kODAttributeTypeTimePackage
    @abstract   Data of Create, Modify, Backup time in UTC.
    @discussion Data of Create, Modify, Backup time in UTC.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTimePackage;

/*!
    @const		kODAttributeTypeTotalSize
    @abstract   checksum/meta data.
    @discussion checksum/meta data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTotalSize;

/*!
    @const		kODAttributeTypeAuthMethod
    @abstract   Authentication method for an authentication capable record.
    @discussion Authentication method for an authentication capable record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthMethod;

/*!
    @const		kODAttributeTypeMetaNodeLocation
    @abstract   Meta attribute returning registered node name by directory node plugin.
    @discussion Meta attribute returning registered node name by directory node plugin.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaNodeLocation;

/*!
    @const		kODAttributeTypeNodePath
	@abstract   Attribute type in Neighborhood records describing the DS Node to search while
				looking up aliases in this neighborhood.
	@discussion Attribute type in Neighborhood records describing the DS Node to search while
				looking up aliases in this neighborhood.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNodePath;

/*!
    @const		kODAttributeTypePlugInInfo
	@abstract   Information (version, signature, about, credits, etc.) about the plug-in
				that is actually servicing a particular directory node.
	@discussion Information (version, signature, about, credits, etc.) about the plug-in
				that is actually servicing a particular directory node.
				Has never been supported.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePlugInInfo;

/*!
    @const		kODAttributeTypeRecordType
    @abstract   Attribute for a Record or a Directory Node.
    @discussion Attribute for a Record or a Directory Node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecordType;

/*!
    @const		kODAttributeTypeSchema
    @abstract   List of attribute types.
    @discussion List of attribute types.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSchema;

/*!
    @const		kODAttributeTypeSubNodes
	@abstract   Attribute of a node which lists the available subnodes
				of that node.
	@discussion Attribute of a node which lists the available subnodes
				of that node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSubNodes;

/*!
    @const		kODAttributeTypeNetGroupTriplet
	@abstract   Attribute that defines the host, user and domain triplet combinations
				to support NetGroups.  Each attribute value is comma separated string to maintain the
				triplet (e.g., host,user,domain).
	@discussion Attribute that defines the host, user and domain triplet combinations
				to support NetGroups.  Each attribute value is comma separated string to maintain the
				triplet (e.g., host,user,domain).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetGroupTriplet;

/*!
    @const		kODAttributeTypeSearchPath
    @abstract   Search path used by the search node.
    @discussion Search path used by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSearchPath;

/*!
    @const		kODAttributeTypeSearchPolicy
    @abstract   Search policy for the search node.
    @discussion Search policy for the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSearchPolicy;

/*!
    @const		kODAttributeTypeAutomaticSearchPath
    @abstract   Automatic search path defined by the search node.
    @discussion Automatic search path defined by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAutomaticSearchPath;

/*!
    @const		kODAttributeTypeLocalOnlySearchPath
    @abstract   Local only search path defined by the search node.
    @discussion Local only search path defined by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocalOnlySearchPath;

/*!
    @const		kODAttributeTypeCustomSearchPath
    @abstract   Admin user configured custom search path defined by the search node.
    @discussion Admin user configured custom search path defined by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCustomSearchPath;

/*!
    @const      kODAttributeTypeNodeOptions
    @abstract   Any extended options supported by the node during creation
    @discussion Any extended options supported by the node during creation
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeOptions __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
    @const      kODAttributeTypeNodeSASLRealm
    @abstract   Contains the SASL realm associated with this node (if any)
    @discussion Contains the SASL realm associated with this node (if any)
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeSASLRealm __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
	@const		kODAttributeTypeAdvertisedServices
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAdvertisedServices __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeLocaleRelay
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocaleRelay __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeLocaleSubnets
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocaleSubnets __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeNetworkInterfaces
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetworkInterfaces __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeParentLocales
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeParentLocales __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypePrimaryLocale
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryLocale __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

#pragma mark Attribute Types (Configure Node)

/*!
    @const		kODAttributeTypeBuildVersion
    @abstract   Build version for reference.
    @discussion Build version for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBuildVersion;

/*!
    @const		kODAttributeTypeConfigAvail
    @abstract   Config avail tag.
    @discussion Config avail tag.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeConfigAvailable;

/*!
    @const		kODAttributeTypeConfigFile
    @abstract   Config file name.
    @discussion Config file name.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeConfigFile;

/*!
    @const		kODAttributeTypeCoreFWVersion
    @abstract   Core FW version for reference.
    @discussion Core FW version for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCoreFWVersion;

/*!
    @const		kODAttributeTypeFunctionalState
    @abstract   Functional state of plugin for example.
    @discussion Functional state of plugin for example.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFunctionalState;

/*!
    @const		kODAttributeTypeFWVersion
    @abstract   Framework version for reference.
    @discussion Framework version for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFWVersion;

/*!
    @const		kODAttributeTypePluginIndex
    @abstract   Plugin index for reference.
    @discussion Plugin index for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePluginIndex;

/*!
    @const		kODAttributeTypeNumTableList
    @abstract   Summary of the reference table entries presented as attribute values 
				from the Configure node.
    @discussion Summary of the reference table entries presented as attribute values
				from the Configure node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNumTableList;

/*!
    @const		kODAttributeTypeVersion
    @abstract   Version label.
    @discussion Version label.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVersion;

/*!
    @const		kODAttributeTypePIDValue
    @abstract   PID value.
    @discussion PID value.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePIDValue;

/*!
    @const		kODAttributeTypeProcessName
    @abstract   Process Name.
    @discussion Process Name.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeProcessName;

/*!
    @const		kODAttributeTypeTotalRefCount
    @abstract   Total count of references for a process.
    @discussion Total count of references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTotalRefCount;

/*!
    @const		kODAttributeTypeDirRefCount
    @abstract   Directory reference count for a process.
    @discussion Directory reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDirRefCount;

/*!
    @const		kODAttributeTypeNodeRefCount
    @abstract   Node reference count for a process.
    @discussion Node reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeRefCount;

/*!
    @const		kODAttributeTypeRecRefCount
    @abstract   Record reference count for a process.
    @discussion Record reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecRefCount;

/*!
    @const		kODAttributeTypeAttrListRefCount
    @abstract   Attribute List reference count for a process.
    @discussion Attribute List reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListRefCount;

/*!
    @const		kODAttributeTypeAttrListValueRefCount
    @abstract   Attr List Value reference count for a process.
    @discussion Attr List Value reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListValueRefCount;

/*!
    @const		kODAttributeTypeDirRefs
    @abstract   All the directory references for a process.
    @discussion All the directory references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDirRefs;

/*!
    @const		kODAttributeTypeNodeRefs
    @abstract   All the node references for a process.
    @discussion All the node references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeRefs;

/*!
    @const		kODAttributeTypeRecRefs
    @abstract   All the record references for a process.
    @discussion All the record references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecRefs;

/*!
    @const		kODAttributeTypeAttrListRefs
    @abstract   All the attribute list references for a process.
    @discussion All the attribute list references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListRefs;

/*!
    @const		kODAttributeTypeAttrListValueRefs
    @abstract   All the attribute list value references for a process.
    @discussion All the attribute list value references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListValueRefs;

#pragma mark Authentication Types

/*!
    @const		kODAuthenticationType2WayRandom
	@abstract   Two way random authentication method.
	@discussion Two way random authentication method. This method uses two passes to
				complete the authentication.

				First pass authentication array has items:
					user name in UTF8 encoding

				Second pass authentication array has items:
					8 byte DES digest,
					8 bytes of random
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationType2WayRandom;

/*!
    @const		kODAuthenticationType2WayRandomChangePasswd
	@abstract   Change the password for a user using the two-way random method.
	@discussion Change the password for a user using the two-way random method.
				Does not require prior authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					old password encrypted with new (should be 8 chars),
					new password encrypted with old (should be 8 chars)
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationType2WayRandomChangePasswd;

/*!
    @const		kODAuthenticationTypeAPOP
	@abstract   APOP authentication method.
	@discussion APOP authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge in UTF8 encoding,
					client response in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeAPOP;

/*!
    @const		kODAuthenticationTypeCRAM_MD5
	@abstract   CRAM MD5 authentication method.
	@discussion CRAM MD5 authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge in UTF8 encoding,
					client response data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeCRAM_MD5;

/*!
    @const		kODAuthenticationTypeChangePasswd
	@abstract   Change the password for a user.
	@discussion Change the password for a user. Does not require prior authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					old password in UTF8 encoding,
					new password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeChangePasswd;

/*!
    @const		kODAuthenticationTypeClearText
	@abstract   Clear text authentication method.
	@discussion Clear text authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeClearText;

/*!
    @const		kODAuthenticationTypeCrypt
	@abstract   Use a crypt password stored in the user record if available to
				do the authentication.
	@discussion Use a crypt password stored in the user record if available to
				do the authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding

				This method may not be supported by all plug-ins or for all users.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeCrypt;

/*!
    @const		kODAuthenticationTypeDIGEST_MD5
	@abstract   Digest MD5 authentication method.
	@discussion Digest MD5 authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge in UTF8 encoding,
					client response data,
					HTTP method in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeDIGEST_MD5;

/*!
    @const		kODAuthenticationTypeDeleteUser
	@abstract   Used for Apple password server user deletion.
	@discussion Used for Apple password server user deletion.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					Password Server ID in UTF8 encoding,
					authenticator password in UTF8 encoding,
					user's Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeDeleteUser;

/*!
    @const		kODAuthenticationTypeGetEffectivePolicy
	@abstract   Used to extract, from a password server, the actual policies that will be applied
				to a user; a combination of global and user policies.
	@discussion Used to extract, from a password server, the actual policies that will be applied
				to a user; a combination of global and user policies.

				Authentication array has following items in order:
					user name or Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetEffectivePolicy;

/*!
    @const		kODAuthenticationTypeGetGlobalPolicy
	@abstract   Used for extraction of global authentication policy.
	@discussion Used for extraction of global authentication policy. Authentication
				is not required to get policies. The authenticator name and password
				fields are optional.

				Authentication array has following items in order:
					user name in UTF8 encoding
					password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetGlobalPolicy;

/*!
    @const		kODAuthenticationTypeGetKerberosPrincipal
	@abstract   Retrieves Kerberos Principal name.
	@discussion Retrieves Kerberos Principal name.

				Authentication array has following items in order:
					user name in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetKerberosPrincipal;

/*!
    @const		kODAuthenticationTypeGetPolicy
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.
				Authentication is not required to get policies. The authenticator name and password
				fields may be left blank by using a length of 1 and a zero-byte for the data.

				Authentication array has following items in order:
					authenticator's name or Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding
					account's name or Password Server ID

				The Password Server does not require authentication for this authentication method.
				The first two fields are to cover us for future policy changes and to keep the buffer
				format as standardized as possible.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetPolicy;

/*!
    @const		kODAuthenticationTypeGetUserData
	@abstract   Used with Apple password server.
	@discussion Used with Apple password server. The password server maintains a space
				for a small amount of miscellaneous data.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding
					Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetUserData;

/*!
    @const		kODAuthenticationTypeGetUserName
	@abstract   Used with Apple password server.
	@discussion Used with Apple password server. This name is the same as the primary
				short name for the user.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					user's Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetUserName;

/*!
    @const		kODAuthenticationTypeKerberosTickets
	@abstract   Provides write-access to LDAP with an existing Kerberos ticket.
	@discussion Provides write-access to LDAP with an existing Kerberos ticket

				Authentication array has following items in order:
					user name in UTF8 encoding,
					krb5_data containing a service ticket
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeKerberosTickets;

/*!
    @const		kODAuthenticationTypeMPPEMasterKeys
	@abstract   Generated 40-bit or 128-bit master keys from MS-CHAPv2 credentials (RFC 3079).
	@discussion Generated 40-bit or 128-bit master keys from MS-CHAPv2 credentials (RFC 3079).

				Authentication array has following items in order:
					user name in UTF8 encoding,
					MS-CHAPv2 digest (P24),
					key size, 8 or 16 (packed as a byte, not a string)
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeMPPEMasterKeys;

/*!
    @const		kODAuthenticationTypeMSCHAP2
	@abstract	MS-CHAP2 is a mutual authentication method.
	@discussion	MS-CHAP2 is a mutual authentication method. The plug-in will generate the data to
				send back to the client and put it in the continue items array.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge,
					peer challenge,
					client's digest,
					client's user name (the name used for MS-CHAPv2, usually the first short name)

				Continue items array contains:
					digest for the client's challenge
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeMSCHAP2;

/*!
    @const		kODAuthenticationTypeNTLMv2
	@abstract   Verifies an NTLMv2 challenge and response.
	@discussion Verifies an NTLMv2 challenge and response. The session keys
				(if any) must be retrieved separately with a trusted authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					SMB server challenge,
					the client "blob" which includes 16 bytes of client digest prefixed
						to the the blob data,
					the user name used to calculate the digest in UTF8 encoding,
					the SMB domain in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNTLMv2;

/*!
    @const		kODAuthenticationTypeNTLMv2WithSessionKey
	@abstract   An optimized method that checks the user's challenge and response
				and retrieves session keys in a single call.
	@discussion An optimized method that checks the user's challenge and response
				and retrieves session keys in a single call. If the NTLMv2 session key is
				supported, it is returned in the step buffer.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					SMB server challenge,
					the client "blob" which includes 16 bytes of client digest prefixed
						to the the blob data,
					the user name used to calculate the digest  in UTF8 encoding,
					the SMB domain in UTF8 encoding,
					user name in UTF8 encoding,
					authenticator password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNTLMv2WithSessionKey;

/*!
    @const		kODAuthenticationTypeNewUser
	@abstract	Create a new user record with the authentication authority.
	@discussion	Create a new user record with the authentication authority
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					user's short-name,
					user's password
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNewUser;

/*!
    @const		kODAuthenticationTypeNewUserWithPolicy
	@abstract	Create a new user record with the authentication authority and initial policy settings.
	@discussion	Create a new user record with the authentication authority and initial policy settings
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					user's short-name,
					user's password,
					policy string in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNewUserWithPolicy;

/*!
    @const		kODAuthenticationTypeNodeNativeClearTextOK
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding

				The plug-in may choose to use a cleartext authentication method if necessary.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNodeNativeClearTextOK;

/*!
    @const		kODAuthenticationTypeNodeNativeNoClearText
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding

				The plug-in must not use an authentication method that sends the password in cleartext.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNodeNativeNoClearText;

/*!
    @const		kODAuthenticationTypeReadSecureHash
	@abstract   Returns the SHA1 or Seeded SHA1 hash for a local user.
	@discussion Returns the SHA1 or Seeded SHA1 hash for a local user
				Only accessible by root processes. Only implemented by the local node.

				Authentication array has following items in order:
					user's name in UTF8 encoding

				Continue items array contains:
					value, either the old 20-byte SHA1 or the new seeded 24-byte SHA1.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeReadSecureHash;

/*!
    @const		kODAuthenticationTypeSMBNTv2UserSessionKey
	@abstract   Generate the ntlm-v2 user session key.
	@discussion Generate the ntlm-v2 user session key. Requires prior authentication with a trusted
				authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge
					client response buffer
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMBNTv2UserSessionKey;

/*!
    @const		kODAuthenticationTypeSMBWorkstationCredentialSessionKey
    @abstract   Generates an SMB workstation credential session key.
    @discussion Generates an SMB workstation credential session key.
 
				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge + 8 byte client challenge
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMBWorkstationCredentialSessionKey;

/*!
    @const		kODAuthenticationTypeSMB_LM_Key
	@abstract   SMB Lan Manager authentication method.
	@discussion SMB Lan Manager authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge,
					24 byte client response
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_LM_Key;

/*!
    @const		kODAuthenticationTypeSMB_NT_Key
	@abstract   SMB NT authentication method.
	@discussion SMB NT authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge,
					24 byte client response
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_NT_Key;

/*!
    @const		kODAuthenticationTypeSMB_NT_UserSessionKey
	@abstract   Used by SMB to get session keys.
	@discussion Used by SMB to get session keys
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					Password Server ID in UTF8 encoding

				Continue items array contains:
					MD4( ntHash )
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_NT_UserSessionKey;

/*!
    @const		kODAuthenticationTypeSMB_NT_WithUserSessionKey
	@abstract   Used by SMB to authenticate and get session keys.
	@discussion Used by SMB to authenticate and get session keys

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge,
					24 byte client response,
					authenticator name in UTF8 encoding,
					authenticator password in UTF8 encoding

				Continue items array contains:
					MD4( ntHash )
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_NT_WithUserSessionKey;

/*!
    @const		kODAuthenticationTypeSecureHash
	@abstract   Authentication specifically using the secure hash.
	@discussion Authentication specifically using the secure hash.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					salted SHA1 hash
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSecureHash __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_7, __IPHONE_NA, __IPHONE_NA);

/*!
	@const		kODAuthenticationTypeSetCertificateHashAsCurrent
	@abstract	Set certificate using the authenticated user's credentials.
	@discussion	Set certificate using the authenticated user's credentials.

				Authentication array has the following items in order:
					user name in UTF8 encoding
					hashed certificate data (40 hex characters)
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetCertificateHashAsCurrent __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
    @const		kODAuthenticationTypeSetGlobalPolicy
	@abstract   Used to set the global policy.
	@discussion Used to set the global policy.

				Authentication array has following items in order:
					user name or Password Server ID in UTF8 encoding,
					password in UTF8 encoding,
					policy string in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetGlobalPolicy;

/*!
    @const		kODAuthenticationTypeSetLMHash
	@abstract   Set the LAN Manager hash for an account.
	@discussion Set the LAN Manager hash for an account. This method requires prior authentication.
				Setting the LM hash for an account instead of the plain text password can cause the Windows
				password to get out-of-sync with the password for other services. Therefore, this
				authentication method should only be used when there is no other choice.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					LAN Manager hash buffer
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetLMHash;

/*!
    @const		kODAuthenticationTypeSetNTHash
	@abstract   Set the NT hash for a user.
	@discussion Set the NT hash for a user. This method requires prior authentication.
				Setting the NT hash for an account instead of the plain text password can cause the Windows
				password to get out-of-sync with the password for other services. Therefore, this
				authentication method should only be used when there is no other choice.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					NT hash buffer
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetNTHash;

/*!
    @const		kODAuthenticationTypeSetPassword
	@abstract   Set password method.
	@discussion Set password method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					new password in UTF8 encoding,
					authenticator's name in UTF8 encoding,
					authenticator's password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPassword;

/*!
    @const		kODAuthenticationTypeSetPasswordAsCurrent
	@abstract   Set password using the current credentials.
	@discussion Set password using the current credentials.
 
				Authentication array has following items in order:
					user name in UTF8 encoding,
					new password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPasswordAsCurrent;

/*!
    @const		kODAuthenticationTypeSetPolicy
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.

				Authentication array has following items in order:
					authenticator's name or Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					name or Password Server ID of the target account in UTF8 encoding,
					policy data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPolicy;

/*!
    @const		kODAuthenticationTypeSetPolicyAsCurrent
	@abstract   A set policy for the password server.
	@discussion A set policy for the password server.

				Authentication array has following items in order:
					user name or Password Server ID of the target account in UTF8 encoding,
					policy data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPolicyAsCurrent;

/*!
    @const		kODAuthenticationTypeSetUserData
	@abstract   Used for Apple password server.
	@discussion Used for Apple password server.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					Password Server ID in UTF8 encoding,
					user data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetUserData;

/*!
    @const		kODAuthenticationTypeSetUserName
	@abstract   Used for Apple password server.
	@discussion Used for Apple password server.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					Password Server ID in UTF8 encoding,
					user's short name in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetUserName;

/*!
    @const		kODAuthenticationTypeSetWorkstationPassword
	@abstract   Supports PDC SMB interaction with DS.
	@discussion Supports PDC SMB interaction with DS.
 
				Authentication array has following items in order:
					workstation's Password Server ID in UTF8 encoding,
					NT hash
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetWorkstationPassword;

/*!
    @const		kODAuthenticationTypeWithAuthorizationRef
	@abstract	Allows access to local directories as root with a valid AuthorizationRef.
	@discussion	Allows access to local directories as root with a valid AuthorizationRef.

				Authentication array has following items in order:
					externalized AuthorizationRef
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeWithAuthorizationRef;

/*!
    @const		kODAuthenticationTypeWriteSecureHash
	@abstract	Supports ONLY a root process to be able to directly write the secure hash of a user record.
	@discussion	Supports ONLY a root process to be able to directly write the secure hash of a user record.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					salted SHA1 hash
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeWriteSecureHash;

#pragma mark Policy Types

/*!
    @const      kODPolicyTypePasswordCannotBeAccountName
    @abstract   Boolean signifying the password must not contain the name of the account.
    @discussion Boolean signifying the password must not contain the name of the account.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordCannotBeAccountName __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordChangeRequired
    @abstract   Boolean stating the password should be changed on next logon.
    @discussion Should be set to a CFBooleanRef/NSNumber accordingly to signify the password should be changed at next logon.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordChangeRequired __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordHistory
    @abstract   The number of previous passwords that will be remembered.
    @discussion Should be set with a CFNumber/NSNumber accordingly with a range of 1 to 15 passwords.  Remove this policy or
                set to 0 if no history is tracked.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordHistory __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMinimumNumberOfCharacters
    @abstract   The minimum number of characters a password must contain.
    @discussion A CFNumber/NSNumber signifying the minimum number of characters a password must contain.
 */
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordMinimumNumberOfCharacters __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMaximumNumberOfCharacters
    @abstract   The maximum number of characters a password can contain.
    @discussion A CFNumber/NSNumber signifying the maximum number of characters a password can contain.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordMaximumNumberOfCharacters __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMaximumAgeInMinutes
    @abstract   Number of minutes before password must be changed.
    @discussion The value for the policy should be a CFNumberRef/NSNumber accordingly.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordMaximumAgeInMinutes __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresAlpha
    @abstract   Sets the number of alpha characters that must present in the password.
    @discussion A CFNumber/NSNumber signifying the number of alpha characters [A-Z][a-z] that must be present in the password.
                Note, not all modules will support this capability.  If you exceed the module's capabilities, it will reset to
                the maximum supported by that module.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresAlpha __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresMixedCase
    @abstract   Boolean signifying if password requires mixed case characters both upper and lower characters.
    @discussion Boolean signifying if password requires mixed case characters both upper and lower characters.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresMixedCase __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresNumeric
    @abstract   Sets the number of numeric characters that must present in the password.
    @discussion A CFNumber/NSNumber signifying the number of numeric characters [0-9] that must be present in the password.
                Note, not all modules will support this capability.  If you exceed the module's capabilities, it will reset to
                the maximum supported by that module.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresNumeric __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresSymbol
    @abstract   Sets the number of symbol characters that must present in the password.
    @discussion A CFNumber/NSNumber signifying the number of symbol characters that must be present in the password.
                Note, not all modules will support this capability.  If you exceed the module's capabilities, it will reset to
                the maximum supported by that module.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresSymbol __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordSelfModification
    @abstract   Boolean stating if the account is allowed to change their own password.
    @discussion Should be set to a CFBooleanRef/NSNumber accordingly to signify the if the account holder is allowed to change
                their own password.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordSelfModification __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeAccountExpiresOnDate
    @abstract   Date when an account expires and becomes deactivated.
    @discussion A CFDate/NSDate signifying when an account expires will be deactivated.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountExpiresOnDate __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeAccountMaximumFailedLogins
    @abstract   Sets the number of maximum failed logins allowed for the account.
    @discussion A CFNumber/NSNumber signifying the number of times a bad password can be entered before the account is locked out.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMaximumFailedLogins __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeAccountMaximumMinutesUntilDisabled
    @abstract   Sets the number of maximum number of minutes before this account is disabled automatically from password set.
    @discussion A CFNumber/NSNumber signifying the number of minutes before the account should be auto-disabled.  Note,
                calculation of this is based on timestamp of the password, therefore also preventing the password from
                being changed is required.
 */
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMaximumMinutesUntilDisabled __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMinutesUntilFailedLoginReset
    @abstract   Number of minutes before an account locked out by bad passwords is automatically re-activated.
    @discussion The value for the policy should be a CFNumberRef/NSNumber accordingly.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMinutesUntilFailedLoginReset __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeMaximumMinutesOfNonUse
    @abstract   Maximum number of minutes that an account has not been used before it is deactivated.
    @discussion A CFNumber/NSNumber signifying the number of minutes before an account has not been used before it is deactivated.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMaximumMinutesOfNonUse __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
   @enum        Expiration constants
   @abstract    Special values that may be returned by ODRecordSecondsUntil*Expires().
   @constant    kODExpirationTimeExpired indicates the password or authentication
                has expired.
   @constant    kODExpirationTimeNeverExpires indicates the password or
                authentication will never expire. 
*/
enum {
    kODExpirationTimeExpired      = 0LL,
    kODExpirationTimeNeverExpires = -1LL,
};

/*!
    @typedef    kODPolicyKeyType
    @abstract   Type for the keys in a policy dictionary.
    @discussion Type for the keys in a policy dictionary.  These are the
                expected keys in a policy.  Some keys are optional.  For more
                information see the the specific key.  Some keys are used in
                individual policies, others in a policy set.
*/
#ifdef __OBJC__
typedef NSString *ODPolicyKeyType;
#else
typedef CFStringRef ODPolicyKeyType;
#endif

/*!
    @const      kODPolicyKeyIdentifier
    @abstract   Key for the policy identifier in a policy dictionary.
    @discussion Key for the policy identifier in a policy dictionary.  Required
                key in a policy dictionary.  The value of this key is a string
                that uniquely identifies the policy.  It can be anything from a
                GUID to a string that describes the policy (e.g. "max num chars"). 
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyIdentifier __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyKeyParameters
    @abstract   Key for the policy parameters, if any, in a policy dictionary.
    @discussion Key for the policy parameters, if any, in a policy dictionary.
                Optional key in a policy dictionary.  The value of this key is a
                dictionary containing any parameters that are relevant to the
                policy.  Parameters may be used for information purposes or to
                provide additional data to be used in the policy format string.
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyParameters __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyKeyContent
    @abstract   Key for the policy format string in a policy dictionary.
    @discussion Key for the policy format string in a policy dictionary.
                Required key in a policy dictionary.  The value of this key is a
                string containing the policy itself, from which a predicate will
                be created.  The predicate will be applied during policy
                evaluation. 
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyContent __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyKeyContentDescription
    @abstract   Key for the policy content description.
    @discussion Key for the policy content description.  Used in either a policy
                dictionary or in kODPolicyKeyEvaluationDetails dictionary.  It
                is an optional key in either dictionary.

                When used in a policy dictionary, the value of this key is a
                dictionary containing key/value pairs consisting of locale
                identifiers and localized descriptions of the policy content.

                When used in kODPolicyKeyEvaluationDetails dictionary, the value
                is a string containing the localized description of the policy
                content.
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyContentDescription __OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_NA);

/*!
    @const      kODPolicyKeyEvaluationDetails
    @abstract   Key containing details of the policy evaluation results.
    @discussion Key containing details of the policy evaluation results.  This
                key may be used in the userInfo portion of a CFErrorRef/NSError.
                The value of this key is an array of dictionaries, with each
                dictionary containing the results of an individual policy
                evaluation.  The keys in the details dictionaries are:
                   kODPolicyKeyIdentifier
                   kODPolicyKeyContentDescription
                   kODPolicyKeyPolicySatisfied
*/
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyEvaluationDetails __OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_NA);

/*!
    @const      kODPolicyKeyPolicySatisfied
    @abstract   Key denoting if a specific policy was satisfied during evaluation.
    @discussion Key denoting if a specific policy was satisfied during evaluation.
                This key is used in the dictionaries in kODPolicyKeyEvaluationDetails.
                The value of this key will be true if the specific policy was
                satisfied and false if not.
*/
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyPolicySatisfied __OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_NA);

/*!
    @typedef    ODPolicyCategoryType
    @abstract   Type for the policy categories.
    @discussion Type for the policy categories.  Policy categories are also keys
                in a policy set dictionary, where the value of each category is
                an array of policy dictionaries.
*/
#ifdef __OBJC__
typedef NSString *ODPolicyCategoryType;
#else
typedef CFStringRef ODPolicyCategoryType;
#endif

/*!
    @const      kODPolicyCategoryAuthentication
    @abstract   Category for policies controlling when authentications are allowed.
    @discussion Category for policies controlling when authentications are allowed.  
                Policies in this category are evaluated when determining if an
                authentication should be allowed or when authentications will
                expire.  This constant is also used as a key in a policy set
                dictionary with a value containing an array of policy
                dictionaries. 
 */
CF_EXPORT
ODPolicyCategoryType kODPolicyCategoryAuthentication __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyCategoryPasswordContent
    @abstract   Category for policies controlling content of passwords.
    @discussion Category for policies controlling content of passwords.
                Policies in this category are evaluated when determining if a
                password contains the required content, which is typically done
                during password changes.  This constant is also used as a key in
                a policy set dictionary with a value containing an array of
                policy dictionaries.
 */
CF_EXPORT
ODPolicyCategoryType kODPolicyCategoryPasswordContent __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyCategoryPasswordChange
    @abstract   Category for policies controlling when password require changing.
    @discussion Category for policies controlling when password require changing.
 */
CF_EXPORT
ODPolicyCategoryType kODPolicyCategoryPasswordChange __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


/*!
    @typedef    kODPolicyAttributeType
    @abstract   Type for attributes that may be used in policies.
    @discussion Type for attributes that may be used in policies.  Policies in
                this category will be evaluated when determining if an
                authentication should be allowed or when determine when a
                password will expire.  This constant is also used as a key in a
                policy set dictionary with a value containing an array of policy
                dictionaries. 
*/
#ifdef __OBJC__
typedef NSString *ODPolicyAttributeType;
#else
typedef CFStringRef ODPolicyAttributeType;
#endif

/*!
    @const      kODPolicyAttributeRecordName
    @abstract   Policy attribute for the record name.
    @discussion Policy attribute for the record name.  May be used in policies
                to compare against other record attributes.  For example, this
                Password Content policy string prevents the password from being
                the same as the record name:
                    [NSString stringWithFormat:@"%@ != %@", kODPolicyAttributeRecordName, kODPolicyAttributePassword];
 */
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeRecordName __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeRecordType
    @abstract   Policy attribute for the record type.
    @discussion Policy attribute for the record type.  Could be used in policies
                to tailor behavior for a particular record type.  For example,
                this Password Content policy string would require computer
                passwords to be a minimum of 24 characters long:
                    [NSString stringWithFormat:@"%@ == %@ and %@ matches '.{24,}+'",
                              kODPolicyAttributeRecordType, kODRecordTypeComputer,
                              kODPolicyAttributePassword]; 
 */
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeRecordType __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


/*!
    @const      kODPolicyAttributePassword
    @abstract   Policy attribute for the password.
    @discussion Policy attribute for the password in plain text.  May be used in
		policies to compare against other attributes or for evaluation
		against regular expressions.  Primarily useful in the Password
		Content policies.  For example, this policy string checks
		whether the password length is at least 8 characters: 
                    [NSString stringWithFormat:@"%@ matches '.{8,}+'", kODPolicyAttributePassword];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePassword __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributePasswordHashes
    @abstract   Policy attribute for the password hashes
    @discussion Policy attribute for the password hashes.  The value should be a
		CFArray containing one or more CFData values representing a
		password hash.

		Used in Password Content policy strings to compare the new
		password against the password history, for example:
                    [NSString stringWithFormat:@"none %@ in %@", kODPolicyAttributePasswordHashes, kODPolicyAttributePasswordHistory];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePasswordHashes __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributePasswordHistory
    @abstract   Policy attribute for the list of previous password hashes
    @discussion Policy attribute for the list of previous password hashes.  The
		value of this attribute is a CFArray containing one or more
		CFData elements representing a hash of a previous password.
		Hash types may be mixed.

		Used in Password Content policy strings to compare the new
		password against the password history, for example:
                    [NSString stringWithFormat:@"none %@ in %@", kODPolicyAttributePasswordHashes, kODPolicyAttributePasswordHistory];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePasswordHistory __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributePasswordHistoryDepth
    @abstract   Policy attribute for the number of previous hashed passwords to keep.
    @discussion Policy attribute for the number of previous hashed passwords to
                keep.  Should used as a key in the policy parameter dictionary,
                with a CFNumber value, specifying the number of password to keep.
                Should not be used in a policy string. 
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePasswordHistoryDepth __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentDate
    @abstract   Policy attribute for the current date and time as a CFDate.
    @discussion Policy attribute for the current date and time as a CFDate used
                in policy strings to compare the current date against another
                date.  The following policy string would allow authentications
                until the expiration date: 
                    [NSString stringWithFormat:@"%@ < %@", kODPolicyAttributeCurrentDate, kODPolicyAttributeExpiresOnDate];

                Do not use kODPolicyAttributeCurrentDate in policies where date
                arithmetic is needed; for those policies use
                kODPolicyAttributeCurrentTime instead.
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentDate __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentTime
    @abstract   Policy attribute for the current date and time in seconds.
    @discussion Policy attribute for the current date and time in seconds since
                the Unix epoch.  Used in policy strings to compare the
                current time against other times.  Suitable for use in policies
                where "date arithmetic" is needed (i.e. adding/subtracting
                values to/from the current time or another time in seconds).
                Ensure all times and date arithmetic in the policy are specified
                in seconds.

                Note that kODPolicyAttributeExpiresEveryNDays needs to be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used to accomplish this.

                In the policy below, password changes are required every 90 days
                (kODPolicyAttributeExpiresEveryNDays = 90).

                    [NSString stringWithFormat:@"%@ < %@ + (%@ * DAYS_TO_SECONDS)",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastPasswordChangeTime,
                              kODPolicyAttributeExpiresEveryNDays];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentTimeOfDay
    @abstract   Policy attribute for the current time of day as a CFNumber.
    @discussion Policy attribute for the current time of day as a CFNumber, in
                24 hour time, i.e. the range is 0000 through 2359.  Does not
                contain any date information.

                This attribute is used in policies to compare the current time
                of day against another time of day.  For example, to allow
                authentications between the hours of 8:00 AM and 5:00 PM, the
                policy string would be (kODPolicyAttributeEnableAtTimeOfDay is
                set to 0800 and  kODPolicyAttributeExpiresAtTimeOfDay is 1700):
                    [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                              kODPolicyAttributeCurrentTimeOfDay,
                              kODPolicyAttributeEnableAtTimeOfDay,
                              kODPolicyAttributeCurrentTimeOfDay,
                              kODPolicyAttributeExpiresAtTimeOfDay];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentTimeOfDay __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentDayOfWeek
    @abstract   Policy attribute for the current day of the week, as a CFNumber.
    @discussion Policy attribute for the current day of the week, as a CFNumber.  
                Specified in units appropriate for the local calendar.  The
                range is 1 through 7, with 1 representing the first day of the
                week in the local calendar, and 7 representing the last day of
                the week.

                This attribute is used in policies to compare the current day of
                the week against another day of the week.  For example, to
                enable authentications on Monday through Friday, the policy
                would be (kODPolicyAttributeEnableOnDayOfWeek is set to the
                number for Monday and kODPolicyAttributeExpiresOnDayOfWeek is
                set to the number for Friday):
                    [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                              kODPolicyAttributeCurrentDayOfWeek,
                              kODPolicyAttributeEnableOnDayOfWeek,
                              kODPolicyAttributeCurrentDayOfWeek,
                              kODPolicyAttributeExpiresOnDayOfWeek];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentDayOfWeek __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeFailedAuthentications
    @abstract   Policy attribute for the number of failed authentications.
    @discussion Policy attribute for the number of failed authentications for
                the record.  Used in policies to compare against the maximum
                failed authentications.  The following policy would deny further
                authentications after 3 failed attempts (assumes
                kODPolicyAttributeMaximumFailedAuthentications is 3):
                    [NSString stringWithFormat:@"%@ < %@",
                              kODPolicyAttributeFailedAuthentications,
                              kODPolicyAttributeMaximumFailedAuthentications];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeFailedAuthentications __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeMaximumFailedAuthentications
    @abstract   Policy attribute for the maximum failed authentication attempts.
    @discussion Policy attribute for the maximum failed authentication attempts.  
                Used as a key in policy parameter dictionary to specify the
                maximum allowable failed authentication attempts with a CFNumber
                value.  Also used in the policy string to compare against the
                number of failed authentication attempts.  This policy would
                disallow authentications after 3 failed attempts:
                    @{ kODPolicyKeyIdentifier  : @"maximum failed authentications",
                       kODPolicyKeyParameters  : @{ kODPolicyAttributeMaximumFailedAuthentications : @3 },
                       kODPolicyKeyContent     : [NSString stringWithFormat:@"%@ < %@",
                                                           kODPolicyAttributeFailedAuthentications,
                                                           kODPolicyAttributeMaximumFailedAuthentications] };
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeMaximumFailedAuthentications __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeLastFailedAuthenticationTime
    @abstract   Policy attribute for the time of the last failed auth attempt.
    @discussion Policy attribute for the time of the last failed auth attempt.
                CFNumber with a value representing the the number of seconds
                since the Unix epoch.  Used in policies to compare against other
                times.  As an example, this policy string would prevent another
                authentication within 10 seconds of a failed authentication:  
                    [NSString stringWithFormat:@"%@ > %@ + 10",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastFailedAuthenticationTime];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeLastFailedAuthenticationTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeLastAuthenticationTime
    @abstract   Policy attribute for the time of the last successful auth attempt.
    @discussion Policy attribute for the time of the last successful auth attempt.
                CFNumber with a value representing the number of seconds since
                the Unix epoch.  Used in policies to compare against another
                time.  

                The sample policy string below would deny authentications if
                there have been no authentications in the last 90 days.

                Note that the number of days needs to be converted to seconds to
                match the units of kODPolicyAttributeCurrentTime.  The special
                keyword DAYS_TO_SECONDS can be used for the conversion.

                    [NSString stringWithFormat:@"%@ < %@ + 90 * DAYS_TO_SECONDS",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastAuthenticationTime];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeLastAuthenticationTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeLastPasswordChangeTime
    @abstract   Policy attribute for time of the last password change.
    @discussion Policy attribute for time of the last password change.  The time
                is specified as the number of seconds since the Unix epoch.
                Used in policies to compare against other times.  Typically
                would be used in Password Change policies to expire a password
                at a certain time or interval.

                The policy string below requires a password change every 90 days
                (kODPolicyAttributeExpiresEveryNDays is set to 90).

                Note that kODPolicyAttributeExpiresEveryNDays needs to be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used for the conversion.

                    [NSString stringWithFormat:@"%@ < %@ + %@ * DAYS_TO_SECONDS",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastPasswordChangeTime,
                              kODPolicyAttributeExpiresEveryNDays];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeLastPasswordChangeTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeNewPasswordRequiredTime
    @abstract   Policy attribute for the time when "new password required" was set.
    @discussion Policy attribute for the time when "new password required" was set.
                The time is specified as the number of seconds since the
                Unix epoch.

                This attribute may be used in the policy string.  Whenever it's
                used in the policy string, it must also be specified in the
                policy's parameter dictionary.

                This attribute is used to capture the time when the system
                administrator wants to force all users to change their
                passwords.  This would be a "one-time" change, i.e. once the
                user changed the password, the policy would apply.  The policy
                would have to be updated with a new time for
                kODPolicyAttributeNewPasswordRequiredTime in order to force a
                new round of password changes.

                For example:
                    @{ kODPolicyKeyIdentifier : @"change on next auth",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeNewPasswordRequiredTime : @(<time>) },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@",
                                                          kODPolicyAttributeLastPasswordChangeTime,
                                                          kODPolicyAttributeNewPasswordRequiredTime]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeNewPasswordRequiredTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCreationTime
    @abstract   Policy attribute for the record creation time.
    @discussion Policy attribute for the record creation time.  The time is
                specified as the number of seconds since the "reference date".
                Could be used to disable "temporary" accounts after a specific
                period of time.  

                The example below disables authentications after 10
                days after the account was created.

                Note that kODPolicyAttributeDaysUntilExpiration must be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used for the conversion.

                    @{ kODPolicyKeyIdentifier : @"expires after 10 days",
                       kODPolicyKeyParameters : @{kODPolicyAttributeDaysUntilExpiration : @10 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@ + (%@ * DAYS_TO_SECONDS)",
                                                          kODPolicyAttributeCurrentTime,
                                                          kODPolicyAttributeCreationTime,
                                                          kODPolicyAttributeDaysUntilExpiration]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCreationTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresEveryNDays
    @abstract   Policy attribute for expires every N days.
    @discussion Policy attribute for expires every N days.  This attribute is
                used as a key in the policy parameter dictionary, with CFNumber
                value.  Also used in the policy strings. Typically would be used
                in Password Change policies to expire a password at a certain
                time or interval. 

                The example policy below would require a password change every
                90 days.

                Note that kODPolicyAttributeExpiresEveryNDays needs to be
                converted to seconds to match the units of the other times used
                in the policy.  The special keyword DAYS_TO_SECONDS can be used
                for the conversion.

                    @{ kODPolicyKeyIdentifier : @"expires every 90 days",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeExpiresEveryNDays : @90 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@ + %@ * DAYS_TO_SECONDS",
                                                          kODPolicyAttributeCurrentTime,
                                                          kODPolicyAttributeLastPasswordChangeTime,
                                                          kODPolicyAttributeExpiresEveryNDays]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresEveryNDays __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeEnableOnDate
    @abstract   Policy attribute for the "enable on" date.
    @discussion Policy attribute for the "enable on" date.  Used as a key in the
                policy parameter dictionary, with a CFDate value.   Also used in
                policy strings. The date is specified as a CFDate representing a
                fixed date, appropriate for the locale.  Use in policies when
                comparing other date-based attributes.

                This attribute is typically used Authentication policies to
                control when authentications are allowed. This policy would
                enable authentications on Jan 1, 2014 (assumes the date
                formatter is properly configured for the locale): 
                    @{ kODPolicyKeyIdentifier : @"enable on Jan 1",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeEnableOnDate : [localFormatter dateWithString:@"01/01/2014"] },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ >= %@",
                                                          kODPolicyAttributeCurrentDate,
                                                          kODPolicyAttributeEnableOnDate]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeEnableOnDate __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresOnDate
    @abstract   Policy attribute for the "expires on" date.
    @discussion Policy attribute for the "expires on" date.  Used as a key in the
                policy parameter dictionary, with a CFDate value.   Also used in
                policy strings. The date is specified as a CFDate representing a
                fixed date, appropriate for the locale.  Use in policies when
                comparing other date-based attributes.

                This attribute is typically used in Authentication policies to
                control when authentications are allowed. This policy would
                disallow authentications on Jan 1, 2014 (assumes the date
                formatter is properly configured for the locale): 
                    @{ kODPolicyKeyIdentifier : @"expires on Jan 1",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeExpiresOnDate : [localFormatter dateWithString:@"01/01/2014"] },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@",
                                                          kODPolicyAttributeCurrentDate,
                                                          kODPolicyAttributeExpiresOnDate]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresOnDate __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeEnableOnDayOfWeek
    @abstract   Policy attribute for enable on a day of the week.
    @discussion Policy attribute for enable on a day of the week.  Specified as a
                in units appropriate for the local calendar.  The range is 1
                through 7, with 1 representing the first day of the week in the
                local calendar, and 7 representing the last day of the week. 

                This attribute is used as a key in the policy parameter
                dictionary, with a CFNumber value, and in policy strings.
                Typically used i policy strings to compare against the another
                day of the week.  For example, to allow authentications only on
                Monday through Friday, the policy would be (assumes Monday = 2
                and Friday = 6 in the local calendar): 
                    @{ kODPolicyKeyIdentifier : @"mon-fri only",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeEnableOnDayOfWeek : @2,
                                                   kODPolicyAttributeExpiresOnDayOfWeek : @6 },
                       kOPolicyKeyPolicy      : [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                                                          kODPolicyAttributeCurrentDayOfWeek,
                                                          kODPolicyAttributeEnableOnDayOfWeek,
                                                          kODPolicyAttributeCurrentDayOfWeek,
                                                          kODPolicyAttributeExpiresOnDayOfWeek]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeEnableOnDayOfWeek __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresOnDayOfWeek
    @abstract   Policy attribute for expires on a day of the week.
    @discussion Policy attribute for expires on a day of the week.  Specified as a
                in units appropriate for the local calendar.  The range is 1
                through 7, with 1 representing the first day of the week in the
                local calendar, and 7 representing the last day of the week. 

                This attribute is used as a key in the policy parameter
                dictionary, with a CFNumber value, and in policy strings.
                Typically used i policy strings to compare against the another
                day of the week.  See the example above for kODPolicyAttributeEnableOnDayOfWeek.
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresOnDayOfWeek __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeEnableAtTimeOfDay
    @abstract   Policy attribute for enable at a specific time of day.
    @discussion Policy attribute for enable at a specific time of day.
                The time is specified in 24-hour time, with a range of 0000
                through 2359.  This attribute can be used as a key in the policy
                parameter dictionary, with a CFNumber value, and in the policy
                strings. 

                Typically used in authentication policies to control specific
                times of when when authentications are allowed.  For example, to
                enable authentications between the hours of 8:00 AM and 5:00 PM,
                the policy would be: 
                    @{ kODPolicyKeyIdentifier : @"school hours",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeEnableAtTimeOfDay  : @800,
                                                   kODPolicyAttributeExpiresAtTimeOfDay : @1700 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                                                          kODPolicyAttributeCurrentTimeOfDay,
                                                          kODPolicyAttributeEnableAtTimeOfDay,
                                                          kODPolicyAttributeCurrentTimeOfDay,
                                                          kODPolicyAttributeExpiresAtTimeOfDay]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeEnableAtTimeOfDay __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresAtTimeOfDay
    @abstract   Policy attribute for expires at a specific time of day.
    @discussion Policy attribute for expires at a specific time of day.
                The time is specified in 24-hour time, with a range of 0000
                through 2359.  This attribute can be used as a key in the policy
                parameter dictionary, with a CFNumber value, and in the policy
                strings. 

                Typically used in authentication policies to control specific
                times of when when authentications are allowed.  See the example
                above for kODPolicyAttributeEnableAtTimeOfDay.
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresAtTimeOfDay __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


/*!
    @const      kODPolicyAttributeDaysUntilExpiration
    @abstract   Policy attribute for the number of days until expiration.
    @discussion Policy attribute for the number of days until expiration.
                This attribute can be used as a key in the policy parameter
                dictionary with a CFNumber value representing some number of
                days.  It can also be used in the policy strings. 

                May be used in Authentication policies to expire authentications
                after some number of days or in Password Change policies to
                expire passwords.

                The example below disables authentications after 10
                days after the account was created.

                Note that kODPolicyAttributeDaysUntilExpiration must be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used for the conversion.

                    @{ kODPolicyKeyIdentifier : @"expires after 10 days",
                       kODPolicyKeyParameters : @{kODPolicyAttributeDaysUntilExpiration : @10 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@ + (%@ * DAYS_TO_SECONDS)",
                                                          kODPolicyAttributeCurrentTime,
                                                          kODPolicyAttributeCreationTime,
                                                          kODPolicyAttributeDaysUntilExpiration]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeDaysUntilExpiration __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


#pragma mark Errors

/*!
 @enum   	ODFrameworkErrors
 @abstract   Errors specific to the framework and to underlying calls
 @discussion Errors specific to the framework and to underlying calls
 @constant kODErrorSuccess is when operation was successful (if appropriate)
 @constant kODErrorSessionLocalOnlyDaemonInUse is when a Local Only session was initiated and is still active
 @constant kODErrorSessionNormalDaemonInUse is when the Normal daemon is still in use but request was issued for Local only
 @constant kODErrorSessionDaemonNotRunning is when the daemon is not running
 @constant kODErrorSessionDaemonRefused is when the daemon refused the session
 @constant kODErrorSessionProxyCommunicationError is when there was a communication error with the remote daemon
 @constant kODErrorSessionProxyVersionMismatch is when versions mismatch between the remote daemon and local framework
 @constant kODErrorSessionProxyIPUnreachable is when the provided kODSessionProxyAddress did not respond
 @constant kODErrorSessionProxyUnknownHost is when the provided kODSessionProxyAddress cannot be resolved
 @constant kODErrorNodeUnknownName is when the node name provided does not exist and cannot be opened
 @constant kODErrorNodeUnknownType is when the node type provided is not a known value
 @constant kODErrorNodeConnectionFailed is when a node connection failed (commonly server closed connection, etc.)
 @constant kODErrorNodeUnknownHost is when an invalid host is provided
 @constant kODErrorQuerySynchronize is an error code that is returned when a synchronize has been initiated
 @constant kODErrorQueryInvalidMatchType is when an invalid match type is provided in a query
 @constant kODErrorQueryUnsupportedMatchType is when plugin does not support the requirested match type
 @constant kODErrorQueryTimeout is when a query timed out during request
 @constant kODErrorRecordReadOnlyNode is when a record cannot be modified
 @constant kODErrorRecordPermissionError is when the changes requested were denied due to insufficient permissions
 @constant kODErrorRecordParameterError is when an invalid parameter was provided
 @constant kODErrorRecordInvalidType is when an invalid record type was provided
 @constant kODErrorRecordAlreadyExists is when a record create failed because the record already exists
 @constant kODErrorRecordTypeDisabled is when a particular record type is disabled by policy for a plugin
 @constant kODErrorRecordAttributeUnknownType is when an unknown attribute type is provided
 @constant kODErrorRecordAttributeNotFound is when an attribute requested is not found in the record
 @constant kODErrorRecordAttributeValueSchemaError is when an attribute value does not meet schema requirements
 @constant kODErrorRecordAttributeValueNotFound is when an attribute value is not found in a record
 @constant kODErrorCredentialsInvalid is when credentials provided are invalid with the current node
 @constant kODErrorCredentialsMethodNotSupported is when a particular extended method is not supported by the node
 @constant kODErrorCredentialsNotAuthorized is when an operation such as changing a password is not authorized with current privileges
 @constant kODErrorCredentialsParameterError is when a parameter provided is invalid
 @constant kODErrorCredentialsOperationFailed is when the requested operation failed (usually due to some unrecoverable error)
 @constant kODErrorCredentialsServerUnreachable is when the authententication server is not reachabable
 @constant kODErrorCredentialsServerNotFound is when the authentication server could not be found for the operation requested
 @constant kODErrorCredentialsServerError is when the authentication server encountered an error
 @constant kODErrorCredentialsServerTimeout is when the authentication server timed out
 @constant kODErrorCredentialsContactMaster is when the authentication server is not the master and the operation requires the master
 @constant kODErrorCredentialsServerCommunicationError is when the authentication server had a communications error
 @constant kODErrorCredentialsAccountNotFound is when the authentication server could not find the account provided
 @constant kODErrorCredentialsAccountDisabled is when the account is disabled
 @constant kODErrorCredentialsAccountExpired is when the account is expired
 @constant kODErrorCredentialsAccountInactive is when the account is inactive
 @constant kODErrorCredentialsPasswordExpired is when the password has expired and must be changed
 @constant kODErrorCredentialsPasswordChangeRequired is when a password change is required
 @constant kODErrorCredentialsPasswordQualityFailed is when a password provided for change did not meet quality minimum requirements
 @constant kODErrorCredentialsPasswordTooShort is when a password provided is too short
 @constant kODErrorCredentialsPasswordTooLong is when a password provided is too long
 @constant kODErrorCredentialsPasswordNeedsLetter is when a password needs a letter
 @constant kODErrorCredentialsPasswordNeedsDigit is when a password needs a digit
 @constant kODErrorCredentialsPasswordChangeTooSoon is when a an attempt to change a password too soon before last change
 @constant kODErrorCredentialsPasswordUnrecoverable is when password was not recoverable from the authentication database
 @constant kODErrorCredentialsInvalidLogonHours is when an account attempts to login outside of set logon hours
 @constant kODErrorCredentialsInvalidComputer is when an account attempts to login to a computer they are not authorized
 @constant kODErrorPolicyUnsupported all requested policies were not supported
 @constant kODErrorPolicyOutOfRange policy value was beyond the allowed range
 @constant kODErrorPluginOperationNotSupported is when a plugin does not support the requested operation
 @constant kODErrorPluginError is when a plugin has encountered some undefined error
 @constant kODErrorDaemonError is when some error occurred inside the daemon
 @constant kODErrorPluginOperationTimeout is when an operation exceeds an imposed timeout
*/

enum ODFrameworkErrors
{
    kODErrorSuccess                             = 0,
    
	/* ODSession error codes */
	kODErrorSessionLocalOnlyDaemonInUse			=	1000,
	kODErrorSessionNormalDaemonInUse			=	1001,
	kODErrorSessionDaemonNotRunning				=	1002,
	kODErrorSessionDaemonRefused				=	1003,

	kODErrorSessionProxyCommunicationError		=	1100,
	kODErrorSessionProxyVersionMismatch			=	1101,
	kODErrorSessionProxyIPUnreachable			=	1102,
	kODErrorSessionProxyUnknownHost				=	1103,
	
	/* ODNode error codes */
	kODErrorNodeUnknownName						=	2000,
	kODErrorNodeUnknownType						=	2001,
	kODErrorNodeDisabled						=	2002,

	kODErrorNodeConnectionFailed				=	2100,
	
	/* ODNode miscellaneous error codes */
	kODErrorNodeUnknownHost						=	2200,
	
	/* ODQuery error codes */
	kODErrorQuerySynchronize					=	3000,
	
	kODErrorQueryInvalidMatchType				=	3100,
	kODErrorQueryUnsupportedMatchType			=	3101,
	kODErrorQueryTimeout						=	3102,
	
	/* ODRecord error codes */
	kODErrorRecordReadOnlyNode					=	4000,
	kODErrorRecordPermissionError				=	4001,
	
	kODErrorRecordParameterError				=	4100,
	kODErrorRecordInvalidType					=	4101,
	kODErrorRecordAlreadyExists					=	4102,
	kODErrorRecordTypeDisabled					=	4103,
	kODErrorRecordNoLongerExists				=	4104,
	
	kODErrorRecordAttributeUnknownType			=	4200,
	kODErrorRecordAttributeNotFound				=	4201,
	kODErrorRecordAttributeValueSchemaError		=	4202,
	kODErrorRecordAttributeValueNotFound		=   4203,
	
	/* Credential specific error codes */
	kODErrorCredentialsInvalid					=	5000,
	
	kODErrorCredentialsMethodNotSupported		=	5100,
	kODErrorCredentialsNotAuthorized			=	5101,
	kODErrorCredentialsParameterError			=	5102,
	kODErrorCredentialsOperationFailed			=	5103,
	
	kODErrorCredentialsServerUnreachable		=	5200,
	kODErrorCredentialsServerNotFound			=	5201,
	kODErrorCredentialsServerError				=	5202,
	kODErrorCredentialsServerTimeout			=	5203,
	kODErrorCredentialsContactMaster			=	5204,
	kODErrorCredentialsServerCommunicationError	=	5205,
	
	kODErrorCredentialsAccountNotFound			=	5300,
	kODErrorCredentialsAccountDisabled			=	5301,
	kODErrorCredentialsAccountExpired			=	5302,
	kODErrorCredentialsAccountInactive			=	5303,
	
	kODErrorCredentialsPasswordExpired			=	5400,
	kODErrorCredentialsPasswordChangeRequired	=	5401,
	kODErrorCredentialsPasswordQualityFailed	=	5402,
	kODErrorCredentialsPasswordTooShort			=	5403,
	kODErrorCredentialsPasswordTooLong			=	5404,
	kODErrorCredentialsPasswordNeedsLetter		=	5405,
	kODErrorCredentialsPasswordNeedsDigit		=	5406,
	kODErrorCredentialsPasswordChangeTooSoon	=	5407,
	kODErrorCredentialsPasswordUnrecoverable	=	5408,

	kODErrorCredentialsInvalidLogonHours		= 	5500,
	kODErrorCredentialsInvalidComputer			= 	5501,
    
    /* Policy errors */
    kODErrorPolicyUnsupported                   =   6000,
    kODErrorPolicyOutOfRange                    =   6001,

	/* Underlying plugin errors */
	kODErrorPluginOperationNotSupported			=	10000,
	kODErrorPluginError							=	10001,
	kODErrorDaemonError							=	10002,
    kODErrorPluginOperationTimeout              =   10003,
};

#endif
                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odcore.h                                   0100644 0001750 0001750 00000017213 12566223340 023023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODCORE_H)
#define __ODCORE_H

#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <CoreFoundation/CoreFoundation.h>
#include <Security/Authorization.h>
#include <xpc/xpc.h>

#include <odmodule/odtypes.h>
#include <odmodule/odmodule.h>
#include <odmodule/odmoduleconfig.h>
#include <odmodule/odrequest.h>
#include <odmodule/odconnection.h>
#include <odmodule/odcredential.h>

/*!
    @header     odcore
    @abstract   definitions public for module development
    @discussion various functions useful for module development
                od_node_t is a client node (tracked via ODNode objects)
                od_nodeconfig_t is an internal node config object

                modules should never retain objects across requests as it can lead to leaks
                retains/releases should be paired (i.e., releases should be called before return from a request)
*/

extern const char *kODKeyPredicateList;    // is a sublist of predicates
extern const char *kODKeyPredicateRecordType;
extern const char *kODKeyPredicateStdRecordType;
extern const char *kODKeyPredicateStdAttribute;
extern const char *kODKeyPredicateOperator;
extern const char *kODKeyPredicateMatchType;
extern const char *kODKeyPredicateValueList;
extern const char *kODKeyPredicateEquality;

// predicate operators
extern const char *kODPredicateOperatorAnd;
extern const char *kODPredicateOperatorOr;
extern const char *kODPredicateOperatorNot;

// function and attribute are mutually exclusive
extern const char *kODKeyPredicateAttribute;
extern const char *kODKeyPredicateFunction;

// used for auth modules in additional info dictionary
extern const char *kODKeyModuleAuthUserDetails;
extern const char *kODKeyModuleConnectionInfo;
extern const char *kODKeyModuleSessionCredentials;
__BEGIN_DECLS


/*!
    @function   log_level_enabled
    @abstract   check if a particular log level is enabled to prevent expensive calculations
*/
bool
log_level_enabled(eODLogLevel level);

/*!
 @function   od_retain_internal
 @abstract   retain an object (internal reference)
 */
OD_NOTHROW
void
od_retain_internal(od_object_t object);

/*!
 @function   od_release_internal
 @abstract   release an object (internal reference)
 */
OD_NOTHROW
void
od_release_internal(od_object_t object);
/*!
 @function   od_retain
 @abstract   retain an object
 */
OD_NOTHROW
void
od_retain(od_object_t object);

#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
#undef od_retain
#define od_retain(object) ({ od_object_t _o = (object); \
_od_object_validate(_o); (void)[_o retain]; })
#endif // OS_OBJECT_USE_OBJC_RETAIN_RELEASE

/*!
    @function   od_release
    @abstract   release an object
*/
OD_NOTHROW
void
od_release(od_object_t object);
#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
#undef od_release
#define od_release(object) ({ od_object_t _o = (object); \
_od_object_validate(_o); [_o release]; })
#endif // OS_OBJECT_USE_OBJC_RETAIN_RELEASE

#pragma mark -
#pragma mark od_context_t
/*!
 @function	odcontext_create
 @abstract   used to create general context information
 @discussion Requests are not persistent, so the context will be added to the od_node_t object associated
 with the request.  When a context is released, it will be removed from the underlying node's
 context list.
 */
OD_WARN_RESULT
od_context_t
odcontext_create(od_request_t request, od_connection_t connection, void *context, od_context_dealloc_fn_t context_dealloc);
/*!
    @function	odcontext_get_identifier
    @abstract   get the identifier of a context, usually to store in a response
    @discussion get the identifier of a context, usually to store in a response
*/
void
odcontext_get_identifier(od_context_t context, uuid_t uuid);

/*!
    @function	odcontext_get_data
    @abstract   returned data is only valid for as long as the context is retained
    @discussion ensure the context is retained until this data is no longer needed, failure to do so could
				cause the data to become deallocated before the client is done.
*/
OD_WARN_RESULT
void *
odcontext_get_data(od_context_t context);

#pragma mark -
#pragma mark Utility functions

/*!
    @function   od_cstr_from_cfstring
    @abstract   get a C string from a CF String as UTF8
    @discussion get a C string from a CF String as UTF8
    @param      inCFStr the CFString to extract
    @param      ioCStr must be freed if it is non-NULL
    @result     a constant C string that should not be freed as it may be internal storage from the CFString
*/
OD_WARN_RESULT OD_NOTHROW
const char *
od_cstr_from_cfstring(CFStringRef inCFStr, char **ioCStr);

/*!
    @function	od_cstr_from_cfstring_or_cfdata
    @abstract   fetches a standard C-string from a CFDataRef or CFStringRef passed to APIs
    @discussion fetches a standard C-string from a CFDataRef or CFStringRef passed to APIs
    @param      value is a CFDataRef or CFStringRef to extract the string from
    @result     a pointer to a char string that must be freed
*/
OD_WARN_RESULT OD_NOTHROW
char *
od_cstr_from_cfstring_or_cfdata(CFTypeRef value);

/*!
 @function   xpctype_to_cftype
 @abstract   Convert xpc_object_t to CFTypeRef
 @param      xpc_obj is the source object
 @result     is a retained CFTypeRef
 */
CF_RETURNS_RETAINED CFTypeRef
xpctype_to_cftype(xpc_object_t xpc_obj);

/*!
 @function   cfctype_to_xpctype
 @abstract   Convert xpc_object_t to xpc_object_t
 @param      cfType is the source object
 @result     is a retained xpc_object_t
 */
XPC_RETURNS_RETAINED
xpc_object_t
cftype_to_xpctype(CFTypeRef cfType);

/*!
 @function   xpc_array_append_cftype
 @abstract   convert a cftype to xpc_object_t and append to array
 @param      xarray is the xpc_array to append to
 @param      cfType is the source object
 */
void
xpc_array_append_cftype(xpc_object_t xarray, CFTypeRef cfType);

/*!
 @function   xpc_dictionary_set_cftype
 @abstract   convert a CFTypeRef to xpc_object_t and insert in xpc_dictionary
 @param      xdict is the xpc_dictionary being modified
 @param      key is the key name
 @param      value is the CFTypeRef value.
 */
void
xpc_dictionary_set_cftype(xpc_object_t xdict, const char *key, CFTypeRef value);

/*!
 @function   CFArrayAppendServer
 @abstract   Append a server configuration to array of servers
 @param      array is the array being modified
 @param      hostname is the server name
 @param      port is the portnumber
 @param      writeable is a bool
 */
void
CFArrayAppendServer(CFMutableArrayRef array, CFStringRef hostname, int port, bool writeable);

/*!
 @function   od_predicate_create_ldapfilter
 @abstract   convert an Open Directory predicate to an LDAP filter
 @param      predicate is an xpc_object_t of type XPC_TYPE_DICTIONARY
 @result     returns a string that must be freed by caller
 */
char *
od_predicate_create_ldapfilter(xpc_object_t predicate);

__END_DECLS

#endif
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odcredential.h                             0100644 0001750 0001750 00000007312 12566223340 024204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODCREDENTIAL_H)
#define __ODCREDENTIAL_H

__BEGIN_DECLS


/*!
 * @function odcredential_create_ext
 *
 * @abstract
 * creates an od_credential_t object
 *
 * @param request
 * is an od_request_t object requesting this creation
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object
 *
 * @param rectype
 * is a CFStringRef
 *
 * @param recname
 * is a CFSTringRef
 *
 * @param metarecname
 * is a CFStringRef
 *
 * @param password
 * is a CFStringRef
 *
 * @param authorities
 * is a CFArrayRef
 *
 * @param flags
 * is a long
 *
 * @result
 * an od_credential_t
 */
OD_NOTHROW OD_WARN_RESULT
od_credential_t
odcredential_create_ext(od_request_t request, od_moduleconfig_t moduleconfig,
					CFStringRef rectype, CFStringRef recname, CFStringRef metarecname, CFStringRef password, CFArrayRef authorities,
					long flags);

/*!
 * @function odcredential_copy_details
 *
 * @abstract
 * copies details from credential
 *
 * @param credential
 * is an od_credential_t object to query
 *
 * @result
 * a CFDictionaryRef
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFDictionaryRef
odcredential_copy_details(od_credential_t credential);

/*!
 * @function odcredential_copy_recordname
 *
 * @abstract
 * copies recordname from credential
 *
 * @param credential
 * is an od_credential_t object to query
 *
 * @result
 * a CFSTringRef
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFStringRef
odcredential_copy_recordname(od_credential_t credential);

/*!
 * @function odcredential_copy_recordtype
 *
 * @abstract
 * copies recordtype from credential
 *
 * @param credential
 * is an od_credential_t object to query
 *
 * @result
 * a CFSTringRef
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFStringRef
odcredential_copy_recordtype(od_credential_t credential);

/*!
 * @function odcredential_copy_password
 *
 * @abstract
 * copies details from credential
 *
 * @param credential
 * is an od_credential_t object to query
 *
 * @result
 * a CFSTringRef
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFStringRef
odcredential_copy_password(od_credential_t credential);

/*!
 * @function odcredential_copy_metarecordname
 *
 * @abstract
 * copies details from credential
 *
 * @param credential
 * is an od_credential_t object to query
 *
 * @result
 * a CFStringRef
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFStringRef
odcredential_copy_metarecordname(od_credential_t credential);

/*!
 * @function odcredential_set_password
 *
 * @abstract
 * copies details from credential
 *
 * @discussion
 * changes the internal password that is used in all operations
 *
 * @param credential
 * is an od_credential_t object to modify
 *
 * @param password
 * is a CFStringRef
 */
void
odcredential_set_password(od_credential_t credential, CFStringRef password);

__END_DECLS

#endif
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odmodule.h                                 0100644 0001750 0001750 00000034672 12566223340 023370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODMODULE_H)
#define __ODMODULE_H

enum {
	eODModuleTypeSession		= 1L << 0,
	eODModuleTypeAuthentication	= 1L << 1,
	eODModuleTypeDiscovery		= 1L << 2,
	eODModuleTypeSystemCache	= 1L << 3,
	eODModuleTypeInternal		= 1L << 4,
};

typedef int32_t eODModuleType;

typedef eODCallbackResponse (*odm_customfunction_t)(od_request_t request, od_connection_t connection, xpc_object_t custom_payload);

struct odmodule_vtable_s {
#define ODMODULE_VTABLE_VERSION 3
    int version; /* set to ODMODULE_VTABLE_VERSION */
    
    /* Callbacks not associated with API calls */
    
    /* module initialization */
    void (*odm_initialize)(od_module_t module);
    
    xpc_object_t (*odm_copy_auth_information)(od_request_t request, od_moduleconfig_t moduleconfig, long info);
    
    /* locate service initiated for this moduleconfig */
    bool (*odm_locate_service)(od_request_t request, od_moduleconfig_t moduleconfig);
    
    /* a new configuration was loaded with this moduleconfig */
    void (*odm_configuration_loaded)(od_request_t request, od_moduleconfig_t moduleconfig);
    
    /* opportunity to parse a dynamic destination that might be understood by this module */
    xpc_object_t (*odm_parse_dynamic_destination)(od_request_t request, od_moduleconfig_t moduleconfig, const char *destination);
    
    /* create a new connection with the given options */
    od_connection_t (*odm_create_connection_with_options)(od_request_t request, od_moduleconfig_t moduleconfig, od_credential_t credential, eODModuleConfigServerFlags flags, xpc_object_t option_dict);
    
    /* copy details related to the provided connection */
    xpc_object_t (*odm_copy_details)(od_request_t request, od_connection_t connection);

    /* this callback doesn't require a response, it's a notification that the record is being deleted and to remove any resources related to it */
    void (*odm_RecordDeleteAuth)(od_request_t request, od_connection_t connection, xpc_object_t addinfo_dict);
    
    /*
     * API callbacks (no need to set ones that are not implemented)
     */
    
    eODCallbackResponse (*odm_NodeSetCredentials)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                  const char *recordname, const char *password, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_NodeSetCredentialsExtended)(od_request_t request, od_connection_t connection, const char *record_type, const char *auth_type, eODAuthType od_auth_type, xpc_object_t auth_items,
                                                          od_context_t auth_context, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_NodeVerifyCredentialsExtended)(od_request_t request, od_connection_t connection, const char *record_type, const char *auth_type, eODAuthType od_auth_type, xpc_object_t auth_items,
                                                             od_context_t auth_context, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_NodeCreateRecord)(od_request_t request, od_connection_t connection, const char *record_type, const char *recordname, xpc_object_t attrib_dict);
    
    eODCallbackResponse (*odm_NodeCopyPolicies)(od_request_t request, od_connection_t connection);
    eODCallbackResponse (*odm_NodeCopySupportedPolicies)(od_request_t request, od_connection_t connection);
    eODCallbackResponse (*odm_NodeSetPolicies)(od_request_t request, od_connection_t connection, xpc_object_t policies_dict);
    eODCallbackResponse (*odm_NodeRemovePolicy)(od_request_t request, od_connection_t connection, const char *policyType);

    eODCallbackResponse (*odm_QueryCreateWithPredicates)(od_request_t request, od_connection_t connection, xpc_object_t predicates, int32_t maxResults, int32_t pageSize, xpc_object_t returnAttributes);
    eODCallbackResponse (*odm_QuerySynchronize)(od_request_t request, od_connection_t connection, od_context_t query_context);
    eODCallbackResponse (*odm_QueryCancel)(od_request_t request, od_connection_t connection, od_context_t query_context);
    
    eODCallbackResponse (*odm_RecordVerifyPassword)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                    const char *recordname, const char *password, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordVerifyPasswordExtended)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                            const char *recordname, const char *auth_type, eODAuthType od_auth_type, xpc_object_t auth_items,
                                                            od_context_t auth_context, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordChangePassword)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                    const char *recordname, const char *old_password, const char *new_password, xpc_object_t addinfo_dict);
                         
    eODCallbackResponse (*odm_RecordSetValue)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                              const char *recordname, const char *attribute, xpc_object_t value_array);
    eODCallbackResponse (*odm_RecordAddValue)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                              const char *recordname, const char *attribute, xpc_object_t value_array);
    eODCallbackResponse (*odm_RecordRemoveValue)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                 const char *recordname, const char *attribute, xpc_object_t value_array);
    eODCallbackResponse (*odm_RecordDelete)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                            const char *recordname);
    
    eODCallbackResponse (*odm_RecordCopyEffectivePolicies)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                           const char *recordname, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordCopyPolicies)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                  const char *recordname, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordCopySupportedPolicies)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                           const char *recordname, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordSetPolicies)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                               const char *recordname, xpc_object_t policies_dict, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordRemovePolicy)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                  const char *recordname, const char *policyType, xpc_object_t addinfo_dict);

    /*
     * Version 2 additions
     */

    eODCallbackResponse (*odm_NodeAddAccountPolicy)(od_request_t request, od_connection_t connection, const char *policyCategory, xpc_object_t policy);
    eODCallbackResponse (*odm_NodeRemoveAccountPolicy)(od_request_t request, od_connection_t connection, const char *policyCategory, xpc_object_t policy);
    eODCallbackResponse (*odm_NodeSetAccountPolicies)(od_request_t request, od_connection_t connection, xpc_object_t policies);
    eODCallbackResponse (*odm_NodeCopyAccountPolicies)(od_request_t request, od_connection_t connection);
    eODCallbackResponse (*odm_NodePasswordContentCheck)(od_request_t request, od_connection_t connection, const char *recordtype, const char *recordname, const char *password);

    eODCallbackResponse (*odm_RecordAddAccountPolicy)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                      const char *recordname, const char *policyCategory, xpc_object_t policy, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordRemoveAccountPolicy)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                         const char *recordname, const char *policyCategory, xpc_object_t policy, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordSetAccountPolicies)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                        const char *recordname, xpc_object_t policies, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordCopyAccountPolicies)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                         const char *recordname, xpc_object_t addinfo_dict);

    eODCallbackResponse (*odm_RecordAuthenticationAllowed)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                           const char *recordname, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordPasswordChangeAllowed)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                           const char *recordname, const char *password, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordWillAuthenticationsExpire)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                               const char *recordname, int64_t expires_in, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordWillPasswordExpire)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                        const char *recordname, int64_t expires_in, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordSecondsUntilAuthenticationsExpire)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                                       const char *recordname, xpc_object_t addinfo_dict);
    eODCallbackResponse (*odm_RecordSecondsUntilPasswordExpires)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                                 const char *recordname, xpc_object_t addinfo_dict);

    /*
     * Version 3 additions
     */

    eODCallbackResponse (*odm_RecordCopyPasswordContentSummary)(od_request_t request, od_connection_t connection, const char *record_type, const char *metarecordname,
                                                                const char *recordname, xpc_object_t addinfo_dict);

};

typedef struct odmodule_vtable_s *odmodule_vtable_t;

__BEGIN_DECLS

/*!
    @function   odmodule_log_message
    @abstract   log a module specific message, that is not associated with a request
    @discussion use only for things done internally to a module that are not associated with a request
 */
OD_NOTHROW
void
odmodule_log_message(od_module_t module, eODLogLevel level, CFStringRef format, ...) CF_FORMAT_FUNCTION(3, 4);

/*!
    @function   odmodule_dispatch_queue_create
    @abstract   utility function for creating new dispatch queues to associate with a module
    @discussion creates a new queue based on the bundleIdentifier or the bundle info plus additional components
                (e.g., "com.apple.opendirectoryd.module.ldapv3")
    @param      module is an od_module_t object
    @param      name is a const char string that is appended to the queue name (e.g., "global", "objectqueue")
                to form "com.apple.opendirectoryd.module.ldapv3.global".
    @param      attr is a valid dispatch_queue_attr_t
    @result     a valid dispatch queue object
*/
OD_NOTHROW OD_WARN_RESULT
dispatch_queue_t
odmodule_dispatch_queue_create(od_module_t module, const char *name, dispatch_queue_attr_t attr);

OD_NOTHROW OD_WARN_RESULT
int32_t
odmodule_get_option_int32(od_module_t module, CFStringRef key, int32_t defaultValue);

void
odmodule_set_option_int32(od_module_t module, CFStringRef key, int32_t value);

OD_NOTHROW OD_WARN_RESULT
bool
odmodule_options_current(od_module_t module);

OD_NOTHROW OD_WARN_RESULT
bool
odmodule_supports_customfunction(od_module_t module, CFStringRef function);

/*!
    @function   odmodule_main
    @abstract   only called XPCService based modules
    @discussion only called XPCService based modules
    @param      vtable is an odmodule_vtable_t.  Pointer is stored and should not be modified
                or released after calling odmodule_main()
*/
OD_NORETURN
void
odmodule_main(const odmodule_vtable_t vtable);

OD_NOTHROW OD_WARN_RESULT
bool
odmodule_supports_customfunction(od_module_t module, CFStringRef function);

CFStringRef
odmodule_copy_identifier(od_module_t module);

void
odmodule_set_identifier(od_module_t module, CFStringRef name);

__END_DECLS

#endif
                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odmoduleconfig.h                           0100644 0001750 0001750 00000036425 12566223340 024554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODMODULECONFIG_H)
#define __ODMODULECONFIG_H

__BEGIN_DECLS

extern const CFStringRef kODModuleConfigServerCategoryPrimary;
extern const CFStringRef kODModuleConfigServerCategorySecondary;

/*!
 * @function odmoduleconfig_create
 *
 * @abstract
 * creates a new moduleconfig object
 *
 * @discussion
 * creates a new object to be used for later operations
 *
 * @param module
 * is an od_module_t object associated with this config
 *
 * @param options_uuid
 * is a uuid for this moduleconfig
 *
 * @result
 * an od_moduleconfig_t object created or NULL on failure
 */
OD_WARN_RESULT OD_NOTHROW OD_RETURNS_RETAINED
od_moduleconfig_t
odmoduleconfig_create(od_module_t module, CFDictionaryRef options, CFStringRef options_uuid);

/*!
 * @function odmoduleconfig_copy_options
 *
 * @abstract
 * copy options for a moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is a CFDictionaryRef with moduleconfig options
 */
OD_WARN_RESULT OD_NOTHROW CF_RETURNS_RETAINED
CFDictionaryRef
odmoduleconfig_copy_options(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_copy_dynamicdata
 *
 * @abstract
 * copy value for a moduleconfig dynamicdata key
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param key
 * is a CFStringRef name for a key
 *
 * @result 
 * is a CFTypeRef value
 */
OD_WARN_RESULT OD_NOTHROW CF_RETURNS_RETAINED
CFTypeRef
odmoduleconfig_copy_dynamicdata(od_moduleconfig_t moduleconfig, CFStringRef key);

/*!
 * @function odmoduleconfig_set_dynamicdata
 *
 * @abstract
 * sets keys/values for a moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param key
 * is a CFStringRef name for a key
 * 
 * @param data
 * is a CFTypeRef value
 */
OD_NOTHROW
void
odmoduleconfig_set_dynamicdata(od_moduleconfig_t moduleconfig, CFStringRef key, CFTypeRef data);

/*!
 * @function odmoduleconfig_get_context
 *
 * @abstract
 * get context associated with moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is a void*
 */
OD_WARN_RESULT OD_NOTHROW
void *
odmoduleconfig_get_context(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_set_context
 *
 * @abstract
 * set context associated with moduleconfig
 *
 * @discussion
 * this replaces any context that is currently set, changing context while in use can cause a crash if not protected
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param context
 * is a void*
 * 
 * @param dealloc
 * is a od_context_dealloc_fn_t function invoked with context when clearing the context
 */
OD_NOTHROW
void
odmoduleconfig_set_context(od_moduleconfig_t moduleconfig, void *context, od_context_dealloc_fn_t dealloc);

/*!
 * @function odmoduleconfig_apply_subnodes
 *
 * @abstract
 * apply block to every subnode of a moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to enumerate
 *
 * @param applier
 * is block applied to every subnode
 */
void
odmoduleconfig_apply_subnodes(od_moduleconfig_t moduleconfig, void (^applier)(od_moduleconfig_t subnode, CFStringRef nodename));

/*!
 * @function odmoduleconfig_copy_nodename
 *
 * @abstract
 * copy nodename
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is a CFStringRef name
 */
CFStringRef
odmoduleconfig_copy_nodename(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_copy_option_type_ext
 *
 * @abstract
 * copy option for moduleconfig/module
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param module
 * is an od_module_t object
 *
 * @param key
 * is a CFStringRef objecting naming the key in the option dictionary
 * 
 * @param cfTypeID
 * is a CFTypeID object specifying the type expected
 *
 * @result
 * is a CFTypeRef object
 */
CFTypeRef
odmoduleconfig_copy_option_type_ext(od_moduleconfig_t moduleconfig,
                                    od_module_t module,
                                    CFStringRef key,
                                    CFTypeID cfTypeID);

/*!
 * @function odmoduleconfig_copy_preferred
 *
 * @abstract
 * copy preferred server for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is a CFDictionaryRef object
 */
CFDictionaryRef
odmoduleconfig_copy_preferred(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_copy_lastused_server
 *
 * @abstract
 * copy preferred server for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is a CFDictionaryRef object
 */
CFDictionaryRef
odmoduleconfig_copy_lastused_server(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_copy_rootconfig
 *
 * @abstract
 * copy the root moduleconfig for a moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is an od_moduleconfig_t object
 */
od_moduleconfig_t
odmoduleconfig_copy_rootconfig(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_copy_servers
 *
 * @abstract
 * copy primary/secondary server list for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param isGlobal
 * is a bool
 *
 * @param listCategory
 * is a CFStringRef with value of kODModuleConfigServerCategoryPrimary or kODModuleConfigServerCategorySecondary
 *
 * @result
 * is a CFArrayRef object
 */
CFArrayRef
odmoduleconfig_copy_servers(od_moduleconfig_t moduleconfig, bool isGlobal, CFStringRef listCategory);

/*!
 * @function odmoduleconfig_copy_trustcredential
 *
 * @abstract
 * copy trust credential for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is an od_credential_t object
 */
od_credential_t
odmoduleconfig_copy_trustcredential(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_create_subnode
 *
 * @abstract
 * create a subnode
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param request
 * is an od_request_t object that triggered this change
 *
 * @param requester
 * is an od_moduleconfig_t object that requested the subnode
 *
 * @param option
 * is a CFDictionaryRef object with moduleconfig options
 *
 * @param subname
 * is a CFStringRef of the relative name/path (i.e., "node1")
 *
 * @param flags
 * is a long
 *
 * @result
 * is an od_moduleconfig_t object
 */
od_moduleconfig_t
odmoduleconfig_create_subnode(od_moduleconfig_t parent_config,
                              od_request_t request,
                              od_moduleconfig_t requester,
                              CFDictionaryRef options,
                              CFStringRef subname,
                              long flags);

/*!
 * @function odmoduleconfig_store_password
 *
 * @abstract
 * store password for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param isGlobal
 * is a bool
 *
 * @param request
 * is an od_request_t object that triggered this change
 *
 * @param accountName
 * is a CFStringRef object naming the password account
 *
 * @param password
 * is a CFStringRef object
 *
 * @result
 * is a bool
 */
bool
odmoduleconfig_store_password(od_moduleconfig_t moduleconfig,
                              bool isGlobal,
                              od_request_t request,
                              CFStringRef accountName,
                              CFStringRef password);

/*!
 * @function odmoduleconfig_delete_password
 *
 * @abstract
 * delete password for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param isGlobal
 * is a bool
 *
 * @param request
 * is an od_request_t object that triggered this change
 *
 * @param accountName
 * is a CFStringRef object naming the password account
 *
 * @result
 * is a bool
 */
bool
odmoduleconfig_delete_password(od_moduleconfig_t moduleconfig,
                               bool isGlobal,
                               od_request_t request,
                               CFStringRef accountName);


/*!
 * @function odmoduleconfig_copy_password
 *
 * @abstract
 * copy password for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param isGlobal
 * is a bool
 *
 * @param request
 * is an od_request_t object that triggered this query
 *
 * @param accountName
 * is a CFStringRef object naming the password account
 *
 * @result
 * is a CFStringRef
 */
CFStringRef
odmoduleconfig_copy_password(od_moduleconfig_t moduleconfig,
                             bool isGlobal,
                             od_request_t request,
                             CFStringRef accountName);

/*!
 * @function odmoduleconfig_fetch_password_timestamps
 *
 * @abstract
 * copy password metadata for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param isGlobal
 * is a bool
 *
 * @param request
 * is an od_request_t object that triggered this query
 *
 * @param accountName
 * is a CFStringRef object naming the password account
 *
 * @param creationDate
 * is a CFDateRef object created upon success
 *
 * @param modificationDate
 * is a CFDateRef object created upon success
 *
 * @result
 * is a bool
 */
bool
odmoduleconfig_fetch_password_timestamps(od_moduleconfig_t moduleconfig,
                                         bool isGlobal,
                                         od_request_t request,
                                         CFStringRef accountName,
                                         CFDateRef *creationDate,
                                         CFDateRef *modificationDate);

/*!
 * @function odmoduleconfig_get_option_bool
 *
 * @abstract
 * get boolean option for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param module
 * is an od_module_t object
 *
 * @param key
 * is a CFStringRef object
 *
 * @result
 * is a bool
 */
bool
odmoduleconfig_get_option_bool(od_moduleconfig_t moduleconfig,
                               od_module_t module,
                               CFStringRef key);

/*!
 * @function odmoduleconfig_get_option_int32
 *
 * @abstract
 * get int32 option for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param module
 * is an od_module_t object
 *
 * @param key
 * is a CFStringRef object
 *
 * @param defauleValue
 * is an int32_t that is returned if option is not present
 *
 * @result
 * is a int32
 */
int32_t
odmoduleconfig_get_option_int32(od_moduleconfig_t moduleconfig,
                                od_module_t module,
                                CFStringRef key,
                                int32_t defaultValue);

/*!
 * @function odmoduleconfig_is_online
 *
 * @abstract
 * get moduleconfig online status
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @param request
 * is an od_request_t object that triggered this query
 *
 * @result
 * is a bool
 */
bool
odmoduleconfig_is_online(od_moduleconfig_t moduleconfig, od_request_t request);

/*!
 * @function odmoduleconfig_is_rootconfig
 *
 * @abstract
 * test if moduleconfig is subnode or root
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to query
 *
 * @result
 * is a bool
 */
bool
odmoduleconfig_is_rootconfig(od_moduleconfig_t moduleconfig);

/*!
 * @function odmoduleconfig_set_preferred
 *
 * @abstract
 * sets preferred destination for a moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param request
 * is an od_request_t object that triggered this change
 *
 * @param destination
 * is a CFDictionaryRef designating the server address
 */
void
odmoduleconfig_set_preferred(od_moduleconfig_t moduleconfig, od_request_t request,
                             CFDictionaryRef destination);

/*!
 * @function odmoduleconfig_set_servers
 *
 * @abstract
 * sets primary or secondary list of servers for moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param request
 * is an od_request_t object that triggered this change
 * 
 * @param listCategory
 * is a CFStringRef with value of kODModuleConfigServerCategoryPrimary or kODModuleConfigServerCategorySecondary
 * 
 * @param list
 * is a CFArrayRef of servers for this moduleconfig
 */
void
odmoduleconfig_set_servers(od_moduleconfig_t moduleconfig,
                           od_request_t request,
                           CFStringRef listCategory,
                           CFArrayRef list);

/*!
 * @function odmoduleconfig_set_state_unknown
 *
 * @abstract
 * sets online state for a moduleconfig to unknown
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param request
 * is an od_request_t object that triggered this change.
 */
void
odmoduleconfig_set_state_unknown(od_moduleconfig_t moduleconfig, od_request_t request);

/*!
 * @function odmoduleconfig_set_subnode_visibility
 *
 * @abstract
 * sets visibility for a node
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param visible
 * is a boolean
 */
void
odmoduleconfig_set_subnode_visibility(od_moduleconfig_t moduleconfig, bool visible);

/*!
 * @function odmoduleconfig_set_netbiosname
 *
 * @abstract
 * sets netBIOSName for a moduleconfig
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object to modify
 *
 * @param netBIOSName
 * is a CFStringRef name
 */
void
odmoduleconfig_set_netbiosname(od_moduleconfig_t moduleconfig, CFStringRef netBIOSName);

/*!
 * @function odmoduleconfig_create_connection
 *
 * @abstract
 * creates a new connection object
 *
 * @discussion
 * creates a new object to be used for later operations
 *
 * @param moduleconfig
 * is an od_moduleconfig_t object associated with this config
 *
 * @param request
 * is an od_request_t object that needs this connection
 *
 * @param name
 * is a CStringRef name for this connection
 *
 * @param credentials
 * is an od_credential_t object for this connection
 *
 * @param flags
 * flags for this connection
 *
 * @param timeout
 * is how many seconds before the connection should be closed
 *
 * @param info
 * is od_connection_info_t object for this connection
 *
 * @result
 * an od_connection_t object created or NULL on failure
 */
od_connection_t
odmoduleconfig_create_connection(od_moduleconfig_t moduleconfig, od_request_t request,
                                 CFStringRef name, od_credential_t credential,
                                 eODNodeConfigServerFlags flags,
                                 uint64_t timeout, od_connection_info_t *info);

__END_DECLS

#endif
                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odobject.h                                 0100644 0001750 0001750 00000014427 12566223340 023345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_APACHE_LICENSE_HEADER_START@
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @APPLE_APACHE_LICENSE_HEADER_END@
 */

#ifndef opendirectoryd_odobject_h
#define opendirectoryd_odobject_h

#include <os/object.h>
#include <os/object_private.h>

#if OS_OBJECT_USE_OBJC
#define OD_DECL_INTERNAL_SUBCLASS(name, super) OS_OBJECT_DECL_SUBCLASS(name, super)
#define OD_DECL_INTERNAL(name) OD_DECL_INTERNAL_SUBCLASS(name, od_object))
#define OD_DECL_SUBCLASS_INTERFACE(name, super) _OS_OBJECT_DECL_SUBCLASS_INTERFACE(name, super)
#else // !OS_OBJECT_USE_OBJC
#define OD_DECL_INTERNAL_SUBCLASS(name, super) OD_DECL(name)
#define OD_DECL_INTERNAL(name) OD_DECL(name)
#define OD_DECL_SUBCLASS_INTERFACE(name, super)
#endif // OS_OBJECT_USE_OBJC

#define OD_CONCAT(x,y) OD_CONCAT1(x,y)
#define OD_CONCAT1(x,y) x ## y

#if __BUILDING_ODMODULE__ && OS_OBJECT_USE_OBJC
#define OD_CLASS(name) OS_OBJECT_CLASS(odx_##name)
#else // !__BUILDING_ODMODULE__ || !OS_OBJECT_USE_OBJC
#define OD_CLASS(name) OS_OBJECT_CLASS(od_##name)
#endif // !__BUILDING_ODMODULE__ || !OS_OBJECT_USE_OBJC

// ObjC classes and dispatch vtables are co-located via linker order and alias
// files rdar://10640168
#define OD_VTABLE_SUBCLASS_INSTANCE(name, super, ...) \
  __attribute__((section("__DATA,__objc_data"), used)) \
  static const struct { \
    _OS_OBJECT_CLASS_HEADER(); \
    OD_VTABLE_HEADER(super); \
  } OD_CONCAT(_,OD_CLASS(name##_vtable)) = { \
    __VA_ARGS__ \
}

#if __BUILDING_ODMODULE__
#define OD_SUBCLASS_DECL(name, super) \
  OD_DECL_SUBCLASS_INTERFACE(odx_##name, super) struct od_##name##_s; \
  extern const struct odx_##name##_vtable_s { \
    _OS_OBJECT_CLASS_HEADER(); \
    OD_VTABLE_HEADER(name); \
  } _odx_##name##_vtable

#define OD_CLASS_DECL(name) OD_SUBCLASS_DECL(name, odx_object)

#define ODINTERNAL_SUBCLASS_DECL(name, super) \
OD_DECL_INTERNAL_SUBCLASS(odx_##name, odx_##super); \
OD_DECL_SUBCLASS_INTERFACE(odx_##name, odx_##super) \
extern const struct odx_##super##_vtable_s _odx_##name##_vtable

#else // !__BUILDING_ODMODULE_
#define OD_SUBCLASS_DECL(name, super) \
  OD_DECL_SUBCLASS_INTERFACE(od_##name, super) struct od_##name##_s; \
  extern const struct od_##name##_vtable_s { \
    _OS_OBJECT_CLASS_HEADER(); \
    OD_VTABLE_HEADER(name); \
  } _od_##name##_vtable

#define OD_CLASS_DECL(name) OD_SUBCLASS_DECL(name, od_object)

#define ODINTERNAL_SUBCLASS_DECL(name, super) \
OD_DECL_INTERNAL_SUBCLASS(od_##name, od_##super); \
OD_DECL_SUBCLASS_INTERFACE(od_##name, od_##super) \
extern const struct od_##super##_vtable_s _od_##name##_vtable
#endif // !__BUILDING_ODMODULE_

#define OD_VTABLE_INSTANCE(name, ...) OD_VTABLE_SUBCLASS_INSTANCE(name, name, __VA_ARGS__)

#define OD_VTABLE(name) &_od_##name##_vtable

#define OD_VTABLE_HEADER(x) \
  unsigned long const odo_type; \
  const char *const odo_kind; \
  size_t (*const odo_debug)(struct od_##x##_s *, char *, size_t); \
  void (*const odo_dispose)(struct od_##x##_s *)

#define OD_STRUCT_HEADER(x) \
  _OS_OBJECT_HEADER( const struct od_##x##_vtable_s *odo_vtable, odo_ref_cnt, odo_xref_cnt); \
  void *odo_finalizer;

#define OD_OBJECT_GLOBAL_REFCNT		_OS_OBJECT_GLOBAL_REFCNT

#if OS_OBJECT_USE_OBJC
/*
 * By default, OD objects are declared as Objective-C types when building
 * with an Objective-C compiler. This allows them to participate in ARC, in RR
 * management by the Blocks runtime and in leaks checking by the static
 * analyzer, and enables them to be added to Cocoa collections.
 * See <os/object.h> for details.
 */
#if __BUILDING_ODMODULE__ 
OS_OBJECT_DECL(odx_object);
#define OD_DECL(name) OS_OBJECT_DECL_SUBCLASS(name, odx_object)

#ifndef __od_object_t__
#define __od_object_t__ 1
typedef odx_object_t od_object_t;
#endif // __od_object_t__

#else // !__BUILDING_ODMODULE__
OS_OBJECT_DECL(od_object);
#define OD_DECL(name) OS_OBJECT_DECL_SUBCLASS(name, od_object)
#endif // !__BUILDING_ODMODULE__
#define OD_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&(object))

#define OD_RETURNS_RETAINED OS_OBJECT_RETURNS_RETAINED

#if defined(__has_attribute) && __has_attribute(ns_returns_not_retained)
#define OD_RETURNS_NOT_RETAINED __attribute__((__ns_returns_not_retained__))
#endif

DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
void
_od_object_validate(od_object_t object) {
    void *isa = *(void* volatile*)(OS_OBJECT_BRIDGE void*)object;
    (void)isa;
}
#else // C

#ifndef __od_object_t__
#define __od_object_t__ 1

typedef union {
    struct _os_object_s         *_os_obj;
    struct od_object_s          *_object;
    struct od_attributemap_s    *_attributemap;
    struct od_connection_s      *_connection;
    struct od_context_s         *_context;
    struct od_credential_s      *_credential;
    struct od_mappings_s        *_mappings;
    struct od_module_s          *_module;
    struct od_moduleconfig_s    *_moduleconfig;
    struct od_node_s            *_node;
    struct od_nodeconfig_s      *_nodeconfig;
    struct od_pidinfo_s         *_pidinfo;
    struct od_recordmap_s       *_recordmap;
    struct od_request_s         *_request;
    struct od_requesttype_s     *_requesttype;
    struct od_response_s        *_response;
    struct od_session_s         *_session;
    struct od_trigger_s         *_trigger;
} od_object_t __attribute__((transparent_union));

#endif // __od_object_t__

/*! @parseOnly */
#define OD_DECL(name) typedef struct name##_s *name##_t
/*! @parseOnly */
#define OD_GLOBAL_OBJECT(t, x) (&(x))
/*! @parseOnly */
#undef OD_RETURNS_RETAINED
#define OD_RETURNS_RETAINED
#undef OD_RETURNS_NOT_RETAINED
#define OD_RETURNS_NOT_RETAINED

#endif // C

od_object_t _od_object_alloc(const void *vtable, size_t size);
void _od_object_xref_dispose(od_object_t obj);
void _od_object_dispose(od_object_t obj);
void _od_release(od_object_t obj);

#endif // opendirectoryd_odobject_h

                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odrequest.h                                0100644 0001750 0001750 00000025344 12566223340 023567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODREQUEST_H)
#define __ODREQUEST_H

typedef bool (^od_result_validation_block_t)(od_request_t request, CFArrayRef values, CFDictionaryRef result);

__BEGIN_DECLS

/*!
    @function   odrequest_log_message
    @abstract   allows logging of a message, it will be prefixed accordingly, etc.
*/
OD_NOTHROW
void
odrequest_log_message(od_request_t request, eODLogLevel level, CFStringRef format, ...) CF_FORMAT_FUNCTION(3, 4);
/*!
    @function	odrequest_copy_context_with_uuid
    @abstract   retains the context associated with an identifier
    @discussion since requests are not persistent, contexts are stored in the od_node_t object associated
				with the request.
*/
OD_WARN_RESULT
od_context_t
odrequest_copy_context_with_uuid(od_request_t request, uuid_t uuid);

/*!
    @function	odrequest_remove_context
    @abstract   call to remove a context from the od_node_t associated with a request
    @discussion requests are not persistent, so contexts are attached to an od_node_t object.  When that
				node closes, these contexts are released and are no long valid.
*/
void
odrequest_remove_context(od_request_t request, od_context_t context);


/*!
 * @function odrequest_respond_success
 *
 * @abstract
 * Sends a response to the client that the request succeeded.
 *
 * @discussion
 * Sends a response to the client that the request succeeded.  This is used for most
 * API callbacks as generally there is an error or a response.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_success(od_request_t request);

/*!
 * @function odrequest_respond_error
 *
 * @abstract
 * Sends an error response to the client.
 *
 * @discussion
 * Sends an error response to the client along with additional unlocalized text used as
 * additional information only.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_error(od_request_t request, uint32_t error, const char *error_desc);

/*!
 * @function odrequest_respond_recordcreate
 *
 * @abstract
 * Responds to a successful record creation request.
 *
 * @discussion
 * Responds to a record creation request with a dictionary of arrays.  If record cannot be
 * created then use odrequest_respond_error with appropriate error.
 *
 * @param request
 * A valid od_request_t object that is being responded to.
 *
 * @param record_dict
 * A valid xpc_object_t of type XPC_DICTIONARY containing the native keys and values
 * for the record which will be sent through the translation layer for the client.
 *
 * @result
 * Returns a eODCallbackResponse as a convenience that can be returned from the API callback.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_recordcreate(od_request_t request, xpc_object_t record_dict);

/*!
 * @function odrequest_respond_recordcopy
 *
 * @abstract
 * Responds to a record copy request.
 *
 * @discussion
 * Responds to a record copy request with a dictionary of arrays.  If record cannot
 * be found it should be called with NULL or use odrequest_respond_error with appropriate
 * error.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @param record_dict
 * A valid xpc_object_t of type XPC_DICTIONARY containing the native keys and values
 * for the record which will be sent through the translation layer for the client.
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_recordcopy(od_request_t request, xpc_object_t record_dict);

/*!
 * @function odrequest_respond_customfunction
 *
 * @abstract
 * Responds to a custom function request.
 *
 * @discussion
 * Responds to a custom function request with a value appropriate for the custom function.
 * The type is defined by the custom function of the module.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @param func_defined
 * A valid xpc_object_t with native keys and values that will be sent through the translation
 * layer for the client.
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_customfunction(od_request_t request, xpc_object_t func_defined);

/*!
 * @function odrequest_respond_policy
 *
 * @abstract
 * Responds to a policy function request.
 *
 * @discussion
 * Responds to a policy function request with a value appropriate for the policy function.
 * An XPC_DICTIONARY should be used for the combined policy calls, otherwise the explict
 * value for the type of policy should be returned.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @param policy
 * A valid xpc_object_t appropriate for the request in question.
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_policy(od_request_t request, xpc_object_t policy);

/*!
 * @function odrequest_respond_authentication_continuation
 *
 * @abstract
 * Responds to an authentication request that requires more steps.
 *
 * @discussion
 * Responds to an authentication request that requires more steps.  If there are no
 * additional continuations, then module should call odrequest_respond_success.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @param auth_ctx
 * A valid od_context_t object that creates the continuation context.
 *
 * @param item_array
 * A valid xpc_object_t of type XPC_ARRAY that is to be sent to the caller.
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_authentication_continuation(od_request_t request, od_context_t auth_ctx, xpc_object_t item_array);

/*!
 * @function odrequest_respond_query_start
 *
 * @abstract
 * Responds to the initial query creation with a query context to be used for
 * either cancellation or resync.
 *
 * @discussion
 * Responds to the initial query creation with a query context to be used for
 * either cancellation or resync.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @param query_ctx
 * A valid od_context_t object for the query.
 *
 * @result
 * Returns a eODCallbackResponse that can be returned from the API callback if necessary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
eODCallbackResponse
odrequest_respond_query_start(od_request_t request, od_context_t query_ctx);

/*!
 * @function odrequest_respond_query_result
 *
 * @abstract
 * Responds to the query with a result from the module.
 *
 * @discussion
 * Responds to the query with a result from the module.  If the query has completed
 * module can call odrequest_respond_success to signify the request is complete.
 *
 * @param request
 * A valid od_request_t object that is being responded to.
 *
 * @param query_ctx
 * A valid od_context_t object for the query.
 *
 * @param result_dict
 * A valid xpc_object_t object of type XPC_DICTIONARY that contains key/value pairs for
 * the record found.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)
void
odrequest_respond_query_result(od_request_t request, od_context_t query_ctx, xpc_object_t result_dict);

/*!
 * @function odrequest_respond_query_sync
 *
 * @abstract
 * Sync a synchronization message to the client telling it that new results
 * are on their way.
 *
 * @discussion
 * Sync a synchronization message to the client telling it that new results
 * are on their way.  The client should forget all prior results.
 *
 * @param request
 * A valid od_request_t object that is being responded to
 *
 * @param query_ctx
 * A valid od_context_t object for the query.
 */
void
odrequest_respond_query_sync(od_request_t request, od_context_t query_ctx);

void
odrequest_submit_rpc_response(od_request_t request, xpc_object_t reply);

OD_WARN_RESULT OD_NOTHROW
bool
odrequest_testcancel(od_request_t request);

OD_WARN_RESULT OD_NOTHROW
uid_t
odrequest_get_uid(od_request_t request);

OD_WARN_RESULT OD_NOTHROW
uid_t
odrequest_get_euid(od_request_t request);

OD_WARN_RESULT OD_NOTHROW
gid_t
odrequest_get_gid(od_request_t request);

OD_WARN_RESULT OD_NOTHROW
gid_t
odrequest_get_egid(od_request_t request);

OD_WARN_RESULT OD_NOTHROW
pid_t
odrequest_get_pid(od_request_t request);

// will return the username associated with the UID of the request
OD_WARN_RESULT OD_NOTHROW CF_RETURNS_RETAINED
CFStringRef
odrequest_copy_process_username(od_request_t request);

OD_WARN_RESULT OD_NOTHROW
int
odrequest_verify_access(od_request_t request, od_credential_t credential, CFStringRef authed_user);

/*!
    @function	odrequest_set_auth_connection
    @abstract   set a new connection on the request, for future continuation calls
    @discussion set a new connection on the request, for future continuation calls
    @param      request the request to attach the connection to
    @param      connection is a new usable connection, will replace any existing.  The existing will
                be released immediately.  It is retained when called.
*/
void
odrequest_set_auth_connection(od_request_t request, od_connection_t connection);
eODRequestType
odrequest_get_typeid(od_request_t request);

OD_WARN_RESULT OD_NOTHROW OD_RETURNS_RETAINED
od_connection_t
odrequest_copy_session_connection(od_request_t request);
__END_DECLS

#endif
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/odmodule/odtypes.h                                  0100644 0001750 0001750 00000042626 12566223340 023245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODTYPES__)
#define __ODTYPES__

#include <stdbool.h>
#include <stdint.h>
#include <uuid/uuid.h>
#include <malloc/malloc.h>
#include <os/object.h>
#include <CoreFoundation/CoreFoundation.h>
#include <odmodule/odconstants.h>
#ifndef __od_object_t__
#define __od_object_t__ 1
typedef union {
    struct _os_object_s         *_os_obj;
    struct od_object_s          *_object;
    struct od_connection_s      *_connection;
    struct od_context_s         *_context;
    struct od_credential_s      *_credential;
    struct od_module_s          *_module;
    struct od_moduleconfig_s    *_moduleconfig;
    struct od_request_s         *_request;
    struct od_session_s         *_session;
    struct od_nodeconfig_s      *_nodeconfig;
} od_object_t __attribute__((transparent_union));
#endif // !__od_object_t__

#define OD_EXPORT extern __attribute__((visibility("default")))
#define OD_NOEXPORT __attribute__((visibility("hidden")))

#define OD_NORETURN                 __attribute__((__noreturn__))
#define OD_NOTHROW                  __attribute__((__nothrow__))
#define OD_SENTINEL                 __attribute__((__sentinel__))
#define OD_PURE                     __attribute__((__pure__))
#define OD_WARN_RESULT              __attribute__((__warn_unused_result__))
#define OD_ALWAYS_INLINE            __attribute__((always_inline))
#define OD_IGNORE_UNUSED            __attribute__((__nowarn_unused__))

#ifndef OD_RETURNS_RETAINED
#define OD_RETURNS_RETAINED         OS_OBJECT_RETURNS_RETAINED
#endif // !OD_RETURNS_RETAINED
#if __OBJC__ && defined(__has_attribute) && __has_attribute(ns_returns_not_retained)
#define OD_RETURNS_NOT_RETAINED __attribute__((__ns_returns_not_retained__))
#else
#define OD_RETURNS_NOT_RETAINED     /**/
#endif
#define OD_TYPEDECL_OBJ(name)       typedef struct od_##name##_s *od_##name##_t

#define OD_CFRETAIN_SAFE(a)         do { if ((a) != NULL) { CFRetain(a); } } while (0)
#define OD_CFRELEASE_SAFE(a)        do { if ((a) != NULL) { CFRelease(a); } } while (0)

#define OD_CFRELEASE_NULL(a)        do { if ((a) != NULL) { CFRelease(a); (a) = NULL; } } while (0)
#define OD_RELEASE_NULL(a)          do { od_release(a); a = NULL; } while (0)
#define OD_FREE_NULL(a)             do { free(a); (a) = NULL; } while (0)
#define OD_ZERO_FREE_NULL(a)        do { if ((a) != NULL) { memset((a), 0, malloc_size(a)); free(a); (a) = NULL; } } while (0)
#define OD_DISPATCH_RETAIN_SAFE(a)  do { if ((a) != NULL) { dispatch_retain(a); } } while (0)
#define OD_DISPATCH_RELEASE_NULL(a) do { if ((a) != NULL) { dispatch_release(a); (a) = NULL; } } while (0)
#define OD_BLOCKRELEASE_NULL(a)		do { Block_release(a); (a) = NULL; } while (0)

#define OD_XPC_RELEASE_NULL(a)      do { if ((a) != NULL) { xpc_release(a); (a) = NULL; } } while (0)

#define OD_ATOMIC_XCHG(p, n)		__sync_lock_test_and_set((p), (n))
#define OD_ATOMIC_CMPXCHG(p, o, n)	__sync_bool_compare_and_swap((p), (o), (n))
#define OD_ATOMIC_INC(p)			__sync_add_and_fetch((p), 1)
#define OD_ATOMIC_DEC(p)			__sync_sub_and_fetch((p), 1)
#define OD_ATOMIC_ADD(p, v)			__sync_add_and_fetch((p), (v))
#define OD_ATOMIC_SUB(p, v)			__sync_sub_and_fetch((p), (v))
#define OD_ATOMIC_OR(p, v)			__sync_fetch_and_or((p), (v))
#define OD_ATOMIC_AND(p, v)			__sync_fetch_and_and((p), (v))
#define OD_ATOMIC_BARRIER()			__sync_synchronize()

#pragma mark -
#pragma mark enum types

enum {
    /* use these in critical only situations */
    eODLogAlert                     = 1L,      // P1 -- redirects to system.log
    eODLogCritical                  = 2L,      // P2 -- redirects to system.log
    
    /* typical logging levels */
    eODLogError                     = 3L,      // P3 -- some error occurred -- default logging level
    eODLogWarning                   = 4L,      // P4 -- concerning, but not fatal
    eODLogNotice                    = 5L,      // P5 -- normal log details for high-level information
    eODLogInfo                      = 6L,      // P6 -- some information info (like connection checks, scans, etc.)
    eODLogDebug                     = 7L,      // P7 -- full debug information needed to help diagnose involved isues
    eODLogDefault                   = eODLogError,
};

enum {
    eODConnectionOperationConnect       = 1L,
    eODConnectionOperationDisconnect    = 2L,
    eODConnectionOperationReconnect     = 3L,
};

enum {
    eODTriggerEventNodeOnline               = 1L << 0,
    eODTriggerEventNodeOffline              = 1L << 1,
    eODTriggerEventNodeRegister             = 1L << 2,        
    eODTriggerEventNodeUnregister           = 1L << 3,
    eODTriggerEventNodeLastServerChanged    = 1L << 4,
    eODTriggerEventNodeOptionsChanged       = 1L << 5,
    eODTriggerEventNodeDeleted              = 1L << 6,
};

enum {
    eODResponseTypeGeneralResponse      = 0,
    eODResponseTypeODQueryResponse      = 1,
    eODResponseTypeODQueryResponseSync  = 2,
};

enum {
    eODAccessModeRead          = 0L,
    eODAccessModeCreate,
    eODAccessModeDelete,
    eODAccessModeReadAttr,
    eODAccessModeWriteAttr,
};

enum {
    eODAuthInfoAttributes   = 1L,
    eODAuthInfoAuthTypes    = 2L,
    eODAuthInfoMechanisms   = 3L,
};

enum {
	eODEqualityRuleNone				= 0,
	eODEqualityRuleCaseIgnore		= 1,
	eODEqualityRuleCaseExact		= 2,
	eODEqualityRuleNumber			= 3,
	eODEqualityRuleCertificate		= 4,
	eODEqualityRuleTime				= 5,
	eODEqualityRuleTelephoneNumber	= 6,
	eODEqualityRuleOctetMatch		= 7,
};

enum {
    eODCallbackResponseSkip         = 0,    // skip this module/connection if possible (go to next module/connection)
    eODCallbackResponseAccepted     = 1,    // has been accepted and will respond directly
    eODCallbackResponseForward      = 2,    // request modified, forward to next module
    eODCallbackResponseRefused      = 3,    // will reply to client operation is unsupported
};

enum {
    eODCredentialFlagKerberos               = 1 << 0,
    eODCredentialFlagSystemKeychain         = 1 << 1,   // password is stored in system keychain
    eODCredentialFlagMutualAuthentication   = 1 << 2,   // validates tickets against local keytab accordingly
    eODCredentialFlagAuthorizationRight     = 1 << 3,   // means it's derived from a authorization ref
    
    // non-configurable options go last
    eODCredentialFlagProxyKerberos          = 1 << 31,
};

typedef uint32_t eODNodeConfigServerFlags;
typedef uint32_t eODModuleConfigServerFlags;
typedef uint32_t eODConnectionCreateFlags; // temporary to prevent breakage
typedef uint32_t eODQueryMatchType;
typedef long eODCallbackResponse;

#define AUTH_METHOD(a,b) eODAuthType##b = a##l,
#define AUTH_METHOD_DEPRECATED(a,b) AUTH_METHOD(a,b)
#define AUTH_METHOD_MAP_DEPRECATED(a,b) eODAuthType##a = eODAuthType##b,

#define SUPPORTED_METHOD_LIST                           \
    AUTH_METHOD(0, Unknown)                             \
    AUTH_METHOD(1, APOP)                                \
    AUTH_METHOD(2, CRAM_MD5)                            \
    AUTH_METHOD(3, DIGEST_MD5)                          \
    AUTH_METHOD(4, MPPEMasterKeys)                      \
    AUTH_METHOD(5, MSCHAP2)                             \
    AUTH_METHOD(6, NTLMv2)                              \
    AUTH_METHOD(7, NTLMv2WithSessionKey)                \
    AUTH_METHOD(8, SMB_LM_Key)                          \
    AUTH_METHOD(9, SMB_NT_Key)                          \
    AUTH_METHOD(10, SMB_NT_WithUserSessionKey)          \
    AUTH_METHOD(11, WithAuthorizationRef)               \
    AUTH_METHOD(12, PPS)                                \
    AUTH_METHOD(13, SetCertificateHash)                 \
    AUTH_METHOD(14, RetainCredential)                   \
    AUTH_METHOD(15, GSSAPI)                             \
    /* temporarily here */                              \
    AUTH_METHOD(56, SetGlobalPolicy)                    \
    AUTH_METHOD(60, SetPolicyAsCurrent)                 \
    AUTH_METHOD(70, GetGlobalPolicy)                    \
    AUTH_METHOD(72, GetPolicy)                          \

#define DEPRECATED_METHOD_LIST                                  \
    AUTH_METHOD_DEPRECATED(50, ClearText)                       \
    AUTH_METHOD_DEPRECATED(51, ChangePassword)                  \
    AUTH_METHOD_DEPRECATED(52, SetPassword)                     \
    AUTH_METHOD_DEPRECATED(53, SetPasswordAsCurrent)            \
    AUTH_METHOD_DEPRECATED(54, Crypt)                           \
    AUTH_METHOD_DEPRECATED(55, 2WayRandomChangePasswd)          \
    AUTH_METHOD_DEPRECATED(57, SetLMHash)                       \
    AUTH_METHOD_DEPRECATED(58, SetNTHash)                       \
    AUTH_METHOD_DEPRECATED(59, SetPolicy)                       \
    AUTH_METHOD_DEPRECATED(61, SetUserData)                     \
    AUTH_METHOD_DEPRECATED(62, SetUserName)                     \
    AUTH_METHOD_DEPRECATED(63, SetWorkstationPassword)          \
    AUTH_METHOD_DEPRECATED(64, NewUser)                         \
    AUTH_METHOD_DEPRECATED(65, NewUserWithPolicy)               \
    AUTH_METHOD_DEPRECATED(66, ReadSecureHash)                  \
    AUTH_METHOD_DEPRECATED(67, WriteSecureHash)                 \
    AUTH_METHOD_DEPRECATED(68, DeleteUser)                      \
    AUTH_METHOD_DEPRECATED(69, GetEffectivePolicy)              \
    AUTH_METHOD_DEPRECATED(71, GetKerberosPrincipal)            \
    AUTH_METHOD_DEPRECATED(73, GetUserData)                     \
    AUTH_METHOD_DEPRECATED(74, GetUserName)                     \
    AUTH_METHOD_DEPRECATED(75, NodeNativeClearTextOK)           \
    AUTH_METHOD_DEPRECATED(76, NodeNativeNoClearText)           \
    AUTH_METHOD_DEPRECATED(77, NTLMv2UserSessionKey)            \
    AUTH_METHOD_DEPRECATED(78, SMB_NT_UserSessionKey)           \
    AUTH_METHOD_DEPRECATED(79, 2WayRandom)                      \
    AUTH_METHOD_DEPRECATED(80, KerberosTickets)                 \
    AUTH_METHOD_DEPRECATED(81, SMBWorkstationCredentialSessionKey) \
    AUTH_METHOD_MAP_DEPRECATED(ChangePasswd, ChangePassword)       \
    AUTH_METHOD_MAP_DEPRECATED(SMBNTv2UserSessionKey, NTLMv2UserSessionKey)  \

enum {
    SUPPORTED_METHOD_LIST
};

typedef long eODAuthType;

enum {
    eODMatchTypeAll             = kODMatchAny,
    
    eODMatchTypeEqualTo         = kODMatchEqualTo,
    eODMatchTypeBeginsWith      = kODMatchBeginsWith,
    eODMatchTypeContains        = kODMatchContains,
    eODMatchTypeEndsWith        = kODMatchEndsWith,
    
    eODMatchTypeGreaterThan     = kODMatchGreaterThan,
    eODMatchTypeLessThan        = kODMatchLessThan,
};

typedef long        eODEqualityRule;
typedef int32_t     eODMatchType;


#pragma mark -
#pragma mark typedefs

typedef uint32_t    eODLogLevel;
typedef uint32_t    eODRequestType;
typedef uint32_t    eODResponseType;

typedef long        eODConnectionOperation;

typedef char        *cstring;

OD_TYPEDECL_OBJ(connection);
OD_TYPEDECL_OBJ(context);
OD_TYPEDECL_OBJ(credential);
OD_TYPEDECL_OBJ(module);
OD_TYPEDECL_OBJ(moduleconfig);
OD_TYPEDECL_OBJ(node);
OD_TYPEDECL_OBJ(request);
OD_TYPEDECL_OBJ(session);
typedef void (*od_context_dealloc_fn_t)(void *context);
/*
 * prototypes for module callback functions
 */

typedef struct od_connection_info_s {
	void					*context;
	od_context_dealloc_fn_t context_dealloc;
	uint32_t				(*reconnect_cb)(od_connection_t connection, od_request_t request, void *context);
	void					(*disconnect_cb)(od_connection_t connection, int sock, void *context);
} od_connection_info_t;

/*!
    @function   odm_initialize
    @abstract   required callback called on first load of a module
    @discussion this callback is only called once on load of the module
    @param      module is an opaque datatype used for other calls
 */
void
odm_initialize(od_module_t module);

/*!
    @function   odm_configuration_loaded
    @abstract   notifies the module that a new configuration was loaded that uses this module
    @discussion notifies the module that a new configuration was loaded that uses this module
    @param      module is an opaque datatype used for other calls
    @param      moduleconfig is an opaque datatype used for other calls
    @param      session is an opaque session handle that can be used to gather session details
 */
void
odm_configuration_loaded(od_module_t module, od_moduleconfig_t moduleconfig, od_session_t session);

/*!
    @function   odm_copy_auth_information
    @abstract   requests information specific to this module such as required attributes, etc.
    @discussion requests information specific for this module to fulfill authentications.  The dictionary should
                contain the following keys "attributes", "auth_types" and "mechanisms".  
    @param      module is an opaque datatype used for other calls
    @result     returns a CFArrayRef value:
 
                eODAuthInfoAttributes are the attributes required from the record in order to do the authentication. Specific
                attributes are already included, so only additional attributes beyond the list below should be returned:

                    kODAttributeTypeAuthenticationAuthority
                    kODAttributeTypePasswordPolicyOptions
                    kODAttributeTypePassword
                    kODAttributeTypeGUID
                    kODAttributeTypeUniqueID

                eODAuthInfoAuthTypes are the authentication types supported by this module (kODAuthenticationTypeDIGEST_MD5, etc.)
                eODAuthInfoMechanisms are what authority tags this module handles "PasswordServer", "Kerberos", "Basic", etc.
 */
OD_NOTHROW OD_WARN_RESULT CF_RETURNS_RETAINED
CFTypeRef
odm_copy_auth_information(od_module_t module, od_moduleconfig_t moduleconfig, long info);


/*!
    @function   module entry points
    @abstract   most callbacks are identical for most API calls
    @param      module is the od_module_t of the module being asked to process
    @param      connection is the connection (if any) associated with this request (may be NULL).
                caller must handle a NULL connection.  This means the primary connection for the request
                is not this module.  Modules are guaranteed to get connections it created.
    @param      request is the request to be processed
    @param      moduleconfig is the configuration for this module callback
    @result     returns an eODCallbackResponse value as appropriate
 */

#define ODM_CALLBACK_DECL(type)     eODCallbackResponse odm_##type(od_module_t module, od_connection_t connection, od_request_t request,    \
                                                                   od_moduleconfig_t moduleconfig)
#define ODM_CUSTOMFUNCTION_DECL(type)   eODCallbackResponse type(od_module_t module, od_connection_t connection, od_request_t request,    \
                                                                 od_moduleconfig_t moduleconfig, CFTypeRef payload)
ODM_CALLBACK_DECL(RecordCopyPasswordPolicy);
ODM_CALLBACK_DECL(RecordVerifyPassword);
ODM_CALLBACK_DECL(RecordVerifyPasswordExtended);
ODM_CALLBACK_DECL(RecordChangePassword);
ODM_CALLBACK_DECL(NodeVerifyCredentialsExtended);

ODM_CALLBACK_DECL(NodeCopySubnodeNames);
ODM_CALLBACK_DECL(NodeCopyUnreachableSubnodeNames);
ODM_CALLBACK_DECL(NodeCopySupportedRecordTypes);
ODM_CALLBACK_DECL(NodeCopySupportedAttributes);
ODM_CALLBACK_DECL(NodeSetCredentials);
ODM_CALLBACK_DECL(NodeSetCredentialsExtended);
ODM_CALLBACK_DECL(NodeCreateRecord);
ODM_CALLBACK_DECL(NodeCustomCall);
ODM_CALLBACK_DECL(NodeCustomFunction);
ODM_CALLBACK_DECL(QueryCreateWithNode);
ODM_CALLBACK_DECL(QuerySynchronize);
ODM_CALLBACK_DECL(QueryCancel);
ODM_CALLBACK_DECL(RecordSetValue);
ODM_CALLBACK_DECL(RecordAddValue);
ODM_CALLBACK_DECL(RecordRemoveValue);
ODM_CALLBACK_DECL(RecordDelete);
ODM_CALLBACK_DECL(RecordCopyPolicies);
ODM_CALLBACK_DECL(RecordCopyEffectivePolicies);
ODM_CALLBACK_DECL(RecordCopySupportedPolicies);
ODM_CALLBACK_DECL(RecordSetPolicies);
ODM_CALLBACK_DECL(RecordRemovePolicy);
ODM_CALLBACK_DECL(NodeCopyPolicies);
ODM_CALLBACK_DECL(NodeCopySupportedPolicies);
ODM_CALLBACK_DECL(NodeSetPolicies);
ODM_CALLBACK_DECL(NodeRemovePolicy);

ODM_CALLBACK_DECL(RecordAddAccountPolicy);
ODM_CALLBACK_DECL(RecordRemoveAccountPolicy);
ODM_CALLBACK_DECL(RecordSetAccountPolicies);
ODM_CALLBACK_DECL(RecordCopyAccountPolicies);
ODM_CALLBACK_DECL(RecordAuthenticationAllowed);
ODM_CALLBACK_DECL(RecordPasswordChangeAllowed);
ODM_CALLBACK_DECL(RecordWillPasswordExpire);
ODM_CALLBACK_DECL(RecordWillAuthenticationsExpire);
ODM_CALLBACK_DECL(RecordSecondsUntilPasswordExpires);
ODM_CALLBACK_DECL(RecordSecondsUntilAuthenticationsExpire);
ODM_CALLBACK_DECL(RecordCopyPasswordContentSummary);
ODM_CALLBACK_DECL(NodeAddAccountPolicy);
ODM_CALLBACK_DECL(NodeRemoveAccountPolicy);
ODM_CALLBACK_DECL(NodeSetAccountPolicies);
ODM_CALLBACK_DECL(NodeCopyAccountPolicies);
ODM_CALLBACK_DECL(NodePasswordContentCheck);

#endif // __ODTYPES__
                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/include/os/                                                 0040755 0001750 0001750 00000000000 12612224753 020210  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/os/activity.h                                       0100644 0001750 0001750 00000023031 12567450543 022220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2013-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __OS_ACTIVITY_H__
#define __OS_ACTIVITY_H__

#include <Availability.h>
#include <os/base.h>
#include <stdint.h>

extern void *__dso_handle;

__BEGIN_DECLS

/*!
 * @typedef os_activity_t
 * An opaque value for the activity ID.
 */
typedef uint64_t os_activity_t;
typedef uint32_t os_breadcrumb_t;

#define OS_ACTIVITY_NULL 0
// No NULL for breadcrumb or activity_code

/*!
 * @typedef os_activity_flag_t
 * Flags for activity
 */
typedef uint32_t os_activity_flag_t;

/*!
 * @constant OS_ACTIVITY_FLAG_DEFAULT
 * Use the default flags for the activity.
 */
static const os_activity_flag_t OS_ACTIVITY_FLAG_DEFAULT = 0;

/*!
 * @constant: OS_ACTIVITY_FLAG_DETACHED
 * Creates an activity that is disassociated from the current activity
 */
static const os_activity_flag_t OS_ACTIVITY_FLAG_DETACHED = 0x1;

#pragma mark - activity related

/*!
 * @function os_activity_initiate
 *
 * @abstract
 * Synchronously initiates an activity using provided block.
 *
 * @discussion
 * Synchronously initiates an activity using the provided block and creates
 * a tracing buffer as appropriate.  All new activities are created as a
 * subactivity of an existing activity on the current thread.
 *
 *		os_activity_initiate("indexing database", OS_ACTIVITY_FLAG_DEFAULT, ^(void) {
 *			// either do work directly or issue work asynchronously
 *		});
 *
 * @param description
 * A constant string describing the activity, e.g., "performClick" or
 * "menuSelection".
 *
 * @param flags
 * Flags to be used when initiating the activity, typically OS_ACTIVITY_FLAG_DEFAULT.
 *
 * @param activity_block
 * The block to execute a given activity
 */
#define os_activity_initiate(description, flags, activity_block) __extension__({                            \
    _Static_assert(__builtin_constant_p(description), "activity description must be a constant string");    \
    __attribute__((section("__TEXT,__os_activity"))) static const char _d[] = description;                  \
    _os_activity_initiate(&__dso_handle, _d, flags, activity_block);                                        \
    __asm__(""); /* avoid tailcall */                                                                       \
})

/*!
 * @function os_activity_initiate_f
 *
 * @abstract
 * Synchronously initiates an activity using the provided function.
 *
 * @discussion
 * Synchronously initiates an activity using the provided function and creates
 * a tracing buffer as appropriate.  All new activities are created as a
 * subactivity of an existing activity on the current thread.
 *
 *		os_activity_initiate_f("indexing database", OS_ACTIVITY_FLAG_DEFAULT, context, function);
 *
 * @param description
 * A constant string describing the activity, e.g., "performClick" or
 * "menuSelection".
 *
 * @param flags
 * Flags to be used when initiating the activity, typically OS_ACTIVITY_FLAG_DEFAULT.
 *
 * @param context
 * An optional context that will be supplied to the activity function.
 *
 * @param activity_func
 * The function to execute for the new activity.
 */
#define os_activity_initiate_f(description, flags, context, activity_func) __extension__({                  \
    _Static_assert(__builtin_constant_p(description), "activity description must be a constant string");    \
    __attribute__((section("__TEXT,__os_activity"))) static const char _d[] = description;                  \
    _os_activity_initiate_f(&__dso_handle, _d, flags, context, activity_func);                              \
    __asm__(""); /* avoid tailcall */                                                                       \
})

/*!
 * @function os_activity_start
 *
 * @abstract
 * Starts a new activity immediately within the current context.
 *
 * @discussion
 * Starts a new activity immediately within the current context.
 *
 *		os_activity_t activity = os_activity_start("indexing database", OS_ACTIVITY_FLAG_DEFAULT);
 *		< do some work >
 *		os_activity_end(activity);
 *
 * The os_activity_t can be stored in a context if needed and ended at a later
 * time.
 *
 * @param description
 * A constant string describing the activity, e.g., "performClick" or
 * "menuSelection".
 *
 * @param flags
 * Flags to be used when initiating the activity, typically OS_ACTIVITY_FLAG_DEFAULT.
 *
 * @result
 * Returns a valid os_activity_t or 0 on failure.
 */
#define os_activity_start(description, flags) __extension__({                                               \
    _Static_assert(__builtin_constant_p(description), "activity description must be a constant string");    \
    __attribute__((section("__TEXT,__os_activity"))) static const char _d[] = description;                  \
    os_activity_t _aid = _os_activity_start(&__dso_handle, _d, flags);                                      \
    __asm__(""); /* avoid possibility of tail call through optimization */                                  \
    _aid;                                                                                                   \
})

/*!
 * @function os_activity_end
 *
 * @abstract
 * Ends the specified activity on the current thread.
 *
 * @discussion
 * Ends the specified activity on the current thread.  Does not signify anything
 * other than the originator has received control back from the activity.  Work
 * could still be in flight related to the activity.
 *
 * @param activity_id
 * An os_activity_t returned from os_activity_start.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW
void
os_activity_end(os_activity_t activity_id);

/*!
 * @function os_activity_get_active
 *
 * @abstract
 * Returns the stack of nested activities associated with the current thread.
 *
 * @discussion
 * Activities have a sense of nesting and therefore there could be more than
 * one activity involved on the current thread.  This should be used by
 * diagnostic tools only for making additional decisions about a situation.
 * 
 * @param entries
 * Pass a buffer of sufficient size to hold the the number of entries being
 * requested.
 *
 * @param count
 * Pointer to the requested number of activity identifiers.
 * On output will be filled with the number of activities that are available.
 *
 * @result
 * Number of activity identifiers written to 'entries'
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW
unsigned int
os_activity_get_active(os_activity_t *entries, unsigned int *count);

#pragma mark - application breadcrumbs

/*!
 * @function os_activity_set_breadcrumb
 *
 * @abstract
 * This flags the current activity as a "breadcrumb", i.e., an interesting event.
 *
 * @discussion
 * Not all activities are interesting events at the macro-level.  Some activities
 * can be flagged as a breadcrumb for evalutating cross activity interactions.
 * This can only be called once per activity, other requests will be ignored.
 *
 * @param name
 * A constant string that describes the breadcrumb.
 */
#define os_activity_set_breadcrumb(name) __extension__({                                            \
    _Static_assert(__builtin_constant_p(name), "breadcrumb name must be a constant string");        \
    __attribute__((section("__TEXT,__os_breadcrumb"))) static const char _m[] = name;               \
    _os_activity_set_breadcrumb(&__dso_handle, _m);                                                 \
    __asm__("");                                                                                    \
})

#pragma mark - internal routines

/*!
 * @function _os_activity_set_breadcrumb
 *
 * @abstract
 * Internal function for setting breadcrumb.  Do not use directly.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW
void
_os_activity_set_breadcrumb(void *dso, const char *name);

/*!
 * @function _os_activity_start
 *
 * @abstract
 * Internal function for activity start, do not use directly will not preserve
 * description.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW OS_WARN_RESULT
os_activity_t
_os_activity_start(void *dso, const char *description, os_activity_flag_t flags);

/*!
 * @function _os_activity_initiate
 *
 * @abstract
 * Do not use directly because your description will not be preserved.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW
void
_os_activity_initiate(void *dso, const char *description, os_activity_flag_t flags, void (^activity_block)(void));

/*!
 * @function _os_activity_initiate_f
 *
 * @abstract
 * Do not use directly because your description will not be preserved.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW
void
_os_activity_initiate_f(void *dso, const char *description, os_activity_flag_t flags, void *context, void (*activity_func)(void *context));

__END_DECLS

#endif // __OS_ACTIVITY_H__
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/include/os/base.h                                           0100644 0001750 0001750 00000010210 12566165766 021302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_APACHE_LICENSE_HEADER_START@
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @APPLE_APACHE_LICENSE_HEADER_END@
 */

#ifndef __OS_BASE__
#define __OS_BASE__

#include <sys/cdefs.h>

#ifndef __has_builtin
#define __has_builtin(x) 0
#endif
#ifndef __has_include
#define __has_include(x) 0
#endif
#ifndef __has_feature
#define __has_feature(x) 0
#endif
#ifndef __has_attribute
#define __has_attribute(x) 0
#endif
#ifndef __has_extension
#define __has_extension(x) 0
#endif

#if __GNUC__
#define OS_NORETURN __attribute__((__noreturn__))
#define OS_NOTHROW __attribute__((__nothrow__))
#define OS_NONNULL1 __attribute__((__nonnull__(1)))
#define OS_NONNULL2 __attribute__((__nonnull__(2)))
#define OS_NONNULL3 __attribute__((__nonnull__(3)))
#define OS_NONNULL4 __attribute__((__nonnull__(4)))
#define OS_NONNULL5 __attribute__((__nonnull__(5)))
#define OS_NONNULL6 __attribute__((__nonnull__(6)))
#define OS_NONNULL7 __attribute__((__nonnull__(7)))
#define OS_NONNULL8 __attribute__((__nonnull__(8)))
#define OS_NONNULL9 __attribute__((__nonnull__(9)))
#define OS_NONNULL10 __attribute__((__nonnull__(10)))
#define OS_NONNULL11 __attribute__((__nonnull__(11)))
#define OS_NONNULL12 __attribute__((__nonnull__(12)))
#define OS_NONNULL13 __attribute__((__nonnull__(13)))
#define OS_NONNULL14 __attribute__((__nonnull__(14)))
#define OS_NONNULL15 __attribute__((__nonnull__(15)))
#define OS_NONNULL_ALL __attribute__((__nonnull__))
#define OS_SENTINEL __attribute__((__sentinel__))
#define OS_PURE __attribute__((__pure__))
#define OS_CONST __attribute__((__const__))
#define OS_WARN_RESULT __attribute__((__warn_unused_result__))
#define OS_MALLOC __attribute__((__malloc__))
#define OS_USED __attribute__((__used__))
#define OS_UNUSED __attribute__((__unused__))
#define OS_WEAK __attribute__((__weak__))
#define OS_WEAK_IMPORT __attribute__((__weak_import__))
#define OS_NOINLINE __attribute__((__noinline__))
#define OS_ALWAYS_INLINE __attribute__((__always_inline__))
#define OS_TRANSPARENT_UNION __attribute__((__transparent_union__))
#define OS_ALIGNED(n) __attribute__((__aligned__((n))))
#define OS_FORMAT_PRINTF(x,y) __attribute__((__format__(printf,x,y)))
#define OS_EXPORT extern __attribute__((__visibility__("default")))
#define OS_INLINE static __inline__
#define OS_EXPECT(x, v) __builtin_expect((x), (v))
#else
#define OS_NORETURN
#define OS_NOTHROW
#define OS_NONNULL1
#define OS_NONNULL2
#define OS_NONNULL3
#define OS_NONNULL4
#define OS_NONNULL5
#define OS_NONNULL6
#define OS_NONNULL7
#define OS_NONNULL8
#define OS_NONNULL9
#define OS_NONNULL10
#define OS_NONNULL11
#define OS_NONNULL12
#define OS_NONNULL13
#define OS_NONNULL14
#define OS_NONNULL15
#define OS_NONNULL_ALL
#define OS_SENTINEL
#define OS_PURE
#define OS_CONST
#define OS_WARN_RESULT
#define OS_MALLOC
#define OS_USED
#define OS_UNUSED
#define OS_WEAK
#define OS_WEAK_IMPORT
#define OS_NOINLINE
#define OS_ALWAYS_INLINE
#define OS_TRANSPARENT_UNION
#define OS_ALIGNED(n)
#define OS_FORMAT_PRINTF(x,y)
#define OS_EXPORT extern
#define OS_INLINE static inline
#define OS_EXPECT(x, v) (x)
#endif

#if __has_extension(attribute_overloadable)
#define OS_OVERLOADABLE __attribute__((__overloadable__))
#else
#define OS_OVERLOADABLE
#endif

#if __has_feature(objc_fixed_enum) || __has_extension(cxx_strong_enums)
#define OS_ENUM(_name, _type, ...) \
		typedef enum : _type { __VA_ARGS__ } _name##_t
#else
#define OS_ENUM(_name, _type, ...) \
		enum { __VA_ARGS__ }; typedef _type _name##_t
#endif

#define __OS_STRINGIFY(s) #s
#define OS_STRINGIFY(s) __OS_STRINGIFY(s)
#define __OS_CONCAT(x, y) x ## y
#define OS_CONCAT(x, y) __OS_CONCAT(x, y)

#endif // __OS_BASE__
                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/os/object.h                                         0100644 0001750 0001750 00000012134 12566166403 021632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2011-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_APACHE_LICENSE_HEADER_START@
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @APPLE_APACHE_LICENSE_HEADER_END@
 */

#ifndef __OS_OBJECT__
#define __OS_OBJECT__

#ifdef __APPLE__
#include <Availability.h>
#endif
#include <os/base.h>

/*!
 * @header
 *
 * @preprocinfo
 * By default, libSystem objects such as GCD and XPC objects are declared as
 * Objective-C types when building with an Objective-C compiler. This allows
 * them to participate in ARC, in RR management by the Blocks runtime and in
 * leaks checking by the static analyzer, and enables them to be added to Cocoa
 * collections.
 *
 * NOTE: this requires explicit cancellation of dispatch sources and xpc
 *       connections whose handler blocks capture the source/connection object,
 *       resp. ensuring that such captures do not form retain cycles (e.g. by
 *       declaring the source as __weak).
 *
 * To opt-out of this default behavior, add -DOS_OBJECT_USE_OBJC=0 to your
 * compiler flags.
 *
 * This mode requires a platform with the modern Objective-C runtime, the
 * Objective-C GC compiler option to be disabled, and at least a Mac OS X 10.8
 * or iOS 6.0 deployment target.
 */

#ifndef OS_OBJECT_HAVE_OBJC_SUPPORT
#if defined(__OBJC__) && defined(__OBJC2__) && !defined(__OBJC_GC__) && ( \
		__MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_8 || \
		__IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_6_0)
#define OS_OBJECT_HAVE_OBJC_SUPPORT 1
#else
#define OS_OBJECT_HAVE_OBJC_SUPPORT 0
#endif
#endif

#if OS_OBJECT_HAVE_OBJC_SUPPORT
#ifndef OS_OBJECT_USE_OBJC
#define OS_OBJECT_USE_OBJC 1
#endif
#elif defined(OS_OBJECT_USE_OBJC) && OS_OBJECT_USE_OBJC
/* Unsupported platform for OS_OBJECT_USE_OBJC=1 */
#undef OS_OBJECT_USE_OBJC
#define OS_OBJECT_USE_OBJC 0
#else
#define OS_OBJECT_USE_OBJC 0
#endif

#if OS_OBJECT_USE_OBJC
#import <objc/NSObject.h>
#define OS_OBJECT_CLASS(name) OS_##name
#define OS_OBJECT_DECL_IMPL(name, ...) \
		@protocol OS_OBJECT_CLASS(name) __VA_ARGS__ \
		@end \
		typedef NSObject<OS_OBJECT_CLASS(name)> *name##_t
#define OS_OBJECT_DECL(name, ...) \
		OS_OBJECT_DECL_IMPL(name, <NSObject> __VA_ARGS__)
#define OS_OBJECT_DECL_SUBCLASS(name, super) \
		OS_OBJECT_DECL_IMPL(name, <OS_OBJECT_CLASS(super)>)
#if defined(__has_attribute)
#if __has_attribute(ns_returns_retained)
#define OS_OBJECT_RETURNS_RETAINED __attribute__((__ns_returns_retained__))
#else
#define OS_OBJECT_RETURNS_RETAINED
#endif
#if __has_attribute(ns_consumed)
#define OS_OBJECT_CONSUMED __attribute__((__ns_consumed__))
#else
#define OS_OBJECT_CONSUMED
#endif
#else
#define OS_OBJECT_RETURNS_RETAINED
#define OS_OBJECT_CONSUMED
#endif
#if defined(__has_feature)
#if __has_feature(objc_arc)
#define OS_OBJECT_BRIDGE __bridge
#define OS_WARN_RESULT_NEEDS_RELEASE
#else
#define OS_OBJECT_BRIDGE
#define OS_WARN_RESULT_NEEDS_RELEASE OS_WARN_RESULT
#endif
#else
#define OS_OBJECT_BRIDGE
#define OS_WARN_RESULT_NEEDS_RELEASE OS_WARN_RESULT
#endif
#ifndef OS_OBJECT_USE_OBJC_RETAIN_RELEASE
#if defined(__clang_analyzer__)
#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 1
#elif defined(__has_feature)
#if __has_feature(objc_arc)
#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 1
#else
#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 0
#endif
#else
#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 0
#endif
#endif
#else
/*! @parseOnly */
#define OS_OBJECT_RETURNS_RETAINED
/*! @parseOnly */
#define OS_OBJECT_CONSUMED
/*! @parseOnly */
#define OS_OBJECT_BRIDGE
/*! @parseOnly */
#define OS_WARN_RESULT_NEEDS_RELEASE OS_WARN_RESULT
#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 0
#endif

#define OS_OBJECT_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&(object))

__BEGIN_DECLS

/*!
 * @function os_retain
 *
 * @abstract
 * Increment the reference count of an os_object.
 *
 * @discussion
 * On a platform with the modern Objective-C runtime this is exactly equivalent
 * to sending the object the -[retain] message.
 *
 * @param object
 * The object to retain.
 *
 * @result
 * The retained object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0)
OS_EXPORT
void*
os_retain(void *object);
#if OS_OBJECT_USE_OBJC
#undef os_retain
#define os_retain(object) [object retain]
#endif

/*!
 * @function os_release
 *
 * @abstract
 * Decrement the reference count of a os_object.
 *
 * @discussion
 * On a platform with the modern Objective-C runtime this is exactly equivalent
 * to sending the object the -[release] message.
 *
 * @param object
 * The object to release.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0)
OS_EXPORT
void
os_release(void *object);
#if OS_OBJECT_USE_OBJC
#undef os_release
#define os_release(object) [object release]
#endif

__END_DECLS

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/include/os/trace.h                                          0100644 0001750 0001750 00000064270 12567450543 021474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2013-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __OS_TRACE_H__
#define __OS_TRACE_H__

#include <Availability.h>
#include <os/base.h>
#include <sys/types.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#if __has_include(<xpc/xpc.h>)
#include <xpc/xpc.h>
#else
typedef void *xpc_object_t;
#endif

#if !__GNUC__
#error "must be GNU C compatible"
#endif

extern void *__dso_handle;

OS_ALWAYS_INLINE
static inline void
_os_trace_verify_printf(const char *msg, ...) __attribute__((format(printf, 1, 2)))
{
#pragma unused(msg)
}

#if !defined OS_COUNT_ARGS
#define OS_COUNT_ARGS(...) OS_COUNT_ARGS1(, ##__VA_ARGS__, _8, _7, _6, _5, _4, _3, _2, _1, _0)
#define OS_COUNT_ARGS1(z, a, b, c, d, e, f, g, h, cnt, ...) cnt
#endif

#define _os_trace_0(_l, _m, _t) __extension__({ \
	_os_trace_verify_printf(_l); \
	_os_trace_with_buffer(&__dso_handle, _m, _t, NULL, 0, NULL); \
	__asm__(""); /* avoid tailcall */ \
})

#define _os_trace_1(_l, _m, _t, _1) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	_os_trace_verify_printf(_l, _c1); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		unsigned char _s[2]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._s[1] = 1, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_2(_l, _m, _t, _1, _2) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	_os_trace_verify_printf(_l, _c1, _c2); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		unsigned char _s[3]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._s[2] = 2, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_3(_l, _m, _t, _1, _2, _3) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		unsigned char _s[4]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._s[3] = 3, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_4(_l, _m, _t, _1, _2, _3, _4) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		unsigned char _s[5]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._s[4] = 4, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_5(_l, _m, _t, _1, _2, _3, _4, _5) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	const __typeof__(_5) _c5 = _5; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4, _c5); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		__typeof__(_c5) _f5; \
		unsigned char _s[6]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._f5 = _c5, ._s[4] = sizeof(_c5), \
		._s[5] = 5, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_6(_l, _m, _t, _1, _2, _3, _4, _5, _6) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	const __typeof__(_5) _c5 = _5; \
	const __typeof__(_6) _c6 = _6; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4, _c5, _c6); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		__typeof__(_c5) _f5; \
		__typeof__(_c6) _f6; \
		unsigned char _s[7]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._f5 = _c5, ._s[4] = sizeof(_c5), \
		._f6 = _c6, ._s[5] = sizeof(_c6), \
		._s[6] = 6, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_7(_l, _m, _t, _1, _2, _3, _4, _5, _6, _7) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	const __typeof__(_5) _c5 = _5; \
	const __typeof__(_6) _c6 = _6; \
	const __typeof__(_7) _c7 = _7; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4, _c5, _c6, _c7); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		__typeof__(_c5) _f5; \
		__typeof__(_c6) _f6; \
		__typeof__(_c7) _f7; \
		unsigned char _s[8]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._f5 = _c5, ._s[4] = sizeof(_c5), \
		._f6 = _c6, ._s[5] = sizeof(_c6), \
		._f7 = _c7, ._s[6] = sizeof(_c7), \
		._s[7] = 7, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), NULL); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_1(_l, _m, _t, _payload) __extension__({ \
	_os_trace_verify_printf(_l); \
	_os_trace_with_buffer(&__dso_handle, _m, _t, NULL, 0, _payload); \
	__asm__(""); /* avoid tailcall */ \
})

#define _os_trace_with_payload_2(_l, _m, _t, _1, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	_os_trace_verify_printf(_l, _c1); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		unsigned char _s[2]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._s[1] = 1, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_3(_l, _m, _t, _1, _2, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	_os_trace_verify_printf(_l, _c1, _c2); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		unsigned char _s[3]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._s[2] = 2, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_4(_l, _m, _t, _1, _2, _3, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		unsigned char _s[4]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._s[3] = 3, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_5(_l, _m, _t, _1, _2, _3, _4, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		unsigned char _s[5]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._s[4] = 4, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_6(_l, _m, _t, _1, _2, _3, _4, _5, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	const __typeof__(_4) _c5 = _5; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4, _c5); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		__typeof__(_c5) _f5; \
		unsigned char _s[6]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._f5 = _c5, ._s[4] = sizeof(_c5), \
		._s[5] = 5, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_7(_l, _m, _t, _1, _2, _3, _4, _5, _6, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	const __typeof__(_5) _c5 = _5; \
	const __typeof__(_6) _c6 = _6; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4, _c5, _c6); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		__typeof__(_c5) _f5; \
		__typeof__(_c6) _f6; \
		unsigned char _s[7]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._f5 = _c5, ._s[4] = sizeof(_c5), \
		._f6 = _c6, ._s[5] = sizeof(_c6), \
		._s[6] = 6, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

#define _os_trace_with_payload_8(_l, _m, _t, _1, _2, _3, _4, _5, _6, _7, _payload) __extension__({ \
        _Pragma("clang diagnostic push") \
        _Pragma("clang diagnostic ignored \"-Wpacked\"") \
	const __typeof__(_1) _c1 = _1; \
	const __typeof__(_2) _c2 = _2; \
	const __typeof__(_3) _c3 = _3; \
	const __typeof__(_4) _c4 = _4; \
	const __typeof__(_5) _c5 = _5; \
	const __typeof__(_6) _c6 = _6; \
	const __typeof__(_7) _c7 = _7; \
	_os_trace_verify_printf(_l, _c1, _c2, _c3, _c4, _c5, _c6, _c7); \
	const struct __attribute__((packed)) { \
		__typeof__(_c1) _f1; \
		__typeof__(_c2) _f2; \
		__typeof__(_c3) _f3; \
		__typeof__(_c4) _f4; \
		__typeof__(_c5) _f5; \
		__typeof__(_c6) _f6; \
		__typeof__(_c7) _f7; \
		unsigned char _s[8]; \
	} _buf = { \
		._f1 = _c1, ._s[0] = sizeof(_c1), \
		._f2 = _c2, ._s[1] = sizeof(_c2), \
		._f3 = _c3, ._s[2] = sizeof(_c3), \
		._f4 = _c4, ._s[3] = sizeof(_c4), \
		._f5 = _c5, ._s[4] = sizeof(_c5), \
		._f6 = _c6, ._s[5] = sizeof(_c6), \
		._f7 = _c7, ._s[6] = sizeof(_c7), \
		._s[7] = 7, \
	}; \
	_os_trace_with_buffer(&__dso_handle, _m, _t, &_buf, sizeof(_buf), _payload); \
	__asm__(""); /* avoid tailcall */ \
        _Pragma("clang diagnostic pop") \
})

/*!
 *
 * @abstract
 * Hashtags in trace messages
 *
 * @discussion
 * Developers are encouraged to include hashtags in log messages, regardless of what API you use.
 * A hashtag is composed of a hash (#) symbol, followed by at least three non-whitespace characters,
 * terminated by whitespace or the end of the message. Hashtags may not begin with a number.
 *
 * Below is the list of predefined tags:
 *   #System     - Message in the context of a system process.
 *   #User       - Message in the context of a user process.
 *   #Developer  - Message in the context of software development. For example, deprecated APIs and debugging messages.
 *   #Attention  - Message that should be investigated by a system administrator, because it may be a sign of a larger issue.
 *     For example, errors from a hard drive controller that typically occur when the drive is about to fail.
 *   #Critical   - Message in the context of a critical event or critical failure.
 *   #Error      - Message that is a noncritical error.
 *   #Comment    - Message that is a comment.
 *   #Marker     - Message that marks a change to divide the messages around it into those before and those after the change.
 *   #Clue       - Message containing extra key/value pairs with additional information to help reconstruct the context.
 *   #Security   - Message related to security concerns.
 *   #Filesystem - Message describing a file system related event.
 *   #Network    - Message describing a network-related event.
 *   #Hardware   - Message describing a hardware-related event.
 *   #CPU        - Message describing CPU related event, e.g., initiating heavy work load
 *   #State      - Message describing state changed, e.g., global state, preference, etc.
 *   #Graphics   - Message describing significant graphics event
 *   #Disk       - Message describing disk activity
 *
 */

#pragma mark - Other defines

/*!
 * @define OS_TRACE_TYPE_RELEASE
 * Trace messages to be recorded on a typical user install.  These should be
 * limited to things which improve diagnosis of a failure/crash/hang. Trace
 * buffers are generally smaller on a production system.
 */
#define OS_TRACE_TYPE_RELEASE (1u << 0)

/*!
 * @define OS_TRACE_TYPE_DEBUG
 * Trace messages to be recorded while debugger or other development tool is
 * attached to the originator.
 */
#define OS_TRACE_TYPE_DEBUG (1u << 1)

/*!
 * @define OS_TRACE_TYPE_ERROR
 * Trace the message as an error and force a collection as a failure may be
 * imminent.
 */
#define OS_TRACE_TYPE_ERROR ((1u << 6) | (1u << 0))

/*!
 * @define OS_TRACE_TYPE_FAULT
 * Trace the message as a fatal error which forces a collection and a diagnostic
 * to be initiated.
 */
#define OS_TRACE_TYPE_FAULT ((1u << 7) | (1u << 6) | (1u << 0))

__BEGIN_DECLS

/*!
 * @typedef os_trace_payload_t
 * A block that populates an xpc_object_t of type XPC_TYPE_DICTIONARY to represent
 * complex data. This block will only be invoked under conditions where tools
 * have attached to the process. The payload can be used to send arbitrary data 
 * via the trace call. Tools may use the data to validate state for integration 
 * tests or provide other introspection services. No assumptions are made about 
 * the format or structure of the data.
 */
typedef void (^os_trace_payload_t)(xpc_object_t xdict);

#pragma mark - function declarations

/*!
 * @function os_trace
 *
 * @abstract
 * Insert a trace message into a buffer pool for later decoding.
 *
 * @discussion
 * Trace message that will be recorded on a typical user install. These should
 * be limited to things which help diagnose a failure during postmortem
 * analysis. Trace buffers are generally smaller on a production system.
 *
 * @param format
 * A printf-style format string to generate a human-readable log message when
 * the trace line is decoded.  Only scalar types are supported, attempts
 * to pass arbitrary strings will store a pointer that is unresolvable and
 * will generate an error during decode.
 *
 *		os_trace("network event: %ld, last seen: %ld, avg: %g", event_id, last_seen, avg);
 */
#define os_trace(format, ...) __extension__({                                                           \
    _Pragma("clang diagnostic push")                                                                    \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat-pedantic\"")                                     \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                   \
    __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;                      \
    OS_CONCAT(_os_trace, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_RELEASE, ##__VA_ARGS__); \
    _Pragma("clang diagnostic pop")                                                                     \
})

/*!
 * @function os_trace_debug
 *
 * @abstract
 * Insert a trace message into a buffer pool for later decoding.
 *
 * @discussion
 * Trace message to be recorded while debugger or other development tool is
 * attached to the originator.  This is transported interprocess to help
 * diagnose the entire call chain including external helpers.
 *
 * @param format
 * A printf-style format string that represents a human-readable message when
 * the trace line is decoded.  Only scalar types are supported, attempts
 * to pass arbitrary strings will store a pointer that is unresolvable and
 * will generate an error during decode.
 *
 *		os_trace_debug("network interface status %ld", status);
 */
#define os_trace_debug(format, ...) __extension__({                                                     \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                   \
    __attribute__((section("__TEXT,__os_trace_dbg"))) static const char _m[] = format;                  \
    OS_CONCAT(_os_trace, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_DEBUG, ##__VA_ARGS__);   \
})

/*!
 * @function os_trace_debug_enabled
 *
 * @abstract
 * Avoid unnecessary work for a trace point by checking if debug level is enabled.
 *
 * @discussion
 * Avoid unnecessary work for a trace point by checking if debug level is enabled.
 * Generally trace points should not involve expensive operations, but some
 * circumstances warrant it.  Use this function to avoid doing the work unless
 * debug level trace messages are requested.
 *
 *	if (os_trace_debug_enabled()) {
 *		os_trace_debug("value = %d, average = %d",
 *				[[dict objectForKey: @"myKey"] intValue],
 *				(int) [self getAverage: dict]);
 *	}
 *
 * @result
 * Returns true if debug mode is enabled.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW OS_WARN_RESULT
bool
os_trace_debug_enabled(void);

/*!
 * @function os_trace_error
 *
 * @abstract
 * Trace the message as an error and force a collection of the trace buffer as a
 * failure may be imminent.
 *
 * @discussion
 * Trace the message as an error and force a collection of the trace buffer as a
 * failure may be imminent.
 *
 * @param format
 * A printf-style format string to generate a human-readable log message when
 * the trace line is decoded.  Only scalar types are supported, attempts
 * to pass arbitrary strings will store a pointer that is unresolvable and
 * will generate an error during decode.
 *
 *		os_trace_error("socket %d connection timeout %ld", fd, secs);
 */
#define os_trace_error(format, ...) __extension__({                                                     \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                   \
    __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;                      \
    OS_CONCAT(_os_trace, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_ERROR, ##__VA_ARGS__);   \
})

/*!
 * @function os_trace_fault
 *
 * @abstract
 * Trace the message as a fault which forces a collection of the trace buffer
 * and diagnostic of the activity.
 *
 * @discussion
 * Trace the message as a fault which forces a collection of the trace buffer
 * and diagnostic of the activity.
 *
 * @param format
 * A printf-style format string to generate a human-readable log message when
 * the trace line is decoded.  Only scalar types are supported, attempts
 * to pass arbitrary strings will store a pointer that is unresolvable and
 * will generate an error during decode.
 *
 *		os_trace_fault("failed to lookup uid %d - aborting", uid);
 */
#define os_trace_fault(format, ...) __extension__({                                                     \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                   \
    __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;                      \
    OS_CONCAT(_os_trace, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_FAULT, ##__VA_ARGS__);   \
})

#if __has_include(<xpc/xpc.h>)
/*!
 * @function os_trace_with_payload
 *
 * @abstract
 * Add a trace entry containing the provided values and call the block if
 * appropriate.
 *
 * @discussion
 * Will insert a trace entry into a limited ring buffer for an activity or
 * process.  Trace points are for recording interesting data that would improve
 * diagnosis of unexpected crashes, failures and hangs.  The block will only be
 * called under the required conditions.
 *
 * @param trace_msg
 * A printf-style format string to generate a human-readable log message when
 * the trace line is decoded.  Only scalar types are supported. Attempts
 * to pass arbitrary strings will store a pointer that is unresolvable and
 * will generate an error during decode.
 *
 * The final parameter must be a block of type os_trace_payload_t.
 *
 *   os_trace_with_payload("network event %ld", event, ^(xpc_object_t xdict) {
 *
 *		// validate the network interface and address where what was expected
 *		xpc_dictionary_set_string(xdict, "network", ifp->ifa_name);
 *		xpc_dictionary_set_string(xdict, "ip_address", _get_address(ifp));
 *   });
 */
#define os_trace_with_payload(format, ...) __extension__({                                                              \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                                   \
    __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;                                      \
    OS_CONCAT(_os_trace_with_payload, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_RELEASE, ##__VA_ARGS__);    \
})

#define os_trace_debug_with_payload(format, ...) __extension__({                                                    \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                               \
    __attribute__((section("__TEXT,__os_trace_dbg"))) static const char _m[] = format;                              \
    OS_CONCAT(_os_trace_with_payload, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_DEBUG, ##__VA_ARGS__);  \
})

#define os_trace_error_with_payload(format, ...) __extension__({                                                    \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                               \
    __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;                                  \
    OS_CONCAT(_os_trace_with_payload, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_ERROR, ##__VA_ARGS__);  \
})

#define os_trace_fault_with_payload(format, ...) __extension__({                                                    \
    _Static_assert(__builtin_constant_p(format), "format must be a constant string");                               \
    __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;                                  \
    OS_CONCAT(_os_trace_with_payload, OS_COUNT_ARGS(__VA_ARGS__))(format, _m, OS_TRACE_TYPE_FAULT, ##__VA_ARGS__);  \
})

#endif // __has_include(<xpc/xpc.h>)

/*!
 * @function _os_trace_with_buffer
 *
 * @abstract
 * Internal function to support pre-encoded buffer.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_NOTHROW
void
_os_trace_with_buffer(void *dso, const char *message, uint8_t type, const void *buffer, size_t buffer_size, os_trace_payload_t payload);

__END_DECLS

#endif // __OS_TRACE_H__
                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/panel.h                                             0100644 0001750 0001750 00000007272 12566174414 021052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /****************************************************************************
 * Copyright (c) 1998-2001,2006 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1995                    *
 *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *
 ****************************************************************************/

/* $Id: panel.h,v 1.10 2006/05/27 19:49:40 tom Exp $ */

/* panel.h -- interface file for panels library */

#ifndef NCURSES_PANEL_H_incl
#define NCURSES_PANEL_H_incl 1

#include <curses.h>

typedef struct panel
{
  WINDOW *win;
  struct panel *below;
  struct panel *above;
  NCURSES_CONST void *user;
} PANEL;

#if	defined(__cplusplus)
extern "C" {
#endif

extern NCURSES_EXPORT(WINDOW*) panel_window (const PANEL *);
extern NCURSES_EXPORT(void)    update_panels (void);
extern NCURSES_EXPORT(int)     hide_panel (PANEL *);
extern NCURSES_EXPORT(int)     show_panel (PANEL *);
extern NCURSES_EXPORT(int)     del_panel (PANEL *);
extern NCURSES_EXPORT(int)     top_panel (PANEL *);
extern NCURSES_EXPORT(int)     bottom_panel (PANEL *);
extern NCURSES_EXPORT(PANEL*)  new_panel (WINDOW *);
extern NCURSES_EXPORT(PANEL*)  panel_above (const PANEL *);
extern NCURSES_EXPORT(PANEL*)  panel_below (const PANEL *);
extern NCURSES_EXPORT(int)     set_panel_userptr (PANEL *, NCURSES_CONST void *);
extern NCURSES_EXPORT(NCURSES_CONST void*) panel_userptr (const PANEL *);
extern NCURSES_EXPORT(int)     move_panel (PANEL *, int, int);
extern NCURSES_EXPORT(int)     replace_panel (PANEL *,WINDOW *);
extern NCURSES_EXPORT(int)     panel_hidden (const PANEL *);

#if	defined(__cplusplus)
}
#endif

#endif /* NCURSES_PANEL_H_incl */

/* end of panel.h */
                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/paths.h                                             0100644 0001750 0001750 00000010147 12566166136 021067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: paths.h,v 1.10 1997/11/09 00:29:02 bri Exp $	*/
/*	$NetBSD: paths.h,v 1.10 1997/04/23 09:41:38 lukem Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)paths.h	8.1 (Berkeley) 6/2/93
 */

#ifndef _PATHS_H_
#define	_PATHS_H_

/* Default search path. */
#define	_PATH_DEFPATH	"/usr/bin:/bin"
/* All standard utilities path. */
#define	_PATH_STDPATH	"/usr/bin:/bin:/usr/sbin:/sbin"

#define	_PATH_BSHELL	"/bin/sh"
#define	_PATH_CONSOLE	"/dev/console"
#define	_PATH_CSHELL	"/bin/csh"
#define _PATH_DEFTAPE	"/dev/nrst0"
#define	_PATH_DEVDB	"/var/run/dev.db"
#define	_PATH_DEVNULL	"/dev/null"
#define	_PATH_DRUM	"/dev/drum"
#define	_PATH_FSIRAND	"/sbin/fsirand"
#define	_PATH_KMEM	"/dev/kmem"
#define	_PATH_KVMDB	"/var/db/kvm.db"
#define	_PATH_LOCALE	"/usr/share/locale"
#define	_PATH_MAILDIR	"/var/mail"
#define	_PATH_MAN	"/usr/share/man"
#define	_PATH_MEM	"/dev/mem"
#define	_PATH_NOLOGIN	"/etc/nologin"
#define	_PATH_RSH	"/usr/bin/rsh"
#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
#define	_PATH_SHELLS	"/etc/shells"
#define	_PATH_TTY	"/dev/tty"
#define	_PATH_UNIX	"/mach"
#define	_PATH_VI	"/usr/bin/vi"

/* Provide trailing slash, since mostly used for building pathnames. */
#define	_PATH_DEV	"/dev/"
#define	_PATH_TMP	"/tmp/"
#define	_PATH_UUCPLOCK	"/var/spool/lock/"
#define	_PATH_VARDB	"/var/db/"
#define	_PATH_VARRUN	"/var/run/"
#define	_PATH_VARTMP	"/var/tmp/"

#include <sys/paths.h>

#endif /* !_PATHS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/                                               0040755 0001750 0001750 00000000000 12612224753 020512  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/bpf.h                                          0100644 0001750 0001750 00000122135 12566174043 021437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*-
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence 
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)bpf.h       7.1 (Berkeley) 5/7/91
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap/bpf.h,v 1.32 2008-12-23 20:13:29 guy Exp $ (LBL)
 */

/*
 * This is libpcap's cut-down version of bpf.h; it includes only
 * the stuff needed for the code generator and the userland BPF
 * interpreter, and the libpcap APIs for setting filters, etc..
 *
 * "pcap-bpf.c" will include the native OS version, as it deals with
 * the OS's BPF implementation.
 *
 * At least two programs found by Google Code Search explicitly includes
 * <pcap/bpf.h> (even though <pcap.h>/<pcap/pcap.h> includes it for you),
 * so moving that stuff to <pcap/pcap.h> would break the build for some
 * programs.
 */

/*
 * If we've already included <net/bpf.h>, don't re-define this stuff.
 * We assume BSD-style multiple-include protection in <net/bpf.h>,
 * which is true of all but the oldest versions of FreeBSD and NetBSD,
 * or Tru64 UNIX-style multiple-include protection (or, at least,
 * Tru64 UNIX 5.x-style; I don't have earlier versions available to check),
 * or AIX-style multiple-include protection (or, at least, AIX 5.x-style;
 * I don't have earlier versions available to check).
 *
 * We do not check for BPF_MAJOR_VERSION, as that's defined by
 * <linux/filter.h>, which is directly or indirectly included in some
 * programs that also include pcap.h, and <linux/filter.h> doesn't
 * define stuff we need.
 *
 * This also provides our own multiple-include protection.
 */
#if !defined(_NET_BPF_H_) && !defined(_BPF_H_) && !defined(_H_BPF) && !defined(lib_pcap_bpf_h)
#define lib_pcap_bpf_h

#ifdef __cplusplus
extern "C" {
#endif

/* BSD style release date */
#define BPF_RELEASE 199606

#ifdef MSDOS /* must be 32-bit */
typedef long          bpf_int32;
typedef unsigned long bpf_u_int32;
#else
typedef	int bpf_int32;
typedef	u_int bpf_u_int32;
#endif

/*
 * Alignment macros.  BPF_WORDALIGN rounds up to the next 
 * even multiple of BPF_ALIGNMENT.
 *
 * Tcpdump's print-pflog.c uses this, so we define it here.
 */
#ifndef __NetBSD__
#define BPF_ALIGNMENT sizeof(bpf_int32)
#else
#define BPF_ALIGNMENT sizeof(long)
#endif
#define BPF_WORDALIGN(x) (((x)+(BPF_ALIGNMENT-1))&~(BPF_ALIGNMENT-1))

/*
 * Structure for "pcap_compile()", "pcap_setfilter()", etc..
 */
struct bpf_program {
	u_int bf_len;
	struct bpf_insn *bf_insns;
};
 
/*
 * Link-layer header type codes.
 *
 * Do *NOT* add new values to this list without asking
 * "tcpdump-workers@lists.tcpdump.org" for a value.  Otherwise, you run
 * the risk of using a value that's already being used for some other
 * purpose, and of having tools that read libpcap-format captures not
 * being able to handle captures with your new DLT_ value, with no hope
 * that they will ever be changed to do so (as that would destroy their
 * ability to read captures using that value for that other purpose).
 *
 * See
 *
 *	http://www.tcpdump.org/linktypes.html
 *
 * for detailed descriptions of some of these link-layer header types.
 */

/*
 * These are the types that are the same on all platforms, and that
 * have been defined by <net/bpf.h> for ages.
 */
#define DLT_NULL	0	/* BSD loopback encapsulation */
#define DLT_EN10MB	1	/* Ethernet (10Mb) */
#define DLT_EN3MB	2	/* Experimental Ethernet (3Mb) */
#define DLT_AX25	3	/* Amateur Radio AX.25 */
#define DLT_PRONET	4	/* Proteon ProNET Token Ring */
#define DLT_CHAOS	5	/* Chaos */
#define DLT_IEEE802	6	/* 802.5 Token Ring */
#define DLT_ARCNET	7	/* ARCNET, with BSD-style header */
#define DLT_SLIP	8	/* Serial Line IP */
#define DLT_PPP		9	/* Point-to-point Protocol */
#define DLT_FDDI	10	/* FDDI */

/*
 * These are types that are different on some platforms, and that
 * have been defined by <net/bpf.h> for ages.  We use #ifdefs to
 * detect the BSDs that define them differently from the traditional
 * libpcap <net/bpf.h>
 *
 * XXX - DLT_ATM_RFC1483 is 13 in BSD/OS, and DLT_RAW is 14 in BSD/OS,
 * but I don't know what the right #define is for BSD/OS.
 */
#define DLT_ATM_RFC1483	11	/* LLC-encapsulated ATM */

#ifdef __OpenBSD__
#define DLT_RAW		14	/* raw IP */
#else
#define DLT_RAW		12	/* raw IP */
#endif

/*
 * Given that the only OS that currently generates BSD/OS SLIP or PPP
 * is, well, BSD/OS, arguably everybody should have chosen its values
 * for DLT_SLIP_BSDOS and DLT_PPP_BSDOS, which are 15 and 16, but they
 * didn't.  So it goes.
 */
#if defined(__NetBSD__) || defined(__FreeBSD__)
#ifndef DLT_SLIP_BSDOS
#define DLT_SLIP_BSDOS	13	/* BSD/OS Serial Line IP */
#define DLT_PPP_BSDOS	14	/* BSD/OS Point-to-point Protocol */
#endif
#else
#define DLT_SLIP_BSDOS	15	/* BSD/OS Serial Line IP */
#define DLT_PPP_BSDOS	16	/* BSD/OS Point-to-point Protocol */
#endif

/*
 * 17 was used for DLT_PFLOG in OpenBSD; it no longer is.
 *
 * It was DLT_LANE8023 in SuSE 6.3, so we defined LINKTYPE_PFLOG
 * as 117 so that pflog captures would use a link-layer header type
 * value that didn't collide with any other values.  On all
 * platforms other than OpenBSD, we defined DLT_PFLOG as 117,
 * and we mapped between LINKTYPE_PFLOG and DLT_PFLOG.
 *
 * OpenBSD eventually switched to using 117 for DLT_PFLOG as well.
 *
 * Don't use 17 for anything else.
 */

/*
 * 18 is used for DLT_PFSYNC in OpenBSD, NetBSD, DragonFly BSD and
 * Mac OS X; don't use it for anything else.  (FreeBSD uses 121,
 * which collides with DLT_HHDLC, even though it doesn't use 18
 * for anything and doesn't appear to have ever used it for anything.)
 *
 * We define it as 18 on those platforms; it is, unfortunately, used
 * for DLT_CIP in Suse 6.3, so we don't define it as DLT_PFSYNC
 * in general.  As the packet format for it, like that for
 * DLT_PFLOG, is not only OS-dependent but OS-version-dependent,
 * we don't support printing it in tcpdump except on OSes that
 * have the relevant header files, so it's not that useful on
 * other platforms.
 */
#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__APPLE__)
#define DLT_PFSYNC	18
#endif

#define DLT_ATM_CLIP	19	/* Linux Classical-IP over ATM */

/*
 * Apparently Redback uses this for its SmartEdge 400/800.  I hope
 * nobody else decided to use it, too.
 */
#define DLT_REDBACK_SMARTEDGE	32

/*
 * These values are defined by NetBSD; other platforms should refrain from
 * using them for other purposes, so that NetBSD savefiles with link
 * types of 50 or 51 can be read as this type on all platforms.
 */
#define DLT_PPP_SERIAL	50	/* PPP over serial with HDLC encapsulation */
#define DLT_PPP_ETHER	51	/* PPP over Ethernet */

/*
 * The Axent Raptor firewall - now the Symantec Enterprise Firewall - uses
 * a link-layer type of 99 for the tcpdump it supplies.  The link-layer
 * header has 6 bytes of unknown data, something that appears to be an
 * Ethernet type, and 36 bytes that appear to be 0 in at least one capture
 * I've seen.
 */
#define DLT_SYMANTEC_FIREWALL	99

/*
 * Values between 100 and 103 are used in capture file headers as
 * link-layer header type LINKTYPE_ values corresponding to DLT_ types
 * that differ between platforms; don't use those values for new DLT_
 * new types.
 */

/*
 * Values starting with 104 are used for newly-assigned link-layer
 * header type values; for those link-layer header types, the DLT_
 * value returned by pcap_datalink() and passed to pcap_open_dead(),
 * and the LINKTYPE_ value that appears in capture files, are the
 * same.
 *
 * DLT_MATCHING_MIN is the lowest such value; DLT_MATCHING_MAX is
 * the highest such value.
 */
#define DLT_MATCHING_MIN	104

/*
 * This value was defined by libpcap 0.5; platforms that have defined
 * it with a different value should define it here with that value -
 * a link type of 104 in a save file will be mapped to DLT_C_HDLC,
 * whatever value that happens to be, so programs will correctly
 * handle files with that link type regardless of the value of
 * DLT_C_HDLC.
 *
 * The name DLT_C_HDLC was used by BSD/OS; we use that name for source
 * compatibility with programs written for BSD/OS.
 *
 * libpcap 0.5 defined it as DLT_CHDLC; we define DLT_CHDLC as well,
 * for source compatibility with programs written for libpcap 0.5.
 */
#define DLT_C_HDLC	104	/* Cisco HDLC */
#define DLT_CHDLC	DLT_C_HDLC

#define DLT_IEEE802_11	105	/* IEEE 802.11 wireless */

/*
 * 106 is reserved for Linux Classical IP over ATM; it's like DLT_RAW,
 * except when it isn't.  (I.e., sometimes it's just raw IP, and
 * sometimes it isn't.)  We currently handle it as DLT_LINUX_SLL,
 * so that we don't have to worry about the link-layer header.)
 */

/*
 * Frame Relay; BSD/OS has a DLT_FR with a value of 11, but that collides
 * with other values.
 * DLT_FR and DLT_FRELAY packets start with the Q.922 Frame Relay header
 * (DLCI, etc.).
 */
#define DLT_FRELAY	107

/*
 * OpenBSD DLT_LOOP, for loopback devices; it's like DLT_NULL, except
 * that the AF_ type in the link-layer header is in network byte order.
 *
 * DLT_LOOP is 12 in OpenBSD, but that's DLT_RAW in other OSes, so
 * we don't use 12 for it in OSes other than OpenBSD.
 */
#ifdef __OpenBSD__
#define DLT_LOOP	12
#else
#define DLT_LOOP	108
#endif

/*
 * Encapsulated packets for IPsec; DLT_ENC is 13 in OpenBSD, but that's
 * DLT_SLIP_BSDOS in NetBSD, so we don't use 13 for it in OSes other
 * than OpenBSD.
 */
#ifdef __OpenBSD__
#define DLT_ENC		13
#else
#define DLT_ENC		109
#endif

/*
 * Values between 110 and 112 are reserved for use in capture file headers
 * as link-layer types corresponding to DLT_ types that might differ
 * between platforms; don't use those values for new DLT_ types
 * other than the corresponding DLT_ types.
 */

/*
 * This is for Linux cooked sockets.
 */
#define DLT_LINUX_SLL	113

/*
 * Apple LocalTalk hardware.
 */
#define DLT_LTALK	114

/*
 * Acorn Econet.
 */
#define DLT_ECONET	115

/*
 * Reserved for use with OpenBSD ipfilter.
 */
#define DLT_IPFILTER	116

/*
 * OpenBSD DLT_PFLOG.
 */
#define DLT_PFLOG	117

/*
 * Registered for Cisco-internal use.
 */
#define DLT_CISCO_IOS	118

/*
 * For 802.11 cards using the Prism II chips, with a link-layer
 * header including Prism monitor mode information plus an 802.11
 * header.
 */
#define DLT_PRISM_HEADER	119

/*
 * Reserved for Aironet 802.11 cards, with an Aironet link-layer header
 * (see Doug Ambrisko's FreeBSD patches).
 */
#define DLT_AIRONET_HEADER	120

/*
 * Sigh.
 *
 * This was reserved for Siemens HiPath HDLC on 2002-01-25, as
 * requested by Tomas Kukosa.
 *
 * On 2004-02-25, a FreeBSD checkin to sys/net/bpf.h was made that
 * assigned 121 as DLT_PFSYNC.  Its libpcap does DLT_ <-> LINKTYPE_
 * mapping, so it probably supports capturing on the pfsync device
 * but not saving the captured data to a pcap file.
 *
 * OpenBSD, from which pf came, however, uses 18 for DLT_PFSYNC;
 * their libpcap does no DLT_ <-> LINKTYPE_ mapping, so it would
 * use 18 in pcap files as well.
 *
 * NetBSD and DragonFly BSD also use 18 for DLT_PFSYNC; their
 * libpcaps do DLT_ <-> LINKTYPE_ mapping, and neither has an entry
 * for DLT_PFSYNC, so it might not be able to write out dump files
 * with 18 as the link-layer header type.  (Earlier versions might
 * not have done mapping, in which case they'd work the same way
 * OpenBSD does.)
 *
 * Mac OS X defines it as 18, but doesn't appear to use it as of
 * Mac OS X 10.7.3.  Its libpcap does DLT_ <-> LINKTYPE_ mapping.
 *
 * We'll define DLT_PFSYNC as 121 on FreeBSD and define it as 18 on
 * all other platforms.  We'll define DLT_HHDLC as 121 on everything
 * except for FreeBSD; anybody who wants to compile, on FreeBSD, code
 * that uses DLT_HHDLC is out of luck.
 *
 * We'll define LINKTYPE_PFSYNC as 18, *even on FreeBSD*, and map
 * it, so that savefiles won't use 121 for PFSYNC - they'll all
 * use 18.  Code that uses pcap_datalink() to determine the link-layer
 * header type of a savefile won't, when built and run on FreeBSD,
 * be able to distinguish between LINKTYPE_PFSYNC and LINKTYPE_HHDLC
 * capture files; code that doesn't, such as the code in Wireshark,
 * will be able to distinguish between them.
 */
#ifdef __FreeBSD__
#define DLT_PFSYNC		121
#else
#define DLT_HHDLC		121
#endif

/*
 * This is for RFC 2625 IP-over-Fibre Channel.
 *
 * This is not for use with raw Fibre Channel, where the link-layer
 * header starts with a Fibre Channel frame header; it's for IP-over-FC,
 * where the link-layer header starts with an RFC 2625 Network_Header
 * field.
 */
#define DLT_IP_OVER_FC		122

/*
 * This is for Full Frontal ATM on Solaris with SunATM, with a
 * pseudo-header followed by an AALn PDU.
 *
 * There may be other forms of Full Frontal ATM on other OSes,
 * with different pseudo-headers.
 *
 * If ATM software returns a pseudo-header with VPI/VCI information
 * (and, ideally, packet type information, e.g. signalling, ILMI,
 * LANE, LLC-multiplexed traffic, etc.), it should not use
 * DLT_ATM_RFC1483, but should get a new DLT_ value, so tcpdump
 * and the like don't have to infer the presence or absence of a
 * pseudo-header and the form of the pseudo-header.
 */
#define DLT_SUNATM		123	/* Solaris+SunATM */

/* 
 * Reserved as per request from Kent Dahlgren <kent@praesum.com>
 * for private use.
 */
#define DLT_RIO                 124     /* RapidIO */
#define DLT_PCI_EXP             125     /* PCI Express */
#define DLT_AURORA              126     /* Xilinx Aurora link layer */

/*
 * Header for 802.11 plus a number of bits of link-layer information
 * including radio information, used by some recent BSD drivers as
 * well as the madwifi Atheros driver for Linux.
 */
#define DLT_IEEE802_11_RADIO	127	/* 802.11 plus radiotap radio header */

/*
 * Reserved for the TZSP encapsulation, as per request from
 * Chris Waters <chris.waters@networkchemistry.com>
 * TZSP is a generic encapsulation for any other link type,
 * which includes a means to include meta-information
 * with the packet, e.g. signal strength and channel
 * for 802.11 packets.
 */
#define DLT_TZSP                128     /* Tazmen Sniffer Protocol */

/*
 * BSD's ARCNET headers have the source host, destination host,
 * and type at the beginning of the packet; that's what's handed
 * up to userland via BPF.
 *
 * Linux's ARCNET headers, however, have a 2-byte offset field
 * between the host IDs and the type; that's what's handed up
 * to userland via PF_PACKET sockets.
 *
 * We therefore have to have separate DLT_ values for them.
 */
#define DLT_ARCNET_LINUX	129	/* ARCNET */

/*
 * Juniper-private data link types, as per request from
 * Hannes Gredler <hannes@juniper.net>.  The DLT_s are used
 * for passing on chassis-internal metainformation such as
 * QOS profiles, etc..
 */
#define DLT_JUNIPER_MLPPP       130
#define DLT_JUNIPER_MLFR        131
#define DLT_JUNIPER_ES          132
#define DLT_JUNIPER_GGSN        133
#define DLT_JUNIPER_MFR         134
#define DLT_JUNIPER_ATM2        135
#define DLT_JUNIPER_SERVICES    136
#define DLT_JUNIPER_ATM1        137

/*
 * Apple IP-over-IEEE 1394, as per a request from Dieter Siegmund
 * <dieter@apple.com>.  The header that's presented is an Ethernet-like
 * header:
 *
 *	#define FIREWIRE_EUI64_LEN	8
 *	struct firewire_header {
 *		u_char  firewire_dhost[FIREWIRE_EUI64_LEN];
 *		u_char  firewire_shost[FIREWIRE_EUI64_LEN];
 *		u_short firewire_type;
 *	};
 *
 * with "firewire_type" being an Ethernet type value, rather than,
 * for example, raw GASP frames being handed up.
 */
#define DLT_APPLE_IP_OVER_IEEE1394	138

/*
 * Various SS7 encapsulations, as per a request from Jeff Morriss
 * <jeff.morriss[AT]ulticom.com> and subsequent discussions.
 */
#define DLT_MTP2_WITH_PHDR	139	/* pseudo-header with various info, followed by MTP2 */
#define DLT_MTP2		140	/* MTP2, without pseudo-header */
#define DLT_MTP3		141	/* MTP3, without pseudo-header or MTP2 */
#define DLT_SCCP		142	/* SCCP, without pseudo-header or MTP2 or MTP3 */

/*
 * DOCSIS MAC frames.
 */
#define DLT_DOCSIS		143

/*
 * Linux-IrDA packets. Protocol defined at http://www.irda.org.
 * Those packets include IrLAP headers and above (IrLMP...), but
 * don't include Phy framing (SOF/EOF/CRC & byte stuffing), because Phy
 * framing can be handled by the hardware and depend on the bitrate.
 * This is exactly the format you would get capturing on a Linux-IrDA
 * interface (irdaX), but not on a raw serial port.
 * Note the capture is done in "Linux-cooked" mode, so each packet include
 * a fake packet header (struct sll_header). This is because IrDA packet
 * decoding is dependant on the direction of the packet (incomming or
 * outgoing).
 * When/if other platform implement IrDA capture, we may revisit the
 * issue and define a real DLT_IRDA...
 * Jean II
 */
#define DLT_LINUX_IRDA		144

/*
 * Reserved for IBM SP switch and IBM Next Federation switch.
 */
#define DLT_IBM_SP		145
#define DLT_IBM_SN		146

/*
 * Reserved for private use.  If you have some link-layer header type
 * that you want to use within your organization, with the capture files
 * using that link-layer header type not ever be sent outside your
 * organization, you can use these values.
 *
 * No libpcap release will use these for any purpose, nor will any
 * tcpdump release use them, either.
 *
 * Do *NOT* use these in capture files that you expect anybody not using
 * your private versions of capture-file-reading tools to read; in
 * particular, do *NOT* use them in products, otherwise you may find that
 * people won't be able to use tcpdump, or snort, or Ethereal, or... to
 * read capture files from your firewall/intrusion detection/traffic
 * monitoring/etc. appliance, or whatever product uses that DLT_ value,
 * and you may also find that the developers of those applications will
 * not accept patches to let them read those files.
 *
 * Also, do not use them if somebody might send you a capture using them
 * for *their* private type and tools using them for *your* private type
 * would have to read them.
 *
 * Instead, ask "tcpdump-workers@lists.tcpdump.org" for a new DLT_ value,
 * as per the comment above, and use the type you're given.
 */
#define DLT_USER0		147
#define DLT_USER1		148
#define DLT_USER2		149
#define DLT_USER3		150
#define DLT_USER4		151
#define DLT_USER5		152
#define DLT_USER6		153
#define DLT_USER7		154
#define DLT_USER8		155
#define DLT_USER9		156
#define DLT_USER10		157
#define DLT_USER11		158
#define DLT_USER12		159
#define DLT_USER13		160
#define DLT_USER14		161
#define DLT_USER15		162

#ifdef __APPLE__
#define DLT_PKTAP       DLT_USER2
#define DLT_PCAPNG      DLT_USER4
#endif
/*
 * For future use with 802.11 captures - defined by AbsoluteValue
 * Systems to store a number of bits of link-layer information
 * including radio information:
 *
 *	http://www.shaftnet.org/~pizza/software/capturefrm.txt
 *
 * but it might be used by some non-AVS drivers now or in the
 * future.
 */
#define DLT_IEEE802_11_RADIO_AVS 163	/* 802.11 plus AVS radio header */

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>.  The DLT_s are used
 * for passing on chassis-internal metainformation such as
 * QOS profiles, etc..
 */
#define DLT_JUNIPER_MONITOR     164

/*
 * BACnet MS/TP frames.
 */
#define DLT_BACNET_MS_TP	165

/*
 * Another PPP variant as per request from Karsten Keil <kkeil@suse.de>.
 *
 * This is used in some OSes to allow a kernel socket filter to distinguish
 * between incoming and outgoing packets, on a socket intended to
 * supply pppd with outgoing packets so it can do dial-on-demand and
 * hangup-on-lack-of-demand; incoming packets are filtered out so they
 * don't cause pppd to hold the connection up (you don't want random
 * input packets such as port scans, packets from old lost connections,
 * etc. to force the connection to stay up).
 *
 * The first byte of the PPP header (0xff03) is modified to accomodate
 * the direction - 0x00 = IN, 0x01 = OUT.
 */
#define DLT_PPP_PPPD		166

/*
 * Names for backwards compatibility with older versions of some PPP
 * software; new software should use DLT_PPP_PPPD.
 */
#define DLT_PPP_WITH_DIRECTION	DLT_PPP_PPPD
#define DLT_LINUX_PPP_WITHDIRECTION	DLT_PPP_PPPD

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>.  The DLT_s are used
 * for passing on chassis-internal metainformation such as
 * QOS profiles, cookies, etc..
 */
#define DLT_JUNIPER_PPPOE       167
#define DLT_JUNIPER_PPPOE_ATM   168

#define DLT_GPRS_LLC		169	/* GPRS LLC */
#define DLT_GPF_T		170	/* GPF-T (ITU-T G.7041/Y.1303) */
#define DLT_GPF_F		171	/* GPF-F (ITU-T G.7041/Y.1303) */

/*
 * Requested by Oolan Zimmer <oz@gcom.com> for use in Gcom's T1/E1 line
 * monitoring equipment.
 */
#define DLT_GCOM_T1E1		172
#define DLT_GCOM_SERIAL		173

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>.  The DLT_ is used
 * for internal communication to Physical Interface Cards (PIC)
 */
#define DLT_JUNIPER_PIC_PEER    174

/*
 * Link types requested by Gregor Maier <gregor@endace.com> of Endace
 * Measurement Systems.  They add an ERF header (see
 * http://www.endace.com/support/EndaceRecordFormat.pdf) in front of
 * the link-layer header.
 */
#define DLT_ERF_ETH		175	/* Ethernet */
#define DLT_ERF_POS		176	/* Packet-over-SONET */

/*
 * Requested by Daniele Orlandi <daniele@orlandi.com> for raw LAPD
 * for vISDN (http://www.orlandi.com/visdn/).  Its link-layer header
 * includes additional information before the LAPD header, so it's
 * not necessarily a generic LAPD header.
 */
#define DLT_LINUX_LAPD		177

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>. 
 * The DLT_ are used for prepending meta-information
 * like interface index, interface name
 * before standard Ethernet, PPP, Frelay & C-HDLC Frames
 */
#define DLT_JUNIPER_ETHER       178
#define DLT_JUNIPER_PPP         179
#define DLT_JUNIPER_FRELAY      180
#define DLT_JUNIPER_CHDLC       181

/*
 * Multi Link Frame Relay (FRF.16)
 */
#define DLT_MFR                 182

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>. 
 * The DLT_ is used for internal communication with a
 * voice Adapter Card (PIC)
 */
#define DLT_JUNIPER_VP          183

/*
 * Arinc 429 frames.
 * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.
 * Every frame contains a 32bit A429 label.
 * More documentation on Arinc 429 can be found at
 * http://www.condoreng.com/support/downloads/tutorials/ARINCTutorial.pdf
 */
#define DLT_A429                184

/*
 * Arinc 653 Interpartition Communication messages.
 * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.
 * Please refer to the A653-1 standard for more information.
 */
#define DLT_A653_ICM            185

/*
 * USB packets, beginning with a USB setup header; requested by
 * Paolo Abeni <paolo.abeni@email.it>.
 */
#define DLT_USB			186

/*
 * Bluetooth HCI UART transport layer (part H:4); requested by
 * Paolo Abeni.
 */
#define DLT_BLUETOOTH_HCI_H4	187

/*
 * IEEE 802.16 MAC Common Part Sublayer; requested by Maria Cruz
 * <cruz_petagay@bah.com>.
 */
#define DLT_IEEE802_16_MAC_CPS	188

/*
 * USB packets, beginning with a Linux USB header; requested by
 * Paolo Abeni <paolo.abeni@email.it>.
 */
#define DLT_USB_LINUX		189

/*
 * Controller Area Network (CAN) v. 2.0B packets.
 * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.
 * Used to dump CAN packets coming from a CAN Vector board.
 * More documentation on the CAN v2.0B frames can be found at
 * http://www.can-cia.org/downloads/?269
 */
#define DLT_CAN20B              190

/*
 * IEEE 802.15.4, with address fields padded, as is done by Linux
 * drivers; requested by Juergen Schimmer.
 */
#define DLT_IEEE802_15_4_LINUX	191

/*
 * Per Packet Information encapsulated packets.
 * DLT_ requested by Gianluca Varenni <gianluca.varenni@cacetech.com>.
 */
#define DLT_PPI			192

/*
 * Header for 802.16 MAC Common Part Sublayer plus a radiotap radio header;
 * requested by Charles Clancy.
 */
#define DLT_IEEE802_16_MAC_CPS_RADIO	193

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>. 
 * The DLT_ is used for internal communication with a
 * integrated service module (ISM).
 */
#define DLT_JUNIPER_ISM         194

/*
 * IEEE 802.15.4, exactly as it appears in the spec (no padding, no
 * nothing); requested by Mikko Saarnivala <mikko.saarnivala@sensinode.com>.
 * For this one, we expect the FCS to be present at the end of the frame;
 * if the frame has no FCS, DLT_IEEE802_15_4_NOFCS should be used.
 */
#define DLT_IEEE802_15_4	195

/*
 * Various link-layer types, with a pseudo-header, for SITA
 * (http://www.sita.aero/); requested by Fulko Hew (fulko.hew@gmail.com).
 */
#define DLT_SITA		196

/*
 * Various link-layer types, with a pseudo-header, for Endace DAG cards;
 * encapsulates Endace ERF records.  Requested by Stephen Donnelly
 * <stephen@endace.com>.
 */
#define DLT_ERF			197

/*
 * Special header prepended to Ethernet packets when capturing from a
 * u10 Networks board.  Requested by Phil Mulholland
 * <phil@u10networks.com>.
 */
#define DLT_RAIF1		198

/*
 * IPMB packet for IPMI, beginning with the I2C slave address, followed
 * by the netFn and LUN, etc..  Requested by Chanthy Toeung
 * <chanthy.toeung@ca.kontron.com>.
 */
#define DLT_IPMB		199

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>. 
 * The DLT_ is used for capturing data on a secure tunnel interface.
 */
#define DLT_JUNIPER_ST          200

/*
 * Bluetooth HCI UART transport layer (part H:4), with pseudo-header
 * that includes direction information; requested by Paolo Abeni.
 */
#define DLT_BLUETOOTH_HCI_H4_WITH_PHDR	201

/*
 * AX.25 packet with a 1-byte KISS header; see
 *
 *	http://www.ax25.net/kiss.htm
 *
 * as per Richard Stearn <richard@rns-stearn.demon.co.uk>.
 */
#define DLT_AX25_KISS		202

/*
 * LAPD packets from an ISDN channel, starting with the address field,
 * with no pseudo-header.
 * Requested by Varuna De Silva <varunax@gmail.com>.
 */
#define DLT_LAPD		203

/*
 * Variants of various link-layer headers, with a one-byte direction
 * pseudo-header prepended - zero means "received by this host",
 * non-zero (any non-zero value) means "sent by this host" - as per
 * Will Barker <w.barker@zen.co.uk>.
 */
#define DLT_PPP_WITH_DIR	204	/* PPP - don't confuse with DLT_PPP_WITH_DIRECTION */
#define DLT_C_HDLC_WITH_DIR	205	/* Cisco HDLC */
#define DLT_FRELAY_WITH_DIR	206	/* Frame Relay */
#define DLT_LAPB_WITH_DIR	207	/* LAPB */

/*
 * 208 is reserved for an as-yet-unspecified proprietary link-layer
 * type, as requested by Will Barker.
 */

/*
 * IPMB with a Linux-specific pseudo-header; as requested by Alexey Neyman
 * <avn@pigeonpoint.com>.
 */
#define DLT_IPMB_LINUX		209

/*
 * FlexRay automotive bus - http://www.flexray.com/ - as requested
 * by Hannes Kaelber <hannes.kaelber@x2e.de>.
 */
#define DLT_FLEXRAY		210

/*
 * Media Oriented Systems Transport (MOST) bus for multimedia
 * transport - http://www.mostcooperation.com/ - as requested
 * by Hannes Kaelber <hannes.kaelber@x2e.de>.
 */
#define DLT_MOST		211

/*
 * Local Interconnect Network (LIN) bus for vehicle networks -
 * http://www.lin-subbus.org/ - as requested by Hannes Kaelber
 * <hannes.kaelber@x2e.de>.
 */
#define DLT_LIN			212

/*
 * X2E-private data link type used for serial line capture,
 * as requested by Hannes Kaelber <hannes.kaelber@x2e.de>.
 */
#define DLT_X2E_SERIAL		213

/*
 * X2E-private data link type used for the Xoraya data logger
 * family, as requested by Hannes Kaelber <hannes.kaelber@x2e.de>.
 */
#define DLT_X2E_XORAYA		214

/*
 * IEEE 802.15.4, exactly as it appears in the spec (no padding, no
 * nothing), but with the PHY-level data for non-ASK PHYs (4 octets
 * of 0 as preamble, one octet of SFD, one octet of frame length+
 * reserved bit, and then the MAC-layer data, starting with the
 * frame control field).
 *
 * Requested by Max Filippov <jcmvbkbc@gmail.com>.
 */
#define DLT_IEEE802_15_4_NONASK_PHY	215

/* 
 * David Gibson <david@gibson.dropbear.id.au> requested this for
 * captures from the Linux kernel /dev/input/eventN devices. This
 * is used to communicate keystrokes and mouse movements from the
 * Linux kernel to display systems, such as Xorg. 
 */
#define DLT_LINUX_EVDEV		216

/*
 * GSM Um and Abis interfaces, preceded by a "gsmtap" header.
 *
 * Requested by Harald Welte <laforge@gnumonks.org>.
 */
#define DLT_GSMTAP_UM		217
#define DLT_GSMTAP_ABIS		218

/*
 * MPLS, with an MPLS label as the link-layer header.
 * Requested by Michele Marchetto <michele@openbsd.org> on behalf
 * of OpenBSD.
 */
#define DLT_MPLS		219

/*
 * USB packets, beginning with a Linux USB header, with the USB header
 * padded to 64 bytes; required for memory-mapped access.
 */
#define DLT_USB_LINUX_MMAPPED	220

/*
 * DECT packets, with a pseudo-header; requested by
 * Matthias Wenzel <tcpdump@mazzoo.de>.
 */
#define DLT_DECT		221

/*
 * From: "Lidwa, Eric (GSFC-582.0)[SGT INC]" <eric.lidwa-1@nasa.gov>
 * Date: Mon, 11 May 2009 11:18:30 -0500
 *
 * DLT_AOS. We need it for AOS Space Data Link Protocol.
 *   I have already written dissectors for but need an OK from
 *   legal before I can submit a patch.
 *
 */
#define DLT_AOS                 222

/*
 * Wireless HART (Highway Addressable Remote Transducer)
 * From the HART Communication Foundation
 * IES/PAS 62591
 *
 * Requested by Sam Roberts <vieuxtech@gmail.com>.
 */
#define DLT_WIHART		223

/*
 * Fibre Channel FC-2 frames, beginning with a Frame_Header.
 * Requested by Kahou Lei <kahou82@gmail.com>.
 */
#define DLT_FC_2		224

/*
 * Fibre Channel FC-2 frames, beginning with an encoding of the
 * SOF, and ending with an encoding of the EOF.
 *
 * The encodings represent the frame delimiters as 4-byte sequences
 * representing the corresponding ordered sets, with K28.5
 * represented as 0xBC, and the D symbols as the corresponding
 * byte values; for example, SOFi2, which is K28.5 - D21.5 - D1.2 - D21.2,
 * is represented as 0xBC 0xB5 0x55 0x55.
 *
 * Requested by Kahou Lei <kahou82@gmail.com>.
 */
#define DLT_FC_2_WITH_FRAME_DELIMS	225

/*
 * Solaris ipnet pseudo-header; requested by Darren Reed <Darren.Reed@Sun.COM>.
 *
 * The pseudo-header starts with a one-byte version number; for version 2,
 * the pseudo-header is:
 *
 * struct dl_ipnetinfo {
 *     u_int8_t   dli_version;
 *     u_int8_t   dli_family;
 *     u_int16_t  dli_htype;
 *     u_int32_t  dli_pktlen;
 *     u_int32_t  dli_ifindex;
 *     u_int32_t  dli_grifindex;
 *     u_int32_t  dli_zsrc;
 *     u_int32_t  dli_zdst;
 * };
 *
 * dli_version is 2 for the current version of the pseudo-header.
 *
 * dli_family is a Solaris address family value, so it's 2 for IPv4
 * and 26 for IPv6.
 *
 * dli_htype is a "hook type" - 0 for incoming packets, 1 for outgoing
 * packets, and 2 for packets arriving from another zone on the same
 * machine.
 *
 * dli_pktlen is the length of the packet data following the pseudo-header
 * (so the captured length minus dli_pktlen is the length of the
 * pseudo-header, assuming the entire pseudo-header was captured).
 *
 * dli_ifindex is the interface index of the interface on which the
 * packet arrived.
 *
 * dli_grifindex is the group interface index number (for IPMP interfaces).
 *
 * dli_zsrc is the zone identifier for the source of the packet.
 *
 * dli_zdst is the zone identifier for the destination of the packet.
 *
 * A zone number of 0 is the global zone; a zone number of 0xffffffff
 * means that the packet arrived from another host on the network, not
 * from another zone on the same machine.
 *
 * An IPv4 or IPv6 datagram follows the pseudo-header; dli_family indicates
 * which of those it is.
 */
#define DLT_IPNET		226

/*
 * CAN (Controller Area Network) frames, with a pseudo-header as supplied
 * by Linux SocketCAN.  See Documentation/networking/can.txt in the Linux
 * source.
 *
 * Requested by Felix Obenhuber <felix@obenhuber.de>.
 */
#define DLT_CAN_SOCKETCAN	227

/*
 * Raw IPv4/IPv6; different from DLT_RAW in that the DLT_ value specifies
 * whether it's v4 or v6.  Requested by Darren Reed <Darren.Reed@Sun.COM>.
 */
#define DLT_IPV4		228
#define DLT_IPV6		229

/*
 * IEEE 802.15.4, exactly as it appears in the spec (no padding, no
 * nothing), and with no FCS at the end of the frame; requested by
 * Jon Smirl <jonsmirl@gmail.com>.
 */
#define DLT_IEEE802_15_4_NOFCS	230

/*
 * Raw D-Bus:
 *
 *	http://www.freedesktop.org/wiki/Software/dbus
 *
 * messages:
 *
 *	http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-messages
 *
 * starting with the endianness flag, followed by the message type, etc.,
 * but without the authentication handshake before the message sequence:
 *
 *	http://dbus.freedesktop.org/doc/dbus-specification.html#auth-protocol
 *
 * Requested by Martin Vidner <martin@vidner.net>.
 */
#define DLT_DBUS		231

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>.
 */
#define DLT_JUNIPER_VS			232
#define DLT_JUNIPER_SRX_E2E		233
#define DLT_JUNIPER_FIBRECHANNEL	234

/*
 * DVB-CI (DVB Common Interface for communication between a PC Card
 * module and a DVB receiver).  See
 *
 *	http://www.kaiser.cx/pcap-dvbci.html
 *
 * for the specification.
 *
 * Requested by Martin Kaiser <martin@kaiser.cx>.
 */
#define DLT_DVB_CI		235

/*
 * Variant of 3GPP TS 27.010 multiplexing protocol (similar to, but
 * *not* the same as, 27.010).  Requested by Hans-Christoph Schemmel
 * <hans-christoph.schemmel@cinterion.com>.
 */
#define DLT_MUX27010		236

/*
 * STANAG 5066 D_PDUs.  Requested by M. Baris Demiray
 * <barisdemiray@gmail.com>.
 */
#define DLT_STANAG_5066_D_PDU	237

/*
 * Juniper-private data link type, as per request from
 * Hannes Gredler <hannes@juniper.net>.
 */
#define DLT_JUNIPER_ATM_CEMIC	238

/*
 * NetFilter LOG messages 
 * (payload of netlink NFNL_SUBSYS_ULOG/NFULNL_MSG_PACKET packets)
 *
 * Requested by Jakub Zawadzki <darkjames-ws@darkjames.pl>
 */
#define DLT_NFLOG		239

/*
 * Hilscher Gesellschaft fuer Systemautomation mbH link-layer type
 * for Ethernet packets with a 4-byte pseudo-header and always
 * with the payload including the FCS, as supplied by their
 * netANALYZER hardware and software.
 *
 * Requested by Holger P. Frommer <HPfrommer@hilscher.com>
 */
#define DLT_NETANALYZER		240

/*
 * Hilscher Gesellschaft fuer Systemautomation mbH link-layer type
 * for Ethernet packets with a 4-byte pseudo-header and FCS and
 * with the Ethernet header preceded by 7 bytes of preamble and
 * 1 byte of SFD, as supplied by their netANALYZER hardware and
 * software.
 *
 * Requested by Holger P. Frommer <HPfrommer@hilscher.com>
 */
#define DLT_NETANALYZER_TRANSPARENT	241

/*
 * IP-over-InfiniBand, as specified by RFC 4391.
 *
 * Requested by Petr Sumbera <petr.sumbera@oracle.com>.
 */
#define DLT_IPOIB		242

/*
 * MPEG-2 transport stream (ISO 13818-1/ITU-T H.222.0).
 *
 * Requested by Guy Martin <gmsoft@tuxicoman.be>.
 */
#define DLT_MPEG_2_TS		243

/*
 * ng4T GmbH's UMTS Iub/Iur-over-ATM and Iub/Iur-over-IP format as
 * used by their ng40 protocol tester.
 *
 * Requested by Jens Grimmer <jens.grimmer@ng4t.com>.
 */
#define DLT_NG40		244

/*
 * Pseudo-header giving adapter number and flags, followed by an NFC
 * (Near-Field Communications) Logical Link Control Protocol (LLCP) PDU,
 * as specified by NFC Forum Logical Link Control Protocol Technical
 * Specification LLCP 1.1.
 *
 * Requested by Mike Wakerly <mikey@google.com>.
 */
#define DLT_NFC_LLCP		245

/*
 * 245 is used as LINKTYPE_PFSYNC; do not use it for any other purpose.
 *
 * DLT_PFSYNC has different values on different platforms, and all of
 * them collide with something used elsewhere.  On platforms that
 * don't already define it, define it as 245.
 */
#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__DragonFly__) && !defined(__APPLE__)
#define DLT_PFSYNC		246
#endif

/*
 * Raw InfiniBand packets, starting with the Local Routing Header.
 *
 * Requested by Oren Kladnitsky <orenk@mellanox.com>.
 */
#define DLT_INFINIBAND		247

/*
 * SCTP, with no lower-level protocols (i.e., no IPv4 or IPv6).
 *
 * Requested by Michael Tuexen <Michael.Tuexen@lurchi.franken.de>.
 */
#define DLT_SCTP		248

/*
 * USB packets, beginning with a USBPcap header.
 *
 * Requested by Tomasz Mon <desowin@gmail.com>
 */
#define DLT_USBPCAP		249

/*
 * Schweitzer Engineering Laboratories "RTAC" product serial-line
 * packets.
 *
 * Requested by Chris Bontje <chris_bontje@selinc.com>.
 */
#define DLT_RTAC_SERIAL		250

/*
 * Bluetooth Low Energy air interface link-layer packets.
 *
 * Requested by Mike Kershaw <dragorn@kismetwireless.net>.
 */
#define DLT_BLUETOOTH_LE_LL	251

/*
 * DLT type for upper-protocol layer PDU saves from wireshark.
 * 
 * the actual contents are determined by two TAGs stored with each
 * packet:
 *   EXP_PDU_TAG_LINKTYPE          the link type (LINKTYPE_ value) of the
 *				   original packet.
 *
 *   EXP_PDU_TAG_PROTO_NAME        the name of the wireshark dissector
 * 				   that can make sense of the data stored.
 */
#define DLT_WIRESHARK_UPPER_PDU	252

#define DLT_MATCHING_MAX	252	/* highest value in the "matching" range */

/*
 * DLT and savefile link type values are split into a class and
 * a member of that class.  A class value of 0 indicates a regular
 * DLT_/LINKTYPE_ value.
 */
#define DLT_CLASS(x)		((x) & 0x03ff0000)

/*
 * NetBSD-specific generic "raw" link type.  The class value indicates
 * that this is the generic raw type, and the lower 16 bits are the
 * address family we're dealing with.  Those values are NetBSD-specific;
 * do not assume that they correspond to AF_ values for your operating
 * system.
 */
#define	DLT_CLASS_NETBSD_RAWAF	0x02240000
#define	DLT_NETBSD_RAWAF(af)	(DLT_CLASS_NETBSD_RAWAF | (af))
#define	DLT_NETBSD_RAWAF_AF(x)	((x) & 0x0000ffff)
#define	DLT_IS_NETBSD_RAWAF(x)	(DLT_CLASS(x) == DLT_CLASS_NETBSD_RAWAF)


/*
 * The instruction encodings.
 */
/* instruction classes */
#define BPF_CLASS(code) ((code) & 0x07)
#define		BPF_LD		0x00
#define		BPF_LDX		0x01
#define		BPF_ST		0x02
#define		BPF_STX		0x03
#define		BPF_ALU		0x04
#define		BPF_JMP		0x05
#define		BPF_RET		0x06
#define		BPF_MISC	0x07

/* ld/ldx fields */
#define BPF_SIZE(code)	((code) & 0x18)
#define		BPF_W		0x00
#define		BPF_H		0x08
#define		BPF_B		0x10
#define BPF_MODE(code)	((code) & 0xe0)
#define		BPF_IMM 	0x00
#define		BPF_ABS		0x20
#define		BPF_IND		0x40
#define		BPF_MEM		0x60
#define		BPF_LEN		0x80
#define		BPF_MSH		0xa0

/* alu/jmp fields */
#define BPF_OP(code)	((code) & 0xf0)
#define		BPF_ADD		0x00
#define		BPF_SUB		0x10
#define		BPF_MUL		0x20
#define		BPF_DIV		0x30
#define		BPF_OR		0x40
#define		BPF_AND		0x50
#define		BPF_LSH		0x60
#define		BPF_RSH		0x70
#define		BPF_NEG		0x80
#define		BPF_JA		0x00
#define		BPF_JEQ		0x10
#define		BPF_JGT		0x20
#define		BPF_JGE		0x30
#define		BPF_JSET	0x40
#define BPF_SRC(code)	((code) & 0x08)
#define		BPF_K		0x00
#define		BPF_X		0x08

/* ret - BPF_K and BPF_X also apply */
#define BPF_RVAL(code)	((code) & 0x18)
#define		BPF_A		0x10

/* misc */
#define BPF_MISCOP(code) ((code) & 0xf8)
#define		BPF_TAX		0x00
#define		BPF_TXA		0x80

/*
 * The instruction data structure.
 */
struct bpf_insn {
	u_short	code;
	u_char 	jt;
	u_char 	jf;
	bpf_u_int32 k;
};

/*
 * Macros for insn array initializers.
 */
#define BPF_STMT(code, k) { (u_short)(code), 0, 0, k }
#define BPF_JUMP(code, k, jt, jf) { (u_short)(code), jt, jf, k }

#if __STDC__ || defined(__cplusplus)
extern int bpf_validate(const struct bpf_insn *, int);
extern u_int bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
#else
extern int bpf_validate();
extern u_int bpf_filter();
#endif

/*
 * Number of scratch memory words (for BPF_LD|BPF_MEM and BPF_ST).
 */
#define BPF_MEMWORDS 16

#ifdef __cplusplus
}
#endif

#endif /* !defined(_NET_BPF_H_) && !defined(_BPF_H_) && !defined(_H_BPF) && !defined(lib_pcap_bpf_h) */
                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/namedb.h                                       0100644 0001750 0001750 00000006535 12566174044 022124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap/namedb.h,v 1.1 2006-10-04 18:09:22 guy Exp $ (LBL)
 */

#ifndef lib_pcap_namedb_h
#define lib_pcap_namedb_h

#ifdef __cplusplus
extern "C" {
#endif

/*
 * As returned by the pcap_next_etherent()
 * XXX this stuff doesn't belong in this interface, but this
 * library already must do name to address translation, so
 * on systems that don't have support for /etc/ethers, we
 * export these hooks since they'll
 */
struct pcap_etherent {
	u_char addr[6];
	char name[122];
};
#ifndef PCAP_ETHERS_FILE
#define PCAP_ETHERS_FILE "/etc/ethers"
#endif
struct	pcap_etherent *pcap_next_etherent(FILE *);
u_char *pcap_ether_hostton(const char*);
u_char *pcap_ether_aton(const char *);

bpf_u_int32 **pcap_nametoaddr(const char *);
#ifdef INET6
struct addrinfo *pcap_nametoaddrinfo(const char *);
#endif
bpf_u_int32 pcap_nametonetaddr(const char *);

int	pcap_nametoport(const char *, int *, int *);
int	pcap_nametoportrange(const char *, int *, int *, int *);
int	pcap_nametoproto(const char *);
int	pcap_nametoeproto(const char *);
int	pcap_nametollc(const char *);
/*
 * If a protocol is unknown, PROTO_UNDEF is returned.
 * Also, pcap_nametoport() returns the protocol along with the port number.
 * If there are ambiguous entried in /etc/services (i.e. domain
 * can be either tcp or udp) PROTO_UNDEF is returned.
 */
#define PROTO_UNDEF		-1

/* XXX move these to pcap-int.h? */
int __pcap_atodn(const char *, bpf_u_int32 *);
int __pcap_atoin(const char *, bpf_u_int32 *);
u_short	__pcap_nametodnaddr(const char *);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/pcap-util.h                                    0100644 0001750 0001750 00000002557 12566174044 022574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef libpcap_pcap_util_h
#define libpcap_pcap_util_h


#endif
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/pcap.h                                         0100644 0001750 0001750 00000045460 12566174044 021621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- Mode: c; tab-width: 8; indent-tabs-mode: 1; c-basic-offset: 8; -*- */
/*
 * Copyright (c) 2012-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap/pcap.h,v 1.15 2008-10-06 15:27:32 gianluca Exp $ (LBL)
 */

#ifndef lib_pcap_pcap_h
#define lib_pcap_pcap_h

#if defined(WIN32)
  #include <pcap-stdinc.h>
#elif defined(MSDOS)
  #include <sys/types.h>
  #include <sys/socket.h>  /* u_int, u_char etc. */
#else /* UN*X */
  #include <sys/types.h>
  #include <sys/time.h>
#endif /* WIN32/MSDOS/UN*X */

#ifndef PCAP_DONT_INCLUDE_PCAP_BPF_H
#include <pcap/bpf.h>
#endif

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Version number of the current version of the pcap file format.
 *
 * NOTE: this is *NOT* the version number of the libpcap library.
 * To fetch the version information for the version of libpcap
 * you're using, use pcap_lib_version().
 */
#define PCAP_VERSION_MAJOR 2
#define PCAP_VERSION_MINOR 4

#define PCAP_ERRBUF_SIZE 256

/*
 * Compatibility for systems that have a bpf.h that
 * predates the bpf typedefs for 64-bit support.
 */
#if BPF_RELEASE - 0 < 199406
typedef	int bpf_int32;
typedef	u_int bpf_u_int32;
#endif

typedef struct pcap pcap_t;
typedef struct pcap_dumper pcap_dumper_t;
typedef struct pcap_if pcap_if_t;
typedef struct pcap_addr pcap_addr_t;

/*
 * The first record in the file contains saved values for some
 * of the flags used in the printout phases of tcpdump.
 * Many fields here are 32 bit ints so compilers won't insert unwanted
 * padding; these files need to be interchangeable across architectures.
 *
 * Do not change the layout of this structure, in any way (this includes
 * changes that only affect the length of fields in this structure).
 *
 * Also, do not change the interpretation of any of the members of this
 * structure, in any way (this includes using values other than
 * LINKTYPE_ values, as defined in "savefile.c", in the "linktype"
 * field).
 *
 * Instead:
 *
 *	introduce a new structure for the new format, if the layout
 *	of the structure changed;
 *
 *	send mail to "tcpdump-workers@lists.tcpdump.org", requesting
 *	a new magic number for your new capture file format, and, when
 *	you get the new magic number, put it in "savefile.c";
 *
 *	use that magic number for save files with the changed file
 *	header;
 *
 *	make the code in "savefile.c" capable of reading files with
 *	the old file header as well as files with the new file header
 *	(using the magic number to determine the header format).
 *
 * Then supply the changes by forking the branch at
 *
 *	https://github.com/the-tcpdump-group/libpcap/issues
 *
 * and issuing a pull request, so that future versions of libpcap and
 * programs that use it (such as tcpdump) will be able to read your new
 * capture file format.
 */
struct pcap_file_header {
	bpf_u_int32 magic;
	u_short version_major;
	u_short version_minor;
	bpf_int32 thiszone;	/* gmt to local correction */
	bpf_u_int32 sigfigs;	/* accuracy of timestamps */
	bpf_u_int32 snaplen;	/* max length saved portion of each pkt */
	bpf_u_int32 linktype;	/* data link type (LINKTYPE_*) */
};

/*
 * Macros for the value returned by pcap_datalink_ext().
 * 
 * If LT_FCS_LENGTH_PRESENT(x) is true, the LT_FCS_LENGTH(x) macro
 * gives the FCS length of packets in the capture.
 */
#define LT_FCS_LENGTH_PRESENT(x)	((x) & 0x04000000)
#define LT_FCS_LENGTH(x)		(((x) & 0xF0000000) >> 28)
#define LT_FCS_DATALINK_EXT(x)		((((x) & 0xF) << 28) | 0x04000000)

typedef enum {
       PCAP_D_INOUT = 0,
       PCAP_D_IN,
       PCAP_D_OUT
} pcap_direction_t;

/*
 * Generic per-packet information, as supplied by libpcap.
 *
 * The time stamp can and should be a "struct timeval", regardless of
 * whether your system supports 32-bit tv_sec in "struct timeval",
 * 64-bit tv_sec in "struct timeval", or both if it supports both 32-bit
 * and 64-bit applications.  The on-disk format of savefiles uses 32-bit
 * tv_sec (and tv_usec); this structure is irrelevant to that.  32-bit
 * and 64-bit versions of libpcap, even if they're on the same platform,
 * should supply the appropriate version of "struct timeval", even if
 * that's not what the underlying packet capture mechanism supplies.
 */
struct pcap_pkthdr {
	struct timeval ts;	/* time stamp */
	bpf_u_int32 caplen;	/* length of portion present */
	bpf_u_int32 len;	/* length this packet (off wire) */
#ifdef __APPLE__
	char comment[256];
#endif
};

/*
 * As returned by the pcap_stats()
 */
struct pcap_stat {
	u_int ps_recv;		/* number of packets received */
	u_int ps_drop;		/* number of packets dropped */
	u_int ps_ifdrop;	/* drops by interface -- only supported on some platforms */
#ifdef WIN32
	u_int bs_capt;		/* number of packets that reach the application */
#endif /* WIN32 */
};

#ifdef MSDOS
/*
 * As returned by the pcap_stats_ex()
 */
struct pcap_stat_ex {
       u_long  rx_packets;        /* total packets received       */
       u_long  tx_packets;        /* total packets transmitted    */
       u_long  rx_bytes;          /* total bytes received         */
       u_long  tx_bytes;          /* total bytes transmitted      */
       u_long  rx_errors;         /* bad packets received         */
       u_long  tx_errors;         /* packet transmit problems     */
       u_long  rx_dropped;        /* no space in Rx buffers       */
       u_long  tx_dropped;        /* no space available for Tx    */
       u_long  multicast;         /* multicast packets received   */
       u_long  collisions;

       /* detailed rx_errors: */
       u_long  rx_length_errors;
       u_long  rx_over_errors;    /* receiver ring buff overflow  */
       u_long  rx_crc_errors;     /* recv'd pkt with crc error    */
       u_long  rx_frame_errors;   /* recv'd frame alignment error */
       u_long  rx_fifo_errors;    /* recv'r fifo overrun          */
       u_long  rx_missed_errors;  /* recv'r missed packet         */

       /* detailed tx_errors */
       u_long  tx_aborted_errors;
       u_long  tx_carrier_errors;
       u_long  tx_fifo_errors;
       u_long  tx_heartbeat_errors;
       u_long  tx_window_errors;
     };
#endif

/*
 * Item in a list of interfaces.
 */
struct pcap_if {
	struct pcap_if *next;
	char *name;		/* name to hand to "pcap_open_live()" */
	char *description;	/* textual description of interface, or NULL */
	struct pcap_addr *addresses;
	bpf_u_int32 flags;	/* PCAP_IF_ interface flags */
};

#define PCAP_IF_LOOPBACK	0x00000001	/* interface is loopback */

/*
 * Representation of an interface address.
 */
struct pcap_addr {
	struct pcap_addr *next;
	struct sockaddr *addr;		/* address */
	struct sockaddr *netmask;	/* netmask for that address */
	struct sockaddr *broadaddr;	/* broadcast address for that address */
	struct sockaddr *dstaddr;	/* P2P destination address for that address */
};

typedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,
			     const u_char *);

/*
 * Error codes for the pcap API.
 * These will all be negative, so you can check for the success or
 * failure of a call that returns these codes by checking for a
 * negative value.
 */
#define PCAP_ERROR			-1	/* generic error code */
#define PCAP_ERROR_BREAK		-2	/* loop terminated by pcap_breakloop */
#define PCAP_ERROR_NOT_ACTIVATED	-3	/* the capture needs to be activated */
#define PCAP_ERROR_ACTIVATED		-4	/* the operation can't be performed on already activated captures */
#define PCAP_ERROR_NO_SUCH_DEVICE	-5	/* no such device exists */
#define PCAP_ERROR_RFMON_NOTSUP		-6	/* this device doesn't support rfmon (monitor) mode */
#define PCAP_ERROR_NOT_RFMON		-7	/* operation supported only in monitor mode */
#define PCAP_ERROR_PERM_DENIED		-8	/* no permission to open the device */
#define PCAP_ERROR_IFACE_NOT_UP		-9	/* interface isn't up */
#define PCAP_ERROR_CANTSET_TSTAMP_TYPE	-10	/* this device doesn't support setting the time stamp type */
#define PCAP_ERROR_PROMISC_PERM_DENIED	-11	/* you don't have permission to capture in promiscuous mode */
#define PCAP_ERROR_TSTAMP_PRECISION_NOTSUP -12  /* the requested time stamp precision is not supported */

/*
 * Warning codes for the pcap API.
 * These will all be positive and non-zero, so they won't look like
 * errors.
 */
#define PCAP_WARNING			1	/* generic warning code */
#define PCAP_WARNING_PROMISC_NOTSUP	2	/* this device doesn't support promiscuous mode */
#define PCAP_WARNING_TSTAMP_TYPE_NOTSUP	3	/* the requested time stamp type is not supported */

/*
 * Value to pass to pcap_compile() as the netmask if you don't know what
 * the netmask is.
 */
#define PCAP_NETMASK_UNKNOWN	0xffffffff

char	*pcap_lookupdev(char *);
int	pcap_lookupnet(const char *, bpf_u_int32 *, bpf_u_int32 *, char *);

pcap_t	*pcap_create(const char *, char *);
int	pcap_set_snaplen(pcap_t *, int);
int	pcap_set_promisc(pcap_t *, int);
int	pcap_can_set_rfmon(pcap_t *);
int	pcap_set_rfmon(pcap_t *, int);
int	pcap_set_timeout(pcap_t *, int);
int	pcap_set_tstamp_type(pcap_t *, int);
int	pcap_set_immediate_mode(pcap_t *, int);
int	pcap_set_buffer_size(pcap_t *, int);
int	pcap_set_tstamp_precision(pcap_t *, int);
int	pcap_get_tstamp_precision(pcap_t *);
int	pcap_activate(pcap_t *);
#ifdef __APPLE__
int pcap_apple_set_exthdr(pcap_t *p, int);
#endif /* __APPLE__ */

int	pcap_list_tstamp_types(pcap_t *, int **);
void	pcap_free_tstamp_types(int *);
int	pcap_tstamp_type_name_to_val(const char *);
const char *pcap_tstamp_type_val_to_name(int);
const char *pcap_tstamp_type_val_to_description(int);

/*
 * Time stamp types.
 * Not all systems and interfaces will necessarily support all of these.
 *
 * A system that supports PCAP_TSTAMP_HOST is offering time stamps
 * provided by the host machine, rather than by the capture device,
 * but not committing to any characteristics of the time stamp;
 * it will not offer any of the PCAP_TSTAMP_HOST_ subtypes.
 *
 * PCAP_TSTAMP_HOST_LOWPREC is a time stamp, provided by the host machine,
 * that's low-precision but relatively cheap to fetch; it's normally done
 * using the system clock, so it's normally synchronized with times you'd
 * fetch from system calls.
 *
 * PCAP_TSTAMP_HOST_HIPREC is a time stamp, provided by the host machine,
 * that's high-precision; it might be more expensive to fetch.  It might
 * or might not be synchronized with the system clock, and might have
 * problems with time stamps for packets received on different CPUs,
 * depending on the platform.
 *
 * PCAP_TSTAMP_ADAPTER is a high-precision time stamp supplied by the
 * capture device; it's synchronized with the system clock.
 *
 * PCAP_TSTAMP_ADAPTER_UNSYNCED is a high-precision time stamp supplied by
 * the capture device; it's not synchronized with the system clock.
 *
 * Note that time stamps synchronized with the system clock can go
 * backwards, as the system clock can go backwards.  If a clock is
 * not in sync with the system clock, that could be because the
 * system clock isn't keeping accurate time, because the other
 * clock isn't keeping accurate time, or both.
 *
 * Note that host-provided time stamps generally correspond to the
 * time when the time-stamping code sees the packet; this could
 * be some unknown amount of time after the first or last bit of
 * the packet is received by the network adapter, due to batching
 * of interrupts for packet arrival, queueing delays, etc..
 */
#define PCAP_TSTAMP_HOST		0	/* host-provided, unknown characteristics */
#define PCAP_TSTAMP_HOST_LOWPREC	1	/* host-provided, low precision */
#define PCAP_TSTAMP_HOST_HIPREC		2	/* host-provided, high precision */
#define PCAP_TSTAMP_ADAPTER		3	/* device-provided, synced with the system clock */
#define PCAP_TSTAMP_ADAPTER_UNSYNCED	4	/* device-provided, not synced with the system clock */

/*
 * Time stamp resolution types.
 * Not all systems and interfaces will necessarily support all of these
 * resolutions when doing live captures; all of them can be requested
 * when reading a savefile.
 */
#define PCAP_TSTAMP_PRECISION_MICRO	0	/* use timestamps with microsecond precision, default */
#define PCAP_TSTAMP_PRECISION_NANO	1	/* use timestamps with nanosecond precision */

pcap_t	*pcap_open_live(const char *, int, int, int, char *);
pcap_t	*pcap_open_dead(int, int);
pcap_t	*pcap_open_dead_with_tstamp_precision(int, int, u_int);
pcap_t	*pcap_open_offline_with_tstamp_precision(const char *, u_int, char *);
pcap_t	*pcap_open_offline(const char *, char *);
#if defined(WIN32)
pcap_t  *pcap_hopen_offline_with_tstamp_precision(intptr_t, u_int, char *);
pcap_t  *pcap_hopen_offline(intptr_t, char *);
#if !defined(LIBPCAP_EXPORTS)
#define pcap_fopen_offline_with_tstamp_precision(f,p,b) \
	pcap_hopen_offline_with_tstamp_precision(_get_osfhandle(_fileno(f)), p, b)
#define pcap_fopen_offline(f,b) \
	pcap_hopen_offline(_get_osfhandle(_fileno(f)), b)
#else /*LIBPCAP_EXPORTS*/
static pcap_t *pcap_fopen_offline_with_tstamp_precision(FILE *, u_int, char *);
static pcap_t *pcap_fopen_offline(FILE *, char *);
#endif
#else /*WIN32*/
pcap_t	*pcap_fopen_offline_with_tstamp_precision(FILE *, u_int, char *);
pcap_t	*pcap_fopen_offline(FILE *, char *);
#endif /*WIN32*/

void	pcap_close(pcap_t *);
int	pcap_loop(pcap_t *, int, pcap_handler, u_char *);
int	pcap_dispatch(pcap_t *, int, pcap_handler, u_char *);
const u_char*
	pcap_next(pcap_t *, struct pcap_pkthdr *);
int 	pcap_next_ex(pcap_t *, struct pcap_pkthdr **, const u_char **);
void	pcap_breakloop(pcap_t *);
int	pcap_stats(pcap_t *, struct pcap_stat *);
int	pcap_setfilter(pcap_t *, struct bpf_program *);
int 	pcap_setdirection(pcap_t *, pcap_direction_t);
int	pcap_getnonblock(pcap_t *, char *);
int	pcap_setnonblock(pcap_t *, int, char *);
int	pcap_inject(pcap_t *, const void *, size_t);
int	pcap_sendpacket(pcap_t *, const u_char *, int);
const char *pcap_statustostr(int);
const char *pcap_strerror(int);
char	*pcap_geterr(pcap_t *);
void	pcap_perror(pcap_t *, char *);
int	pcap_compile(pcap_t *, struct bpf_program *, const char *, int,
	    bpf_u_int32);
int	pcap_compile_nopcap(int, int, struct bpf_program *,
	    const char *, int, bpf_u_int32);
void	pcap_freecode(struct bpf_program *);
int	pcap_offline_filter(const struct bpf_program *,
	    const struct pcap_pkthdr *, const u_char *);
int	pcap_datalink(pcap_t *);
int	pcap_datalink_ext(pcap_t *);
int	pcap_list_datalinks(pcap_t *, int **);
int	pcap_set_datalink(pcap_t *, int);
void	pcap_free_datalinks(int *);
int	pcap_datalink_name_to_val(const char *);
const char *pcap_datalink_val_to_name(int);
const char *pcap_datalink_val_to_description(int);
int	pcap_snapshot(pcap_t *);
int	pcap_is_swapped(pcap_t *);
int	pcap_major_version(pcap_t *);
int	pcap_minor_version(pcap_t *);

/* XXX */
FILE	*pcap_file(pcap_t *);
int	pcap_fileno(pcap_t *);

pcap_dumper_t *pcap_dump_open(pcap_t *, const char *);
pcap_dumper_t *pcap_dump_fopen(pcap_t *, FILE *fp);
FILE	*pcap_dump_file(pcap_dumper_t *);
long	pcap_dump_ftell(pcap_dumper_t *);
int	pcap_dump_flush(pcap_dumper_t *);
void	pcap_dump_close(pcap_dumper_t *);
void	pcap_dump(u_char *, const struct pcap_pkthdr *, const u_char *);

int	pcap_findalldevs(pcap_if_t **, char *);
void	pcap_freealldevs(pcap_if_t *);

const char *pcap_lib_version(void);

/*
 * On at least some versions of NetBSD, we don't want to declare
 * bpf_filter() here, as it's also be declared in <net/bpf.h>, with a
 * different signature, but, on other BSD-flavored UN*Xes, it's not
 * declared in <net/bpf.h>, so we *do* want to declare it here, so it's
 * declared when we build pcap-bpf.c.
 */
#ifndef __NetBSD__
u_int	bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
#endif
int	bpf_validate(const struct bpf_insn *f, int len);
char	*bpf_image(const struct bpf_insn *, int);
void	bpf_dump(const struct bpf_program *, int);

#if defined(WIN32)

/*
 * Win32 definitions
 */

int pcap_setbuff(pcap_t *p, int dim);
int pcap_setmode(pcap_t *p, int mode);
int pcap_setmintocopy(pcap_t *p, int size);
Adapter *pcap_get_adapter(pcap_t *p);

#ifdef WPCAP
/* Include file with the wpcap-specific extensions */
#include <Win32-Extensions.h>
#endif /* WPCAP */

#define MODE_CAPT 0
#define MODE_STAT 1
#define MODE_MON 2

#elif defined(MSDOS)

/*
 * MS-DOS definitions
 */

int  pcap_stats_ex (pcap_t *, struct pcap_stat_ex *);
void pcap_set_wait (pcap_t *p, void (*yield)(void), int wait);
u_long pcap_mac_packets (void);

#else /* UN*X */

/*
 * UN*X definitions
 */

int	pcap_get_selectable_fd(pcap_t *);

#endif /* WIN32/MSDOS/UN*X */

#ifdef __cplusplus
}
#endif

#endif /* lib_pcap_pcap_h */
                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/sll.h                                          0100644 0001750 0001750 00000012673 12566174045 021471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*-
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap/sll.h,v 1.3 2008-05-30 01:35:33 guy Exp $ (LBL)
 */

/*
 * For captures on Linux cooked sockets, we construct a fake header
 * that includes:
 *
 *	a 2-byte "packet type" which is one of:
 *
 *		LINUX_SLL_HOST		packet was sent to us
 *		LINUX_SLL_BROADCAST	packet was broadcast
 *		LINUX_SLL_MULTICAST	packet was multicast
 *		LINUX_SLL_OTHERHOST	packet was sent to somebody else
 *		LINUX_SLL_OUTGOING	packet was sent *by* us;
 *
 *	a 2-byte Ethernet protocol field;
 *
 *	a 2-byte link-layer type;
 *
 *	a 2-byte link-layer address length;
 *
 *	an 8-byte source link-layer address, whose actual length is
 *	specified by the previous value.
 *
 * All fields except for the link-layer address are in network byte order.
 *
 * DO NOT change the layout of this structure, or change any of the
 * LINUX_SLL_ values below.  If you must change the link-layer header
 * for a "cooked" Linux capture, introduce a new DLT_ type (ask
 * "tcpdump-workers@lists.tcpdump.org" for one, so that you don't give it
 * a value that collides with a value already being used), and use the
 * new header in captures of that type, so that programs that can
 * handle DLT_LINUX_SLL captures will continue to handle them correctly
 * without any change, and so that capture files with different headers
 * can be told apart and programs that read them can dissect the
 * packets in them.
 */

#ifndef lib_pcap_sll_h
#define lib_pcap_sll_h

/*
 * A DLT_LINUX_SLL fake link-layer header.
 */
#define SLL_HDR_LEN	16		/* total header length */
#define SLL_ADDRLEN	8		/* length of address field */

struct sll_header {
	u_int16_t sll_pkttype;		/* packet type */
	u_int16_t sll_hatype;		/* link-layer address type */
	u_int16_t sll_halen;		/* link-layer address length */
	u_int8_t sll_addr[SLL_ADDRLEN];	/* link-layer address */
	u_int16_t sll_protocol;		/* protocol */
};

/*
 * The LINUX_SLL_ values for "sll_pkttype"; these correspond to the
 * PACKET_ values on Linux, but are defined here so that they're
 * available even on systems other than Linux, and so that they
 * don't change even if the PACKET_ values change.
 */
#define LINUX_SLL_HOST		0
#define LINUX_SLL_BROADCAST	1
#define LINUX_SLL_MULTICAST	2
#define LINUX_SLL_OTHERHOST	3
#define LINUX_SLL_OUTGOING	4

/*
 * The LINUX_SLL_ values for "sll_protocol"; these correspond to the
 * ETH_P_ values on Linux, but are defined here so that they're
 * available even on systems other than Linux.  We assume, for now,
 * that the ETH_P_ values won't change in Linux; if they do, then:
 *
 *	if we don't translate them in "pcap-linux.c", capture files
 *	won't necessarily be readable if captured on a system that
 *	defines ETH_P_ values that don't match these values;
 *
 *	if we do translate them in "pcap-linux.c", that makes life
 *	unpleasant for the BPF code generator, as the values you test
 *	for in the kernel aren't the values that you test for when
 *	reading a capture file, so the fixup code run on BPF programs
 *	handed to the kernel ends up having to do more work.
 *
 * Add other values here as necessary, for handling packet types that
 * might show up on non-Ethernet, non-802.x networks.  (Not all the ones
 * in the Linux "if_ether.h" will, I suspect, actually show up in
 * captures.)
 */
#define LINUX_SLL_P_802_3	0x0001	/* Novell 802.3 frames without 802.2 LLC header */
#define LINUX_SLL_P_802_2	0x0004	/* 802.2 frames (not D/I/X Ethernet) */

#endif
                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap/usb.h                                          0100644 0001750 0001750 00000011063 12566174045 021460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Paolo Abeni (Italy)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Basic USB data struct
 * By Paolo Abeni <paolo.abeni@email.it>
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap/usb.h,v 1.9 2008-12-23 20:13:29 guy Exp $
 */
 
#ifndef _PCAP_USB_STRUCTS_H__
#define _PCAP_USB_STRUCTS_H__

/* 
 * possible transfer mode
 */
#define URB_TRANSFER_IN   0x80
#define URB_ISOCHRONOUS   0x0
#define URB_INTERRUPT     0x1
#define URB_CONTROL       0x2
#define URB_BULK          0x3

/*
 * possible event type
 */
#define URB_SUBMIT        'S'
#define URB_COMPLETE      'C'
#define URB_ERROR         'E'

/*
 * USB setup header as defined in USB specification.
 * Appears at the front of each Control S-type packet in DLT_USB captures.
 */
typedef struct _usb_setup {
	u_int8_t bmRequestType;
	u_int8_t bRequest;
	u_int16_t wValue;
	u_int16_t wIndex;
	u_int16_t wLength;
} pcap_usb_setup;

/*
 * Information from the URB for Isochronous transfers.
 */
typedef struct _iso_rec {
	int32_t	error_count;
	int32_t	numdesc;
} iso_rec;

/*
 * Header prepended by linux kernel to each event.
 * Appears at the front of each packet in DLT_USB_LINUX captures.
 */
typedef struct _usb_header {
	u_int64_t id;
	u_int8_t event_type;
	u_int8_t transfer_type;
	u_int8_t endpoint_number;
	u_int8_t device_address;
	u_int16_t bus_id;
	char setup_flag;/*if !=0 the urb setup header is not present*/
	char data_flag; /*if !=0 no urb data is present*/
	int64_t ts_sec;
	int32_t ts_usec;
	int32_t status;
	u_int32_t urb_len;
	u_int32_t data_len; /* amount of urb data really present in this event*/
	pcap_usb_setup setup;
} pcap_usb_header;

/*
 * Header prepended by linux kernel to each event for the 2.6.31
 * and later kernels; for the 2.6.21 through 2.6.30 kernels, the
 * "iso_rec" information, and the fields starting with "interval"
 * are zeroed-out padding fields.
 *
 * Appears at the front of each packet in DLT_USB_LINUX_MMAPPED captures.
 */
typedef struct _usb_header_mmapped {
	u_int64_t id;
	u_int8_t event_type;
	u_int8_t transfer_type;
	u_int8_t endpoint_number;
	u_int8_t device_address;
	u_int16_t bus_id;
	char setup_flag;/*if !=0 the urb setup header is not present*/
	char data_flag; /*if !=0 no urb data is present*/
	int64_t ts_sec;
	int32_t ts_usec;
	int32_t status;
	u_int32_t urb_len;
	u_int32_t data_len; /* amount of urb data really present in this event*/
	union {
		pcap_usb_setup setup;
		iso_rec iso;
	} s;
	int32_t	interval;	/* for Interrupt and Isochronous events */
	int32_t start_frame;	/* for Isochronous events */
	u_int32_t xfer_flags;	/* copy of URB's transfer flags */
	u_int32_t ndesc;	/* number of isochronous descriptors */
} pcap_usb_header_mmapped;

/*
 * Isochronous descriptors; for isochronous transfers there might be
 * one or more of these at the beginning of the packet data.  The
 * number of descriptors is given by the "ndesc" field in the header;
 * as indicated, in older kernels that don't put the descriptors at
 * the beginning of the packet, that field is zeroed out, so that field
 * can be trusted even in captures from older kernels.
 */
typedef struct _usb_isodesc {
	int32_t		status;
	u_int32_t	offset;
	u_int32_t	len;
	u_int8_t	pad[4];
} usb_isodesc;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap-bpf.h                                          0100644 0001750 0001750 00000004531 12566174045 021436  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*-
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence 
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap-bpf.h,v 1.50 2007-04-01 21:43:55 guy Exp $ (LBL)
 */

/*
 * For backwards compatibility.
 *
 * Note to OS vendors: do NOT get rid of this file!  Some applications
 * might expect to be able to include <pcap-bpf.h>.
 */
#include <pcap/bpf.h>
                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap-namedb.h                                       0100644 0001750 0001750 00000004115 12566174045 022113  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap-namedb.h,v 1.13 2006-10-04 18:13:32 guy Exp $ (LBL)
 */

/*
 * For backwards compatibility.
 *
 * Note to OS vendors: do NOT get rid of this file!  Some applications
 * might expect to be able to include <pcap-namedb.h>.
 */
#include <pcap/namedb.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pcap.h                                              0100644 0001750 0001750 00000004420 12566174045 020666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @(#) $Header: /tcpdump/master/libpcap/pcap.h,v 1.59 2006-10-04 18:09:22 guy Exp $ (LBL)
 */

/*
 * For backwards compatibility.
 *
 * Note to OS vendors: do NOT get rid of this file!  Many applications
 * expect to be able to include <pcap.h>, and at least some of them
 * go through contortions in their configure scripts to try to detect
 * OSes that have "helpfully" moved pcap.h to <pcap/pcap.h> without
 * leaving behind a <pcap.h> file.
 */
#include <pcap/pcap.h>
                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/                                            0040755 0001750 0001750 00000000000 12612224753 021256  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/boot.h                                      0100644 0001750 0001750 00000002652 12567450736 022407  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_BOOT_H_
#define _PEXPERT_BOOT_H_

#include <pexpert/machine/boot.h>

#endif /* _PEXPERT_BOOT_H_ */
                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/i386/                                       0040755 0001750 0001750 00000000000 12612224753 021747  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/i386/boot.h                                 0100644 0001750 0001750 00000013760 12567450733 023077  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_I386_BOOT_H
#define _PEXPERT_I386_BOOT_H

#include <stdint.h>

/*
 * What the booter leaves behind for the kernel.
 */

/*
 * Types of boot driver that may be loaded by the booter.
 */
enum {
    kBootDriverTypeInvalid = 0,
    kBootDriverTypeKEXT    = 1,
    kBootDriverTypeMKEXT   = 2
};

enum {
    kEfiReservedMemoryType	= 0,
    kEfiLoaderCode		= 1,
    kEfiLoaderData		= 2,
    kEfiBootServicesCode	= 3,
    kEfiBootServicesData	= 4,
    kEfiRuntimeServicesCode	= 5,
    kEfiRuntimeServicesData	= 6,
    kEfiConventionalMemory	= 7,
    kEfiUnusableMemory		= 8,
    kEfiACPIReclaimMemory	= 9,
    kEfiACPIMemoryNVS		= 10,
    kEfiMemoryMappedIO		= 11,
    kEfiMemoryMappedIOPortSpace = 12,
    kEfiPalCode			= 13,
    kEfiMaxMemoryType		= 14
};

/*
 * Memory range descriptor.
 */
typedef struct EfiMemoryRange {
    uint32_t Type;
    uint32_t Pad;
    uint64_t PhysicalStart;
    uint64_t VirtualStart;
    uint64_t NumberOfPages;
    uint64_t Attribute;
} EfiMemoryRange;

#define BOOT_LINE_LENGTH        1024
#define BOOT_STRING_LEN         BOOT_LINE_LENGTH

/*
 * Video information.. 
 */

struct Boot_Video {
	uint32_t	v_baseAddr;	/* Base address of video memory */
	uint32_t	v_display;	/* Display Code (if Applicable */
	uint32_t	v_rowBytes;	/* Number of bytes per pixel row */
	uint32_t	v_width;	/* Width */
	uint32_t	v_height;	/* Height */
	uint32_t	v_depth;	/* Pixel Depth */
};

typedef struct Boot_Video	Boot_Video;

/* Values for v_display */

#define GRAPHICS_MODE         1
#define FB_TEXT_MODE          2

/* Struct describing an image passed in by the booter */
struct boot_icon_element {
    unsigned int    width;
    unsigned int    height;
    int             y_offset_from_center;
    unsigned int    data_size;
    unsigned int    __reserved1[4];
    unsigned char   data[0];
};
typedef struct boot_icon_element boot_icon_element;

/* Boot argument structure - passed into Mach kernel at boot time.
 * "Revision" can be incremented for compatible changes
 */
#define kBootArgsRevision		0
#define kBootArgsVersion		2

/* Snapshot constants of previous revisions that are supported */
#define kBootArgsVersion1		1
#define kBootArgsVersion2		2
#define kBootArgsRevision2_0		0

#define kBootArgsEfiMode32              32
#define kBootArgsEfiMode64              64

/* Bitfields for boot_args->flags */
#define kBootArgsFlagRebootOnPanic	(1 << 0)
#define kBootArgsFlagHiDPI		(1 << 1)
#define kBootArgsFlagBlack		(1 << 2)
#define kBootArgsFlagCSRActiveConfig	(1 << 3)
#define kBootArgsFlagCSRConfigMode	(1 << 4)
#define kBootArgsFlagCSRBoot		(1 << 5)
#define kBootArgsFlagBlackBg		(1 << 6)
#define kBootArgsFlagLoginUI		(1 << 7)
#define kBootArgsFlagInstallUI		(1 << 8)

typedef struct boot_args {
    uint16_t    Revision;	/* Revision of boot_args structure */
    uint16_t    Version;	/* Version of boot_args structure */

    uint8_t     efiMode;    /* 32 = 32-bit, 64 = 64-bit */
    uint8_t     debugMode;  /* Bit field with behavior changes */
    uint16_t    flags;

    char        CommandLine[BOOT_LINE_LENGTH];	/* Passed in command line */

    uint32_t    MemoryMap;  /* Physical address of memory map */
    uint32_t    MemoryMapSize;
    uint32_t    MemoryMapDescriptorSize;
    uint32_t    MemoryMapDescriptorVersion;

    Boot_Video	Video;		/* Video Information */

    uint32_t    deviceTreeP;	  /* Physical address of flattened device tree */
    uint32_t    deviceTreeLength; /* Length of flattened tree */

    uint32_t    kaddr;            /* Physical address of beginning of kernel text */
    uint32_t    ksize;            /* Size of combined kernel text+data+efi */

    uint32_t    efiRuntimeServicesPageStart; /* physical address of defragmented runtime pages */
    uint32_t    efiRuntimeServicesPageCount;
    uint64_t    efiRuntimeServicesVirtualPageStart; /* virtual address of defragmented runtime pages */

    uint32_t    efiSystemTable;   /* physical address of system table in runtime area */
    uint32_t    kslide;

    uint32_t    performanceDataStart; /* physical address of log */
    uint32_t    performanceDataSize;

    uint32_t    keyStoreDataStart; /* physical address of key store data */
    uint32_t    keyStoreDataSize;
    uint64_t	bootMemStart;
    uint64_t	bootMemSize;
    uint64_t    PhysicalMemorySize;
    uint64_t    FSBFrequency;
    uint64_t    pciConfigSpaceBaseAddress;
    uint32_t    pciConfigSpaceStartBusNumber;
    uint32_t    pciConfigSpaceEndBusNumber;
    uint32_t	csrActiveConfig;
    uint32_t	csrCapabilities;
    uint32_t    boot_SMC_plimit;
    uint16_t    bootProgressMeterStart;
    uint16_t    bootProgressMeterEnd;
    uint32_t    __reserved4[726];

} boot_args;

extern char assert_boot_args_size_is_4096[sizeof(boot_args) == 4096 ? 1 : -1];

#endif /* _PEXPERT_I386_BOOT_H */

                osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/i386/efi.h                                  0100644 0001750 0001750 00000035273 12567450733 022702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _PEXPERT_I386_EFI_H
#define _PEXPERT_I386_EFI_H

#include <stdint.h>

typedef uint8_t   EFI_UINT8;
typedef uint16_t  EFI_UINT16;
typedef uint32_t  EFI_UINT32;
typedef uint64_t  EFI_UINT64;

typedef uint32_t  EFI_UINTN; /* natural size for firmware, not kernel */

typedef int8_t    EFI_INT8;
typedef int16_t   EFI_INT16;
typedef int32_t   EFI_INT32;
typedef int64_t   EFI_INT64;

typedef int8_t    EFI_CHAR8;
typedef int16_t   EFI_CHAR16;
typedef int32_t   EFI_CHAR32;
typedef int64_t   EFI_CHAR64;

typedef uint32_t  EFI_STATUS;
typedef uint8_t   EFI_BOOLEAN;
typedef void      VOID;

typedef uint32_t  EFI_PTR32;
typedef uint32_t  EFI_HANDLE32;

typedef uint64_t  EFI_PTR64;
typedef uint64_t  EFI_HANDLE64;
/*

Portions Copyright 2004, Intel Corporation
All rights reserved. This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
    http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/


//
// Modifiers for EFI Runtime and Boot Services
//
#define EFI_RUNTIMESERVICE
#define EFIAPI
#define IN
#define OUT
#define OPTIONAL

#define EFI_MAX_BIT       0x80000000

//
// Set the upper bit to indicate EFI Error.
//
#define EFIERR(a)                 (EFI_MAX_BIT | (a))

#define EFIWARN(a)                (a)
#define EFI_ERROR(a)              (((INTN) (a)) < 0)

#define EFI_SUCCESS               0
#define EFI_LOAD_ERROR            EFIERR (1)
#define EFI_INVALID_PARAMETER     EFIERR (2)
#define EFI_UNSUPPORTED           EFIERR (3)
#define EFI_BAD_BUFFER_SIZE       EFIERR (4)
#define EFI_BUFFER_TOO_SMALL      EFIERR (5)
#define EFI_NOT_READY             EFIERR (6)
#define EFI_DEVICE_ERROR          EFIERR (7)
#define EFI_WRITE_PROTECTED       EFIERR (8)
#define EFI_OUT_OF_RESOURCES      EFIERR (9)
#define EFI_VOLUME_CORRUPTED      EFIERR (10)
#define EFI_VOLUME_FULL           EFIERR (11)
#define EFI_NO_MEDIA              EFIERR (12)
#define EFI_MEDIA_CHANGED         EFIERR (13)
#define EFI_NOT_FOUND             EFIERR (14)
#define EFI_ACCESS_DENIED         EFIERR (15)
#define EFI_NO_RESPONSE           EFIERR (16)
#define EFI_NO_MAPPING            EFIERR (17)
#define EFI_TIMEOUT               EFIERR (18)
#define EFI_NOT_STARTED           EFIERR (19)
#define EFI_ALREADY_STARTED       EFIERR (20)
#define EFI_ABORTED               EFIERR (21)
#define EFI_ICMP_ERROR            EFIERR (22)
#define EFI_TFTP_ERROR            EFIERR (23)
#define EFI_PROTOCOL_ERROR        EFIERR (24)
#define EFI_INCOMPATIBLE_VERSION  EFIERR (25)
#define EFI_SECURITY_VIOLATION    EFIERR (26)
#define EFI_CRC_ERROR             EFIERR (27)

#define EFI_WARN_UNKNOWN_GLYPH    EFIWARN (1)
#define EFI_WARN_DELETE_FAILURE   EFIWARN (2)
#define EFI_WARN_WRITE_FAILURE    EFIWARN (3)
#define EFI_WARN_BUFFER_TOO_SMALL EFIWARN (4)

//
// EFI Specification Revision information
//
#define EFI_SPECIFICATION_MAJOR_REVISION  1
#define EFI_SPECIFICATION_MINOR_REVISION  10

typedef struct {
  EFI_UINT32  Data1;
  EFI_UINT16  Data2;
  EFI_UINT16  Data3;
  EFI_UINT8   Data4[8];
} EFI_GUID;

#define APPLE_VENDOR_GUID \
    {0xAC39C713, 0x7E50, 0x423D, {0x88, 0x9D, 0x27,0x8F, 0xCC, 0x34, 0x22, 0xB6} }

#define EFI_GLOBAL_VARIABLE_GUID \
    {0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }

typedef union {
  EFI_GUID  Guid;
  EFI_UINT8 Raw[16];
} EFI_GUID_UNION;

//
// EFI Time Abstraction:
//  Year:       2000 - 20XX
//  Month:      1 - 12
//  Day:        1 - 31
//  Hour:       0 - 23
//  Minute:     0 - 59
//  Second:     0 - 59
//  Nanosecond: 0 - 999,999,999
//  TimeZone:   -1440 to 1440 or 2047
//
typedef struct {
  EFI_UINT16  Year;
  EFI_UINT8   Month;
  EFI_UINT8   Day;
  EFI_UINT8   Hour;
  EFI_UINT8   Minute;
  EFI_UINT8   Second;
  EFI_UINT8   Pad1;
  EFI_UINT32  Nanosecond;
  EFI_INT16   TimeZone;
  EFI_UINT8   Daylight;
  EFI_UINT8   Pad2;
} EFI_TIME;

//
// Bit definitions for EFI_TIME.Daylight
//
#define EFI_TIME_ADJUST_DAYLIGHT  0x01
#define EFI_TIME_IN_DAYLIGHT      0x02

//
// Value definition for EFI_TIME.TimeZone
//
#define EFI_UNSPECIFIED_TIMEZONE  0x07FF

typedef enum {
  EfiReservedMemoryType,
  EfiLoaderCode,
  EfiLoaderData,
  EfiBootServicesCode,
  EfiBootServicesData,
  EfiRuntimeServicesCode,
  EfiRuntimeServicesData,
  EfiConventionalMemory,
  EfiUnusableMemory,
  EfiACPIReclaimMemory,
  EfiACPIMemoryNVS,
  EfiMemoryMappedIO,
  EfiMemoryMappedIOPortSpace,
  EfiPalCode,
  EfiMaxMemoryType
} EFI_MEMORY_TYPE;

typedef struct {
  EFI_UINT64  Signature;
  EFI_UINT32  Revision;
  EFI_UINT32  HeaderSize;
  EFI_UINT32  CRC32;
  EFI_UINT32  Reserved;
} __attribute__((aligned(8))) EFI_TABLE_HEADER;

//
// possible caching types for the memory range
//
#define EFI_MEMORY_UC   0x0000000000000001ULL
#define EFI_MEMORY_WC   0x0000000000000002ULL
#define EFI_MEMORY_WT   0x0000000000000004ULL
#define EFI_MEMORY_WB   0x0000000000000008ULL
#define EFI_MEMORY_UCE  0x0000000000000010ULL

//
// physical memory protection on range
//
#define EFI_MEMORY_WP 0x0000000000001000ULL
#define EFI_MEMORY_RP 0x0000000000002000ULL
#define EFI_MEMORY_XP 0x0000000000004000ULL

//
// range requires a runtime mapping
//
#define EFI_MEMORY_RUNTIME  0x8000000000000000ULL
#define EFI_MEMORY_KERN_RESERVED (1ULL << 59)
typedef EFI_UINT64  EFI_PHYSICAL_ADDRESS;
typedef EFI_UINT64  EFI_VIRTUAL_ADDRESS;

#define EFI_MEMORY_DESCRIPTOR_VERSION 1
typedef struct {
  EFI_UINT32            Type;
  EFI_UINT32            Pad;
  EFI_PHYSICAL_ADDRESS  PhysicalStart;
  EFI_VIRTUAL_ADDRESS   VirtualStart;
  EFI_UINT64            NumberOfPages;
  EFI_UINT64            Attribute;
} __attribute__((aligned(8))) EFI_MEMORY_DESCRIPTOR;


typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
  IN EFI_UINTN                    MemoryMapSize,
  IN EFI_UINTN                    DescriptorSize,
  IN EFI_UINT32                   DescriptorVersion,
  IN EFI_MEMORY_DESCRIPTOR        * VirtualMap
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_CONVERT_POINTER) (
  IN EFI_UINTN                DebugDisposition,
  IN OUT VOID                 **Address
  );

//
// Variable attributes
//
#define EFI_VARIABLE_NON_VOLATILE       0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS     0x00000004
#define EFI_VARIABLE_READ_ONLY          0x00000008

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_GET_VARIABLE) (
  IN EFI_CHAR16               * VariableName,
  IN EFI_GUID                 * VendorGuid,
  OUT EFI_UINT32              * Attributes OPTIONAL,
  IN OUT EFI_UINTN            * DataSize,
  OUT VOID                    * Data
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
  IN OUT EFI_UINTN            * VariableNameSize,
  IN OUT EFI_CHAR16           * VariableName,
  IN OUT EFI_GUID             * VendorGuid
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_SET_VARIABLE) (
  IN EFI_CHAR16               * VariableName,
  IN EFI_GUID                 * VendorGuid,
  IN EFI_UINT32               Attributes,
  IN EFI_UINTN                DataSize,
  IN VOID                     * Data
  );

//
// EFI Time
//
typedef struct {
  EFI_UINT32  Resolution;
  EFI_UINT32  Accuracy;
  EFI_BOOLEAN SetsToZero;
} __attribute__((aligned(4))) EFI_TIME_CAPABILITIES;

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_GET_TIME) (
  OUT EFI_TIME                * Time,
  OUT EFI_TIME_CAPABILITIES   * Capabilities OPTIONAL
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_SET_TIME) (
  IN EFI_TIME                 * Time
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_GET_WAKEUP_TIME) (
  OUT EFI_BOOLEAN             * Enabled,
  OUT EFI_BOOLEAN             * Pending,
  OUT EFI_TIME                * Time
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_SET_WAKEUP_TIME) (
  IN EFI_BOOLEAN              Enable,
  IN EFI_TIME                 * Time OPTIONAL
  );

typedef enum {
  EfiResetCold,
  EfiResetWarm,
  EfiResetShutdown,

#ifdef TIANO_EXTENSION_FLAG
  EfiResetUpdate
#endif

} EFI_RESET_TYPE;

typedef
EFI_RUNTIMESERVICE
VOID
(EFIAPI *EFI_RESET_SYSTEM) (
  IN EFI_RESET_TYPE               ResetType,
  IN EFI_STATUS                   ResetStatus,
  IN EFI_UINTN                    DataSize,
  IN EFI_CHAR16                   * ResetData OPTIONAL
  );

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
  OUT EFI_UINT32                  * HighCount
  );

//
// Definition of Status Code extended data header
//
//  HeaderSize    The size of the architecture. This is specified to enable
//                the future expansion
//
//  Size          The size of the data in bytes. This does not include the size
//                of the header structure.
//
//  Type          A GUID defining the type of the data
//
//
#ifdef TIANO_EXTENSION_FLAG

typedef
EFI_RUNTIMESERVICE
EFI_STATUS
(EFIAPI *EFI_REPORT_STATUS_CODE) (
  IN EFI_STATUS_CODE_TYPE       Type,
  IN EFI_STATUS_CODE_VALUE      Value,
  IN EFI_UINT32                 Instance,
  IN EFI_GUID                   * CallerId OPTIONAL,
  IN EFI_STATUS_CODE_DATA       * Data OPTIONAL
  );

#endif
//
// EFI Runtime Services Table
//
#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552ULL
#define EFI_RUNTIME_SERVICES_REVISION   ((EFI_SPECIFICATION_MAJOR_REVISION << 16) | (EFI_SPECIFICATION_MINOR_REVISION))

typedef struct {
  EFI_TABLE_HEADER              Hdr;

  //
  // Time services
  //
  EFI_PTR32                     GetTime;
  EFI_PTR32                     SetTime;
  EFI_PTR32                     GetWakeupTime;
  EFI_PTR32                     SetWakeupTime;

  //
  // Virtual memory services
  //
  EFI_PTR32                     SetVirtualAddressMap;
  EFI_PTR32                     ConvertPointer;

  //
  // Variable services
  //
  EFI_PTR32                     GetVariable;
  EFI_PTR32                     GetNextVariableName;
  EFI_PTR32                     SetVariable;

  //
  // Misc
  //
  EFI_PTR32                     GetNextHighMonotonicCount;
  EFI_PTR32                     ResetSystem;

#ifdef TIANO_EXTENSION_FLAG
  //
  // ////////////////////////////////////////////////////
  // Extended EFI Services
    //////////////////////////////////////////////////////
  //
  EFI_PTR32                     ReportStatusCode;
#endif

} __attribute__((aligned(8))) EFI_RUNTIME_SERVICES_32;

typedef struct {
  EFI_TABLE_HEADER              Hdr;

  //
  // Time services
  //
  EFI_PTR64                     GetTime;
  EFI_PTR64                     SetTime;
  EFI_PTR64                     GetWakeupTime;
  EFI_PTR64                     SetWakeupTime;

  //
  // Virtual memory services
  //
  EFI_PTR64                     SetVirtualAddressMap;
  EFI_PTR64                     ConvertPointer;

  //
  // Variable services
  //
  EFI_PTR64                     GetVariable;
  EFI_PTR64                     GetNextVariableName;
  EFI_PTR64                     SetVariable;

  //
  // Misc
  //
  EFI_PTR64                     GetNextHighMonotonicCount;
  EFI_PTR64                     ResetSystem;

#ifdef TIANO_EXTENSION_FLAG
  //
  // ////////////////////////////////////////////////////
  // Extended EFI Services
    //////////////////////////////////////////////////////
  //
  EFI_PTR64                     ReportStatusCode;
#endif

} __attribute__((aligned(8))) EFI_RUNTIME_SERVICES_64;

//
// EFI Configuration Table
//
typedef struct {
  EFI_GUID  VendorGuid;
  EFI_PTR32 VendorTable;
} EFI_CONFIGURATION_TABLE_32;

typedef struct {
  EFI_GUID  VendorGuid;
  EFI_PTR64 VendorTable;
} __attribute__((aligned(8))) EFI_CONFIGURATION_TABLE_64;

//
// EFI System Table
//
#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249ULL
#define EFI_SYSTEM_TABLE_REVISION       ((EFI_SPECIFICATION_MAJOR_REVISION << 16) | (EFI_SPECIFICATION_MINOR_REVISION))
#define EFI_2_00_SYSTEM_TABLE_REVISION  ((2 << 16) | 00)
#define EFI_1_02_SYSTEM_TABLE_REVISION  ((1 << 16) | 02)
#define EFI_1_10_SYSTEM_TABLE_REVISION  ((1 << 16) | 10)

typedef struct EFI_SYSTEM_TABLE_32 {
  EFI_TABLE_HEADER              Hdr;

  EFI_PTR32                     FirmwareVendor;
  EFI_UINT32                    FirmwareRevision;

  EFI_HANDLE32                  ConsoleInHandle;
  EFI_PTR32                     ConIn;

  EFI_HANDLE32                  ConsoleOutHandle;
  EFI_PTR32                     ConOut;

  EFI_HANDLE32                  StandardErrorHandle;
  EFI_PTR32                     StdErr;

  EFI_PTR32                     RuntimeServices;
  EFI_PTR32                     BootServices;

  EFI_UINT32                    NumberOfTableEntries;
  EFI_PTR32                     ConfigurationTable;

} __attribute__((aligned(8))) EFI_SYSTEM_TABLE_32;

typedef struct EFI_SYSTEM_TABLE_64 {
  EFI_TABLE_HEADER              Hdr;

  EFI_PTR64                     FirmwareVendor;
  EFI_UINT32                    FirmwareRevision;

  EFI_UINT32                    __pad;

  EFI_HANDLE64                  ConsoleInHandle;
  EFI_PTR64                     ConIn;

  EFI_HANDLE64                  ConsoleOutHandle;
  EFI_PTR64                     ConOut;

  EFI_HANDLE64                  StandardErrorHandle;
  EFI_PTR64                     StdErr;

  EFI_PTR64                     RuntimeServices;
  EFI_PTR64                     BootServices;

  EFI_UINT64                    NumberOfTableEntries;
  EFI_PTR64                     ConfigurationTable;

} __attribute__((aligned(8))) EFI_SYSTEM_TABLE_64;

#endif /* _PEXPERT_I386_EFI_H */
                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/i386/protos.h                               0100644 0001750 0001750 00000005251 12567450733 023456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_I386_PROTOS_H
#define _PEXPERT_I386_PROTOS_H

//------------------------------------------------------------------------
// x86 IN/OUT I/O inline functions.
//
// IN :  inb, inw, inl
//       IN(port)
//
// OUT:  outb, outw, outl
//       OUT(port, data)

typedef unsigned short   i386_ioport_t;

#define __IN(s, u) \
static __inline__ unsigned u \
in##s(i386_ioport_t port) \
{ \
    unsigned u data; \
    asm volatile ( \
        "in" #s " %1,%0" \
        : "=a" (data) \
        : "d" (port)); \
    return (data); \
}

#define __OUT(s, u) \
static __inline__ void \
out##s(i386_ioport_t port, unsigned u data) \
{ \
    asm volatile ( \
        "out" #s " %1,%0" \
        : \
        : "d" (port), "a" (data)); \
}

__IN(b, char)
__IN(w, short)
__IN(l, long)

__OUT(b, char)
__OUT(w, short)
__OUT(l, long)

extern void cninit(void);
extern int  sprintf(char * str, const char * format, ...);

/* ------------------------------------------------------------------------
 * from osfmk/i386/serial_io.h
 */
int switch_to_serial_console(void);
void switch_to_old_console(int);
boolean_t console_is_serial(void);
int serial_init(void);
void serial_putc(char);
int serial_getc(void);

/* ------------------------------------------------------------------------
 * from osfmk/kern/misc_protos.h
 */
void cnputc(char);
int cngetc(void);

#endif /* _PEXPERT_I386_PROTOS_H */
                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/machine/                                    0040755 0001750 0001750 00000000000 12612224753 022662  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/machine/boot.h                              0100644 0001750 0001750 00000003024 12567450736 024005  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_MACHINE_BOOT_H
#define _PEXPERT_MACHINE_BOOT_H

#if defined (__i386__) || defined(__x86_64__)
#include "pexpert/i386/boot.h"
#else
#error architecture not supported
#endif

#endif /* _PEXPERT_MACHINE_BOOT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/machine/protos.h                            0100644 0001750 0001750 00000003034 12567450736 024371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_MACHINE_PROTOS_H
#define _PEXPERT_MACHINE_PROTOS_H

#if defined (__i386__) || defined(__x86_64__)
#include "pexpert/i386/protos.h"
#else
#error architecture not supported
#endif

#endif /* _PEXPERT_MACHINE_PROTOS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/pexpert.h                                   0100644 0001750 0001750 00000016745 12567450737 023144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_PEXPERT_H_
#define _PEXPERT_PEXPERT_H_

#include <sys/cdefs.h>


__BEGIN_DECLS
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/machine/vm_types.h>

#include <pexpert/boot.h>

typedef void *cpu_id_t;


void PE_enter_debugger(
	const char *cause);

void PE_init_platform(
	boolean_t vm_initialized, 
	void *args);

/*
 * Copies the requested number of bytes from the "random-seed" property in
 * the device tree, and zeros the corresponding bytes in the device tree.
 * Returns the number of bytes actually copied.
 */
uint32_t PE_get_random_seed(
	unsigned char * dst_random_seed,
	uint32_t request_size);

uint32_t PE_i_can_has_debugger(
	uint32_t *);



void PE_init_kprintf(
	boolean_t vm_initialized);

extern int32_t gPESerialBaud;

extern uint8_t gPlatformECID[8];

unsigned int PE_init_taproot(vm_offset_t *taddr);

extern void (*PE_kputc)(char c);

void PE_init_printf(
	boolean_t vm_initialized);

extern void (*PE_putc)(char c);

void PE_init_iokit(
	void);

struct clock_frequency_info_t {
  unsigned long bus_clock_rate_hz;
  unsigned long cpu_clock_rate_hz;
  unsigned long dec_clock_rate_hz;
  unsigned long bus_clock_rate_num;
  unsigned long bus_clock_rate_den;
  unsigned long bus_to_cpu_rate_num;
  unsigned long bus_to_cpu_rate_den;
  unsigned long bus_to_dec_rate_num;
  unsigned long bus_to_dec_rate_den;
  unsigned long timebase_frequency_hz;
  unsigned long timebase_frequency_num;
  unsigned long timebase_frequency_den;
  unsigned long long bus_frequency_hz;
  unsigned long long bus_frequency_min_hz;
  unsigned long long bus_frequency_max_hz;
  unsigned long long cpu_frequency_hz;
  unsigned long long cpu_frequency_min_hz;
  unsigned long long cpu_frequency_max_hz;
  unsigned long long prf_frequency_hz;
  unsigned long long prf_frequency_min_hz;
  unsigned long long prf_frequency_max_hz;
  unsigned long long mem_frequency_hz;
  unsigned long long mem_frequency_min_hz;
  unsigned long long mem_frequency_max_hz;
  unsigned long long fix_frequency_hz;
};

typedef struct clock_frequency_info_t clock_frequency_info_t;

extern clock_frequency_info_t gPEClockFrequencyInfo;

struct timebase_freq_t {
  unsigned long timebase_num;
  unsigned long timebase_den;
};

typedef void (*timebase_callback_func)(struct timebase_freq_t *timebase_freq);

void PE_register_timebase_callback(timebase_callback_func callback);

void PE_call_timebase_callback(void);


#ifndef _FN_KPRINTF
#define	_FN_KPRINTF
void kprintf(const char *fmt, ...) __printflike(1,2);
#endif


#if CONFIG_NO_KPRINTF_STRINGS
#define kprintf(x, ...) do {} while (0)
#endif

void init_display_putc(unsigned char *baseaddr, int rowbytes, int height);
void display_putc(char c);

enum {
    kPEReadTOD,
    kPEWriteTOD
};
extern int (*PE_read_write_time_of_day)(
	unsigned int options, 
	long * secs);

enum {
    kPEWaitForInput 	= 0x00000001,
    kPERawInput		= 0x00000002
};
extern int (*PE_poll_input)(
	unsigned int options, 
	char * c);

extern int (*PE_write_IIC)(
	unsigned char addr, 
	unsigned char reg,
	unsigned char data);

/* Private Stuff - eventually put in pexpertprivate.h */
enum {
    kDebugTypeNone    = 0,
    kDebugTypeDisplay = 1,
    kDebugTypeSerial  = 2 
};

/*  Scale factor values for PE_Video.v_scale */
enum {
   kPEScaleFactorUnknown = 0,
   kPEScaleFactor1x      = 1,
   kPEScaleFactor2x      = 2
};

struct PE_Video {
        unsigned long   v_baseAddr;     /* Base address of video memory */
        unsigned long   v_rowBytes;     /* Number of bytes per pixel row */
        unsigned long   v_width;        /* Width */
        unsigned long   v_height;       /* Height */
        unsigned long   v_depth;        /* Pixel Depth */
        unsigned long   v_display;      /* Text or Graphics */
	char		v_pixelFormat[64];
	unsigned long	v_offset;	/* offset into video memory to start at */
	unsigned long	v_length;	/* length of video memory (0 for v_rowBytes * v_height) */
	unsigned char	v_rotate;	/* Rotation: 0:normal, 1:right 90, 2:left 180, 3:left 90 */
	unsigned char	v_scale;	/* Scale Factor for both X & Y */
	char		reserved1[2];
#ifdef __LP64__
	long		reserved2;
#else
	long		v_baseAddrHigh;
#endif
};

typedef struct PE_Video       PE_Video;

extern void initialize_screen(PE_Video *, unsigned int);

extern void dim_screen(void);

extern int PE_current_console(
	PE_Video *info);

extern void PE_create_console(
        void);

extern int PE_initialize_console(
	PE_Video *newInfo, 
	int op);

#define kPEGraphicsMode		1
#define kPETextMode		2
#define kPETextScreen		3
#define kPEAcquireScreen	4
#define kPEReleaseScreen	5
#define kPEEnableScreen	 	6
#define kPEDisableScreen	7
#define kPEBaseAddressChange	8
#define kPERefreshBootGraphics	9

extern void PE_display_icon( unsigned int flags,
			     const char * name );

typedef struct PE_state {
	boolean_t	initialized;
	PE_Video	video;
	void		*deviceTreeHead;
	void		*bootArgs;
} PE_state_t;

extern PE_state_t PE_state;

extern char * PE_boot_args(
	void);

#if !defined(__LP64__) && !defined(__arm__)
extern boolean_t PE_parse_boot_arg(
	const char	*arg_string,
	void    	*arg_ptr) __deprecated;
#endif

extern boolean_t PE_parse_boot_argn(
	const char	*arg_string,
	void    	*arg_ptr,
	int			max_arg);

extern boolean_t PE_get_default(
	const char	*property_name,
	void		*property_ptr,
	unsigned int max_property);

#define PE_default_value(_key, _variable, _default)	\
	do {															  \
		if (!PE_get_default((_key), &(_variable), sizeof(_variable))) \
			_variable = _default;									  \
	} while(0)

enum {
    kPEOptionKey	= 0x3a,
    kPECommandKey	= 0x37,
    kPEControlKey	= 0x36,
    kPEShiftKey		= 0x38
};

extern boolean_t PE_get_hotkey(
	unsigned char	key);

extern kern_return_t PE_cpu_start(
	cpu_id_t target,
	vm_offset_t start_paddr,
	vm_offset_t arg_paddr);

extern void PE_cpu_halt(
	cpu_id_t target);

extern void PE_cpu_signal(
	cpu_id_t source,
	cpu_id_t target);

extern void PE_cpu_signal_deferred(
	cpu_id_t source,
	cpu_id_t target);

extern void PE_cpu_signal_cancel(
	cpu_id_t source,
	cpu_id_t target);

extern void PE_cpu_machine_init(
	cpu_id_t target,
	boolean_t bootb);

extern void PE_cpu_machine_quiesce(
	cpu_id_t target);

extern void pe_init_debug(void);

extern boolean_t PE_imgsrc_mount_supported(void);



__END_DECLS

#endif /* _PEXPERT_PEXPERT_H_ */
                           osxcross/target/SDK/MacOSX10.11.sdk/usr/include/pexpert/protos.h                                    0100644 0001750 0001750 00000002616 12567450737 022773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _PEXPERT_PROTOS_H_
#define _PEXPERT_PROTOS_H_


#endif /* _PEXPERT_PROTOS_H_ */
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/                                                0040755 0001750 0001750 00000000000 12612224754 020357  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/                                           0040755 0001750 0001750 00000000000 12612224753 021143  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/TSRM.h                                     0100644 0001750 0001750 00000012564 12566220070 022102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Thread Safe Resource Manager                                         |
   +----------------------------------------------------------------------+
   | Copyright (c) 1999-2011, Andi Gutmans, Sascha Schumann, Zeev Suraski |
   | This source file is subject to the TSRM license, that is bundled     |
   | with this package in the file LICENSE                                |
   +----------------------------------------------------------------------+
   | Authors:  Zeev Suraski <zeev@zend.com>                               |
   +----------------------------------------------------------------------+
*/

#ifndef TSRM_H
#define TSRM_H

#if !defined(__CYGWIN__) && defined(WIN32)
# define TSRM_WIN32
# include "tsrm_config.w32.h"
#else
# include <tsrm_config.h>
#endif

#ifdef TSRM_WIN32
#	ifdef TSRM_EXPORTS
#		define TSRM_API __declspec(dllexport)
#	else
#		define TSRM_API __declspec(dllimport)
#	endif
#elif defined(__GNUC__) && __GNUC__ >= 4
#	define TSRM_API __attribute__ ((visibility("default")))
#else
#	define TSRM_API
#endif

#ifdef _WIN64
typedef __int64 tsrm_intptr_t;
typedef unsigned __int64 tsrm_uintptr_t;
#else
typedef long tsrm_intptr_t;
typedef unsigned long tsrm_uintptr_t;
#endif

/* Only compile multi-threading functions if we're in ZTS mode */
#ifdef ZTS

#ifdef TSRM_WIN32
# ifndef TSRM_INCLUDE_FULL_WINDOWS_HEADERS
#  define WIN32_LEAN_AND_MEAN
# endif
# include <windows.h>
# include <shellapi.h>
#elif defined(GNUPTH)
# include <pth.h>
#elif defined(PTHREADS)
# include <pthread.h>
#elif defined(TSRM_ST)
# include <st.h>
#elif defined(BETHREADS)
#include <kernel/OS.h> 
#include <TLS.h>
#endif

typedef int ts_rsrc_id;

/* Define THREAD_T and MUTEX_T */
#ifdef TSRM_WIN32
# define THREAD_T DWORD
# define MUTEX_T CRITICAL_SECTION *
#elif defined(GNUPTH)
# define THREAD_T pth_t
# define MUTEX_T pth_mutex_t *
#elif defined(PTHREADS)
# define THREAD_T pthread_t
# define MUTEX_T pthread_mutex_t *
#elif defined(NSAPI)
# define THREAD_T SYS_THREAD
# define MUTEX_T CRITICAL
#elif defined(PI3WEB)
# define THREAD_T PIThread *
# define MUTEX_T PISync *
#elif defined(TSRM_ST)
# define THREAD_T st_thread_t
# define MUTEX_T st_mutex_t
#elif defined(BETHREADS)
# define THREAD_T thread_id
typedef struct {
  sem_id sem;
  int32 ben;
} beos_ben;
# define MUTEX_T beos_ben * 
#endif

#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif

typedef void (*ts_allocate_ctor)(void *, void ***);
typedef void (*ts_allocate_dtor)(void *, void ***);

#define THREAD_HASH_OF(thr,ts)  (unsigned long)thr%(unsigned long)ts

#ifdef __cplusplus
extern "C" {
#endif

/* startup/shutdown */
TSRM_API int tsrm_startup(int expected_threads, int expected_resources, int debug_level, char *debug_filename);
TSRM_API void tsrm_shutdown(void);

/* allocates a new thread-safe-resource id */
TSRM_API ts_rsrc_id ts_allocate_id(ts_rsrc_id *rsrc_id, size_t size, ts_allocate_ctor ctor, ts_allocate_dtor dtor);

/* fetches the requested resource for the current thread */
TSRM_API void *ts_resource_ex(ts_rsrc_id id, THREAD_T *th_id);
#define ts_resource(id)			ts_resource_ex(id, NULL)

/* frees all resources allocated for the current thread */
TSRM_API void ts_free_thread(void);

/* frees all resources allocated for all threads except current */
void ts_free_worker_threads(void);

/* deallocates all occurrences of a given id */
TSRM_API void ts_free_id(ts_rsrc_id id);


/* Debug support */
#define TSRM_ERROR_LEVEL_ERROR	1
#define TSRM_ERROR_LEVEL_CORE	2
#define TSRM_ERROR_LEVEL_INFO	3

typedef void (*tsrm_thread_begin_func_t)(THREAD_T thread_id, void ***tsrm_ls);
typedef void (*tsrm_thread_end_func_t)(THREAD_T thread_id, void ***tsrm_ls);


TSRM_API int tsrm_error(int level, const char *format, ...);
TSRM_API void tsrm_error_set(int level, char *debug_filename);

/* utility functions */
TSRM_API THREAD_T tsrm_thread_id(void);
TSRM_API MUTEX_T tsrm_mutex_alloc(void);
TSRM_API void tsrm_mutex_free(MUTEX_T mutexp);
TSRM_API int tsrm_mutex_lock(MUTEX_T mutexp);
TSRM_API int tsrm_mutex_unlock(MUTEX_T mutexp);
#ifdef HAVE_SIGPROCMASK
TSRM_API int tsrm_sigmask(int how, const sigset_t *set, sigset_t *oldset);
#endif

TSRM_API void *tsrm_set_new_thread_begin_handler(tsrm_thread_begin_func_t new_thread_begin_handler);
TSRM_API void *tsrm_set_new_thread_end_handler(tsrm_thread_end_func_t new_thread_end_handler);

/* these 3 APIs should only be used by people that fully understand the threading model
 * used by PHP/Zend and the selected SAPI. */
TSRM_API void *tsrm_new_interpreter_context(void);
TSRM_API void *tsrm_set_interpreter_context(void *new_ctx);
TSRM_API void tsrm_free_interpreter_context(void *context);

#define TSRM_SHUFFLE_RSRC_ID(rsrc_id)		((rsrc_id)+1)
#define TSRM_UNSHUFFLE_RSRC_ID(rsrc_id)		((rsrc_id)-1)

#define TSRMLS_FETCH()			void ***tsrm_ls = (void ***) ts_resource_ex(0, NULL)
#define TSRMLS_FETCH_FROM_CTX(ctx)	void ***tsrm_ls = (void ***) ctx
#define TSRMLS_SET_CTX(ctx)		ctx = (void ***) tsrm_ls
#define TSRMG(id, type, element)	(((type) (*((void ***) tsrm_ls))[TSRM_UNSHUFFLE_RSRC_ID(id)])->element)
#define TSRMLS_D	void ***tsrm_ls
#define TSRMLS_DC	, TSRMLS_D
#define TSRMLS_C	tsrm_ls
#define TSRMLS_CC	, TSRMLS_C

#ifdef __cplusplus
}
#endif

#else /* non ZTS */

#define TSRMLS_FETCH()
#define TSRMLS_FETCH_FROM_CTX(ctx)
#define TSRMLS_SET_CTX(ctx)
#define TSRMLS_D	void
#define TSRMLS_DC
#define TSRMLS_C
#define TSRMLS_CC

#endif /* ZTS */

#endif /* TSRM_H */
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/readdir.h                                  0100644 0001750 0001750 00000002116 12566220071 022720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef READDIR_H
#define READDIR_H


/*
 * Structures and types used to implement opendir/readdir/closedir
 * on Windows 95/NT.
 */

#include <windows.h>

#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <direct.h>

/* struct dirent - same as Unix */

struct dirent {
	long d_ino;					/* inode (always 1 in WIN32) */
	off_t d_off;				/* offset to this dirent */
	unsigned short d_reclen;	/* length of d_name */
	char d_name[_MAX_FNAME + 1];	/* filename (null terminated) */
};


/* typedef DIR - not the same as Unix */
typedef struct {
	HANDLE handle;				/* _findfirst/_findnext handle */
	short offset;				/* offset into directory */
	short finished;				/* 1 if there are not more files */
	WIN32_FIND_DATA fileinfo;	/* from _findfirst/_findnext */
	char *dir;					/* the dir we are reading */
	struct dirent dent;			/* the dirent to return */
} DIR;

/* Function prototypes */
DIR *opendir(const char *);
struct dirent *readdir(DIR *);
int readdir_r(DIR *, struct dirent *, struct dirent **);
int closedir(DIR *);
int rewinddir(DIR *);

#endif /* READDIR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_config.h                              0100644 0001750 0001750 00000000040 12566220071 023612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <../main/php_config.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_config.w32.h                          0100644 0001750 0001750 00000000400 12566220071 024224  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef TSRM_CONFIG_W32_H
#define TSRM_CONFIG_W32_H

#include <../main/config.w32.h>
#include "Zend/zend_config.w32.h"

#define HAVE_UTIME 1
#define HAVE_ALLOCA 1
#define HAVE_REALPATH 1

#include <malloc.h>
#include <stdlib.h>
#include <crtdbg.h>

#endif
                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_config_common.h                       0100644 0001750 0001750 00000002664 12566220071 025200  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef TSRM_CONFIG_COMMON_H
#define TSRM_CONFIG_COMMON_H

#ifndef __CYGWIN__
# ifdef _WIN32
#  define TSRM_WIN32
# endif
#endif

#ifdef TSRM_WIN32
# include "tsrm_config.w32.h"
#else
# include <tsrm_config.h>
# include <sys/param.h>
#endif

#if HAVE_ALLOCA_H && !defined(_ALLOCA_H)
#  include <alloca.h>
#endif

/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifndef HAVE_ALLOCA_H
#  ifdef _AIX
#pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
#    ifndef NETWARE
char *alloca ();
#    endif
#   endif
#  endif
# endif
#endif

#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#if HAVE_LIMITS_H
#include <limits.h>
#endif

#ifndef MAXPATHLEN
# ifdef PATH_MAX
#  define MAXPATHLEN PATH_MAX
# elif defined(MAX_PATH)
#  define MAXPATHLEN MAX_PATH
# else
#  define MAXPATHLEN 256
# endif
#endif

#if (HAVE_ALLOCA || (defined (__GNUC__) && __GNUC__ >= 2))
# define TSRM_ALLOCA_MAX_SIZE 4096
# define TSRM_ALLOCA_FLAG(name) \
	int name;
# define tsrm_do_alloca_ex(size, limit, use_heap) \
	((use_heap = ((size) > (limit))) ? malloc(size) : alloca(size))
# define tsrm_do_alloca(size, use_heap) \
	tsrm_do_alloca_ex(size, TSRM_ALLOCA_MAX_SIZE, use_heap)
# define tsrm_free_alloca(p, use_heap) \
	do { if (use_heap) free(p); } while (0)
#else
# define TSRM_ALLOCA_FLAG(name)
# define tsrm_do_alloca(p, use_heap)	malloc(p)
# define tsrm_free_alloca(p, use_heap)	free(p)
#endif

#endif /* TSRM_CONFIG_COMMON_H */
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_nw.h                                  0100644 0001750 0001750 00000002550 12566220071 023001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
   | Copyright (c) 1997-2015 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   | Authors: Venkat Raghavan S <rvenkat@novell.com>                      |
   |          Anantha Kesari H Y <hyanantha@novell.com>                   |
   +----------------------------------------------------------------------+
*/


#ifndef TSRM_NW_H
#define TSRM_NW_H

#include "TSRM.h"

TSRM_API FILE* popen(const char *command, const char *type);
TSRM_API int pclose(FILE* stream);

#endif
                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_strtok_r.h                            0100644 0001750 0001750 00000000163 12566220071 024222  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef TSRM_STRTOK_R
#define TSRM_STRTOK_R

char *tsrm_strtok_r(char *s, const char *delim, char **last);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_virtual_cwd.h                         0100644 0001750 0001750 00000027374 12566220071 024713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
   | Copyright (c) 1997-2015 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Sascha Schumann <sascha@schumann.cx>                        |
   |          Pierre Joye <pierre@php.net>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef VIRTUAL_CWD_H
#define VIRTUAL_CWD_H

#include "TSRM.h"
#include "tsrm_config_common.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>

#ifdef HAVE_UTIME_H
#include <utime.h>
#endif

#ifdef HAVE_STDARG_H
#include <stdarg.h>
#endif

#ifdef ZTS
#define VIRTUAL_DIR
#endif

#ifndef TSRM_WIN32
#include <unistd.h>
#else
#include <direct.h>
#endif

#if defined(__osf__) || defined(_AIX)
#include <errno.h>
#endif

#ifdef TSRM_WIN32
#include "readdir.h"
#include <sys/utime.h>
/* mode_t isn't defined on Windows */
typedef unsigned short mode_t;

#define DEFAULT_SLASH '\\'
#define DEFAULT_DIR_SEPARATOR	';'
#define IS_SLASH(c)	((c) == '/' || (c) == '\\')
#define IS_SLASH_P(c)	(*(c) == '/' || \
        (*(c) == '\\' && !IsDBCSLeadByte(*(c-1))))

/* COPY_WHEN_ABSOLUTE is 2 under Win32 because by chance both regular absolute paths
   in the file system and UNC paths need copying of two characters */
#define COPY_WHEN_ABSOLUTE(path) 2
#define IS_UNC_PATH(path, len) \
	(len >= 2 && IS_SLASH(path[0]) && IS_SLASH(path[1]))
#define IS_ABSOLUTE_PATH(path, len) \
	(len >= 2 && ((isalpha(path[0]) && path[1] == ':') || IS_UNC_PATH(path, len)))

#elif defined(NETWARE)
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif

#define DEFAULT_SLASH '/'
#define DEFAULT_DIR_SEPARATOR	';'
#define IS_SLASH(c)	((c) == '/' || (c) == '\\')
#define IS_SLASH_P(c)	IS_SLASH(*(c))
/* Colon indicates volume name, either first character should be forward slash or backward slash */
#define IS_ABSOLUTE_PATH(path, len) \
    ((strchr(path, ':') != NULL) || ((len >= 1) && ((path[0] == '/') || (path[0] == '\\'))))

#else
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif

#define DEFAULT_SLASH '/'

#ifdef __riscos__
#define DEFAULT_DIR_SEPARATOR  ';'
#else
#define DEFAULT_DIR_SEPARATOR  ':'
#endif

#define IS_SLASH(c)	((c) == '/')
#define IS_SLASH_P(c)	(*(c) == '/')

#endif


#ifndef COPY_WHEN_ABSOLUTE
#define COPY_WHEN_ABSOLUTE(path) 0
#endif

#ifndef IS_ABSOLUTE_PATH
#define IS_ABSOLUTE_PATH(path, len) \
	(IS_SLASH(path[0]))
#endif

#ifdef TSRM_EXPORTS
#define CWD_EXPORTS
#endif

#ifdef TSRM_WIN32
#	ifdef CWD_EXPORTS
#		define CWD_API __declspec(dllexport)
#	else
#		define CWD_API __declspec(dllimport)
#	endif
#elif defined(__GNUC__) && __GNUC__ >= 4
#	define CWD_API __attribute__ ((visibility("default")))
#else
#	define CWD_API
#endif

#ifdef TSRM_WIN32
CWD_API int php_sys_stat_ex(const char *path, struct stat *buf, int lstat);
# define php_sys_stat(path, buf) php_sys_stat_ex(path, buf, 0)
# define php_sys_lstat(path, buf) php_sys_stat_ex(path, buf, 1)
CWD_API int php_sys_readlink(const char *link, char *target, size_t target_len);
#else
# define php_sys_stat stat
# define php_sys_lstat lstat
# ifdef HAVE_SYMLINK
# define php_sys_readlink(link, target, target_len) readlink(link, target, target_len)
# endif
#endif

typedef struct _cwd_state {
	char *cwd;
	int cwd_length;
} cwd_state;

typedef int (*verify_path_func)(const cwd_state *);

CWD_API void virtual_cwd_startup(void);
CWD_API void virtual_cwd_shutdown(void);
CWD_API char *virtual_getcwd_ex(size_t *length TSRMLS_DC);
CWD_API char *virtual_getcwd(char *buf, size_t size TSRMLS_DC);
CWD_API int virtual_chdir(const char *path TSRMLS_DC);
CWD_API int virtual_chdir_file(const char *path, int (*p_chdir)(const char *path TSRMLS_DC) TSRMLS_DC);
CWD_API int virtual_filepath(const char *path, char **filepath TSRMLS_DC);
CWD_API int virtual_filepath_ex(const char *path, char **filepath, verify_path_func verify_path TSRMLS_DC);
CWD_API char *virtual_realpath(const char *path, char *real_path TSRMLS_DC);
CWD_API FILE *virtual_fopen(const char *path, const char *mode TSRMLS_DC);
CWD_API int virtual_open(const char *path TSRMLS_DC, int flags, ...);
CWD_API int virtual_creat(const char *path, mode_t mode TSRMLS_DC);
CWD_API int virtual_rename(char *oldname, char *newname TSRMLS_DC);
CWD_API int virtual_stat(const char *path, struct stat *buf TSRMLS_DC);
CWD_API int virtual_lstat(const char *path, struct stat *buf TSRMLS_DC);
CWD_API int virtual_unlink(const char *path TSRMLS_DC);
CWD_API int virtual_mkdir(const char *pathname, mode_t mode TSRMLS_DC);
CWD_API int virtual_rmdir(const char *pathname TSRMLS_DC);
CWD_API DIR *virtual_opendir(const char *pathname TSRMLS_DC);
CWD_API FILE *virtual_popen(const char *command, const char *type TSRMLS_DC);
CWD_API int virtual_access(const char *pathname, int mode TSRMLS_DC);
#if defined(TSRM_WIN32)
/* these are not defined in win32 headers */
#ifndef W_OK
#define W_OK 0x02
#endif
#ifndef R_OK
#define R_OK 0x04
#endif
#ifndef X_OK
#define X_OK 0x01
#endif
#ifndef F_OK
#define F_OK 0x00
#endif
#endif

#if HAVE_UTIME
CWD_API int virtual_utime(const char *filename, struct utimbuf *buf TSRMLS_DC);
#endif
CWD_API int virtual_chmod(const char *filename, mode_t mode TSRMLS_DC);
#if !defined(TSRM_WIN32) && !defined(NETWARE)
CWD_API int virtual_chown(const char *filename, uid_t owner, gid_t group, int link TSRMLS_DC);
#endif

/* One of the following constants must be used as the last argument
   in virtual_file_ex() call. */

#define CWD_EXPAND   0 /* expand "." and ".." but dont resolve symlinks      */
#define CWD_FILEPATH 1 /* resolve symlinks if file is exist otherwise expand */
#define CWD_REALPATH 2 /* call realpath(), resolve symlinks. File must exist */

CWD_API int virtual_file_ex(cwd_state *state, const char *path, verify_path_func verify_path, int use_realpath TSRMLS_DC);

CWD_API char *tsrm_realpath(const char *path, char *real_path TSRMLS_DC);

#define REALPATH_CACHE_TTL  (2*60) /* 2 minutes */
#define REALPATH_CACHE_SIZE 0      /* disabled while php.ini isn't loaded */

typedef struct _realpath_cache_bucket {
	unsigned long                  key;
	char                          *path;
	int                            path_len;
	char                          *realpath;
	int                            realpath_len;
	int                            is_dir;
	time_t                         expires;
#ifdef PHP_WIN32
	unsigned char                  is_rvalid;
	unsigned char                  is_readable;
	unsigned char                  is_wvalid;
	unsigned char                  is_writable;
#endif
	struct _realpath_cache_bucket *next;
} realpath_cache_bucket;

typedef struct _virtual_cwd_globals {
	cwd_state cwd;
	long                   realpath_cache_size;
	long                   realpath_cache_size_limit;
	long                   realpath_cache_ttl;
	realpath_cache_bucket *realpath_cache[1024];
} virtual_cwd_globals;

#ifdef ZTS
extern ts_rsrc_id cwd_globals_id;
# define CWDG(v) TSRMG(cwd_globals_id, virtual_cwd_globals *, v)
#else
extern virtual_cwd_globals cwd_globals;
# define CWDG(v) (cwd_globals.v)
#endif

CWD_API void realpath_cache_clean(TSRMLS_D);
CWD_API void realpath_cache_del(const char *path, int path_len TSRMLS_DC);
CWD_API realpath_cache_bucket* realpath_cache_lookup(const char *path, int path_len, time_t t TSRMLS_DC);
CWD_API int realpath_cache_size(TSRMLS_D);
CWD_API int realpath_cache_max_buckets(TSRMLS_D);
CWD_API realpath_cache_bucket** realpath_cache_get_buckets(TSRMLS_D);

/* The actual macros to be used in programs using TSRM
 * If the program defines VIRTUAL_DIR it will use the
 * virtual_* functions
 */

#ifdef VIRTUAL_DIR

#define VCWD_GETCWD(buff, size) virtual_getcwd(buff, size TSRMLS_CC)
#define VCWD_FOPEN(path, mode) virtual_fopen(path, mode TSRMLS_CC)
/* Because open() has two modes, we have to macros to replace it */
#define VCWD_OPEN(path, flags) virtual_open(path TSRMLS_CC, flags)
#define VCWD_OPEN_MODE(path, flags, mode) virtual_open(path TSRMLS_CC, flags, mode)
#define VCWD_CREAT(path, mode) virtual_creat(path, mode TSRMLS_CC)
#define VCWD_CHDIR(path) virtual_chdir(path TSRMLS_CC)
#define VCWD_CHDIR_FILE(path) virtual_chdir_file(path, virtual_chdir TSRMLS_CC)
#define VCWD_GETWD(buf)
#define VCWD_REALPATH(path, real_path) virtual_realpath(path, real_path TSRMLS_CC)
#define VCWD_RENAME(oldname, newname) virtual_rename(oldname, newname TSRMLS_CC)
#define VCWD_STAT(path, buff) virtual_stat(path, buff TSRMLS_CC)
# define VCWD_LSTAT(path, buff) virtual_lstat(path, buff TSRMLS_CC)
#define VCWD_UNLINK(path) virtual_unlink(path TSRMLS_CC)
#define VCWD_MKDIR(pathname, mode) virtual_mkdir(pathname, mode TSRMLS_CC)
#define VCWD_RMDIR(pathname) virtual_rmdir(pathname TSRMLS_CC)
#define VCWD_OPENDIR(pathname) virtual_opendir(pathname TSRMLS_CC)
#define VCWD_POPEN(command, type) virtual_popen(command, type TSRMLS_CC)
#define VCWD_ACCESS(pathname, mode) virtual_access(pathname, mode TSRMLS_CC)
#if HAVE_UTIME
#define VCWD_UTIME(path, time) virtual_utime(path, time TSRMLS_CC)
#endif
#define VCWD_CHMOD(path, mode) virtual_chmod(path, mode TSRMLS_CC)
#if !defined(TSRM_WIN32) && !defined(NETWARE)
#define VCWD_CHOWN(path, owner, group) virtual_chown(path, owner, group, 0 TSRMLS_CC)
#if HAVE_LCHOWN
#define VCWD_LCHOWN(path, owner, group) virtual_chown(path, owner, group, 1 TSRMLS_CC)
#endif
#endif

#else

#define VCWD_GETCWD(buff, size) getcwd(buff, size)
#define VCWD_FOPEN(path, mode)  fopen(path, mode)
#define VCWD_OPEN(path, flags) open(path, flags)
#define VCWD_OPEN_MODE(path, flags, mode)	open(path, flags, mode)
#define VCWD_CREAT(path, mode) creat(path, mode)
/* rename on windows will fail if newname already exists.
   MoveFileEx has to be used */
#if defined(TSRM_WIN32)
# define VCWD_RENAME(oldname, newname) (MoveFileEx(oldname, newname, MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED) == 0 ? -1 : 0)
#else
# define VCWD_RENAME(oldname, newname) rename(oldname, newname)
#endif
#define VCWD_CHDIR(path) chdir(path)
#define VCWD_CHDIR_FILE(path) virtual_chdir_file(path, chdir)
#define VCWD_GETWD(buf) getwd(buf)
#define VCWD_STAT(path, buff) php_sys_stat(path, buff)
#define VCWD_LSTAT(path, buff) lstat(path, buff)
#define VCWD_UNLINK(path) unlink(path)
#define VCWD_MKDIR(pathname, mode) mkdir(pathname, mode)
#define VCWD_RMDIR(pathname) rmdir(pathname)
#define VCWD_OPENDIR(pathname) opendir(pathname)
#define VCWD_POPEN(command, type) popen(command, type)
#if defined(TSRM_WIN32)
#define VCWD_ACCESS(pathname, mode) tsrm_win32_access(pathname, mode TSRMLS_CC)
#else
#define VCWD_ACCESS(pathname, mode) access(pathname, mode)
#endif

#define VCWD_REALPATH(path, real_path) tsrm_realpath(path, real_path TSRMLS_CC)

#if HAVE_UTIME
# ifdef TSRM_WIN32
#  define VCWD_UTIME(path, time) win32_utime(path, time)
# else
#  define VCWD_UTIME(path, time) utime(path, time)
# endif
#endif

#define VCWD_CHMOD(path, mode) chmod(path, mode)
#if !defined(TSRM_WIN32) && !defined(NETWARE)
#define VCWD_CHOWN(path, owner, group) chown(path, owner, group)
#if HAVE_LCHOWN
#define VCWD_LCHOWN(path, owner, group) lchown(path, owner, group)
#endif
#endif

#endif

#endif /* VIRTUAL_CWD_H */
                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/TSRM/tsrm_win32.h                               0100644 0001750 0001750 00000006221 12566220071 023316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
   | Copyright (c) 1997-2015 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   | Authors: Daniel Beulshausen <daniel@php4win.de>                      |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef TSRM_WIN32_H
#define TSRM_WIN32_H

#include "TSRM.h"
#include <windows.h>

struct ipc_perm {
	int			key;
	unsigned short	uid;
	unsigned short	gid;
	unsigned short	cuid;
	unsigned short	cgid;
	unsigned short	mode;
	unsigned short	seq;
};

struct shmid_ds {
	struct	ipc_perm	shm_perm;
	int				shm_segsz;
	time_t			shm_atime;
	time_t			shm_dtime;
	time_t			shm_ctime;
	unsigned short	shm_cpid;
	unsigned short	shm_lpid;
	short			shm_nattch;
};

typedef struct {
	FILE	*stream;
	HANDLE	prochnd;
} process_pair;

typedef struct {
	void	*addr;
	HANDLE	info;
	HANDLE	segment;
	struct	shmid_ds	*descriptor;
} shm_pair;

typedef struct {
	process_pair	*process;
	shm_pair		*shm;
	int				process_size;
	int				shm_size;
	char			*comspec;
	HANDLE impersonation_token;
	PSID			impersonation_token_sid;
} tsrm_win32_globals;

#ifdef ZTS
# define TWG(v) TSRMG(win32_globals_id, tsrm_win32_globals *, v)
#else
# define TWG(v) (win32_globals.v)
#endif

#define IPC_PRIVATE	0
#define IPC_CREAT	00001000
#define IPC_EXCL	00002000
#define IPC_NOWAIT	00004000

#define IPC_RMID	0
#define IPC_SET		1
#define IPC_STAT	2
#define IPC_INFO	3

#define SHM_R		PAGE_READONLY
#define SHM_W		PAGE_READWRITE

#define	SHM_RDONLY	FILE_MAP_READ
#define	SHM_RND		FILE_MAP_WRITE
#define	SHM_REMAP	FILE_MAP_COPY

char * tsrm_win32_get_path_sid_key(const char *pathname  TSRMLS_DC);

TSRM_API void tsrm_win32_startup(void);
TSRM_API void tsrm_win32_shutdown(void);

TSRM_API FILE *popen_ex(const char *command, const char *type, const char *cwd, char *env TSRMLS_DC);
TSRM_API FILE *popen(const char *command, const char *type);
TSRM_API int pclose(FILE *stream);
TSRM_API int tsrm_win32_access(const char *pathname, int mode TSRMLS_DC);
TSRM_API int win32_utime(const char *filename, struct utimbuf *buf);

TSRM_API int shmget(int key, int size, int flags);
TSRM_API void *shmat(int key, const void *shmaddr, int flags);
TSRM_API int shmdt(const void *shmaddr);
TSRM_API int shmctl(int key, int cmd, struct shmid_ds *buf);

TSRM_API char *realpath(char *orig_path, char *buffer);
#endif
                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/                                           0040755 0001750 0001750 00000000000 12612224753 021256  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend.h                                     0100644 0001750 0001750 00000064055 12566220066 022377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_H
#define ZEND_H

#define ZEND_VERSION "2.5.0"

#define ZEND_ENGINE_2

#ifdef __cplusplus
#define BEGIN_EXTERN_C() extern "C" {
#define END_EXTERN_C() }
#else
#define BEGIN_EXTERN_C()
#define END_EXTERN_C()
#endif

/*
 * general definitions
 */

#ifdef ZEND_WIN32
# include "zend_config.w32.h"
# define ZEND_PATHS_SEPARATOR		';'
#elif defined(NETWARE)
# include <zend_config.h>
# define ZEND_PATHS_SEPARATOR		';'
#elif defined(__riscos__)
# include <zend_config.h>
# define ZEND_PATHS_SEPARATOR		';'
#else
# include <zend_config.h>
# define ZEND_PATHS_SEPARATOR		':'
#endif

#ifdef ZEND_WIN32
/* Only use this macro if you know for sure that all of the switches values
   are covered by its case statements */
#define EMPTY_SWITCH_DEFAULT_CASE() \
			default:				\
				__assume(0);		\
				break;
#else
#define EMPTY_SWITCH_DEFAULT_CASE()
#endif

/* all HAVE_XXX test have to be after the include of zend_config above */

#include <stdio.h>

#ifdef HAVE_UNIX_H
# include <unix.h>
#endif

#ifdef HAVE_STDARG_H
# include <stdarg.h>
#endif

#ifdef HAVE_DLFCN_H
# include <dlfcn.h>
#endif

#if defined(HAVE_LIBDL) && !defined(ZEND_WIN32)

# ifndef RTLD_LAZY
#  define RTLD_LAZY 1    /* Solaris 1, FreeBSD's (2.1.7.1 and older) */
# endif

# ifndef RTLD_GLOBAL
#  define RTLD_GLOBAL 0
# endif

# if defined(RTLD_GROUP) && defined(RTLD_WORLD) && defined(RTLD_PARENT)
#  define DL_LOAD(libname)			dlopen(libname, RTLD_LAZY | RTLD_GLOBAL | RTLD_GROUP | RTLD_WORLD | RTLD_PARENT)
# elif defined(RTLD_DEEPBIND)
#  define DL_LOAD(libname)			dlopen(libname, RTLD_LAZY | RTLD_GLOBAL | RTLD_DEEPBIND)
# else
#  define DL_LOAD(libname)			dlopen(libname, RTLD_LAZY | RTLD_GLOBAL)
# endif
# define DL_UNLOAD					dlclose
# if defined(DLSYM_NEEDS_UNDERSCORE)
#  define DL_FETCH_SYMBOL(h,s)		dlsym((h), "_" s)
# else
#  define DL_FETCH_SYMBOL			dlsym
# endif
# define DL_ERROR					dlerror
# define DL_HANDLE					void *
# define ZEND_EXTENSIONS_SUPPORT	1
#elif defined(ZEND_WIN32)
# define DL_LOAD(libname)			LoadLibrary(libname)
# define DL_FETCH_SYMBOL			GetProcAddress
# define DL_UNLOAD					FreeLibrary
# define DL_HANDLE					HMODULE
# define ZEND_EXTENSIONS_SUPPORT	1
#else
# define DL_HANDLE					void *
# define ZEND_EXTENSIONS_SUPPORT	0
#endif

#if HAVE_ALLOCA_H && !defined(_ALLOCA_H)
#  include <alloca.h>
#endif

/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifndef HAVE_ALLOCA_H
#  ifdef _AIX
#pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
char *alloca ();
#   endif
#  endif
# endif
#endif

/* Compatibility with non-clang compilers */
#ifndef __has_attribute
# define __has_attribute(x) 0
#endif

/* GCC x.y.z supplies __GNUC__ = x and __GNUC_MINOR__ = y */
#ifdef __GNUC__
# define ZEND_GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
#else
# define ZEND_GCC_VERSION 0
#endif

#if ZEND_GCC_VERSION >= 2096
# define ZEND_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
#else
# define ZEND_ATTRIBUTE_MALLOC
#endif

#if ZEND_GCC_VERSION >= 4003 || __has_attribute(alloc_size)
# define ZEND_ATTRIBUTE_ALLOC_SIZE(X) __attribute__ ((alloc_size(X)))
# define ZEND_ATTRIBUTE_ALLOC_SIZE2(X,Y) __attribute__ ((alloc_size(X,Y)))
#else
# define ZEND_ATTRIBUTE_ALLOC_SIZE(X)
# define ZEND_ATTRIBUTE_ALLOC_SIZE2(X,Y)
#endif

#if ZEND_GCC_VERSION >= 2007
# define ZEND_ATTRIBUTE_FORMAT(type, idx, first) __attribute__ ((format(type, idx, first)))
#else
# define ZEND_ATTRIBUTE_FORMAT(type, idx, first)
#endif

#if ZEND_GCC_VERSION >= 3001 && !defined(__INTEL_COMPILER)
# define ZEND_ATTRIBUTE_PTR_FORMAT(type, idx, first) __attribute__ ((format(type, idx, first)))
#else
# define ZEND_ATTRIBUTE_PTR_FORMAT(type, idx, first)
#endif

#if ZEND_GCC_VERSION >= 3001
# define ZEND_ATTRIBUTE_DEPRECATED  __attribute__((deprecated))
#elif defined(ZEND_WIN32) && defined(_MSC_VER) && _MSC_VER >= 1300
# define ZEND_ATTRIBUTE_DEPRECATED  __declspec(deprecated)
#else
# define ZEND_ATTRIBUTE_DEPRECATED
#endif

#if defined(__GNUC__) && ZEND_GCC_VERSION >= 3004 && defined(__i386__)
# define ZEND_FASTCALL __attribute__((fastcall))
#elif defined(_MSC_VER) && defined(_M_IX86)
# define ZEND_FASTCALL __fastcall
#else
# define ZEND_FASTCALL
#endif

#if defined(__GNUC__) && ZEND_GCC_VERSION >= 3004
#else
# define __restrict__
#endif
#define restrict __restrict__

#if (HAVE_ALLOCA || (defined (__GNUC__) && __GNUC__ >= 2)) && !(defined(ZTS) && defined(ZEND_WIN32)) && !(defined(ZTS) && defined(NETWARE)) && !(defined(ZTS) && defined(HPUX)) && !defined(DARWIN)
# define ZEND_ALLOCA_MAX_SIZE (32 * 1024)
# define ALLOCA_FLAG(name) \
	zend_bool name;
# define SET_ALLOCA_FLAG(name) \
	name = 1
# define do_alloca_ex(size, limit, use_heap) \
	((use_heap = (UNEXPECTED((size) > (limit)))) ? emalloc(size) : alloca(size))
# define do_alloca(size, use_heap) \
	do_alloca_ex(size, ZEND_ALLOCA_MAX_SIZE, use_heap)
# define free_alloca(p, use_heap) \
	do { if (UNEXPECTED(use_heap)) efree(p); } while (0)
#else
# define ALLOCA_FLAG(name)
# define SET_ALLOCA_FLAG(name)
# define do_alloca(p, use_heap)		emalloc(p)
# define free_alloca(p, use_heap)	efree(p)
#endif

#if ZEND_DEBUG
#define ZEND_FILE_LINE_D				const char *__zend_filename, const uint __zend_lineno
#define ZEND_FILE_LINE_DC				, ZEND_FILE_LINE_D
#define ZEND_FILE_LINE_ORIG_D			const char *__zend_orig_filename, const uint __zend_orig_lineno
#define ZEND_FILE_LINE_ORIG_DC			, ZEND_FILE_LINE_ORIG_D
#define ZEND_FILE_LINE_RELAY_C			__zend_filename, __zend_lineno
#define ZEND_FILE_LINE_RELAY_CC			, ZEND_FILE_LINE_RELAY_C
#define ZEND_FILE_LINE_C				__FILE__, __LINE__
#define ZEND_FILE_LINE_CC				, ZEND_FILE_LINE_C
#define ZEND_FILE_LINE_EMPTY_C			NULL, 0
#define ZEND_FILE_LINE_EMPTY_CC			, ZEND_FILE_LINE_EMPTY_C
#define ZEND_FILE_LINE_ORIG_RELAY_C		__zend_orig_filename, __zend_orig_lineno
#define ZEND_FILE_LINE_ORIG_RELAY_CC	, ZEND_FILE_LINE_ORIG_RELAY_C
#define ZEND_ASSERT(c)					assert(c)
#else
#define ZEND_FILE_LINE_D
#define ZEND_FILE_LINE_DC
#define ZEND_FILE_LINE_ORIG_D
#define ZEND_FILE_LINE_ORIG_DC
#define ZEND_FILE_LINE_RELAY_C
#define ZEND_FILE_LINE_RELAY_CC
#define ZEND_FILE_LINE_C
#define ZEND_FILE_LINE_CC
#define ZEND_FILE_LINE_EMPTY_C
#define ZEND_FILE_LINE_EMPTY_CC
#define ZEND_FILE_LINE_ORIG_RELAY_C
#define ZEND_FILE_LINE_ORIG_RELAY_CC
#define ZEND_ASSERT(c)
#endif	/* ZEND_DEBUG */

#ifdef ZTS
#define ZTS_V 1
#else
#define ZTS_V 0
#endif

#include "zend_errors.h"
#include "zend_alloc.h"

#include "zend_types.h"
#include "zend_string.h"

#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif

#ifndef LONG_MAX
#define LONG_MAX 2147483647L
#endif

#ifndef LONG_MIN
#define LONG_MIN (- LONG_MAX - 1)
#endif

#if SIZEOF_LONG == 4
#define MAX_LENGTH_OF_LONG 11
static const char long_min_digits[] = "2147483648";
#elif SIZEOF_LONG == 8
#define MAX_LENGTH_OF_LONG 20
static const char long_min_digits[] = "9223372036854775808";
#else
#error "Unknown SIZEOF_LONG"
#endif

#define MAX_LENGTH_OF_DOUBLE 32

typedef enum {
  SUCCESS =  0,
  FAILURE = -1,		/* this MUST stay a negative number, or it may affect functions! */
} ZEND_RESULT_CODE;

#include "zend_hash.h"
#include "zend_ts_hash.h"
#include "zend_llist.h"

#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC
#define INTERNAL_FUNCTION_PARAM_PASSTHRU ht, return_value, return_value_ptr, this_ptr, return_value_used TSRMLS_CC

#if defined(__GNUC__) && __GNUC__ >= 3 && !defined(__INTEL_COMPILER) && !defined(DARWIN) && !defined(__hpux) && !defined(_AIX) && !defined(__osf__)
void zend_error_noreturn(int type, const char *format, ...) __attribute__ ((noreturn));
#else
#  define zend_error_noreturn zend_error
#endif

/*
 * zval
 */
typedef struct _zend_class_entry zend_class_entry;

typedef struct _zend_guard {
	zend_bool in_get;
	zend_bool in_set;
	zend_bool in_unset;
	zend_bool in_isset;
	zend_bool dummy; /* sizeof(zend_guard) must not be equal to sizeof(void*) */
} zend_guard;

typedef struct _zend_object {
	zend_class_entry *ce;
	HashTable *properties;
	zval **properties_table;
	HashTable *guards; /* protects from __get/__set ... recursion */
} zend_object;

#include "zend_object_handlers.h"

typedef union _zvalue_value {
	long lval;					/* long value */
	double dval;				/* double value */
	struct {
		char *val;
		int len;
	} str;
	HashTable *ht;				/* hash table value */
	zend_object_value obj;
} zvalue_value;

struct _zval_struct {
	/* Variable information */
	zvalue_value value;		/* value */
	zend_uint refcount__gc;
	zend_uchar type;	/* active type */
	zend_uchar is_ref__gc;
};

#define Z_REFCOUNT_PP(ppz)		Z_REFCOUNT_P(*(ppz))
#define Z_SET_REFCOUNT_PP(ppz, rc)	Z_SET_REFCOUNT_P(*(ppz), rc)
#define Z_ADDREF_PP(ppz)		Z_ADDREF_P(*(ppz))
#define Z_DELREF_PP(ppz)		Z_DELREF_P(*(ppz))
#define Z_ISREF_PP(ppz)			Z_ISREF_P(*(ppz))
#define Z_SET_ISREF_PP(ppz)		Z_SET_ISREF_P(*(ppz))
#define Z_UNSET_ISREF_PP(ppz)		Z_UNSET_ISREF_P(*(ppz))
#define Z_SET_ISREF_TO_PP(ppz, isref)	Z_SET_ISREF_TO_P(*(ppz), isref)

#define Z_REFCOUNT_P(pz)		zval_refcount_p(pz)
#define Z_SET_REFCOUNT_P(pz, rc)	zval_set_refcount_p(pz, rc)
#define Z_ADDREF_P(pz)			zval_addref_p(pz)
#define Z_DELREF_P(pz)			zval_delref_p(pz)
#define Z_ISREF_P(pz)			zval_isref_p(pz)
#define Z_SET_ISREF_P(pz)		zval_set_isref_p(pz)
#define Z_UNSET_ISREF_P(pz)		zval_unset_isref_p(pz)
#define Z_SET_ISREF_TO_P(pz, isref)	zval_set_isref_to_p(pz, isref)

#define Z_REFCOUNT(z)			Z_REFCOUNT_P(&(z))
#define Z_SET_REFCOUNT(z, rc)		Z_SET_REFCOUNT_P(&(z), rc)
#define Z_ADDREF(z)			Z_ADDREF_P(&(z))
#define Z_DELREF(z)			Z_DELREF_P(&(z))
#define Z_ISREF(z)			Z_ISREF_P(&(z))
#define Z_SET_ISREF(z)			Z_SET_ISREF_P(&(z))
#define Z_UNSET_ISREF(z)		Z_UNSET_ISREF_P(&(z))
#define Z_SET_ISREF_TO(z, isref)	Z_SET_ISREF_TO_P(&(z), isref)

#if ZEND_DEBUG
#define zend_always_inline inline
#define zend_never_inline
#else
#if defined(__GNUC__)
#if __GNUC__ >= 3
#define zend_always_inline inline __attribute__((always_inline))
#define zend_never_inline __attribute__((noinline))
#else
#define zend_always_inline inline
#define zend_never_inline
#endif
#elif defined(_MSC_VER)
#define zend_always_inline __forceinline
#define zend_never_inline
#else
#define zend_always_inline inline
#define zend_never_inline
#endif
#endif /* ZEND_DEBUG */

#if (defined (__GNUC__) && __GNUC__ > 2 ) && !defined(DARWIN) && !defined(__hpux) && !defined(_AIX)
# define EXPECTED(condition)   __builtin_expect(condition, 1)
# define UNEXPECTED(condition) __builtin_expect(condition, 0)
#else
# define EXPECTED(condition)   (condition)
# define UNEXPECTED(condition) (condition)
#endif

static zend_always_inline zend_uint zval_refcount_p(zval* pz) {
	return pz->refcount__gc;
}

static zend_always_inline zend_uint zval_set_refcount_p(zval* pz, zend_uint rc) {
	return pz->refcount__gc = rc;
}

static zend_always_inline zend_uint zval_addref_p(zval* pz) {
	return ++pz->refcount__gc;
}

static zend_always_inline zend_uint zval_delref_p(zval* pz) {
	return --pz->refcount__gc;
}

static zend_always_inline zend_bool zval_isref_p(zval* pz) {
	return pz->is_ref__gc;
}

static zend_always_inline zend_bool zval_set_isref_p(zval* pz) {
	return pz->is_ref__gc = 1;
}

static zend_always_inline zend_bool zval_unset_isref_p(zval* pz) {
	return pz->is_ref__gc = 0;
}

static zend_always_inline zend_bool zval_set_isref_to_p(zval* pz, zend_bool isref) {
	return pz->is_ref__gc = isref;
}

/* excpt.h on Digital Unix 4.0 defines function_table */
#undef function_table

/* A lot of stuff needs shifiting around in order to include zend_compile.h here */
union _zend_function;

#include "zend_iterators.h"

struct _zend_serialize_data;
struct _zend_unserialize_data;

typedef struct _zend_serialize_data zend_serialize_data;
typedef struct _zend_unserialize_data zend_unserialize_data;

struct _zend_trait_method_reference {
	const char* method_name;
	unsigned int mname_len;
	
	zend_class_entry *ce;
	
	const char* class_name;
	unsigned int cname_len;
};
typedef struct _zend_trait_method_reference	zend_trait_method_reference;

struct _zend_trait_precedence {
	zend_trait_method_reference *trait_method;
	
	zend_class_entry** exclude_from_classes;
};
typedef struct _zend_trait_precedence zend_trait_precedence;

struct _zend_trait_alias {
	zend_trait_method_reference *trait_method;
	
	/**
	* name for method to be added
	*/
	const char* alias;
	unsigned int alias_len;
	
	/**
	* modifiers to be set on trait method
	*/
	zend_uint modifiers;
};
typedef struct _zend_trait_alias zend_trait_alias;

struct _zend_class_entry {
	char type;
	const char *name;
	zend_uint name_length;
	struct _zend_class_entry *parent;
	int refcount;
	zend_uint ce_flags;

	HashTable function_table;
	HashTable properties_info;
	zval **default_properties_table;
	zval **default_static_members_table;
	zval **static_members_table;
	HashTable constants_table;
	int default_properties_count;
	int default_static_members_count;

	union _zend_function *constructor;
	union _zend_function *destructor;
	union _zend_function *clone;
	union _zend_function *__get;
	union _zend_function *__set;
	union _zend_function *__unset;
	union _zend_function *__isset;
	union _zend_function *__call;
	union _zend_function *__callstatic;
	union _zend_function *__tostring;
	union _zend_function *serialize_func;
	union _zend_function *unserialize_func;

	zend_class_iterator_funcs iterator_funcs;

	/* handlers */
	zend_object_value (*create_object)(zend_class_entry *class_type TSRMLS_DC);
	zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC);
	int (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type TSRMLS_DC); /* a class implements this interface */
	union _zend_function *(*get_static_method)(zend_class_entry *ce, char* method, int method_len TSRMLS_DC);

	/* serializer callbacks */
	int (*serialize)(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data TSRMLS_DC);
	int (*unserialize)(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC);

	zend_class_entry **interfaces;
	zend_uint num_interfaces;
	
	zend_class_entry **traits;
	zend_uint num_traits;
	zend_trait_alias **trait_aliases;
	zend_trait_precedence **trait_precedences;

	union {
		struct {
			const char *filename;
			zend_uint line_start;
			zend_uint line_end;
			const char *doc_comment;
			zend_uint doc_comment_len;
		} user;
		struct {
			const struct _zend_function_entry *builtin_functions;
			struct _zend_module_entry *module;
		} internal;
	} info;
};

#include "zend_stream.h"
typedef struct _zend_utility_functions {
	void (*error_function)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) ZEND_ATTRIBUTE_PTR_FORMAT(printf, 4, 0);
	int (*printf_function)(const char *format, ...) ZEND_ATTRIBUTE_PTR_FORMAT(printf, 1, 2);
	int (*write_function)(const char *str, uint str_length);
	FILE *(*fopen_function)(const char *filename, char **opened_path TSRMLS_DC);
	void (*message_handler)(long message, const void *data TSRMLS_DC);
	void (*block_interruptions)(void);
	void (*unblock_interruptions)(void);
	int (*get_configuration_directive)(const char *name, uint name_length, zval *contents);
	void (*ticks_function)(int ticks);
	void (*on_timeout)(int seconds TSRMLS_DC);
	int (*stream_open_function)(const char *filename, zend_file_handle *handle TSRMLS_DC);
	int (*vspprintf_function)(char **pbuf, size_t max_len, const char *format, va_list ap);
	char *(*getenv_function)(char *name, size_t name_len TSRMLS_DC);
	char *(*resolve_path_function)(const char *filename, int filename_len TSRMLS_DC);
} zend_utility_functions;

typedef struct _zend_utility_values {
	char *import_use_extension;
	uint import_use_extension_length;
	zend_bool html_errors;
} zend_utility_values;

typedef int (*zend_write_func_t)(const char *str, uint str_length);

#undef MIN
#undef MAX
#define MAX(a, b)  (((a)>(b))?(a):(b))
#define MIN(a, b)  (((a)<(b))?(a):(b))
#define ZEND_STRL(str)		(str), (sizeof(str)-1)
#define ZEND_STRS(str)		(str), (sizeof(str))
#define ZEND_NORMALIZE_BOOL(n)			\
	((n) ? (((n)>0) ? 1 : -1) : 0)
#define ZEND_TRUTH(x)		((x) ? 1 : 0)
#define ZEND_LOG_XOR(a, b)		(ZEND_TRUTH(a) ^ ZEND_TRUTH(b))

/* data types */
/* All data types <= IS_BOOL have their constructor/destructors skipped */
#define IS_NULL		0
#define IS_LONG		1
#define IS_DOUBLE	2
#define IS_BOOL		3
#define IS_ARRAY	4
#define IS_OBJECT	5
#define IS_STRING	6
#define IS_RESOURCE	7
#define IS_CONSTANT	8
#define IS_CONSTANT_ARRAY	9
#define IS_CALLABLE	10

/* Ugly hack to support constants as static array indices */
#define IS_CONSTANT_TYPE_MASK		0x00f
#define IS_CONSTANT_UNQUALIFIED		0x010
#define IS_CONSTANT_INDEX			0x080
#define IS_LEXICAL_VAR				0x020
#define IS_LEXICAL_REF				0x040
#define IS_CONSTANT_IN_NAMESPACE	0x100

/* overloaded elements data types */
#define OE_IS_ARRAY		(1<<0)
#define OE_IS_OBJECT	(1<<1)
#define OE_IS_METHOD	(1<<2)

int zend_startup(zend_utility_functions *utility_functions, char **extensions TSRMLS_DC);
void zend_shutdown(TSRMLS_D);
void zend_register_standard_ini_entries(TSRMLS_D);
void zend_post_startup(TSRMLS_D);
void zend_set_utility_values(zend_utility_values *utility_values);

BEGIN_EXTERN_C()
ZEND_API void _zend_bailout(char *filename, uint lineno);
END_EXTERN_C()

#define zend_bailout()		_zend_bailout(__FILE__, __LINE__)

#ifdef HAVE_SIGSETJMP
#	define SETJMP(a) sigsetjmp(a, 0)
#	define LONGJMP(a,b) siglongjmp(a, b)
#	define JMP_BUF sigjmp_buf
#else
#	define SETJMP(a) setjmp(a)
#	define LONGJMP(a,b) longjmp(a, b)
#	define JMP_BUF jmp_buf
#endif

#define zend_try												\
	{															\
		JMP_BUF *__orig_bailout = EG(bailout);					\
		JMP_BUF __bailout;										\
																\
		EG(bailout) = &__bailout;								\
		if (SETJMP(__bailout)==0) {
#define zend_catch												\
		} else {												\
			EG(bailout) = __orig_bailout;
#define zend_end_try()											\
		}														\
		EG(bailout) = __orig_bailout;							\
	}
#define zend_first_try		EG(bailout)=NULL;	zend_try

BEGIN_EXTERN_C()
ZEND_API char *get_zend_version(void);
ZEND_API void zend_make_printable_zval(zval *expr, zval *expr_copy, int *use_copy);
ZEND_API int zend_print_zval(zval *expr, int indent);
ZEND_API int zend_print_zval_ex(zend_write_func_t write_func, zval *expr, int indent);
ZEND_API void zend_print_zval_r(zval *expr, int indent TSRMLS_DC);
ZEND_API void zend_print_flat_zval_r(zval *expr TSRMLS_DC);
ZEND_API void zend_print_zval_r_ex(zend_write_func_t write_func, zval *expr, int indent TSRMLS_DC);
ZEND_API void zend_output_debug_string(zend_bool trigger_break, const char *format, ...) ZEND_ATTRIBUTE_FORMAT(printf, 2, 3);
END_EXTERN_C()

void zend_activate(TSRMLS_D);
void zend_deactivate(TSRMLS_D);
void zend_call_destructors(TSRMLS_D);
void zend_activate_modules(TSRMLS_D);
void zend_deactivate_modules(TSRMLS_D);
void zend_post_deactivate_modules(TSRMLS_D);

#if ZEND_DEBUG
#define Z_DBG(expr)		(expr)
#else
#define	Z_DBG(expr)
#endif

BEGIN_EXTERN_C()
ZEND_API void free_estring(char **str_p);
END_EXTERN_C()

/* FIXME: Check if we can save if (ptr) too */

#define STR_FREE(ptr) if (ptr && !IS_INTERNED(ptr)) { efree(ptr); }
#define STR_FREE_REL(ptr) if (ptr && !IS_INTERNED(ptr)) { efree_rel(ptr); }

#define STR_EMPTY_ALLOC() estrndup("", sizeof("")-1)

#define STR_REALLOC(ptr, size) \
			ptr = (char *) erealloc(ptr, size);

/* output support */
#define ZEND_WRITE(str, str_len)		zend_write((str), (str_len))
#define ZEND_WRITE_EX(str, str_len)		write_func((str), (str_len))
#define ZEND_PUTS(str)					zend_write((str), strlen((str)))
#define ZEND_PUTS_EX(str)				write_func((str), strlen((str)))
#define ZEND_PUTC(c)					zend_write(&(c), 1), (c)

BEGIN_EXTERN_C()
extern ZEND_API int (*zend_printf)(const char *format, ...) ZEND_ATTRIBUTE_PTR_FORMAT(printf, 1, 2);
extern ZEND_API zend_write_func_t zend_write;
extern ZEND_API FILE *(*zend_fopen)(const char *filename, char **opened_path TSRMLS_DC);
extern ZEND_API void (*zend_block_interruptions)(void);
extern ZEND_API void (*zend_unblock_interruptions)(void);
extern ZEND_API void (*zend_ticks_function)(int ticks);
extern ZEND_API void (*zend_error_cb)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) ZEND_ATTRIBUTE_PTR_FORMAT(printf, 4, 0);
extern ZEND_API void (*zend_on_timeout)(int seconds TSRMLS_DC);
extern ZEND_API int (*zend_stream_open_function)(const char *filename, zend_file_handle *handle TSRMLS_DC);
extern int (*zend_vspprintf)(char **pbuf, size_t max_len, const char *format, va_list ap);
extern ZEND_API char *(*zend_getenv)(char *name, size_t name_len TSRMLS_DC);
extern ZEND_API char *(*zend_resolve_path)(const char *filename, int filename_len TSRMLS_DC);

ZEND_API void zend_error(int type, const char *format, ...) ZEND_ATTRIBUTE_FORMAT(printf, 2, 3);

void zenderror(const char *error);

/* The following #define is used for code duality in PHP for Engine 1 & 2 */
#define ZEND_STANDARD_CLASS_DEF_PTR zend_standard_class_def
extern ZEND_API zend_class_entry *zend_standard_class_def;
extern ZEND_API zend_utility_values zend_uv;
extern ZEND_API zval zval_used_for_init;

END_EXTERN_C()

#define ZEND_UV(name) (zend_uv.name)

#ifndef ZEND_SIGNALS
#define HANDLE_BLOCK_INTERRUPTIONS()		if (zend_block_interruptions) { zend_block_interruptions(); }
#define HANDLE_UNBLOCK_INTERRUPTIONS()		if (zend_unblock_interruptions) { zend_unblock_interruptions(); }
#else
#include "zend_signal.h"

#define HANDLE_BLOCK_INTERRUPTIONS()		ZEND_SIGNAL_BLOCK_INTERRUPUTIONS()
#define HANDLE_UNBLOCK_INTERRUPTIONS()		ZEND_SIGNAL_UNBLOCK_INTERRUPTIONS()
#endif

BEGIN_EXTERN_C()
ZEND_API void zend_message_dispatcher(long message, const void *data TSRMLS_DC);

ZEND_API int zend_get_configuration_directive(const char *name, uint name_length, zval *contents);
END_EXTERN_C()

/* Messages for applications of Zend */
#define ZMSG_FAILED_INCLUDE_FOPEN		1L
#define ZMSG_FAILED_REQUIRE_FOPEN		2L
#define ZMSG_FAILED_HIGHLIGHT_FOPEN		3L
#define ZMSG_MEMORY_LEAK_DETECTED		4L
#define ZMSG_MEMORY_LEAK_REPEATED		5L
#define ZMSG_LOG_SCRIPT_NAME			6L
#define ZMSG_MEMORY_LEAKS_GRAND_TOTAL	7L

#define INIT_PZVAL(z)		\
	(z)->refcount__gc = 1;	\
	(z)->is_ref__gc = 0;

#define INIT_ZVAL(z) z = zval_used_for_init;

#define ALLOC_INIT_ZVAL(zp)						\
	ALLOC_ZVAL(zp);		\
	INIT_ZVAL(*zp);

#define MAKE_STD_ZVAL(zv)				 \
	ALLOC_ZVAL(zv); \
	INIT_PZVAL(zv);

#define PZVAL_IS_REF(z)		Z_ISREF_P(z)

#define ZVAL_COPY_VALUE(z, v)					\
	do {										\
		(z)->value = (v)->value;				\
		Z_TYPE_P(z) = Z_TYPE_P(v);				\
	} while (0)

#define INIT_PZVAL_COPY(z, v)					\
	do {										\
		ZVAL_COPY_VALUE(z, v);					\
		Z_SET_REFCOUNT_P(z, 1);					\
		Z_UNSET_ISREF_P(z);						\
	} while (0)

#define SEPARATE_ZVAL(ppzv)						\
	do {										\
		if (Z_REFCOUNT_PP((ppzv)) > 1) {		\
			zval *new_zv;						\
			Z_DELREF_PP(ppzv);					\
			ALLOC_ZVAL(new_zv);					\
			INIT_PZVAL_COPY(new_zv, *(ppzv));	\
			*(ppzv) = new_zv;					\
			zval_copy_ctor(new_zv);				\
		}										\
	} while (0)

#define SEPARATE_ZVAL_IF_NOT_REF(ppzv)		\
	if (!PZVAL_IS_REF(*ppzv)) {				\
		SEPARATE_ZVAL(ppzv);				\
	}

#define SEPARATE_ZVAL_TO_MAKE_IS_REF(ppzv)	\
	if (!PZVAL_IS_REF(*ppzv)) {				\
		SEPARATE_ZVAL(ppzv);				\
		Z_SET_ISREF_PP((ppzv));				\
	}

#define COPY_PZVAL_TO_ZVAL(zv, pzv)			\
	(zv) = *(pzv);							\
	if (Z_REFCOUNT_P(pzv)>1) {				\
		zval_copy_ctor(&(zv));				\
		Z_DELREF_P((pzv));					\
	} else {								\
		FREE_ZVAL(pzv);						\
	}										\
	INIT_PZVAL(&(zv));
	
#define MAKE_COPY_ZVAL(ppzv, pzv) 	\
	INIT_PZVAL_COPY(pzv, *(ppzv));	\
	zval_copy_ctor((pzv));

#define REPLACE_ZVAL_VALUE(ppzv_dest, pzv_src, copy) {	\
	int is_ref, refcount;						\
												\
	SEPARATE_ZVAL_IF_NOT_REF(ppzv_dest);		\
	is_ref = Z_ISREF_PP(ppzv_dest);				\
	refcount = Z_REFCOUNT_PP(ppzv_dest);		\
	zval_dtor(*ppzv_dest);						\
	ZVAL_COPY_VALUE(*ppzv_dest, pzv_src);		\
	if (copy) {                                 \
		zval_copy_ctor(*ppzv_dest);				\
    }		                                    \
	Z_SET_ISREF_TO_PP(ppzv_dest, is_ref);		\
	Z_SET_REFCOUNT_PP(ppzv_dest, refcount);		\
}

#define SEPARATE_ARG_IF_REF(varptr) \
	if (PZVAL_IS_REF(varptr)) { \
		zval *original_var = varptr; \
		ALLOC_ZVAL(varptr); \
		INIT_PZVAL_COPY(varptr, original_var); \
		zval_copy_ctor(varptr); \
	} else { \
		Z_ADDREF_P(varptr); \
	}

#define READY_TO_DESTROY(zv) \
	(Z_REFCOUNT_P(zv) == 1 && \
	 (Z_TYPE_P(zv) != IS_OBJECT || \
	  zend_objects_store_get_refcount(zv TSRMLS_CC) == 1))

#define ZEND_MAX_RESERVED_RESOURCES	4

#include "zend_gc.h"
#include "zend_operators.h"
#include "zend_variables.h"

typedef enum {
	EH_NORMAL = 0,
	EH_SUPPRESS,
	EH_THROW
} zend_error_handling_t;

typedef struct {
	zend_error_handling_t  handling;
	zend_class_entry       *exception;
	zval                   *user_handler;
} zend_error_handling;

ZEND_API void zend_save_error_handling(zend_error_handling *current TSRMLS_DC);
ZEND_API void zend_replace_error_handling(zend_error_handling_t error_handling, zend_class_entry *exception_class, zend_error_handling *current TSRMLS_DC);
ZEND_API void zend_restore_error_handling(zend_error_handling *saved TSRMLS_DC);

#define DEBUG_BACKTRACE_PROVIDE_OBJECT (1<<0)
#define DEBUG_BACKTRACE_IGNORE_ARGS    (1<<1)

#endif /* ZEND_H */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_API.h                                 0100644 0001750 0001750 00000117723 12566220066 023071  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   |          Andrei Zmievski <andrei@php.net>                            |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_API_H
#define ZEND_API_H

#include "zend_modules.h"
#include "zend_list.h"
#include "zend_operators.h"
#include "zend_variables.h"
#include "zend_execute.h"


BEGIN_EXTERN_C()

typedef struct _zend_function_entry {
	const char *fname;
	void (*handler)(INTERNAL_FUNCTION_PARAMETERS);
	const struct _zend_arg_info *arg_info;
	zend_uint num_args;
	zend_uint flags;
} zend_function_entry;

typedef struct _zend_fcall_info {
	size_t size;
	HashTable *function_table;
	zval *function_name;
	HashTable *symbol_table;
	zval **retval_ptr_ptr;
	zend_uint param_count;
	zval ***params;
	zval *object_ptr;
	zend_bool no_separation;
} zend_fcall_info;

typedef struct _zend_fcall_info_cache {
	zend_bool initialized;
	zend_function *function_handler;
	zend_class_entry *calling_scope;
	zend_class_entry *called_scope;
	zval *object_ptr;
} zend_fcall_info_cache;

#define ZEND_NS_NAME(ns, name)			ns "\\" name

#define ZEND_FN(name) zif_##name
#define ZEND_MN(name) zim_##name
#define ZEND_NAMED_FUNCTION(name)		void name(INTERNAL_FUNCTION_PARAMETERS)
#define ZEND_FUNCTION(name)				ZEND_NAMED_FUNCTION(ZEND_FN(name))
#define ZEND_METHOD(classname, name)	ZEND_NAMED_FUNCTION(ZEND_MN(classname##_##name))

#define ZEND_FENTRY(zend_name, name, arg_info, flags)	{ #zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags },

#define ZEND_RAW_FENTRY(zend_name, name, arg_info, flags)   { zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags },
#define ZEND_RAW_NAMED_FE(zend_name, name, arg_info) ZEND_RAW_FENTRY(#zend_name, name, arg_info, 0)

#define ZEND_NAMED_FE(zend_name, name, arg_info)	ZEND_FENTRY(zend_name, name, arg_info, 0)
#define ZEND_FE(name, arg_info)						ZEND_FENTRY(name, ZEND_FN(name), arg_info, 0)
#define ZEND_DEP_FE(name, arg_info)                 ZEND_FENTRY(name, ZEND_FN(name), arg_info, ZEND_ACC_DEPRECATED)
#define ZEND_FALIAS(name, alias, arg_info)			ZEND_FENTRY(name, ZEND_FN(alias), arg_info, 0)
#define ZEND_DEP_FALIAS(name, alias, arg_info)		ZEND_FENTRY(name, ZEND_FN(alias), arg_info, ZEND_ACC_DEPRECATED)
#define ZEND_NAMED_ME(zend_name, name, arg_info, flags)	ZEND_FENTRY(zend_name, name, arg_info, flags)
#define ZEND_ME(classname, name, arg_info, flags)	ZEND_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)
#define ZEND_ABSTRACT_ME(classname, name, arg_info)	ZEND_FENTRY(name, NULL, arg_info, ZEND_ACC_PUBLIC|ZEND_ACC_ABSTRACT)
#define ZEND_MALIAS(classname, name, alias, arg_info, flags) \
                                                    ZEND_FENTRY(name, ZEND_MN(classname##_##alias), arg_info, flags)
#define ZEND_ME_MAPPING(name, func_name, arg_types, flags) ZEND_NAMED_ME(name, ZEND_FN(func_name), arg_types, flags)

#define ZEND_NS_FENTRY(ns, zend_name, name, arg_info, flags)		ZEND_RAW_FENTRY(ZEND_NS_NAME(ns, #zend_name), name, arg_info, flags)

#define ZEND_NS_RAW_FENTRY(ns, zend_name, name, arg_info, flags)	ZEND_RAW_FENTRY(ZEND_NS_NAME(ns, zend_name), name, arg_info, flags)
#define ZEND_NS_RAW_NAMED_FE(ns, zend_name, name, arg_info)			ZEND_NS_RAW_FENTRY(ns, #zend_name, name, arg_info, 0)

#define ZEND_NS_NAMED_FE(ns, zend_name, name, arg_info)	ZEND_NS_FENTRY(ns, zend_name, name, arg_info, 0)
#define ZEND_NS_FE(ns, name, arg_info)					ZEND_NS_FENTRY(ns, name, ZEND_FN(name), arg_info, 0)
#define ZEND_NS_DEP_FE(ns, name, arg_info)				ZEND_NS_FENTRY(ns, name, ZEND_FN(name), arg_info, ZEND_ACC_DEPRECATED)
#define ZEND_NS_FALIAS(ns, name, alias, arg_info)		ZEND_NS_FENTRY(ns, name, ZEND_FN(alias), arg_info, 0)
#define ZEND_NS_DEP_FALIAS(ns, name, alias, arg_info)	ZEND_NS_FENTRY(ns, name, ZEND_FN(alias), arg_info, ZEND_ACC_DEPRECATED)

#define ZEND_FE_END            { NULL, NULL, NULL, 0, 0 }

#define ZEND_ARG_INFO(pass_by_ref, name)							{ #name, sizeof(#name)-1, NULL, 0, 0, 0, pass_by_ref},
#define ZEND_ARG_PASS_INFO(pass_by_ref)								{ NULL, 0, NULL, 0, 0, 0, pass_by_ref},
#define ZEND_ARG_OBJ_INFO(pass_by_ref, name, classname, allow_null) { #name, sizeof(#name)-1, #classname, sizeof(#classname)-1, IS_OBJECT, allow_null, pass_by_ref},
#define ZEND_ARG_ARRAY_INFO(pass_by_ref, name, allow_null) { #name, sizeof(#name)-1, NULL, 0, IS_ARRAY, allow_null, pass_by_ref},
#define ZEND_ARG_TYPE_INFO(pass_by_ref, name, type_hint, allow_null) { #name, sizeof(#name)-1, NULL, 0, type_hint, allow_null, pass_by_ref},
#define ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, return_reference, required_num_args)	\
	static const zend_arg_info name[] = {																		\
		{ NULL, 0, NULL, required_num_args, 0, return_reference, pass_rest_by_reference},
#define ZEND_BEGIN_ARG_INFO(name, pass_rest_by_reference)	\
	ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, ZEND_RETURN_VALUE, -1)
#define ZEND_END_ARG_INFO()		};

/* Name macros */
#define ZEND_MODULE_STARTUP_N(module)       zm_startup_##module
#define ZEND_MODULE_SHUTDOWN_N(module)		zm_shutdown_##module
#define ZEND_MODULE_ACTIVATE_N(module)		zm_activate_##module
#define ZEND_MODULE_DEACTIVATE_N(module)	zm_deactivate_##module
#define ZEND_MODULE_POST_ZEND_DEACTIVATE_N(module)	zm_post_zend_deactivate_##module
#define ZEND_MODULE_INFO_N(module)			zm_info_##module
#define ZEND_MODULE_GLOBALS_CTOR_N(module)  zm_globals_ctor_##module
#define ZEND_MODULE_GLOBALS_DTOR_N(module)  zm_globals_dtor_##module

/* Declaration macros */
#define ZEND_MODULE_STARTUP_D(module)		int ZEND_MODULE_STARTUP_N(module)(INIT_FUNC_ARGS)
#define ZEND_MODULE_SHUTDOWN_D(module)		int ZEND_MODULE_SHUTDOWN_N(module)(SHUTDOWN_FUNC_ARGS)
#define ZEND_MODULE_ACTIVATE_D(module)		int ZEND_MODULE_ACTIVATE_N(module)(INIT_FUNC_ARGS)
#define ZEND_MODULE_DEACTIVATE_D(module)	int ZEND_MODULE_DEACTIVATE_N(module)(SHUTDOWN_FUNC_ARGS)
#define ZEND_MODULE_POST_ZEND_DEACTIVATE_D(module)	int ZEND_MODULE_POST_ZEND_DEACTIVATE_N(module)(void)
#define ZEND_MODULE_INFO_D(module)			void ZEND_MODULE_INFO_N(module)(ZEND_MODULE_INFO_FUNC_ARGS)
#define ZEND_MODULE_GLOBALS_CTOR_D(module)  void ZEND_MODULE_GLOBALS_CTOR_N(module)(zend_##module##_globals *module##_globals TSRMLS_DC)
#define ZEND_MODULE_GLOBALS_DTOR_D(module)  void ZEND_MODULE_GLOBALS_DTOR_N(module)(zend_##module##_globals *module##_globals TSRMLS_DC)

#define ZEND_GET_MODULE(name) \
    BEGIN_EXTERN_C()\
	ZEND_DLEXPORT zend_module_entry *get_module(void) { return &name##_module_entry; }\
    END_EXTERN_C()

#define ZEND_BEGIN_MODULE_GLOBALS(module_name)		\
	typedef struct _zend_##module_name##_globals {
#define ZEND_END_MODULE_GLOBALS(module_name)		\
	} zend_##module_name##_globals;

#ifdef ZTS

#define ZEND_DECLARE_MODULE_GLOBALS(module_name)							\
	ts_rsrc_id module_name##_globals_id;
#define ZEND_EXTERN_MODULE_GLOBALS(module_name)								\
	extern ts_rsrc_id module_name##_globals_id;
#define ZEND_INIT_MODULE_GLOBALS(module_name, globals_ctor, globals_dtor)	\
	ts_allocate_id(&module_name##_globals_id, sizeof(zend_##module_name##_globals), (ts_allocate_ctor) globals_ctor, (ts_allocate_dtor) globals_dtor);

#else

#define ZEND_DECLARE_MODULE_GLOBALS(module_name)							\
	zend_##module_name##_globals module_name##_globals;
#define ZEND_EXTERN_MODULE_GLOBALS(module_name)								\
	extern zend_##module_name##_globals module_name##_globals;
#define ZEND_INIT_MODULE_GLOBALS(module_name, globals_ctor, globals_dtor)	\
	globals_ctor(&module_name##_globals);

#endif

#define INIT_CLASS_ENTRY(class_container, class_name, functions) \
	INIT_OVERLOADED_CLASS_ENTRY(class_container, class_name, functions, NULL, NULL, NULL)

#define INIT_CLASS_ENTRY_EX(class_container, class_name, class_name_len, functions) \
	INIT_OVERLOADED_CLASS_ENTRY_EX(class_container, class_name, class_name_len, functions, NULL, NULL, NULL, NULL, NULL)

#define INIT_OVERLOADED_CLASS_ENTRY_EX(class_container, class_name, class_name_len, functions, handle_fcall, handle_propget, handle_propset, handle_propunset, handle_propisset) \
	{															\
		const char *cl_name = class_name;								\
		int _len = class_name_len;								\
		class_container.name = zend_new_interned_string(cl_name, _len+1, 0 TSRMLS_CC);	\
		if (class_container.name == cl_name) {					\
			class_container.name = zend_strndup(cl_name, _len);	\
		}														\
		class_container.name_length = _len;						\
		INIT_CLASS_ENTRY_INIT_METHODS(class_container, functions, handle_fcall, handle_propget, handle_propset, handle_propunset, handle_propisset) \
	}

#define INIT_CLASS_ENTRY_INIT_METHODS(class_container, functions, handle_fcall, handle_propget, handle_propset, handle_propunset, handle_propisset) \
	{															\
		class_container.constructor = NULL;						\
		class_container.destructor = NULL;						\
		class_container.clone = NULL;							\
		class_container.serialize = NULL;						\
		class_container.unserialize = NULL;						\
		class_container.create_object = NULL;					\
		class_container.interface_gets_implemented = NULL;		\
		class_container.get_static_method = NULL;				\
		class_container.__call = handle_fcall;					\
		class_container.__callstatic = NULL;					\
		class_container.__tostring = NULL;						\
		class_container.__get = handle_propget;					\
		class_container.__set = handle_propset;					\
		class_container.__unset = handle_propunset;				\
		class_container.__isset = handle_propisset;				\
		class_container.serialize_func = NULL;					\
		class_container.unserialize_func = NULL;				\
		class_container.serialize = NULL;						\
		class_container.unserialize = NULL;						\
		class_container.parent = NULL;							\
		class_container.num_interfaces = 0;						\
		class_container.traits = NULL;							\
		class_container.num_traits = 0;							\
		class_container.trait_aliases = NULL;					\
		class_container.trait_precedences = NULL;				\
		class_container.interfaces = NULL;						\
		class_container.get_iterator = NULL;					\
		class_container.iterator_funcs.funcs = NULL;			\
		class_container.info.internal.module = NULL;			\
		class_container.info.internal.builtin_functions = functions;	\
	}

#define INIT_OVERLOADED_CLASS_ENTRY(class_container, class_name, functions, handle_fcall, handle_propget, handle_propset) \
	INIT_OVERLOADED_CLASS_ENTRY_EX(class_container, class_name, sizeof(class_name)-1, functions, handle_fcall, handle_propget, handle_propset, NULL, NULL)

#define INIT_NS_CLASS_ENTRY(class_container, ns, class_name, functions) \
	INIT_CLASS_ENTRY(class_container, ZEND_NS_NAME(ns, class_name), functions)
#define INIT_OVERLOADED_NS_CLASS_ENTRY_EX(class_container, ns, class_name, functions, handle_fcall, handle_propget, handle_propset, handle_propunset, handle_propisset) \
	INIT_OVERLOADED_CLASS_ENTRY_EX(class_container, ZEND_NS_NAME(ns, class_name), sizeof(ZEND_NS_NAME(ns, class_name))-1, functions, handle_fcall, handle_propget, handle_propset, handle_propunset, handle_propisset)
#define INIT_OVERLOADED_NS_CLASS_ENTRY(class_container, ns, class_name, functions, handle_fcall, handle_propget, handle_propset) \
	INIT_OVERLOADED_CLASS_ENTRY(class_container, ZEND_NS_NAME(ns, class_name), functions, handle_fcall, handle_propget, handle_propset)

#ifdef ZTS
#	define CE_STATIC_MEMBERS(ce) (((ce)->type==ZEND_USER_CLASS)?(ce)->static_members_table:CG(static_members_table)[(zend_intptr_t)(ce)->static_members_table])
#else
#	define CE_STATIC_MEMBERS(ce) ((ce)->static_members_table)
#endif

#define ZEND_FCI_INITIALIZED(fci) ((fci).size != 0)

int zend_next_free_module(void);

BEGIN_EXTERN_C()
ZEND_API int zend_get_parameters(int ht, int param_count, ...);
ZEND_API int _zend_get_parameters_array(int ht, int param_count, zval **argument_array TSRMLS_DC);
ZEND_API ZEND_ATTRIBUTE_DEPRECATED int zend_get_parameters_ex(int param_count, ...);
ZEND_API int _zend_get_parameters_array_ex(int param_count, zval ***argument_array TSRMLS_DC);

/* internal function to efficiently copy parameters when executing __call() */
ZEND_API int zend_copy_parameters_array(int param_count, zval *argument_array TSRMLS_DC);

#define zend_get_parameters_array(ht, param_count, argument_array)			\
	_zend_get_parameters_array(ht, param_count, argument_array TSRMLS_CC)
#define zend_get_parameters_array_ex(param_count, argument_array)			\
	_zend_get_parameters_array_ex(param_count, argument_array TSRMLS_CC)
#define zend_parse_parameters_none()										\
	zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "")

/* Parameter parsing API -- andrei */

#define ZEND_PARSE_PARAMS_QUIET 1<<1
ZEND_API int zend_parse_parameters(int num_args TSRMLS_DC, const char *type_spec, ...);
ZEND_API int zend_parse_parameters_ex(int flags, int num_args TSRMLS_DC, const char *type_spec, ...);
ZEND_API char *zend_zval_type_name(const zval *arg);

ZEND_API int zend_parse_method_parameters(int num_args TSRMLS_DC, zval *this_ptr, const char *type_spec, ...);
ZEND_API int zend_parse_method_parameters_ex(int flags, int num_args TSRMLS_DC, zval *this_ptr, const char *type_spec, ...);

ZEND_API int zend_parse_parameter(int flags, int arg_num TSRMLS_DC, zval **arg, const char *spec, ...);

/* End of parameter parsing API -- andrei */

ZEND_API int zend_register_functions(zend_class_entry *scope, const zend_function_entry *functions, HashTable *function_table, int type TSRMLS_DC);
ZEND_API void zend_unregister_functions(const zend_function_entry *functions, int count, HashTable *function_table TSRMLS_DC);
ZEND_API int zend_startup_module(zend_module_entry *module_entry);
ZEND_API zend_module_entry* zend_register_internal_module(zend_module_entry *module_entry TSRMLS_DC);
ZEND_API zend_module_entry* zend_register_module_ex(zend_module_entry *module TSRMLS_DC);
ZEND_API int zend_startup_module_ex(zend_module_entry *module TSRMLS_DC);
ZEND_API int zend_startup_modules(TSRMLS_D);
ZEND_API void zend_collect_module_handlers(TSRMLS_D);
ZEND_API void zend_destroy_modules(void);
ZEND_API void zend_check_magic_method_implementation(const zend_class_entry *ce, const zend_function *fptr, int error_type TSRMLS_DC);

ZEND_API zend_class_entry *zend_register_internal_class(zend_class_entry *class_entry TSRMLS_DC);
ZEND_API zend_class_entry *zend_register_internal_class_ex(zend_class_entry *class_entry, zend_class_entry *parent_ce, char *parent_name TSRMLS_DC);
ZEND_API zend_class_entry *zend_register_internal_interface(zend_class_entry *orig_class_entry TSRMLS_DC);
ZEND_API void zend_class_implements(zend_class_entry *class_entry TSRMLS_DC, int num_interfaces, ...);

ZEND_API int zend_register_class_alias_ex(const char *name, int name_len, zend_class_entry *ce TSRMLS_DC);

#define zend_register_class_alias(name, ce) \
	zend_register_class_alias_ex(name, sizeof(name)-1, ce TSRMLS_CC)
#define zend_register_ns_class_alias(ns, name, ce) \
	zend_register_class_alias_ex(ZEND_NS_NAME(ns, name), sizeof(ZEND_NS_NAME(ns, name))-1, ce TSRMLS_CC)

ZEND_API int zend_disable_function(char *function_name, uint function_name_length TSRMLS_DC);
ZEND_API int zend_disable_class(char *class_name, uint class_name_length TSRMLS_DC);

ZEND_API void zend_wrong_param_count(TSRMLS_D);

#define IS_CALLABLE_CHECK_SYNTAX_ONLY (1<<0)
#define IS_CALLABLE_CHECK_NO_ACCESS   (1<<1)
#define IS_CALLABLE_CHECK_IS_STATIC   (1<<2)
#define IS_CALLABLE_CHECK_SILENT      (1<<3)

#define IS_CALLABLE_STRICT  (IS_CALLABLE_CHECK_IS_STATIC)

ZEND_API zend_bool zend_is_callable_ex(zval *callable, zval *object_ptr, uint check_flags, char **callable_name, int *callable_name_len, zend_fcall_info_cache *fcc, char **error TSRMLS_DC);
ZEND_API zend_bool zend_is_callable(zval *callable, uint check_flags, char **callable_name TSRMLS_DC);
ZEND_API zend_bool zend_make_callable(zval *callable, char **callable_name TSRMLS_DC);
ZEND_API const char *zend_get_module_version(const char *module_name);
ZEND_API int zend_get_module_started(const char *module_name);
ZEND_API int zend_declare_property(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type TSRMLS_DC);
ZEND_API int zend_declare_property_ex(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type, const char *doc_comment, int doc_comment_len TSRMLS_DC);
ZEND_API int zend_declare_property_null(zend_class_entry *ce, const char *name, int name_length, int access_type TSRMLS_DC);
ZEND_API int zend_declare_property_bool(zend_class_entry *ce, const char *name, int name_length, long value, int access_type TSRMLS_DC);
ZEND_API int zend_declare_property_long(zend_class_entry *ce, const char *name, int name_length, long value, int access_type TSRMLS_DC);
ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC);
ZEND_API int zend_declare_property_string(zend_class_entry *ce, const char *name, int name_length, const char *value, int access_type TSRMLS_DC);
ZEND_API int zend_declare_property_stringl(zend_class_entry *ce, const char *name, int name_length, const char *value, int value_len, int access_type TSRMLS_DC);

ZEND_API int zend_declare_class_constant(zend_class_entry *ce, const char *name, size_t name_length, zval *value TSRMLS_DC);
ZEND_API int zend_declare_class_constant_null(zend_class_entry *ce, const char *name, size_t name_length TSRMLS_DC);
ZEND_API int zend_declare_class_constant_long(zend_class_entry *ce, const char *name, size_t name_length, long value TSRMLS_DC);
ZEND_API int zend_declare_class_constant_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_bool value TSRMLS_DC);
ZEND_API int zend_declare_class_constant_double(zend_class_entry *ce, const char *name, size_t name_length, double value TSRMLS_DC);
ZEND_API int zend_declare_class_constant_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_length TSRMLS_DC);
ZEND_API int zend_declare_class_constant_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value TSRMLS_DC);

ZEND_API void zend_update_class_constants(zend_class_entry *class_type TSRMLS_DC);
ZEND_API void zend_update_property(zend_class_entry *scope, zval *object, const char *name, int name_length, zval *value TSRMLS_DC);
ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, int name_length TSRMLS_DC);
ZEND_API void zend_update_property_bool(zend_class_entry *scope, zval *object, const char *name, int name_length, long value TSRMLS_DC);
ZEND_API void zend_update_property_long(zend_class_entry *scope, zval *object, const char *name, int name_length, long value TSRMLS_DC);
ZEND_API void zend_update_property_double(zend_class_entry *scope, zval *object, const char *name, int name_length, double value TSRMLS_DC);
ZEND_API void zend_update_property_string(zend_class_entry *scope, zval *object, const char *name, int name_length, const char *value TSRMLS_DC);
ZEND_API void zend_update_property_stringl(zend_class_entry *scope, zval *object, const char *name, int name_length, const char *value, int value_length TSRMLS_DC);

ZEND_API int zend_update_static_property(zend_class_entry *scope, const char *name, int name_length, zval *value TSRMLS_DC);
ZEND_API int zend_update_static_property_null(zend_class_entry *scope, const char *name, int name_length TSRMLS_DC);
ZEND_API int zend_update_static_property_bool(zend_class_entry *scope, const char *name, int name_length, long value TSRMLS_DC);
ZEND_API int zend_update_static_property_long(zend_class_entry *scope, const char *name, int name_length, long value TSRMLS_DC);
ZEND_API int zend_update_static_property_double(zend_class_entry *scope, const char *name, int name_length, double value TSRMLS_DC);
ZEND_API int zend_update_static_property_string(zend_class_entry *scope, const char *name, int name_length, const char *value TSRMLS_DC);
ZEND_API int zend_update_static_property_stringl(zend_class_entry *scope, const char *name, int name_length, const char *value, int value_length TSRMLS_DC);

ZEND_API zval *zend_read_property(zend_class_entry *scope, zval *object, const char *name, int name_length, zend_bool silent TSRMLS_DC);

ZEND_API zval *zend_read_static_property(zend_class_entry *scope, const char *name, int name_length, zend_bool silent TSRMLS_DC);

ZEND_API zend_class_entry *zend_get_class_entry(const zval *zobject TSRMLS_DC);
ZEND_API int zend_get_object_classname(const zval *object, const char **class_name, zend_uint *class_name_len TSRMLS_DC);
ZEND_API char *zend_get_type_by_const(int type);

#define getThis() (this_ptr)

#define WRONG_PARAM_COUNT					ZEND_WRONG_PARAM_COUNT()
#define WRONG_PARAM_COUNT_WITH_RETVAL(ret)	ZEND_WRONG_PARAM_COUNT_WITH_RETVAL(ret)
#define ARG_COUNT(dummy)	(ht)
#define ZEND_NUM_ARGS()		(ht)
#define ZEND_WRONG_PARAM_COUNT()					{ zend_wrong_param_count(TSRMLS_C); return; }
#define ZEND_WRONG_PARAM_COUNT_WITH_RETVAL(ret)		{ zend_wrong_param_count(TSRMLS_C); return ret; }

#ifndef ZEND_WIN32
#define DLEXPORT
#endif

#define array_init(arg)			_array_init((arg), 0 ZEND_FILE_LINE_CC)
#define array_init_size(arg, size) _array_init((arg), (size) ZEND_FILE_LINE_CC)
#define object_init(arg)		_object_init((arg) ZEND_FILE_LINE_CC TSRMLS_CC)
#define object_init_ex(arg, ce)	_object_init_ex((arg), (ce) ZEND_FILE_LINE_CC TSRMLS_CC)
#define object_and_properties_init(arg, ce, properties)	_object_and_properties_init((arg), (ce), (properties) ZEND_FILE_LINE_CC TSRMLS_CC)
ZEND_API int _array_init(zval *arg, uint size ZEND_FILE_LINE_DC);
ZEND_API int _object_init(zval *arg ZEND_FILE_LINE_DC TSRMLS_DC);
ZEND_API int _object_init_ex(zval *arg, zend_class_entry *ce ZEND_FILE_LINE_DC TSRMLS_DC);
ZEND_API int _object_and_properties_init(zval *arg, zend_class_entry *ce, HashTable *properties ZEND_FILE_LINE_DC TSRMLS_DC);
ZEND_API void object_properties_init(zend_object *object, zend_class_entry *class_type);

ZEND_API void zend_merge_properties(zval *obj, HashTable *properties, int destroy_ht TSRMLS_DC);

/* no longer supported */
ZEND_API int add_assoc_function(zval *arg, const char *key, void (*function_ptr)(INTERNAL_FUNCTION_PARAMETERS));

ZEND_API int add_assoc_long_ex(zval *arg, const char *key, uint key_len, long n);
ZEND_API int add_assoc_null_ex(zval *arg, const char *key, uint key_len);
ZEND_API int add_assoc_bool_ex(zval *arg, const char *key, uint key_len, int b);
ZEND_API int add_assoc_resource_ex(zval *arg, const char *key, uint key_len, int r);
ZEND_API int add_assoc_double_ex(zval *arg, const char *key, uint key_len, double d);
ZEND_API int add_assoc_string_ex(zval *arg, const char *key, uint key_len, char *str, int duplicate);
ZEND_API int add_assoc_stringl_ex(zval *arg, const char *key, uint key_len, char *str, uint length, int duplicate);
ZEND_API int add_assoc_zval_ex(zval *arg, const char *key, uint key_len, zval *value);

#define add_assoc_long(__arg, __key, __n) add_assoc_long_ex(__arg, __key, strlen(__key)+1, __n)
#define add_assoc_null(__arg, __key) add_assoc_null_ex(__arg, __key, strlen(__key) + 1)
#define add_assoc_bool(__arg, __key, __b) add_assoc_bool_ex(__arg, __key, strlen(__key)+1, __b)
#define add_assoc_resource(__arg, __key, __r) add_assoc_resource_ex(__arg, __key, strlen(__key)+1, __r)
#define add_assoc_double(__arg, __key, __d) add_assoc_double_ex(__arg, __key, strlen(__key)+1, __d)
#define add_assoc_string(__arg, __key, __str, __duplicate) add_assoc_string_ex(__arg, __key, strlen(__key)+1, __str, __duplicate)
#define add_assoc_stringl(__arg, __key, __str, __length, __duplicate) add_assoc_stringl_ex(__arg, __key, strlen(__key)+1, __str, __length, __duplicate)
#define add_assoc_zval(__arg, __key, __value) add_assoc_zval_ex(__arg, __key, strlen(__key)+1, __value)

/* unset() functions are only suported for legacy modules and null() functions should be used */
#define add_assoc_unset(__arg, __key) add_assoc_null_ex(__arg, __key, strlen(__key) + 1)
#define add_index_unset(__arg, __key) add_index_null(__arg, __key)
#define add_next_index_unset(__arg) add_next_index_null(__arg)
#define add_property_unset(__arg, __key) add_property_null(__arg, __key)

ZEND_API int add_index_long(zval *arg, ulong idx, long n);
ZEND_API int add_index_null(zval *arg, ulong idx);
ZEND_API int add_index_bool(zval *arg, ulong idx, int b);
ZEND_API int add_index_resource(zval *arg, ulong idx, int r);
ZEND_API int add_index_double(zval *arg, ulong idx, double d);
ZEND_API int add_index_string(zval *arg, ulong idx, const char *str, int duplicate);
ZEND_API int add_index_stringl(zval *arg, ulong idx, const char *str, uint length, int duplicate);
ZEND_API int add_index_zval(zval *arg, ulong index, zval *value);

ZEND_API int add_next_index_long(zval *arg, long n);
ZEND_API int add_next_index_null(zval *arg);
ZEND_API int add_next_index_bool(zval *arg, int b);
ZEND_API int add_next_index_resource(zval *arg, int r);
ZEND_API int add_next_index_double(zval *arg, double d);
ZEND_API int add_next_index_string(zval *arg, const char *str, int duplicate);
ZEND_API int add_next_index_stringl(zval *arg, const char *str, uint length, int duplicate);
ZEND_API int add_next_index_zval(zval *arg, zval *value);

ZEND_API int add_get_assoc_string_ex(zval *arg, const char *key, uint key_len, const char *str, void **dest, int duplicate);
ZEND_API int add_get_assoc_stringl_ex(zval *arg, const char *key, uint key_len, const char *str, uint length, void **dest, int duplicate);

#define add_get_assoc_string(__arg, __key, __str, __dest, __duplicate) add_get_assoc_string_ex(__arg, __key, strlen(__key)+1, __str, __dest, __duplicate)
#define add_get_assoc_stringl(__arg, __key, __str, __length, __dest, __duplicate) add_get_assoc_stringl_ex(__arg, __key, strlen(__key)+1, __str, __length, __dest, __duplicate)

ZEND_API int add_get_index_long(zval *arg, ulong idx, long l, void **dest);
ZEND_API int add_get_index_double(zval *arg, ulong idx, double d, void **dest);
ZEND_API int add_get_index_string(zval *arg, ulong idx, const char *str, void **dest, int duplicate);
ZEND_API int add_get_index_stringl(zval *arg, ulong idx, const char *str, uint length, void **dest, int duplicate);

ZEND_API int array_set_zval_key(HashTable *ht, zval *key, zval *value);

ZEND_API int add_property_long_ex(zval *arg, const char *key, uint key_len, long l TSRMLS_DC);
ZEND_API int add_property_null_ex(zval *arg, const char *key, uint key_len TSRMLS_DC);
ZEND_API int add_property_bool_ex(zval *arg, const char *key, uint key_len, int b TSRMLS_DC);
ZEND_API int add_property_resource_ex(zval *arg, const char *key, uint key_len, long r TSRMLS_DC);
ZEND_API int add_property_double_ex(zval *arg, const char *key, uint key_len, double d TSRMLS_DC);
ZEND_API int add_property_string_ex(zval *arg, const char *key, uint key_len, const char *str, int duplicate TSRMLS_DC);
ZEND_API int add_property_stringl_ex(zval *arg, const char *key, uint key_len,  const char *str, uint length, int duplicate TSRMLS_DC);
ZEND_API int add_property_zval_ex(zval *arg, const char *key, uint key_len, zval *value TSRMLS_DC);

#define add_property_long(__arg, __key, __n) add_property_long_ex(__arg, __key, strlen(__key)+1, __n TSRMLS_CC)
#define add_property_null(__arg, __key) add_property_null_ex(__arg, __key, strlen(__key) + 1 TSRMLS_CC)
#define add_property_bool(__arg, __key, __b) add_property_bool_ex(__arg, __key, strlen(__key)+1, __b TSRMLS_CC)
#define add_property_resource(__arg, __key, __r) add_property_resource_ex(__arg, __key, strlen(__key)+1, __r TSRMLS_CC)
#define add_property_double(__arg, __key, __d) add_property_double_ex(__arg, __key, strlen(__key)+1, __d TSRMLS_CC)
#define add_property_string(__arg, __key, __str, __duplicate) add_property_string_ex(__arg, __key, strlen(__key)+1, __str, __duplicate TSRMLS_CC)
#define add_property_stringl(__arg, __key, __str, __length, __duplicate) add_property_stringl_ex(__arg, __key, strlen(__key)+1, __str, __length, __duplicate TSRMLS_CC)
#define add_property_zval(__arg, __key, __value) add_property_zval_ex(__arg, __key, strlen(__key)+1, __value TSRMLS_CC)       


ZEND_API int call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC);
ZEND_API int call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table TSRMLS_DC);

ZEND_API extern const zend_fcall_info empty_fcall_info;
ZEND_API extern const zend_fcall_info_cache empty_fcall_info_cache;

/** Build zend_call_info/cache from a zval*
 *
 * Caller is responsible to provide a return value, otherwise the we will crash. 
 * fci->retval_ptr_ptr = NULL;
 * In order to pass parameters the following members need to be set:
 * fci->param_count = 0;
 * fci->params = NULL;
 * The callable_name argument may be NULL.
 * Set check_flags to IS_CALLABLE_STRICT for every new usage!
 */
ZEND_API int zend_fcall_info_init(zval *callable, uint check_flags, zend_fcall_info *fci, zend_fcall_info_cache *fcc, char **callable_name, char **error TSRMLS_DC);

/** Clear arguments connected with zend_fcall_info *fci
 * If free_mem is not zero then the params array gets free'd as well
 */
ZEND_API void zend_fcall_info_args_clear(zend_fcall_info *fci, int free_mem);

/** Save current arguments from zend_fcall_info *fci
 * params array will be set to NULL
 */
ZEND_API void zend_fcall_info_args_save(zend_fcall_info *fci, int *param_count, zval ****params);

/** Free arguments connected with zend_fcall_info *fci andset back saved ones.
 */
ZEND_API void zend_fcall_info_args_restore(zend_fcall_info *fci, int param_count, zval ***params);

/** Set or clear the arguments in the zend_call_info struct taking care of
 * refcount. If args is NULL and arguments are set then those are cleared.
 */
ZEND_API int zend_fcall_info_args(zend_fcall_info *fci, zval *args TSRMLS_DC);

/** Set arguments in the zend_fcall_info struct taking care of refcount.
 * If argc is 0 the arguments which are set will be cleared, else pass
 * a variable amount of zval** arguments.
 */
ZEND_API int zend_fcall_info_argp(zend_fcall_info *fci TSRMLS_DC, int argc, zval ***argv);

/** Set arguments in the zend_fcall_info struct taking care of refcount.
 * If argc is 0 the arguments which are set will be cleared, else pass
 * a variable amount of zval** arguments.
 */
ZEND_API int zend_fcall_info_argv(zend_fcall_info *fci TSRMLS_DC, int argc, va_list *argv);

/** Set arguments in the zend_fcall_info struct taking care of refcount.
 * If argc is 0 the arguments which are set will be cleared, else pass
 * a variable amount of zval** arguments.
 */
ZEND_API int zend_fcall_info_argn(zend_fcall_info *fci TSRMLS_DC, int argc, ...);

/** Call a function using information created by zend_fcall_info_init()/args().
 * If args is given then those replace the argument info in fci is temporarily.
 */
ZEND_API int zend_fcall_info_call(zend_fcall_info *fci, zend_fcall_info_cache *fcc, zval **retval, zval *args TSRMLS_DC);

ZEND_API int zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC);

ZEND_API int zend_set_hash_symbol(zval *symbol, const char *name, int name_length, zend_bool is_ref, int num_symbol_tables, ...);

ZEND_API void zend_delete_variable(zend_execute_data *ex, HashTable *ht, const char *name, int name_len, ulong hash_value TSRMLS_DC);

ZEND_API int zend_delete_global_variable(const char *name, int name_len TSRMLS_DC);

ZEND_API int zend_delete_global_variable_ex(const char *name, int name_len, ulong hash_value TSRMLS_DC);

ZEND_API void zend_reset_all_cv(HashTable *symbol_table TSRMLS_DC);

ZEND_API void zend_rebuild_symbol_table(TSRMLS_D);

ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len);
ZEND_API const char* zend_resolve_method_name(zend_class_entry *ce, zend_function *f);

#define add_method(arg, key, method)	add_assoc_function((arg), (key), (method))

ZEND_API ZEND_FUNCTION(display_disabled_function);
ZEND_API ZEND_FUNCTION(display_disabled_class);
END_EXTERN_C()

#if ZEND_DEBUG
#define CHECK_ZVAL_STRING(z) \
	if (Z_STRVAL_P(z)[ Z_STRLEN_P(z) ] != '\0') { zend_error(E_WARNING, "String is not zero-terminated (%s)", Z_STRVAL_P(z)); }
#define CHECK_ZVAL_STRING_REL(z) \
	if (Z_STRVAL_P(z)[ Z_STRLEN_P(z) ] != '\0') { zend_error(E_WARNING, "String is not zero-terminated (%s) (source: %s:%d)", Z_STRVAL_P(z) ZEND_FILE_LINE_RELAY_CC); }
#else
#define CHECK_ZVAL_STRING(z)
#define CHECK_ZVAL_STRING_REL(z)
#endif

#define CHECK_ZVAL_NULL_PATH(p) (Z_STRLEN_P(p) != strlen(Z_STRVAL_P(p)))
#define CHECK_NULL_PATH(p, l) (strlen(p) != l)

#define ZVAL_RESOURCE(z, l) do {	\
		zval *__z = (z);			\
		Z_LVAL_P(__z) = l;			\
		Z_TYPE_P(__z) = IS_RESOURCE;\
	} while (0)

#define ZVAL_BOOL(z, b) do {		\
		zval *__z = (z);			\
		Z_LVAL_P(__z) = ((b) != 0);	\
		Z_TYPE_P(__z) = IS_BOOL;	\
	} while (0)

#define ZVAL_NULL(z) {				\
		Z_TYPE_P(z) = IS_NULL;		\
	}

#define ZVAL_LONG(z, l) {			\
		zval *__z = (z);			\
		Z_LVAL_P(__z) = l;			\
		Z_TYPE_P(__z) = IS_LONG;	\
	}

#define ZVAL_DOUBLE(z, d) {			\
		zval *__z = (z);			\
		Z_DVAL_P(__z) = d;			\
		Z_TYPE_P(__z) = IS_DOUBLE;	\
	}

#define ZVAL_STRING(z, s, duplicate) do {	\
		const char *__s=(s);				\
		zval *__z = (z);					\
		Z_STRLEN_P(__z) = strlen(__s);		\
		Z_STRVAL_P(__z) = (duplicate?estrndup(__s, Z_STRLEN_P(__z)):(char*)__s);\
		Z_TYPE_P(__z) = IS_STRING;			\
	} while (0)

#define ZVAL_STRINGL(z, s, l, duplicate) do {	\
		const char *__s=(s); int __l=l;			\
		zval *__z = (z);						\
		Z_STRLEN_P(__z) = __l;					\
		Z_STRVAL_P(__z) = (duplicate?estrndup(__s, __l):(char*)__s);\
		Z_TYPE_P(__z) = IS_STRING;				\
	} while (0)

#define ZVAL_EMPTY_STRING(z) do {	\
		zval *__z = (z);			\
		Z_STRLEN_P(__z) = 0;		\
		Z_STRVAL_P(__z) = STR_EMPTY_ALLOC();\
		Z_TYPE_P(__z) = IS_STRING;	\
	} while (0)

#define ZVAL_ZVAL(z, zv, copy, dtor) {			\
		zend_uchar is_ref = Z_ISREF_P(z);		\
		zend_uint refcount = Z_REFCOUNT_P(z);	\
		ZVAL_COPY_VALUE(z, zv);					\
		if (copy) {								\
			zval_copy_ctor(z);					\
	    }										\
		if (dtor) {								\
			if (!copy) {						\
				ZVAL_NULL(zv);					\
			}									\
			zval_ptr_dtor(&zv);					\
	    }										\
		Z_SET_ISREF_TO_P(z, is_ref);			\
		Z_SET_REFCOUNT_P(z, refcount);			\
	}

#define ZVAL_FALSE(z)  					ZVAL_BOOL(z, 0)
#define ZVAL_TRUE(z)  					ZVAL_BOOL(z, 1)

#define RETVAL_RESOURCE(l)				ZVAL_RESOURCE(return_value, l)
#define RETVAL_BOOL(b)					ZVAL_BOOL(return_value, b)
#define RETVAL_NULL() 					ZVAL_NULL(return_value)
#define RETVAL_LONG(l) 					ZVAL_LONG(return_value, l)
#define RETVAL_DOUBLE(d) 				ZVAL_DOUBLE(return_value, d)
#define RETVAL_STRING(s, duplicate) 		ZVAL_STRING(return_value, s, duplicate)
#define RETVAL_STRINGL(s, l, duplicate) 	ZVAL_STRINGL(return_value, s, l, duplicate)
#define RETVAL_EMPTY_STRING() 			ZVAL_EMPTY_STRING(return_value)
#define RETVAL_ZVAL(zv, copy, dtor)		ZVAL_ZVAL(return_value, zv, copy, dtor)
#define RETVAL_FALSE  					ZVAL_BOOL(return_value, 0)
#define RETVAL_TRUE   					ZVAL_BOOL(return_value, 1)

#define RETURN_RESOURCE(l) 				{ RETVAL_RESOURCE(l); return; }
#define RETURN_BOOL(b) 					{ RETVAL_BOOL(b); return; }
#define RETURN_NULL() 					{ RETVAL_NULL(); return;}
#define RETURN_LONG(l) 					{ RETVAL_LONG(l); return; }
#define RETURN_DOUBLE(d) 				{ RETVAL_DOUBLE(d); return; }
#define RETURN_STRING(s, duplicate) 	{ RETVAL_STRING(s, duplicate); return; }
#define RETURN_STRINGL(s, l, duplicate) { RETVAL_STRINGL(s, l, duplicate); return; }
#define RETURN_EMPTY_STRING() 			{ RETVAL_EMPTY_STRING(); return; }
#define RETURN_ZVAL(zv, copy, dtor)		{ RETVAL_ZVAL(zv, copy, dtor); return; }
#define RETURN_FALSE  					{ RETVAL_FALSE; return; }
#define RETURN_TRUE   					{ RETVAL_TRUE; return; }

#define SET_VAR_STRING(n, v) {																				\
								{																			\
									zval *var;																\
									ALLOC_ZVAL(var);														\
									ZVAL_STRING(var, v, 0);													\
									ZEND_SET_GLOBAL_VAR(n, var);											\
								}																			\
							}

#define SET_VAR_STRINGL(n, v, l) {														\
									{													\
										zval *var;										\
										ALLOC_ZVAL(var);								\
										ZVAL_STRINGL(var, v, l, 0);						\
										ZEND_SET_GLOBAL_VAR(n, var);					\
									}													\
								}

#define SET_VAR_LONG(n, v)	{															\
								{														\
									zval *var;											\
									ALLOC_ZVAL(var);									\
									ZVAL_LONG(var, v);									\
									ZEND_SET_GLOBAL_VAR(n, var);						\
								}														\
							}

#define SET_VAR_DOUBLE(n, v) {															\
								{														\
									zval *var;											\
									ALLOC_ZVAL(var);									\
									ZVAL_DOUBLE(var, v);								\
									ZEND_SET_GLOBAL_VAR(n, var);						\
								}														\
							}


#define ZEND_SET_SYMBOL(symtable, name, var)										\
	{																				\
		char *_name = (name);														\
																					\
		ZEND_SET_SYMBOL_WITH_LENGTH(symtable, _name, strlen(_name)+1, var, 1, 0);	\
	}

#define ZEND_SET_SYMBOL_WITH_LENGTH(symtable, name, name_length, var, _refcount, _is_ref)				\
	{																									\
		zval **orig_var;																				\
																										\
		if (zend_hash_find(symtable, (name), (name_length), (void **) &orig_var)==SUCCESS				\
			&& PZVAL_IS_REF(*orig_var)) {																\
			Z_SET_REFCOUNT_P(var, Z_REFCOUNT_PP(orig_var));												\
			Z_SET_ISREF_P(var);																			\
																										\
			if (_refcount) {																			\
				Z_SET_REFCOUNT_P(var, Z_REFCOUNT_P(var) + _refcount - 1);								\
			}																							\
			zval_dtor(*orig_var);																		\
			**orig_var = *(var);																		\
			FREE_ZVAL(var);																				\
		} else {																						\
			Z_SET_ISREF_TO_P(var, _is_ref);																\
			if (_refcount) {																			\
				Z_SET_REFCOUNT_P(var, _refcount);														\
			}																							\
			zend_hash_update(symtable, (name), (name_length), &(var), sizeof(zval *), NULL);			\
		}																								\
	}


#define ZEND_SET_GLOBAL_VAR(name, var)				\
	ZEND_SET_SYMBOL(&EG(symbol_table), name, var)

#define ZEND_SET_GLOBAL_VAR_WITH_LENGTH(name, name_length, var, _refcount, _is_ref)	\
	ZEND_SET_SYMBOL_WITH_LENGTH(&EG(symbol_table), name, name_length, var, _refcount, _is_ref)

#define ZEND_DEFINE_PROPERTY(class_ptr, name, value, mask)							\
{																					\
	char *_name = (name);															\
	int namelen = strlen(_name);													\
	zend_declare_property(class_ptr, _name, namelen, value, mask TSRMLS_CC);		\
}

#define HASH_OF(p) (Z_TYPE_P(p)==IS_ARRAY ? Z_ARRVAL_P(p) : ((Z_TYPE_P(p)==IS_OBJECT ? Z_OBJ_HT_P(p)->get_properties((p) TSRMLS_CC) : NULL)))
#define ZVAL_IS_NULL(z) (Z_TYPE_P(z)==IS_NULL)

/* For compatibility */
#define ZEND_MINIT			ZEND_MODULE_STARTUP_N
#define ZEND_MSHUTDOWN		ZEND_MODULE_SHUTDOWN_N
#define ZEND_RINIT			ZEND_MODULE_ACTIVATE_N
#define ZEND_RSHUTDOWN		ZEND_MODULE_DEACTIVATE_N
#define ZEND_MINFO			ZEND_MODULE_INFO_N
#define ZEND_GINIT(module)		((void (*)(void* TSRMLS_DC))(ZEND_MODULE_GLOBALS_CTOR_N(module)))
#define ZEND_GSHUTDOWN(module)	((void (*)(void* TSRMLS_DC))(ZEND_MODULE_GLOBALS_DTOR_N(module)))

#define ZEND_MINIT_FUNCTION			ZEND_MODULE_STARTUP_D
#define ZEND_MSHUTDOWN_FUNCTION		ZEND_MODULE_SHUTDOWN_D
#define ZEND_RINIT_FUNCTION			ZEND_MODULE_ACTIVATE_D
#define ZEND_RSHUTDOWN_FUNCTION		ZEND_MODULE_DEACTIVATE_D
#define ZEND_MINFO_FUNCTION			ZEND_MODULE_INFO_D
#define ZEND_GINIT_FUNCTION			ZEND_MODULE_GLOBALS_CTOR_D
#define ZEND_GSHUTDOWN_FUNCTION		ZEND_MODULE_GLOBALS_DTOR_D

END_EXTERN_C()

#endif /* ZEND_API_H */


/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_alloc.h                               0100644 0001750 0001750 00000027510 12566220066 023544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_ALLOC_H
#define ZEND_ALLOC_H

#include <stdio.h>

#include "../TSRM/TSRM.h"
#include "zend.h"

#ifndef ZEND_MM_ALIGNMENT
# define ZEND_MM_ALIGNMENT 8
# define ZEND_MM_ALIGNMENT_LOG2 3
#elif ZEND_MM_ALIGNMENT < 4
# undef ZEND_MM_ALIGNMENT
# undef ZEND_MM_ALIGNMENT_LOG2
# define ZEND_MM_ALIGNMENT 4
# define ZEND_MM_ALIGNMENT_LOG2 2
#endif

#define ZEND_MM_ALIGNMENT_MASK ~(ZEND_MM_ALIGNMENT-1)

#define ZEND_MM_ALIGNED_SIZE(size)	(((size) + ZEND_MM_ALIGNMENT - 1) & ZEND_MM_ALIGNMENT_MASK)

typedef struct _zend_leak_info {
	void *addr;
	size_t size;
	const char *filename;
	uint lineno;
	const char *orig_filename;
	uint orig_lineno;
} zend_leak_info;

BEGIN_EXTERN_C()

ZEND_API char *zend_strndup(const char *s, unsigned int length) ZEND_ATTRIBUTE_MALLOC;

ZEND_API void *_emalloc(size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_MALLOC ZEND_ATTRIBUTE_ALLOC_SIZE(1);
ZEND_API void *_safe_emalloc(size_t nmemb, size_t size, size_t offset ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_MALLOC;
ZEND_API void *_safe_malloc(size_t nmemb, size_t size, size_t offset) ZEND_ATTRIBUTE_MALLOC;
ZEND_API void _efree(void *ptr ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);
ZEND_API void *_ecalloc(size_t nmemb, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_MALLOC ZEND_ATTRIBUTE_ALLOC_SIZE2(1,2);
ZEND_API void *_erealloc(void *ptr, size_t size, int allow_failure ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_ALLOC_SIZE(2);
ZEND_API void *_safe_erealloc(void *ptr, size_t nmemb, size_t size, size_t offset ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);
ZEND_API void *_safe_realloc(void *ptr, size_t nmemb, size_t size, size_t offset);
ZEND_API char *_estrdup(const char *s ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_MALLOC;
ZEND_API char *_estrndup(const char *s, unsigned int length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_MALLOC;
ZEND_API size_t _zend_mem_block_size(void *ptr TSRMLS_DC ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);

/* Standard wrapper macros */
#define emalloc(size)						_emalloc((size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define safe_emalloc(nmemb, size, offset)	_safe_emalloc((nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define efree(ptr)							_efree((ptr) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define ecalloc(nmemb, size)				_ecalloc((nmemb), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define erealloc(ptr, size)					_erealloc((ptr), (size), 0 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define safe_erealloc(ptr, nmemb, size, offset)	_safe_erealloc((ptr), (nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define erealloc_recoverable(ptr, size)		_erealloc((ptr), (size), 1 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define estrdup(s)							_estrdup((s) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define estrndup(s, length)					_estrndup((s), (length) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define zend_mem_block_size(ptr)			_zend_mem_block_size((ptr) TSRMLS_CC ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)

/* Relay wrapper macros */
#define emalloc_rel(size)						_emalloc((size) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define safe_emalloc_rel(nmemb, size, offset)	_safe_emalloc((nmemb), (size), (offset) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define efree_rel(ptr)							_efree((ptr) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define ecalloc_rel(nmemb, size)				_ecalloc((nmemb), (size) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define erealloc_rel(ptr, size)					_erealloc((ptr), (size), 0 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define erealloc_recoverable_rel(ptr, size)		_erealloc((ptr), (size), 1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define safe_erealloc_rel(ptr, nmemb, size, offset)	_safe_erealloc((ptr), (nmemb), (size), (offset) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define estrdup_rel(s)							_estrdup((s) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define estrndup_rel(s, length)					_estrndup((s), (length) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define zend_mem_block_size_rel(ptr)			_zend_mem_block_size((ptr) TSRMLS_CC ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)

inline static void * __zend_malloc(size_t len)
{
	void *tmp = malloc(len);
	if (tmp) {
		return tmp;
	}
	fprintf(stderr, "Out of memory\n");
	exit(1);
}

inline static void * __zend_calloc(size_t nmemb, size_t len)
{
	void *tmp = _safe_malloc(nmemb, len, 0);
	memset(tmp, 0, nmemb * len);
	return tmp;
}

inline static void * __zend_realloc(void *p, size_t len)
{
	p = realloc(p, len);
	if (p) {
		return p;
	}
	fprintf(stderr, "Out of memory\n");
	exit(1);
}


/* Selective persistent/non persistent allocation macros */
#define pemalloc(size, persistent) ((persistent)?__zend_malloc(size):emalloc(size))
#define safe_pemalloc(nmemb, size, offset, persistent)	((persistent)?_safe_malloc(nmemb, size, offset):safe_emalloc(nmemb, size, offset))
#define pefree(ptr, persistent)  ((persistent)?free(ptr):efree(ptr))
#define pecalloc(nmemb, size, persistent) ((persistent)?__zend_calloc((nmemb), (size)):ecalloc((nmemb), (size)))
#define perealloc(ptr, size, persistent) ((persistent)?__zend_realloc((ptr), (size)):erealloc((ptr), (size)))
#define safe_perealloc(ptr, nmemb, size, offset, persistent)	((persistent)?_safe_realloc((ptr), (nmemb), (size), (offset)):safe_erealloc((ptr), (nmemb), (size), (offset)))
#define perealloc_recoverable(ptr, size, persistent) ((persistent)?__zend_realloc((ptr), (size)):erealloc_recoverable((ptr), (size)))
#define pestrdup(s, persistent) ((persistent)?strdup(s):estrdup(s))
#define pestrndup(s, length, persistent) ((persistent)?zend_strndup((s),(length)):estrndup((s),(length)))

#define pemalloc_rel(size, persistent) ((persistent)?__zend_malloc(size):emalloc_rel(size))
#define pefree_rel(ptr, persistent)	((persistent)?free(ptr):efree_rel(ptr))
#define pecalloc_rel(nmemb, size, persistent) ((persistent)?__zend_calloc((nmemb), (size)):ecalloc_rel((nmemb), (size)))
#define perealloc_rel(ptr, size, persistent) ((persistent)?__zend_realloc((ptr), (size)):erealloc_rel((ptr), (size)))
#define perealloc_recoverable_rel(ptr, size, persistent) ((persistent)?__zend_realloc((ptr), (size)):erealloc_recoverable_rel((ptr), (size)))
#define pestrdup_rel(s, persistent) ((persistent)?strdup(s):estrdup_rel(s))

#define safe_estrdup(ptr)  ((ptr)?(estrdup(ptr)):STR_EMPTY_ALLOC())
#define safe_estrndup(ptr, len) ((ptr)?(estrndup((ptr), (len))):STR_EMPTY_ALLOC())

ZEND_API int zend_set_memory_limit(size_t memory_limit);

ZEND_API void start_memory_manager(TSRMLS_D);
ZEND_API void shutdown_memory_manager(int silent, int full_shutdown TSRMLS_DC);
ZEND_API int is_zend_mm(TSRMLS_D);

#if ZEND_DEBUG
ZEND_API int _mem_block_check(void *ptr, int silent ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);
ZEND_API void _full_mem_check(int silent ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);
void zend_debug_alloc_output(char *format, ...);
#define mem_block_check(ptr, silent) _mem_block_check(ptr, silent ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define full_mem_check(silent) _full_mem_check(silent ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#else
#define mem_block_check(type, ptr, silent)
#define full_mem_check(silent)
#endif

ZEND_API size_t zend_memory_usage(int real_usage TSRMLS_DC);
ZEND_API size_t zend_memory_peak_usage(int real_usage TSRMLS_DC);

END_EXTERN_C()

/* fast cache for zval's */
#define ALLOC_ZVAL(z)	\
	(z) = (zval *) emalloc(sizeof(zval))

#define FREE_ZVAL(z)	\
	efree_rel(z)

#define ALLOC_ZVAL_REL(z)	\
	(z) = (zval *) emalloc_rel(sizeof(zval))

#define FREE_ZVAL_REL(z)	\
	efree_rel(z)

/* fast cache for HashTables */
#define ALLOC_HASHTABLE(ht)	\
	(ht) = (HashTable *) emalloc(sizeof(HashTable))

#define FREE_HASHTABLE(ht)	\
	efree(ht)

#define ALLOC_HASHTABLE_REL(ht)	\
	(ht) = (HashTable *) emalloc_rel(sizeof(HashTable))

#define FREE_HASHTABLE_REL(ht)	\
	efree_rel(ht)

/* Heap functions */
typedef struct _zend_mm_heap zend_mm_heap;

ZEND_API zend_mm_heap *zend_mm_startup(void);
ZEND_API void zend_mm_shutdown(zend_mm_heap *heap, int full_shutdown, int silent TSRMLS_DC);
ZEND_API void *_zend_mm_alloc(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) ZEND_ATTRIBUTE_MALLOC;
ZEND_API void _zend_mm_free(zend_mm_heap *heap, void *p ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);
ZEND_API void *_zend_mm_realloc(zend_mm_heap *heap, void *p, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);
ZEND_API size_t _zend_mm_block_size(zend_mm_heap *heap, void *p ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);

#define zend_mm_alloc(heap, size)			_zend_mm_alloc((heap), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define zend_mm_free(heap, p)				_zend_mm_free((heap), (p) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define zend_mm_realloc(heap, p, size)		_zend_mm_realloc((heap), (p), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)
#define zend_mm_block_size(heap, p)			_zend_mm_block_size((heap), (p) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)

#define zend_mm_alloc_rel(heap, size)		_zend_mm_alloc((heap), (size) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define zend_mm_free_rel(heap, p)			_zend_mm_free((heap), (p) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define zend_mm_realloc_rel(heap, p, size)	_zend_mm_realloc((heap), (p), (size) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_CC)
#define zend_mm_block_size_rel(heap, p)		_zend_mm_block_size((heap), (p) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)

/* Heaps with user defined storage */
typedef struct _zend_mm_storage zend_mm_storage;

typedef struct _zend_mm_segment {
	size_t	size;
	struct _zend_mm_segment *next_segment;
} zend_mm_segment;

typedef struct _zend_mm_mem_handlers {
	const char *name;
	zend_mm_storage* (*init)(void *params);
	void (*dtor)(zend_mm_storage *storage);
	void (*compact)(zend_mm_storage *storage);
	zend_mm_segment* (*_alloc)(zend_mm_storage *storage, size_t size);
	zend_mm_segment* (*_realloc)(zend_mm_storage *storage, zend_mm_segment *ptr, size_t size);
	void (*_free)(zend_mm_storage *storage, zend_mm_segment *ptr);
} zend_mm_mem_handlers;

struct _zend_mm_storage {
	const zend_mm_mem_handlers *handlers;
	void *data;
};

ZEND_API zend_mm_heap *zend_mm_startup_ex(const zend_mm_mem_handlers *handlers, size_t block_size, size_t reserve_size, int internal, void *params);
ZEND_API zend_mm_heap *zend_mm_set_heap(zend_mm_heap *new_heap TSRMLS_DC);
ZEND_API zend_mm_storage *zend_mm_get_storage(zend_mm_heap *heap);

ZEND_API void zend_mm_set_custom_handlers(zend_mm_heap *heap,
                                          void* (*_malloc)(size_t),
                                          void  (*_free)(void*),
                                          void* (*_realloc)(void*, size_t));

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_build.h                               0100644 0001750 0001750 00000003133 12566220066 023544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Stanislav Malyshev <stas@zend.com>                          |
   +----------------------------------------------------------------------+
*/

#ifndef ZEND_BUILD_H
#define ZEND_BUILD_H

#define ZEND_TOSTR_(x) #x
#define ZEND_TOSTR(x) ZEND_TOSTR_(x)

#ifdef ZTS
#define ZEND_BUILD_TS ",TS"
#else
#define ZEND_BUILD_TS ",NTS"
#endif

#if ZEND_DEBUG
#define ZEND_BUILD_DEBUG ",debug"
#else
#define ZEND_BUILD_DEBUG
#endif

#if defined(ZEND_WIN32) && defined(PHP_COMPILER_ID)
#define ZEND_BUILD_SYSTEM "," PHP_COMPILER_ID
#else
#define ZEND_BUILD_SYSTEM
#endif

/* for private applications */
#define ZEND_BUILD_EXTRA 

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_builtin_functions.h                   0100644 0001750 0001750 00000003133 12566220066 026203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_BUILTIN_FUNCTIONS_H
#define ZEND_BUILTIN_FUNCTIONS_H

int zend_startup_builtin_functions(TSRMLS_D);

BEGIN_EXTERN_C()
ZEND_API void zend_fetch_debug_backtrace(zval *return_value, int skip_last, int options, int limit TSRMLS_DC);
END_EXTERN_C()

#endif /* ZEND_BUILTIN_FUNCTIONS_H */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_closures.h                            0100644 0001750 0001750 00000003503 12566220066 024305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Christian Seiler <chris_se@gmx.net>                         |
   |          Dmitry Stogov <dmitry@zend.com>                             |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_CLOSURES_H
#define ZEND_CLOSURES_H

BEGIN_EXTERN_C()

void zend_register_closure_ce(TSRMLS_D);

extern ZEND_API zend_class_entry *zend_ce_closure;

ZEND_API void zend_create_closure(zval *res, zend_function *op_array, zend_class_entry *scope, zval *this_ptr TSRMLS_DC);
ZEND_API zend_function *zend_get_closure_invoke_method(zval *obj TSRMLS_DC);
ZEND_API const zend_function *zend_get_closure_method_def(zval *obj TSRMLS_DC);
ZEND_API zval* zend_get_closure_this_ptr(zval *obj TSRMLS_DC);

END_EXTERN_C()

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_compile.h                             0100644 0001750 0001750 00000103423 12566220066 024100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_COMPILE_H
#define ZEND_COMPILE_H

#include "zend.h"

#ifdef HAVE_STDARG_H
# include <stdarg.h>
#endif

#include "zend_llist.h"

#define DEBUG_ZEND 0

#define FREE_PNODE(znode)	zval_dtor(&znode->u.constant);

#define SET_UNUSED(op)  op ## _type = IS_UNUSED

#define INC_BPC(op_array)	if (op_array->fn_flags & ZEND_ACC_INTERACTIVE) { (CG(context).backpatch_count++); }
#define DEC_BPC(op_array)	if (op_array->fn_flags & ZEND_ACC_INTERACTIVE) { (CG(context).backpatch_count--); }
#define HANDLE_INTERACTIVE()  if (CG(active_op_array)->fn_flags & ZEND_ACC_INTERACTIVE) { execute_new_code(TSRMLS_C); }
#define DO_TICKS()            if (Z_LVAL(CG(declarables).ticks)) { zend_do_ticks(TSRMLS_C); }

#define RESET_DOC_COMMENT()        \
    {                              \
        if (CG(doc_comment)) {     \
          efree(CG(doc_comment));  \
          CG(doc_comment) = NULL;  \
        }                          \
        CG(doc_comment_len) = 0;   \
    }

typedef struct _zend_op_array zend_op_array;
typedef struct _zend_op zend_op;

typedef struct _zend_compiler_context {
	zend_uint  opcodes_size;
	int        vars_size;
	int        literals_size;
	int        current_brk_cont;
	int        backpatch_count;
	int        nested_calls;
	int        used_stack;
	int        in_finally;
	HashTable *labels;
} zend_compiler_context;

typedef struct _zend_literal {
	zval       constant;
	zend_ulong hash_value;
	zend_uint  cache_slot;
} zend_literal;

#define Z_HASH_P(zv) \
	(((zend_literal*)(zv))->hash_value)

typedef union _znode_op {	
	zend_uint      constant;
	zend_uint      var;
	zend_uint      num;
	zend_ulong     hash;
	zend_uint      opline_num; /*  Needs to be signed */
	zend_op       *jmp_addr;
	zval          *zv;
	zend_literal  *literal;
	void          *ptr;        /* Used for passing pointers from the compile to execution phase, currently used for traits */
} znode_op;

typedef struct _znode { /* used only during compilation */ 
	int op_type;
	union {
		znode_op op;
		zval constant; /* replaced by literal/zv */
		zend_op_array *op_array;
	} u;
	zend_uint EA;      /* extended attributes */
} znode;

typedef struct _zend_execute_data zend_execute_data;

#define ZEND_OPCODE_HANDLER_ARGS zend_execute_data *execute_data TSRMLS_DC
#define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU execute_data TSRMLS_CC

typedef int (*user_opcode_handler_t) (ZEND_OPCODE_HANDLER_ARGS);
typedef int (ZEND_FASTCALL *opcode_handler_t) (ZEND_OPCODE_HANDLER_ARGS);

extern ZEND_API opcode_handler_t *zend_opcode_handlers;

struct _zend_op {
	opcode_handler_t handler;
	znode_op op1;
	znode_op op2;
	znode_op result;
	ulong extended_value;
	uint lineno;
	zend_uchar opcode;
	zend_uchar op1_type;
	zend_uchar op2_type;
	zend_uchar result_type;
};


typedef struct _zend_brk_cont_element {
	int start;
	int cont;
	int brk;
	int parent;
} zend_brk_cont_element;

typedef struct _zend_label {
	int brk_cont;
	zend_uint opline_num;
} zend_label;

typedef struct _zend_try_catch_element {
	zend_uint try_op;
	zend_uint catch_op;  /* ketchup! */
	zend_uint finally_op;
	zend_uint finally_end;
} zend_try_catch_element;

#if SIZEOF_LONG == 8
#define THIS_HASHVAL 210728972157UL
#else
#define THIS_HASHVAL 275574653UL
#endif

/* method flags (types) */
#define ZEND_ACC_STATIC			0x01
#define ZEND_ACC_ABSTRACT		0x02
#define ZEND_ACC_FINAL			0x04
#define ZEND_ACC_IMPLEMENTED_ABSTRACT		0x08

/* class flags (types) */
/* ZEND_ACC_IMPLICIT_ABSTRACT_CLASS is used for abstract classes (since it is set by any abstract method even interfaces MAY have it set, too). */
/* ZEND_ACC_EXPLICIT_ABSTRACT_CLASS denotes that a class was explicitly defined as abstract by using the keyword. */
#define ZEND_ACC_IMPLICIT_ABSTRACT_CLASS	0x10
#define ZEND_ACC_EXPLICIT_ABSTRACT_CLASS	0x20
#define ZEND_ACC_FINAL_CLASS	            0x40
#define ZEND_ACC_INTERFACE		            0x80
#define ZEND_ACC_TRAIT						0x120

/* op_array flags */
#define ZEND_ACC_INTERACTIVE				0x10

/* method flags (visibility) */
/* The order of those must be kept - public < protected < private */
#define ZEND_ACC_PUBLIC		0x100
#define ZEND_ACC_PROTECTED	0x200
#define ZEND_ACC_PRIVATE	0x400
#define ZEND_ACC_PPP_MASK  (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)

#define ZEND_ACC_CHANGED	0x800
#define ZEND_ACC_IMPLICIT_PUBLIC	0x1000

/* method flags (special method detection) */
#define ZEND_ACC_CTOR		0x2000
#define ZEND_ACC_DTOR		0x4000
#define ZEND_ACC_CLONE		0x8000

/* method flag (bc only), any method that has this flag can be used statically and non statically. */
#define ZEND_ACC_ALLOW_STATIC	0x10000

/* shadow of parent's private method/property */
#define ZEND_ACC_SHADOW 0x20000

/* deprecation flag */
#define ZEND_ACC_DEPRECATED 0x40000

/* class implement interface(s) flag */
#define ZEND_ACC_IMPLEMENT_INTERFACES 0x80000
#define ZEND_ACC_IMPLEMENT_TRAITS	  0x400000

/* class constants updated */
#define ZEND_ACC_CONSTANTS_UPDATED	  0x100000

/* user class has methods with static variables */
#define ZEND_HAS_STATIC_IN_METHODS    0x800000


#define ZEND_ACC_CLOSURE              0x100000
#define ZEND_ACC_GENERATOR            0x800000

/* function flag for internal user call handlers __call, __callstatic */
#define ZEND_ACC_CALL_VIA_HANDLER     0x200000

/* disable inline caching */
#define ZEND_ACC_NEVER_CACHE          0x400000

#define ZEND_ACC_PASS_REST_BY_REFERENCE 0x1000000
#define ZEND_ACC_PASS_REST_PREFER_REF	0x2000000

#define ZEND_ACC_RETURN_REFERENCE		0x4000000
#define ZEND_ACC_DONE_PASS_TWO			0x8000000

char *zend_visibility_string(zend_uint fn_flags);


typedef struct _zend_property_info {
	zend_uint flags;
	const char *name;
	int name_length;
	ulong h;
	int offset;
	const char *doc_comment;
	int doc_comment_len;
	zend_class_entry *ce;
} zend_property_info;


typedef struct _zend_arg_info {
	const char *name;
	zend_uint name_len;
	const char *class_name;
	zend_uint class_name_len;
	zend_uchar type_hint;
	zend_bool allow_null;
	zend_bool pass_by_reference;
} zend_arg_info;

/* the following structure repeats the layout of zend_arg_info,
 * but its fields have different meaning. It's used as the first element of 
 * arg_info array to define properties of internal functions.
 */
typedef struct _zend_internal_function_info {
	const char *_name;
	zend_uint _name_len;
	const char *_class_name;
	zend_uint required_num_args;
	zend_uchar _type_hint;
	zend_bool return_reference;
	zend_bool pass_rest_by_reference;
} zend_internal_function_info;

typedef struct _zend_compiled_variable {
	const char *name;
	int name_len;
	ulong hash_value;
} zend_compiled_variable;

struct _zend_op_array {
	/* Common elements */
	zend_uchar type;
	const char *function_name;		
	zend_class_entry *scope;
	zend_uint fn_flags;
	union _zend_function *prototype;
	zend_uint num_args;
	zend_uint required_num_args;
	zend_arg_info *arg_info;
	/* END of common elements */

	zend_uint *refcount;

	zend_op *opcodes;
	zend_uint last;

	zend_compiled_variable *vars;
	int last_var;

	zend_uint T;

	zend_uint nested_calls;
	zend_uint used_stack;

	zend_brk_cont_element *brk_cont_array;
	int last_brk_cont;

	zend_try_catch_element *try_catch_array;
	int last_try_catch;
	zend_bool has_finally_block;

	/* static variables support */
	HashTable *static_variables;

	zend_uint this_var;

	const char *filename;
	zend_uint line_start;
	zend_uint line_end;
	const char *doc_comment;
	zend_uint doc_comment_len;
	zend_uint early_binding; /* the linked list of delayed declarations */

	zend_literal *literals;
	int last_literal;

	void **run_time_cache;
	int  last_cache_slot;

	void *reserved[ZEND_MAX_RESERVED_RESOURCES];
};


#define ZEND_RETURN_VALUE				0
#define ZEND_RETURN_REFERENCE			1

typedef struct _zend_internal_function {
	/* Common elements */
	zend_uchar type;
	const char * function_name;
	zend_class_entry *scope;
	zend_uint fn_flags;
	union _zend_function *prototype;
	zend_uint num_args;
	zend_uint required_num_args;
	zend_arg_info *arg_info;
	/* END of common elements */

	void (*handler)(INTERNAL_FUNCTION_PARAMETERS);
	struct _zend_module_entry *module;
} zend_internal_function;

#define ZEND_FN_SCOPE_NAME(function)  ((function) && (function)->common.scope ? (function)->common.scope->name : "")

typedef union _zend_function {
	zend_uchar type;	/* MUST be the first element of this struct! */

	struct {
		zend_uchar type;  /* never used */
		const char *function_name;
		zend_class_entry *scope;
		zend_uint fn_flags;
		union _zend_function *prototype;
		zend_uint num_args;
		zend_uint required_num_args;
		zend_arg_info *arg_info;
	} common;

	zend_op_array op_array;
	zend_internal_function internal_function;
} zend_function;


typedef struct _zend_function_state {
	zend_function *function;
	void **arguments;
} zend_function_state;


typedef struct _zend_switch_entry {
	znode cond;
	int default_case;
	int control_var;
} zend_switch_entry;


typedef struct _list_llist_element {
	znode var;
	zend_llist dimensions;
	znode value;
} list_llist_element;

union _temp_variable;

typedef struct _call_slot {
	zend_function     *fbc;
	zval              *object;
	zend_class_entry  *called_scope;
	zend_bool          is_ctor_call;
	zend_bool          is_ctor_result_used;
} call_slot;

struct _zend_execute_data {
	struct _zend_op *opline;
	zend_function_state function_state;
	zend_op_array *op_array;
	zval *object;
	HashTable *symbol_table;
	struct _zend_execute_data *prev_execute_data;
	zval *old_error_reporting;
	zend_bool nested;
	zval **original_return_value;
	zend_class_entry *current_scope;
	zend_class_entry *current_called_scope;
	zval *current_this;
	struct _zend_op *fast_ret; /* used by FAST_CALL/FAST_RET (finally keyword) */
	call_slot *call_slots;
	call_slot *call;
};

#define EX(element) execute_data.element

#define EX_TMP_VAR(ex, n)	   ((temp_variable*)(((char*)(ex)) + ((int)(n))))
#define EX_TMP_VAR_NUM(ex, n)  (EX_TMP_VAR(ex, 0) - (1 + (n)))

#define EX_CV_NUM(ex, n)       (((zval***)(((char*)(ex))+ZEND_MM_ALIGNED_SIZE(sizeof(zend_execute_data))))+(n))


#define IS_CONST	(1<<0)
#define IS_TMP_VAR	(1<<1)
#define IS_VAR		(1<<2)
#define IS_UNUSED	(1<<3)	/* Unused variable */
#define IS_CV		(1<<4)	/* Compiled variable */

#define EXT_TYPE_UNUSED	(1<<5)

#include "zend_globals.h"

BEGIN_EXTERN_C()

void init_compiler(TSRMLS_D);
void shutdown_compiler(TSRMLS_D);
void zend_init_compiler_data_structures(TSRMLS_D);
void zend_init_compiler_context(TSRMLS_D);

extern ZEND_API zend_op_array *(*zend_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);
extern ZEND_API zend_op_array *(*zend_compile_string)(zval *source_string, char *filename TSRMLS_DC);

ZEND_API int lex_scan(zval *zendlval TSRMLS_DC);
void startup_scanner(TSRMLS_D);
void shutdown_scanner(TSRMLS_D);

ZEND_API char *zend_set_compiled_filename(const char *new_compiled_filename TSRMLS_DC);
ZEND_API void zend_restore_compiled_filename(char *original_compiled_filename TSRMLS_DC);
ZEND_API char *zend_get_compiled_filename(TSRMLS_D);
ZEND_API int zend_get_compiled_lineno(TSRMLS_D);
ZEND_API size_t zend_get_scanned_file_offset(TSRMLS_D);

void zend_resolve_non_class_name(znode *element_name, zend_bool check_namespace TSRMLS_DC);
void zend_resolve_class_name(znode *class_name, ulong fetch_type, int check_ns_name TSRMLS_DC);
ZEND_API const char* zend_get_compiled_variable_name(const zend_op_array *op_array, zend_uint var, int* name_len);

#ifdef ZTS
const char *zend_get_zendtext(TSRMLS_D);
int zend_get_zendleng(TSRMLS_D);
#endif


/* parser-driven code generators */
void zend_do_binary_op(zend_uchar op, znode *result, const znode *op1, const znode *op2 TSRMLS_DC);
void zend_do_unary_op(zend_uchar op, znode *result, const znode *op1 TSRMLS_DC);
void zend_do_binary_assign_op(zend_uchar op, znode *result, const znode *op1, const znode *op2 TSRMLS_DC);
void zend_do_assign(znode *result, znode *variable, znode *value TSRMLS_DC);
void zend_do_assign_ref(znode *result, const znode *lvar, const znode *rvar TSRMLS_DC);
void fetch_simple_variable(znode *result, znode *varname, int bp TSRMLS_DC);
void fetch_simple_variable_ex(znode *result, znode *varname, int bp, zend_uchar op TSRMLS_DC);
void zend_do_indirect_references(znode *result, const znode *num_references, znode *variable TSRMLS_DC);
void zend_do_fetch_static_variable(znode *varname, const znode *static_assignment, int fetch_type TSRMLS_DC);
void zend_do_fetch_global_variable(znode *varname, const znode *static_assignment, int fetch_type TSRMLS_DC);

void fetch_array_begin(znode *result, znode *varname, znode *first_dim TSRMLS_DC);
void fetch_array_dim(znode *result, const znode *parent, const znode *dim TSRMLS_DC);
void fetch_string_offset(znode *result, const znode *parent, const znode *offset TSRMLS_DC);
void zend_do_fetch_static_member(znode *result, znode *class_znode TSRMLS_DC);
void zend_do_print(znode *result, const znode *arg TSRMLS_DC);
void zend_do_echo(const znode *arg TSRMLS_DC);
typedef int (*unary_op_type)(zval *, zval * TSRMLS_DC);
typedef int (*binary_op_type)(zval *, zval *, zval * TSRMLS_DC);
ZEND_API unary_op_type get_unary_op(int opcode);
ZEND_API binary_op_type get_binary_op(int opcode);

void zend_do_while_cond(const znode *expr, znode *close_bracket_token TSRMLS_DC);
void zend_do_while_end(const znode *while_token, const znode *close_bracket_token TSRMLS_DC);
void zend_do_do_while_begin(TSRMLS_D);
void zend_do_do_while_end(const znode *do_token, const znode *expr_open_bracket, const znode *expr TSRMLS_DC);


void zend_do_if_cond(const znode *cond, znode *closing_bracket_token TSRMLS_DC);
void zend_do_if_after_statement(const znode *closing_bracket_token, unsigned char initialize TSRMLS_DC);
void zend_do_if_end(TSRMLS_D);

void zend_do_for_cond(const znode *expr, znode *second_semicolon_token TSRMLS_DC);
void zend_do_for_before_statement(const znode *cond_start, const znode *second_semicolon_token TSRMLS_DC);
void zend_do_for_end(const znode *second_semicolon_token TSRMLS_DC);

void zend_do_pre_incdec(znode *result, const znode *op1, zend_uchar op TSRMLS_DC);
void zend_do_post_incdec(znode *result, const znode *op1, zend_uchar op TSRMLS_DC);

void zend_do_begin_variable_parse(TSRMLS_D);
void zend_do_end_variable_parse(znode *variable, int type, int arg_offset TSRMLS_DC);

void zend_check_writable_variable(const znode *variable);

void zend_do_free(znode *op1 TSRMLS_DC);

void zend_do_add_string(znode *result, const znode *op1, znode *op2 TSRMLS_DC);
void zend_do_add_variable(znode *result, const znode *op1, const znode *op2 TSRMLS_DC);

int zend_do_verify_access_types(const znode *current_access_type, const znode *new_modifier);
void zend_do_begin_function_declaration(znode *function_token, znode *function_name, int is_method, int return_reference, znode *fn_flags_znode TSRMLS_DC);
void zend_do_end_function_declaration(const znode *function_token TSRMLS_DC);
void zend_do_receive_arg(zend_uchar op, znode *varname, const znode *offset, const znode *initialization, znode *class_type, zend_bool pass_by_reference TSRMLS_DC);
int zend_do_begin_function_call(znode *function_name, zend_bool check_namespace TSRMLS_DC);
void zend_do_begin_method_call(znode *left_bracket TSRMLS_DC);
void zend_do_clone(znode *result, const znode *expr TSRMLS_DC);
void zend_do_begin_dynamic_function_call(znode *function_name, int prefix_len TSRMLS_DC);
void zend_do_fetch_class(znode *result, znode *class_name TSRMLS_DC);
void zend_do_build_full_name(znode *result, znode *prefix, znode *name, int is_class_member TSRMLS_DC);
int zend_do_begin_class_member_function_call(znode *class_name, znode *method_name TSRMLS_DC);
void zend_do_end_function_call(znode *function_name, znode *result, const znode *argument_list, int is_method, int is_dynamic_fcall TSRMLS_DC);
void zend_do_return(znode *expr, int do_end_vparse TSRMLS_DC);
void zend_do_yield(znode *result, znode *value, const znode *key, zend_bool is_variable TSRMLS_DC);
void zend_do_handle_exception(TSRMLS_D);

void zend_do_begin_lambda_function_declaration(znode *result, znode *function_token, int return_reference, int is_static TSRMLS_DC);
void zend_do_fetch_lexical_variable(znode *varname, zend_bool is_ref TSRMLS_DC);

void zend_do_try(znode *try_token TSRMLS_DC);
void zend_do_begin_catch(znode *try_token, znode *catch_class, znode *catch_var, znode *first_catch TSRMLS_DC);
void zend_do_bind_catch(znode *try_token, znode *catch_token TSRMLS_DC);
void zend_do_end_catch(znode *catch_token TSRMLS_DC);
void zend_do_finally(znode *finally_token TSRMLS_DC);
void zend_do_end_finally(znode *try_token, znode* catch_token, znode *finally_token TSRMLS_DC);
void zend_do_throw(const znode *expr TSRMLS_DC);

ZEND_API int do_bind_function(const zend_op_array *op_array, zend_op *opline, HashTable *function_table, zend_bool compile_time);
ZEND_API zend_class_entry *do_bind_class(const zend_op_array *op_array, const zend_op *opline, HashTable *class_table, zend_bool compile_time TSRMLS_DC);
ZEND_API zend_class_entry *do_bind_inherited_class(const zend_op_array *op_array, const zend_op *opline, HashTable *class_table, zend_class_entry *parent_ce, zend_bool compile_time TSRMLS_DC);
ZEND_API void zend_do_inherit_interfaces(zend_class_entry *ce, const zend_class_entry *iface TSRMLS_DC);
ZEND_API void zend_do_implement_interface(zend_class_entry *ce, zend_class_entry *iface TSRMLS_DC);
void zend_do_implements_interface(znode *interface_znode TSRMLS_DC);

/* Trait related functions */
void zend_do_use_trait(znode *trait_znode TSRMLS_DC);
void zend_prepare_reference(znode *result, znode *class_name, znode *method_name TSRMLS_DC);
void zend_add_trait_precedence(znode *method_reference, znode *trait_list TSRMLS_DC);
void zend_add_trait_alias(znode *method_reference, znode *modifiers, znode *alias TSRMLS_DC);

ZEND_API void zend_do_implement_trait(zend_class_entry *ce, zend_class_entry *trait TSRMLS_DC);
ZEND_API void zend_do_bind_traits(zend_class_entry *ce TSRMLS_DC);

ZEND_API void zend_do_inheritance(zend_class_entry *ce, zend_class_entry *parent_ce TSRMLS_DC);
void zend_do_early_binding(TSRMLS_D);
ZEND_API void zend_do_delayed_early_binding(const zend_op_array *op_array TSRMLS_DC);

void zend_do_pass_param(znode *param, zend_uchar op, int offset TSRMLS_DC);


void zend_do_boolean_or_begin(znode *expr1, znode *op_token TSRMLS_DC);
void zend_do_boolean_or_end(znode *result, const znode *expr1, const znode *expr2, znode *op_token TSRMLS_DC);
void zend_do_boolean_and_begin(znode *expr1, znode *op_token TSRMLS_DC);
void zend_do_boolean_and_end(znode *result, const znode *expr1, const znode *expr2, const znode *op_token TSRMLS_DC);

void zend_do_brk_cont(zend_uchar op, const znode *expr TSRMLS_DC);

void zend_do_switch_cond(const znode *cond TSRMLS_DC);
void zend_do_switch_end(const znode *case_list TSRMLS_DC);
void zend_do_case_before_statement(const znode *case_list, znode *case_token, const znode *case_expr TSRMLS_DC);
void zend_do_case_after_statement(znode *result, const znode *case_token TSRMLS_DC);
void zend_do_default_before_statement(const znode *case_list, znode *default_token TSRMLS_DC);

void zend_do_begin_class_declaration(const znode *class_token, znode *class_name, const znode *parent_class_name TSRMLS_DC);
void zend_do_end_class_declaration(const znode *class_token, const znode *parent_token TSRMLS_DC);
void zend_do_declare_property(const znode *var_name, const znode *value, zend_uint access_type TSRMLS_DC);
void zend_do_declare_class_constant(znode *var_name, const znode *value TSRMLS_DC);

void zend_do_fetch_property(znode *result, znode *object, const znode *property TSRMLS_DC);

void zend_do_halt_compiler_register(TSRMLS_D);

void zend_do_push_object(const znode *object TSRMLS_DC);
void zend_do_pop_object(znode *object TSRMLS_DC);


void zend_do_begin_new_object(znode *new_token, znode *class_type TSRMLS_DC);
void zend_do_end_new_object(znode *result, const znode *new_token, const znode *argument_list TSRMLS_DC);

void zend_do_fetch_constant(znode *result, znode *constant_container, znode *constant_name, int mode, zend_bool check_namespace TSRMLS_DC);

void zend_do_shell_exec(znode *result, const znode *cmd TSRMLS_DC);

void zend_do_init_array(znode *result, const znode *expr, const znode *offset, zend_bool is_ref TSRMLS_DC);
void zend_do_add_array_element(znode *result, const znode *expr, const znode *offset, zend_bool is_ref TSRMLS_DC);
void zend_do_add_static_array_element(znode *result, znode *offset, const znode *expr);
void zend_do_list_init(TSRMLS_D);
void zend_do_list_end(znode *result, znode *expr TSRMLS_DC);
void zend_do_add_list_element(const znode *element TSRMLS_DC);
void zend_do_new_list_begin(TSRMLS_D);
void zend_do_new_list_end(TSRMLS_D);

/* Functions for a null terminated pointer list, used for traits parsing and compilation */
void zend_init_list(void *result, void *item TSRMLS_DC);
void zend_add_to_list(void *result, void *item TSRMLS_DC);


void zend_do_cast(znode *result, const znode *expr, int type TSRMLS_DC);
void zend_do_include_or_eval(int type, znode *result, const znode *op1 TSRMLS_DC);

void zend_do_unset(const znode *variable TSRMLS_DC);
void zend_do_isset_or_isempty(int type, znode *result, znode *variable TSRMLS_DC);

void zend_do_instanceof(znode *result, const znode *expr, const znode *class_znode, int type TSRMLS_DC);

void zend_do_foreach_begin(znode *foreach_token, znode *open_brackets_token, znode *array, znode *as_token, int variable TSRMLS_DC);
void zend_do_foreach_cont(znode *foreach_token, const znode *open_brackets_token, const znode *as_token, znode *value, znode *key TSRMLS_DC);
void zend_do_foreach_end(const znode *foreach_token, const znode *as_token TSRMLS_DC);

void zend_do_declare_begin(TSRMLS_D);
void zend_do_declare_stmt(znode *var, znode *val TSRMLS_DC);
void zend_do_declare_end(const znode *declare_token TSRMLS_DC);

void zend_do_exit(znode *result, const znode *message TSRMLS_DC);

void zend_do_begin_silence(znode *strudel_token TSRMLS_DC);
void zend_do_end_silence(const znode *strudel_token TSRMLS_DC);

void zend_do_jmp_set(const znode *value, znode *jmp_token, znode *colon_token TSRMLS_DC);
void zend_do_jmp_set_else(znode *result, const znode *false_value, const znode *jmp_token, const znode *colon_token TSRMLS_DC);

void zend_do_begin_qm_op(const znode *cond, znode *qm_token TSRMLS_DC);
void zend_do_qm_true(const znode *true_value, znode *qm_token, znode *colon_token TSRMLS_DC);
void zend_do_qm_false(znode *result, const znode *false_value, const znode *qm_token, const znode *colon_token TSRMLS_DC);

void zend_do_extended_info(TSRMLS_D);
void zend_do_extended_fcall_begin(TSRMLS_D);
void zend_do_extended_fcall_end(TSRMLS_D);

void zend_do_ticks(TSRMLS_D);

void zend_do_abstract_method(const znode *function_name, znode *modifiers, const znode *body TSRMLS_DC);

void zend_do_declare_constant(znode *name, znode *value TSRMLS_DC);
void zend_do_build_namespace_name(znode *result, znode *prefix, znode *name TSRMLS_DC);
void zend_do_begin_namespace(const znode *name, zend_bool with_brackets TSRMLS_DC);
void zend_do_end_namespace(TSRMLS_D);
void zend_verify_namespace(TSRMLS_D);
void zend_do_use(znode *name, znode *new_name TSRMLS_DC);
void zend_do_end_compilation(TSRMLS_D);

void zend_do_resolve_class_name(znode *result, znode *class_name, int is_static TSRMLS_DC);

void zend_do_label(znode *label TSRMLS_DC);
void zend_do_goto(const znode *label TSRMLS_DC);
void zend_resolve_goto_label(zend_op_array *op_array, zend_op *opline, int pass2 TSRMLS_DC);
void zend_release_labels(int temporary TSRMLS_DC);

ZEND_API void function_add_ref(zend_function *function);

#define INITIAL_OP_ARRAY_SIZE 64
#define INITIAL_INTERACTIVE_OP_ARRAY_SIZE 8192


/* helper functions in zend_language_scanner.l */
ZEND_API zend_op_array *compile_file(zend_file_handle *file_handle, int type TSRMLS_DC);
ZEND_API zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC);
ZEND_API zend_op_array *compile_filename(int type, zval *filename TSRMLS_DC);
ZEND_API int zend_execute_scripts(int type TSRMLS_DC, zval **retval, int file_count, ...);
ZEND_API int open_file_for_scanning(zend_file_handle *file_handle TSRMLS_DC);
ZEND_API void init_op_array(zend_op_array *op_array, zend_uchar type, int initial_ops_size TSRMLS_DC);
ZEND_API void destroy_op_array(zend_op_array *op_array TSRMLS_DC);
ZEND_API void zend_destroy_file_handle(zend_file_handle *file_handle TSRMLS_DC);
ZEND_API int zend_cleanup_class_data(zend_class_entry **pce TSRMLS_DC);
ZEND_API int zend_cleanup_user_class_data(zend_class_entry **pce TSRMLS_DC);
ZEND_API void zend_cleanup_internal_class_data(zend_class_entry *ce TSRMLS_DC);
ZEND_API void zend_cleanup_internal_classes(TSRMLS_D);
ZEND_API int zend_cleanup_function_data(zend_function *function TSRMLS_DC);
ZEND_API int zend_cleanup_function_data_full(zend_function *function TSRMLS_DC);
ZEND_API int clean_non_persistent_function_full(zend_function *function TSRMLS_DC);
ZEND_API int clean_non_persistent_class_full(zend_class_entry **ce TSRMLS_DC);

ZEND_API void destroy_zend_function(zend_function *function TSRMLS_DC);
ZEND_API void zend_function_dtor(zend_function *function);
ZEND_API void destroy_zend_class(zend_class_entry **pce);
void zend_class_add_ref(zend_class_entry **ce);

ZEND_API void zend_mangle_property_name(char **dest, int *dest_length, const char *src1, int src1_length, const char *src2, int src2_length, int internal);
#define zend_unmangle_property_name(mangled_property, mangled_property_len, class_name, prop_name) \
        zend_unmangle_property_name_ex(mangled_property, mangled_property_len, class_name, prop_name, NULL) 
ZEND_API int zend_unmangle_property_name_ex(const char *mangled_property, int mangled_property_len, const char **class_name, const char **prop_name, int *prop_len);

#define ZEND_FUNCTION_DTOR (void (*)(void *)) zend_function_dtor
#define ZEND_CLASS_DTOR (void (*)(void *)) destroy_zend_class

zend_op *get_next_op(zend_op_array *op_array TSRMLS_DC);
void init_op(zend_op *op TSRMLS_DC);
int get_next_op_number(zend_op_array *op_array);
int print_class(zend_class_entry *class_entry TSRMLS_DC);
void print_op_array(zend_op_array *op_array, int optimizations);
ZEND_API int pass_two(zend_op_array *op_array TSRMLS_DC);
zend_brk_cont_element *get_next_brk_cont_element(zend_op_array *op_array);
void zend_do_first_catch(znode *open_parentheses TSRMLS_DC);
void zend_initialize_try_catch_element(znode *catch_token TSRMLS_DC);
void zend_do_mark_last_catch(const znode *first_catch, const znode *last_additional_catch TSRMLS_DC);
ZEND_API zend_bool zend_is_compiling(TSRMLS_D);
ZEND_API char *zend_make_compiled_string_description(const char *name TSRMLS_DC);
ZEND_API void zend_initialize_class_data(zend_class_entry *ce, zend_bool nullify_handlers TSRMLS_DC);
int zend_get_class_fetch_type(const char *class_name, uint class_name_len);

typedef zend_bool (*zend_auto_global_callback)(const char *name, uint name_len TSRMLS_DC);
typedef struct _zend_auto_global {
	const char *name;
	uint name_len;
	zend_auto_global_callback auto_global_callback;
	zend_bool jit;
	zend_bool armed;
} zend_auto_global;

ZEND_API int zend_register_auto_global(const char *name, uint name_len, zend_bool jit, zend_auto_global_callback auto_global_callback TSRMLS_DC);
ZEND_API void zend_activate_auto_globals(TSRMLS_D);
ZEND_API zend_bool zend_is_auto_global(const char *name, uint name_len TSRMLS_DC);
ZEND_API zend_bool zend_is_auto_global_quick(const char *name, uint name_len, ulong hashval TSRMLS_DC);
ZEND_API size_t zend_dirname(char *path, size_t len);

int zendlex(znode *zendlval TSRMLS_DC);

int zend_add_literal(zend_op_array *op_array, const zval *zv TSRMLS_DC);

/* BEGIN: OPCODES */

#include "zend_vm_opcodes.h"

#define ZEND_OP_DATA				137

/* END: OPCODES */

/* class fetches */
#define ZEND_FETCH_CLASS_DEFAULT	0
#define ZEND_FETCH_CLASS_SELF		1
#define ZEND_FETCH_CLASS_PARENT		2
#define ZEND_FETCH_CLASS_MAIN		3
#define ZEND_FETCH_CLASS_GLOBAL		4
#define ZEND_FETCH_CLASS_AUTO		5
#define ZEND_FETCH_CLASS_INTERFACE	6
#define ZEND_FETCH_CLASS_STATIC		7
#define ZEND_FETCH_CLASS_TRAIT		14
#define ZEND_FETCH_CLASS_MASK        0x0f
#define ZEND_FETCH_CLASS_NO_AUTOLOAD 0x80
#define ZEND_FETCH_CLASS_SILENT      0x0100

/* variable parsing type (compile-time) */
#define ZEND_PARSED_MEMBER				(1<<0)
#define ZEND_PARSED_METHOD_CALL			(1<<1)
#define ZEND_PARSED_STATIC_MEMBER		(1<<2)
#define ZEND_PARSED_FUNCTION_CALL		(1<<3)
#define ZEND_PARSED_VARIABLE			(1<<4)
#define ZEND_PARSED_REFERENCE_VARIABLE	(1<<5)
#define ZEND_PARSED_NEW					(1<<6)
#define ZEND_PARSED_LIST_EXPR			(1<<7)


/* unset types */
#define ZEND_UNSET_REG 0

/* var status for backpatching */
#define BP_VAR_R			0
#define BP_VAR_W			1
#define BP_VAR_RW			2
#define BP_VAR_IS			3
#define BP_VAR_NA			4	/* if not applicable */
#define BP_VAR_FUNC_ARG		5
#define BP_VAR_UNSET		6


#define ZEND_INTERNAL_FUNCTION				1
#define ZEND_USER_FUNCTION					2
#define ZEND_OVERLOADED_FUNCTION			3
#define	ZEND_EVAL_CODE						4
#define ZEND_OVERLOADED_FUNCTION_TEMPORARY	5

#define ZEND_INTERNAL_CLASS         1
#define ZEND_USER_CLASS             2

#define ZEND_EVAL				(1<<0)
#define ZEND_INCLUDE			(1<<1)
#define ZEND_INCLUDE_ONCE		(1<<2)
#define ZEND_REQUIRE			(1<<3)
#define ZEND_REQUIRE_ONCE		(1<<4)

#define ZEND_CT	(1<<0)
#define ZEND_RT (1<<1)

/* global/local fetches */
#define ZEND_FETCH_GLOBAL			0x00000000
#define ZEND_FETCH_LOCAL			0x10000000
#define ZEND_FETCH_STATIC			0x20000000
#define ZEND_FETCH_STATIC_MEMBER	0x30000000
#define ZEND_FETCH_GLOBAL_LOCK		0x40000000
#define ZEND_FETCH_LEXICAL			0x50000000

#define ZEND_FETCH_TYPE_MASK		0x70000000

#define ZEND_FETCH_STANDARD		    0x00000000
#define ZEND_FETCH_ADD_LOCK		    0x08000000
#define ZEND_FETCH_MAKE_REF		    0x04000000

#define ZEND_ISSET				    0x02000000
#define ZEND_ISEMPTY			    0x01000000
#define ZEND_ISSET_ISEMPTY_MASK	    (ZEND_ISSET | ZEND_ISEMPTY)
#define ZEND_QUICK_SET			    0x00800000

#define ZEND_FETCH_ARG_MASK         0x000fffff

#define ZEND_FE_FETCH_BYREF	1
#define ZEND_FE_FETCH_WITH_KEY	2

#define ZEND_FE_RESET_VARIABLE 		(1<<0)
#define ZEND_FE_RESET_REFERENCE		(1<<1)
#define EXT_TYPE_FREE_ON_RETURN		(1<<2)

#define ZEND_MEMBER_FUNC_CALL	1<<0

#define ZEND_ARG_SEND_BY_REF (1<<0)
#define ZEND_ARG_COMPILE_TIME_BOUND (1<<1)
#define ZEND_ARG_SEND_FUNCTION (1<<2)
#define ZEND_ARG_SEND_SILENT   (1<<3)

#define ZEND_SEND_BY_VAL     0
#define ZEND_SEND_BY_REF     1
#define ZEND_SEND_PREFER_REF 2

#define CHECK_ARG_SEND_TYPE(zf, arg_num, m1, m2)											\
	((zf) &&																				\
	  ((((zend_function*)(zf))->common.arg_info && 											\
	    arg_num <= ((zend_function*)(zf))->common.num_args) ?								\
	   (((zend_function *)(zf))->common.arg_info[arg_num-1].pass_by_reference & (m1)) :		\
       (((zend_function *)(zf))->common.fn_flags & (m2))))

#define ARG_MUST_BE_SENT_BY_REF(zf, arg_num) \
	CHECK_ARG_SEND_TYPE(zf, arg_num, ZEND_SEND_BY_REF, ZEND_ACC_PASS_REST_BY_REFERENCE)

#define ARG_SHOULD_BE_SENT_BY_REF(zf, arg_num) \
	CHECK_ARG_SEND_TYPE(zf, arg_num, ZEND_SEND_BY_REF|ZEND_SEND_PREFER_REF, ZEND_ACC_PASS_REST_BY_REFERENCE|ZEND_ACC_PASS_REST_PREFER_REF)

#define ARG_MAY_BE_SENT_BY_REF(zf, arg_num) \
	CHECK_ARG_SEND_TYPE(zf, arg_num, ZEND_SEND_PREFER_REF, ZEND_ACC_PASS_REST_PREFER_REF)

#define ZEND_RETURN_VAL 0
#define ZEND_RETURN_REF 1


#define ZEND_RETURNS_FUNCTION 1<<0
#define ZEND_RETURNS_NEW      1<<1

#define ZEND_FAST_RET_TO_CATCH		1
#define ZEND_FAST_RET_TO_FINALLY	2

#define ZEND_FAST_CALL_FROM_CATCH	1
#define ZEND_FAST_CALL_FROM_FINALLY	2

END_EXTERN_C()

#define ZEND_CLONE_FUNC_NAME		"__clone"
#define ZEND_CONSTRUCTOR_FUNC_NAME	"__construct"
#define ZEND_DESTRUCTOR_FUNC_NAME	"__destruct"
#define ZEND_GET_FUNC_NAME          "__get"
#define ZEND_SET_FUNC_NAME          "__set"
#define ZEND_UNSET_FUNC_NAME        "__unset"
#define ZEND_ISSET_FUNC_NAME        "__isset"
#define ZEND_CALL_FUNC_NAME         "__call"
#define ZEND_CALLSTATIC_FUNC_NAME   "__callstatic"
#define ZEND_TOSTRING_FUNC_NAME     "__tostring"
#define ZEND_AUTOLOAD_FUNC_NAME     "__autoload"
#define ZEND_INVOKE_FUNC_NAME       "__invoke"

/* The following constants may be combined in CG(compiler_options)
 * to change the default compiler behavior */

/* generate extended debug information */
#define ZEND_COMPILE_EXTENDED_INFO				(1<<0)

/* call op_array handler of extendions */
#define ZEND_COMPILE_HANDLE_OP_ARRAY            (1<<1)

/* generate ZEND_DO_FCALL_BY_NAME for internal functions instead of ZEND_DO_FCALL */
#define ZEND_COMPILE_IGNORE_INTERNAL_FUNCTIONS	(1<<2)

/* don't perform early binding for classes inherited form internal ones;
 * in namespaces assume that internal class that doesn't exist at compile-time
 * may apper in run-time */
#define ZEND_COMPILE_IGNORE_INTERNAL_CLASSES	(1<<3)

/* generate ZEND_DECLARE_INHERITED_CLASS_DELAYED opcode to delay early binding */
#define ZEND_COMPILE_DELAYED_BINDING			(1<<4)

/* disable constant substitution at compile-time */
#define ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION	(1<<5)

/* The default value for CG(compiler_options) */
#define ZEND_COMPILE_DEFAULT					ZEND_COMPILE_HANDLE_OP_ARRAY

/* The default value for CG(compiler_options) during eval() */
#define ZEND_COMPILE_DEFAULT_FOR_EVAL			0

#endif /* ZEND_COMPILE_H */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_config.h                              0100644 0001750 0001750 00000000153 12566220070 023704  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <../main/php_config.h>
#if defined(APACHE) && defined(PHP_API_VERSION)
#undef HAVE_DLFCN_H
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_config.nw.h                           0100644 0001750 0001750 00000004706 12566220066 024344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_CONFIG_NW_H
#define ZEND_CONFIG_NW_H


#include <string.h>
#include <float.h>

typedef unsigned long ulong;
typedef unsigned int uint;

#define HAVE_ALLOCA 1
#define HAVE_LIMITS_H 1
/* #include <malloc.h> */

#define HAVE_STRING_H 1
#define HAVE_SYS_SELECT_H 1
#define HAVE_STDLIB_H 1
#undef HAVE_KILL
#define HAVE_GETPID 1
/* #define HAVE_ALLOCA_H 1 */
#define HAVE_MEMCPY 1
#define HAVE_STRDUP 1
#define HAVE_SYS_TYPES_H 1
/* #define HAVE_STDIOSTR_H 1 */
#define HAVE_CLASS_ISTDIOSTREAM
#define istdiostream stdiostream
#define HAVE_STDARG_H	1
#define HAVE_DLFCN_H	1
/* #define HAVE_LIBDL 1 */
#define HAVE_SNPRINTF	1
#define HAVE_VSNPRINTF	1

/*
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#define zend_isinf(a)	0
#define zend_finite(x)	_finite(x)
#define zend_isnan(x)	_isnan(x)
*/

#define zend_sprintf sprintf

/* This will cause the compilation process to be MUCH longer, but will generate
 * a much quicker PHP binary
 */
/* 
#undef inline
#ifdef ZEND_WIN32_FORCE_INLINE
# define inline __forceinline
#else
# define inline
#endif
*/

/*
#define zend_finite(A) _finite(A)
#define zend_isnan(A) _isnan(A)
*/

#endif /* ZEND_CONFIG_NW_H */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_config.w32.h                          0100644 0001750 0001750 00000006307 12566220066 024332  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_CONFIG_W32_H
#define ZEND_CONFIG_W32_H

#include <../main/config.w32.h>

#define _CRTDBG_MAP_ALLOC

#include <malloc.h>
#include <stdlib.h>
#include <crtdbg.h>

#include <string.h>

#ifndef ZEND_INCLUDE_FULL_WINDOWS_HEADERS
#define WIN32_LEAN_AND_MEAN
#endif
#include <winsock2.h>
#include <windows.h>

#include <float.h>

typedef unsigned long ulong;
typedef unsigned int uint;

#define HAVE_STDIOSTR_H 1
#define HAVE_CLASS_ISTDIOSTREAM
#define istdiostream stdiostream

#define snprintf _snprintf
#if _MSC_VER < 1500
#define vsnprintf _vsnprintf
#endif
#define strcasecmp(s1, s2) stricmp(s1, s2)
#define strncasecmp(s1, s2, n) strnicmp(s1, s2, n)
#define zend_isinf(a)	((_fpclass(a) == _FPCLASS_PINF) || (_fpclass(a) == _FPCLASS_NINF))
#define zend_finite(x)	_finite(x)
#define zend_isnan(x)	_isnan(x)

#define zend_sprintf sprintf

/* This will cause the compilation process to be MUCH longer, but will generate
 * a much quicker PHP binary
 */
#ifdef ZEND_WIN32_FORCE_INLINE
/* _ALLOW_KEYWORD_MACROS is only relevant for C++ */
# if (_MSC_VER >= 1700) && !defined(_ALLOW_KEYWORD_MACROS)
#  define _ALLOW_KEYWORD_MACROS
# endif
# undef inline
# define inline __forceinline
#elif !defined(ZEND_WIN32_KEEP_INLINE)
# undef inline
# define inline
#endif

#ifdef LIBZEND_EXPORTS
#	define ZEND_API __declspec(dllexport)
#else
#	define ZEND_API __declspec(dllimport)
#endif

#define ZEND_DLEXPORT		__declspec(dllexport)
#define ZEND_DLIMPORT		__declspec(dllimport)

/* 0x00200000L is MB_SERVICE_NOTIFICATION, which is only supported under Windows NT
 * (and requires _WIN32_WINNT to be defined, which prevents the resulting executable
 * from running under Windows 9x
 * Windows 9x should silently ignore it, so it's being used here directly
 */
#ifndef MB_SERVICE_NOTIFICATION
#define	MB_SERVICE_NOTIFICATION		0x00200000L
#endif

#define ZEND_SERVICE_MB_STYLE		(MB_TOPMOST|MB_SERVICE_NOTIFICATION)

#endif /* ZEND_CONFIG_W32_H */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_constants.h                           0100644 0001750 0001750 00000011755 12566220066 024472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_CONSTANTS_H
#define ZEND_CONSTANTS_H

#include "zend_globals.h"

#define CONST_CS				(1<<0)				/* Case Sensitive */
#define CONST_PERSISTENT		(1<<1)				/* Persistent */
#define CONST_CT_SUBST			(1<<2)				/* Allow compile-time substitution */

#define	PHP_USER_CONSTANT INT_MAX	/* a constant defined in user space */

typedef struct _zend_constant {
	zval value;
	int flags;
	char *name;
	uint name_len;
	int module_number;
} zend_constant;

#define REGISTER_LONG_CONSTANT(name, lval, flags)  zend_register_long_constant((name), sizeof(name), (lval), (flags), module_number TSRMLS_CC)
#define REGISTER_DOUBLE_CONSTANT(name, dval, flags)  zend_register_double_constant((name), sizeof(name), (dval), (flags), module_number TSRMLS_CC)
#define REGISTER_STRING_CONSTANT(name, str, flags)  zend_register_string_constant((name), sizeof(name), (str), (flags), module_number TSRMLS_CC)
#define REGISTER_STRINGL_CONSTANT(name, str, len, flags)  zend_register_stringl_constant((name), sizeof(name), (str), (len), (flags), module_number TSRMLS_CC)

#define REGISTER_NS_LONG_CONSTANT(ns, name, lval, flags)  zend_register_long_constant(ZEND_NS_NAME(ns, name), sizeof(ZEND_NS_NAME(ns, name)), (lval), (flags), module_number TSRMLS_CC)
#define REGISTER_NS_DOUBLE_CONSTANT(ns, name, dval, flags)  zend_register_double_constant(ZEND_NS_NAME(ns, name), sizeof(ZEND_NS_NAME(ns, name)), (dval), (flags), module_number TSRMLS_CC)
#define REGISTER_NS_STRING_CONSTANT(ns, name, str, flags)  zend_register_string_constant(ZEND_NS_NAME(ns, name), sizeof(ZEND_NS_NAME(ns, name)), (str), (flags), module_number TSRMLS_CC)
#define REGISTER_NS_STRINGL_CONSTANT(ns, name, str, len, flags)  zend_register_stringl_constant(ZEND_NS_NAME(ns, name), sizeof(ZEND_NS_NAME(ns, name)), (str), (len), (flags), module_number TSRMLS_CC)

#define REGISTER_MAIN_LONG_CONSTANT(name, lval, flags)  zend_register_long_constant((name), sizeof(name), (lval), (flags), 0 TSRMLS_CC)
#define REGISTER_MAIN_DOUBLE_CONSTANT(name, dval, flags)  zend_register_double_constant((name), sizeof(name), (dval), (flags), 0 TSRMLS_CC)
#define REGISTER_MAIN_STRING_CONSTANT(name, str, flags)  zend_register_string_constant((name), sizeof(name), (str), (flags), 0 TSRMLS_CC)
#define REGISTER_MAIN_STRINGL_CONSTANT(name, str, len, flags)  zend_register_stringl_constant((name), sizeof(name), (str), (len), (flags), 0 TSRMLS_CC)

BEGIN_EXTERN_C()
void clean_module_constants(int module_number TSRMLS_DC);
void free_zend_constant(zend_constant *c);
int zend_startup_constants(TSRMLS_D);
int zend_shutdown_constants(TSRMLS_D);
void zend_register_standard_constants(TSRMLS_D);
void clean_non_persistent_constants(TSRMLS_D);
ZEND_API int zend_get_constant(const char *name, uint name_len, zval *result TSRMLS_DC);
ZEND_API int zend_get_constant_ex(const char *name, uint name_len, zval *result, zend_class_entry *scope, ulong flags TSRMLS_DC);
ZEND_API void zend_register_long_constant(const char *name, uint name_len, long lval, int flags, int module_number TSRMLS_DC);
ZEND_API void zend_register_double_constant(const char *name, uint name_len, double dval, int flags, int module_number TSRMLS_DC);
ZEND_API void zend_register_string_constant(const char *name, uint name_len, char *strval, int flags, int module_number TSRMLS_DC);
ZEND_API void zend_register_stringl_constant(const char *name, uint name_len, char *strval, uint strlen, int flags, int module_number TSRMLS_DC);
ZEND_API int zend_register_constant(zend_constant *c TSRMLS_DC);
void zend_copy_constants(HashTable *target, HashTable *sourc);
void copy_zend_constant(zend_constant *c);
zend_constant *zend_quick_get_constant(const zend_literal *key, ulong flags TSRMLS_DC);
END_EXTERN_C()

#define ZEND_CONSTANT_DTOR (void (*)(void *)) free_zend_constant

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                   osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_dtrace.h                              0100644 0001750 0001750 00000004000 12566220066 023701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2009 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: David Soria Parra <david.soriaparra@sun.com>                |
   +----------------------------------------------------------------------+
*/

/* $Id: $ */

#ifndef	_ZEND_DTRACE_H
#define	_ZEND_DTRACE_H

#ifndef ZEND_WIN32
# include <unistd.h>
#endif

#ifdef	__cplusplus
extern "C" {
#endif

#ifdef HAVE_DTRACE
ZEND_API zend_op_array *(*zend_dtrace_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);
ZEND_API void (*zend_dtrace_execute)(zend_op_array *op_array TSRMLS_DC);
ZEND_API void (*zend_dtrace_execute_internal)(zend_execute_data *execute_data_ptr, zend_fcall_info *fci, int return_value_used TSRMLS_DC);

ZEND_API zend_op_array *dtrace_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC);
ZEND_API void dtrace_execute_ex(zend_execute_data *execute_data TSRMLS_DC);
ZEND_API void dtrace_execute_internal(zend_execute_data *execute_data_ptr, zend_fcall_info *fci, int return_value_used TSRMLS_DC);
#include <zend_dtrace_gen.h>

#endif /* HAVE_DTRACE */

#ifdef	__cplusplus
}
#endif

#endif	/* _ZEND_DTRACE_H */
osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_dynamic_array.h                       0100644 0001750 0001750 00000003562 12566220066 025275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_DYNAMIC_ARRAY_H
#define ZEND_DYNAMIC_ARRAY_H

typedef struct _dynamic_array {
	char *array;
	unsigned int element_size;
	unsigned int last_used;
	unsigned int allocated;
} dynamic_array;

BEGIN_EXTERN_C()
ZEND_API int zend_dynamic_array_init(dynamic_array *da, unsigned int element_size, unsigned int size);
ZEND_API void *zend_dynamic_array_push(dynamic_array *da);
ZEND_API void *zend_dynamic_array_pop(dynamic_array *da);
ZEND_API void *zend_dynamic_array_get_element(dynamic_array *da, unsigned int index);
END_EXTERN_C()

#endif /* ZEND_DYNAMIC_ARRAY_H */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/include/php/Zend/zend_errors.h                              0100644 0001750 0001750 00000004157 12566220066 023770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifndef ZEND_ERRORS_H
#define ZEND_ERRORS_H

#define E_ERROR				(1<<0L)
#define E_WARNING			(1<<1L)
#define E_PARSE				(1<<2L)
#define E_NOTICE			(1<<3L)
#define E_CORE_ERROR		(1<<4L)
#define E_CORE_WARNING		(1<<5L)
#define E_COMPILE_ERROR		(1<<6L)
#define E_COMPILE_WARNING	(1<<7L)
#define E_USER_ER