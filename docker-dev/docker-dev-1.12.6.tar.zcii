-------------------
/* DataTypes for _ICD_ReadFileData/_ICD_WriteFileData */

enum {
    kICS_FileData                 = 'file',
    kICS_MetaData                 = 'meta',
    kICS_ThumbnailData            = 'thum',     // Deprecated in 10.5
    kICS_ThumbnailDataFormatJPEG  = 'tjpg',     // Deprecated in 10.5.
                                                // Use kICAThumbnailFormatJPEG or kICAThumbnailFormatJPEGAutoRotated instead.
    kICS_ThumbnailDataFormatTIFF  = 'ttif',     // Deprecated in 10.5.
                                                // Use kICAThumbnailFormatTIFF or kICAThumbnailFormatTIFFAutoRotated instead.
    kICS_ThumbnailDataFormatPNG   = 'tpng'      // Deprecated in 10.5. 
                                                // Use kICAThumbnailFormatPNG instead.
};

//------------------------------------------------------------------------------------------------------------------------------

typedef struct ScannerObjectInfo
{
    ICAObject		icaObject;			// Apple
    unsigned long	reserved;			// Apple
    ICAObjectInfo 	icaObjectInfo;		// vendor
    UInt32			uniqueID;			// vendor
    UInt64			uniqueIDFireWire;	// vendor
    UInt32			thumbnailSize;		// vendor
    UInt32			dataSize;			// vendor
    UInt32 			dataWidth;			// vendor
    UInt32 			dataHeight;			// vendor
    UInt8			name[32];			// vendor
    UInt8			creationDate[20];	// vendor
    UInt32			flags;				// vendor
    Ptr				privateData;		// vendor
    UInt32          tag;                // Apple
} ScannerObjectInfo;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerObjectSendMessagePB {
    ICDHeader                       header;

    ICAObject                       object;                     /* <-- */
    ICAObjectInfo                   objectInfo;     		    /* <-- */
    ICAConnectionID            	  	connectionID;               /* <-- */
    ICAMessage                      message;                    /* <-- */
    UInt32                          totalDataSize;              /* <-- */
    UInt32                      	result;                     /* --> */
};
typedef struct ICD_ScannerObjectSendMessagePB  ICD_ScannerObjectSendMessagePB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerOpenSessionPB {
    ICDHeader               header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID  	sessionID;             	/* <-- */
};
typedef struct ICD_ScannerOpenSessionPB    ICD_ScannerOpenSessionPB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerCloseSessionPB {
    ICDHeader               header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID  	sessionID;              /* <-- */
};
typedef struct ICD_ScannerCloseSessionPB    ICD_ScannerCloseSessionPB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerInitializePB {
    ICDHeader             	header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID  	sessionID;             	/* <-- */
};
typedef struct ICD_ScannerInitializePB    ICD_ScannerInitializePB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerGetParametersPB {
    ICDHeader         		header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID		sessionID;             	/* <-- */
    CFMutableDictionaryRef	theDict;               	/* <-> */
};
typedef struct ICD_ScannerGetParametersPB    ICD_ScannerGetParametersPB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerSetParametersPB {
    ICDHeader          		header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID		sessionID;             	/* <-- */
    CFMutableDictionaryRef	theDict;               	/* <-> */
};
typedef struct ICD_ScannerSetParametersPB    ICD_ScannerSetParametersPB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerStatusPB {
    ICDHeader               header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID  	sessionID;             	/* <-- */
    UInt32	  				status;             	/* --> */
};
typedef struct ICD_ScannerStatusPB    ICD_ScannerStatusPB;

//------------------------------------------------------------------------------------------------------------------------------

struct ICD_ScannerStartPB {
    ICDHeader           	header;
    ICAObject           	object;                	/* <-- */
    ICAObjectInfo         	objectInfo;     	   	/* <-- */
    ICAConnectionID       	connectionID;        	/* <-- */
    ICAScannerSessionID  	sessionID;             	/* <-- */
};
typedef struct ICD_ScannerStartPB    ICD_ScannerStartPB;

//------------------------------------------------------------------------------------------------------------------------------

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenUSBDevice)
                                    (UInt32 locationID, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenUSBDeviceWithIORegPath)
                                    (UInt32 locationID, io_string_t ioregPath, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenFireWireDevice)
                                    (UInt64 guid, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenFireWireDeviceWithIORegPath)
                                    (UInt64 guid, io_string_t ioregPath, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenBluetoothDevice)
                                    (CFDictionaryRef params, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenTCPIPDevice)
                                    (CFDictionaryRef params, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenMassStorageDevice)
                                    (CFStringRef diskBSDName, DASessionRef daSession, ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerCloseDevice)
                                    (ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerPeriodicTask)
                                    (ScannerObjectInfo* objectInfo);

/* index is zero based */
typedef CALLBACK_API_C(ICAError, __ICD_ScannerGetObjectInfo)
                                    (const ScannerObjectInfo* parentInfo, UInt32 index, ScannerObjectInfo* newInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerCleanup)
                                    (ScannerObjectInfo* objectInfo);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerGetPropertyData)
                                    (const ScannerObjectInfo* objectInfo, void* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerSetPropertyData)
                                    (const ScannerObjectInfo* objectInfo, const void* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerReadFileData)
                                    (const ScannerObjectInfo* objectInfo, UInt32 dataType, Ptr buffer, UInt32 offset, UInt32* length);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerWriteFileData)
                                    (const ScannerObjectInfo* parentInfo, const char* filename, UInt32 dataType, Ptr buffer, UInt32 offset, UInt32* length);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerSendMessage)
                                    (const ScannerObjectInfo* objectInfo, ICD_ScannerObjectSendMessagePB* pb, ICDCompletion completion);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerAddPropertiesToCFDictionary)
                                    (ScannerObjectInfo* objectInfo, CFMutableDictionaryRef dict);
// scanner specific
typedef CALLBACK_API_C(ICAError, __ICD_ScannerOpenSession)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerOpenSessionPB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerCloseSession)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerCloseSessionPB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerInitialize)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerInitializePB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerGetParameters)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerGetParametersPB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerSetParameters)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerSetParametersPB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerStatus)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerStatusPB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerStart)
                                    (const ScannerObjectInfo* deviceObjectInfo, ICD_ScannerStartPB* pb);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerWriteDataToFile)
                                      (const ScannerObjectInfo* objectInfo, FILE* file, UInt32 offset, long* length);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerWriteDataToFileDescriptor)
                                      (const ScannerObjectInfo* objectInfo, int fd, UInt32 offset, long* length);

typedef CALLBACK_API_C(ICAError, __ICD_ScannerWriteDataToFileDescriptor64)
                                      (const ScannerObjectInfo* objectInfo, int fd);

	
//------------------------------------------------------------------------------------------------------------------------------

// callback functions
typedef struct ICD_Scannerscanner_callback_functions
{
    __ICD_ScannerOpenUSBDevice  					f_ICD_ScannerOpenUSBDevice;
    __ICD_ScannerOpenUSBDeviceWithIORegPath			f_ICD_ScannerOpenUSBDeviceWithIORegPath;
    __ICD_ScannerCloseDevice 						f_ICD_ScannerCloseDevice;
    __ICD_ScannerPeriodicTask						f_ICD_ScannerPeriodicTask;
    __ICD_ScannerGetObjectInfo						f_ICD_ScannerGetObjectInfo;
    __ICD_ScannerCleanup							f_ICD_ScannerCleanup;
    __ICD_ScannerGetPropertyData					f_ICD_ScannerGetPropertyData;
    __ICD_ScannerSetPropertyData					f_ICD_ScannerSetPropertyData;
    __ICD_ScannerReadFileData						f_ICD_ScannerReadFileData;
    __ICD_ScannerWriteFileData						f_ICD_ScannerWriteFileData;
    __ICD_ScannerSendMessage						f_ICD_ScannerSendMessage;
    __ICD_ScannerAddPropertiesToCFDictionary 		f_ICD_ScannerAddPropertiesToCFDictionary;
    __ICD_ScannerOpenFireWireDevice  				f_ICD_ScannerOpenFireWireDevice;
    __ICD_ScannerOpenFireWireDeviceWithIORegPath	f_ICD_ScannerOpenFireWireDeviceWithIORegPath;

    __ICD_ScannerOpenSession						f_ICD_ScannerOpenSession;
    __ICD_ScannerCloseSession						f_ICD_ScannerCloseSession;
    __ICD_ScannerInitialize							f_ICD_ScannerInitialize;
    __ICD_ScannerGetParameters						f_ICD_ScannerGetParameters;
    __ICD_ScannerSetParameters						f_ICD_ScannerSetParameters;
    __ICD_ScannerStatus								f_ICD_ScannerStatus;
    __ICD_ScannerStart								f_ICD_ScannerStart;
    __ICD_ScannerOpenBluetoothDevice                f_ICD_ScannerOpenBluetoothDevice;
    __ICD_ScannerOpenTCPIPDevice                    f_ICD_ScannerOpenTCPIPDevice;
    __ICD_ScannerWriteDataToFile                    f_ICD_ScannerWriteDataToFile;
    __ICD_ScannerOpenMassStorageDevice              f_ICD_ScannerOpenMassStorageDevice;
    __ICD_ScannerWriteDataToFileDescriptor          f_ICD_ScannerWriteDataToFileDescriptor;
    __ICD_ScannerWriteDataToFileDescriptor64        f_ICD_ScannerWriteDataToFileDescriptor64;	
} ICD_scanner_callback_functions;

extern ICD_scanner_callback_functions gICDScannerCallbackFunctions;

//------------------------------------------------------------------------------------------------------------------------------


// scanner related callBacks into the ICADevices.framework:
int ICD_ScannerMain (int argc, const char* argv[]);

ICAError ICDScannerGetStandardPropertyData(const ScannerObjectInfo* objectInfo, void* pb);

ICAError ICDScannerNewObjectInfoCreated(const ScannerObjectInfo* parentInfo, UInt32 index, ICAObject* newICAObject);

ICAError ICDScannerCopyDeviceInfoDictionary(const char*		deviceName,		// name of the device (from device's objectInfo)
                                         CFDictionaryRef*	theDict);		// this CFDictionaryRef contains information about the camera, e.g. the icon file,...

ICAError ICDScannerCreateICAThumbnailFromICNS( const char* fileName, void* thumbnail ) DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

//Use ICDSendNotification or ICDSendNotificationAndWaitForReply instead of ICDInitiateNotificationCallback
ICAError ICDScannerInitiateNotificationCallback(const void* pb)                   DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

ICAError ICDScannerCreateEventDataCookie(const ICAObject object, ICAEventDataCookie* cookie);

//------------------------------------------------------------------------------------------------------------------------------
// USB
ICAError ICDScannerConnectUSBDevice(UInt32 locationID);
ICAError ICDScannerConnectUSBDeviceWithIORegPath(UInt32 locationID, io_string_t ioregPath);

ICAError ICDScannerDisconnectUSBDevice(UInt32 locationID);
ICAError ICDScannerDisconnectUSBDeviceWithIORegPath(UInt32 locationID, io_string_t ioregPath);

//------------------------------------------------------------------------------------------------------------------------------
// FireWire
ICAError ICDScannerConnectFWDevice(UInt64 guid);
ICAError ICDScannerConnectFWDeviceWithIORegPath(UInt64 guid, io_string_t ioregPath);

ICAError ICDScannerDisconnectFWDevice(UInt64 guid);
ICAError ICDScannerDisconnectFWDeviceWithIORegPath(UInt64 guid, io_string_t ioregPath);

//------------------------------------------------------------------------------------------------------------------------------
// Bluetooth

ICAError ICDScannerConnectBluetoothDevice(CFDictionaryRef params);
ICAError ICDScannerDisconnectBluetoothDevice(CFDictionaryRef params);

//------------------------------------------------------------------------------------------------------------------------------
// TCP/IP

ICAError ICDScannerConnectTCPIPDevice(CFDictionaryRef params);
ICAError ICDScannerDisconnectTCPIPDevice(CFDictionaryRef params);

//------------------------------------------------------------------------------------------------------------------------------

#pragma pack(pop)

#ifdef __cplusplus
}
#endif

//------------------------------------------------------------------------------------------------------------------------------
                                                                    ICADevices.tbd                                                                                      0100644 0001750 0001750 00000103245 12571375064 032551  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/ICADevices.framework/Versions/A                                                                          ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/ICADevices.framework/Versions/A/ICADevices
exports:         
  - archs:           [ i386 ]
    symbols:         [ __Z16DoMacho2CFMMagicv, __Z45NewMachOFunctionPointerFromCFMFunctionPointerPc, 
                       __ZN10ICACommandC1EPFvP9ICAHeaderEPhmPK10__CFString, 
                       __ZN10ICACommandC2EPFvP9ICAHeaderEPhmPK10__CFString, 
                       __ZN22ICASendNotificationImpC1EP21ICASendNotificationPBm, 
                       __ZN22ICASendNotificationImpC2EP21ICASendNotificationPBm ]
  - archs:           [ x86_64 ]
    symbols:         [ __ZN10ICACommandC1EPFvP9ICAHeaderEPhjPK10__CFString, 
                       __ZN10ICACommandC2EPFvP9ICAHeaderEPhjPK10__CFString, 
                       __ZN22ICASendNotificationImpC1EP21ICASendNotificationPBj, 
                       __ZN22ICASendNotificationImpC2EP21ICASendNotificationPBj ]
    objc-ivars:      [ _BaseObjectImp._gotMetadata, _BaseObjectImp._lockObject, 
                       _BaseObjectImp._metadata, _BaseObjectImp.m_ICAObject, 
                       _BaseObjectImp.m_ObjectDict, _BaseObjectImp.m_ObjectInfoSize, 
                       _BaseObjectImp.m_ObjectInformation, _BaseObjectImp.m_cleanUpCalled, 
                       _BaseObjectImp.m_parent, _BaseObjectImp.m_saveFSRef, 
                       _BaseObjectImp.m_savePath, _BluetoothDevice._bluetoothAddress, 
                       _BluetoothDevice._params, _Device._IORegPath, _Device._autoDisconnect, 
                       _Device._bufferSizeForMetadata, _Device._clientAppPIDs, 
                       _Device._colorSyncMode, _Device._colorSyncProfiles, 
                       _Device._connectionID, _Device._deleteCanceled, 
                       _Device._deviceIconPath, _Device._deviceProfileHandler, 
                       _Device._disconnectIfSessionNotOpened, _Device._disconnectTime, 
                       _Device._isBeingDisconnected, _Device._isOpened, 
                       _Device._modulePath, _Device._moduleVersion, _Device._persistentID, 
                       _Device._timer, _Device._transportType, _Device._userAssignedName, 
                       _Device._userAssignedNameLock, _Device._usesLegacyKeys, 
                       _Device._uuid, _FireWireDevice._guid, _ICDBaseCommandImp._commandData, 
                       _ICDBaseCommandImp._commandError, _ICDBaseCommandImp._incomingAppleEvent, 
                       _ICDBaseCommandImp._name, _ICDBaseCommandImp._objectPriv, 
                       _ICDBaseCommandImp._privateData, _ICDCopyObjectDataImp._bufferPtr, 
                       _ICDCopyObjectDataImp._bufferSize, _ICDCopyObjectDataImp._deleteAfterGetData, 
                       _ICDCopyObjectThumbnailImp._thumbnailBufferPtr, 
                       _ICDCopyObjectThumbnailImp._thumbnailBufferSize, 
                       _ICDGetPropertyDataImp._deleteAfterGetData, _ICDGetPropertyDataImp._getPropertyDataPB, 
                       _ICDObjectSendMessageImp._objectSendMessagePB, _ICDScannerCloseSessionImp._scannerCloseSessionPB, 
                       _ICDScannerGetParametersImp._scannerGetParametersPB, 
                       _ICDScannerInitializeImp._scannerInitializePB, _ICDScannerOpenSessionImp._scannerOpenSessionPB, 
                       _ICDScannerSetParametersImp._scannerSetParametersPB, 
                       _ICDScannerStartImp._scannerStartPB, _ICDScannerStatusImp._scannerStatusPB, 
                       _ICDSendPTPCmdImp._dataDict, _ICDataBuffer2._buffer, 
                       _ICDataBuffer2._type, _MassStorageDevice._diskBSDName, 
                       _Profile._header, _Profile._name, _Profile._ref, 
                       _TCPIPDevice._bonjourDeviceLocation, _TCPIPDevice._bonjourServiceDomain, 
                       _TCPIPDevice._bonjourServiceName, _TCPIPDevice._bonjourServiceType, 
                       _TCPIPDevice._bonjourTXTRecord, _TCPIPDevice._netService, 
                       _TCPIPDevice._params, _TCPIPDevice._resolveFailed, 
                       _TCPIPDevice._resolved, _TCPIPDevice._targetHostname, 
                       _TCPIPDevice._targetIPAddress, _TCPIPDevice._targetIPPort, 
                       _TWAINDevice._guid, _TWAINDevice._locationID, _TWAINDevice._twainPath, 
                       _TWAINDevice._usbProductID, _TWAINDevice._usbSerialNumberString, 
                       _TWAINDevice._usbVendorID, _USBDevice._IOUSBDeviceIOServicePath, 
                       _USBDevice._locationID, _USBDevice._usbProductID, 
                       _USBDevice._usbSerialNumberString, _USBDevice._usbVendorID, 
                       __DirectoryObject.m_children ]
  - archs:           [ i386, x86_64 ]
    re-exports:      [ /usr/lib/libobjc.A.dylib ]
    symbols:         [ _CanTerminate, _ClientDiedCallback, _DebugLog, _DisconnectFWDevice, 
                       _DisconnectFWDeviceWithIORegPath, _DisconnectFWDeviceWithTwainDS, 
                       _DisconnectMassStorageDevice, _DisconnectUSBDevice, 
                       _DisconnectUSBDeviceWithIORegPath, _DisconnectUSBDeviceWithTwainDS, 
                       _FWDeviceSendScanEventNotification, _ICAAESendMessage, 
                       _ICAAddDataPtrToAppleEvent, _ICAAddDataToAppleEvent, 
                       _ICAApplicationMain, _ICAConvertJPEGDataToICADataInPlace, 
                       _ICAConvertTIFFDataToICADataInPlace, _ICACreateCutsomIconForImageAtPath, 
                       _ICACreateDataPtrFromAppleEvent, _ICACreateJPEGThumbnailDataFromURL, 
                       _ICADictionaryApplierFunction, _ICAElapsedTime, 
                       _ICAGetApplicationSupportPath, _ICAGetAttrFromAppleEvent, 
                       _ICAGetDataFromAppleEvent, _ICAGetDateFromSeconds, 
                       _ICAGetDateFromSecondsSince1904, _ICAGetDateFromSecondsSince1970, 
                       _ICAGetEXIFDateCStringFromSecondsSince1904, _ICAGetEXIFDateCStringFromSecondsSince1970, 
                       _ICAGetEXIFUTCDateCStringFromSecondsSince1904, _ICAGetEXIFUTCDateCStringFromSecondsSince1970, 
                       _ICAGetICAObjectForFile, _ICAGetICAObjectFromDict, 
                       _ICAGetLongValueFromDict, _ICAGetSInt16ValueFromDict, 
                       _ICAGetSInt32ValueFromDict, _ICAGetSInt64ValueFromDict, 
                       _ICAGetUTCDateFromDateCString, _ICAGetUTCDateFromSeconds, 
                       _ICAGetUTCDateFromSecondsSince1904, _ICAGetUTCDateFromSecondsSince1970, 
                       _ICALaunchImageCaptureExtension, _ICALoadDeviceModule, 
                       _ICALoadDeviceModule_Deprecated, _ICAScannerCloseSession, 
                       _ICAScannerCloseSession_Deprecated, _ICASendNotification, 
                       _ICASendNotificationAndWaitForReply, _ICASendNotificationAndWaitForReply_Deprecated, 
                       _ICASendNotification_Deprecated, _ICASetFinderComment, 
                       _ICASetICAObjectInDict, _ICASetLongValueInDict, 
                       _ICASetSInt16ValueInDict, _ICASetSInt32ValueInDict, 
                       _ICASetSInt64ValueInDict, _ICASetUTF8StringInDict, 
                       _ICAUnloadDeviceModule, _ICAUnloadDeviceModule_Deprecated, 
                       _ICDAddBandInfoToNotificationDictionary, _ICDAddImageInfoToNotificationDictionary, 
                       _ICDAddScannedImageMetaDataToFinderComment, _ICDBulkNewObject, 
                       _ICDBulkNewProperty, _ICDCanTerminate, _ICDConnectBluetoothDevice, 
                       _ICDConnectFWDevice, _ICDConnectFWDeviceWithIORegPath, 
                       _ICDConnectMassStorageDevice, _ICDConnectTCPIPDevice, 
                       _ICDConnectTWAIN_DS, _ICDConnectUSBDevice, _ICDConnectUSBDeviceWithIORegPath, 
                       _ICDConvertJPEGDataToPNGDataInPlace, _ICDConvertJPEGDataToTIFFDataInPlace, 
                       _ICDConvertRGB8DataToJPEGDataInPlace, _ICDConvertTIFFDataToJPEGDataInPlace, 
                       _ICDConvertTIFFDataToPNGDataInPlace, _ICDCopyDeviceInfoDictionary, 
                       _ICDCopyDeviceInfoDictionaryForDeviceName, _ICDCopyDeviceInfoDictionaryForUSBProductID, 
                       _ICDCopyPropertiesOfIOServiceWithLocationID, _ICDCopyTemporaryDirectoryPath, 
                       _ICDCreateColorSpace, _ICDCreateCutsomIcon, _ICDCreateDeviceColorSyncProfileWithAbstractAtPath, 
                       _ICDCreateEventDataCookie, _ICDCreateGPSDictionaryFromString, 
                       _ICDCreateICAThumbnailFromICNS, _ICDCreateICAThumbnailFromIconRef, 
                       _ICDCreateIconFilePathForDevice, _ICDCreateJPEGThumbnailDataFromJPEGData, 
                       _ICDCreateJPEGThumbnailForMovieAtPath, _ICDCreateLargeJPEGThumbnailForMovieAtPath, 
                       _ICDCreatePropertiesForMovieAtPath, _ICDCreateThumbnailFromBitmapContext, 
                       _ICDCreateThumbnailFromIconFile, _ICDDeleteCacheFolder, 
                       _ICDDeviceHasClients, _ICDDeviceNotification, _ICDDeviceRegister, 
                       _ICDDeviceUnRegister, _ICDDeviceYieldAndInstallIOKitNotificationHandler, 
                       _ICDDeviceYieldIOKitNotificationHandler, _ICDDisableSuddenTermination, 
                       _ICDDisconnectBluetoothDevice, _ICDDisconnectFWDevice, 
                       _ICDDisconnectFWDeviceWithIORegPath, _ICDDisconnectMassStorageDevice, 
                       _ICDDisconnectTCPIPDevice, _ICDDisconnectTWAIN_DS, 
                       _ICDDisconnectUSBDevice, _ICDDisconnectUSBDeviceWithIORegPath, 
                       _ICDDisposeObject, _ICDDisposeProperty, _ICDEnableSuddenTermination, 
                       _ICDGetColorSyncProfilePathForMode, _ICDGetDeviceThumbnail, 
                       _ICDGetStandardPropertyData, _ICDInitiateNotificationCallback, 
                       _ICDInitiateNotificationCallbackWithData, _ICDNewObject, 
                       _ICDNewObjectCreated, _ICDNewObjectInfoCreated, 
                       _ICDNewProperty, _ICDScanForDevices, _ICDScannerConnectBluetoothDevice, 
                       _ICDScannerConnectFWDevice, _ICDScannerConnectFWDeviceWithIORegPath, 
                       _ICDScannerConnectTCPIPDevice, _ICDScannerConnectUSBDevice, 
                       _ICDScannerConnectUSBDeviceWithIORegPath, _ICDScannerCopyDeviceInfoDictionary, 
                       _ICDScannerCreateEventDataCookie, _ICDScannerCreateICAThumbnailFromICNS, 
                       _ICDScannerDeviceYieldAndInstallIOKitNotificationHandler, 
                       _ICDScannerDeviceYieldIOKitNotificationHandler, 
                       _ICDScannerDisconnectBluetoothDevice, _ICDScannerDisconnectFWDevice, 
                       _ICDScannerDisconnectFWDeviceWithIORegPath, _ICDScannerDisconnectTCPIPDevice, 
                       _ICDScannerDisconnectUSBDevice, _ICDScannerDisconnectUSBDeviceWithIORegPath, 
                       _ICDScannerGetStandardPropertyData, _ICDScannerInitiateNotificationCallback, 
                       _ICDScannerInitiateNotificationCallbackWithData, 
                       _ICDScannerNewObjectInfoCreated, _ICDSendNotification, 
                       _ICDSendNotificationAndWaitForReply, _ICDStatusChanged, 
                       _ICDTerminate, _ICD_ScannerMain, _ICD_main, _ICLoggingEnabled, 
                       _ICLoggingLevelBasicInfo, _ICLoggingLevelError, 
                       _ICLoggingLevelMask, _ICLoggingLevelTimingInfo, 
                       _ICLoggingLevelVerboseInfo, _ICLoggingLevelWarning, 
                       _ICRegisterForProcessDeath, _InitDeviceCalls, _LogoutExit, 
                       _NewFWDevice, _NewFWDeviceWithIORegPath, _NewFWDeviceWithTwainDS, 
                       _NewMassStorageDevice, _NewUSBDevice, _NewUSBDeviceWithIORegPath, 
                       _NewUSBDeviceWithTwainDS, _PostDeviceParam, _SendDeviceArrivalNotification, 
                       _SendDeviceRemovedNotification, _SendDeviceResetNotification, 
                       _StartListeningToICDDMessages, _USBDeviceSendScanEventNotification, 
                       _UnpostDeviceParam, __AddPropertiesToCFDictionary, 
                       __AgentDiedCallback, __ByteSwaptPTPEventDatabase, 
                       __ByteSwaptPTPPassThroughPB, __Cleanup, __CloseDevice, 
                       __DisconnectTWAINDS, __GetObjectInfo, __GetPropertyData, 
                       __ICALaunchImageCaptureExtension, __ICDCreatePropertiesForMovie, 
                       __ICDDeviceYieldAndInstallIOKitNotificationHandler, 
                       __ICDDeviceYieldIOKitNotificationHandler, __ICGetPIDForProcess, 
                       __ICRegisterForProcessDeath, __NewTWAINDS, __OpenBluetoothDevice, 
                       __OpenFireWireDevice, __OpenFireWireDeviceWithIORegPath, 
                       __OpenMassStorageDevice, __OpenTCPIPDevice, __OpenUSBDevice, 
                       __OpenUSBDeviceWithIORegPath, __PeriodicTask, __ReadFileData, 
                       __ScannerCloseSession, __ScannerGetParameters, __ScannerInitialize, 
                       __ScannerOpenSession, __ScannerSetParameters, __ScannerStart, 
                       __ScannerStatus, __SendMessage, __SetPropertyData, 
                       __WriteDataToFile, __WriteDataToFileDescriptor, 
                       __WriteDataToFileDescriptor64, __WriteFileData, 
                       __ZN10ICACommand14AddCommandDataEv, __ZN10ICACommand14PrepareCommandEv, 
                       __ZN10ICACommand14ProcessCommandEv, __ZN10ICACommand15CompleteCommandEPK6AEDescPK14__CFDictionaryS5_, 
                       __ZN10ICACommand16PrintCommandDataEhPK14__CFDictionary, 
                       __ZN10ICACommand20ProcessResultPrivateEPK6AEDescPK14__CFDictionary, 
                       __ZN10ICACommand8SendSyncEv, __ZN10ICACommand9SendAsyncEv, 
                       __ZN10ICACommandD0Ev, __ZN10ICACommandD1Ev, __ZN10ICACommandD2Ev, 
                       __ZN15ICDNewObjectImp13ProcessResultEPK14__CFDictionary, 
                       __ZN15ICDNewObjectImpC1EP15ICD_NewObjectPBPFvP9ICAHeaderE, 
                       __ZN15ICDNewObjectImpC2EP15ICD_NewObjectPBPFvP9ICAHeaderE, 
                       __ZN17ICDNewPropertyImp13ProcessResultEPK14__CFDictionary, 
                       __ZN17ICDNewPropertyImpC1EP17ICD_NewPropertyPBPFvP9ICAHeaderE, 
                       __ZN17ICDNewPropertyImpC2EP17ICD_NewPropertyPBPFvP9ICAHeaderE, 
                       __ZN19ICDBulkNewObjectImp13ProcessResultEPK14__CFDictionary, 
                       __ZN19ICDBulkNewObjectImpC1EP19ICD_BulkNewObjectPBPFvP9ICAHeaderE, 
                       __ZN19ICDBulkNewObjectImpC2EP19ICD_BulkNewObjectPBPFvP9ICAHeaderE, 
                       __ZN19ICDDisposeObjectImpC1EP19ICD_DisposeObjectPBPFvP9ICAHeaderE, 
                       __ZN19ICDDisposeObjectImpC2EP19ICD_DisposeObjectPBPFvP9ICAHeaderE, 
                       __ZN20ICDDeviceRegisterImp13ProcessResultEPK14__CFDictionary, 
                       __ZN20ICDDeviceRegisterImpC1EP22ICD_DeviceRegisteredPBPFvP9ICAHeaderE, 
                       __ZN20ICDDeviceRegisterImpC2EP22ICD_DeviceRegisteredPBPFvP9ICAHeaderE, 
                       __ZN21ICDBulkNewPropertyImp13ProcessResultEPK14__CFDictionary, 
                       __ZN21ICDBulkNewPropertyImpC1EP21ICD_BulkNewPropertyPBPFvP9ICAHeaderE, 
                       __ZN21ICDBulkNewPropertyImpC2EP21ICD_BulkNewPropertyPBPFvP9ICAHeaderE, 
                       __ZN21ICDDisposePropertyImpC1EP21ICD_DisposePropertyPBPFvP9ICAHeaderE, 
                       __ZN21ICDDisposePropertyImpC2EP21ICD_DisposePropertyPBPFvP9ICAHeaderE, 
                       __ZN22ICALoadDeviceModuleImpC1EP21ICALoadDeviceModulePBPFvP9ICAHeaderE, 
                       __ZN22ICALoadDeviceModuleImpC2EP21ICALoadDeviceModulePBPFvP9ICAHeaderE, 
                       __ZN22ICASendNotificationImp13ProcessResultEPK14__CFDictionary, 
                       __ZN22ICDDeviceUnregisterImpC1EP24ICD_DeviceUnRegisteredPBPFvP9ICAHeaderE, 
                       __ZN22ICDDeviceUnregisterImpC2EP24ICD_DeviceUnRegisteredPBPFvP9ICAHeaderE, 
                       __ZN24ICAUnloadDeviceModuleImpC1EP23ICAUnloadDeviceModulePBPFvP9ICAHeaderE, 
                       __ZN24ICAUnloadDeviceModuleImpC2EP23ICAUnloadDeviceModulePBPFvP9ICAHeaderE, 
                       __ZN24ICDDeviceNotificationImp13ProcessResultEPK14__CFDictionary, 
                       __ZN24ICDDeviceNotificationImpC1EP24ICD_DeviceNotificationPBPFvP9ICAHeaderE, 
                       __ZN24ICDDeviceNotificationImpC2EP24ICD_DeviceNotificationPBPFvP9ICAHeaderE, 
                       __ZN25ICAScannerCloseSessionImpC1EP24ICAScannerCloseSessionPBPFvP9ICAHeaderE, 
                       __ZN25ICAScannerCloseSessionImpC2EP24ICAScannerCloseSessionPBPFvP9ICAHeaderE, 
                       __ZTI10ICACommand, __ZTI15ICDNewObjectImp, __ZTI17ICDNewPropertyImp, 
                       __ZTI19ICDBulkNewObjectImp, __ZTI20ICDDeviceRegisterImp, 
                       __ZTI21ICDBulkNewPropertyImp, __ZTI22ICASendNotificationImp, 
                       __ZTI24ICDDeviceNotificationImp, __ZTS10ICACommand, 
                       __ZTS15ICDNewObjectImp, __ZTS17ICDNewPropertyImp, 
                       __ZTS19ICDBulkNewObjectImp, __ZTS20ICDDeviceRegisterImp, 
                       __ZTS21ICDBulkNewPropertyImp, __ZTS22ICASendNotificationImp, 
                       __ZTS24ICDDeviceNotificationImp, __ZTV10ICACommand, 
                       __ZTV15ICDNewObjectImp, __ZTV17ICDNewPropertyImp, 
                       __ZTV19ICDBulkNewObjectImp, __ZTV20ICDDeviceRegisterImp, 
                       __ZTV21ICDBulkNewPropertyImp, __ZTV22ICASendNotificationImp, 
                       __ZTV24ICDDeviceNotificationImp, ___ICInitLogging, 
                       ___ICLog, __gAgentPID, __gAppController, __gApplicationShouldTerminateLater, 
                       __gDiskArbSession, __gExecutableArchitecture, __gICABehaviorFlags, 
                       __gICACopyPBForAsyncCall, __gICADoMacho2CFMConversion, 
                       __gImageCaptureAgentDied, __gLogFile, __gLogInternal, 
                       __gLoggedDeprecated, __gPendingCommands, __gPreLeopardExecutable, 
                       __gSendDeviceArrivalNotification, __gSockfd, _crc32, 
                       _deprecatedMessage, _deviceRegisterCompletion, _deviceUnregistered, 
                       _dummyCompletion, _gArgc, _gArgv, _gCallbacks, _gCookieCounter, 
                       _gDeviceFrameworkShouldScanForDevices, _gDeviceUpdatesDeviceDatabase, 
                       _gFilenamePrefix, _gICDCallbackFunctions, _gICDScannerCallbackFunctions, 
                       _gICD_Disconnect_TWAIN_DS_Callback, _gICD_New_TWAIN_DS_Callback, 
                       _gIsBluetooth, _gIsCameraModule, _gIsTWAINBridge, 
                       _gModuleSpecificPrefs, _gNextFilenameCount, _gQuitWhenLastDeviceIsDisconnected, 
                       _gTWAINBundle, _gTimerCalledCount, _gTimerValueInSeconds, 
                       _internalMessage, _kICAActualByteCountKey, _kICAAddMetaDataToFinderCommentKey, 
                       _kICAAdjustCreationDateKey, _kICAAudioCodecsKey, 
                       _kICABIPVersionKey, _kICABluetoothAddressKey, _kICABluetoothKey, 
                       _kICABluetoothServiceNamesKey, _kICABluetoothTransportType, 
                       _kICABonjourDevicesKey, _kICABonjourServiceNameKey, 
                       _kICABonjourServiceTypeKey, _kICABonjourTXTRecordKey, 
                       _kICACallingProcessSerialNumberHiKey, _kICACallingProcessSerialNumberLoKey, 
                       _kICAChildObjectKey, _kICACloseSessionCmd, _kICACommandKey, 
                       _kICACompletionProcKey, _kICAConnectionIDKey, _kICAConnectionInfoDictionaryKey, 
                       _kICACopyMatchingDeviceDictionariesCmd, _kICACopyObjectDataCmd, 
                       _kICACopyObjectMetadataCmd, _kICACopyObjectPropertyDictionaryCmd, 
                       _kICACopyObjectThumbnailCmd, _kICACopyObjectThumbnailsCmd, 
                       _kICACopyObjectThumbnailsWithMetadataCmd, _kICACountKey, 
                       _kICACreateCustomIconKey, _kICACreationDateStringKey, 
                       _kICADataKey, _kICADataPropertyInfoKey, _kICADataPropertyKey, 
                       _kICADataSizeKey, _kICADataTypeKey, _kICADebugModeKey, 
                       _kICADeleteAfterDownloadKey, _kICADeleteAfterGetDataKey, 
                       _kICADeviceBrowserDeviceRefKey, _kICADeviceCapabilitiesKey, 
                       _kICADeviceDatabaseKey, _kICADeviceIconPathKey, 
                       _kICADeviceInfoDictionaryKey, _kICADeviceInfoPlistVersionKey, 
                       _kICADeviceIsWiFiConfigurableKey, _kICADeviceModulePathKey, 
                       _kICADeviceModuleVersionKey, _kICADeviceNameKey, 
                       _kICADevicePropArtist, _kICADevicePropBatteryLevel, 
                       _kICADevicePropBurstInterval, _kICADevicePropBurstNumber, 
                       _kICADevicePropCaptureDelay, _kICADevicePropCompressionSetting, 
                       _kICADevicePropContrast, _kICADevicePropCopyrightInfo, 
                       _kICADevicePropDateTime, _kICADevicePropDigitalZoom, 
                       _kICADevicePropEffectMode, _kICADevicePropExposureBiasCompensation, 
                       _kICADevicePropExposureIndex, _kICADevicePropExposureMeteringMode, 
                       _kICADevicePropExposureProgramMode, _kICADevicePropExposureTime, 
                       _kICADevicePropFNumber, _kICADevicePropFlashMode, 
                       _kICADevicePropFocalLength, _kICADevicePropFocusDistance, 
                       _kICADevicePropFocusMeteringMode, _kICADevicePropFocusMode, 
                       _kICADevicePropFunctionalMode, _kICADevicePropImageSize, 
                       _kICADevicePropRGBGain, _kICADevicePropSharpness, 
                       _kICADevicePropStillCaptureMode, _kICADevicePropTimelapseInterval, 
                       _kICADevicePropTimelapseNumber, _kICADevicePropUndefined, 
                       _kICADevicePropUploadURL, _kICADevicePropWhiteBalance, 
                       _kICADeviceSharedKey, _kICADeviceTypeCamera, _kICADeviceTypeKey, 
                       _kICADeviceTypeScanner, _kICADeviceUsedKey, _kICADeviceWebSharedKey, 
                       _kICADevicesArrayKey, _kICADevicesDictionaryKey, 
                       _kICADictionaryArrayKey, _kICADirPathKey, _kICADisplayNameKey, 
                       _kICADontEmbedColorSyncProfileKey, _kICADownloadFileCmd, 
                       _kICAErrorKey, _kICAEventsOfInterestKey, _kICAExecutableArchitectureKey, 
                       _kICAExtensionCommandHandlerObjectKey, _kICAExtensionProcessSerialNumberHiKey, 
                       _kICAExtensionProcessSerialNumberLoKey, _kICAFileCreatorKey, 
                       _kICAFilePathKey, _kICAFileTypeKey, _kICAFileUTTypeKey, 
                       _kICAFireWireGUIDKey, _kICAFireWireKey, _kICAFireWireTransportType, 
                       _kICAFlagsKey, _kICAGetChildCountCmd, _kICAGetDeviceListCmd, 
                       _kICAGetNthChildCmd, _kICAGetNthPropertyCmd, _kICAGetObjectInfoCmd, 
                       _kICAGetObjectRefConCmd, _kICAGetParentOfObjectCmd, 
                       _kICAGetParentOfPropertyCmd, _kICAGetPropertyByTypeCmd, 
                       _kICAGetPropertyCountCmd, _kICAGetPropertyDataCmd, 
                       _kICAGetPropertyInfoCmd, _kICAGetPropertyRefConCmd, 
                       _kICAGetRootOfObjectCmd, _kICAGetRootOfPropertyCmd, 
                       _kICAIOServicePathKey, _kICAIPAddressKey, _kICAIPGUIDKey, 
                       _kICAIPNameKey, _kICAIPPortKey, _kICAIconFilePathKey, 
                       _kICAIndexKey, _kICAInstancesKey, _kICAKeywordsKey, 
                       _kICALoadDeviceModuleCmd, _kICALocalDevicesKey, 
                       _kICALockStatusKey, _kICAMaintainFileLockedStateKey, 
                       _kICAManualConnectDeviceRefKey, _kICAMassStorageTransportType, 
                       _kICAMatchCriteriaDictionaryKey, _kICAMediaDurationInSecondsKey, 
                       _kICAMediaFormatsKey, _kICAMediaHeightKey, _kICAMediaMaxDurationKey, 
                       _kICAMediaSizesKey, _kICAMediaWidthKey, _kICAMessageTypeKey, 
                       _kICAModelNameKey, _kICAModificationDateStringKey, 
                       _kICAMovieExtensionsKey, _kICANotificationBatteryLevelKey, 
                       _kICANotificationClassKey, _kICANotificationClassOldStyleKey, 
                       _kICANotificationClassPTPStandard, _kICANotificationClassPTPVendor, 
                       _kICANotificationClassProprietary, _kICANotificationDataCookieKey, 
                       _kICANotificationDataIsBigEndianKey, _kICANotificationDataKey, 
                       _kICANotificationDataSizeKey, _kICANotificationDeviceBrowserDictionaryKey, 
                       _kICANotificationDeviceICAObjectKey, _kICANotificationDeviceInfoDictionaryKey, 
                       _kICANotificationDeviceListICAObjectKey, _kICANotificationDictionaryKey, 
                       _kICANotificationExtdEventTypeKey, _kICANotificationICAObjectArrayKey, 
                       _kICANotificationICAObjectKey, _kICANotificationImageBytesPerRowKey, 
                       _kICANotificationImageDataKey, _kICANotificationImageDataSizeKey, 
                       _kICANotificationImageHeightKey, _kICANotificationImageKey, 
                       _kICANotificationImageNumberOfRowsKey, _kICANotificationImageStartRowKey, 
                       _kICANotificationImageWidthKey, _kICANotificationNumerOfImagesRemainingKey, 
                       _kICANotificationPercentDownloadedKey, _kICANotificationProcIsOldStyleKey, 
                       _kICANotificationProcKey, _kICANotificationRawEventKey, 
                       _kICANotificationScannerButtonTypeKey, _kICANotificationScannerDocumentNameKey, 
                       _kICANotificationSubTypeDocumentLoaded, _kICANotificationSubTypeDocumentNotLoaded, 
                       _kICANotificationSubTypeKey, _kICANotificationSubTypePerformOverviewScan, 
                       _kICANotificationSubTypeWarmUpDone, _kICANotificationSubTypeWarmUpStarted, 
                       _kICANotificationTypeCaptureComplete, _kICANotificationTypeDeviceAdded, 
                       _kICANotificationTypeDeviceBrowserContentChanged, 
                       _kICANotificationTypeDeviceConnectionFailed, _kICANotificationTypeDeviceConnectionProgress, 
                       _kICANotificationTypeDeviceInfoChanged, _kICANotificationTypeDevicePairingFailed, 
                       _kICANotificationTypeDevicePropertyChanged, _kICANotificationTypeDeviceRemoved, 
                       _kICANotificationTypeDeviceStatusError, _kICANotificationTypeDeviceStatusInfo, 
                       _kICANotificationTypeDeviceWasReset, _kICANotificationTypeDownloadProgressStatus, 
                       _kICANotificationTypeIsOldOldStyleKey, _kICANotificationTypeKey, 
                       _kICANotificationTypeNetworkSettingChanged, _kICANotificationTypeObjectAdded, 
                       _kICANotificationTypeObjectInfoChanged, _kICANotificationTypeObjectRemoved, 
                       _kICANotificationTypeObjectUpdatedKey, _kICANotificationTypeOldStyleKey, 
                       _kICANotificationTypeProprietary, _kICANotificationTypeRequestObjectTransfer, 
                       _kICANotificationTypeScanProgressStatus, _kICANotificationTypeScannerButtonPressed, 
                       _kICANotificationTypeScannerOverviewOverlayAvailable, 
                       _kICANotificationTypeScannerPageDone, _kICANotificationTypeScannerScanDone, 
                       _kICANotificationTypeScannerSessionClosed, _kICANotificationTypeStartTWAIN_UI, 
                       _kICANotificationTypeStoppedTWAIN_UI, _kICANotificationTypeStoreAdded, 
                       _kICANotificationTypeStoreFull, _kICANotificationTypeStoreInfoChanged, 
                       _kICANotificationTypeStoreRemoved, _kICANotificationTypeTWAINSessionClosed, 
                       _kICANotificationTypeTWAINSessionOpened, _kICANotificationTypeTransactionCanceled, 
                       _kICANotificationTypeUnreportedStatus, _kICANotificationTypeWebServerURLChanged, 
                       _kICANotificationTypeWebSharingChanged, _kICANotificationVendorErrorCodeKey, 
                       _kICAOBEXVersionKey, _kICAObjectArrayKey, _kICAObjectInTemporaryStoreKey, 
                       _kICAObjectKey, _kICAObjectNameKey, _kICAObjectOfInterestKey, 
                       _kICAObjectPropertyDictionaryKey, _kICAObjectRefConKey, 
                       _kICAObjectSendMessageCmd, _kICAObjectSubtypeKey, 
                       _kICAObjectTypeKey, _kICAObjectsOfInterestKey, _kICAOpenSessionCmd, 
                       _kICAOptionsDictionaryKey, _kICAOrientationKey, 
                       _kICAOverwriteKey, _kICAParameterDictionaryKey, 
                       _kICAParentObjectKey, _kICAPhysicalTransportsKey, 
                       _kICAPictureFolderKey, _kICAPropertyArrayKey, _kICAPropertyDataFlagsKey, 
                       _kICAPropertyDataPtrKey, _kICAPropertyDataSizeKey, 
                       _kICAPropertyDataTypeKey, _kICAPropertyKey, _kICAPropertyRefConKey, 
                       _kICAPropertyTypeKey, _kICAProtocolKey, _kICAProtocolVersionKey, 
                       _kICARawExtensionsKey, _kICARawKey, _kICARefconKey, 
                       _kICARegisterEventNotificationCmd, _kICARegisterForEventNotificationCmd, 
                       _kICARemoteDeviceKey, _kICARemoteDevicesKey, _kICARemoteObjectKey, 
                       _kICARequestedByteCountKey, _kICAResultKey, _kICARootObjectKey, 
                       _kICASCSITransportType, _kICASaveAsFilenameKey, 
                       _kICASavedFilenameKey, _kICAScannerCloseSessionCmd, 
                       _kICAScannerGetParametersCmd, _kICAScannerInitializeCmd, 
                       _kICAScannerOpenSessionCmd, _kICAScannerOpenSessionShouldCallCloseSessionFirstKey, 
                       _kICAScannerSetParametersCmd, _kICAScannerStartCmd, 
                       _kICAScannerStatusCmd, _kICAScannerStatusKey, _kICAScreenHeightKey, 
                       _kICAScreenWidthKey, _kICASendNotificationCmd, _kICASenderObjectKey, 
                       _kICASessionIDKey, _kICASetObjectRefConCmd, _kICASetPropertyDataCmd, 
                       _kICASetPropertyRefConCmd, _kICASharingSetupPasswordKey, 
                       _kICASharingSetupRequiresPasswordKey, _kICASharingSetupScanningForRemoteDevicesKey, 
                       _kICASharingSetupSharedNameKey, _kICASharingSetupSharingEnabledKey, 
                       _kICASharingSetupWebServerURLKey, _kICASharingSetupWebSharingEnabledKey, 
                       _kICASoundFolderKey, _kICAStarRatingKey, _kICAStartByteOffsetKey, 
                       _kICASupportedFeaturesKey, _kICASupportedFileExtensionsKey, 
                       _kICASupportingSoftwaresKey, _kICATCPIPTransportType, 
                       _kICATWAINClientPSNKey, _kICATWAINClientPathKey, 
                       _kICATWAINDSPathKey, _kICATWAINDevicesKey, _kICATWAINInfoDictionaryKey, 
                       _kICATWAINSessionIsOpenKey, _kICATWAINTransportType, 
                       _kICATelephoneNetworksKey, _kICAThumbnailFormatKey, 
                       _kICAThumbnailPropertyInfoKey, _kICAThumbnailPropertyKey, 
                       _kICAThumbnailSizeKey, _kICATransportTypeKey, _kICAUSBKey, 
                       _kICAUSBLocationIDKey, _kICAUSBProductIDKey, _kICAUSBTransportType, 
                       _kICAUSBVendorIDKey, _kICAUnloadDeviceModuleCmd, 
                       _kICAUpdateDeviceDictionaryCmd, _kICAUploadFileCmd, 
                       _kICAUserAssignedDeviceNameKey, _kICAVendorNameKey, 
                       _kICAVideoCodecsKey, _kICAVideoFolderKey, _kICAWMCVersionKey, 
                       _kICAWiFiSecuritiesKey, _kICAWiFiSecurityAuthenticationKey, 
                       _kICAWiFiSecurityEncryptionKey, _kICDBulkNewObjectsCmd, 
                       _kICDBulkNewPropertiesCmd, _kICDDeviceCallbackCmd, 
                       _kICDDeviceNotificationCmd, _kICDDeviceRegisterCmd, 
                       _kICDDeviceUnregisterCmd, _kICDDisposeObjectCmd, 
                       _kICDDisposePropertyCmd, _kICDNewObjectCmd, _kICDNewPropertyCmd, 
                       _kICUTTypeRaw, _kMetaDataDictionaryKey ]
    objc-classes:    [ _AppController, _AudioObjectImp, _BaseObjectImp, 
                       _BluetoothDevice, _Device, _DeviceList, _DeviceProfileHandler, 
                       _FireWireDevice, _ICDBaseCommandImp, _ICDCopyObjectDataImp, 
                       _ICDCopyObjectMetadataImp, _ICDCopyObjectPropertyDictionaryImp, 
                       _ICDCopyObjectThumbnailImp, _ICDCopyObjectThumbnailsImp, 
                       _ICDCopyObjectThumbnailsWithMetadataImp, _ICDDownloadFileImp, 
                       _ICDGetPropertyDataImp, _ICDLoadDeviceModuleImp, 
                       _ICDObjectSendMessageImp, _ICDScannerCloseSessionImp, 
                       _ICDScannerGetParametersImp, _ICDScannerInitializeImp, 
                       _ICDScannerOpenSessionImp, _ICDScannerSetParametersImp, 
                       _ICDScannerStartImp, _ICDScannerStatusImp, _ICDSendPTPCmdImp, 
                       _ICDUnloadDeviceModuleImp, _ICDUploadFileImp, _ICDataBuffer2, 
                       _ICScannerScanAreaSelectionChangedImp, _ImageObjectImp, 
                       _MassStorageDevice, _OtherObjectImp, _Profile, _TCPIPDevice, 
                       _TWAINDevice, _USBDevice, __DirectoryObject, __MovieObject ]
    weak-def-symbols: [ __ZTI19ICDDisposeObjectImp, __ZTI21ICDDisposePropertyImp, 
                        __ZTI22ICALoadDeviceModuleImp, __ZTI22ICDDeviceUnregisterImp, 
                        __ZTI24ICAUnloadDeviceModuleImp, __ZTI25ICAScannerCloseSessionImp, 
                        __ZTS19ICDDisposeObjectImp, __ZTS21ICDDisposePropertyImp, 
                        __ZTS22ICALoadDeviceModuleImp, __ZTS22ICDDeviceUnregisterImp, 
                        __ZTS24ICAUnloadDeviceModuleImp, __ZTS25ICAScannerCloseSessionImp ]
...
                                                                                                                                                                                                                                                                                                                                                           Modules/                                                                                            0040755 0001750 0001750 00000000000 12612224741 031554  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/ICADevices.framework/Versions/A                                                                          module.modulemap                                                                                    0100644 0001750 0001750 00000000157 12566226260 034754  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/ICADevices.framework/Versions/A/Modules                                                                  framework module ICADevices [extern_c] {
  umbrella header "ICADevices.h"
  export *
  module * { export * }
}
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/ICADevices.framework/Versions/Current 0120777 0001750 0001750 00000000000 12620245063 031506  2A                                                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/            0040755 0001750 0001750 00000000000 12612224741 027301  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Frameworks  0120777 0001750 0001750 00000000000 12620245063 036634  2Versions/Current/Frameworks                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Headers     0120777 0001750 0001750 00000000000 12620245063 035322  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        IMServicePlugIn.tbd                                                                                 0120777 0001750 0001750 00000000000 12620245063 041547  2Versions/Current/IMServicePlugIn.tbd                                                                ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework                                                                                osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/   0040755 0001750 0001750 00000000000 12612224741 031111  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/ 0040755 0001750 0001750 00000000000 12612224741 031271  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Frameworks/                                                                                         0040755 0001750 0001750 00000000000 12612224741 033332  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A                                                                     IMServicePlugInSupport.framework/                                                                   0040755 0001750 0001750 00000000000 12612224741 041670  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks                                                          IMServicePlugInSupport.tbd                                                                          0120777 0001750 0001750 00000000000 12620245063 057207  2Versions/Current/IMServicePlugInSupport.tbd                                                         ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework                         Versions/                                                                                           0040755 0001750 0001750 00000000000 12612224741 043500  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework                         A/                                                                                                  0040755 0001750 0001750 00000000000 12612224741 043660  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework/Versions                IMServicePlugInSupport.tbd                                                                          0100644 0001750 0001750 00000005635 12571375064 050734  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework/Versions/A              ---
archs:           [ x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework/Versions/A/IMServicePlugInSupport
current-version: 1000.0
exports:         
  - archs:           [ x86_64 ]
    symbols:         [ _IMAccountSettingLoginHandle, _IMAccountSettingPassword, 
                       _IMAccountSettingServerHost, _IMAccountSettingServerPort, 
                       _IMAccountSettingUsesSSL, _IMAttributeAddress, _IMAttributeBackgroundColor, 
                       _IMAttributeBaseWritingDirection, _IMAttributeBold, 
                       _IMAttributeFontFamily, _IMAttributeFontSize, _IMAttributeForegroundColor, 
                       _IMAttributeItalic, _IMAttributeLink, _IMAttributeMessageBackgroundColor, 
                       _IMAttributePreformatted, _IMAttributeStrikethrough, 
                       _IMAttributeUnderline, _IMCalendarEventAttributeName, 
                       _IMDataDetectedAttributeName, _IMGroupListDefaultGroup, 
                       _IMGroupListHandlesKey, _IMGroupListNameKey, _IMGroupListPermissionsKey, 
                       _IMHandleCapabilityChatRoom, _IMHandleCapabilityDirectoryFileTransfer, 
                       _IMHandleCapabilityFileTransfer, _IMHandleCapabilityHandlePicture, 
                       _IMHandleCapabilityInlineFileTransfer, _IMHandleCapabilityMessaging, 
                       _IMHandleCapabilityOfflineMessaging, _IMHandlePropertyAlias, 
                       _IMHandlePropertyAuthorizationStatus, _IMHandlePropertyAvailability, 
                       _IMHandlePropertyCapabilities, _IMHandlePropertyEmailAddress, 
                       _IMHandlePropertyFirstName, _IMHandlePropertyIdleDate, 
                       _IMHandlePropertyLastName, _IMHandlePropertyNickname, 
                       _IMHandlePropertyPictureData, _IMHandlePropertyPictureIdentifier, 
                       _IMHandlePropertyStatusMessage, _IMServiceCapabilityChatRoomSupport, 
                       _IMServiceCapabilityFileTransferSessionSupport, 
                       _IMServiceCapabilityGroupListAuthorizationSupport, 
                       _IMServiceCapabilityGroupListHandlePictureSupport, 
                       _IMServiceCapabilityGroupListOrderingSupport, _IMServiceCapabilityGroupListSupport, 
                       _IMServiceCapabilityInstantMessagingSupport, _IMServiceCapabilityOfflineMessagingSupport, 
                       _IMServiceCapabilityPresenceInvisibilitySupport, 
                       _IMServiceCapabilityPresenceSupport, _IMServicePlugInSupportVersionNumber, 
                       _IMServicePlugInSupportVersionString, _IMSessionPropertyAvailability, 
                       _IMSessionPropertyIdleDate, _IMSessionPropertyIsInvisible, 
                       _IMSessionPropertyPictureData, _IMSessionPropertyStatusMessage ]
    objc-classes:    [ _IMServicePlugInBundle ]
...
                                                                                                   Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 045143  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework/Versions                Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032565  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A                                                                     IMServicePlugIn.h                                                                                   0100644 0001750 0001750 00000001014 12566246160 035703  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    IMServicePlugIn.h
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <IMServicePlugIn/IMServicePlugInTypes.h>
#import <IMServicePlugIn/IMServicePlugInProtocols.h>

#import <IMServicePlugIn/IMServicePlugInMessage.h>

#import <IMServicePlugIn/IMServicePlugInChatRoomSupport.h>
#import <IMServicePlugIn/IMServicePlugInGroupListSupport.h>
#import <IMServicePlugIn/IMServicePlugInInstantMessageSupport.h>
#import <IMServicePlugIn/IMServicePlugInPresenceSupport.h>

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    IMServicePlugInChatRoomSupport.h                                                                    0100644 0001750 0001750 00000024021 12566246160 040740  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    Protocols for Chat Room Support
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>

@class IMServicePlugInMessage;


#pragma mark -
#pragma mark IMServicePlugIn (Messages -> Service Plug-in)

/*!
    @protocol   IMServicePlugInChatRoomSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports chat-room-based messaging.

                If implementing this protocol, you must also include "IMServiceCapabilityChatRoomSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.

                IMServicePlugInChatRoomSupport and IMServiceApplicationChatRoomSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInChatRoomSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationChatRoomSupport protocol.
*/

@protocol IMServicePlugInChatRoomSupport


/*!
    @method     joinChatRoom:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user attempts
                to join a chat room.
                
                To indicate success, -plugInDidJoinChatRoom: should be called by the service plug-in on the
                service application, followed by -handles:didJoinChatRoom: to indicate the current
                chat room member handles.

                To indicate failure, -plugInDidLeaveChatRoom:error: should be called by the service plug-in
                with a non-nil error.
                
                This method may also be called by Messages when the user clicks "Accept" to a chat
                room invitation.
                
    @param      roomName  The name of the room which the user wishes to join.
*/
- (oneway void) joinChatRoom:(NSString *)roomName;


/*!
    @method     leaveChatRoom:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user closes
                the chat room window, or when the service disconnects.
                
                The service plug-in should attempt to cleanly leave the chat room, and then
                call -plugInDidLeaveChatRoom:error: on the service application once the room is left.

    @param      roomName  The name of the room which the user wishes to leave.
*/
- (oneway void) leaveChatRoom:(NSString *)roomName;


/*!
    @method     inviteHandles:toChatRoom:withMessage:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user 
                invites handles to a specific chatRoom

    @param      handles   The handles to invite.
    @param      roomName  The name of the room which the user wishes to leave
    @param      message   The invitation message
*/
- (oneway void) inviteHandles:(NSArray *)handles toChatRoom:(NSString *)roomName withMessage:(IMServicePlugInMessage *)message;


/*!
    @method     sendMessage:toChatRoom:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user sends
                a message to a chat room.

                The service plug-in should use -plugInDidSendMessage:toChatRoom:error: to report 
                delivery of the message.
                
                Some instant messaging services do not report message delivery status of
                messages sent to chat rooms.  Instead, the message is received in a similar
                fashion to other incoming chat room messages.  In this case, the service
                plug-in may choose to reflect successful message delievery status via
                a call to -plugInDidReceiveMessage:forChatRoom:fromHandle:, with the handle
                parameter set to the handle name.

    @param      message  The message to send.
    @param      roomName The recipient chat room.
*/
- (oneway void) sendMessage:(IMServicePlugInMessage *)message toChatRoom:(NSString *)roomName;


/*!
    @method     declineChatRoomInvitation:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user clicks
                the "Decline" button of an incoming chat room invitation.
                
                This method is always called in response to Messages receiving
                -plugInDidReceiveInvitation:forChatRoom:fromHandle: from the service plug-in.

    @param      roomName  The name of the room which the user has declined.
*/
- (oneway void) declineChatRoomInvitation:(NSString *)roomName;

@end


#pragma mark -
#pragma mark IMServiceApplication (Service Plug-in -> Messages)

@protocol IMServiceApplicationChatRoomSupport <IMServiceApplication>

/*!
    @method     plugInDidReceiveInvitation:forChatRoom:fromHandle:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                displays an invitation window from the specified handle for the chat room.

                If the user clicks "Accept" on the window, Messages then calls -joinChatRoom: on the
                service plug-in.  If the user clicks "Decline", Messages calls -declineChatRoomInvitation:
                instead.

    @param      invitation An invitation message.  If nil, Messages uses a default invitation message.
    @param      roomName   The name of the chat room.
    @param      handle     The handle of the inviter.
*/
- (oneway void) plugInDidReceiveInvitation:(IMServicePlugInMessage *)invitation forChatRoom:(NSString *)roomName fromHandle:(NSString *)handle;


/*!
    @method     plugInDidReceiveMessage:forChatRoom:fromHandle:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                appends the sender and message to the transcript for the specified chat room.
                 
                This call may be used to indicate successful delivery of a message sent via
                -sendMessage:toChatRoom:

    @param      message    The message.
    @param      roomName   The name of the chat room.
    @param      handle     The sender of the message.
*/
- (oneway void) plugInDidReceiveMessage:(IMServicePlugInMessage *)message forChatRoom:(NSString *)roomName fromHandle:(NSString *)handle;


/*!
    @method     plugInDidReceiveNotice:forChatRoom:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                appends an information message to the transcript for the specified chat room.

                Since the IMServicePlugIn API does not support chat room properties such as topic,
                moderator status, or chat room settings; clients may use this method to display
                additional information which would otherwise be hidden to the user.

    @param      notice    An informational message to be displayed.
    @param      roomName  The name of the chat room.
*/
- (oneway void) plugInDidReceiveNotice:(NSString *)notice forChatRoom:(NSString *)roomName;


/*!
    @method     plugInDidSendMessage:toChatRoom:error:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                appends the message to the transcript for the specified chat room.
                 
                This call may be used to indicate successful delivery of a message sent via
                -sendMessage:toChatRoom:

    @param      message    The message.
    @param      roomName   The name of the chat room.
    @param      error      An error, if one occurred during message delivery.
*/
- (oneway void) plugInDidSendMessage:(IMServicePlugInMessage *)message toChatRoom:(NSString *)roomName error:(NSError *)error;


/*!
    @method     plugInDidJoinChatRoom:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                indicates to the user that the specified chat room is now joined and ready to receive
                messages.
                 
                This call should be used in response to joinChatRoom: being called on the service plug-in.

    @param      roomName   The name of the chat room
*/
- (oneway void) plugInDidJoinChatRoom:(NSString *)roomName;


/*!
    @method     plugInDidLeaveChatRoom:error:

    @discussion The IMServicePlugIn should call this method on the service application to indiciate that
                a chat room has been successfully left, and that the user may attempt to re-enter that
                room in the future.

                This call may also be used in response to joinChatRoom: to indicate that an error occurred
                while joining the room.

    @param      roomName   The name of the chat room.
    @param      error      An error, if any, which caused the user to be removed from the chat room,
                           or prevented the user from joining the chat room.
*/
- (oneway void) plugInDidLeaveChatRoom:(NSString *)roomName error:(NSError *)error;


/*!
    @method     handles:didJoinChatRoom:

    @discussion The IMServicePlugIn should call this method on the service application to indiciate that
                a handle, or multiple handles, have joined the chat room.

                This method may also be used after plugInDidJoinChatRoom: to report the initial list
                of chat room members.

    @param      handles   An NSArray of NSString objects, corresponding to the handles which joined the room.
    @param      roomName  The name of the chat room.
*/
- (oneway void) handles:(NSArray *)handles didJoinChatRoom:(NSString *)roomName;


/*!
    @method     handles:didLeaveChatRoom:

    @discussion The IMServicePlugIn should call this method on the service application to indiciate that
                a handle, or multiple handles, have left or been removed from the chat room.

    @param      handles   An NSArray of NSString objects, corresponding to the handles which left the room.
    @param      roomName  The name of the chat room.
*/
- (oneway void) handles:(NSArray *)handles didLeaveChatRoom:(NSString *)roomName;


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               IMServicePlugInFileTransfer.h                                                                       0100644 0001750 0001750 00000002411 12566246160 040212  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    IMServicePlugInFileTransfer.h
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>

@class IMServicePlugInFileTransferSession;

typedef struct _IMServicePlugInFileTransferInternal IMServicePlugInFileTransferInternal;

@interface IMServicePlugInFileTransfer : NSObject {
    IMServicePlugInFileTransferInternal *_internal;
}

+ (id) fileTransferWithPath: (NSString *) path
                       type: (NSString *) type 
                 totalBytes: (uint64_t) totalBytes;
 
- (id) initWithPath: (NSString *) path
               type: (NSString *) type
         totalBytes: (uint64_t) totalBytes;

@property (readonly) NSString *guid;

@property (readonly) NSString *path;
@property (readonly) NSString *type;
@property (readonly) uint64_t transferredBytes;
@property (readonly) uint64_t totalBytes;

@property (readonly) IMServicePlugInFileTransferSession *session;

@end


@interface IMServicePlugInOutgoingFileTransfer : IMServicePlugInFileTransfer

- (void) resetInputStream;

@property (readonly) NSInputStream *inputStream;

@end


@interface IMServicePlugInIncomingFileTransfer : IMServicePlugInFileTransfer

- (void) resetOutputStream;

@property (readonly) NSOutputStream *outputStream;

@end
                                                                                                                                                                                                                                                       IMServicePlugInFileTransferSession.h                                                                0100644 0001750 0001750 00000002263 12566246160 041563  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             //
//  IMServicePlugInFileTransferSession.h
//  IMServicePlugIn
//
//  Created by Ricci Adams on 2010-07-14.
//  Copyright 2010 Apple, Inc. All rights reserved.
//

#import <Foundation/Foundation.h>


@class IMServicePlugInIncomingFileTransfer, IMServicePlugInOutgoingFileTransfer;

typedef struct _IMServicePlugInFileTransferSessionInternal IMServicePlugInFileTransferSessionInternal;

@interface IMServicePlugInFileTransferSession : NSObject {
    IMServicePlugInFileTransferSessionInternal *_internal;
}

@property (readonly) NSString *guid;
@property (readonly) NSString *containerName;

@end


@interface IMServicePlugInOutgoingFileTransferSession : IMServicePlugInFileTransferSession

@property (readonly) NSArray *outgoingFileTransfers;
- (IMServicePlugInOutgoingFileTransfer *) outgoingFileTransferForPath:(NSString *)path;

@end


@interface IMServicePlugInIncomingFileTransferSession : IMServicePlugInFileTransferSession

- (void) setContainerName:(NSString *)containerName;
- (void) addIncomingFileTransfer:(IMServicePlugInIncomingFileTransfer *)fileTransfer;

- (NSArray *) incomingFileTransfers;
- (IMServicePlugInIncomingFileTransfer *) incomingFileTransferForPath:(NSString *)path;

@end
                                                                                                                                                                                                                                                                                                                                             IMServicePlugInFileTransferSessionSupport.h                                                         0100644 0001750 0001750 00000011456 12566246160 043164  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    Protocols for File Transfer Support
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>

@class IMServicePlugInFileTransferSession,
       IMServicePlugInOutgoingFileTransferSession,
       IMServicePlugInIncomingFileTransferSession;


#pragma mark -
#pragma mark IMServicePlugIn (Messages -> Service Plug-in)
#pragma mark -

/*!
    @protocol   IMServicePlugInFileTransferSessionSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports handle-to-handle file transfers.

                If implementing this protocol, you must also include "IMServiceCapabilityFileTransferSessionSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.

                Incoming File Transfers:
                1) The Service Plug-in creates an IMServicePlugInIncomingFileTransferSession instance
                2) The Service Plug-in creates an IMServicePlugInIncomingFileTransfer instance for each incoming file,
                   and adds them via -[IMServicePlugInIncomingFileTransferSession addIncomingFileTransfer:]
                3) The Service Plug-in calls -plugInDidReceiveIncomingFileTransferSession:fromHandle on the service application
                4) Messages displays the "Incoming file transfer" dialog to the user.
                5) If the user selects "Accept", Messages sends -acceptIncomingFileTransferSession: to the service plug-in
                   If the user selects "Decline", Messages sends -cancelFileTransferSession: to the service plug-in
                   
                If the file transfer is accepted:
                
                1) The service plug-in reads bytes from the network
                5) The service plug-in writes bytes via the fileHandleForWriting property's NSFileHandle object 
                7) Upon completing the file transfer -plugInDidFinishFileTransfer:error: is called with a nil error
                   If at any time the plug-in cannot finish the file transfer, call -plugInDidFinishFileTransfer:error:
                   with an actual NSError
                   
                Outgoing File Transfers:
                1) Messages creates an IMServicePlugInOutgoingFileTransfer instance
                2) Messages calls -startOutgoingFileTransfer:toHandle: on the service plug-in.
                3) The service plug-in delivers the file transfer notification to the selected handle
                4) If the handle accepts the transfer, the service plug-in calls:
                   -plugInDidReceiveAcceptForOutgoingFileTransfer:
                   If the handle declines the transfer, the service plug-in calls:
                   -plugInDidFinishFileTransfer:error:  with a non-nil error.

                If the file transfer is accepted:
                4) The service plug-in reads bytes via the fileHandleForReading property's NSFileHandle object 
                5) The bytes are written over the network
                6) The service plug-in sends occasional progress reports (once every second) via -plugInDidUpdateFileTransfer:transferredBytes:
                7) Upon completing the file transfer -plugInDidFinishFileTransfer:error: is called with a nil error
                   If at any time the plug-in cannot finish the file transfer, call -plugInDidFinishFileTransfer:error:
                   with an actual NSError

                IMServicePlugInFileTransferSessionSupport and IMServiceApplicationFileTransferSessionSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInFileTransferSessionSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationFileTransferSessionSupport protocol.
*/
@protocol IMServicePlugInFileTransferSessionSupport

- (oneway void) startOutgoingFileTransferSession:(IMServicePlugInOutgoingFileTransferSession *)session toHandle:(NSString *)handle;

- (oneway void) acceptIncomingFileTransferSession:(IMServicePlugInIncomingFileTransferSession *)session;
- (oneway void) cancelFileTransferSession:(IMServicePlugInFileTransferSession *)session;

@end


#pragma mark -
#pragma mark IMServiceApplication (Service Plug-in -> Messages)
#pragma mark -

@protocol IMServiceApplicationFileTransferSessionSupport <IMServiceApplication>
- (oneway void) plugInDidReceiveIncomingFileTransferSession:(IMServicePlugInIncomingFileTransferSession *)session fromHandle:(NSString *)handle;

- (oneway void) plugInDidAcceptOutgoingFileTransferSession:(IMServicePlugInOutgoingFileTransferSession *)session;

- (oneway void) plugInDidFinishFileTransferSession:(IMServicePlugInFileTransferSession *)session error:(NSError *)error;

@end

                                                                                                                                                                                                                  IMServicePlugInGroupListSupport.h                                                                   0100644 0001750 0001750 00000032675 12566246160 041172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    Protocols for Group List Support
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>


#pragma mark -
#pragma mark IMServicePlugIn (Messages -> Service Plug-in)
#pragma mark -

/*!
    @protocol   IMServicePlugInGroupListSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports a group list.

                If implementing this protocol, you must also include "IMServiceCapabilityGroupListSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.

                IMServicePlugInGroupListSupport and IMServiceApplicationGroupListSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInGroupListSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationGroupListSupport protocol.
*/
@protocol IMServicePlugInGroupListSupport

/*!
    @method     requestGroupList

    @discussion Messages calls this method on the IMServicePlugIn when the user
                finishes modifying the group list.
                
                After a -requestGroupList is requested, the service plug-in should
                respond with -plugInDidUpdateGroupList:error: with the current "truth"
                of the group list.
                
                If any operations from IMServicePlugInGroupListEditingSupport
                are still pending, -plugInDidUpdateGroupList:error: should not be
                called until they finish.
*/
- (oneway void) requestGroupList;

@end


#pragma mark  -


/*!
    @protocol   IMServicePlugInGroupListEditingSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports editing the group list.  It requires that you also implement the
                IMServicePlugInGroupListSupport protocol.
                
                If implementing this protocol, you must also include "IMServiceCapabilityGroupListEditingSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.
*/
@protocol IMServicePlugInGroupListEditingSupport <IMServicePlugInGroupListSupport>


/*!
    @method     addGroups:

    @discussion Messages calls this method when the user had added one or 
                more groups to the group list.

    @param      groupNames  An array of NSString objects, corresponding to the
                            names of the added groups
*/
- (oneway void) addGroups:(NSArray *)groupNames;


/*!
    @method     removeGroups:

    @discussion Messages calls this method when the user had removed one or
                more groups from the group list.

    @param      groupNames  An array of NSString objects, corresponding to the
                            names of the removed groups
*/
- (oneway void) removeGroups:(NSArray *)groupNames;


/*!
    @method     renameGroup:toGroup:

    @discussion Messages calls this method when the user renames a group.

    @param      oldGroupName  The former name of the group
    @param      newGroupName  The new name of the group
*/
- (oneway void) renameGroup:(NSString *)oldGroupName toGroup:(NSString *)newGroupName;


/*!
    @method     addHandles:toGroup:

    @discussion Messages calls this method when the user adds member handles to a group.

                In the event that the user moves a member from one group to
                another group, Messages will first call this method for the
                destination group, and then call -removeHandles:fromGroup:
                for the source group.

    @param      handles    The added handles
    @param      groupName  The name of the group
*/
- (oneway void) addHandles:(NSArray *)handles toGroup:(NSString *)groupName;


/*!
    @method     removeHandles:fromGroup:

    @discussion Messages calls this method when the adds member handles to a group.

                In the event that the user moves a member from one group to
                another group, Messages will first call -addHandles:toGroup: 
                for the destination group, and then call this method for
                the source group.

    @param      handles    The removed handles
    @param      groupName  The name of the group
*/
- (oneway void) removeHandles:(NSArray *)handles fromGroup:(NSString *)groupName;

@end


#pragma mark -


/*!
    @protocol   IMServicePlugInGroupListOrderingSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates
                that your service supports ordered group list.  It requires that you also implement the
                IMServicePlugInGroupListSupport protocol.

                If implementing this protocol, you must also include "IMServiceCapabilityGroupListOrderingSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.
*/
@protocol IMServicePlugInGroupListOrderingSupport <IMServicePlugInGroupListSupport>


/*!
    @method     reorderGroups:

    @discussion Messages calls this method when the user modifies the order of groups.

    @param      groupNames  An NSArray of NSStrings, corresponding to group names in the new order
*/
- (oneway void) reorderGroups:(NSArray *)groupNames;


/*!
    @method     reorderGroups:

    @discussion Messages calls this method when the user modifies the order of handles in a specific group.
    
    @param      handles    An NSArray of NSStrings, corresponding to handles in the new order
    @param      groupName  The containing group
*/
- (oneway void) reorderHandles:(NSArray *)handles inGroup:(NSString *)groupName;

@end


#pragma mark -

/*!
    @protocol   IMServicePlugInGroupListAuthorizationSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service requires authorization when adding a handle to the group list.

                If implementing this protocol, you must also include "IMServiceCapabilityGroupListAuthorizationSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.

                IMServicePlugInGroupListAuthorizationSupport and IMServiceApplicationGroupListAuthorizationSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInGroupListAuthorizationSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationGroupListAuthorizationSupport protocol.
*/
@protocol IMServicePlugInGroupListAuthorizationSupport <IMServicePlugInGroupListSupport>


/*!
    @method     sendAuthorizationRequestToHandle:

    @discussion When Messages adds a handle to the group list on a service which requires authorization,
                it will call -sendAuthorizationRequestToHandle: for each handle after 
                -addHandles:toGroup:

    @param      handle     The handle from which to request authorization
*/
- (oneway void) sendAuthorizationRequestToHandle:(NSString *)handle;


/*!
    @method     acceptAuthorizationRequestFromHandle:

    @discussion When the user clicks the "Accept" button on a pending authorization request.  Messages
                calls this method on the service plug-in

    @param      handle     The handle to authorize
*/
- (oneway void) acceptAuthorizationRequestFromHandle:(NSString *)handle;


/*!
    @method     declineAuthorizationRequestFromHandle:

    @discussion When the user clicks the "Decline" button on a pending authorization request.  Messages
                calls this method on the service plug-in

    @param      handle     The handle to not authorize
*/
- (oneway void) declineAuthorizationRequestFromHandle:(NSString *)handle;

@end


#pragma mark -

/*!
    @protocol   IMServicePlugInGroupListHandlePictureSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports handle pictures.

                If implementing this protocol, you must also include "IMServiceCapabilityGroupListHandlePictureSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.

                Messages uses a caching mechanism for dealing with user pictures.  A unique identifier
                should be provided/calculated for each buddy picture and pass up to the application
                via the IMHandlePropertyPictureIdentifier handle property via:
                id<IMServiceApplicationGroupListSupport> plugInDidUpdateProperties:ofHandle:]
                
                If Messages does not have the user picture cached, it will request it via:
                id<IMServicePlugInGroupListHandlePictureSupport> requestHandlePictureWithIdentifier:]
                
                The service plug-in then fetches the image data and responds with:
                id<IMServiceApplicationGroupListSupport> plugInDidUpdateProperties:ofHandle:]
                with both the IMHandlePropertyPictureIdentifier and IMHandlePropertyPictureData
                properties set
*/
@protocol IMServicePlugInGroupListHandlePictureSupport <NSObject>


/*!
    @method     requestPictureForHandle:withIdentifier:

    @discussion Messages calls this method on the IMServicePlugIn instance when it needs the handle picture data
                for the specified identifier.

                Once the service plug-in obtains this data, it should call
                -[id<IMServiceApplication> plugInDidUpdateProperties:ofHandle:] 
				with the IMHandlePropertyPictureData property set
				
				Further calls to -plugInDidUpdateProperties:ofHandle: must NOT include the 
				IMHandlePropertyPictureData key.

    @param      handle      The handle to fetch
    @param      identifier  A unqiue handle picture identifier
*/
- (oneway void) requestPictureForHandle:(NSString *)handle withIdentifier:(NSString *)identifier;

@end


#pragma mark -
#pragma mark IMServiceApplication (Service Plug-in -> Messages)
#pragma mark -


/*!
    @protocol   IMServiceApplicationGroupListSupport

    @discussion This protocol is used to pass the group list information up to Messages
                Messages, and to provide response callbacks to IMServicePlugInInstantMessagingSupport 
                methods.
                
                IMServicePlugInGroupListSupport and IMServiceApplicationGroupListSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInGroupListSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationGroupListSupport protocol.
*/

@protocol IMServiceApplicationGroupListSupport <IMServiceApplication>

/*!
    @method     plug-inDidUpdateGroupList:error:

    @discussion The IMServicePlugIn instance should call this method on Messages in response to 
                a downwards -requestGroupList request (which will be called after each user
                modification of the group list).

                The current "truth" state of the group list should be passed up.

                To indicate that a requested modification operation failed, pass up an error
                in addition to the truth state.
                
    @param      groups  An array of NSDictionary objects, representing the service's group list.

                        Each dictionary should contain the following keys:

                        IMGroupListNameKey        - The name of the group
                        IMGroupListPermissionsKey - An NSNumber of IMGroupListPermissions
                        IMGroupListHandlesKey     - An NSArray containing NSStrings, corresponding to the handles in the group
                
    @param      error   An error for any requested group list modification operation, if one occurred
*/
- (oneway void) plugInDidUpdateGroupList:(NSArray *)groups error:(NSError *)error;

@end


#pragma mark -

/*!
    @protocol   IMServiceApplicationGroupListAuthorizationSupport

    @discussion This protocol is used to pass authorization requests from the server up to Messages.
                
                IMServicePlugInGroupListAuthorizationSupport and IMServiceApplicationGroupListAuthorizationSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInGroupListAuthorizationSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationGroupListAuthorizationSupport protocol.
*/
@protocol IMServiceApplicationGroupListAuthorizationSupport <IMServiceApplicationGroupListSupport>

/*!
    @method     plugInDidReceiveAuthorizationRequestFromHandle:

	@discussion When the IMServicePlugIn instance calls this method on the service application, Messages
	            displays an authorization request window from the specified handle.

	            If the user clicks "Accept" on the window, Messages then calls -acceptAuthorizationRequestFromHandle:
	 			on the service plug-in.
				
				If the user clicks "Decline", Messages instead calls -declineAuthorizationRequestFromHandle:
	            on the service plug-in.

	@param      handle   The handle requesting authorization
*/
- (oneway void) plugInDidReceiveAuthorizationRequestFromHandle:(NSString *)handle;

@end

                                                                   IMServicePlugInInstantMessageSupport.h                                                              0100644 0001750 0001750 00000014131 12566246160 042152  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    Protocols for Instant Messaging Support
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>

@class IMServicePlugInMessage;


#pragma mark -
#pragma mark IMServicePlugIn (Messages -> Service Plug-in)

/*!
    @protocol   IMServicePlugInInstantMessagingSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports one-to-one instant messaging.

                If implementing this protocol, you must also include "IMServiceCapabilityInstantMessagingSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.
                
                If your service supports delivery of messages to offline users, you must also include
                "IMServiceCapabilityOfflineMessagingSupport" in the "IMServiceCapabilities" key in the Info.plist
                of your service plug-in.
 
                IMServicePlugInInstantMessagingSupport and IMServiceApplicationInstantMessagingSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInInstantMessagingSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationInstantMessagingSupport protocol.
*/
@protocol IMServicePlugInInstantMessagingSupport


/*!
    @method     userDidStartTypingToHandle:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user starts
                typing a message to a specific handle from the input line.

    @param      handle  The handle to which the user has started typing.
*/
- (oneway void) userDidStartTypingToHandle:(NSString *)handle;


/*!
    @method     userDidStopTypingToHandle:

    @discussion Messages calls this method on the IMServicePlugIn instance if the user clears the input line
                after typing instead of sending the message.

    @param      handle  The handle to which the user started typing, but then cleared the input line.
*/
- (oneway void) userDidStopTypingToHandle:(NSString *)handle;


/*!
    @method     sendMessage:toHandle:

    @discussion Messages calls this method on the IMServicePlugIn instance when the user sends a message
                to a specific handle.
                
                To indicate successful delivery of the message (and have it show up in Messages), the
                IMServicePlugIn should reflect the message via
                
                -[id<IMServiceApplicationInstantMessagingSupport> plug-inDidSendMessage:toHandle:error:]
                
                with a nil error.  A non-nil error indicates that the message could not be sent.

    @param      message  The message to send
    @param      handle   The receipient of the message
*/
- (oneway void) sendMessage:(IMServicePlugInMessage *)message toHandle:(NSString *)handle;

@end


#pragma mark -
#pragma mark IMServiceApplication (Service Plug-in -> Messages)

/*!
    @protocol   IMServiceApplicationInstantMessagingSupport

    @discussion This protocol is used to pass incoming instant messaging events from the server up to
                Messages, and to provide response callbacks to IMServicePlugInInstantMessagingSupport 
                methods.
                
                IMServicePlugInInstantMessagingSupport and IMServiceApplicationInstantMessagingSupport are
                paired protocols.  If your service plug-in's principal class implements the
                IMServicePlugInInstantMessagingSupport protocol, the IMServiceApplication object handed to your
                IMServicePlugIn will implement the IMServiceApplicationInstantMessagingSupport protocol.
*/
@protocol IMServiceApplicationInstantMessagingSupport


/*!
    @method     handleDidStartTyping:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages displays
                the "thought bubble" for the specified handle.  
                
                A call to -handleDidStopTyping: will clear the thought bubble.
                
                A call to -plugInDidReceiveMessage:fromHandle: will replace the thought bubble with an actual message.

    @param      handle   The handle that started typing
*/
- (oneway void) handleDidStartTyping:(NSString *)handle;


/*!
    @method     handleDidStopTyping:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages removes
                any thought bubble for the specified handle.  

    @param      handle   The handle that stopped typing
*/
- (oneway void) handleDidStopTyping:(NSString *)handle;


/*!
    @method     plugInDidReceiveMessage:fromHandle:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages appends
                the message to the active chat with the handle.
                
                If no chat is present, Messages displays the message in a notifier window.

    @param      message  The incoming message
    @param      handle   The sender of the message
*/
- (oneway void) plugInDidReceiveMessage:(IMServicePlugInMessage *)message fromHandle:(NSString *)handle;


/*!
    @method     plugInDidSendMessage:toHandle:error:

    @discussion When the IMServicePlugIn instance calls this method on the service application with a nil
                error, Messages appends the message to the active chat with the handle.
    
                If an error is non-nil, Messages displays an error informing the user that the message
                could not be delivered.
                
                This method should be called once in response to every:
                -[id<IMServicePlugInInstantMessageSupport> sendMessage:toHandle:]
    
    @param      message  The incoming message
    @param      handle   The sender of the message
    @param      error    An error that occurred during message delivery
*/
- (oneway void) plugInDidSendMessage:(IMServicePlugInMessage *)message toHandle:(NSString *)handle error:(NSError *)error;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                       IMServicePlugInMessage.h                                                                            0100644 0001750 0001750 00000001433 12566246160 037215  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    IMServicePlugInMessage.h
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>


typedef struct _IMServicePlugInMessageInternal IMServicePlugInMessageInternal;

@interface IMServicePlugInMessage : NSObject <NSCoding, NSCopying> {
    IMServicePlugInMessageInternal *_internal;
}

+ (id) servicePlugInMessageWithContent:(NSAttributedString*)content;
- (id) initWithContent:(NSAttributedString*)content;

+ (id) servicePlugInMessageWithContent:(NSAttributedString*)content date:(NSDate *)date;
- (id) initWithContent:(NSAttributedString*)content date:(NSDate *)date;

@property (readonly) NSString *guid;
@property (nonatomic, copy) NSAttributedString *content;
@property (nonatomic, copy) NSDate *date;

@end
                                                                                                                                                                                                                                     IMServicePlugInPresenceSupport.h                                                                    0100644 0001750 0001750 00000003675 12566246160 041004  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    Protocols for Group List Support
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>


#pragma mark -
#pragma mark IMServicePlugIn (Messages -> Service Plug-in)
#pragma mark -

/*!
    @protocol   IMServicePlugInPresenceSupport

    @discussion Implementing this protocol on your service plug-in's principal class indicates that your
                service supports presence information.
                
                If implementing this protocol, you must also include "IMServiceCapabilityPresenceSupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.

                If implementing this protocol, you may optionally include "IMServiceCapabilityPresenceInvisibilitySupport"
                in the "IMServiceCapabilities" key in the Info.plist of your service plug-in.  Doing so indicates that
                your service supports a value of YES for the IMSessionPropertyIsInvisible key of
                updateSessionProperties:.
*/
@protocol IMServicePlugInPresenceSupport

/*!
    @method     updateSessionProperties:

    @discussion Messages calls this method on the IMServicePlugIn instance when the 
                the user's availability, status message, idle state, or picture
                changes.

    @param      properties  A dictionary, corresponding to the modified session properties
    
                Available keys include:
                IMSessionPropertyAvailability   - the user's availablility
                IMSessionPropertyStatusMessage  - the user's status message
                IMSessionPropertyPictureData    - the user's icon
                IMSessionPropertyIdleDate       - the time of the last user activity
                IMSessionPropertyIsInvisible    - If YES, the user wishes to appear offline to other users
*/
- (oneway void) updateSessionProperties:(NSDictionary *)properties;

@end
                                                                   IMServicePlugInProtocols.h                                                                          0100644 0001750 0001750 00000015174 12566246160 037624  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    IMServicePlugIn Protocol
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>

@protocol IMServiceApplication;


#pragma mark -
#pragma mark IMServicePlugIn (Messages -> Service Plug-in)

/*!
    @protocol   IMServicePlugIn

    @discussion The principal class for each service plug-in must implement the IMServicePlugIn protocol.
    
                Messages messages your service plug-in instance to perform basic tasks such as
                logging in, logging out, and updating account settings.
*/
@protocol IMServicePlugIn <NSObject>


/*!
    @method     initWithServiceApplication:

    @discussion Messages calls this method to instantiate your service plug-in.
                
                At instantiation time, you are handed an IMServiceApplication
                which implements the corresponding protocols for each 
                optional protocol that your IMServicePlugIn implements.

    @param      serviceApplication  Your service application interface, used
                to communicate upwards to Messages.
*/
- (id) initWithServiceApplication:(id<IMServiceApplication>)serviceApplication;


/*!
    @method     updateAccountSettings:

    @discussion Messages calls this method on the IMServicePlugIn prior to login
                with the user's account settings.

    @param      accountSettings  An NSDictionary containing the account settings.
    
                Common keys:
                IMServerHostAccountSetting     NSString - the server hostname
                IMServerPortAccountSetting     NSNumber - the server port number
                IMLoginHandleAccountSetting    NSString - the login handle to use
                IMPasswordAccountSetting       NSString - the password
                IMUsesSSLAccountSetting        NSNumber - (YES = use SSL, NO = do not use SSL)
*/
- (oneway void) updateAccountSettings:(NSDictionary *)accountSettings;


/*!
    @method     login

    @discussion Messages calls this method on the IMServicePlugIn instance when the user 
                wishes to log into your service.

                Messages will show your service in the "Connecting" state until
                -plugInDidLogIn is called on the service application.
*/
- (oneway void) login;


/*!
    @method     logout

    @discussion Messages calls this method on the IMServicePlugIn instance when the user 
                wishes to disconnect from your service.

                Messages will show your service in the "Disconnecting" state until
                -plugInDidLogOutWithError: is called on the service application.
*/
- (oneway void) logout;

@end


#pragma mark -
#pragma mark IMServiceApplication (Service Plug-in -> Messages)

/*!
    @protocol   IMServiceApplication

    @discussion The IMServiceApplication is the base protocol your service plug-in uses to communicate
                information back to Messages.
                
                An object implementing the IMServiceApplication protocol is handed to your service
                plug-in in the -initWithServiceApplication: method.
*/
@protocol IMServiceApplication <NSObject>


/*!
    @method     plugInDidLogIn

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                changes the connection state from "Connecting" to "Connected"
*/
- (oneway void) plugInDidLogIn;


/*!
    @method     plugInDidLogOutWithError:

    @discussion When the IMServicePlugIn instance calls this method on the service application, Messages
                changes the connection state to "Disconnected".
         
    @param      error      An error, if any, that caused the disconnection.  If plugInDidLogOutWithError:
                           is called in response to a requested -logout, error should be nil
    @param      reconnect  If set to YES, Messages will attempt to reconnect to the service when the
                           IMAccountSettingServerHost associated with the account becomes reachable.
                           reconnect should only be set to YES when a network error causes a log out.
*/
- (oneway void) plugInDidLogOutWithError:(NSError *)error reconnect:(BOOL)reconnect;


/*!
     @method     plugInDidFailToAuthenticate
     
     @discussion When the IMServicePlugIn instance calls this method on the service application during
                 the login process, Messages will re-request the user name and password. It will then call
                 updateAccountSettings: with the new settings or logout if the user cancels.
*/
- (oneway void) plugInDidFailToAuthenticate;


/*!
    @method     plugInDidUpdateProperties:ofHandle:

    @discussion The IMServicePlugIn instance should call this method on Messages in response to 
                a change in one or more of a handle's properties.

                In addition, this method should be called once for each handle in the group 
                list after the first call to -plugInDidUpdateGroupList:error:

                Note:
                Messages may discard the properties of handles which are neither in the group list nor have
                an active conversation.  For this reason, only call -plugInDidUpdateProperties:ofHandle:
                to update the properties of a handle after specifying the handle in
                -plugInDidUpdateGroupList:error:, -plugInDidReceiveMessage:fromHandle:, or
                -plugInDidSendMessage:toHandle:error:
                
    @param      handle  A handle
                changes An NSDictionary, corresponding to new handle properties for the handle
                
                        Available keys include:
                        IMHandlePropertyAvailability      - The IMHandleAvailability of the handle
                        IMHandlePropertyStatusMessage     - Current status message as plaintext NSString
                        IMHandlePropertyIdleDate          - The time of the last user activity
                        IMHandlePropertyAlias             - A "prettier" version of the handle, if available
                        IMHandlePropertyFirstName         - The first name (given name) of a handle
                        IMHandlePropertyLastName          - The last name (family name) of a handle
                        IMHandlePropertyEmailAddress      - The e-mail address for a handle
                        IMHandlePropertyPictureIdentifier - A unique identifier for the handle's picture
                        IMHandlePropertyCapabilities      - The capabilities of the handle                
*/
- (oneway void) plugInDidUpdateProperties:(NSDictionary *)changes ofHandle:(NSString *)handle;

@end



                                                                                                                                                                                                                                                                                                                                                                                                    IMServicePlugInTypes.h                                                                              0100644 0001750 0001750 00000017157 12566246160 036747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Headers                                                             /*
    IMServicePlugInTypes.h
    IMServicePlugIn Framework
    Copyright (c) 2009-2010, Apple, Inc.
    All rights reserved.
*/

#ifndef IMSERVICEPLUGIN_EXTERN
#ifdef __cplusplus
#define IMSERVICEPLUGIN_EXTERN  extern "C" __attribute__((visibility("default")))
#else
#define IMSERVICEPLUGIN_EXTERN  extern __attribute__((visibility("default")))
#endif
#endif

#ifndef IMSERVICEPLUGIN_EXTERN_CLASS
#define IMSERVICEPLUGIN_EXTERN_CLASS  extern __attribute__((visibility("default")))
#endif

#import <Foundation/Foundation.h>

#pragma mark -
#pragma mark Account Settings

/*
    Used by:
        -[id<IMServicePlugIn> updateAccountSettings:]
*/
IMSERVICEPLUGIN_EXTERN NSString * const IMAccountSettingServerHost;     // NSString - the server hostname
IMSERVICEPLUGIN_EXTERN NSString * const IMAccountSettingServerPort;     // NSNumber - the server port number
IMSERVICEPLUGIN_EXTERN NSString * const IMAccountSettingLoginHandle;    // NSString - the login handle to use
IMSERVICEPLUGIN_EXTERN NSString * const IMAccountSettingPassword;       // NSString - the password
IMSERVICEPLUGIN_EXTERN NSString * const IMAccountSettingUsesSSL;        // NSNumber - (YES = use SSL, NO = do not use SSL)


#pragma mark -
#pragma mark Session Properties

//  Used by:
//    -[id<IMServicePlugInGroupListSupport> updateSessionProperties:]
//    -[IMServiceApplication sessionPropertiesChanged:]

typedef NS_ENUM(NSInteger, IMSessionAvailability) {
    IMSessionAvailabilityAway,
    IMSessionAvailabilityAvailable
};

IMSERVICEPLUGIN_EXTERN NSString * const IMSessionPropertyAvailability;      // NSNumber of IMSessionAvailabilityStatus
IMSERVICEPLUGIN_EXTERN NSString * const IMSessionPropertyStatusMessage;     // NSString  - Current status message as plaintext NSString
IMSERVICEPLUGIN_EXTERN NSString * const IMSessionPropertyPictureData;       // NSData    - Image that should be used for the users icon. 
IMSERVICEPLUGIN_EXTERN NSString * const IMSessionPropertyIdleDate;          // NSDate    - the time of the last user activity
IMSERVICEPLUGIN_EXTERN NSString * const IMSessionPropertyIsInvisible;       // NSNumber  - If YES, the user wishes to appear offline to other users.

#pragma mark -
#pragma mark Group List Types

typedef NS_ENUM(NSUInteger, IMGroupListPermissions) {
    IMGroupListCanReorderGroup   = (1 << 0),
    IMGroupListCanRenameGroup    = (1 << 1),
    IMGroupListCanAddNewMembers  = (1 << 2),
    IMGroupListCanRemoveMembers  = (1 << 3),
    IMGroupListCanReorderMembers = (1 << 4)
};

/* Use IMGroupListDefaultGroup for IMGroupListNameKey for ungrouped handles */
IMSERVICEPLUGIN_EXTERN NSString * const IMGroupListDefaultGroup;

IMSERVICEPLUGIN_EXTERN NSString * const IMGroupListNameKey;                 // NSString - the name of the group
IMSERVICEPLUGIN_EXTERN NSString * const IMGroupListPermissionsKey;          // NSNumber - the permissions for the group
IMSERVICEPLUGIN_EXTERN NSString * const IMGroupListHandlesKey;              // NSArray of NSStrings - the members in the group


#pragma mark -
#pragma mark Handle Properties

//  Used by:
//    -[IMServiceApplication handle:propertiesChanged:]

typedef NS_ENUM(NSInteger, IMHandleAvailability) {
    IMHandleAvailabilityUnknown   = -2,
    IMHandleAvailabilityOffline   = -1,
    IMHandleAvailabilityAway      =  0,
    IMHandleAvailabilityAvailable =  1
};

typedef NS_ENUM(NSInteger, IMHandleAuthorizationStatus) {
    IMHandleAuthorizationStatusAccepted = 0,  // An outgoing authorization request was accepted.  You are now able to see the handle's online status
    IMHandleAuthorizationStatusPending  = 1,  // An outgoing authorization request has been sent to the handle.  "Waiting for authorization"
    IMHandleAuthorizationStatusDeclined = 2   // An outgoing authorization request was declined.                 "Not Authorized"
};


IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyAvailability;          // NSNumber of IMHandleAvailability
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyStatusMessage;         // NSString  - Current status message as plaintext NSString
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyAuthorizationStatus;   // NSNumber of IMHandleAuthorizationStatus
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyIdleDate;              // NSDate    - If the user is idle, the time of the last user activity.  Use [NSDate distantPast] if the exact time is not known
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyAlias;                 // NSString  - A "prettier" version of the handle, if available
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyFirstName;             // NSString  - The first name (given name) of a handle
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyLastName;              // NSString  - The last name (family name) of a handle
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyEmailAddress;          // NSString  - The e-mail address for a handle
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyPictureIdentifier;     // NSString  - A unique identifier for the handle's picture 
IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyPictureData;           // NSData    - The handle's picture data. Include only in response to a -requestPictureForHandle:withIdentifier: request

IMSERVICEPLUGIN_EXTERN NSString * const IMHandlePropertyCapabilities;                // NSArray of the following NSStrings:
IMSERVICEPLUGIN_EXTERN NSString * const     IMHandleCapabilityMessaging;             //      If present, the handle can send and receive instant messages
IMSERVICEPLUGIN_EXTERN NSString * const     IMHandleCapabilityOfflineMessaging;      //      If present, the handle can receive instant messages when offline
IMSERVICEPLUGIN_EXTERN NSString * const     IMHandleCapabilityChatRoom;              //      If present, the handle can join chat rooms
IMSERVICEPLUGIN_EXTERN NSString * const     IMHandleCapabilityHandlePicture;         //      If present, the handle can have a handle picture
IMSERVICEPLUGIN_EXTERN NSString * const     IMHandleCapabilityFileTransfer;          //      If present, the handle can send and receive files


#pragma mark -
#pragma mark Rich-text Message Format Attributes

//  Used by:
//    -[IMServicePlugInMessage content]

IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeFontFamily;                 // NSString
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeFontSize;                   // NSNumber
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeItalic;                     // NSNumber  (YES = italic,    NO = normal)
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeBold;                       // NSNumber  (YES = bold,      NO = normal)
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeUnderline;                  // NSNumber  (YES = underline, NO = normal)
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeStrikethrough;              // NSNumber  (YES = strikethrough, NO = normal)
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeLink;                       // NSURL
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributePreformatted;               // NSNumber  (YES = preformatted, Messages should not add smileys, URLs, or data detection)
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeBaseWritingDirection;       // NSNumber  (-1 = natural, 0 = left-to-right, 1 = right-to-left)

// All colors specified as NSStrings in hex format (@"#ff0000", @"#fff", @"333", @"12abcd")
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeForegroundColor;            // The foreground color of text
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeBackgroundColor;            // The background color behind text
IMSERVICEPLUGIN_EXTERN NSString * const IMAttributeMessageBackgroundColor;     // The color of the background message bubble/box

                                                                                                                                                                                                                                                                                                                                                                                                                 IMServicePlugIn.tbd                                                                                 0100644 0001750 0001750 00000003040 12571375064 034655  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions/A                                                                     ---
archs:           [ x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/IMServicePlugIn
current-version: 1000.0
exports:         
  - archs:           [ x86_64 ]
    re-exports:      [ /System/Library/Frameworks/IMServicePlugIn.framework/Versions/A/Frameworks/IMServicePlugInSupport.framework/Versions/A/IMServicePlugInSupport ]
    symbols:         [ _IMFZCapabilitiesForServicePluginCapabilities, _IMServicePlugInCapabilitiesForFZCapabilities, 
                       _IMServicePlugInFileTransferSessionDidStartNotification, 
                       _IMServicePlugInFileTransferSessionDidUpdateNotification, 
                       _IMServicePlugInVersionNumber, _IMServicePlugInVersionString ]
    objc-classes:    [ _IMFileTransferInputStream, _IMFileTransferOutputStream, 
                       _IMServicePlugInFileTransfer, _IMServicePlugInFileTransferSession, 
                       _IMServicePlugInIncomingFileTransfer, _IMServicePlugInIncomingFileTransferSession, 
                       _IMServicePlugInMessage, _IMServicePlugInOutgoingFileTransfer, 
                       _IMServicePlugInOutgoingFileTransferSession ]
    objc-ivars:      [ _IMFileTransferInputStream._stream, _IMFileTransferInputStream._transfer, 
                       _IMFileTransferOutputStream._stream, _IMFileTransferOutputStream._transfer, 
                       _IMServicePlugInFileTransfer._internal, _IMServicePlugInFileTransferSession._internal, 
                       _IMServicePlugInMessage._internal ]
...
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 032475  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/Versions                                                                       osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IMServicePlugIn.framework/module.map  0100644 0001750 0001750 00000000741 12566173265 031300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        framework module IMServicePlugIn {
  umbrella header "IMServicePlugIn.h"

  export *
  module * { export * }

  explicit module IMServicePlugInFileTransfer {
    header "IMServicePlugInFileTransfer.h"
    export *
  }

  explicit module IMServicePlugInFileTransferSession {
    header "IMServicePlugInFileTransferSession.h"
    export *
  }

  explicit module IMServicePlugInFileTransferSessionSupport {
    header "IMServicePlugInFileTransferSessionSupport.h"
    export *
  }
}

                               osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/                0040755 0001750 0001750 00000000000 12612224741 026531  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Frameworks      0120777 0001750 0001750 00000000000 12620245063 036064  2Versions/Current/Frameworks                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Headers         0120777 0001750 0001750 00000000000 12620245063 034552  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/IOBluetooth.tbd 0120777 0001750 0001750 00000000000 12620245063 037536  2Versions/Current/IOBluetooth.tbd                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Modules         0120777 0001750 0001750 00000000000 12620245063 034644  2Versions/Current/Modules                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/       0040755 0001750 0001750 00000000000 12612224741 030341  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/     0040755 0001750 0001750 00000000000 12612224741 030521  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Frameworks/                                                                                         0040755 0001750 0001750 00000000000 12612224741 032562  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A                                                                         CoreBluetooth.framework                                                                             0120777 0001750 0001750 00000000000 12620245063 045023  2../../../../CoreBluetooth.framework                                                                 ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Frameworks                                                              Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032015  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A                                                                         Bluetooth.h                                                                                         0100644 0001750 0001750 00000314545 12567444611 034155  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 /*
	File:		Bluetooth.h
	Contains:	Public interfaces for Bluetooth technology.
	Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/

#pragma once

#ifdef KERNEL
#import	<IOKit/bluetooth/BluetoothAssignedNumbers.h>
#else
#import	<CoreFoundation/CFBase.h>
#import	<IOBluetooth/BluetoothAssignedNumbers.h>
#endif

#import <IOKit/IOTypes.h>
#import <libkern/OSByteOrder.h>

//---------------------------------------------------------------------------------------------------------------------------
/*!	@header		Bluetooth
	Bluetooth wireless technology
*/

#if defined(__cplusplus)
	#define IOBLUETOOTH_EXPORT extern "C"
#else
	#define IOBLUETOOTH_EXPORT extern
#endif

#ifdef	__cplusplus
	extern "C" {
#endif


#if 0

#pragma mark === Baseband ===
#endif

//===========================================================================================================================
//	Baseband
//===========================================================================================================================

typedef uint16_t		BluetoothConnectionHandle;		// Upper 4 bits are reserved.
typedef uint8_t		BluetoothLMPHandle;
enum
{
    kBluetoothConnectionHandleNone	= 0xffff
};

typedef uint8_t		BluetoothReasonCode;
typedef uint8_t		BluetoothEncryptionEnable;
enum
{
	kBluetoothEncryptionEnableOff           = 0x00,
	kBluetoothEncryptionEnableOn            = 0x01,
    
    kBluetoothEncryptionEnableBREDRE0       = 0x01,
    kBluetoothEncryptionEnableLEAESCCM      = 0x01,
    kBluetoothEncryptionEnableBREDRAESCCM   = 0x02
};

typedef uint8_t		BluetoothKeyFlag;
enum
{
	kBluetoothKeyFlagSemiPermanent 	= 0x00, 
	kBluetoothKeyFlagTemporary 		= 0x01
};

typedef uint8_t		BluetoothKeyType;
enum
{
	kBluetoothKeyTypeCombination					= 0x00, 
	kBluetoothKeyTypeLocalUnit						= 0x01,
	kBluetoothKeyTypeRemoteUnit						= 0x02,
	kBluetoothKeyTypeDebugCombination				= 0x03,
	kBluetoothKeyTypeUnauthenticatedCombination		= 0x04,
	kBluetoothKeyTypeAuthenticatedCombination		= 0x05,
	kBluetoothKeyTypeChangedCombination				= 0x06
};

// Packet types (Bluetooth spec section 7.1.5 - Create Connection)

typedef uint16_t		BluetoothPacketType;
enum
{
	kBluetoothPacketTypeReserved1	= 0x0001, 
	kBluetoothPacketType2DH1Omit	= 0x0002,	// Masks OUT this packet type
	kBluetoothPacketType3DH1Omit	= 0x0004,	// Masks OUT this packet type

	kBluetoothPacketTypeDM1			= 0x0008, 
	kBluetoothPacketTypeDH1			= 0x0010, 
	kBluetoothPacketTypeHV1			= 0x0020, 	// Reserved
	kBluetoothPacketTypeHV2			= 0x0040, 	// Reserved
	kBluetoothPacketTypeHV3			= 0x0080, 	// Reserved
	kBluetoothPacketTypeDV			= 0x0100, 	// Reserved
	kBluetoothPacketType2DH3Omit	= 0x0100,	// Masks OUT this packet type
	kBluetoothPacketType3DH3Omit	= 0x0200,	// Masks OUT this packet type
	kBluetoothPacketTypeAUX			= 0x0200,	// Deprecated
	
	kBluetoothPacketTypeDM3			= 0x0400, 
	kBluetoothPacketTypeDH3			= 0x0800,
	
	kBluetoothPacketType2DH5Omit	= 0x1000,	// Masks OUT this packet type
	kBluetoothPacketType3DM5Omit	= 0x2000,	// Masks OUT this packet type 
	
	kBluetoothPacketTypeDM5			= 0x4000, 
	kBluetoothPacketTypeDH5			= 0x8000, 
	
	kBluetoothPacketTypeEnd
};

// Setup Synchronous Packet types (Bluetooth 2.1 spec section 7.1.26 - Setup Synchronous Command)

enum
{
	kBluetoothSynchronousConnectionPacketTypeNone			= 0x0000,
	kBluetoothSynchronousConnectionPacketTypeHV1			= 0x0001,
	kBluetoothSynchronousConnectionPacketTypeHV2			= 0x0002,
	kBluetoothSynchronousConnectionPacketTypeHV3			= 0x0004,
	kBluetoothSynchronousConnectionPacketTypeEV3			= 0x0008,
	kBluetoothSynchronousConnectionPacketTypeEV4			= 0x0010,
	kBluetoothSynchronousConnectionPacketTypeEV5			= 0x0020,

	// masking out certain types:
	
	kBluetoothSynchronousConnectionPacketType2EV3Omit		= 0x0040,
	kBluetoothSynchronousConnectionPacketType3EV3Omit		= 0x0080,
	kBluetoothSynchronousConnectionPacketType2EV5Omit		= 0x0100,
	kBluetoothSynchronousConnectionPacketType3EV5Omit		= 0x0200,
	
	kBluetoothSynchronousConnectionPacketTypeFutureUse		= 0xFC00,
	
	kBluetoothSynchronousConnectionPacketTypeAll			= 0xFFFF,

	kBluetoothSynchronousConnectionPacketTypeEnd
};


// LAP/Inquiry Access Codes

typedef uint32_t		BluetoothLAP;
enum
{
	kBluetoothGeneralInquiryAccessCodeIndex		= 0, 			// General/Unlimited Inquiry Access Code (GIAC)
	kBluetoothGeneralInquiryAccessCodeLAPValue 	= 0x9E8B33, 	// General/Unlimited Inquiry Access Code (GIAC)
	
	kBluetoothLimitedInquiryAccessCodeIndex		= 1, 			// Limited Dedicated Inquiry Access Code (LIAC)
	kBluetoothLimitedInquiryAccessCodeLAPValue 	= 0x9E8B00, 	// Limited Dedicated Inquiry Access Code (LIAC)
	
	// All other access codes are reserved for future use (indices 2-63, LAP values 0x9E8B01-0x9E8B32 and 0x9E8B34-0x9E8B3F).
	
	kBluetoothLimitedInquiryAccessCodeEnd
};

// PageScanRepetitionMode

typedef	uint8_t	BluetoothPageScanRepetitionMode;
enum
{
	kBluetoothPageScanRepetitionModeR0 			= 0x00, 
	kBluetoothPageScanRepetitionModeR1 			= 0x01, 
	kBluetoothPageScanRepetitionModeR2 			= 0x02
	
	// All other values are reserved for future use.
};

// PageScanPeriodMode

typedef uint8_t	BluetoothPageScanPeriodMode;
enum
{
	kBluetoothPageScanPeriodModeP0 				= 0x00, 
	kBluetoothPageScanPeriodModeP1 				= 0x01, 
	kBluetoothPageScanPeriodModeP2 				= 0x02
	
	// All other values are reserved for future use.
};

// PageScanMode

typedef uint8_t	BluetoothPageScanMode;
enum
{
	kBluetoothPageScanModeMandatory 			= 0x00, 
	kBluetoothPageScanModeOptional1 			= 0x01, 
	kBluetoothPageScanModeOptional2 			= 0x02, 
	kBluetoothPageScanModeOptional3 			= 0x03
	
	// All other values are reserved for future use.
};
		
// PageScanType
		
typedef uint8_t	BluetoothHCIPageScanType;
enum BluetoothHCIPageScanTypes
{
	kBluetoothHCIPageScanTypeStandard		= 0x00,
	kBluetoothHCIPageScanTypeInterlaced		= 0x01,
			
	kBluetoothHCIPageScanTypeReservedStart	= 0x02,
	kBluetoothHCIPageScanTypeReservedEnd	= 0xFF
};	
		
// Erroneous Data Reporting
typedef uint8_t	BluetoothHCIErroneousDataReporting;
enum
{
	kBluetoothHCIErroneousDataReportingDisabled			= 0x00,
	kBluetoothHCIErroneousDataReportingEnabled			= 0x01,
			
	kBluetoothHCIErroneousDataReportingReservedStart	= 0x02,
	kBluetoothHCIErroneousDataReportingReservedEnd		= 0xFF
};		

#if 0
#pragma mark -
#pragma mark === Devices ===
#endif

typedef struct	BluetoothDeviceAddress		BluetoothDeviceAddress;
struct	BluetoothDeviceAddress
{
	uint8_t		data[ 6 ];
};

typedef struct	BluetoothKey				BluetoothKey;
struct	BluetoothKey
{
	uint8_t		data[ 16 ];
};

typedef struct  BluetoothIRK                BluetoothIRK;
struct BluetoothIRK
{
    uint8_t     data[ 16 ];
};
        
typedef struct	BluetoothPINCode			BluetoothPINCode;
struct	BluetoothPINCode
{
	uint8_t		data[ 16 ];		// PIN codes may be up to 128 bits.
};


//	Physical layout of the "class of device/service" field (see Bluetooth Assigned Numbers section 1.2):
//
//	 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//	 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  <- Bit Transmission Order
//	+---------------+---------------+---------------+
//	|    octet 3    |    octet 2    |    octet 1    | <- Octet Transmission Order
//	+---------------+---------------+---------------+
//	<------ 11 bits ----->< 5 bits ><- 6 bits ->
//	+---------------------+---------+-----------+-+-+
//	|   Service Classes   | Major   |  Minor    | | |
//	+-+-+-+-+-+-+-+-+-+-+-+  Device |   Device  |0|0|
//	| | | | | | | |*|*|*| |   Class |    Class  | | |
//	+-+-+-+-+-+-+-+-+-+-+-+---------+-----------+-+-+
//	 | | | | | | |       |                        |
//   | | | | | | |       + Limited Discoverable   +- Format Type
//	 | | | | | | +- Networking
//	 | | | | | +- Rendering
//	 | | | | +- Capturing
//	 | | | +- Object Transfer
//	 | | +- Audio
//	 | +- Telephony
//	 +- Information

typedef uint32_t		BluetoothClassOfDevice;

#define		BluetoothGetDeviceClassMajor( inCOD )		( (inCOD & 0x00001F00) >> 8 )
#define		BluetoothGetDeviceClassMinor( inCOD )		( (inCOD & 0x000000FC) >> 2 )
#define		BluetoothGetServiceClassMajor( inCOD )		( (inCOD & 0x00FFE000) >> 13 )
#define		BluetoothMakeClassOfDevice( inServiceClassMajor, inDeviceClassMajor, inDeviceClassMinor )		\
										(((inServiceClassMajor << 13) & 0x00FFE000) | ((inDeviceClassMajor << 8) & 0x00001F00) | ((inDeviceClassMinor << 2) & 0x000000FC))

///
/// Major Service Classes (11-bit value - bits 13-23 of Device/Service field)
///

typedef uint32_t		BluetoothServiceClassMajor;
// Service Class Major enum in BluetoothAssignedNumbers.h

///
/// Major Device Classes (5-bit value - bits 8-12 of Device/Service field)
///

typedef uint32_t		BluetoothDeviceClassMajor;
// Device Class Major enum in BluetoothAssignedNumbers.h

///
/// Minor Device Classes (6-bit value - bits 2-7 of Device/Service field)
///

typedef uint32_t		BluetoothDeviceClassMinor;
// Device Class Minor enum in BluetoothAssignedNumbers.h

// Misc Device Types

enum
{
	kBluetoothDeviceNameMaxLength	= 248
};

typedef uint8_t		BluetoothDeviceName[ 256 ];		// Max 248 bytes of UTF-8 encoded Unicode.
typedef uint16_t	BluetoothClockOffset;			// Bits 14-0 come from bits 16-2 of CLKslav-CLKmaster.
typedef uint8_t		BluetoothRole;					// 
typedef uint8_t		BluetoothAllowRoleSwitch;		// 0x00-0x01 valid, 0x02-0xFF reserved.
enum
{
	kBluetoothDontAllowRoleSwitch 	= 0x00, 
	kBluetoothAllowRoleSwitch 		= 0x01
};

enum
{
	kBluetoothRoleBecomeMaster 	= 0x00, 
	kBluetoothRoleRemainSlave 	= 0x01
};

typedef struct BluetoothSetEventMask	BluetoothSetEventMask;
struct	BluetoothSetEventMask
{
	uint8_t		data[ 8 ];
};

typedef uint8_t	BluetoothPINType;


#if 0
#pragma mark -
#pragma mark === L2CAP ===
#endif

//===========================================================================================================================
//	Logical Link Control and Adaptation Protocol (L2CAP)
//===========================================================================================================================


// ACL Packet values (Bluetooth L2CAP spec section 1).

enum
{
	kBluetoothL2CAPMaxPacketSize					= 65535,	// Max number of data bytes in an L2CAP packet.

	kBluetoothACLLogicalChannelReserved 			= 0, 		// [00] Reserved for future use
	kBluetoothACLLogicalChannelL2CAPContinue	 	= 1, 		// [01] Continuation of L2CAP packet.
	kBluetoothACLLogicalChannelL2CAPStart 			= 2, 		// [10] Start of L2CAP packet.
	kBluetoothACLLogicalChannelLMP	 				= 3			// [11] Link Manager Protocol packet.
};

// Channel Identifiers (Bluetooth L2CAP spec section 2.1).

typedef uint16_t		BluetoothL2CAPChannelID;
enum
{
	kBluetoothL2CAPChannelNull					= 0x0000, 	// Illegal, should not be used
	kBluetoothL2CAPChannelSignalling	 		= 0x0001, 	// L2CAP signalling channel
	kBluetoothL2CAPChannelConnectionLessData	= 0x0002, 	// L2CAP connection less data
	kBluetoothL2CAPChannelAMPManagerProtocol	= 0x0003,	// AMP Manager Protocol
	kBluetoothL2CAPChannelAttributeProtocol		= 0x0004,
	kBluetoothL2CAPChannelLESignalling			= 0x0005,
	kBluetoothL2CAPChannelSecurityManager		= 0x0006,
	// Range 0x0003 to 0x003F reserved for future use.
	kBluetoothL2CAPChannelReservedStart			= 0x0007,
    kBluetoothL2CAPChannelLEAP					= 0x002A,
    kBluetoothL2CAPChannelLEAS					= 0x002B,
	kBluetoothL2CAPChannelMagnet				= 0x003A, // Magnet
    kBluetoothL2CAPChannelReservedEnd			= 0x003F,
    
    // Range 0x0040 to 0xFFFF are dynamically allocated.
    kBluetoothL2CAPChannelDynamicStart			= 0x0040,
    kBluetoothL2CAPChannelDynamicEnd			= 0xffff,
	kBluetoothL2CAPChannelEnd					= 0xffff
};

typedef BluetoothL2CAPChannelID		BluetoothL2CAPGroupID;

// Protocol/Service Multiplexor (PSM) values (Bluetooth L2CAP spec section 5.2).

typedef uint16_t		BluetoothL2CAPPSM;
// PSM enum in BluetoothAssignedNumbers.h

// Command Codes

typedef enum
{
	kBluetoothL2CAPCommandCodeReserved							= 0x00, 
	kBluetoothL2CAPCommandCodeCommandReject						= 0x01, 
	kBluetoothL2CAPCommandCodeConnectionRequest					= 0x02, 
	kBluetoothL2CAPCommandCodeConnectionResponse				= 0x03, 
	kBluetoothL2CAPCommandCodeConfigureRequest					= 0x04, 
	kBluetoothL2CAPCommandCodeConfigureResponse					= 0x05, 
	kBluetoothL2CAPCommandCodeDisconnectionRequest				= 0x06, 
	kBluetoothL2CAPCommandCodeDisconnectionResponse				= 0x07, 
	kBluetoothL2CAPCommandCodeEchoRequest						= 0x08, 
	kBluetoothL2CAPCommandCodeEchoResponse						= 0x09, 
	kBluetoothL2CAPCommandCodeInformationRequest				= 0x0A, 
	kBluetoothL2CAPCommandCodeInformationResponse				= 0x0B,
	kBluetoothL2CAPCommandCodeCreateChannelRequest				= 0x0C,
	kBluetoothL2CAPCommandCodeCreateChannelResponse				= 0x0D,
	kBluetoothL2CAPCommandCodeMoveChannelRequest				= 0x0E,
	kBluetoothL2CAPCommandCodeMoveChannelResponse				= 0x0F,
	kBluetoothL2CAPCommandCodeMoveChannelConfirmation			= 0x10,
	kBluetoothL2CAPCommandCodeMoveChannelConfirmationResponse	= 0x11,
	kBluetoothL2CAPCommandCodeConnectionParameterUpdateRequest	= 0x12,
	kBluetoothL2CAPCommandCodeConnectionParameterUpdateResponse	= 0x13,
	kBluetoothL2CAPCommandCodeLECreditBasedConnectionRequest    = 0x14,
	kBluetoothL2CAPCommandCodeLECreditBasedConnectionResponse	= 0x15,
	kBluetoothL2CAPCommandCodeLEFlowControlCredit               = 0x16,
} BluetoothL2CAPCommandCode;

// Command Reject

typedef enum
{
	kBluetoothL2CAPCommandRejectReasonCommandNotUnderstood 	= 0x0000, 
	kBluetoothL2CAPCommandRejectReasonSignallingMTUExceeded = 0x0001, 
	kBluetoothL2CAPCommandRejectReasonInvalidCIDInRequest 	= 0x0002, 
} BluetoothL2CAPCommandRejectReason;

typedef uint16_t		BluetoothL2CAPMTU;
typedef	uint16_t		BluetoothL2CAPLinkTimeout;
typedef uint16_t		BluetoothL2CAPFlushTimeout;
enum
{
	kBluetoothL2CAPFlushTimeoutUseExisting 	= 0x0000, 
	kBluetoothL2CAPFlushTimeoutImmediate 	= 0x0001, 
	kBluetoothL2CAPFlushTimeoutForever 		= 0xFFFF, 
	
	kBluetoothL2CAPFlushTimeoutEnd
};

typedef struct BluetoothL2CAPQualityOfServiceOptions	BluetoothL2CAPQualityOfServiceOptions;
struct BluetoothL2CAPQualityOfServiceOptions
{
	uint8_t		flags;
	uint8_t		serviceType;
	uint32_t	tokenRate;
	uint32_t	tokenBucketSize;
	uint32_t	peakBandwidth;
	uint32_t	latency;
	uint32_t	delayVariation;
};

typedef struct BluetoothL2CAPRetransmissionAndFlowControlOptions BluetoothL2CAPRetransmissionAndFlowControlOptions;
struct BluetoothL2CAPRetransmissionAndFlowControlOptions
{
	uint8_t		flags;
	uint8_t		txWindowSize;
	uint8_t		maxTransmit;
	uint16_t	retransmissionTimeout;
	uint16_t	monitorTimeout;
	uint16_t	maxPDUPayloadSize;
};

enum
{
	kBluetoothL2CAPInfoTypeMaxConnectionlessMTUSize = 0x0001
};

// Packets

enum
{
	kBluetoothL2CAPPacketHeaderSize = 4
};

typedef uint16_t	BluetoothL2CAPByteCount;
typedef uint8_t		BluetoothL2CAPCommandID;
typedef uint16_t	BluetoothL2CAPCommandByteCount;

typedef enum
{
    kBluetoothL2CAPConnectionResultSuccessful				= 0x0000,
    kBluetoothL2CAPConnectionResultPending					= 0x0001,
    kBluetoothL2CAPConnectionResultRefusedPSMNotSupported	= 0x0002,
    kBluetoothL2CAPConnectionResultRefusedSecurityBlock		= 0x0003,
    kBluetoothL2CAPConnectionResultRefusedNoResources		= 0x0004,
} BluetoothL2CAPConnectionResult;

typedef enum 
{
    kBluetoothL2CAPConnectionStatusNoInfoAvailable			= 0x0000,
    kBluetoothL2CAPConnectionStatusAuthenticationPending	= 0x0001,
    kBluetoothL2CAPConnectionStatusAuthorizationPending		= 0x0002,
} BluetoothL2CAPConnectionStatus;

typedef enum
{
    kBluetoothL2CAPConfigurationResultSuccess					= 0x0000,
    kBluetoothL2CAPConfigurationResultUnacceptableParams		= 0x0001,
    kBluetoothL2CAPConfigurationResultRejected					= 0x0002,
    kBluetoothL2CAPConfigurationResultUnknownOptions			= 0x0003,
} BluetoothL2CAPConfigurationResult;

typedef enum
{
    kBluetoothL2CAPConfigurationOptionMTU                           = 0x01,
    kBluetoothL2CAPConfigurationOptionFlushTimeout                  = 0x02,
    kBluetoothL2CAPConfigurationOptionQoS                           = 0x03,
    kBluetoothL2CAPConfigurationOptionRetransmissionAndFlowControl  = 0x04,
    kBluetoothL2CAPConfigurationOptionFrameCheckSequence            = 0x05,
    kBluetoothL2CAPConfigurationOptionExtendedFlowSpecification     = 0x06,
    kBluetoothL2CAPConfigurationOptionExtendedWindowSize            = 0x07
} BluetoothL2CAPConfigurationOption;

enum
{
    kBluetoothL2CAPConfigurationOptionMTULength                             = 2,
    kBluetoothL2CAPConfigurationOptionFlushTimeoutLength                    = 2,
    kBluetoothL2CAPConfigurationOptionQoSLength                             = 22,
    kBluetoothL2CAPConfigurationOptionRetransmissionAndFlowControlLength    = 9
};

typedef enum
{
    kBluetoothL2CAPConfigurationBasicL2CAPModeFlag          = 0x00,
    kBluetoothL2CAPConfigurationRetransmissionModeFlag      = 0x01,
    kBluetoothL2CAPConfigurationFlowControlModeFlag         = 0x02,
    kBluetoothL2CAPConfigurationEnhancedRetransmissionMode  = 0x03,
    kBluetoothL2CAPConfigurationStreamingMode               = 0x04
} BluetoothL2CAPConfigurationRetransmissionAndFlowControlFlags;


typedef enum
{
    kBluetoothL2CAPInformationTypeConnectionlessMTU			= 0x0001,
    kBluetoothL2CAPInformationTypeExtendedFeatures			= 0x0002,
	kBluetoothL2CAPInformationTypeFixedChannelsSupported	= 0x0003,
} BluetoothL2CAPInformationType;

typedef enum
{
    kBluetoothL2CAPInformationResultSuccess			= 0x0000,
    kBluetoothL2CAPInformationResultNotSupported	= 0x0001,
} BluetoothL2CAPInformationResult;

typedef enum
{
    kBluetoothL2CAPInformationNoExtendedFeatures			= 0x00000000,
    kBluetoothL2CAPInformationFlowControlMode				= 0x00000001,
    kBluetoothL2CAPInformationRetransmissionMode			= 0x00000002,
    kBluetoothL2CAPInformationBidirectionalQoS				= 0x00000004,
	kBluetoothL2CAPInformationEnhancedRetransmissionMode	= 0x00000008,
	kBluetoothL2CAPInformationStreamingMode					= 0x00000010,
	kBluetoothL2CAPInformationFCSOption						= 0x00000020,
	kBluetoothL2CAPInformationExtendedFlowSpecification		= 0x00000040,
	kBluetoothL2CAPInformationFixedChannels					= 0x00000080,
	kBluetoothL2CAPInformationExtendedWindowSize			= 0x00000100,
	kBluetoothL2CAPUnicastConnectionlessDataReception		= 0x00000200,
} BluetoothL2CAPInformationExtendedFeaturesMask;

typedef enum
{
    kBluetoothL2CAPQoSTypeNoTraffic     = 0x00,
    kBluetoothL2CAPQoSTypeBestEffort	= 0x01,
    kBluetoothL2CAPQoSTypeGuaranteed	= 0x02,
} BluetoothL2CAPQoSType;

enum
{
	kBluetoothL2CAPMTULowEnergyDefault			= 0x001b,	// 27 bytes
	kBluetoothL2CAPMTUMinimum					= 0x0030,	// 48 bytes
	kBluetoothL2CAPMTUDefault					= 0x03F9,	// 11.10.08 - dropped back to 1017 from 1021 (don't aggravate the 3DH5 problem between CSR<->BRCM just yet)
	kBluetoothL2CAPMTUMaximum					= 0xffff,	
	kBluetoothL2CAPMTUStart						= 0x7fff,
	kBluetoothL2CAPMTUSIG						= 0x0030,	// 48 bytes
	kBluetoothL2CAPFlushTimeoutDefault			= kBluetoothL2CAPFlushTimeoutForever,	// 0xffff
	kBluetoothL2CAPQoSFlagsDefault				= 0,
	kBluetoothL2CAPQoSTypeDefault				= kBluetoothL2CAPQoSTypeBestEffort,	// 0x01
	kBluetoothL2CAPQoSTokenRateDefault			= 0x00000000,
	kBluetoothL2CAPQoSTokenBucketSizeDefault	= 0x00000000,
	kBluetoothL2CAPQoSPeakBandwidthDefault		= 0x00000000,
	kBluetoothL2CAPQoSLatencyDefault			= 0xffffffff,
	kBluetoothL2CAPQoSDelayVariationDefault		= 0xffffffff
};
		
#pragma mark === LE Security Manager ===

#define kBluetoothLESMPTimeout 30		
		
#define kBluetoothLESMPMinEncryptionKeySize 7
#define kBluetoothLESMPMaxEncryptionKeySize	16
		
enum BluetoothLESecurityManagerKeyDistributionFormat
{
	kBluetoothLESecurityManagerEncryptionKey			= (1 << 0L), // LTK, EDIV, RAND
	kBluetoothLESecurityManagerIDKey					= (1 << 1L), // IRK 
	kBluetoothLESecurityManagerSignKey					= (1 << 2L), // CSRK
    kBluetoothLESecurityManagerLinkKey					= (1 << 3L), // LinkKey
};				
		
typedef enum
{
	kBluetoothLESecurityManagerCommandCodeReserved                      = 0x00,
	kBluetoothLESecurityManagerCommandCodePairingRequest                = 0x01,
	kBluetoothLESecurityManagerCommandCodePairingResponse               = 0x02,
	kBluetoothLESecurityManagerCommandCodePairingConfirm                = 0x03,
	kBluetoothLESecurityManagerCommandCodePairingRandom                 = 0x04,
	kBluetoothLESecurityManagerCommandCodePairingFailed                 = 0x05,
	kBluetoothLESecurityManagerCommandCodeEncryptionInfo                = 0x06,
	kBluetoothLESecurityManagerCommandCodeMasterIdentification          = 0x07,
	kBluetoothLESecurityManagerCommandCodeIdentityInfo                  = 0x08,
	kBluetoothLESecurityManagerCommandCodeIdentityAddressInfo           = 0x09,
	kBluetoothLESecurityManagerCommandCodeSigningInfo                   = 0x0A,
    kBluetoothLESecurityManagerCommandCodeSecurityRequest               = 0x0B,
    kBluetoothLESecurityManagerCommandCodePairingPublicKey              = 0x0C,
    kBluetoothLESecurityManagerCommandCodePairingDHKeyCheck             = 0x0D,
    kBluetoothLESecurityManagerCommandCodePairingKeypressNotification	= 0x0E,
    
	// 0x0C - 0xFF reserved
	kBluetoothLESecurityManagerCommandCodeReservedStart                 = 0x0F,
	kBluetoothLESecurityManagerCommandCodeReservedEnd                   = 0xFF
} BluetoothLESecurityManagerCommandCode;

typedef enum
{
	kBluetoothLESecurityManagerUserInputCapabilityNoInput			= 0x01,
	kBluetoothLESecurityManagerUserInputCapabilityYesNo				= 0x02,
	kBluetoothLESecurityManagerUserInputCapabilityKeyboard			= 0x03
} BluetoothLESecurityManagerUserInputCapability;

typedef enum
{
	kBluetoothLESecurityManagerUserOutputCapabilityNoOutput			= 0x01,
	kBluetoothLESecurityManagerUserOutputCapabilityNumericOutput	= 0x02
} BluetoothLESecurityManagerUserOutputCapability;

typedef enum
{
	kBluetoothLESecurityManagerIOCapabilityDisplayOnly				= 0x00,
	kBluetoothLESecurityManagerIOCapabilityDisplayYesNo				= 0x01,
	kBluetoothLESecurityManagerIOCapabilityKeyboardOnly				= 0x02,
	kBluetoothLESecurityManagerIOCapabilityNoInputNoOutput          = 0x03,
	kBluetoothLESecurityManagerIOCapabilityKeyboardDisplay          = 0x04,
	
	// 0x05 - 0xFF reserved
	kBluetoothLESecurityManagerIOCapabilityReservedStart            = 0x05,
	kBluetoothLESecurityManagerIOCapabilityReservedEnd				= 0xFF
} BluetoothLESecurityManagerIOCapability;

typedef enum
{
	kBluetoothLESecurityManagerOOBAuthenticationDataNotPresent      = 0x00,
	kBluetoothLESecurityManagerOOBAuthenticationDataPresent         = 0x01,
	
	// 0x02 - 0xFF reserved
	kBluetoothLESecurityManagerOOBDataReservedStart					= 0x02,
	kBluetoothLESecurityManagerOOBDataReservedEnd					= 0xFF,
} BluetoothLESecurityManagerOOBData;

enum
{
	kBluetoothLESecurityManagerNoBonding							= 0,    // [00]
	kBluetoothLESecurityManagerBonding								= 1,    // [01]
	kBluetoothLESecurityManagerReservedStart						= 2,    // [10]
	kBluetoothLESecurityManagerReservedEnd							= 3     // [11]
};

typedef enum
{
	kBluetoothLESecurityManagerReasonCodeReserved                                           = 0x00,
	kBluetoothLESecurityManagerReasonCodePasskeyEntryFailed                                 = 0x01,
	kBluetoothLESecurityManagerReasonCodeOOBNotAvailbale                                    = 0x02,
	kBluetoothLESecurityManagerReasonCodeAuthenticationRequirements                         = 0x03,
	kBluetoothLESecurityManagerReasonCodeConfirmValueFailed                                 = 0x04,
	kBluetoothLESecurityManagerReasonCodePairingNotSupported                                = 0x05,
	kBluetoothLESecurityManagerReasonCodeEncryptionKeySize                                  = 0x06,
	kBluetoothLESecurityManagerReasonCodeCommandNotSupported                                = 0x07,
	kBluetoothLESecurityManagerReasonCodeUnspecifiedReason                                  = 0x08,
	kBluetoothLESecurityManagerReasonCodeRepeatedAttempts                                   = 0x09,
    kBluetoothLESecurityManagerReasonCodeInvalidParameters                                  = 0x0A,
    kBluetoothLESecurityManagerReasonCodeDHKeyCheckFailed                                   = 0x0B,
    kBluetoothLESecurityManagerReasonCodeNumericComparisonFailed                            = 0x0C,
    kBluetoothLESecurityManagerReasonCodeBREDRPairingInProgress                             = 0x0D,
    kBluetoothLESecurityManagerReasonCodeCrossTransportKeyDerivationGenerationNotAllowed    = 0x0E,
    
	kBluetoothLESecurityManagerReasonCodeReservedStart                                      = 0x0F,
	kBluetoothLESecurityManagerReasonCodeReservedEnd                                        = 0xFF
} BluetoothLESecurityManagerPairingFailedReasonCode;
        
typedef enum
{
    kBluetoothLESecurityManagerNotificationTypePasskeyEntryStarted      = 0,
    kBluetoothLESecurityManagerNotificationTypePasskeyDigitEntered      = 1,
    kBluetoothLESecurityManagerNotificationTypePasskeyDigitErased       = 2,
    kBluetoothLESecurityManagerNotificationTypePasskeyCleared           = 3,
    kBluetoothLESecurityManagerNotificationTypePasskeyEntryCompleted    = 4,
    
    kBluetoothLESecurityManagerNotificationTypeReservedStart            = 5,
    kBluetoothLESecurityManagerNotificationTypeReservedEnd              = 255,
}  BluetoothLESecurityManagerKeypressNotificationType;

		
		

#pragma mark === AMP Manager ===
typedef enum {
	kBluetoothAMPManagerCodeReserved							= 0x00,
	kBluetoothAMPManagerCodeAMPCommandReject					= 0x01,
	kBluetoothAMPManagerCodeAMPDiscoverRequest					= 0x02,
	kBluetoothAMPManagerCodeAMPDiscoverResponse					= 0x03,
	kBluetoothAMPManagerCodeAMPChangeNotify						= 0x04,
	kBluetoothAMPManagerCodeAMPChangeResponse					= 0x05,
	kBluetoothAMPManagerCodeAMPGetInfoRequest					= 0x06,
	kBluetoothAMPManagerCodeAMPGetInfoResponse					= 0x07,
	kBluetoothAMPManagerCodeAMPGetAssocRequest					= 0x08,
	kBluetoothAMPManagerCodeAMPGetAssocResponse					= 0x09,
	kBluetoothAMPManagerCodeAMPCreatePhysicalLinkRequest		= 0x0A,
	kBluetoothAMPManagerCodeAMPCreatePhysicalLinkResponse		= 0x0B,
	kBluetoothAMPManagerCodeAMPDisconnectPhysicalLinkRequest	= 0x0C,
	kBluetoothAMPManagerCodeAMPDisconnectPhysicalLinkResponse	= 0x0D,
} BluetoothAMPManagerCode;
		
typedef enum {
	kBluetoothAMPManagerCommandRejectReasonCommandNotRecognized	= 0x0000,
} BluetoothAMPCommandRejectReason;
		
typedef enum {
	kBluetoothAMPManagerDiscoverResponseControllerStatusPoweredDown		= 0x00,
	kBluetoothAMPManagerDiscoverResponseControllerStatusBluetoothOnly	= 0x01,
	kBluetoothAMPManagerDiscoverResponseControllerStatusNoCapacity		= 0x02,
	kBluetoothAMPManagerDiscoverResponseControllerStatusLowCapacity		= 0x03,
	kBluetoothAMPManagerDiscoverResponseControllerStatusMediumCapacity	= 0x04,
	kBluetoothAMPManagerDiscoverResponseControllerStatusHighCapacity	= 0x05,
	kBluetoothAMPManagerDiscoverResponseControllerStatusFullCapacity	= 0x06,
} BluetoothAMPDiscoverResponseControllerStatus;
		
typedef enum {
	kBluetoothAMPManagerGetInfoResponseSuccess				= 0x00,
	kBluetoothAMPManagerGetInfoResponseInvalidControllerID	= 0x01,
} BluetoothAMPGetInfoResponseStatus;
		
typedef enum {
	kBluetoothAMPManagerGetAssocResponseSuccess				= 0x00,
	kBluetoothAMPManagerGetAssocResponseInvalidControllerID	= 0x01,
} BluetoothAMPGetAssocResponseStatus;
		
typedef enum {
	kBluetoothAMPManagerCreatePhysicalLinkResponseSuccess										= 0x00,
	kBluetoothAMPManagerCreatePhysicalLinkResponseInvalidControllerID							= 0x01,
	kBluetoothAMPManagerCreatePhysicalLinkResponseUnableToStartLinkCreation						= 0x02,
	kBluetoothAMPManagerCreatePhysicalLinkResponseCollisionOccurred								= 0x03,
	kBluetoothAMPManagerCreatePhysicalLinkResponseAMPDisconnectedPhysicalLinkRequestReceived	= 0x04,
	kBluetoothAMPManagerCreatePhysicalLinkResponsePhysicalLinkAlreadyExists						= 0x05,
	kBluetoothAMPManagerCreatePhysicalLinkResponseSecurityViolation								= 0x06,
} BluetoothAMPCreatePhysicalLinkResponseStatus;
		
typedef enum {
	kBluetoothAMPManagerDisconnectPhysicalLinkResponseSuccess				= 0x00,
	kBluetoothAMPManagerDisconnectPhysicalLinkResponseInvalidControllerID	= 0x01,
	kBluetoothAMPManagerDisconnectPhysicalLinkResponseNoPhysicalLink		= 0x02,
} BluetoothAMPDisconnectPhysicalLinkResponseStatus;

#if 0
#pragma mark -
#pragma mark === HCI ===
#endif

//===========================================================================================================================
//	Host Controller Interface (HCI)
//===========================================================================================================================

//	HCI Command Packet
//	------------------
//	
//	                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
//	 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//	+--------------------------------+---------------+--------------+
//	|            OpCode              |               |              |
//	+--------------------+-----------| Param Length  |  Params...   |
//	|         OCF        |    OGF    |               |              |
//	+--------------------+-----------+---------------+--------------+
//	|                                                               |
//	|                         Params...                             |
//	|                                                               |
//	+---------------------------------------------------------------+

// Commands
		
typedef uint8_t		BluetoothHCICommandOpCodeGroup;
typedef uint16_t		BluetoothHCICommandOpCodeCommand;
typedef uint16_t		BluetoothHCICommandOpCode;
typedef	uint32_t		BluetoothHCIVendorCommandSelector;

#define	BluetoothHCIMakeCommandOpCode( GROUP, CMD )				( ( ( ( GROUP ) & 0x003F ) << 10 ) | ( ( CMD ) & 0x03FF ) )
#define	BluetoothHCIMakeCommandOpCodeEndianSwap( GROUP, CMD )	( CFSwapInt16HostToLittle ( BluetoothHCIMakeCommandOpCode( GROUP, CMD ) ) )
#define	BluetoothHCIExtractCommandOpCodeGroup( OPCODE )			( ( ( OPCODE ) >> 10 ) & 0x003F )
#define	BluetoothHCIExtractCommandOpCodeCommand( OPCODE )		( ( OPCODE ) & 0x03FF )

#define BluetoothHCIMakeCommandOpCodeHostOrder(GROUP, CMD )	OSSwapLittleToHostConstInt16( ( ( ( GROUP ) & 0x003F ) << 10 ) | ( ( CMD ) & 0x03FF ) )


enum
{
	// Command Group: NoOp
	
	kBluetoothHCIOpCodeNoOp												= 0, 
	kBluetoothHCICommandGroupNoOp										= 0x00, 
		kBluetoothHCICommandNoOp										= 0x0000,
	
	// Command Group: Link Control
	
	kBluetoothHCICommandGroupLinkControl								= 0x01, 
		kBluetoothHCICommandInquiry										= 0x0001, 
		kBluetoothHCICommandInquiryCancel								= 0x0002, 
		kBluetoothHCICommandPeriodicInquiryMode							= 0x0003, 
		kBluetoothHCICommandExitPeriodicInquiryMode						= 0x0004, 
		kBluetoothHCICommandCreateConnection							= 0x0005, 
		kBluetoothHCICommandDisconnect									= 0x0006, 
		kBluetoothHCICommandAddSCOConnection							= 0x0007,	// DEPRECATED
		kBluetoothHCICommandCreateConnectionCancel						= 0x0008,
		kBluetoothHCICommandAcceptConnectionRequest						= 0x0009, 
		kBluetoothHCICommandRejectConnectionRequest						= 0x000A, 
		kBluetoothHCICommandLinkKeyRequestReply							= 0x000B, 
		kBluetoothHCICommandLinkKeyRequestNegativeReply					= 0x000C, 
		kBluetoothHCICommandPINCodeRequestReply							= 0x000D, 
		kBluetoothHCICommandPINCodeRequestNegativeReply					= 0x000E, 
		kBluetoothHCICommandChangeConnectionPacketType					= 0x000F, 
		kBluetoothHCICommandAuthenticationRequested						= 0x0011, 
		kBluetoothHCICommandSetConnectionEncryption						= 0x0013, 
		kBluetoothHCICommandChangeConnectionLinkKey						= 0x0015, 
		kBluetoothHCICommandMasterLinkKey								= 0x0017, 
		kBluetoothHCICommandRemoteNameRequest							= 0x0019, 
		kBluetoothHCICommandReadRemoteSupportedFeatures					= 0x001B, 
		kBluetoothHCICommandReadRemoteExtendedFeatures					= 0x001C, 
		kBluetoothHCICommandReadRemoteVersionInformation				= 0x001D, 
		kBluetoothHCICommandReadClockOffset								= 0x001F, 
		kBluetoothHCICommandRemoteNameRequestCancel						= 0x001A,
		kBluetoothHCICommandReadLMPHandle								= 0x0020,
		kBluetoothHCICommandSetupSynchronousConnection					= 0x0028,
		kBluetoothHCICommandAcceptSynchronousConnectionRequest			= 0x0029,
		kBluetoothHCICommandRejectSynchronousConnectionRequest			= 0x002A,
		kBluetoothHCICommandIOCapabilityRequestReply					= 0x002B,
		kBluetoothHCICommandUserConfirmationRequestReply				= 0x002C,
		kBluetoothHCICommandUserConfirmationRequestNegativeReply		= 0x002D,
		kBluetoothHCICommandUserPasskeyRequestReply						= 0x002E,
		kBluetoothHCICommandUserPasskeyRequestNegativeReply				= 0x002F,
		kBluetoothHCICommandRemoteOOBDataRequestReply					= 0x0030,
		kBluetoothHCICommandRemoteOOBDataRequestNegativeReply			= 0x0033,
		kBluetoothHCICommandIOCapabilityRequestNegativeReply			= 0x0034,
		kBluetoothHCICommandEnhancedSetupSynchronousConnection			= 0x003D,
		kBluetoothHCICommandEnhancedAcceptSynchronousConnectionRequest	= 0x003E,
		kBluetoothHCICommandTruncatedPage								= 0x003F,
		kBluetoothHCICommandTruncatedPageCancel							= 0x0040,
		kBluetoothHCICommandSetConnectionlessSlaveBroadcast				= 0x0041,
		kBluetoothHCICommandSetConnectionlessSlaveBroadcastReceive		= 0x0042,
		kBluetoothHCICommandStartSynchronizationTrain					= 0x0043,
		kBluetoothHCICommandReceiveSynchronizationTrain					= 0x0044,
		kBluetoothHCICommandRemoteOOBExtendedDataRequestReply			= 0x0045,

	// Command Group: Link Policy
	
	kBluetoothHCICommandGroupLinkPolicy									= 0x02, 
		kBluetoothHCICommandHoldMode									= 0x0001, 
		kBluetoothHCICommandSniffMode									= 0x0003, 
		kBluetoothHCICommandExitSniffMode								= 0x0004, 
		kBluetoothHCICommandParkMode									= 0x0005, 
		kBluetoothHCICommandExitParkMode								= 0x0006, 
		kBluetoothHCICommandQoSSetup									= 0x0007, 
		kBluetoothHCICommandRoleDiscovery								= 0x0009, 
		kBluetoothHCICommandSwitchRole									= 0x000B, 
		kBluetoothHCICommandReadLinkPolicySettings						= 0x000C, 
		kBluetoothHCICommandWriteLinkPolicySettings						= 0x000D, 
		kBluetoothHCICommandReadDefaultLinkPolicySettings				= 0x000E,
		kBluetoothHCICommandWriteDefaultLinkPolicySettings				= 0x000F,
		kBluetoothHCICommandFlowSpecification							= 0x0010,
		kBluetoothHCICommandSniffSubrating								= 0x0011,
		kBluetoothHCICommandAcceptSniffRequest							= 0x0031,
		kBluetoothHCICommandRejectSniffRequest							= 0x0032,
	
	// Command Group: Host Controller & Baseband
	
	kBluetoothHCICommandGroupHostController								= 0x03, 
		kBluetoothHCICommandSetEventMask								= 0x0001, 
		kBluetoothHCICommandReset										= 0x0003, 
		kBluetoothHCICommandSetEventFilter								= 0x0005, 
		kBluetoothHCICommandFlush										= 0x0008, 
		kBluetoothHCICommandReadPINType									= 0x0009, 
		kBluetoothHCICommandWritePINType								= 0x000A, 
		kBluetoothHCICommandCreateNewUnitKey							= 0x000B, 
		kBluetoothHCICommandReadStoredLinkKey							= 0x000D, 
		kBluetoothHCICommandWriteStoredLinkKey							= 0x0011, 
		kBluetoothHCICommandDeleteStoredLinkKey							= 0x0012, 
		kBluetoothHCICommandChangeLocalName								= 0x0013, 
		kBluetoothHCICommandReadLocalName								= 0x0014, 
		kBluetoothHCICommandReadConnectionAcceptTimeout					= 0x0015, 
		kBluetoothHCICommandWriteConnectionAcceptTimeout				= 0x0016, 
		kBluetoothHCICommandReadPageTimeout								= 0x0017, 
		kBluetoothHCICommandWritePageTimeout							= 0x0018, 
		kBluetoothHCICommandReadScanEnable								= 0x0019, 
		kBluetoothHCICommandWriteScanEnable								= 0x001A, 
		kBluetoothHCICommandReadPageScanActivity						= 0x001B, 
		kBluetoothHCICommandWritePageScanActivity						= 0x001C, 
		kBluetoothHCICommandReadInquiryScanActivity						= 0x001D, 
		kBluetoothHCICommandWriteInquiryScanActivity					= 0x001E, 
		kBluetoothHCICommandReadAuthenticationEnable					= 0x001F, 
		kBluetoothHCICommandWriteAuthenticationEnable					= 0x0020, 
		kBluetoothHCICommandReadEncryptionMode							= 0x0021,	// DEPRECATED
		kBluetoothHCICommandWriteEncryptionMode							= 0x0022,	// DEPRECATED
		kBluetoothHCICommandReadClassOfDevice							= 0x0023,
		kBluetoothHCICommandWriteClassOfDevice							= 0x0024, 
		kBluetoothHCICommandReadVoiceSetting							= 0x0025,
		kBluetoothHCICommandWriteVoiceSetting							= 0x0026, 
		kBluetoothHCICommandReadAutomaticFlushTimeout					= 0x0027, 
		kBluetoothHCICommandWriteAutomaticFlushTimeout					= 0x0028, 
		kBluetoothHCICommandReadNumberOfBroadcastRetransmissions		= 0x0029, 
		kBluetoothHCICommandWriteNumberOfBroadcastRetransmissions		= 0x002A, 
		kBluetoothHCICommandReadHoldModeActivity						= 0x002B, 
		kBluetoothHCICommandWriteHoldModeActivity						= 0x002C, 
		kBluetoothHCICommandReadTransmitPowerLevel						= 0x002D, 
		kBluetoothHCICommandReadSCOFlowControlEnable					= 0x002E, 
		kBluetoothHCICommandWriteSCOFlowControlEnable					= 0x002F, 
		kBluetoothHCICommandSetHostControllerToHostFlowControl			= 0x0031, 
		kBluetoothHCICommandHostBufferSize								= 0x0033, 
		kBluetoothHCICommandHostNumberOfCompletedPackets				= 0x0035, 
		kBluetoothHCICommandReadLinkSupervisionTimeout					= 0x0036, 
		kBluetoothHCICommandWriteLinkSupervisionTimeout					= 0x0037, 
		kBluetoothHCICommandReadNumberOfSupportedIAC					= 0x0038, 
		kBluetoothHCICommandReadCurrentIACLAP							= 0x0039, 
		kBluetoothHCICommandWriteCurrentIACLAP							= 0x003A, 
		kBluetoothHCICommandReadPageScanPeriodMode						= 0x003B,	// DEPRECATED 
		kBluetoothHCICommandWritePageScanPeriodMode						= 0x003C,	// DEPRECATED 
		kBluetoothHCICommandReadPageScanMode							= 0x003D,	// DEPRECATED 
		kBluetoothHCICommandWritePageScanMode							= 0x003E,	// DEPRECATED 
		kBluetoothHCICommandSetAFHClassification						= 0x003F, 		
		kBluetoothHCICommandReadInquiryScanType							= 0x0042, 		
		kBluetoothHCICommandWriteInquiryScanType						= 0x0043, 		
		kBluetoothHCICommandReadInquiryMode								= 0x0044, 		
		kBluetoothHCICommandWriteInquiryMode							= 0x0045,
		kBluetoothHCICommandReadPageScanType							= 0x0046,
		kBluetoothHCICommandWritePageScanType							= 0x0047,
		kBluetoothHCICommandReadAFHChannelAssessmentMode				= 0x0048,
		kBluetoothHCICommandWriteAFHChannelAssessmentMode				= 0x0049,
		kBluetoothHCICommandReadExtendedInquiryResponse					= 0x0051, 		
		kBluetoothHCICommandWriteExtendedInquiryResponse				= 0x0052,
		kBluetoothHCICommandRefreshEncryptionKey						= 0x0053,
		kBluetoothHCICommandReadSimplePairingMode						= 0x0055,
		kBluetoothHCICommandWriteSimplePairingMode						= 0x0056,
		kBluetoothHCICommandReadLocalOOBData							= 0x0057,
		kBluetoothHCICommandReadInquiryResponseTransmitPower			= 0x0058,
		kBluetoothHCICommandWriteInquiryResponseTransmitPower			= 0x0059,
		kBluetoothHCICommandSendKeypressNotification					= 0x0060,
		kBluetoothHCICommandReadDefaultErroneousDataReporting			= 0x005A,
		kBluetoothHCICommandWriteDefaultErroneousDataReporting			= 0x005B,
		kBluetoothHCICommandEnhancedFlush								= 0x005F,
		kBluetoothHCICommandReadLogicalLinkAcceptTimeout				= 0x0061,
		kBluetoothHCICommandWriteLogicalLinkAcceptTimeout				= 0x0062,
		kBluetoothHCICommandSetEventMaskPageTwo							= 0x0063,
		kBluetoothHCICommandReadLocationData							= 0x0064,
		kBluetoothHCICommandWriteLocationData							= 0x0065,
		kBluetoothHCICommandReadFlowControlMode							= 0x0066,
		kBluetoothHCICommandWriteFlowControlMode						= 0x0067,
		kBluetoothHCICommandReadEnhancedTransmitPowerLevel				= 0x0068,
		kBluetoothHCICommandReadBestEffortFlushTimeout					= 0x0069,
		kBluetoothHCICommandWriteBestEffortFlushTimeout					= 0x006A,
		kBluetoothHCICommandShortRangeMode								= 0x006B,
		kBluetoothHCICommandReadLEHostSupported							= 0x006C,
		kBluetoothHCICommandWriteLEHostSupported						= 0x006D,
		kBluetoothHCICommandSetMWSChannelParameters						= 0x006E,
		kBluetoothHCICommandSetExternalFrameConfiguration				= 0x006F,
		kBluetoothHCICommandSetMWSSignaling								= 0x0070,
		kBluetoothHCICommandSetMWSTransportLayer						= 0x0071,
		kBluetoothHCICommandSetMWSScanFrequencyTable					= 0x0072,
		kBluetoothHCICommandSetMWSPATTERNConfiguration					= 0x0073,
		kBluetoothHCICommandSetReservedLTADDR							= 0x0074,
		kBluetoothHCICommandDeleteReservedLTADDR						= 0x0075,
		kBluetoothHCICommandSetConnectionlessSlaveBroadcastData			= 0x0076,
		kBluetoothHCICommandReadSynchronizationTrainParameters			= 0x0077,
		kBluetoothHCICommandWriteSynchronizationTrainParameters			= 0x0078,
		kBluetoothHCICommandReadSecureConnectionsHostSupport			= 0x0079,
		kBluetoothHCICommandWriteSecureConnectionsHostSupport			= 0x007A,
		kBluetoothHCICommandReadAuthenticatedPayloadTimeout				= 0x007B,
		kBluetoothHCICommandWriteAuthenticatedPayloadTimeout			= 0x007C,
		kBluetoothHCICommandReadLocalOOBExtendedData					= 0x007D,
		kBluetoothHCICommandReadExtendedPageTimeout						= 0x007E,
		kBluetoothHCICommandWriteExtendedPageTimeout					= 0x007F,
		kBluetoothHCICommandReadExtendedInquiryLength					= 0x0080,
		kBluetoothHCICommandWriteExtendedInquiryLength					= 0x0081,

	// Command Group: Informational
	
	kBluetoothHCICommandGroupInformational								= 0x04, 
		kBluetoothHCICommandReadLocalVersionInformation					= 0x0001, 
		kBluetoothHCICommandReadLocalSupportedCommands					= 0x0002, 
		kBluetoothHCICommandReadLocalSupportedFeatures					= 0x0003, 
		kBluetoothHCICommandReadLocalExtendedFeatures					= 0x0004,
		kBluetoothHCICommandReadBufferSize								= 0x0005, 
		kBluetoothHCICommandReadCountryCode								= 0x0007,	// DEPRECATED 
		kBluetoothHCICommandReadDeviceAddress							= 0x0009,
		kBluetoothHCICommandReadDataBlockSize							= 0x000A,
		kBluetoothHCICommandReadLocalSupportedCodecs					= 0x000B,
	
	// Command Group: Status
	
	kBluetoothHCICommandGroupStatus										= 0x05, 
		kBluetoothHCICommandReadFailedContactCounter					= 0x0001, 
		kBluetoothHCICommandResetFailedContactCounter					= 0x0002, 
		kBluetoothHCICommandGetLinkQuality								= 0x0003, 
		kBluetoothHCICommandReadRSSI									= 0x0005, 
		kBluetoothHCICommandReadAFHMappings								= 0x0006,
		kBluetoothHCICommandReadClock									= 0x0007,
		kBluetoothHCICommandReadEncryptionKeySize						= 0x0008,
		kBluetoothHCICommandReadLocalAMPInfo							= 0x0009,
		kBluetoothHCICommandReadLocalAMPASSOC							= 0x000A,
		kBluetoothHCICommandWriteRemoteAMPASSOC							= 0x000B,
		kBluetoothHCICommandGetMWSTransportLayerConfiguration			= 0x000C,
		kBluetoothHCICommandSetTriggeredClockCapture					= 0x000D,

	// Command Group: Testing
	
	kBluetoothHCICommandGroupTesting									= 0x06, 
		kBluetoothHCICommandReadLoopbackMode							= 0x0001, 
		kBluetoothHCICommandWriteLoopbackMode							= 0x0002, 
		kBluetoothHCICommandEnableDeviceUnderTestMode					= 0x0003, 
		kBluetoothHCICommandWriteSimplePairingDebugMode					= 0x0004,
		kBluetoothHCICommandEnableAMPReceiverReports					= 0x0007,
		kBluetoothHCICommandAMPTestEnd									= 0x0008,
		kBluetoothHCICommandAMPTest										= 0x0009,

	// Command Group: Low Energy
	
	kBluetoothHCICommandGroupLowEnergy										= 0x08,
		kBluetoothHCICommandLESetEventMask									= 0x0001,
		kBluetoothHCICommandLEReadBufferSize								= 0x0002,
		kBluetoothHCICommandLEReadLocalSupportedFeatures					= 0x0003,
		kBluetoothHCICommandLESetRandomAddress								= 0x0005,
		kBluetoothHCICommandLESetAdvertisingParameters						= 0x0006,
		kBluetoothHCICommandLEReadAdvertisingChannelTxPower					= 0x0007,
		kBluetoothHCICommandLESetAdvertisingData							= 0x0008,
		kBluetoothHCICommandLESetScanResponseData							= 0x0009,
		kBluetoothHCICommandLESetAdvertiseEnable							= 0x000A,
		kBluetoothHCICommandLESetScanParameters								= 0x000B,
		kBluetoothHCICommandLESetScanEnable									= 0x000C,
		kBluetoothHCICommandLECreateConnection								= 0x000D,
		kBluetoothHCICommandLECreateConnectionCancel						= 0x000E,
		kBluetoothHCICommandLEReadWhiteListSize								= 0x000F,
		kBluetoothHCICommandLEClearWhiteList								= 0x0010,
		kBluetoothHCICommandLEAddDeviceToWhiteList							= 0x0011,
		kBluetoothHCICommandLERemoveDeviceFromWhiteList						= 0x0012,
		kBluetoothHCICommandLEConnectionUpdate								= 0x0013,
		kBluetoothHCICommandLESetHostChannelClassification					= 0x0014,
		kBluetoothHCICommandLEReadChannelMap								= 0x0015,
		kBluetoothHCICommandLEReadRemoteUsedFeatures						= 0x0016,
		kBluetoothHCICommandLEEncrypt										= 0x0017,
		kBluetoothHCICommandLERand											= 0x0018,
		kBluetoothHCICommandLEStartEncryption								= 0x0019,
		kBluetoothHCICommandLELongTermKeyRequestReply						= 0x001A,
		kBluetoothHCICommandLELongTermKeyRequestNegativeReply				= 0x001B,
		kBluetoothHCICommandLEReadSupportedStates							= 0x001C,
		kBluetoothHCICommandLEReceiverTest									= 0x001D,
		kBluetoothHCICommandLETransmitterTest								= 0x001E,
		kBluetoothHCICommandLETestEnd										= 0x001F,
		kBluetoothHCICommandLERemoteConnectionParameterRequestReply			= 0x0020,
		kBluetoothHCICommandLERemoteConnectionParameterRequestNegativeReply	= 0x0021,
		kBluetoothHCICommandLESetDataLength									= 0x0022,
		kBluetoothHCICommandLEReadSuggestedDefaultDataLength				= 0x0023,
		kBluetoothHCICommandLEWriteSuggestedDefaultDataLength				= 0x0024,
		kBluetoothHCICommandLEReadLocalP256PublicKey						= 0x0025,
		kBluetoothHCICommandLEGenerateDHKey									= 0x0026,
		kBluetoothHCICommandLEAddDeviceToResolvingList						= 0x0027,
		kBluetoothHCICommandLERemoveDeviceFromResolvingList					= 0x0028,
		kBluetoothHCICommandLEClearResolvingList							= 0x0029,
		kBluetoothHCICommandLEReadResolvingListSize							= 0x002A,
		kBluetoothHCICommandLEReadPeerResolvableAddress						= 0x002B,
		kBluetoothHCICommandLEReadLocalResolvableAddress					= 0x002C,
		kBluetoothHCICommandLESetAddressResolutionEnable					= 0x002D,
		kBluetoothHCICommandLESetResolvablePrivateAddressTimeout			= 0x002E,
		kBluetoothHCICommandLEReadMaximumDataLength							= 0x002F,
	
	// Command Group: Logo Testing (no commands yet)
	
	kBluetoothHCICommandGroupLogoTesting 								= 0x3E, 
	
	// Command Group: Vendor Specific
	kBluetoothHCICommandGroupVendorSpecific								= 0x3F, 
	
	kBluetoothHCICommandGroupMax										= 0x40, 
	kBluetoothHCICommandMax												= 0x03FF
};

// HCI Data Types

typedef uint8_t										BluetoothHCIQoSFlags;
typedef uint8_t										BluetoothHCIParamByteCount;
typedef uint16_t									BluetoothHCIACLDataByteCount;
typedef uint8_t										BluetoothHCISCODataByteCount;
typedef uint8_t										BluetoothHCIInquiryLength;
typedef uint8_t										BluetoothHCIResponseCount;
typedef uint8_t										BluetoothHCICountryCode;
typedef uint16_t									BluetoothHCIModeInterval;
typedef uint16_t									BluetoothHCISniffAttemptCount;
typedef uint16_t									BluetoothHCISniffTimeout;
typedef uint16_t									BluetoothHCIParkModeBeaconInterval;

typedef uint8_t										BluetoothMaxSlots;
typedef uint16_t									BluetoothManufacturerName;
typedef uint8_t										BluetoothLMPVersion;
typedef uint16_t									BluetoothLMPSubversion;

typedef uint8_t										BluetoothHCIConnectionMode;
enum BluetoothHCIConnectionModes
{
	kConnectionActiveMode					= 0,
	kConnectionHoldMode						= 1,
	kConnectionSniffMode					= 2,
	kConnectionParkMode						= 3,
	kConnectionModeReservedForFutureUse		= 4,
};
				
typedef struct	BluetoothHCISupportedCommands		BluetoothHCISupportedCommands;
struct BluetoothHCISupportedCommands
{
	uint8_t	data[64];
};		
		
typedef struct	BluetoothHCISupportedFeatures		BluetoothHCISupportedFeatures;
struct BluetoothHCISupportedFeatures
{
	uint8_t	data[8];
};

typedef uint8_t										BluetoothHCIPageNumber;
typedef struct	BluetoothHCIExtendedFeaturesInfo	BluetoothHCIExtendedFeaturesInfo;
struct BluetoothHCIExtendedFeaturesInfo
{
	BluetoothHCIPageNumber	page;
	BluetoothHCIPageNumber	maxPage;
	uint8_t					data[8];
};
		
enum BluetoothFeatureBits
{
	// Byte 0 of the support features data structure.

	kBluetoothFeatureThreeSlotPackets					= (1 << 0L),
	kBluetoothFeatureFiveSlotPackets					= (1 << 1L),
	kBluetoothFeatureEncryption							= (1 << 2L),
	kBluetoothFeatureSlotOffset							= (1 << 3L),
	kBluetoothFeatureTimingAccuracy						= (1 << 4L),
	kBluetoothFeatureSwitchRoles						= (1 << 5L),
	kBluetoothFeatureHoldMode							= (1 << 6L),
	kBluetoothFeatureSniffMode							= (1 << 7L),
	
	// Byte 1 of the support features data structure.

	kBluetoothFeatureParkMode							= (1 << 0L),
	kBluetoothFeatureRSSI								= (1 << 1L),
	kBluetoothFeaturePowerControlRequests				= (1 << 1L),
	kBluetoothFeatureChannelQuality						= (1 << 2L),
	kBluetoothFeatureSCOLink							= (1 << 3L),
	kBluetoothFeatureHV2Packets							= (1 << 4L),
	kBluetoothFeatureHV3Packets							= (1 << 5L),
	kBluetoothFeatureULawLog							= (1 << 6L),
	kBluetoothFeatureALawLog							= (1 << 7L),

	// Byte 2 of the support features data structure.

	kBluetoothFeatureCVSD								= (1 << 0L),
	kBluetoothFeaturePagingScheme						= (1 << 1L),
	kBluetoothFeaturePowerControl						= (1 << 2L),
	kBluetoothFeatureTransparentSCOData					= (1 << 3L),
	kBluetoothFeatureFlowControlLagBit0					= (1 << 4L),
	kBluetoothFeatureFlowControlLagBit1					= (1 << 5L),
	kBluetoothFeatureFlowControlLagBit2					= (1 << 6L),
	kBluetoothFeatureBroadcastEncryption				= (1 << 7L),	
	
	// Byte 3 of the support features data structure.	
	
	kBluetoothFeatureScatterMode						= (1 << 0L),
	kBluetoothFeatureEnhancedDataRateACL2MbpsMode		= (1 << 1L),	
	kBluetoothFeatureEnhancedDataRateACL3MbpsMode		= (1 << 2L),	
	kBluetoothFeatureEnhancedInquiryScan				= (1 << 3L),
	kBluetoothFeatureInterlacedInquiryScan				= (1 << 4L),	
	kBluetoothFeatureInterlacedPageScan					= (1 << 5L),		
	kBluetoothFeatureRSSIWithInquiryResult				= (1 << 6L),	
	kBluetoothFeatureExtendedSCOLink					= (1 << 7L),

	// Byte 4 of the support features data structure.	

	kBluetoothFeatureEV4Packets							= (1 << 0L),
	kBluetoothFeatureEV5Packets							= (1 << 1L),	
	kBluetoothFeatureAbsenceMasks						= (1 << 2L),
	kBluetoothFeatureAFHCapableSlave					= (1 << 3L),
	kBluetoothFeatureAFHClassificationSlave				= (1 << 4L),	
	kBluetoothFeatureAliasAuhentication					= (1 << 5L),
	kBluetoothFeatureLESupportedController				= (1 << 6L),
	kBluetoothFeature3SlotEnhancedDataRateACLPackets	= (1 << 7L),
	
	// Byte 5 of the support features data structure.

	kBluetoothFeature5SlotEnhancedDataRateACLPackets	= (1 << 0L), // 2.0 version of this header had this at the wrong bit location
	kBluetoothFeatureSniffSubrating						= (1 << 1L),
	kBluetoothFeaturePauseEncryption					= (1 << 2L),
	kBluetoothFeatureAFHCapableMaster					= (1 << 3L),
	kBluetoothFeatureAFHClassificationMaster			= (1 << 4L),
	kBluetoothFeatureEnhancedDataRateeSCO2MbpsMode		= (1 << 5L),
	kBluetoothFeatureEnhancedDataRateeSCO3MbpsMode		= (1 << 6L),
	kBluetoothFeature3SlotEnhancedDataRateeSCOPackets	= (1 << 7L),
	
	// Byte 6 of the support features data structure.	

	kBluetoothFeatureExtendedInquiryResponse			= (1 << 0L),
	kBluetoothFeatureSecureSimplePairing				= (1 << 3L),
	kBluetoothFeatureEncapsulatedPDU					= (1 << 4L),
	kBluetoothFeatureErroneousDataReporting				= (1 << 5L),
	kBluetoothFeatureNonFlushablePacketBoundaryFlag		= (1 << 6L),
	
	// Byte 7 of the support features data structure.

	kBluetoothFeatureLinkSupervisionTimeoutChangedEvent	= (1 << 0L),
	kBluetoothFeatureInquiryTransmissionPowerLevel		= (1 << 1L),
	kBluetoothFeatureExtendedFeatures					= (1 << 7L),
	
	// Byte 8 of the support features data structure (extended)

	kBluetoothFeatureSimpleSecurePairingHostMode		= (1 << 0L),

};

typedef struct BluetoothEventFilterCondition	BluetoothEventFilterCondition;
struct BluetoothEventFilterCondition
{
    uint8_t		data[ 7 ];
};        
        
typedef uint16_t										BluetoothHCIFailedContactCount;
typedef struct BluetoothHCIFailedContactInfo		BluetoothHCIFailedContactInfo;
struct BluetoothHCIFailedContactInfo
{
	BluetoothHCIFailedContactCount	count;
	BluetoothConnectionHandle		handle;
};

typedef SInt8										BluetoothHCIRSSIValue;	/* Valid Range: -127 to +20 */
typedef struct BluetoothHCIRSSIInfo					BluetoothHCIRSSIInfo;
struct BluetoothHCIRSSIInfo
{
	BluetoothConnectionHandle		handle;
	BluetoothHCIRSSIValue			RSSIValue;
};

typedef	uint8_t										BluetoothHCILinkQuality;
typedef struct BluetoothHCILinkQualityInfo			BluetoothHCILinkQualityInfo;
struct BluetoothHCILinkQualityInfo
{
	BluetoothConnectionHandle		handle;
	BluetoothHCILinkQuality			qualityValue;
};

typedef uint8_t	BluetoothHCIRole;
typedef struct	BluetoothHCIRoleInfo					BluetoothHCIRoleInfo;
struct BluetoothHCIRoleInfo
{
	uint8_t						role;
	BluetoothConnectionHandle	handle;
};

enum BluetoothHCIRoles
{
	kBluetoothHCIMasterRole				= 0x00,
	kBluetoothHCISlaveRole				= 0x01
};

typedef uint16_t										BluetoothHCILinkPolicySettings;
enum BluetoothHCILinkPolicySettingsValues
{
	kDisableAllLMModes					= 0x0000,
	kEnableMasterSlaveSwitch			= 0x0001,
	kEnableHoldMode						= 0x0002,
	kEnableSniffMode					= 0x0004,
	kEnableParkMode						= 0x0008,
	kReservedForFutureUse				= 0x0010
};

typedef struct	BluetoothHCILinkPolicySettingsInfo		BluetoothHCILinkPolicySettingsInfo;
struct BluetoothHCILinkPolicySettingsInfo
{
	BluetoothHCILinkPolicySettings		settings;
	BluetoothConnectionHandle			handle;
};


typedef struct BluetoothHCIQualityOfServiceSetupParams	BluetoothHCIQualityOfServiceSetupParams;
struct BluetoothHCIQualityOfServiceSetupParams
{
	uint8_t		flags;
	uint8_t		serviceType;
	uint32_t		tokenRate;
	uint32_t		peakBandwidth;
	uint32_t		latency;
	uint32_t		delayVariation;
};

typedef struct BluetoothHCISetupSynchronousConnectionParams	BluetoothHCISetupSynchronousConnectionParams;
struct BluetoothHCISetupSynchronousConnectionParams
{
	uint32_t		transmitBandwidth;
	uint32_t		receiveBandwidth;
	uint16_t		maxLatency;
	uint16_t		voiceSetting;
	uint8_t		retransmissionEffort;
	uint16_t		packetType;
};
		
typedef struct BluetoothHCIAcceptSynchronousConnectionRequestParams	BluetoothHCIAcceptSynchronousConnectionRequestParams;
struct BluetoothHCIAcceptSynchronousConnectionRequestParams
{
	uint32_t		transmitBandwidth;
	uint32_t		receiveBandwidth;
	uint16_t		maxLatency;
	uint16_t		contentFormat;
	uint8_t		retransmissionEffort;
	uint16_t		packetType;
};

typedef uint8_t	BluetoothHCILoopbackMode;
enum
{
	kBluetoothHCILoopbackModeOff		= 0x00,
	kBluetoothHCILoopbackModeLocal		= 0x01,
	kBluetoothHCILoopbackModeRemote		= 0x02
};
		
typedef struct BluetoothReadClockInfo BluetoothReadClockInfo;
struct BluetoothReadClockInfo
{
	BluetoothConnectionHandle	handle;
	uint32_t					clock;
	uint16_t					accuracy;			
};
        
typedef struct BluetoothHCIEventFlowSpecificationData BluetoothHCIEventFlowSpecificationData;
struct BluetoothHCIEventFlowSpecificationData
{
    BluetoothConnectionHandle					connectionHandle;
    uint8_t										flags;
    uint8_t										flowDirection;
    uint8_t										serviceType;
    uint32_t									tokenRate;
    uint32_t									tokenBucketSize;
    uint32_t									peakBandwidth;
    uint32_t									accessLatency;
};        
                
typedef uint32_t BluetoothHCIOperationID;
typedef uint32_t BluetoothHCIEventID;
typedef uint32_t BluetoothHCIDataID;
typedef uint32_t BluetoothHCISignalID;
typedef uint32_t BluetoothHCITransportID;
typedef uint32_t BluetoothHCITransportCommandID;
typedef uint32_t BluetoothHCIRequestID;
		

// Version Information

typedef struct	BluetoothHCIVersionInfo		BluetoothHCIVersionInfo;
struct	BluetoothHCIVersionInfo
{
	// Local & Remote information
	
	BluetoothManufacturerName	manufacturerName;
	BluetoothLMPVersion			lmpVersion;
	BluetoothLMPSubversion		lmpSubVersion;
	
	// Local information only
	
	uint8_t						hciVersion;
	uint16_t					hciRevision;
};

// HCI buffer sizes.

typedef struct	BluetoothHCIBufferSize		BluetoothHCIBufferSize;
struct	BluetoothHCIBufferSize
{
	uint16_t	ACLDataPacketLength;
	uint8_t		SCODataPacketLength;
	uint16_t	totalNumACLDataPackets;
	uint16_t	totalNumSCODataPackets;
};

typedef struct	BluetoothHCILEBufferSize	BluetoothHCILEBufferSize;
struct	BluetoothHCILEBufferSize
{
	uint16_t	ACLDataPacketLength;
	uint8_t		totalNumACLDataPackets;
};

// Timeouts
typedef uint16_t	BluetoothHCIConnectionAcceptTimeout;
typedef uint16_t	BluetoothHCIPageTimeout;
enum BluetoothHCITimeoutValues
{
	kDefaultPageTimeout			= 0x2710,
};

#define		BluetoothGetSlotsFromSeconds( inSeconds )		( (inSeconds/.000625 ) )
#define		BluetoothGetSecondsFromSlots( inSlots )			( (inSlots*.000625 ) )


// Link Keys
typedef uint16_t	BluetoothHCINumLinkKeysDeleted;
typedef uint8_t	BluetoothHCINumLinkKeysToWrite;
typedef uint8_t	BluetoothHCIDeleteStoredLinkKeyFlag;
enum BluetoothHCIDeleteStoredLinkKeyFlags
{
	kDeleteKeyForSpecifiedDeviceOnly			= 0x00,
	kDeleteAllStoredLinkKeys					= 0x01,
};

typedef uint8_t	BluetoothHCIReadStoredLinkKeysFlag;
enum BluetoothHCIReadStoredLinkKeysFlags
{
	kReturnLinkKeyForSpecifiedDeviceOnly		= 0x00,
	kReadAllStoredLinkKeys						= 0x01,
};

typedef struct	BluetoothHCIStoredLinkKeysInfo	BluetoothHCIStoredLinkKeysInfo;
struct BluetoothHCIStoredLinkKeysInfo
{
	uint16_t	numLinkKeysRead;
	uint16_t	maxNumLinkKeysAllowedInDevice;
};


// Page Scan

typedef uint8_t	BluetoothHCIPageScanMode;
enum BluetoothHCIPageScanModes
{
	kMandatoryPageScanMode		= 0x00,
	kOptionalPageScanMode1		= 0x01,
	kOptionalPageScanMode2		= 0x02,
	kOptionalPageScanMode3		= 0x03,
};

typedef uint8_t	BluetoothHCIPageScanPeriodMode;
enum BluetoothHCIPageScanPeriodModes
{
	kP0Mode						= 0x00,
	kP1Mode						= 0x01,
	kP2Mode						= 0x02,
};

typedef uint8_t	BluetoothHCIPageScanEnableState;
enum BluetoothHCIPageScanEnableStates
{
	kNoScansEnabled							= 0x00,
	kInquiryScanEnabledPageScanDisabled		= 0x01,
	kInquiryScanDisabledPageScanEnabled		= 0x02,
	kInquiryScanEnabledPageScanEnabled		= 0x03,
};

typedef struct	BluetoothHCIScanActivity	BluetoothHCIScanActivity;
struct BluetoothHCIScanActivity
{
	uint16_t 	scanInterval;
	uint16_t	scanWindow;
};

typedef struct	BluetoothHCIInquiryAccessCode	BluetoothHCIInquiryAccessCode;
struct BluetoothHCIInquiryAccessCode
{
	uint8_t 	data[3];
};

typedef uint8_t BluetoothHCIInquiryAccessCodeCount;
typedef struct	BluetoothHCICurrentInquiryAccessCodes	BluetoothHCICurrentInquiryAccessCodes;
struct BluetoothHCICurrentInquiryAccessCodes
{
	BluetoothHCIInquiryAccessCodeCount	count;	// Number of codes in array.
	BluetoothHCIInquiryAccessCode *		codes;	// Ptr to array of codes.
};

enum
{
	kMaximumNumberOfInquiryAccessCodes	= 0x40
};
		
typedef struct	BluetoothHCICurrentInquiryAccessCodesForWrite	BluetoothHCICurrentInquiryAccessCodesForWrite;
struct BluetoothHCICurrentInquiryAccessCodesForWrite
{
	BluetoothHCIInquiryAccessCodeCount	count;			// Number of codes in array (Range 0x01 to 0x40)
	uint8_t 							codes [kMaximumNumberOfInquiryAccessCodes * sizeof (BluetoothHCIInquiryAccessCode)];	// Array of bytes (maximum 192 bytes -- 64 * 3).
};
		
typedef	struct BluetoothHCILinkSupervisionTimeout	BluetoothHCILinkSupervisionTimeout;
struct BluetoothHCILinkSupervisionTimeout
{
	BluetoothConnectionHandle 	handle;
	uint16_t					timeout;
};

typedef uint8_t BluetoothHCIFlowControlState;
enum BluetoothHCISCOFlowControlStates
{
	kSCOFlowControlDisabled		= 0x00,
	kSCOFlowControlEnabled		= 0x01
};

enum BluetoothHCIGeneralFlowControlStates
{
	kHostControllerToHostFlowControlOff			= 0x00,
	kHCIACLDataPacketsOnHCISCODataPacketsOff	= 0x01,
	kHCIACLDataPacketsOffHCISCODataPacketsOn	= 0x02,
	kHCIACLDataPacketsOnHCISCODataPacketsOn		= 0x03,
};		
		
typedef SInt8 BluetoothHCITransmitPowerLevel;
typedef uint8_t BluetoothHCITransmitPowerLevelType;
enum BluetoothHCITransmitReadPowerLevelTypes
{
	kReadCurrentTransmitPowerLevel	= 0x00,
	kReadMaximumTransmitPowerLevel	= 0x01,
};

typedef uint8_t	BluetoothHCIAFHChannelAssessmentMode;	
enum BluetoothHCIAFHChannelAssessmentModes
{
	kAFHChannelAssessmentModeDisabled		= 0x00,
	kAFHChannelAssessmentModeEnabled		= 0x01
};


typedef struct BluetoothHCITransmitPowerLevelInfo	BluetoothHCITransmitPowerLevelInfo;
struct BluetoothHCITransmitPowerLevelInfo
{
	BluetoothConnectionHandle		handle;
	BluetoothHCITransmitPowerLevel	level; // Range: -70 <= N <= 20 (units are dBm)
};

typedef uint8_t	BluetoothHCINumBroadcastRetransmissions;
typedef uint8_t	BluetoothHCIHoldModeActivity;
enum BluetoothHCIHoldModeActivityStates
{
	kMaintainCurrentPowerState		= 0x00,
	kSuspendPageScan				= 0x01,
	kSuspendInquiryScan				= 0x02,
	kSuspendPeriodicInquiries		= 0x03,
};

typedef uint8_t BluetoothHCIAuthenticationEnable;
enum BluetoothHCIAuthentionEnableModes
{
	kAuthenticationDisabled			= 0x00,
	kAuthenticationEnabled			= 0x01,
};

typedef uint8_t	BluetoothHCIEncryptionMode;
enum BluetoothHCIEncryptionModes
{
	kEncryptionDisabled									= 0x00,		// Default.
	kEncryptionOnlyForPointToPointPackets				= 0x01,
	kEncryptionForBothPointToPointAndBroadcastPackets	= 0x02,
};

typedef uint16_t	BluetoothHCIAutomaticFlushTimeout;
typedef struct	BluetoothHCIAutomaticFlushTimeoutInfo	BluetoothHCIAutomaticFlushTimeoutInfo;
struct BluetoothHCIAutomaticFlushTimeoutInfo
{
	BluetoothConnectionHandle			handle;
	BluetoothHCIAutomaticFlushTimeout	timeout;
};

#define	kInfoStringMaxLength		35
typedef struct	BluetoothTransportInfo 		BluetoothTransportInfo;
typedef 		BluetoothTransportInfo*		BluetoothTransportInfoPtr;
struct			BluetoothTransportInfo
{
	uint32_t	productID;
	uint32_t	vendorID;
	uint32_t	type;
	char		productName[kInfoStringMaxLength];
	char		vendorName[kInfoStringMaxLength];
	
	uint64_t	totalDataBytesSent;
	uint64_t	totalSCOBytesSent;
	uint64_t	totalDataBytesReceived;
	uint64_t	totalSCOBytesReceived;
};

enum BluetoothTransportTypes
{
	kBluetoothTransportTypeUSB		= 0x01,
	kBluetoothTransportTypePCCard	= 0x02,
	kBluetoothTransportTypePCICard	= 0x03,
	kBluetoothTransportTypeUART		= 0x04
};

// Inquiries

typedef struct	BluetoothHCIInquiryResult	BluetoothHCIInquiryResult;
struct	BluetoothHCIInquiryResult
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
	BluetoothHCIPageScanPeriodMode		pageScanPeriodMode;
	BluetoothHCIPageScanMode			pageScanMode;
	BluetoothClassOfDevice				classOfDevice;
	BluetoothClockOffset				clockOffset;
};

#define kBluetoothHCIInquiryResultsMaxResults 50
typedef struct	BluetoothHCIInquiryResults	BluetoothHCIInquiryResults;
struct	BluetoothHCIInquiryResults
{
	BluetoothHCIInquiryResult		results[kBluetoothHCIInquiryResultsMaxResults];
	IOItemCount						count;
};


//Inquiries with RSSI (v1.2 specification)

typedef struct	BluetoothHCIInquiryWithRSSIResult	BluetoothHCIInquiryWithRSSIResult;
struct	BluetoothHCIInquiryWithRSSIResult
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
	uint8_t								reserved;
	BluetoothClassOfDevice				classOfDevice;
	BluetoothClockOffset				clockOffset;
	BluetoothHCIRSSIValue				RSSIValue;
};

typedef struct	BluetoothHCIInquiryWithRSSIResults	BluetoothHCIInquiryWithRSSIResults;
struct	BluetoothHCIInquiryWithRSSIResults
{
	BluetoothHCIInquiryWithRSSIResult	results[50];
	IOItemCount							count;
};

//Inquiries with 'Extended Inquiry Response' (v2.1 specification)

typedef uint8_t	BluetoothHCIFECRequired;
enum BluetoothHCIFECRequiredValues
{
	kBluetoothHCIFECRequired		= 0x00,
	kBluetoothHCIFECNotRequired		= 0x01
};

typedef	uint8_t	BluetoothHCIInquiryMode;
enum BluetoothHCIInquiryModes
{
	kBluetoothHCIInquiryModeResultFormatStandard								=	0x00,
	kBluetoothHCIInquiryModeResultFormatWithRSSI								=	0x01,
	kBluetoothHCIInquiryModeResultFormatWithRSSIOrExtendedInquiryResultFormat	=	0x02
};

typedef uint8_t	BluetoothHCIInquiryScanType;
enum BluetoothHCIInquiryScanTypes
{
	kBluetoothHCIInquiryScanTypeStandard		= 0x00,
	kBluetoothHCIInquiryScanTypeInterlaced		= 0x01,
	
	kBluetoothHCIInquiryScanTypeReservedStart	= 0x02,
	kBluetoothHCIInquiryScanTypeReservedEnd		= 0xFF
};						

typedef	uint8_t	BluetoothHCIExtendedInquiryResponseDataType;

typedef struct	BluetoothHCIExtendedInquiryResponse		BluetoothHCIExtendedInquiryResponse;	/* Extended Inquiry Response [EIR] data, consisting of a sequence of data structures in this format: [length(1byte)][data type(1byte)][data(e.g. device name)] */
struct	BluetoothHCIExtendedInquiryResponse
{
	uint8_t		data[ 240 ];
};

typedef struct	BluetoothHCIReadExtendedInquiryResponseResults	BluetoothHCIReadExtendedInquiryResponseResults;
struct	BluetoothHCIReadExtendedInquiryResponseResults
{
	BluetoothHCIFECRequired					outFECRequired;
	BluetoothHCIExtendedInquiryResponse		extendedInquiryResponse;
};

typedef struct	BluetoothHCIExtendedInquiryResult	BluetoothHCIExtendedInquiryResult;
struct	BluetoothHCIExtendedInquiryResult
{
	uint8_t								numberOfReponses;			/* always a value of 1 */
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
	uint8_t								reserved;
	BluetoothClassOfDevice				classOfDevice;
	BluetoothClockOffset				clockOffset;
	BluetoothHCIRSSIValue				RSSIValue;
	BluetoothHCIExtendedInquiryResponse	extendedInquiryResponse;
};

typedef struct BluetoothHCIReadLMPHandleResults	BluetoothHCIReadLMPHandleResults;
struct BluetoothHCIReadLMPHandleResults
{
	BluetoothConnectionHandle		handle;
	BluetoothLMPHandle				lmp_handle;
	uint32_t						reserved;
};		
						
// 'Simple Pairing' (v2.1 specification)

typedef	uint8_t	BluetoothHCISimplePairingMode;
enum BluetoothHCISimplePairingModes
{
	kBluetoothHCISimplePairingModeNotSet									=	0x00,
	kBluetoothHCISimplePairingModeEnabled									=	0x01
};

typedef	uint8_t	BluetoothSimplePairingDebugMode;
enum BluetoothSimplePairingDebugModes
{
	kBluetoothHCISimplePairingDebugModeDisabled								=	0x00,
	kBluetoothHCISimplePairingDebugModeEnabled								=	0x01
};

typedef struct	BluetoothHCISimplePairingOOBData		BluetoothHCISimplePairingOOBData;
struct BluetoothHCISimplePairingOOBData
{
	uint8_t		data[ 16 ];
};

typedef struct BluetoothHCIReadLocalOOBDataResults BluetoothHCIReadLocalOOBDataResults;
struct	BluetoothHCIReadLocalOOBDataResults
{
	BluetoothHCISimplePairingOOBData		hash;
	BluetoothHCISimplePairingOOBData		randomizer;
};

typedef uint8_t	BluetoothIOCapability;
enum BluetoothIOCapabilities
{
	kBluetoothCapabilityTypeDisplayOnly			= 0x00,
	kBluetoothCapabilityTypeDisplayYesNo		= 0x01,
	kBluetoothCapabilityTypeKeyboardOnly		= 0x02,
	kBluetoothCapabilityTypeNoInputNoOutput		= 0x03
};

typedef uint8_t	BluetoothOOBDataPresence;
enum BluetoothOOBDataPresenceValues
{
	kBluetoothOOBAuthenticationDataNotPresent				= 0x00,
	kBluetoothOOBAuthenticationDataFromRemoteDevicePresent	= 0x01
};

typedef uint8_t	BluetoothAuthenticationRequirements;
enum BluetoothAuthenticationRequirementsValues
{
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequired					= 0x00,		/* Numeric comparison with automatic accept allowed */
	kBluetoothAuthenticationRequirementsMITMProtectionRequired						= 0x01,		/* Refer to BluetoothIOCapabilities to determine authentication procedure */
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequiredNoBonding			= 0x00,
	kBluetoothAuthenticationRequirementsMITMProtectionRequiredNoBonding				= 0x01,
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequiredDedicatedBonding	= 0x02,
	kBluetoothAuthenticationRequirementsMITMProtectionRequiredDedicatedBonding		= 0x03,
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequiredGeneralBonding		= 0x04,
	kBluetoothAuthenticationRequirementsMITMProtectionRequiredGeneralBonding		= 0x05
};

typedef struct BluetoothIOCapabilityResponse	BluetoothIOCapabilityResponse;
struct BluetoothIOCapabilityResponse
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothIOCapability				ioCapability;				/* possible values from BluetoothIOCapabilities above */
	BluetoothOOBDataPresence			OOBDataPresence;				
	BluetoothAuthenticationRequirements	authenticationRequirements;
};

typedef uint32_t	BluetoothPasskey;

typedef struct BluetoothUserPasskeyNotification	BluetoothUserPasskeyNotification;
struct BluetoothUserPasskeyNotification
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPasskey					passkey;				/* passkey for display. valid values are 000000 - 999999 */
};

typedef uint8_t	BluetoothKeypressNotificationType;
enum BluetoothKeypressNotificationTypes
{
	kBluetoothKeypressNotificationTypePasskeyEntryStarted		= 0,
	kBluetoothKeypressNotificationTypePasskeyDigitEntered		= 1,
	kBluetoothKeypressNotificationTypePasskeyDigitErased		= 2,
	kBluetoothKeypressNotificationTypePasskeyCleared			= 3,
	kBluetoothKeypressNotificationTypePasskeyEntryCompleted		= 4
};
		
typedef struct BluetoothKeypressNotification	BluetoothKeypressNotification;
struct BluetoothKeypressNotification
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothKeypressNotificationType	notificationType;
};
		
typedef struct BluetoothRemoteHostSupportedFeaturesNotification	BluetoothRemoteHostSupportedFeaturesNotification;
struct BluetoothRemoteHostSupportedFeaturesNotification
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothHCISupportedFeatures		hostSupportedFeatures;
};		
		
typedef SInt8	TransmissionPower;

typedef struct BluetoothAFHHostChannelClassification	BluetoothAFHHostChannelClassification;
struct BluetoothAFHHostChannelClassification
{
	uint8_t		data[ 10 ];			/* 79 bits meaningful */
};

typedef uint8_t	BluetoothAFHMode;
typedef struct	BluetoothAFHResults					BluetoothAFHResults;
struct BluetoothAFHResults
{
	BluetoothConnectionHandle	handle;
	BluetoothAFHMode			mode;
	uint8_t						afhMap[10];
};

typedef uint32_t	BluetoothNumericValue;

typedef struct BluetoothUserConfirmationRequest	BluetoothUserConfirmationRequest;
struct BluetoothUserConfirmationRequest
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothNumericValue				numericValue;				/* numeric value for display. valid values are 000000 - 999999 */
};

typedef struct	BluetoothHCIEventSimplePairingCompleteResults 		BluetoothHCIEventSimplePairingCompleteResults;
struct			BluetoothHCIEventSimplePairingCompleteResults
{
	BluetoothDeviceAddress						deviceAddress;
};


// Packet Sizes

enum
{
	kBluetoothHCICommandPacketHeaderSize 	= 3, 
	kBluetoothHCICommandPacketMaxDataSize 	= 255, 
	kBluetoothHCIMaxCommandPacketSize		= kBluetoothHCICommandPacketHeaderSize + kBluetoothHCICommandPacketMaxDataSize, 
	
	kBluetoothHCIEventPacketHeaderSize	 	= 2, 
	kBluetoothHCIEventPacketMaxDataSize 	= 255, 
	kBluetoothHCIMaxEventPacketSize			= kBluetoothHCIEventPacketHeaderSize + kBluetoothHCIEventPacketMaxDataSize, 
	
	kBluetoothHCIDataPacketHeaderSize 		= 4, 
	kBluetoothHCIDataPacketMaxDataSize 		= 65535, 
	kBluetoothHCIMaxDataPacketSize			= kBluetoothHCIDataPacketHeaderSize + kBluetoothHCIDataPacketMaxDataSize
};

typedef uint8_t		BluetoothHCIEventCode;
typedef uint8_t		BluetoothLinkType;
enum BluetoothLinkTypes
{
	kBluetoothSCOConnection		= 0,
	kBluetoothACLConnection		= 1,
	kBluetoothESCOConnection	= 2,
    kBluetoothLinkTypeNone		= 0xff
};

typedef uint16_t		BluetoothHCIContentFormat; // 10 bits meaningful

typedef uint16_t		BluetoothHCIVoiceSetting; // 10 bits meaningful
enum
{
	// Input Coding
	kBluetoothVoiceSettingInputCodingMask					= 0x300,
	kBluetoothVoiceSettingInputCodingLinearInputCoding		= 0x000,
	kBluetoothVoiceSettingInputCodingULawInputCoding		= 0x100,
	kBluetoothVoiceSettingInputCodingALawInputCoding		= 0x200,
};

enum
{
	// Input Data Format
	kBluetoothVoiceSettingInputDataFormatMask				= 0x0C0,
	kBluetoothVoiceSettingInputDataFormat1sComplement		= 0x000,
	kBluetoothVoiceSettingInputDataFormat2sComplement		= 0x040,
	kBluetoothVoiceSettingInputDataFormatSignMagnitude		= 0x080,
	kBluetoothVoiceSettingInputDataFormatUnsigned			= 0x0C0,
};

enum
{
	// Input Sample Size
	kBluetoothVoiceSettingInputSampleSizeMask				= 0x020,
	kBluetoothVoiceSettingInputSampleSize8Bit				= 0x000,
	kBluetoothVoiceSettingInputSampleSize16Bit				= 0x020,
};

enum
{
	// Linear PCM Bit Position
	kBluetoothVoiceSettingPCMBitPositionMask				= 0x01C,
};

enum
{
	// Air Coding Format
	kBluetoothVoiceSettingAirCodingFormatMask				= 0x003,
	kBluetoothVoiceSettingAirCodingFormatCVSD				= 0x000,
	kBluetoothVoiceSettingAirCodingFormatULaw				= 0x001,
	kBluetoothVoiceSettingAirCodingFormatALaw				= 0x002,
	kBluetoothVoiceSettingAirCodingFormatTransparentData	= 0x003,
};

typedef uint8_t		BluetoothHCISupportedIAC;
typedef uint32_t	BluetoothHCITransmitBandwidth;
typedef uint32_t	BluetoothHCIReceiveBandwidth;
typedef uint16_t	BluetoothHCIMaxLatency;
typedef uint8_t		BluetoothHCIRetransmissionEffort;		
enum BluetoothHCIRetransmissionEffortTypes
{
	kHCIRetransmissionEffortTypeNone								= 0x00,
	kHCIRetransmissionEffortTypeAtLeastOneAndOptimizeForPower		= 0x01,
	kHCIRetransmissionEffortTypeAtLeastOneAndOptimizeLinkQuality	= 0x02,
	kHCIRetransmissionEffortTypeDontCare							= 0xFF,
};
		

// Setup Synchronous Packet types (Bluetooth 2.1 spec section 7.7.35  - Setup Synchronous Command Complete Event)

typedef uint8_t		BluetoothAirMode;
enum
{
	kBluetoothAirModeULawLog				= 0x00,
	kBluetoothAirModeALawLog				= 0x01,
	kBluetoothAirModeCVSD					= 0x02,
	kBluetoothAirModeTransparentData		= 0x03
};

typedef struct	BluetoothSynchronousConnectionInfo		BluetoothSynchronousConnectionInfo;
struct	BluetoothSynchronousConnectionInfo
{
	BluetoothHCITransmitBandwidth		transmitBandWidth;
	BluetoothHCIReceiveBandwidth		receiveBandWidth;
	BluetoothHCIMaxLatency				maxLatency;
	BluetoothHCIVoiceSetting			voiceSetting;
	BluetoothHCIRetransmissionEffort	retransmissionEffort;
	BluetoothPacketType					packetType;
};

typedef struct	BluetoothHCIEventSynchronousConnectionCompleteResults 	BluetoothHCIEventSynchronousConnectionCompleteResults;
struct			BluetoothHCIEventSynchronousConnectionCompleteResults
{
	BluetoothConnectionHandle			connectionHandle;
	BluetoothDeviceAddress				deviceAddress;
	BluetoothLinkType					linkType;
	uint8_t								transmissionInterval;
	uint8_t								retransmissionWindow;
	uint16_t							receivePacketLength;
	uint16_t							transmitPacketLength;
	BluetoothAirMode					airMode;
};

typedef struct	BluetoothHCIEventSynchronousConnectionChangedResults 	BluetoothHCIEventSynchronousConnectionChangedResults;
struct			BluetoothHCIEventSynchronousConnectionChangedResults
{
	BluetoothConnectionHandle			connectionHandle;
	uint8_t								transmissionInterval;
	uint8_t								retransmissionWindow;
	uint16_t							receivePacketLength;
	uint16_t							transmitPacketLength;
};

typedef uint8_t	BluetoothHCIStatus;
typedef uint8_t	BluetoothHCIEventStatus;

// Events.

enum
{
	kBluetoothHCIEventInquiryComplete									= 0x01,
	kBluetoothHCIEventInquiryResult										= 0x02,
	kBluetoothHCIEventConnectionComplete								= 0x03,
	kBluetoothHCIEventConnectionRequest									= 0x04,
	kBluetoothHCIEventDisconnectionComplete								= 0x05,
	kBluetoothHCIEventAuthenticationComplete							= 0x06,
	kBluetoothHCIEventRemoteNameRequestComplete							= 0x07,
	kBluetoothHCIEventEncryptionChange									= 0x08,
	kBluetoothHCIEventChangeConnectionLinkKeyComplete					= 0x09,
	kBluetoothHCIEventMasterLinkKeyComplete								= 0x0A,
	kBluetoothHCIEventReadRemoteSupportedFeaturesComplete				= 0x0B,
	kBluetoothHCIEventReadRemoteVersionInformationComplete				= 0x0C,
	kBluetoothHCIEventQoSSetupComplete									= 0x0D,
	kBluetoothHCIEventCommandComplete									= 0x0E,
	kBluetoothHCIEventCommandStatus										= 0x0F,
	kBluetoothHCIEventHardwareError										= 0x10,
	kBluetoothHCIEventFlushOccurred										= 0x11,
	kBluetoothHCIEventRoleChange										= 0x12,
	kBluetoothHCIEventNumberOfCompletedPackets							= 0x13,
	kBluetoothHCIEventModeChange										= 0x14,
	kBluetoothHCIEventReturnLinkKeys									= 0x15,
	kBluetoothHCIEventPINCodeRequest									= 0x16,
	kBluetoothHCIEventLinkKeyRequest									= 0x17,
	kBluetoothHCIEventLinkKeyNotification								= 0x18,
	kBluetoothHCIEventLoopbackCommand									= 0x19,
	kBluetoothHCIEventDataBufferOverflow								= 0x1A,
	kBluetoothHCIEventMaxSlotsChange									= 0x1B,
	kBluetoothHCIEventReadClockOffsetComplete							= 0x1C,
	kBluetoothHCIEventConnectionPacketType								= 0x1D,
	kBluetoothHCIEventQoSViolation										= 0x1E,
	kBluetoothHCIEventPageScanModeChange								= 0x1F,	// DEPRECATED
	kBluetoothHCIEventPageScanRepetitionModeChange						= 0x20,
	
	// [v1.2]

	kBluetoothHCIEventFlowSpecificationComplete							= 0x21,
	kBluetoothHCIEventInquiryResultWithRSSI								= 0x22,
	kBluetoothHCIEventReadRemoteExtendedFeaturesComplete				= 0x23,
	kBluetoothHCIEventSynchronousConnectionComplete						= 0x2C,
	kBluetoothHCIEventSynchronousConnectionChanged						= 0x2D,

	// [v2.1]

	kBluetoothHCIEventSniffSubrating									= 0x2E,
	kBluetoothHCIEventExtendedInquiryResult								= 0x2F,
	kBluetoothHCIEventEncryptionKeyRefreshComplete						= 0x30,
	kBluetoothHCIEventIOCapabilityRequest								= 0x31,
	kBluetoothHCIEventIOCapabilityResponse								= 0x32,
	kBluetoothHCIEventUserConfirmationRequest							= 0x33,
	kBluetoothHCIEventUserPasskeyRequest								= 0x34,
	kBluetoothHCIEventRemoteOOBDataRequest								= 0x35,
	kBluetoothHCIEventSimplePairingComplete								= 0x36,
	kBluetoothHCIEventLinkSupervisionTimeoutChanged						= 0x38,
	kBluetoothHCIEventEnhancedFlushComplete								= 0x39,
	kBluetoothHCIEventUserPasskeyNotification							= 0x3B,
	kBluetoothHCIEventKeypressNotification								= 0x3C,
	kBluetoothHCIEventRemoteHostSupportedFeaturesNotification			= 0x3D,
	
	// [v4.0] (All LE Events come through this event, and the first following byte is the subevent
	
	kBluetoothHCIEventLEMetaEvent										= 0x3E,
		kBluetoothHCISubEventLEConnectionComplete						= 0x01,
		kBluetoothHCISubEventLEAdvertisingReport						= 0x02,
		kBluetoothHCISubEventLEConnectionUpdateComplete					= 0x03,
		kBluetoothHCISubEventLEReadRemoteUsedFeaturesComplete			= 0x04,
		kBluetoothHCISubEventLELongTermKeyRequest						= 0x05,
	
	// [v3.0]
	
	kBluetoothHCIEventPhysicalLinkComplete								= 0x40,
	kBluetoothHCIEventChannelSelected									= 0x41,
	kBluetoothHCIEventDisconnectionPhysicalLinkComplete					= 0x42,
	kBluetoothHCIEventPhysicalLinkLossEarlyWarning						= 0x43,
	kBluetoothHCIEventPhysicalLinkRecovery								= 0x44,
	kBluetoothHCIEventLogicalLinkComplete								= 0x45,
	kBluetoothHCIEventDisconnectionLogicalLinkComplete					= 0x46,
	kBluetoothHCIEventFlowSpecModifyComplete							= 0x47,
	kBluetoothHCIEventNumberOfCompletedDataBlocks						= 0x48,
	kBluetoothHCIEventShortRangeModeChangeComplete						= 0x4C,
	kBluetoothHCIEventAMPStatusChange									= 0x4D,
	kBluetoothHCIEventAMPStartTest										= 0x49,
	kBluetoothHCIEventAMPTestEnd										= 0x4A,
	kBluetoothHCIEventAMPReceiverReport									= 0x4B,
	
	
	kBluetoothHCIEventLogoTesting										= 0xFE,
	kBluetoothHCIEventVendorSpecific									= 0xFF
};

// HCI Event Masks

// Event masks are 8 octets according to the spec. v2.1 introduces some event masks that
// actually exceed 32 bits so the 4 byte enum we had before Bluetooth 2.0 will still work for old
// the masks, but the new masks need to be defined as 64 bits.

typedef uint64_t	BluetoothHCIEventMask;

#define kBluetoothHCIEventMaskLEDefault64Bit									0x000000000000001FLL
#define	kBluetoothHCIEventMaskDefault64Bit										0x00001FFFFFFFFFFFLL
#define	kBluetoothHCIEventMaskAll64Bit											0xFFFFFFFFFFFFFFFFLL

	// [v1.2]

#define	kBluetoothHCIEventMaskFlowSpecificationCompleteEvent					0x0000000100000000LL
#define	kBluetoothHCIEventMaskInquiryResultWithRSSIEvent						0x0000000200000000LL
#define	kBluetoothHCIEventMaskReadRemoteExtendedFeaturesCompleteEvent			0x0000000400000000LL
#define	kBluetoothHCIEventMaskSynchronousConnectionCompleteEvent				0x0000080000000000LL
#define	kBluetoothHCIEventMaskSynchronousConnectionChangedEvent					0x0000100000000000LL

	// [v2.1]

#define	kBluetoothHCIEventMaskSniffSubratingEvent								0x0000200000000000LL
#define	kBluetoothHCIEventMaskExtendedInquiryResultEvent						0x0000400000000000LL
#define kBluetoothHCIEventMaskEncryptionChangeEvent								0x0000000000000080LL
#define kBluetoothHCIEventMaskEncryptionKeyRefreshCompleteEvent					0x0000800000000000LL
#define	kBluetoothHCIEventMaskLinkSupervisionTimeoutChangedEvent				0x0080000000000000LL
#define	kBluetoothHCIEventMaskEnhancedFlushCompleteEvent						0x0100000000000000LL
	
	// [v2.1 Secure Simple Pairing]

#define	kBluetoothHCIEventMaskIOCapabilityRequestEvent							0x0001000000000000LL
#define	kBluetoothHCIEventMaskIOCapabilityRequestReplyEvent						0x0002000000000000LL
#define	kBluetoothHCIEventMaskUserConfirmationRequestEvent						0x0004000000000000LL
#define	kBluetoothHCIEventMaskUserPasskeyRequestEvent							0x0008000000000000LL
#define	kBluetoothHCIEventMaskRemoteOOBDataRequestEvent							0x0010000000000000LL
#define	kBluetoothHCIEventMaskSimplePairingCompleteEvent						0x0020000000000000LL
#define kBluetoothHCIEvnetMaskLinkSupervisionTimeoutChangedEvent				0x0080000000000000LL
#define kBluetoothHCIEvnetMaskEnhancedFlushCompleteEvent						0x0100000000000000LL
#define	kBluetoothHCIEventMaskUserPasskeyNotificationEvent						0x0400000000000000LL
#define	kBluetoothHCIEventMaskKeypressNotificationEvent							0x0800000000000000LL
#define	kBluetoothHCIEventMaskRemoteHostSupportedFeaturesNotificationEvent		0x1000000000000000LL
#define	kBluetoothHCIEventMaskLEMetaEvent										0x2000000000000000LL
	
enum
{
	kBluetoothHCIEventMaskNone											= 0x00000000, 
	kBluetoothHCIEventMaskInquiryComplete								= 0x00000001, 
	kBluetoothHCIEventMaskInquiryResult									= 0x00000002, 
	kBluetoothHCIEventMaskConnectionComplete							= 0x00000004, 
	kBluetoothHCIEventMaskConnectionRequest								= 0x00000008, 
	kBluetoothHCIEventMaskDisconnectionComplete							= 0x00000010, 
	kBluetoothHCIEventMaskAuthenticationComplete						= 0x00000020, 
	kBluetoothHCIEventMaskRemoteNameRequestComplete						= 0x00000040, 
	kBluetoothHCIEventMaskEncryptionChange								= 0x00000080, 
	kBluetoothHCIEventMaskChangeConnectionLinkKeyComplete				= 0x00000100, 
	kBluetoothHCIEventMaskMasterLinkKeyComplete							= 0x00000200, 
	kBluetoothHCIEventMaskReadRemoteSupportedFeaturesComplete			= 0x00000400, 
	kBluetoothHCIEventMaskReadRemoteVersionInformationComplete			= 0x00000800, 
	kBluetoothHCIEventMaskQoSSetupComplete								= 0x00001000, 
	kBluetoothHCIEventMaskCommandComplete								= 0x00002000, 
	kBluetoothHCIEventMaskCommandStatus									= 0x00004000, 
	kBluetoothHCIEventMaskHardwareError									= 0x00008000, 
	kBluetoothHCIEventMaskFlushOccurred									= 0x00010000, 
	kBluetoothHCIEventMaskRoleChange									= 0x00020000, 
	
	kBluetoothHCIEventMaskNumberOfCompletedPackets						= 0x00040000, 
	kBluetoothHCIEventMaskModeChange									= 0x00080000, 
	kBluetoothHCIEventMaskReturnLinkKeys								= 0x00100000, 
	kBluetoothHCIEventMaskPINCodeRequest								= 0x00200000, 
	kBluetoothHCIEventMaskLinkKeyRequest								= 0x00400000, 
	kBluetoothHCIEventMaskLinkKeyNotification							= 0x00800000, 
	kBluetoothHCIEventMaskLoopbackCommand								= 0x01000000, 
	kBluetoothHCIEventMaskDataBufferOverflow							= 0x02000000, 
	kBluetoothHCIEventMaskMaxSlotsChange								= 0x04000000, 
	kBluetoothHCIEventMaskReadClockOffsetComplete						= 0x08000000, 
	kBluetoothHCIEventMaskConnectionPacketTypeChanged					= 0x10000000, 
	kBluetoothHCIEventMaskQoSViolation									= 0x20000000, 
	kBluetoothHCIEventMaskPageScanModeChange							= 0x40000000, 
	kBluetoothHCIEventMaskPageScanRepetitionModeChange					= 0x80000000, 
	
	kBluetoothHCIEventMaskAll											= 0xFFFFFFFF, 
	kBluetoothHCIEventMaskDefault										= kBluetoothHCIEventMaskAll		/* Use kBluetoothHCIEventMaskDefault64Bit above! */
};

// Event results structures.

typedef struct	BluetoothHCIEventConnectionCompleteResults		BluetoothHCIEventConnectionCompleteResults;
struct			BluetoothHCIEventConnectionCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothDeviceAddress						deviceAddress;
	BluetoothLinkType							linkType;
	BluetoothHCIEncryptionMode					encryptionMode;
};

typedef struct	BluetoothHCIEventLEConnectionCompleteResults		BluetoothHCIEventLEConnectionCompleteResults;
struct			BluetoothHCIEventLEConnectionCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	uint8_t										role;
	uint8_t										peerAddressType;
	BluetoothDeviceAddress						peerAddress;
	uint16_t									connInterval;
	uint16_t									connLatency;
	uint16_t									supervisionTimeout;
	uint8_t										masterClockAccuracy;
} __attribute__((packed));		
	
typedef struct	BluetoothHCIEventLEConnectionUpdateCompleteResults		BluetoothHCIEventLEConnectionUpdateCompleteResults;
struct			BluetoothHCIEventLEConnectionUpdateCompleteResults
{
    BluetoothConnectionHandle					connectionHandle;
    uint16_t									connInterval;
    uint16_t									connLatency;
    uint16_t									supervisionTimeout;
} __attribute__((packed));
        
typedef struct	BluetoothHCIEventDisconnectionCompleteResults		BluetoothHCIEventDisconnectionCompleteResults;
struct			BluetoothHCIEventDisconnectionCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothReasonCode							reason;
};

typedef struct	BluetoothHCIEventReadSupportedFeaturesResults 	BluetoothHCIEventReadSupportedFeaturesResults;
struct 			BluetoothHCIEventReadSupportedFeaturesResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCISupportedFeatures				supportedFeatures;
};

typedef struct	BluetoothHCIEventReadExtendedFeaturesResults 	BluetoothHCIEventReadExtendedFeaturesResults;
struct 			BluetoothHCIEventReadExtendedFeaturesResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIExtendedFeaturesInfo			supportedFeaturesInfo;
};
		
typedef struct	BluetoothHCIEventReadRemoteVersionInfoResults 	BluetoothHCIEventReadRemoteVersionInfoResults;
struct 			BluetoothHCIEventReadRemoteVersionInfoResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothLMPVersion							lmpVersion;
	BluetoothManufacturerName					manufacturerName;
	BluetoothLMPSubversion						lmpSubversion;
};

typedef struct	BluetoothHCIEventRemoteNameRequestResults 		BluetoothHCIEventRemoteNameRequestResults;
struct 			BluetoothHCIEventRemoteNameRequestResults
{
	BluetoothDeviceAddress						deviceAddress;
	BluetoothDeviceName							deviceName;
};

typedef struct	BluetoothHCIEventReadClockOffsetResults 		BluetoothHCIEventReadClockOffsetResults;
struct			BluetoothHCIEventReadClockOffsetResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothClockOffset						clockOffset;
};

typedef struct	BluetoothHCIEventConnectionRequestResults 		BluetoothHCIEventConnectionRequestResults;
struct			BluetoothHCIEventConnectionRequestResults
{
	BluetoothDeviceAddress						deviceAddress;
	BluetoothClassOfDevice						classOfDevice;
	BluetoothLinkType							linkType;
};

typedef struct	BluetoothHCIEventLinkKeyNotificationResults 		BluetoothHCIEventLinkKeyNotificationResults;
struct			BluetoothHCIEventLinkKeyNotificationResults
{
	BluetoothDeviceAddress						deviceAddress;
	BluetoothKey								linkKey;
	BluetoothKeyType							keyType;
};

typedef struct	BluetoothHCIEventMaxSlotsChangeResults 		BluetoothHCIEventMaxSlotsChangeResults;
struct			BluetoothHCIEventMaxSlotsChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothMaxSlots							maxSlots;
};

typedef struct	BluetoothHCIEventModeChangeResults 		BluetoothHCIEventModeChangeResults;
struct			BluetoothHCIEventModeChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIConnectionMode					mode;
	BluetoothHCIModeInterval					modeInterval;
};

typedef struct	BluetoothHCIEventReturnLinkKeysResults	BluetoothHCIEventReturnLinkKeysResults;
struct			BluetoothHCIEventReturnLinkKeysResults
{
	uint8_t										numLinkKeys;
	struct {
		BluetoothDeviceAddress					deviceAddress;
		BluetoothKey							linkKey;
	} linkKeys[1];
};

typedef struct	BluetoothHCIEventAuthenticationCompleteResults 		BluetoothHCIEventAuthenticationCompleteResults;
struct			BluetoothHCIEventAuthenticationCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventEncryptionChangeResults 		BluetoothHCIEventEncryptionChangeResults;
struct			BluetoothHCIEventEncryptionChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothEncryptionEnable					enable;
};

typedef struct	BluetoothHCIEventChangeConnectionLinkKeyCompleteResults 	BluetoothHCIEventChangeConnectionLinkKeyCompleteResults;
struct			BluetoothHCIEventChangeConnectionLinkKeyCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventMasterLinkKeyCompleteResults 	BluetoothHCIEventMasterLinkKeyCompleteResults;
struct			BluetoothHCIEventMasterLinkKeyCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothKeyFlag							keyFlag;
};

typedef struct	BluetoothHCIEventQoSSetupCompleteResults 	BluetoothHCIEventQoSSetupCompleteResults;
struct			BluetoothHCIEventQoSSetupCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIQualityOfServiceSetupParams		setupParams;
};

typedef struct	BluetoothHCIEventHardwareErrorResults 	BluetoothHCIEventHardwareErrorResults;
struct			BluetoothHCIEventHardwareErrorResults
{
	BluetoothHCIStatus							error;
};

typedef struct	BluetoothHCIEventFlushOccurredResults 	BluetoothHCIEventFlushOccurredResults;
struct			BluetoothHCIEventFlushOccurredResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventRoleChangeResults 	BluetoothHCIEventRoleChangeResults;
struct			BluetoothHCIEventRoleChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothDeviceAddress						deviceAddress;
	BluetoothRole								role;
};

typedef struct	BluetoothHCIEventDataBufferOverflowResults 	BluetoothHCIEventDataBufferOverflowResults;
struct			BluetoothHCIEventDataBufferOverflowResults
{
	BluetoothLinkType							linkType;
};

typedef struct	BluetoothHCIEventConnectionPacketTypeResults 	BluetoothHCIEventConnectionPacketTypeResults;
struct			BluetoothHCIEventConnectionPacketTypeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothPacketType							packetType;
};

typedef struct	BluetoothHCIEventReadRemoteSupportedFeaturesResults 	BluetoothHCIEventReadRemoteSupportedFeaturesResults;
struct			BluetoothHCIEventReadRemoteSupportedFeaturesResults
{
	BluetoothHCIStatus							error;
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCISupportedFeatures				lmpFeatures;
};

typedef struct	BluetoothHCIEventReadRemoteExtendedFeaturesResults 	BluetoothHCIEventReadRemoteExtendedFeaturesResults;
struct			BluetoothHCIEventReadRemoteExtendedFeaturesResults
{
	BluetoothHCIStatus							error;
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIPageNumber						page;
	BluetoothHCIPageNumber						maxPage;
	BluetoothHCISupportedFeatures				lmpFeatures;
};

typedef struct	BluetoothHCIEventQoSViolationResults 	BluetoothHCIEventQoSViolationResults;
struct			BluetoothHCIEventQoSViolationResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventPageScanModeChangeResults 	BluetoothHCIEventPageScanModeChangeResults;
struct			BluetoothHCIEventPageScanModeChangeResults
{
	BluetoothDeviceAddress			deviceAddress;
	BluetoothPageScanMode			pageScanMode;
};

typedef struct	BluetoothHCIEventPageScanRepetitionModeChangeResults 	BluetoothHCIEventPageScanRepetitionModeChangeResults;
struct			BluetoothHCIEventPageScanRepetitionModeChangeResults
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
};

typedef struct	BluetoothHCIEventVendorSpecificResults 	BluetoothHCIEventVendorSpecificResults;
struct			BluetoothHCIEventVendorSpecificResults
{
	uint8_t								length;
	uint8_t								data[255];
};

typedef struct	BluetoothHCIEventEncryptionKeyRefreshCompleteResults		BluetoothHCIEventEncryptionKeyRefreshCompleteResults;
struct			BluetoothHCIEventEncryptionKeyRefreshCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct BluetoothHCIEventSniffSubratingResults BluetoothHCIEventSniffSubratingResults;
struct BluetoothHCIEventSniffSubratingResults
{
	BluetoothConnectionHandle			connectionHandle;
	uint16_t							maxTransmitLatency;
	uint16_t							maxReceiveLatency;
	uint16_t							minRemoteTimeout;
	uint16_t							minLocalTimeout;			
};
	
// LE Meta Events	
typedef struct BluetoothHCIEventLEMetaResults BluetoothHCIEventLEMetaResults;
struct BluetoothHCIEventLEMetaResults
{
	uint8_t		length;
	uint8_t		data[255];
};
		
typedef struct BluetoothHCIEventLELongTermKeyRequestResults BluetoothHCIEventLELongTermKeyRequestResults;
struct BluetoothHCIEventLELongTermKeyRequestResults
{
	BluetoothConnectionHandle	connectionHandle;
	uint8_t						randomNumber[8];
	uint16_t					ediv;	
};
		
#define kNoNotifyProc	NULL
#define kNoUserRefCon	NULL

typedef struct BluetoothHCIRequestCallbackInfo BluetoothHCIRequestCallbackInfo;
struct BluetoothHCIRequestCallbackInfo
{
	mach_vm_address_t					userCallback;			// Proc to call when async handler is called.
	mach_vm_address_t					userRefCon;				// For user's info.
	mach_vm_address_t					internalRefCon;			// For our purposes.
	mach_vm_address_t 					asyncIDRefCon;			// For our aync calls.
	mach_vm_address_t					reserved;				// For the future. Currently Unused.
};

// Error codes

enum
{
	kBluetoothHCIErrorSuccess											= 0x00, 
	kBluetoothHCIErrorUnknownHCICommand									= 0x01, 
	kBluetoothHCIErrorNoConnection										= 0x02, 
	kBluetoothHCIErrorHardwareFailure									= 0x03, 
	kBluetoothHCIErrorPageTimeout										= 0x04, 
	kBluetoothHCIErrorAuthenticationFailure								= 0x05, 
	kBluetoothHCIErrorKeyMissing										= 0x06, 
	kBluetoothHCIErrorMemoryFull										= 0x07, 
	kBluetoothHCIErrorConnectionTimeout									= 0x08, 
	kBluetoothHCIErrorMaxNumberOfConnections							= 0x09, 
	kBluetoothHCIErrorMaxNumberOfSCOConnectionsToADevice				= 0x0A, 
	kBluetoothHCIErrorACLConnectionAlreadyExists						= 0x0B, 
	kBluetoothHCIErrorCommandDisallowed									= 0x0C, 
	kBluetoothHCIErrorHostRejectedLimitedResources						= 0x0D, 
	kBluetoothHCIErrorHostRejectedSecurityReasons						= 0x0E, 
	kBluetoothHCIErrorHostRejectedRemoteDeviceIsPersonal				= 0x0F, 
	kBluetoothHCIErrorHostTimeout										= 0x10, 
	kBluetoothHCIErrorUnsupportedFeatureOrParameterValue				= 0x11, 
	kBluetoothHCIErrorInvalidHCICommandParameters						= 0x12, 
	kBluetoothHCIErrorOtherEndTerminatedConnectionUserEnded				= 0x13, 
	kBluetoothHCIErrorOtherEndTerminatedConnectionLowResources			= 0x14, 
	kBluetoothHCIErrorOtherEndTerminatedConnectionAboutToPowerOff		= 0x15, 
	kBluetoothHCIErrorConnectionTerminatedByLocalHost					= 0x16, 
	kBluetoothHCIErrorRepeatedAttempts									= 0x17, 
	kBluetoothHCIErrorPairingNotAllowed									= 0x18, 
	kBluetoothHCIErrorUnknownLMPPDU										= 0x19, 
	kBluetoothHCIErrorUnsupportedRemoteFeature							= 0x1A, 
	kBluetoothHCIErrorSCOOffsetRejected									= 0x1B, 
	kBluetoothHCIErrorSCOIntervalRejected								= 0x1C, 
	kBluetoothHCIErrorSCOAirModeRejected								= 0x1D, 
	kBluetoothHCIErrorInvalidLMPParameters								= 0x1E, 
	kBluetoothHCIErrorUnspecifiedError									= 0x1F, 
	kBluetoothHCIErrorUnsupportedLMPParameterValue						= 0x20, 
	kBluetoothHCIErrorRoleChangeNotAllowed								= 0x21, 
	kBluetoothHCIErrorLMPResponseTimeout								= 0x22, 
	kBluetoothHCIErrorLMPErrorTransactionCollision						= 0x23, 
	kBluetoothHCIErrorLMPPDUNotAllowed									= 0x24, 
	kBluetoothHCIErrorEncryptionModeNotAcceptable						= 0x25, 	// Added Core Spec, v1.1
	kBluetoothHCIErrorUnitKeyUsed										= 0x26, 	// 1.1
	kBluetoothHCIErrorQoSNotSupported									= 0x27, 	// 1.1
	kBluetoothHCIErrorInstantPassed										= 0x28, 	// 1.1
	kBluetoothHCIErrorPairingWithUnitKeyNotSupported					= 0x29, 	// 1.1
	kBluetoothHCIErrorHostRejectedUnacceptableDeviceAddress				= 0x0F,		// 2.0+
	kBluetoothHCIErrorDifferentTransactionCollision						= 0x2A, 	// 1.2
	kBluetoothHCIErrorQoSUnacceptableParameter							= 0x2C, 	// 1.2
	kBluetoothHCIErrorQoSRejected										= 0x2D, 	// 1.2
	kBluetoothHCIErrorChannelClassificationNotSupported					= 0x2E, 	// 1.2
	kBluetoothHCIErrorInsufficientSecurity								= 0x2F, 	// 1.2
	kBluetoothHCIErrorParameterOutOfMandatoryRange						= 0x30,		// 1.2
	kBluetoothHCIErrorRoleSwitchPending									= 0x31,		// 1.2
	kBluetoothHCIErrorReservedSlotViolation								= 0x34,		// 1.2
	kBluetoothHCIErrorRoleSwitchFailed									= 0x35,		// 1.2
	kBluetoothHCIErrorExtendedInquiryResponseTooLarge					= 0x36, 	// 2.1
	kBluetoothHCIErrorSecureSimplePairingNotSupportedByHost				= 0x37, 	// 2.1
	kBluetoothHCIErrorHostBusyPairing                                   = 0x38,
	kBluetoothHCIErrorConnectionRejectedDueToNoSuitableChannelFound		= 0x39,
	kBluetoothHCIErrorControllerBusy                                    = 0x3A,
	kBluetoothHCIErrorUnacceptableConnectionInterval                    = 0x3B,
	kBluetoothHCIErrorDirectedAdvertisingTimeout                        = 0x3C,
	kBluetoothHCIErrorConnectionTerminatedDueToMICFailure				= 0x3D,
	kBluetoothHCIErrorConnectionFailedToBeEstablished                   = 0x3E,
	kBluetoothHCIErrorMACConnectionFailed                               = 0x3F,
	
	kBluetoothHCIErrorMax												= 0x3F
};

#if 0
#pragma mark === HCI Power Mode ===
#endif

//===========================================================================================================================
//	HCI Power Mode 
//===========================================================================================================================

typedef enum
{
	kBluetoothHCIPowerStateON				= 0x01,
	kBluetoothHCIPowerStateOFF				= 0x00,
	kBluetoothHCIPowerStateUnintialized		= 0xFF,	
} BluetoothHCIPowerState;

enum
{
	kBluetoothHCIErrorPowerIsOFF			= (kBluetoothHCIErrorMax + 1)
};

#if 0
#pragma mark === HCI USB Transport ===
#endif

//===========================================================================================================================
//	HCI USB Transport
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		BluetoothHCIUSBDeviceMatchingConstants
	@abstract	Bluetooth USB device matching constants
	@constant	kBluetoothHCITransportUSBClassCode			Wireless Controller
	@constant	kBluetoothHCITransportUSBSubClassCode		RF Controller
	@constant	kBluetoothHCITransportUSBProtocolCode		Bluetooth Programming
*/

enum
{
	kBluetoothHCITransportUSBClassCode		= 0xE0,
	kBluetoothHCITransportUSBSubClassCode	= 0x01,
	kBluetoothHCITransportUSBProtocolCode	= 0x01
};

#if 0
#pragma mark === TCI - L2CAP ===
#endif

//===========================================================================================================================
//	TCI - L2CAP
//===========================================================================================================================

enum
{
	kBluetoothL2CAPTCIEventIDReserved							= 0x00,
	kBluetoothL2CAPTCIEventIDL2CA_ConnectInd					= 0x01,
	kBluetoothL2CAPTCIEventIDL2CA_ConfigInd						= 0x02,
	kBluetoothL2CAPTCIEventIDL2CA_DisconnectInd					= 0x03,
	kBluetoothL2CAPTCIEventIDL2CA_QoSViolationInd				= 0x04,
	kBluetoothL2CAPTCIEventIDL2CA_TimeOutInd					= 0x05
};

enum
{
	kBluetoothL2CAPTCICommandReserved							= 0x0000,
	kBluetoothL2CAPTCICommandL2CA_ConnectReq					= 0x0001,
	kBluetoothL2CAPTCICommandL2CA_DisconnectReq					= 0x0002,
	kBluetoothL2CAPTCICommandL2CA_ConfigReq						= 0x0003,
	kBluetoothL2CAPTCICommandL2CA_DisableCLT					= 0x0004,
	kBluetoothL2CAPTCICommandL2CA_EnableCLT						= 0x0005,
	kBluetoothL2CAPTCICommandL2CA_GroupCreate					= 0x0006,
	kBluetoothL2CAPTCICommandL2CA_GroupClose					= 0x0007,
	kBluetoothL2CAPTCICommandL2CA_GroupAddMember				= 0x0008,
	kBluetoothL2CAPTCICommandL2CA_GroupRemoveMember				= 0x0009,
	kBluetoothL2CAPTCICommandL2CA_GroupMembership				= 0x000A,
	kBluetoothL2CAPTCICommandL2CA_WriteData						= 0x000B,
	kBluetoothL2CAPTCICommandL2CA_ReadData						= 0x000C,
	kBluetoothL2CAPTCICommandL2CA_Ping							= 0x000D,
	kBluetoothL2CAPTCICommandL2CA_GetInfo						= 0x000E,
	kBluetoothL2CAPTCICommandL2CA_Reserved1						= 0x000F,
	kBluetoothL2CAPTCICommandL2CA_Reserved2						= 0x0010,
	kBluetoothL2CAPTCICommandL2CA_ConnectResp					= 0x0011,
	kBluetoothL2CAPTCICommandL2CA_DisconnectResp				= 0x0012,
	kBluetoothL2CAPTCICommandL2CA_ConfigResp					= 0x0013
};

#if 0
#pragma mark -
#pragma mark === RFCOMM ===
#endif

//===========================================================================================================================
//	RFCOMM
//===========================================================================================================================
#define kMaxChannelIDPerSide	31

typedef uint8_t	BluetoothRFCOMMChannelID;

#define	RFCOMM_CHANNEL_ID_IS_VALID( CHANNEL ) (( CHANNEL >= 1 ) && ( CHANNEL <= 30 ))

typedef uint16_t	BluetoothRFCOMMMTU;

typedef enum BluetoothRFCOMMParityType
{
    kBluetoothRFCOMMParityTypeNoParity = 0, 
    kBluetoothRFCOMMParityTypeOddParity, 
    kBluetoothRFCOMMParityTypeEvenParity, 
    kBluetoothRFCOMMParityTypeMaxParity
} BluetoothRFCOMMParityType;

typedef enum BluetoothRFCOMMLineStatus
{
    BluetoothRFCOMMLineStatusNoError = 0, 
    BluetoothRFCOMMLineStatusOverrunError, 
    BluetoothRFCOMMLineStatusParityError, 
    BluetoothRFCOMMLineStatusFramingError
} BluetoothRFCOMMLineStatus;

#if 0
#pragma mark -
#pragma mark === SDP ===
#endif

//===========================================================================================================================
//	SDP
//===========================================================================================================================

typedef uint8_t	BluetoothSDPPDUID;
enum {
    kBluetoothSDPPDUIDReserved							= 0,
    kBluetoothSDPPDUIDErrorResponse						= 1,
    kBluetoothSDPPDUIDServiceSearchRequest				= 2,
    kBluetoothSDPPDUIDServiceSearchResponse				= 3,
    kBluetoothSDPPDUIDServiceAttributeRequest			= 4,
    kBluetoothSDPPDUIDServiceAttributeResponse			= 5,
    kBluetoothSDPPDUIDServiceSearchAttributeRequest		= 6,
    kBluetoothSDPPDUIDServiceSearchAttributeResponse	= 7
};

#define IS_REQUEST_PDU( _pduID ) (	( _pduID == kBluetoothSDPPDUIDServiceSearchRequest ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceAttributeRequest ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceSearchAttributeRequest ) )
                                    
#define IS_RESPONSE_PDU( _pduID ) (	( _pduID == kBluetoothSDPPDUIDErrorResponse ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceSearchResponse ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceAttributeResponse ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceSearchAttributeResponse ) )

typedef uint16_t	BluetoothSDPErrorCode;
enum {
    kBluetoothSDPErrorCodeSuccess						= 0x0000,
    kBluetoothSDPErrorCodeReserved						= 0x0000,
    kBluetoothSDPErrorCodeInvalidSDPVersion				= 0x0001,
    kBluetoothSDPErrorCodeInvalidServiceRecordHandle	= 0x0002,
    kBluetoothSDPErrorCodeInvalidRequestSyntax			= 0x0003,
    kBluetoothSDPErrorCodeInvalidPDUSize				= 0x0004,
    kBluetoothSDPErrorCodeInvalidContinuationState		= 0x0005,
    kBluetoothSDPErrorCodeInsufficientResources			= 0x0006,
    
    kBluetoothSDPErrorCodeReservedStart					= 0x0007,
    kBluetoothSDPErrorCodeReservedEnd					= 0xFFFF
};

typedef uint16_t	BluetoothSDPTransactionID;

typedef uint32_t	BluetoothSDPServiceRecordHandle;

enum {
    kBluetoothSDPDataElementTypeNil						= 0,
    kBluetoothSDPDataElementTypeUnsignedInt				= 1,
    kBluetoothSDPDataElementTypeSignedInt				= 2,
    kBluetoothSDPDataElementTypeUUID					= 3,
    kBluetoothSDPDataElementTypeString					= 4,
    kBluetoothSDPDataElementTypeBoolean					= 5,
    kBluetoothSDPDataElementTypeDataElementSequence		= 6,
    kBluetoothSDPDataElementTypeDataElementAlternative	= 7,
    kBluetoothSDPDataElementTypeURL						= 8,
    kBluetoothSDPDataElementTypeReservedStart			= 9,
    kBluetoothSDPDataElementTypeReservedEnd				= 31
};

typedef uint16_t	BluetoothSDPUUID16;
typedef uint32_t	BluetoothSDPUUID32;

typedef uint8_t		BluetoothSDPDataElementTypeDescriptor;
typedef uint8_t		BluetoothSDPDataElementSizeDescriptor;

typedef uint16_t	BluetoothSDPServiceAttributeID;

#if 0
#pragma mark -
#pragma mark === LE ===
#endif
        
typedef enum {
    BluetoothLEScanTypePassive	= 0x00,
    BluetoothLEScanTypeActive	= 0x01
} BluetoothLEScanType;

typedef enum {
    BluetoothLEAddressTypePublic	= 0x00,
    BluetoothLEAddressTypeRandom	= 0x01
} BluetoothLEAddressType;
        
typedef enum {
    BluetoothLEScanFilterNone		= 0x00,
    BluetoothLEScanFilterWhitelist	= 0x01
} BluetoothLEScanFilter;
        
typedef enum {
    BluetoothLEScanDisable	= 0x00,
    BluetoothLEScanEnable	= 0x01
} BluetoothLEScan;
		
typedef enum {
	BluetoothLEConnectionIntervalMin	= 0x06,
	BluetoothLEConnectionIntervalMax	= 0x0C80
} BluetoothLEConnectionInterval;
		
typedef enum {
    BluetoothLEScanDuplicateFilterDisable	= 0x00,
    BluetoothLEScanDuplicateFilterEnable	= 0x01,
} BluetoothLEScanDuplicateFilter;
        
typedef enum {
    BluetoothLEAdvertisingTypeConnectableUndirected		= 0x00,
    BluetoothLEAdvertisingTypeConnectableDirected		= 0x01,
    BluetoothLEAdvertisingTypeDiscoverableUndirected	= 0x02,
    BluetoothLEAdvertisingTypeNonConnectableUndirected	= 0x03,
    BluetoothLEAdvertisingTypeScanResponse				= 0x04
} BluetoothLEAdvertisingType;

#ifdef	__cplusplus
	}
#endif
                                                                                                                                                           BluetoothAssignedNumbers.h                                                                          0100644 0001750 0001750 00000107227 12567444611 037164  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 /*
	File:		BluetoothAssignedNumbers.h
	Copyright:	(c) 2001-2012 by Apple, Inc. All rights reserved.
*/

#pragma once

#ifdef	__cplusplus
	extern "C" {
#endif

#pragma mark -
#pragma mark === General ===

enum BluetoothCompanyIdentifers
{
	kBluetoothCompanyIdentiferEricssonTechnologyLicensing						=	0,
	kBluetoothCompanyIdentiferNokiaMobilePhones									=	1,
	kBluetoothCompanyIdentiferIntel												=	2,
	kBluetoothCompanyIdentiferIBM												=	3,
	kBluetoothCompanyIdentiferToshiba											=	4,
	kBluetoothCompanyIdentifer3Com												=	5,
	kBluetoothCompanyIdentiferMicrosoft											=	6,
	kBluetoothCompanyIdentiferLucent											=	7,
	kBluetoothCompanyIdentiferMotorola											=	8,
	kBluetoothCompanyIdentiferInfineonTechnologiesAG							=	9,
	kBluetoothCompanyIdentiferCambridgeSiliconRadio								=	10,
	kBluetoothCompanyIdentiferSiliconWave										=	11,
	kBluetoothCompanyIdentiferDigianswerAS										=	12,
	kBluetoothCompanyIdentiferTexasInstruments									=	13,
	kBluetoothCompanyIdentiferParthusTechnologies								=	14,
	kBluetoothCompanyIdentiferBroadcom											=	15,
	kBluetoothCompanyIdentiferMitelSemiconductor								=	16,
	kBluetoothCompanyIdentiferWidcomm											=	17,
	kBluetoothCompanyIdentiferZeevo												=	18,
	kBluetoothCompanyIdentiferAtmel												=	19,
	kBluetoothCompanyIdentiferMistubishiElectric								=	20,
	kBluetoothCompanyIdentiferRTXTelecom										=	21,
	kBluetoothCompanyIdentiferKCTechnology										=	22,
	kBluetoothCompanyIdentiferNewlogic											=	23,
	kBluetoothCompanyIdentiferTransilica										=	24,
	kBluetoothCompanyIdentiferRohdeandSchwarz									=	25,
	kBluetoothCompanyIdentiferTTPCom											=	26,
	kBluetoothCompanyIdentiferSigniaTechnologies								=	27,
	kBluetoothCompanyIdentiferConexantSystems									=	28,
	kBluetoothCompanyIdentiferQualcomm											=	29,
	kBluetoothCompanyIdentiferInventel											=	30,
	kBluetoothCompanyIdentiferAVMBerlin											=	31,
	kBluetoothCompanyIdentiferBandspeed											=	32,
	kBluetoothCompanyIdentiferMansella											=	33,
	kBluetoothCompanyIdentiferNEC												=	34,
	kBluetoothCompanyIdentiferWavePlusTechnology								=	35,
	kBluetoothCompanyIdentiferAlcatel											=	36,
	kBluetoothCompanyIdentiferPhilipsSemiconductor								=	37,
	kBluetoothCompanyIdentiferCTechnologies										=	38,
	kBluetoothCompanyIdentiferOpenInterface										=	39,
	kBluetoothCompanyIdentiferRFCMicroDevices									=	40,
	kBluetoothCompanyIdentiferHitachi											=	41,
	kBluetoothCompanyIdentiferSymbolTechnologies								=	42,
	kBluetoothCompanyIdentiferTenovis											=	43,
	kBluetoothCompanyIdentiferMacronixInternational								=	44,
	kBluetoothCompanyIdentiferGCTSemiconductor									=	45,
	kBluetoothCompanyIdentiferNorwoodSystems									=	46,
	kBluetoothCompanyIdentiferMewTelTechnology									=	47,
	kBluetoothCompanyIdentiferSTMicroelectronics								=	48,
	kBluetoothCompanyIdentiferSynopsys											=	49,
	kBluetoothCompanyIdentiferRedMCommunications								=	50,
	kBluetoothCompanyIdentiferCommil											=	51,
	kBluetoothCompanyIdentiferCATC												=	52,
	kBluetoothCompanyIdentiferEclipse											=	53,
	kBluetoothCompanyIdentiferRenesasTechnology									=	54,
	kBluetoothCompanyIdentiferMobilian											=	55,
	kBluetoothCompanyIdentiferTerax												=	56,
	kBluetoothCompanyIdentiferIntegratedSystemSolution							=	57,
	kBluetoothCompanyIdentiferMatsushitaElectricIndustrial						=	58,
	kBluetoothCompanyIdentiferGennum											=	59,
	kBluetoothCompanyIdentiferResearchInMotion									=	60,
	kBluetoothCompanyIdentiferIPextreme											=	61,
	kBluetoothCompanyIdentiferSystemsAndChips									=	62,
	kBluetoothCompanyIdentiferBluetoothSIG										=	63,
	kBluetoothCompanyIdentiferSeikoEpson										=	64,
	kBluetoothCompanyIdentiferIntegratedSiliconSolution							=	65,
	kBluetoothCompanyIdentiferCONWISETechnology									=	66,
	kBluetoothCompanyIdentiferParrotSA											=	67,
	kBluetoothCompanyIdentiferSocketCommunications								=	68,
	kBluetoothCompanyIdentiferAtherosCommunications								=	69,
	kBluetoothCompanyIdentiferMediaTek											=	70,
	kBluetoothCompanyIdentiferBluegiga											=	71,
	kBluetoothCompanyIdentiferMarvellTechnologyGroup							=	72,
	kBluetoothCompanyIdentifer3DSP												=	73,
	kBluetoothCompanyIdentiferAccelSemiconductor								=	74,
	kBluetoothCompanyIdentiferContinentialAutomotiveSystems						=	75,
	kBluetoothCompanyIdentiferApple												=	76,
	kBluetoothCompanyIdentiferStaccatoCommunications							=	77,
	kBluetoothCompanyIdentiferAvagoTechnologies									=	78,
	kBluetoothCompanyIdentiferAPT												=	79,
	kBluetoothCompanyIdentiferSiRFTechnology									=	80,
	kBluetoothCompanyIdentiferTZeroTechnologies									=	81,
	kBluetoothCompanyIdentiferJandM												=	82,
	kBluetoothCompanyIdentiferFree2Move											=	83,
	kBluetoothCompanyIdentifer3DiJoy											=	84,
	kBluetoothCompanyIdentiferPlantronics										=	85,
	kBluetoothCompanyIdentiferSonyEricssonMobileCommunications					=	86,
	kBluetoothCompanyIdentiferHarmonInternational								=	87,
	kBluetoothCompanyIdentiferVisio												=	88,
	kBluetoothCompanyIdentiferNordicSemiconductor								=	89,
	kBluetoothCompanyIdentiferEMMicroElectronicMarin							=	90,

	kBluetoothCompanyIdentiferInteropIdentifier									=	65535
};

#pragma mark -
#pragma mark === Baseband ===

//==================================================================================================================
//	Baseband
//==================================================================================================================

//
// Service Class Major
//

enum
{
	kBluetoothServiceClassMajorLimitedDiscoverableMode		= 0x001,	// Bit 13 - Limited Discoverable Mode
	kBluetoothServiceClassMajorReserved1					= 0x002, 	// Bit 14 - Reserved for future use.
	kBluetoothServiceClassMajorReserved2					= 0x004, 	// Bit 15 - Reserved for future use.
	kBluetoothServiceClassMajorPositioning					= 0x008, 	// Bit 16 - Positioning (Location ID)
	kBluetoothServiceClassMajorNetworking					= 0x010, 	// Bit 17 - LAN, Ad hoc, etc...
	kBluetoothServiceClassMajorRendering					= 0x020, 	// Bit 18 - Printing, Speaker, etc...
	kBluetoothServiceClassMajorCapturing					= 0x040,	// Bit 19 - Scanner, Microphone, etc...
	kBluetoothServiceClassMajorObjectTransfer				= 0x080,	// Bit 20 - v-Inbox, v-Folder, etc...
	kBluetoothServiceClassMajorAudio						= 0x100,	// Bit 21 - Speaker, Microphone, Headset, etc...
	kBluetoothServiceClassMajorTelephony					= 0x200,	// Bit 22 - Cordless telephony, Modem, Headset, etc...
	kBluetoothServiceClassMajorInformation					= 0x400,	// Bit 23 - Web server, WAP server, etc...
	
	kBluetoothServiceClassMajorAny							= '****',	// Pseudo-class - means anything acceptable.
	kBluetoothServiceClassMajorNone							= 'none',	// Pseudo-class - means no matching.
	
	kBluetoothServiceClassMajorEnd
};

//
// Device Class Major
//

enum
{
	kBluetoothDeviceClassMajorMiscellaneous					= 0x00, 	// [00000] Miscellaneous
	kBluetoothDeviceClassMajorComputer						= 0x01, 	// [00001] Desktop, Notebook, PDA, Organizers, etc...
	kBluetoothDeviceClassMajorPhone							= 0x02, 	// [00010] Cellular, Cordless, Payphone, Modem, etc...
	kBluetoothDeviceClassMajorLANAccessPoint				= 0x03, 	// [00011] LAN Access Point
    kBluetoothDeviceClassMajorAudio							= 0x04, 	// [00100] Headset, Speaker, Stereo, etc...
	kBluetoothDeviceClassMajorPeripheral					= 0x05, 	// [00101] Mouse, Joystick, Keyboards, etc...
    kBluetoothDeviceClassMajorImaging						= 0x06,		// [00110] Printing, scanner, camera, display, etc...
	kBluetoothDeviceClassMajorWearable						= 0x07,		// [00111] Wearable
	kBluetoothDeviceClassMajorToy							= 0x08,		// [01000] Toy
	kBluetoothDeviceClassMajorHealth						= 0x09,		// [01001] Health devices
	kBluetoothDeviceClassMajorUnclassified					= 0x1F, 	// [11111] Specific device code not assigned
	
	// Range 0x06 to 0x1E Reserved for future use.
	
	kBluetoothDeviceClassMajorAny							= '****',	// Pseudo-class - means anything acceptable.
	kBluetoothDeviceClassMajorNone							= 'none',	// Pseudo-class - means no matching.
	
	kBluetoothDeviceClassMajorEnd
};

//
// Device Class Minor
//

enum
{
	///
	/// Computer Minor Class
	///
	
	kBluetoothDeviceClassMinorComputerUnclassified			= 0x00, 	// [000000] Specific device code not assigned
	kBluetoothDeviceClassMinorComputerDesktopWorkstation	= 0x01, 	// [000001] Desktop workstation
	kBluetoothDeviceClassMinorComputerServer				= 0x02, 	// [000010] Server-class computer
	kBluetoothDeviceClassMinorComputerLaptop				= 0x03, 	// [000011] Laptop
	kBluetoothDeviceClassMinorComputerHandheld				= 0x04, 	// [000100] Handheld PC/PDA (clam shell)
	kBluetoothDeviceClassMinorComputerPalmSized				= 0x05, 	// [000101] Palm-sized PC/PDA
    kBluetoothDeviceClassMinorComputerWearable				= 0x06,		// [000110] Wearable computer (watch sized)
	
	// Range 0x06 to 0x7F Reserved for future use.
	
    
	///
	/// Phone Minor Class
	///
	
	kBluetoothDeviceClassMinorPhoneUnclassified				= 0x00, 	// [000000] Specific device code not assigned
	kBluetoothDeviceClassMinorPhoneCellular					= 0x01, 	// [000001] Cellular
	kBluetoothDeviceClassMinorPhoneCordless					= 0x02, 	// [000010] Cordless
	kBluetoothDeviceClassMinorPhoneSmartPhone				= 0x03, 	// [000011] Smart phone
	kBluetoothDeviceClassMinorPhoneWiredModemOrVoiceGateway	= 0x04, 	// [000100] Wired modem or voice gateway
    kBluetoothDeviceClassMinorPhoneCommonISDNAccess			= 0x05,		// [000101] Common ISDN Access
	
	// Range 0x05 to 0x7F Reserved for future use.
	
    
	///
	/// LAN Access Point Minor Class
	///
	
	// See the Bluetooth specification for LAN Access Point minor classes, which are broken into bits 5-7 for utilization and bits 2-4 for class.
	
    
	///
	/// Audio Minor Class
	///
	
	kBluetoothDeviceClassMinorAudioUnclassified					= 0x00, 	// [000000] Specific device code not assigned
	kBluetoothDeviceClassMinorAudioHeadset						= 0x01, 	// [000001] Device conforms to the Headset profile
    kBluetoothDeviceClassMinorAudioHandsFree					= 0x02,		// [000010] Hands-free
    kBluetoothDeviceClassMinorAudioReserved1					= 0x03,		// [000011] Reserved
    kBluetoothDeviceClassMinorAudioMicrophone					= 0x04,		// [000100] Microphone
    kBluetoothDeviceClassMinorAudioLoudspeaker					= 0x05,		// [000101] Loudspeaker
    kBluetoothDeviceClassMinorAudioHeadphones					= 0x06,		// [000110] Headphones
    kBluetoothDeviceClassMinorAudioPortable						= 0x07,		// [000111] Portable Audio
    kBluetoothDeviceClassMinorAudioCar							= 0x08,		// [001000] Car Audio
    kBluetoothDeviceClassMinorAudioSetTopBox					= 0x09,		// [001001] Set-top box
    kBluetoothDeviceClassMinorAudioHiFi							= 0x0a,		// [001010] HiFi Audio Device
    kBluetoothDeviceClassMinorAudioVCR							= 0x0b,		// [001011] VCR
    kBluetoothDeviceClassMinorAudioVideoCamera					= 0x0c,		// [001100] Video Camera
    kBluetoothDeviceClassMinorAudioCamcorder					= 0x0d,		// [001101] Camcorder
    kBluetoothDeviceClassMinorAudioVideoMonitor					= 0x0e,		// [001110] Video Monitor
    kBluetoothDeviceClassMinorAudioVideoDisplayAndLoudspeaker	= 0x0f,		// [001111] Video Display and Loudspeaker
    kBluetoothDeviceClassMinorAudioVideoConferencing			= 0x10,		// [010000] Video Conferencing
    kBluetoothDeviceClassMinorAudioReserved2					= 0x11,		// [010001] Reserved
    kBluetoothDeviceClassMinorAudioGamingToy					= 0x12,		// [010010] Gaming/Toy
    
	
	// Range 0x13 to 0x7F Reserved for future use.
	
    
	///
	/// Peripheral Minor Class
	///
    
    // Peripheral1 subclass is bits 7 & 6
    
    kBluetoothDeviceClassMinorPeripheral1Keyboard			= 0x10,		// [01XXXX] Keyboard
    kBluetoothDeviceClassMinorPeripheral1Pointing			= 0x20,		// [10XXXX] Pointing device
    kBluetoothDeviceClassMinorPeripheral1Combo				= 0x30,		// [11XXXX] Combo keyboard/pointing device
    
    // Peripheral2 subclass is bits 5-2
    
    kBluetoothDeviceClassMinorPeripheral2Unclassified		= 0x00,		// [XX0000] Uncategorized device
    kBluetoothDeviceClassMinorPeripheral2Joystick			= 0x01,		// [XX0001] Joystick
    kBluetoothDeviceClassMinorPeripheral2Gamepad			= 0x02,		// [XX0010] Gamepad
    kBluetoothDeviceClassMinorPeripheral2RemoteControl		= 0x03,		// [XX0011] Remote control
    kBluetoothDeviceClassMinorPeripheral2SensingDevice		= 0x04,		// [XX0100] Sensing device
    kBluetoothDeviceClassMinorPeripheral2DigitizerTablet	= 0x05,		// [XX0101] Digitizer Tablet	
    kBluetoothDeviceClassMinorPeripheral2CardReader			= 0x06,		// [XX0110] Card Reader
    kBluetoothDeviceClassMinorPeripheral2DigitalPen         = 0x07,     // [XX0111] Digital Pen
    kBluetoothDeviceClassMinorPeripheral2HandheldScanner    = 0x08,     // [XX1000] Handheld scanner for bar-codes, RFID, etc.
    kBluetoothDeviceClassMinorPeripheral2GesturalInputDevice = 0x09,    // [XX1001] Handheld gestural input device (e.g., "wand" form factor)
    
	kBluetoothDeviceClassMinorPeripheral2AnyPointing		= 'poin',	// Anything under MinorPeripheral1Pointing
	
    // Range 0x05 to 0x0f reserved for future use
	
    
	///
	/// Imaging Minor Class
	///
    
    // Imaging1 subclass is bits 7 - 4
    
    kBluetoothDeviceClassMinorImaging1Display				= 0x04,		// [XXX1XX] Display
    kBluetoothDeviceClassMinorImaging1Camera				= 0x08,		// [XX1XXX] Camera
    kBluetoothDeviceClassMinorImaging1Scanner				= 0x10,		// [X1XXXX] Scanner
    kBluetoothDeviceClassMinorImaging1Printer				= 0x20,		// [1XXXXX] Printer
    
    // Imaging2 subclass is bits 3 - 2
    
    kBluetoothDeviceClassMinorImaging2Unclassified			= 0x00,		// [XXXX00] Uncategorized, default
    
    // Range 0x01 - 0x03 reserved for future use
    
	///
	/// Wearable Minor Class
	///
        
    kBluetoothDeviceClassMinorWearableWristWatch			= 0x01,		// [000001] Watch
    kBluetoothDeviceClassMinorWearablePager					= 0x02,		// [000010] Pager
    kBluetoothDeviceClassMinorWearableJacket				= 0x03,		// [000011] Jacket
    kBluetoothDeviceClassMinorWearableHelmet				= 0x04,		// [000100] Helmet
    kBluetoothDeviceClassMinorWearableGlasses				= 0x05,		// [000101] Glasses
    
	///
	/// Toy Minor Class
	///
        
    kBluetoothDeviceClassMinorToyRobot						= 0x01,		// [000001] Robot
    kBluetoothDeviceClassMinorToyVehicle					= 0x02,		// [000010] Vehicle
    kBluetoothDeviceClassMinorToyDollActionFigure			= 0x03,		// [000011] Doll / Action Figure
    kBluetoothDeviceClassMinorToyController					= 0x04,		// [000100] Controller
    kBluetoothDeviceClassMinorToyGame						= 0x05,		// [000101] Game
    
	///
	/// Health Minor Class
	///
        
    kBluetoothDeviceClassMinorHealthUndefined				= 0x00,		// [000000] Undefined
    kBluetoothDeviceClassMinorHealthBloodPressureMonitor	= 0x01,		// [000001] Blood Pressure Monitor
    kBluetoothDeviceClassMinorHealthThermometer				= 0x02,		// [000010] Thermometer
    kBluetoothDeviceClassMinorHealthScale					= 0x03,		// [000011] Scale
    kBluetoothDeviceClassMinorHealthGlucoseMeter			= 0x04,		// [000100] Glucose Meter
    kBluetoothDeviceClassMinorHealthPulseOximeter			= 0x05,		// [000101] Pulse Oximeter
    kBluetoothDeviceClassMinorHealthHeartRateMonitor		= 0x06,		// [000111] Heart Rate Monitor
    kBluetoothDeviceClassMinorHealthDataDisplay				= 0x07,		// [001000] Display
    
	///
	///	Misc
	///
	
	kBluetoothDeviceClassMinorAny							= '****',	// Pseudo-class - means anything acceptable.
	kBluetoothDeviceClassMinorNone							= 'none',	// Pseudo-class - means no matching.
	
	kBluetoothDeviceClassMinorEnd
};
		
		
// Peripheral devices bits 7 & 6
#define BluetoothCoDMinorPeripheral1(minorClass) (minorClass & 0x30)
		
// Peripheral devices bits 5 - 2
#define BluetoothCoDMinorPeripheral2(minorClass) (minorClass & 0x0f)	
		
#pragma mark - LE Appearance
enum {
    kBluetoothGAPAppearanceUnknown                                  = 0,
    kBluetoothGAPAppearanceGenericPhone                             = 64,
    kBluetoothGAPAppearanceGenericComputer                          = 128,
    kBluetoothGAPAppearanceGenericWatch                             = 192,
    kBluetoothGAPAppearanceGenericClock                             = 256,
    kBluetoothGAPAppearanceGenericDisplay                           = 320,
    kBluetoothGAPAppearanceGenericRemoteControl                     = 384,
    kBluetoothGAPAppearanceGenericEyeGlasses                        = 448,
    kBluetoothGAPAppearanceGenericTag                               = 512,
    kBluetoothGAPAppearanceGenericKeyring                           = 576,
    kBluetoothGAPAppearanceGenericMediaPlayer                       = 640,
    kBluetoothGAPAppearanceGenericBarcodeScanner                    = 704,
    kBluetoothGAPAppearanceGenericThermometer                       = 768,
    kBluetoothGAPAppearanceGenericHeartrateSensor                   = 832,
    kBluetoothGAPAppearanceGenericBloodPressure                     = 896,
    kBluetoothGAPAppearanceGenericHumanInterfaceDevice              = 960,
    kBluetoothGAPAppearanceHumanInterfaceDeviceKeyboard             = 961,
    kBluetoothGAPAppearanceHumanInterfaceDeviceMouse                = 962,
    kBluetoothGAPAppearanceHumanInterfaceDeviceJoystick             = 963,
    kBluetoothGAPAppearanceHumanInterfaceDeviceGamepad              = 964,
    kBluetoothGAPAppearanceHumanInterfaceDeviceDigitizerTablet      = 965,
    kBluetoothGAPAppearanceHumanInterfaceDeviceCardReader           = 966,
    kBluetoothGAPAppearanceHumanInterfaceDeviceDigitalPen           = 967,
    kBluetoothGAPAppearanceHumanInterfaceDeviceBarcodeScanner       = 968,
    kBluetoothGAPAppearanceGenericGlucoseMeter                      = 1024,
    kBluetoothGAPAppearanceGenericRunningWalkingSensor              = 1088,
    kBluetoothGAPAppearanceGenericCycling                           = 1152,
};
        
#pragma mark -
#pragma mark === L2CAP ===

//===========================================================================================================================
//	L2CAP
//===========================================================================================================================

enum
{
    kBluetoothL2CAPPSMSDP						= 0x0001, 
    kBluetoothL2CAPPSMRFCOMM					= 0x0003, 
    kBluetoothL2CAPPSMTCS_BIN					= 0x0005,	// Telephony Control Specifictation / TCS Binary
    kBluetoothL2CAPPSMTCS_BIN_Cordless			= 0x0007,	// Telephony Control Specifictation / TCS Binary
    kBluetoothL2CAPPSMBNEP						= 0x000F,	// Bluetooth Network Encapsulation Protocol
    kBluetoothL2CAPPSMHIDControl				= 0x0011,	// HID profile - control interface
    kBluetoothL2CAPPSMHIDInterrupt				= 0x0013,	// HID profile - interrupt interface
    kBluetoothL2CAPPSMAVCTP						= 0x0017,	// Audio/Video Control Transport Protocol
    kBluetoothL2CAPPSMAVDTP						= 0x0019,	// Audio/Video Distribution Transport Protocol
    kBluetoothL2CAPPSMAVCTP_Browsing			= 0x001B,	// AVTCP (AVRCP) Browsing
    kBluetoothL2CAPPSMUID_C_Plane				= 0x001D,	// Unrestricted Digital Information Profile (UDI)
    kBluetoothL2CAPPSMATT						= 0x001F,	// Attribute Protocol
	
	// Range < 0x1000 reserved.
    kBluetoothL2CAPPSMReservedStart				= 0x0001,
    kBluetoothL2CAPPSMReservedEnd				= 0x1000,
    
	// Range 0x1001-0xFFFF dynamically assigned.
    kBluetoothL2CAPPSMDynamicStart				= 0x1001,
	kBluetoothL2CAPPSMD2D						= 0x100F,
    kBluetoothL2CAPPSMDynamicEnd				= 0xFFFF,
    
    kBluetoothL2CAPPSMNone						= 0x0000
};


#pragma mark -
#pragma mark === SDP ===

//===========================================================================================================================
//	Service Discovery Protocol
//===========================================================================================================================

enum
{
	// General
	
	kBluetoothSDPUUID16Base									= 0x0000, 	// 00000000-0000-1000-8000-00805f9b34fb
	
	// Protocols
	
	kBluetoothSDPUUID16SDP				 					= 0x0001, 	// 00000001-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16UDP 									= 0x0002, 	// 00000002-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16RFCOMM 								= 0x0003, 	// 00000003-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16TCP 									= 0x0004, 	// 00000004-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16TCSBIN 								= 0x0005, 	// 00000005-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16TCSAT 								= 0x0006, 	// 00000006-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16OBEX 								= 0x0008, 	// 00000008-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16IP 									= 0x0009, 	// 00000009-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16FTP 									= 0x000A, 	// 0000000A-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16HTTP 								= 0x000C, 	// 0000000C-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16WSP	 								= 0x000E, 	// 0000000E-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16BNEP									= 0x000F,
	kBluetoothSDPUUID16UPNP									= 0x0010,
	kBluetoothSDPUUID16HIDP									= 0x0011,
	kBluetoothSDPUUID16HardcopyControlChannel				= 0x0012,
	kBluetoothSDPUUID16HardcopyDataChannel					= 0x0014,
	kBluetoothSDPUUID16HardcopyNotification					= 0x0016,
	kBluetoothSDPUUID16AVCTP								= 0x0017,
	kBluetoothSDPUUID16AVDTP								= 0x0019,
	kBluetoothSDPUUID16CMPT									= 0x001B,
	kBluetoothSDPUUID16UDI_C_Plane							= 0x001D,
	kBluetoothSDPUUID16MCAPControlChannel					= 0x001E,
	kBluetoothSDPUUID16MCAPDataChannel						= 0x001F,
	kBluetoothSDPUUID16L2CAP 								= 0x0100, 	// 00000100-0000-1000-8000-00805f9b34fb
};

enum SDPServiceClasses
{
	kBluetoothSDPUUID16ServiceClassServiceDiscoveryServer					= 0x1000,	// 00001000-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassBrowseGroupDescriptor					= 0x1001,	// 00001001-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassPublicBrowseGroup						= 0x1002,	// 00001002-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassSerialPort								= 0x1101,	// 00001101-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassLANAccessUsingPPP						= 0x1102,	// 00001102-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassDialupNetworking							= 0x1103,	// 00001103-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassIrMCSync									= 0x1104,	// 00001104-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassOBEXObjectPush							= 0x1105,	// 00001105-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassOBEXFileTransfer							= 0x1106,	// 00001106-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassIrMCSyncCommand							= 0x1107,	// 00001107-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassHeadset									= 0x1108,	// 00001108-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassCordlessTelephony						= 0x1109,	// 00001109-0000-1000-8000-00805f9b34fb
    kBluetoothSDPUUID16ServiceClassAudioSource								= 0x110A,
    kBluetoothSDPUUID16ServiceClassAudioSink								= 0x110B,
    kBluetoothSDPUUID16ServiceClassAVRemoteControlTarget					= 0x110C,
    kBluetoothSDPUUID16ServiceClassAdvancedAudioDistribution				= 0x110D,
    kBluetoothSDPUUID16ServiceClassAVRemoteControl							= 0x110E,
    kBluetoothSDPUUID16ServiceClassAVRemoteControlController				= 0x110F,
	kBluetoothSDPUUID16ServiceClassIntercom									= 0x1110,	// 00001110-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassFax										= 0x1111,	// 00001111-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassHeadsetAudioGateway						= 0x1112,	// 00001112-0000-1000-8000-00805f9b34fb
    kBluetoothSDPUUID16ServiceClassWAP										= 0x1113,
    kBluetoothSDPUUID16ServiceClassWAPClient								= 0x1114,
    kBluetoothSDPUUID16ServiceClassPANU										= 0x1115,
    kBluetoothSDPUUID16ServiceClassNAP										= 0x1116,
    kBluetoothSDPUUID16ServiceClassGN										= 0x1117,
    kBluetoothSDPUUID16ServiceClassDirectPrinting							= 0x1118,
    kBluetoothSDPUUID16ServiceClassReferencePrinting						= 0x1119,
    kBluetoothSDPUUID16ServiceClassImaging									= 0x111A,
    kBluetoothSDPUUID16ServiceClassImagingResponder							= 0x111B,
    kBluetoothSDPUUID16ServiceClassImagingAutomaticArchive					= 0x111C,
    kBluetoothSDPUUID16ServiceClassImagingReferencedObjects					= 0x111D,
    kBluetoothSDPUUID16ServiceClassHandsFree								= 0x111E,
    kBluetoothSDPUUID16ServiceClassHandsFreeAudioGateway					= 0x111F,
    kBluetoothSDPUUID16ServiceClassDirectPrintingReferenceObjectsService	= 0x1120,
    kBluetoothSDPUUID16ServiceClassReflectedUI								= 0x1121,
    kBluetoothSDPUUID16ServiceClassBasicPrinting							= 0x1122,
    kBluetoothSDPUUID16ServiceClassPrintingStatus							= 0x1123,
    kBluetoothSDPUUID16ServiceClassHumanInterfaceDeviceService				= 0x1124,
    kBluetoothSDPUUID16ServiceClassHardcopyCableReplacement					= 0x1125,
    kBluetoothSDPUUID16ServiceClassHCR_Print								= 0x1126,
    kBluetoothSDPUUID16ServiceClassHCR_Scan									= 0x1127,
    kBluetoothSDPUUID16ServiceClassCommonISDNAccess							= 0x1128,
    kBluetoothSDPUUID16ServiceClassVideoConferencingGW						= 0x1129,
    kBluetoothSDPUUID16ServiceClassUDI_MT									= 0x112A,
    kBluetoothSDPUUID16ServiceClassUDI_TA									= 0x112B,
    kBluetoothSDPUUID16ServiceClassAudioVideo								= 0x112C,
    kBluetoothSDPUUID16ServiceClassSIM_Access								= 0x112D,
    kBluetoothSDPUUID16ServiceClassPhonebookAccess_PCE						= 0x112E,
    kBluetoothSDPUUID16ServiceClassPhonebookAccess_PSE						= 0x112F,
    kBluetoothSDPUUID16ServiceClassPhonebookAccess							= 0x1130,
    kBluetoothSDPUUID16ServiceClassHeadset_HS								= 0x1131,
    kBluetoothSDPUUID16ServiceClassMessageAccessServer						= 0x1132,
    kBluetoothSDPUUID16ServiceClassMessageNotificationServer				= 0x1133,
    kBluetoothSDPUUID16ServiceClassMessageAccessProfile						= 0x1134,
    kBluetoothSDPUUID16ServiceClassGlobalNavigationSatelliteSystem			= 0x1135,
    kBluetoothSDPUUID16ServiceClassGlobalNavigationSatelliteSystemServer	= 0x1136,
	kBluetoothSDPUUID16ServiceClassPnPInformation							= 0x1200,	// 00001200-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericNetworking						= 0x1201,	// 00001201-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericFileTransfer						= 0x1202,	// 00001202-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericAudio								= 0x1203,	// 00001203-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericTelephony							= 0x1204,	// 00001204-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassVideoSource								= 0x1303,
	kBluetoothSDPUUID16ServiceClassVideoSink								= 0x1304,
	kBluetoothSDPUUID16ServiceClassVideoDistribution						= 0x1305,
	kBluetoothSDPUUID16ServiceClassHealthDevice								= 0x1400,
	kBluetoothSDPUUID16ServiceClassHealthDeviceSource						= 0x1401,
	kBluetoothSDPUUID16ServiceClassHealthDeviceSink							= 0x1402
};

enum SDPAttributeIdentifierCodes
{
	kBluetoothSDPAttributeIdentifierServiceRecordHandle					= 0x0000,
	kBluetoothSDPAttributeIdentifierServiceClassIDList					= 0x0001,
	kBluetoothSDPAttributeIdentifierServiceRecordState					= 0x0002,
	kBluetoothSDPAttributeIdentifierServiceID							= 0x0003,
	kBluetoothSDPAttributeIdentifierProtocolDescriptorList				= 0x0004,
	kBluetoothSDPAttributeIdentifierBrowseGroupList						= 0x0005,
	kBluetoothSDPAttributeIdentifierLanguageBaseAttributeIDList			= 0x0006,
	kBluetoothSDPAttributeIdentifierServiceInfoTimeToLive				= 0x0007,
	kBluetoothSDPAttributeIdentifierServiceAvailability					= 0x0008,
	kBluetoothSDPAttributeIdentifierBluetoothProfileDescriptorList		= 0x0009,
	kBluetoothSDPAttributeIdentifierDocumentationURL					= 0x000A,
	kBluetoothSDPAttributeIdentifierClientExecutableURL					= 0x000B,
	kBluetoothSDPAttributeIdentifierIconURL								= 0x000C,
	kBluetoothSDPAttributeIdentifierAdditionalProtocolsDescriptorList	= 0x000D,

    // Service Discovery Server
	kBluetoothSDPAttributeIdentifierVersionNumberList					= 0x0200,
	kBluetoothSDPAttributeIdentifierServiceDatabaseState				= 0x0201,
    
    // Browse Group Descriptor
    kBluetoothSDPAttributeIdentifierGroupID								= 0x0200,
    
    // PAN
    kBluetoothSDPAttributeIdentifierIPSubnet							= 0x0200,

    // HID																			Required		Type		Notes
    kBluetoothSDPAttributeIdentifierHIDReleaseNumber					= 0x0200,	// O			uint16
    kBluetoothSDPAttributeIdentifierHIDParserVersion					= 0x0201,	// M			uint16
    kBluetoothSDPAttributeIdentifierHIDDeviceSubclass					= 0x0202,	// M			uint8       Should match the low order 8 bits of CoD unless a combo device
    kBluetoothSDPAttributeIdentifierHIDCountryCode						= 0x0203,	// M			uint8
    kBluetoothSDPAttributeIdentifierHIDVirtualCable						= 0x0204,	// M			bool
    kBluetoothSDPAttributeIdentifierHIDReconnectInitiate				= 0x0205,	// M			bool
    kBluetoothSDPAttributeIdentifierHIDDescriptorList					= 0x0206,	// M			sequence    Layout is defined in Section 6.2 of the HID Specification
    kBluetoothSDPAttributeIdentifierHIDLangIDBaseList					= 0x0207,	// M			sequence
    kBluetoothSDPAttributeIdentifierHIDSDPDisable						= 0x0208,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDBatteryPower						= 0x0209,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDRemoteWake						= 0x020A,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDProfileVersion					= 0x020B,	// M			uint16
    kBluetoothSDPAttributeIdentifierHIDSupervisionTimeout				= 0x020C,	// O			uint16		Default to 5 seconds or longer if not defined
    kBluetoothSDPAttributeIdentifierHIDNormallyConnectable				= 0x020D,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDBootDevice						= 0x020E,	// M			bool		Only defined for mice and keyboards as of HID 1.0
    kBluetoothSDPAttributeIdentifierHIDSSRHostMaxLatency				= 0x020F,	// O			uint16
    kBluetoothSDPAttributeIdentifierHIDSSRHostMinTimeout				= 0x0210,	// O			uint16
    
	kBluetoothSDPAttributeIdentifierServiceVersion						= 0x0300,
	kBluetoothSDPAttributeIdentifierExternalNetwork						= 0x0301,	// Cordless telephony
    kBluetoothSDPAttributeIdentifierNetwork								= 0x0301,	// Handsfree Profile (HFP)
	kBluetoothSDPAttributeIdentifierSupportedDataStoresList				= 0x0301,	// Sync Profile
	kBluetoothSDPAttributeIdentifierFaxClass1Support					= 0x0302,	// Fax Profile
	kBluetoothSDPAttributeIdentifierRemoteAudioVolumeControl			= 0x0302,	// GAP???
	kBluetoothSDPAttributeIdentifierFaxClass2_0Support					= 0x0303,
	kBluetoothSDPAttributeIdentifierSupporterFormatsList				= 0x0303,
	kBluetoothSDPAttributeIdentifierFaxClass2Support					= 0x0304,
	kBluetoothSDPAttributeIdentifierAudioFeedbackSupport				= 0x0305,
    kBluetoothSDPAttributeIdentifierNetworkAddress						= 0x0306,	// WAP
    kBluetoothSDPAttributeIdentifierWAPGateway							= 0x0307,	// WAP
    kBluetoothSDPAttributeIdentifierHomepageURL							= 0x0308,	// WAP
    kBluetoothSDPAttributeIdentifierWAPStackType						= 0x0309,	// WAP
    kBluetoothSDPAttributeIdentifierSecurityDescription					= 0x030A,	// PAN
    kBluetoothSDPAttributeIdentifierNetAccessType						= 0x030B,	// PAN
    kBluetoothSDPAttributeIdentifierMaxNetAccessRate					= 0x030C,	// PAN
    kBluetoothSDPAttributeIdentifierSupportedCapabilities				= 0x0310,	// Imaging
    kBluetoothSDPAttributeIdentifierSupportedFeatures					= 0x0311,	// Imaging & HFP
    kBluetoothSDPAttributeIdentifierSupportedFunctions					= 0x0312,	// Imaging
    kBluetoothSDPAttributeIdentifierTotalImagingDataCapacity			= 0x0313,	// Imaging

	kBluetoothSDPAttributeIdentifierServiceName							= 0x0000, /* +language base offset*/
	kBluetoothSDPAttributeIdentifierServiceDescription					= 0x0001, /* +language base offset*/
	kBluetoothSDPAttributeIdentifierProviderName						= 0x0002  /* +language base offset*/
};

enum SDPAttributeDeviceIdentificationRecord
{
	// DeviceID v1.3																Required		Type		Section		Notes
	kBluetoothSDPAttributeDeviceIdentifierServiceDescription			= 0x0001,	// O			string		-
	kBluetoothSDPAttributeDeviceIdentifierDocumentationURL				= 0x000A,	// O			url			-
	kBluetoothSDPAttributeDeviceIdentifierClientExecutableURL			= 0x000B,	// O			url			-
	kBluetoothSDPAttributeDeviceIdentifierSpecificationID				= 0x0200,	// M			uint16		5.1
	kBluetoothSDPAttributeDeviceIdentifierVendorID						= 0x0201,	// M			uint16		5.2
	kBluetoothSDPAttributeDeviceIdentifierProductID						= 0x0202,	// M			uint16		5.3
	kBluetoothSDPAttributeDeviceIdentifierVersion						= 0x0203,	// M			uint16		5.4
	kBluetoothSDPAttributeDeviceIdentifierPrimaryRecord					= 0x0204,	// M			bool		5.5
	kBluetoothSDPAttributeDeviceIdentifierVendorIDSource				= 0x0205,	// M			uint16		5.6
	kBluetoothSDPAttributeDeviceIdentifierReservedRangeStart			= 0x0206,
	kBluetoothSDPAttributeDeviceIdentifierReservedRangeEnd				= 0x02FF
	
};

enum ProtocolParameters
{
    kBluetoothSDPProtocolParameterL2CAPPSM								= 1,
    kBluetoothSDPProtocolParameterRFCOMMChannel							= 1,
    kBluetoothSDPProtocolParameterTCPPort								= 1,
    kBluetoothSDPProtocolParameterUDPPort								= 1,
    kBluetoothSDPProtocolParameterBNEPVersion							= 1,
    kBluetoothSDPProtocolParameterBNEPSupportedNetworkPacketTypeList	= 2
};

//Inquiries with 'Extended Inquiry Response' (v2.1 specification)

enum BluetoothHCIExtendedInquiryResponseDataTypes
{
	kBluetoothHCIExtendedInquiryResponseDataTypeFlags										=	0x01,
	kBluetoothHCIExtendedInquiryResponseDataType16BitServiceClassUUIDsWithMoreAvailable		=	0x02,
	kBluetoothHCIExtendedInquiryResponseDataType16BitServiceClassUUIDsCompleteList			=	0x03,
	kBluetoothHCIExtendedInquiryResponseDataType32BitServiceClassUUIDsWithMoreAvailable		=	0x04,
	kBluetoothHCIExtendedInquiryResponseDataType32BitServiceClassUUIDsCompleteList			=	0x05,
	kBluetoothHCIExtendedInquiryResponseDataType128BitServiceClassUUIDsWithMoreAvailable	=	0x06,
	kBluetoothHCIExtendedInquiryResponseDataType128BitServiceClassUUIDsCompleteList			=	0x07,
	kBluetoothHCIExtendedInquiryResponseDataTypeShortenedLocalName							=	0x08,
	kBluetoothHCIExtendedInquiryResponseDataTypeCompleteLocalName							=	0x09,
    kBluetoothHCIExtendedInquiryResponseDataTypeTransmitPowerLevel                          =   0x0A,
    kBluetoothHCIExtendedInquiryResponseDataTypeSSPOOBClassOfDevice                         =   0x0D,
    kBluetoothHCIExtendedInquiryResponseDataTypeSSPOOBSimplePairingHashC                    =   0x0E,
    kBluetoothHCIExtendedInquiryResponseDataTypeSSPOOBSimplePairingRandomizerR              =   0x0F,
	kBluetoothHCIExtendedInquiryResponseDataTypeDeviceID									=	0x10,
	kBluetoothHCIExtendedInquiryResponseDataTypeSecurityManagerTKValue						=	0x10,
    kBluetoothHCIExtendedInquiryResponseDataTypeSecurityManagerOOBFlags                     =   0x11,
    kBluetoothHCIExtendedInquiryResponseDataTypeSlaveConnectionIntervalRange                =   0x12,
    kBluetoothHCIExtendedInquiryResponseDataTypeServiceSolicitation16BitUUIDs               =   0x14,
    kBluetoothHCIExtendedInquiryResponseDataTypeServiceSolicitation128BitUUIDs              =   0x15,
    kBluetoothHCIExtendedInquiryResponseDataTypeServiceData                                 =   0x16,
    kBluetoothHCIExtendedInquiryResponseDataTypePublicTargetAddress                         =   0x17,
    kBluetoothHCIExtendedInquiryResponseDataTypeRandomTargetAddress                         =   0x18,
    kBluetoothHCIExtendedInquiryResponseDataTypeAppearance                                  =   0x19,
	kBluetoothHCIExtendedInquiryResponseDataTypeManufacturerSpecificData					=	0xFF
};


// HCI Versions

enum BluetoothHCIVersions
{
	kBluetoothHCIVersionCoreSpecification1_0b												=	0x00,
	kBluetoothHCIVersionCoreSpecification1_1												=	0x01,
	kBluetoothHCIVersionCoreSpecification1_2												=	0x02,
	kBluetoothHCIVersionCoreSpecification2_0EDR												=	0x03,
	kBluetoothHCIVersionCoreSpecification2_1EDR												=	0x04,
	kBluetoothHCIVersionCoreSpecification3_0HS												=	0x05,
	kBluetoothHCIVersionCoreSpecification4_0												=	0x06,
	kBluetoothHCIVersionCoreSpecification4_1												=	0x07
};


// LMP Versions

enum BluetoothLMPVersions
{
	kBluetoothLMPVersionCoreSpecification1_0b												=	0x00,
	kBluetoothLMPVersionCoreSpecification1_1												=	0x01,
	kBluetoothLMPVersionCoreSpecification1_2												=	0x02,
	kBluetoothLMPVersionCoreSpecification2_0EDR												=	0x03,
	kBluetoothLMPVersionCoreSpecification2_1EDR												=	0x04,
	kBluetoothLMPVersionCoreSpecification3_0HS												=	0x05,
	kBluetoothLMPVersionCoreSpecification4_0												=	0x06,
	kBluetoothLMPVersionCoreSpecification4_1												=	0x07
};

#ifdef	__cplusplus
	}
#endif
                                                                                                                                                                                                                                                                                                                                                                         IOBluetooth.h                                                                                       0100644 0001750 0001750 00000003344 12567444611 034375  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 //
//  IOBluetooth.h
//  IOBluetooth Framework
//
//  Copyright (c) 2010 Apple Inc. All rights reserved.
//

#if __OBJC__

	// Objective C API

	#if defined(__cplusplus)
	extern "C" {
	#endif
		
		// Core - General & Support

		#import	<IOBluetooth/Bluetooth.h>
		#import	<IOBluetooth/BluetoothAssignedNumbers.h>
		#import	<IOBluetooth/IOBluetoothTypes.h>
		#import	<IOBluetooth/IOBluetoothUtilities.h>
		#import <IOBluetooth/objc/IOBluetoothObject.h>
		#import <IOBluetooth/objc/IOBluetoothDevice.h>
		#import <IOBluetooth/objc/IOBluetoothDeviceInquiry.h>
		#import <IOBluetooth/objc/IOBluetoothDevicePair.h>
		
		// Core - Host Controller (HCI)

		#import <IOBluetooth/objc/IOBluetoothHostController.h>
		#import <IOBluetooth/objc/IOBluetoothDeviceInquiry.h>

		// Core - L2CAP

		#import <IOBluetooth/objc/IOBluetoothL2CAPChannel.h>

		// Core - RFCOMM

		#import <IOBluetooth/objc/IOBluetoothRFCOMMChannel.h>

		// Core - SDP

		#import <IOBluetooth/objc/IOBluetoothSDPDataElement.h>
		#import <IOBluetooth/objc/IOBluetoothSDPServiceAttribute.h>
		#import <IOBluetooth/objc/IOBluetoothSDPServiceRecord.h>
		#import <IOBluetooth/objc/IOBluetoothSDPUUID.h>

		// Profiles - OBEX

		#import <IOBluetooth/OBEX.h>
		#import <IOBluetooth/OBEXBluetooth.h>
		#import <IOBluetooth/objc/OBEXSession.h>
		#import <IOBluetooth/objc/IOBluetoothOBEXSession.h>
		#import <IOBluetooth/objc/OBEXFileTransferServices.h>
		#import <IOBluetooth/objc/NSDictionaryOBEXExtensions.h>

		// Profiles - Audio, etc.

		#import <IOBluetooth/objc/IOBluetoothHandsFreeAudioGateway.h>
		#import <IOBluetooth/objc/IOBluetoothHandsFree.h>
		#import <IOBluetooth/objc/IOBluetoothHandsFreeDevice.h>

        #import <CoreBluetooth/CoreBluetooth.h>
	#if defined(__cplusplus)
	}
	#endif
	
#endif

                                                                                                                                                                                                                                                                                            IOBluetoothTypes.h                                                                                  0100644 0001750 0001750 00000001364 12567444611 035422  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 /*
	File:		IOBluetoothTypes.h
	Copyright:	 2010 by Apple Inc. All rights reserved.
*/

#pragma once

#import <IOKit/IOReturn.h>

// Error returns
#ifndef sub_iokit_bluetooth
#define sub_iokit_bluetooth				err_sub(8)
#endif

#define iokit_bluetooth_err(return)		(sys_iokit|sub_iokit_bluetooth|return)

#define kIOBluetoothDeviceResetError			iokit_bluetooth_err(1)	// Device reset interrupted pending operation
#define kIOBluetoothConnectionAlreadyExists		iokit_bluetooth_err(2)	// Attempting to open a connection that already exists
#define kIOBluetoothNoHCIController				iokit_bluetooth_err(3)	// No HCI controller is present
#define kIOBluetoothHCIPowerStatesNotSupported	iokit_bluetooth_err(4)	// HCI controller does not support changing power states


                                                                                                                                                                                                                                                                            IOBluetoothUserLib.h                                                                                0100644 0001750 0001750 00000064443 12567444611 035672  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 
#pragma once

#import	<IOKit/IOKitLib.h>
#import 	<CoreFoundation/CFMachPort.h>

#import	<IOBluetooth/Bluetooth.h>

#ifdef __OBJC__
#import		<Foundation/Foundation.h>
#endif

#ifdef	__cplusplus
	extern "C" {
#endif

//--------------------------------------------------------------------------------------------------------------------------
/*!	@header		IOBluetoothUserLib.h
	@abstract	Public Interfaces for Apple's implementation of Bluetooth technology.
	@discussion	There is an accompanying header to this, "Bluetooth.h", which contains all technology-specific typedefs and information. This header relies heavily on it.
*/

//===========================================================================================================================
// General
//===========================================================================================================================
 
#if 0
#pragma mark -
#pragma mark === General ===
#endif


typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothObjectRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothDeviceRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothL2CAPChannelRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothRFCOMMChannelRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothSDPServiceRecordRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothSDPUUIDRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothSDPDataElementRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothUserNotificationRef;

typedef unsigned long								IOBluetoothObjectID;

#define kIOBluetoothObjectIDNULL	((IOBluetoothObjectID)0)

//--------------------------------------------------------------------------------------------------------------------------
/*!
    @function	IOBluetoothGetObjectIDFromArguments
	@abstract	Returns the BluetoothObjectID passed as an argument to an auto-launched app.
	@discussion	When an application gets auto-launched by the blued process (as a result of an incoming connection
				to an appropriately configured service), it has a BluetoothObjectID passed to it on the command
				line.  To get the BluetoothObjectID, simply pass the argc and argv parameters received in main()
				to this function.  The returned BluetoothObjectID can then be used to find the appropriate
				IOBluetoothL2CAPChannel or IOBluetoothRFCOMMChannel depending on the type of service (using 
				IOBluetoothL2CAPChannelCreateFromObjectID() or IOBluetoothRFCOMMChannelCreateFromObjectID.)

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.

    @param		argc The argc parameter passed to main()
	@param		argv The argv parameter passed to main()
	@result		Returns the BluetoothObjectID passed in the given arguments.  If no ID is present,
				kIOBluetoothObjectIDNULL is returned.
*/

extern IOBluetoothObjectID IOBluetoothGetObjectIDFromArguments( int argc, const char *argv[] )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//===========================================================================================================================
// Device searching.
//===========================================================================================================================
 
#if 0
#pragma mark -
#pragma mark === Device Inquiry ===
#endif

//--------------------------------------------------------------------------------------------------------------------------
// As promised, the IOBluetoothDeviceInquiry C API has been removed. Please use obj-c equivalents.
//--------------------------------------------------------------------------------------------------------------------------
		
/*!	@typedef	IOBluetoothDeviceSearchOptions
*/
typedef	UInt32	IOBluetoothDeviceSearchOptions;

enum IOBluetoothDeviceSearchOptionsBits
{
	kSearchOptionsNone							= 0L,
	kSearchOptionsAlwaysStartInquiry			= (1L << 0),
	kSearchOptionsDiscardCachedResults			= (1L << 1),
};

//--------------------------------------------------------------------------------------------------------------------------
/*!	@typedef	IOBluetoothDeviceSearchDeviceAttributes
	@abstract	Structure used to search for particular devices.
	@discussion Make sure you specify all fields! If you do not set deviceClassMajor for example, and the value is
				0, that is mapped to kBluetoothDeviceClassMajorMiscellaneous, which is probably not what you want. To
				search for all device types, you must pass kBluetoothDeviceClassMajorAny and its relatives. 
*/

struct 	IOBluetoothDeviceSearchDeviceAttributes
{
	BluetoothDeviceAddress				address;				// 00 08 22 44 AB 56, etc.
	BluetoothDeviceName					name;					// "Al Yankovic's Phone", etc.
	BluetoothServiceClassMajor			serviceClassMajor;		// Networking, Rendering, etc.
	BluetoothDeviceClassMajor			deviceClassMajor;		// Computer, Phone, Audio, etc.
	BluetoothDeviceClassMinor			deviceClassMinor;		// Desktop, cordless, headset, etc.
};
typedef	struct	IOBluetoothDeviceSearchDeviceAttributes	IOBluetoothDeviceSearchDeviceAttributes;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@struct		IOBluetoothDeviceSearchAttributes
	@discussion You can search for general device classes and service classes, or you can search for a 
				specific device address or name. If you pass NULL as the attribute structure,
				you will get ALL devices in the vicinity found during a search. Note that passing a zeroed
				out block of attributes is NOT equivalent to passing in NULL!	
*/ 

struct 	IOBluetoothDeviceSearchAttributes
{
	IOBluetoothDeviceSearchOptions	options;				// Options.
	IOItemCount						maxResults;				// Maximum number of results you desire. 0 means infinite.
	IOItemCount						deviceAttributeCount;

	IOBluetoothDeviceSearchDeviceAttributes	*attributeList;	
};
typedef	struct	IOBluetoothDeviceSearchAttributes	IOBluetoothDeviceSearchAttributes;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@typedef		IOBluetoothDeviceSearchTypes
 */

typedef UInt32	IOBluetoothDeviceSearchTypes;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@enum		IOBluetoothDeviceSearchTypesBits
	@abstract	Bits to determine what Bluetooth devices to search for
 */

enum IOBluetoothDeviceSearchTypesBits
{
    kIOBluetoothDeviceSearchClassic = 1,
    kIOBluetoothDeviceSearchLE = 2
};

//===========================================================================================================================
// Local Device Interaction
//===========================================================================================================================

#if 0
#pragma mark -
#pragma mark ===  Local Device Interaction ===
#endif

//--------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothIgnoreHIDDevice
	@abstract	Hints that the Mac OS X Bluetooth software should ignore a HID device that connects up.
	@param		device	A Bluetooth Device to ignore.
*/

extern	void	IOBluetoothIgnoreHIDDevice( IOBluetoothDeviceRef	device );

//--------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothRemoveIgnoredHIDDevice
	@abstract	The counterpart to the above IOBluetoothIgnoreHIDDevice() API.
	@param		device	A Bluetooth Device to "un"ignore.
*/

extern	void	IOBluetoothRemoveIgnoredHIDDevice( IOBluetoothDeviceRef	device );


#if 0
#pragma mark -
#pragma mark === SDP ===
#endif

//--------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothAddServiceDict
	@abstract	Adds a service to the local SDP server.
    @discussion	Each entry in the dictionary representing the service contains the individual attributes.  Each
                attribute in the dict is keyed by a string that must begin with a hex number representing the
                attribute ID.  The key string may contain additional characters if desired as long as they 
                follow a space after the ID hex string.  The attribute value must follow the dictionary format 
                described by IOBluetoothSDPDataElement.  This dictionary format allows a service dict to be
                created as a plist file and then loaded into the system rather than built up in code.  See the
                example code for an example of how can be done.
                
                If the service record handle, L2CAP PSM or RFCOMM channel ID specified in the dictionary are in
                use, an alternate one will be assigned.
                
                In addition to attributes that represent the service itself, additional attributes may be specified
				that control the local behavior of the service.  To specify these local attributes, an additional
				property titled "LocalAttributes" may be added to the root of the service dict.  The value of this 
				property must be a dictionary that contains the individual local attributes.
				
				Currently, only two local attributes are supported: "Persistent" and "TargetApplication".
				
				The "Persistent" local attribute must be either a boolean or number representing whether the service
				should be persistent.  A persistent service will be saved off and restored any time the Bluetooth
				hardware is present.  It will persist through reboots and can only be removed by calling 
				IOBluetoothRemoveServiceWithRecordHandle().  This attribute is optional.  By default, if no 
				"Persistent" local property is present,	the service will only exist temporarily.  It will 
				be removed either when IOBluetoothRemoveServiceWithRecordHandle() is called or when the client 
				application exits.
				
				The "TargetApplication" local attribute is used to specify an application to be launched when a 
				remote device attempts to connect to the service (by opening either an L2CAP or RFCOMM channel of
				the type specified in the service).  This value must be a string representing the absolute path to
				the target executable (not just the .app wrapper - i.e. 
				/System/Library/CoreServices/OBEXAgent.app/Contents/MacOS/OBEXAgent).  This attribute is optional.
				If no "TargetApplication" local attribute is specified, no special action will take place when an
				incoming connection to the service is created.  It is up to the client to be monitoring for the
				connection and to do the right thing when one appears.
				
				The "LocalAttributes" property is optional.  If it is not specified, by default the created service
				is transient and will be removed when the client exits.
                
                Additional local attributes to further control incoming services will be added in the future.
                
	@param		serviceDict	A dictionary containing the attributes for the new service
	@param		outServiceRecord A pointer to the newly created IOBluetoothSDPServiceRecordRef.  The assigned RFCOMM
				channel ID can be retrieved from the service record (as can other assigned parameters.)  This value 
				only gets set if kIOReturnSuccess is returned.  The caller is responsible for releasing the 
				IOBluetoothSDPServiceRecordRef when done.
	@result		Returns kIOReturnSuccess if successful.
 
 THIS CALL IS DEPRECATED IN 10.9.  PLEASE USE +[IOBluetoothSDPServiceRecord publishedServiceRecordWithDictionary:]

*/

extern IOReturn IOBluetoothAddServiceDict(CFDictionaryRef serviceDict, IOBluetoothSDPServiceRecordRef *outServiceRecord) DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothRemoveServiceWithRecordHandle
	@abstract	Removes the given service from the local SDP server.
	@discussion	The service record handle passed to this function must match the handle in the service record returned by 
                IOBluetoothAddServiceDict.
	@param		serviceRecordHandle The handle of the service to be removed.
	@result		Returns kIOReturnSuccess if successful.
 
    THIS CALL IS DEPRECATED IN 10.9.  PLEASE USE -[IOBluetoothSDPServiceRecord removeServiceRecord]

*/

extern IOReturn IOBluetoothRemoveServiceWithRecordHandle( BluetoothSDPServiceRecordHandle serviceRecordHandle ) DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER;


#if 0
#pragma mark -
#pragma mark === Notifications ===
#endif

typedef enum IOBluetoothUserNotificationChannelDirection
{
    kIOBluetoothUserNotificationChannelDirectionAny						= 0,
    kIOBluetoothUserNotificationChannelDirectionIncoming				= 1,
    kIOBluetoothUserNotificationChannelDirectionOutgoing				= 2,
} IOBluetoothUserNotificationChannelDirection;

/*!
    @typedef IOBluetoothUserNotificationCallback
    @abstract Callback function definition for user notifications.
    @discussion This callback will be invoked when the notification for which it was registered is sent.
    @param userRefCon	(void *) This user defined parameter was provided during the original call to register
						the notification.
    @param inRef		(IOBluetoothUserNotificationRef) The notification responsible for sending the notification.
    @param status		(IOBluetoothObjectRef) The object that originated the notification.
    @result None.
*/

typedef void (*IOBluetoothUserNotificationCallback)( 	void * userRefCon,
                                                        IOBluetoothUserNotificationRef inRef,
                                                        IOBluetoothObjectRef objectRef );

/*!
    @function IOBluetoothUserNotificationUnregister
    @abstract Unregisters the target notification.
    @discussion This function will unregister the notification.  Once the notification has been unregistered,
				it will no longer call the callback.  Additionally, once this function has been called the
				target IOBluetoothUserNotificationRef is no longer valid.
    @param	notificationRef The target IOBluetoothUserNotificationRef to be unregistered
    @result None.
*/

void IOBluetoothUserNotificationUnregister( IOBluetoothUserNotificationRef notificationRef );

/*!
    @function	IOBluetoothRegisterForDeviceConnectNotifications
	@abstract	Allows a client to register for device connect notifications for any connection.
	@discussion	The given callback will be called whenever any device connection is made.
	@param		callback	The callback to be called when a new connection is made
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding device connect notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothRegisterForDeviceConnectNotifications(	IOBluetoothUserNotificationCallback callback,
                                                                                    void * inRefCon );

/*!
    @function	IOBluetoothDeviceRegisterForDisconnectNotification
	@abstract	Allows a client to register for device disconnect notification.
	@discussion	The given callback will be called when the target device's connection is closed..
	@param		callback	The callback to be called when the target's connection is destroyed
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding device disconnect notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothDeviceRegisterForDisconnectNotification(	IOBluetoothDeviceRef inDevice,
                                                                                    IOBluetoothUserNotificationCallback callback,
                                                                                    void * inRefCon );

/*!
    @function	IOBluetoothRegisterForL2CAPChannelOpenNotifications
	@abstract	Allows a client to register for L2CAP channel open notifications for any L2CAP channel.
	@discussion	The given callback will be called whenever any L2CAP channel is opened.
	@param		callback	The callback to be called when a new L2CAP channel is opened.
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding L2CAP channel notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothRegisterForL2CAPChannelOpenNotifications(	IOBluetoothUserNotificationCallback callback,
                                                                                    void *inRefCon );

/*!
    @function	IOBluetoothRegisterForFilteredL2CAPChannelOpenNotifications
	@abstract	Allows a client to register for L2CAP channel open notifications for certain types of
				L2CAP channels.
	@discussion	The given callback will be called whenever any L2CAP channel is opened.
	@param		callback	The callback to be called when a new L2CAP channel is opened.
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@param		psm			PSM to match a new L2CAP channel.  If the PSM doesn't matter, 0 may be passed in.
	@param		inDirection	The desired direction of the L2CAP channel - kIOBluetoothUserNotificationChannelDirectionAny
				if the direction doesn't matter.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding L2CAP channel notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothRegisterForFilteredL2CAPChannelOpenNotifications(	IOBluetoothUserNotificationCallback callback,
                                                                                            void * inRefCon,
                                                                                            BluetoothL2CAPPSM inPSM,
                                                                                            IOBluetoothUserNotificationChannelDirection inDirection );

/*!
    @function	IOBluetoothL2CAPChannelRegisterForChannelCloseNotification
	@abstract	Allows a client to register for a channel close notification.
    @discussion	The given callback will be called when the L2CAP channel is closed.
	@param		channel		The target L2CAP channel
	@param		callback	Callback to be called when the L2CAP channel is closed.
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding L2CAP channel close notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothL2CAPChannelRegisterForChannelCloseNotification(	IOBluetoothL2CAPChannelRef channel,
                                                                                            IOBluetoothUserNotificationCallback callback,
                                                                                            void *inRefCon );

/*!
    @function	IOBluetoothRegisterForRFCOMMChannelOpenNotifications
	@abstract	Allows a client to register for RFCOMM channel open notifications for any RFCOMM channel.
	@discussion	The given callback will be called whenever any RFCOMM channel is opened.
	@param		callback	The callback to be called when a new RFCOMM channel is opened.
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding RFCOMM channel notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothRegisterForRFCOMMChannelOpenNotifications(	IOBluetoothUserNotificationCallback callback,
                                                                                        void * inRefCon );

/*!
    @function	IOBluetoothRegisterForFilteredRFCOMMChannelOpenNotifications
	@abstract	Allows a client to register for RFCOMM channel open notifications for certain types of
				RFCOMM channels.
	@discussion	The given callback will be called whenever any RFCOMM channel is opened.
	@param		callback	The callback to be called when a new RFCOMM channel is opened.
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@param		channeLID	RFCOMM channel ID to match a new RFCOMM channel.  If the channel ID doesn't matter, 0 may be passed in.
	@param		inDirection	The desired direction of the RFCOMM channel - kIOBluetoothUserNotificationChannelDirectionAny
				if the direction doesn't matter.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding RFCOMM channel notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothRegisterForFilteredRFCOMMChannelOpenNotifications(	IOBluetoothUserNotificationCallback callback,
                                                                                                void * inRefCon,
                                                                                                BluetoothRFCOMMChannelID channelID,
                                                                                                IOBluetoothUserNotificationChannelDirection inDirection );

/*!
    @function	IOBluetoothRFCOMMChannelRegisterForChannelCloseNotification
	@abstract	Allows a client to register for a channel close notification.
    @discussion	The given callback will be called when the RFCOMM channel is closed.
	@param		channel		The target RFCOMM channel
	@param		callback	Callback to be called when the RFCOMM channel is closed.
	@param		inRefCon	Client-supplied refCon to be passed to the callback.
	@result		Returns an IOBluetoothUserNotificationRef representing the outstanding RFCOMM channel close notification.
				To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned
				IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.  
				The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
				be valid.
*/

IOBluetoothUserNotificationRef IOBluetoothRFCOMMChannelRegisterForChannelCloseNotification(	IOBluetoothRFCOMMChannelRef inChannel,
                                                                                            IOBluetoothUserNotificationCallback callback,
                                                                                            void * inRefCon );
        
/*!
 @function	IOBluetoothAddSCOAudioDevice
 @abstract   Creates a persistent audio driver that will route audio data to/from the specified device.
 @discussion In 10.9 this is not needed and does nothing.
 @param		device	A paired Bluetooth audio device
 @param		configDict	Configuration dictionary containing a description of the audio controls to be attached to the driver.  Passing NULL will result in default controls
 @result		Returns kIOReturnSuccess if the audio driver was successfully created, error if hardware does not support SCO or device is not paired. On 10.9 it will always return kIOReturnSuccess.
 */
extern IOReturn IOBluetoothAddSCOAudioDevice( IOBluetoothDeviceRef device, CFDictionaryRef configDict ) DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER;

/*!
 @function	IOBluetoothRemoveSCOAudioDevice
 @abstract   Removes a persistent audio driver for a device that had already been added using IOBluetoothAddAudioDevice(). In 10.9 this is not needed and does nothing.
 @param		device	Bluetooth audio device to remove
 @result		Returns kIOReturnSuccess if the audio driver was successfully removed. On 10.9 it will always return kIOReturnSuccess
 */
extern IOReturn IOBluetoothRemoveSCOAudioDevice( IOBluetoothDeviceRef device ) DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER;


#ifdef	__cplusplus
	}
#endif

                                                                                                                                                                                                                             IOBluetoothUtilities.h                                                                              0100644 0001750 0001750 00000027227 12567444611 036277  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 
#pragma once

#import <stdio.h>
#import <stdlib.h>
#import <string.h>
#import <sysexits.h>
#import <sys/errno.h>
#import <unistd.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOKit/IOReturn.h>
#import <IOBluetooth/IOBluetoothUserLib.h>


#ifdef	__cplusplus
	extern "C" {
#endif

#ifdef __OBJC__

#pragma mark === String Functions === 

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNSStringToDeviceAddress
	@abstract	Convenience routine to take an NSString and turn it into a BluetoothDeviceAddress structure.
	@param		inNameString		Ptr to an NSString that contains the data to turn into the device address.
	@param		outDeviceAddress	Ptr to an address structure that will be returned.
	@result		Returns success (0) or failure code.
	@discussion	Pass in most types of strings, such as "001122334455" or "00-11-22-33-44-55" and the conversion should be successful. Also, you should have 2 characters per byte for the conversion to work properly.
*/

extern	IOReturn	IOBluetoothNSStringToDeviceAddress( NSString * inNameString, BluetoothDeviceAddress * outDeviceAddress );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNSStringFromDeviceAddress
	@abstract	Convenience routine to take a device address structure and create an NSString.
	@param		deviceAddress		A valid bluetooth device structure.
	@result		Returns the created address string.
	@discussion	The resultant string will be in this format: "00-11-22-33-44-55"
*/

extern	NSString *	IOBluetoothNSStringFromDeviceAddress( const BluetoothDeviceAddress *deviceAddress );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNSStringFromDeviceAddressColon
@abstract	Convenience routine to take a device address structure and create an NSString.
@param		deviceAddress		A valid bluetooth device structure.
@result		Returns the created address string.
@discussion	The resultant string will be in this format: "00:11:22:33:44:55"
*/

extern  NSString *	IOBluetoothNSStringFromDeviceAddressColon(const BluetoothDeviceAddress *deviceAddress);
        
#pragma mark -
#pragma mark === File Utilities ===

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothIsFileAppleDesignatedPIMData
	@abstract	Apple designated PIM data is classified as: .vcard, .vcal, .vcf, .vnote, .vmsg, .vcs
	@param		inFileName		Name of file - should include extension!
	@result		Yes or no, is it Apple-designated PIM data?
	@discussion	Not much to talk about.
*/

extern	Boolean		IOBluetoothIsFileAppleDesignatedPIMData( NSString* inFileName );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothGetUniqueFileNameAndPath
	@abstract	
	@param		inName		Name of file that needs unique name in the specified path.
	@param		inPath		Path you are trying to put file into.
	@result		String with a unique name appended on it for the provided path.
	@discussion		When passed a VALID filename and a VALID path, this routine will return you a the path with the name
					appended onto it. If it already exist, it will insert a #1, #2, etc. Example:
					If you pass &#64"TestFile.txt" and &#64"~/Documents", you will get &#64"~Documents/TestFile.txt".
					If one already exists, you will be returned: &#64"~Documents/TestFile #1.txt".
*/

extern	NSString*	IOBluetoothGetUniqueFileNameAndPath( NSString* inName, NSString* inPath );
		
#else

extern	IOReturn	IOBluetoothCFStringToDeviceAddress( CFStringRef inNameString, BluetoothDeviceAddress * outDeviceAddress );
extern	CFStringRef	IOBluetoothCFStringFromDeviceAddress( const BluetoothDeviceAddress *deviceAddress );
extern	Boolean		IOBluetoothIsFileAppleDesignatedPIMDataAtCFStringPath( CFStringRef inFileName );
extern	CFStringRef	IOBluetoothGetUniqueFileNameAndWithCFStringPath( CFStringRef inName, CFStringRef inPath );
		
#endif /* __OBJC__ */

#pragma mark -
#pragma mark === Data Handling Functions === 

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothPackData
	@abstract	Packs a variable amount of parameters into a buffer according to a printf-style format string.
	@param		ioBuffer	Ptr to buffer to receive packed data.
	@param		inFormat	printf-style format string controlling how the data is packed.
	@param		varArg		Variable number parameters controlled by the printf-style format string (only PackData).
	@param		inArgs		Variable argument list containing data controlled by format string (only PackDataList).
	@result		Number of bytes packed or -1 if an error occurred.
	@discussion	
	Supported format characters:
	<pre>
		'b' 1 byte of data ('b'yte)
		'h' 2 bytes of data ('h'alf-word)
		'H' 2 bytes of data ('h'alf-word) to byte reverse.
		't' 3 bytes of data ('t'riple byte, least significant 24-bits).
		'T' 3 bytes of data ('t'riple byte, least significant 24-bits) to byte reverse.
		'w' 4 bytes of data ('w'ord).
		'W' 4 bytes of data ('w'ord) to byte reverse.
		'1'	Ptr to 1 byte of data.
		'2' Ptr to 2 bytes of data.
		'&#64'	(shift-2) Ptr to 2 bytes of data to byte reverse.
		'3' Ptr to 3 bytes of data.
		'#'	(shift-3) Ptr to 3 bytes of data to byte reverse.
		'4' Ptr to 4 bytes of data.
		'$'	(shift-4) Ptr to 4 bytes of data to byte reverse.
		'5' Ptr to 5 bytes of data.
		'%'	(shift-5) Ptr to 5 bytes of data to byte reverse.
		'6' Ptr to 6 bytes of data.
		'^'	(shift-6) Ptr to 6 bytes of data to byte reverse.
		'7' Ptr to 6 bytes of data.
		'&'	(shift-7) Ptr to 7 bytes of data to byte reverse.
		'8' Ptr to 6 bytes of data.
		'*'	(shift-8) Ptr to 8 bytes of data to byte reverse.
		'9' Ptr to 6 bytes of data.
		'('	(shift-9) Ptr to 9 bytes of data to byte reverse.
		'n' Ptr to n bytes of data (first param is size, second is ptr).
		'N' Ptr to n bytes of data to byte reverse (first param is size, second is ptr).
		's' Ptr to C-string (includes null terminator)
		'p' Ptr to Pascal-string (includes length byte).
	</pre>
	Example usage:
	<pre>
		bytesPacked = PackData( buffer, "bts", 'U', 'XYZ', "This is a C-style string" );
	</pre>
	<b>
		<i>
			Warning:
		</i>
	</b>
	<i>
		Raw values packed with 'b', 'h', 't', and 'w' have their bytes packed into the buffer from left to right
		even on little-endian systems. For example, the value 0x12345678 would be sent out as 0x12 0x34 0x56 0x78.
		This needs to be taken into consideration if the value is expected to be in little-endian format in the 
		buffer. This case requires you byte swap the value on all systems before sending it to this routine.
	</i>
*/

extern long		IOBluetoothPackData( void *ioBuffer, const char *inFormat, ... );
extern long		IOBluetoothPackDataList( void *ioBuffer, const char *inFormat, va_list inArgs );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothUnpackData
	@abstract	Unpacks a variable amount of data from a buffer into a variable number of parameters according to a 
				printf-style format string.
	@param		inBufferSize	Size of buffer to unpack data from.
	@param		inBuffer		Ptr to buffer to unpack data from.
	@param		inFormat		printf-style format string controlling how the data is unpacked.
	@param		varArg			Variable number parameters to receive data, controlled by the format string (only UnpackData).
	@param		inArgs			Variable argument list containing data controlled by format string (only UnpackDataList).
	@result		Number of bytes unpacked or -1 if an error occurred.
	@discussion	
	Supported format characters:
	<pre>
		'b' Ptr to receive 1 byte of data ('b'yte).
		'h' Ptr to receive 2 bytes of data ('h'alf-word).
		'H' Ptr to receive 2 bytes of byte-reversed data ('h'alf-word).
		't' Ptr to receive 3 bytes of data ('t'riple byte, least significant 24-bits).
		'T' Ptr to receive 3 bytes of byte-reversed data ('t'riple byte, least significant 24-bits).
		'w' Ptr to receive 4 bytes of data ('w'ord).
		'W' Ptr to receive 4 bytes of byte-reversed data ('w'ord).
		'1' Ptr to receive 1 byte of data.
		'2' Ptr to receive 2 bytes of data.
		'&#64'	(shift-2) Ptr to 2 bytes of data, byte reversed.
		'3' Ptr to receive 3 bytes of data.
		'#'	(shift-3) Ptr to receive 3 bytes of data, byte reversed.
		'4' Ptr to receive 4 bytes of data.
		'$'	(shift-4) Ptr to receive 4 bytes of data, byte reversed.
		'5' Ptr to receive 5 bytes of data.
		'%'	(shift-5) Ptr to receive 5 bytes of data, byte reversed.
		'6' Ptr to receive 6 bytes of data.
		'^'	(shift-6) Ptr to receive 6 bytes of data, byte reversed.
		'7' Ptr to receive 7 bytes of data.
		'&'	(shift-7) Ptr to receive 7 bytes of data, byte reversed.
		'8' Ptr to receive 8 bytes of data.
		'*'	(shift-8) Ptr to receive 8 bytes of data, byte reversed.
		'9' Ptr to receive 9 bytes of data.
		'('	(shift-9) Ptr to receive 9 bytes of data, byte reversed.
		'n' Ptr to receive n bytes of data (first param is size, second is ptr to receive data).
		'N' Ptr to receive n bytes of data to byte reverse (first param is size, second is ptr to receive data).
		's' Ptr to receive C-string (first param is max size, second is ptr to receive data).
		'p' Ptr to receive Pascal-string (first param is max size including length-byte, second is ptr to receive data).
	</pre>
	Example usage:
	<pre>
		bytesUnpacked = UnpackData( 100, buffer, "bwnsp", &myByte1, &myWord, 50, buffer1, 128, buffer2, 255, pString );
	</pre>
*/

extern long		IOBluetoothUnpackData( ByteCount inBufferSize, const void *inBuffer, const char *inFormat, ... );
extern long		IOBluetoothUnpackDataList( ByteCount inBufferSize, const void *inBuffer, const char *inFormat, va_list inArgs );

#pragma mark -
#pragma mark === Registry Stuff ===

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNumberOfAvailableHIDDevices
	@abstract	Returns total number of HID devices on the system (Bluetooth + USB)
	@result		Number of HID devices.
*/

extern long IOBluetoothNumberOfAvailableHIDDevices();

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNumberOfPointingHIDDevices
	@abstract	Returns number of "pointing" HID devices on the system (Bluetooth + USB)
	@result		Number of HID devices.
*/

extern long IOBluetoothNumberOfPointingHIDDevices();

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNumberOfKeyboardHIDDevices
	@abstract	Returns number of keyboard HID devices on the system (Bluetooth + USB)
	@result		Number of HID devices.
*/

extern long IOBluetoothNumberOfKeyboardHIDDevices();

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothNumberOfTabletHIDDevices
	@abstract	Returns number of "Tablet" HID devices on the system (Bluetooth + USB)
	@result		Number of HID devices.
*/

extern long IOBluetoothNumberOfTabletHIDDevices();

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothFindNumberOfRegistryEntriesOfClassName
	@abstract	Returns total number of registry entries with the provided device classname. e.g. "IOHIPointing"
	@result		Number of HID devices.
*/

extern long IOBluetoothFindNumberOfRegistryEntriesOfClassName( const char *deviceType );


#ifdef	__cplusplus
	}
#endif
                                                                                                                                                                                                                                                                                                                                                                         OBEX.h                                                                                              0100644 0001750 0001750 00000254521 12567444611 032742  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 /*
	File:		OBEX.h
	Contains:	Technology interfaces for OBEX.
	Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/

#pragma once

#import <stdio.h>
#import <stdint.h>

#import <CoreServices/CoreServices.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

//---------------------------------------------------------------------------------------------------------------------------
/*!	@header		OBEX
	@abstract	Public OBEX technology interfaces.	
	@discussion	Contains generic OBEX constants, structs, and C API used for all OBEX communication over any transport.
				For specific transport API, see that transport's C API. For example, if you wanted to know more about the
				Bluetooth OBEX implementation, see OBEXBluetooth.h.
				
				The file also contains API that will assist in the construction and deconstruction of OBEX headers to
				and from raw bytes, as well as the creation of vCards and vEvents.
*/

#if 0
#pragma mark ======= OBEX.h =======
#endif


#ifdef	__cplusplus
	extern "C" {
#endif


//===========================================================================================================================
//	OBEXErrorCodes
//===========================================================================================================================

#if 0
#pragma mark -
#pragma mark ======= OBEXErrorCodes =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXErrorCodes
	@abstract	Codes for OBEX errors. If the return value was not in the following range, then it is most likely resulting
				from kernel code/IOKit, and you should consult IOReturn.h for those codes.
	@constant	kOBEXErrorRangeMin				Minimum value in OBEX error range.
	@constant	kOBEXErrorRangeMax				Maximum value in OBEX error range.
	
*/

typedef int32_t	OBEXError;
enum OBEXErrorCodes
{
	kOBEXErrorRangeMin					= -21850,
	kOBEXErrorRangeMax					= -21899,
	
	kOBEXSuccess						= 0,			// Success at whatever you were attempting.
	kOBEXGeneralError					= -21850,		// Catch all for misc. errors.
	kOBEXNoResourcesError				= -21851,		// An allocation failed, etc.
	kOBEXUnsupportedError				= -21852,		// operation or item is not supported.
	kOBEXInternalError					= -21853,		// A problem has occurred in our internal code.
	kOBEXBadArgumentError				= -21854,		// A bad argument was passed to an OBEX function.
	kOBEXTimeoutError					= -21855,		// timeout error
	kOBEXBadRequestError				= -21856,		// bad request error
	kOBEXCancelledError					= -21857,
	kOBEXForbiddenError					= -21858,		// operation was not allowed on remote device (wrong permissions, etc.).
	
	kOBEXUnauthorizedError				= -21859,		// Unauthorized
	kOBEXNotAcceptableError				= -21860,		// Not Acceptable
	kOBEXConflictError					= -21861,		// Conflict
	kOBEXMethodNotAllowedError			= -21862,		// Method not allowed
	kOBEXNotFoundError					= -21863,		// File/Folder not found
	kOBEXNotImplementedError			= -21864,		// Not Implemented
	kOBEXPreconditionFailedError		= -21865,		// Precondition failed
		
	kOBEXSessionBusyError				= -21875,		// Session is busy with a command already.
	kOBEXSessionNotConnectedError		= -21876,		// Session does not have an open connection.
	kOBEXSessionBadRequestError			= -21877,		// Whatever you are trying to do is invalid (trying to send more data than the max packet size supports, e.g.).
	kOBEXSessionBadResponseError		= -21878,		// The OBEX Server/client you are talking to has sent us a bad response (e.g. when a Connect Command was sent, we got back "0xA0", which is not correct).
	kOBEXSessionNoTransportError		= -21879,		// The underlying transport (Bluetooth, etc.) is not open/available.
	kOBEXSessionTransportDiedError		= -21880,		// The underlying transport connection (Bluetooth, etc.) died.
	kOBEXSessionTimeoutError			= -21881,		// Timeout occurred performing an operation.
	kOBEXSessionAlreadyConnectedError	= -21882		// Connection over OBEX already established (returned from OBEXConnect).
};

//===========================================================================================================================
//	OBEXMacros
//===========================================================================================================================

#if 0
#pragma mark -
#pragma mark ======= OBEXMacros =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*! @defineblock OBEX Convenience Macros
 *	Convenience Macros for OBEX Header Identifiers. The API should shield you from using these, they are included here to completeness.
 */

#define 	GET_HEADER_ID_IS_NULL_TERMINATED_UNICODE_TEXT( HEADER_ID )		( (HEADER_ID & 0xC0) == 0x00 )
#define 	GET_HEADER_ID_IS_BYTE_SEQUENCE( HEADER_ID )						( (HEADER_ID & 0xC0) == 0x40 )
#define 	GET_HEADER_ID_IS_1_BYTE_QUANTITY( HEADER_ID )					( (HEADER_ID & 0xC0) == 0x80 )
#define 	GET_HEADER_ID_IS_4_BYTE_QUANTITY( HEADER_ID )					( (HEADER_ID & 0xC0) == 0xC0 )
#define 	SET_HEADER_ID_IS_NULL_TERMINATED_UNICODE_TEXT( HEADER_ID )		( (HEADER_ID & 0x3F) )
#define 	SET_HEADER_ID_IS_BYTE_SEQUENCE( HEADER_ID )						( (HEADER_ID & 0x3F) | 0x40 )
#define 	SET_HEADER_ID_IS_1_BYTE_QUANTITY( HEADER_ID )					( (HEADER_ID & 0x3F) | 0x80 )
#define 	SET_HEADER_ID_IS_4_BYTE_QUANTITY( HEADER_ID )					( (HEADER_ID & 0x3F) | 0xC0 )
#define 	IS_RESPONSE_CODE_FINAL_BIT_SET( RESPONSE_CODE )					( RESPONSE_CODE >> 7L )
#define 	STRIP_RESPONSE_CODE_FINAL_BIT( RESPONSE_CODE )					( RESPONSE_CODE & 0x7F )
		
/*! @/defineblock */
		
//===========================================================================================================================
//	OBEXHeaderIdentifiers
//===========================================================================================================================

#if 0
#pragma mark -
#pragma mark ======= OBEXHeaderIdentifiers =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXHeaderIdentifiers
	@abstract	Identifiers for OBEX Headers.
	@constant	kOBEXHeaderIDName						Name of the object.  Null terminated unicode text.
	@constant	kOBEXHeaderIDDescription				Text description of the object. Null terminated unicode text.
	@constant	kOBEXHeaderIDReservedRangeStart			Range includes all combos of the upper 2 bits. Reserved.
	@constant	kOBEXHeaderIDReservedRangeEnd			Range includes all combos of the upper 2 bits. Reserved.
	@constant	kOBEXHeaderIDUserDefinedRangeStart		Range includes all combos of the upper 2 bits. User defined.
	@constant	kOBEXHeaderIDUserDefinedRangeEnd		Range includes all combos of the upper 2 bits. User defined.
	@constant	kOBEXHeaderIDType						Type of object - e.g. text, html, binary, etc. Null terminated ASCII text.
	@constant	kOBEXHeaderIDTimeISO					Date/time stamp - ISO8601 version of time. (YYYYMMDDTHHMMSSZ)
	@constant	kOBEXHeaderIDTarget						Name of service that operation is destined for.
	@constant	kOBEXHeaderIDHTTP						An HTTP 1.x header.
	@constant	kOBEXHeaderIDBody						A Chunk of the object body.
	@constant	kOBEXHeaderIDEndOfBody					The last checking of the object body.
	@constant	kOBEXHeaderIDWho						Identifies the OBEX applications, used to tell if talking to a peer.
	@constant	kOBEXHeaderIDAppParameters				Extended application request and resposnse info.
	@constant	kOBEXHeaderIDAuthorizationChallenge		Authentication digest-challenge.
	@constant	kOBEXHeaderIDAuthorizationResponse		Authentication digest-reponse.
	@constant	kOBEXHeaderIDObjectClass				OBEX Object - class of object.
	@constant	kOBEXHeaderIDCount						Number of objects (used in Connect command).
	@constant	kOBEXHeaderIDLength						The length of the object in bytes. 4 byte unsigned integer value.
	@constant	kOBEXHeaderIDTime4Byte					Date/time stamp - 4 byte version for compat. only. Seconds since Jan 1, 1970.
	@constant	kOBEXHeaderIDConnectionID				An identifier used for OBEX connection multiplexing.
	@constant	kOBEXHeaderIDOBEX13WANUUID					Used to provide state information when layering OBEX over stateless networks. 16byte UUID.
	@constant	kOBEXHeaderIDOBEX13ObjectClass				Used to reference the object class and properties. Byte Sequence.
	@constant	kOBEXHeaderIDOBEX13SessionParameters		Byte sequence required for CreateSession, CloseSession and other OBEX commands.
	@constant	kOBEXHeaderIDOBEX13SessionSequenceNumber	1-byte quantitied containing the current sequence number.
	@constant	kOBEXHeaderIDOBEX13CreatorID				4-byte unsigned integer that identifies the creator of the object.
*/

enum OBEXHeaderIdentifiers
{
	kOBEXHeaderIDName							= 0x01,
	kOBEXHeaderIDDescription					= 0x05,
	kOBEXHeaderIDReservedRangeStart				= 0x10,
	kOBEXHeaderIDReservedRangeEnd				= 0x2F,
	
	kOBEXHeaderIDUserDefinedRangeStart			= 0x30,
	kOBEXHeaderIDUserDefinedRangeEnd			= 0x3F,
	
	kOBEXHeaderIDType							= 0x42,
	kOBEXHeaderIDTimeISO						= 0x44,
	kOBEXHeaderIDTarget							= 0x46,
	kOBEXHeaderIDHTTP							= 0x47,
	kOBEXHeaderIDBody							= 0x48,
	kOBEXHeaderIDEndOfBody						= 0x49,
	kOBEXHeaderIDWho							= 0x4A,
	kOBEXHeaderIDAppParameters					= 0x4C,
	kOBEXHeaderIDAuthorizationChallenge			= 0x4D,
	kOBEXHeaderIDAuthorizationResponse			= 0x4E,
	kOBEXHeaderIDObjectClass					= 0x4F, /* OBEX 1.2 and prior specification only; note that there is another Object Class defined below; this is removed in the 1.3 specification */

	kOBEXHeaderIDCount							= 0xC0,
	kOBEXHeaderIDLength							= 0xC3,
	kOBEXHeaderIDTime4Byte						= 0xC4,
	kOBEXHeaderIDConnectionID					= 0xCB,

	/* OBEX 1.3 and later specification */
	
	kOBEXHeaderIDOBEX13WANUUID					= 0x50, 
	kOBEXHeaderIDOBEX13ObjectClass				= 0x51,
	kOBEXHeaderIDOBEX13SessionParameters		= 0x52,
	kOBEXHeaderIDOBEX13SessionSequenceNumber	= 0x93,
	kOBEXHeaderIDOBEX13CreatorID				= 0xCF,
	
	/* End OBEX 1.3 and later specification */
	
};

//===========================================================================================================================
//	OBEXOpCodeResponseValues
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXOpCodeCommandResponseValues =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXOpCodeResponseValues
	@abstract	Response opCode values.
*/

enum OBEXOpCodeResponseValues
{
	kOBEXResponseCodeReservedRangeStart						= 0x00,
	kOBEXResponseCodeReservedRangeEnd						= 0x0F,
	
	kOBEXResponseCodeContinue								= 0x10,
	kOBEXResponseCodeContinueWithFinalBit					= 0x90,
	kOBEXResponseCodeSuccess								= 0x20,
	kOBEXResponseCodeSuccessWithFinalBit					= 0xA0,
	kOBEXResponseCodeCreated								= 0x21,
	kOBEXResponseCodeCreatedWithFinalBit					= 0xA1,
	kOBEXResponseCodeAccepted								= 0x22,
	kOBEXResponseCodeAcceptedWithFinalBit					= 0xA2,
	kOBEXResponseCodeNonAuthoritativeInfo					= 0x23,
	kOBEXResponseCodeNonAuthoritativeInfoWithFinalBit		= 0xA3,
	kOBEXResponseCodeNoContent								= 0x24,
	kOBEXResponseCodeNoContentWithFinalBit					= 0xA4,
	kOBEXResponseCodeResetContent							= 0x25,
	kOBEXResponseCodeResetContentWithFinalBit				= 0xA5,
	kOBEXResponseCodePartialContent							= 0x26,
	kOBEXResponseCodePartialContentWithFinalBit				= 0xA6,
	
	kOBEXResponseCodeMultipleChoices						= 0x30,
	kOBEXResponseCodeMultipleChoicesWithFinalBit			= 0xB0,
	kOBEXResponseCodeMovedPermanently						= 0x31,
	kOBEXResponseCodeMovedPermanentlyWithFinalBit			= 0xB1,
	kOBEXResponseCodeMovedTemporarily						= 0x32,
	kOBEXResponseCodeMovedTemporarilyWithFinalBit			= 0xB2,
	kOBEXResponseCodeSeeOther								= 0x33,
	kOBEXResponseCodeSeeOtherWithFinalBit					= 0xB3,
	kOBEXResponseCodeNotModified							= 0x34,
	kOBEXResponseCodeNotModifiedWithFinalBit				= 0xB4,
	kOBEXResponseCodeUseProxy								= 0x35,
	kOBEXResponseCodeUseProxyWithFinalBit					= 0xB5,
	
	kOBEXResponseCodeBadRequest								= 0x40,
	kOBEXResponseCodeBadRequestWithFinalBit					= 0xC0,
	kOBEXResponseCodeUnauthorized							= 0x41,
	kOBEXResponseCodeUnauthorizedWithFinalBit				= 0xC1,
	kOBEXResponseCodePaymentRequired						= 0x42,
	kOBEXResponseCodePaymentRequiredWithFinalBit			= 0xC2,
	kOBEXResponseCodeForbidden								= 0x43,
	kOBEXResponseCodeForbiddenWithFinalBit					= 0xC3,
	kOBEXResponseCodeNotFound								= 0x44,
	kOBEXResponseCodeNotFoundWithFinalBit					= 0xC4,
	kOBEXResponseCodeMethodNotAllowed						= 0x45,
	kOBEXResponseCodeMethodNotAllowedWithFinalBit			= 0xC5,
	kOBEXResponseCodeNotAcceptable							= 0x46,
	kOBEXResponseCodeNotAcceptableWithFinalBit				= 0xC6,
	kOBEXResponseCodeProxyAuthenticationRequired			= 0x47,
	kOBEXResponseCodeProxyAuthenticationRequiredWithFinalBit= 0xC7,
	kOBEXResponseCodeRequestTimeOut							= 0x48,
	kOBEXResponseCodeRequestTimeOutWithFinalBit				= 0xC8,
	kOBEXResponseCodeConflict								= 0x49,
	kOBEXResponseCodeConflictWithFinalBit					= 0xC9,
	kOBEXResponseCodeGone									= 0x4A,
	kOBEXResponseCodeGoneWithFinalBit						= 0xCA,
	kOBEXResponseCodeLengthRequired							= 0x4B,
	kOBEXResponseCodeLengthRequiredFinalBit					= 0xCB,
	kOBEXResponseCodePreconditionFailed						= 0x4C,
	kOBEXResponseCodePreconditionFailedWithFinalBit			= 0xCC,
	kOBEXResponseCodeRequestedEntityTooLarge				= 0x4D,
	kOBEXResponseCodeRequestedEntityTooLargeWithFinalBit	= 0xCD,
	kOBEXResponseCodeRequestURLTooLarge						= 0x4E,
	kOBEXResponseCodeRequestURLTooLargeWithFinalBit			= 0xCE,
	kOBEXResponseCodeUnsupportedMediaType					= 0x4F,
	kOBEXResponseCodeUnsupportedMediaTypeWithFinalBit		= 0xCF,
	
	kOBEXResponseCodeInternalServerError					= 0x50,
	kOBEXResponseCodeInternalServerErrorWithFinalBit		= 0xD0,
	kOBEXResponseCodeNotImplemented							= 0x51,
	kOBEXResponseCodeNotImplementedWithFinalBit				= 0xD1,
	kOBEXResponseCodeBadGateway								= 0x52,
	kOBEXResponseCodeBadGatewayWithFinalBit					= 0xD2,
	kOBEXResponseCodeServiceUnavailable						= 0x53,
	kOBEXResponseCodeServiceUnavailableWithFinalBit			= 0xD3,
	kOBEXResponseCodeGatewayTimeout							= 0x54,
	kOBEXResponseCodeGatewayTimeoutWithFinalBit				= 0xD4,
	kOBEXResponseCodeHTTPVersionNotSupported				= 0x55,
	kOBEXResponseCodeHTTPVersionNotSupportedWithFinalBit	= 0xD5,
	
	kOBEXResponseCodeDatabaseFull							= 0x60,
	kOBEXResponseCodeDatabaseFullWithFinalBit				= 0xE0,
	kOBEXResponseCodeDatabaseLocked							= 0x61,
	kOBEXResponseCodeDatabaseLockedWithFinalBit				= 0xE1,
};

//===========================================================================================================================
//	OBEXOpCodeCommandValues
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXOpCodeCommandValues =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXOpCodeCommandValues
	@abstract	Operation OpCode values for commands.
*/

enum OBEXOpCodeCommandValues
{
	kOBEXOpCodeReserved					= 0x04,

	kOBEXOpCodeConnect					= 0x80,		// High bit always set.
	kOBEXOpCodeDisconnect				= 0x81,		// High bit always set.
	
	kOBEXOpCodePut						= 0x02,
	kOBEXOpCodePutWithHighBitSet		= 0x82,
	kOBEXOpCodeGet						= 0x03,
	kOBEXOpCodeGetWithHighBitSet		= 0x83,
	
	kOBEXOpCodeReservedWithHighBitSet	= 0x84,
	kOBEXOpCodeSetPath					= 0x85,		// High bit always set.

	kOBEXOpCodeAbort					= 0xFF,		// High bit always set.
	kOBEXOpCodeReservedRangeStart		= 0x06,
	kOBEXOpCodeReservedRangeEnd			= 0x0F,
	kOBEXOpCodeUserDefinedStart			= 0x10,
	kOBEXOpCodeUserDefinedEnd			= 0x1F,
};

//===========================================================================================================================
//	OBEXConnectFlags
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXConnectFlags =======
#endif


//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXConnectFlags
	@abstract	Flags for Connect command.
*/

enum OBEXConnectFlagValues
{
	kOBEXConnectFlagNone							= (0 << 0L),
	
	kOBEXConnectFlagSupportMultipleItLMPConnections	= (1 << 0L),
	kOBEXConnectFlag1Reserved						= (1 << 1L),
	kOBEXConnectFlag2Reserved						= (1 << 2L),
	kOBEXConnectFlag3Reserved						= (1 << 3L),
	kOBEXConnectFlag4Reserved						= (1 << 4L),
	kOBEXConnectFlag5Reserved						= (1 << 5L),
	kOBEXConnectFlag6Reserved						= (1 << 6L),
	kOBEXConnectFlag7Reserved						= (1 << 7L),
};

//===========================================================================================================================
//	OBEXPutFlags
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXSetPathFlags =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXSetPathFlags
	@abstract	Flags for SetPath command. Not that these are called "PutFlags". That is a mistake, they are not used
				with a Put command. We are not changing the names to maintain backwards compatibility.
*/

enum OBEXPutFlagValues
{
	kOBEXPutFlagNone								= (0 << 0L),
	
	kOBEXPutFlagGoToParentDirFirst					= (1 << 0L),
	kOBEXPutFlagDontCreateDirectory					= (1 << 1L),
	kOBEXPutFlag2Reserved							= (1 << 2L),
	kOBEXPutFlag3Reserved							= (1 << 3L),
	kOBEXPutFlag4Reserved							= (1 << 4L),
	kOBEXPutFlag5Reserved							= (1 << 5L),
	kOBEXPutFlag6Reserved							= (1 << 6L),
	kOBEXPutFlag7Reserved							= (1 << 7L),

};

//===========================================================================================================================
//	OBEXNonceFlags
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXNonceFlags =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXNonceFlags
	@abstract	Flags for Nonce command during digest challenge.
*/

enum OBEXNonceFlagValues
{
	kOBEXNonceFlagNone								= (0 << 0L),
	
	kOBEXNonceFlagSendUserIDInResponse				= (1 << 0L),
	kOBEXNonceFlagAccessModeReadOnly				= (1 << 1L),
	kOBEXNonceFlag2Reserved							= (1 << 2L),
	kOBEXNonceFlag3Reserved							= (1 << 3L),
	kOBEXNonceFlag4Reserved							= (1 << 4L),
	kOBEXNonceFlag5Reserved							= (1 << 5L),
	kOBEXNonceFlag6Reserved							= (1 << 6L),
	kOBEXNonceFlag7Reserved							= (1 << 7L),

};


//===========================================================================================================================
//	OBEXRealmValues
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXRealmValues =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXRealmValues
	@abstract	Values for Realm during digest response.
*/

enum OBEXRealmValues
{
	kOBEXRealmASCII									= 0x00,
	kOBEXRealmISO88591								= 0x01,
	kOBEXRealmISO88592								= 0x02,
	kOBEXRealmISO88593								= 0x03,
	kOBEXRealmISO88594								= 0x04,
	kOBEXRealmISO88595								= 0x05,
	kOBEXRealmISO88596								= 0x06,
	kOBEXRealmISO88597								= 0x07,
	kOBEXRealmISO88598								= 0x08,
	kOBEXRealmISO88599								= 0x09,
	kOBEXRealmUNICODE								= 0xFF,
};

//===========================================================================================================================
//	OBEXOpCodeSessionValues
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXOpCodeSessionValues =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXOpCodeSessionValues
	@abstract	Operation OpCode values for sessions. From the OBEX 1.3 specification.
*/

enum OBEXOpCodeSessionValues
{
	kOBEXOpCodeCreateSession			= 0x00,
	kOBEXOpCodeCloseSession				= 0x01,
	kOBEXOpCodeSuspendSession			= 0x02,
	kOBEXOpCodeResumeSession			= 0x03,
	kOBEXOpCodeSetTimeout				= 0x04
	
	/* 0x05-0xFF are reserved */
};

//===========================================================================================================================
//	OBEXPutTags
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXSessionTags =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXSessionParameterTags
	@abstract	Tags for SessionParameters.
*/

enum OBEXSessionParameterTags
{
	kOBEXSessionParameterTagDeviceAddress					= 0x00,
	kOBEXSessionParameterTagNonce							= 0x01,
	kOBEXSessionParameterTagSessionID						= 0x02,
	kOBEXSessionParameterTagNextSequenceNumber				= 0x03,
	kOBEXSessionParameterTagTimeout							= 0x04,
	kOBEXSessionParameterTagSessionOpcode					= 0x05

};

//===========================================================================================================================
//	OBEXVersions
//===========================================================================================================================

#if 0
#pragma mark ======= OBEXVersions =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXVersions
	@abstract	The available/supported OBEX versions.
*/

enum OBEXVersions
{
	kOBEXVersion10									= 0x10,
};

//===========================================================================================================================
//	OBEX Types
//===========================================================================================================================

#if 0
#pragma mark ======= OBEX Types =======
#endif


typedef	uint8_t		OBEXHeaderIdentifier;			
typedef	uint8_t		OBEXVersion;			
typedef	uint8_t		OBEXFlags;			
typedef	uint8_t		OBEXOpCode;			
typedef	uint8_t		OBEXConstants;			
typedef	uint16_t	OBEXMaxPacketLength;			

typedef	struct OpaqueOBEXSessionRef *	OBEXSessionRef;


//===========================================================================================================================
//	OBEX Session Types
//===========================================================================================================================

#if 0
#pragma mark -
#pragma mark ======= Client Session Types =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXConnectCommandResponseData
	@discussion	Part of the OBEXSessionEvent structure. Is readable when the event is of type
				kOBEXSessionEventTypeConnectCommandResponseReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXConnectCommandResponseData			OBEXConnectCommandResponseData;
struct OBEXConnectCommandResponseData
{
	OBEXOpCode			serverResponseOpCode;
	void* 				headerDataPtr;
	size_t 				headerDataLength;
	OBEXMaxPacketLength	maxPacketSize;
	OBEXVersion			version;
	OBEXFlags			flags;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXDisconnectCommandResponseData	Part of the OBEXSessionEvent structure. Is readable when the event is
													of type kOBEXSessionEventTypeDisconnectCommandResponseReceived (see
													OBEXSessionEventTypes).
*/

typedef struct	OBEXDisconnectCommandResponseData		OBEXDisconnectCommandResponseData;
struct OBEXDisconnectCommandResponseData
{
	OBEXOpCode			serverResponseOpCode;
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXPutCommandResponseData	Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypePutCommandResponseReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXPutCommandResponseData				OBEXPutCommandResponseData;
struct OBEXPutCommandResponseData
{
	OBEXOpCode			serverResponseOpCode;
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXGetCommandResponseData	Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypeGetCommandResponseReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXGetCommandResponseData				OBEXGetCommandResponseData;
struct OBEXGetCommandResponseData
{
	OBEXOpCode			serverResponseOpCode;
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXSetPathCommandResponseData	Part of the OBEXSessionEvent structure. Is readable when the event is
												of type kOBEXSessionEventTypeSetPathCommandResponseReceived (see
												OBEXSessionEventTypes).
*/

typedef struct	OBEXSetPathCommandResponseData			OBEXSetPathCommandResponseData;
struct OBEXSetPathCommandResponseData
{
	OBEXOpCode			serverResponseOpCode;
	void* 				headerDataPtr;
	size_t 				headerDataLength;
	OBEXFlags			flags;
	OBEXConstants		constants;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXAbortCommandResponseData	Part of the OBEXSessionEvent structure. Is readable when the event is
												of type kOBEXSessionEventTypeAbortCommandResponseReceived (see
												OBEXSessionEventTypes).
*/

typedef struct	OBEXAbortCommandResponseData			OBEXAbortCommandResponseData;
struct OBEXAbortCommandResponseData
{
	OBEXOpCode			serverResponseOpCode;
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};


//===========================================================================================================================
//	Server Session Types
//===========================================================================================================================

#if 0
#pragma mark -
#pragma mark ======= Server Session Types =======
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXConnectCommandData	Part of the OBEXSessionEvent structure. Is readable when the event is
										of type kOBEXSessionEventTypeConnectCommandReceived (see
										OBEXSessionEventTypes).
*/

typedef struct	OBEXConnectCommandData			OBEXConnectCommandData;
struct OBEXConnectCommandData
{
	void* 				headerDataPtr;
	size_t 				headerDataLength;
	OBEXMaxPacketLength	maxPacketSize;
	OBEXVersion			version;
	OBEXFlags			flags;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXDisconnectCommandData	Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypeDisconnectCommandReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXDisconnectCommandData		OBEXDisconnectCommandData;
struct OBEXDisconnectCommandData
{
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXPutCommandData			Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypePutCommandReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXPutCommandData				OBEXPutCommandData;
struct OBEXPutCommandData
{
	void* 				headerDataPtr;
	size_t 				headerDataLength;
	size_t				bodyDataLeftToSend;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXGetCommandData			Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypeGetCommandReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXGetCommandData				OBEXGetCommandData;
struct OBEXGetCommandData
{
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXSetPathCommandData		Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypeSetPathCommandReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXSetPathCommandData			OBEXSetPathCommandData;
struct OBEXSetPathCommandData
{
	void* 				headerDataPtr;
	size_t 				headerDataLength;
	OBEXFlags			flags;
	OBEXConstants		constants;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXAbortCommandData		Part of the OBEXSessionEvent structure. Is readable when the event is
											of type kOBEXSessionEventTypeAbortCommandReceived (see OBEXSessionEventTypes).
*/

typedef struct	OBEXAbortCommandData			OBEXAbortCommandData;
struct OBEXAbortCommandData
{
	void* 				headerDataPtr;
	size_t 				headerDataLength;
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXErrorData		Part of the OBEXSessionEvent structure. Is readable when the event is
									of type kOBEXSessionEventTypeError (see OBEXSessionEventTypes).
*/

typedef struct	OBEXErrorData		OBEXErrorData;
struct OBEXErrorData
{
	OBEXError			error;
	void*				dataPtr;			// If data was associated with the error, it will be included here if possible.
	size_t				dataLength;			// Check the size to see if there is data to be examined.
};


#if 0
#pragma mark -
#pragma mark ======= OBEXSessionEventTypes =======
#endif


//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXSessionEventTypes
	@abstract	When a new session event occurs, your selector (or C callback) will be given an OBEXSessionEvent pointer,
				and in it will be a 'type' field with one of the following types in it. Based on that type, you can then
				read the corresponding field in the union to get out interesting data for that event type. For example,
				if the type of an event is a 'kOBEXSessionEventTypeConnectCommandResponseReceived', you should look in
				the 'OBEXConnectCommandResponseData' part of the structure's union to find more information pased to you
				in the event. Note that some you will never see, depending on the type of session you are using - a client
				or server. If you are a client (most likely case), you will never see the "Command" events, but instead
				you will only receive the "CommandResponse" events since you will be the issuer oft he commands, not the
				receiver of them. Both types of sessions will receive error type events.
*/

enum OBEXSessionEventTypes
{
	// Client event types.

	kOBEXSessionEventTypeConnectCommandResponseReceived		= 'OCEC',
	kOBEXSessionEventTypeDisconnectCommandResponseReceived 	= 'OCED',
	kOBEXSessionEventTypePutCommandResponseReceived			= 'OCEP',
	kOBEXSessionEventTypeGetCommandResponseReceived			= 'OCEG',
	kOBEXSessionEventTypeSetPathCommandResponseReceived		= 'OCES',
	kOBEXSessionEventTypeAbortCommandResponseReceived		= 'OCEA',
	
	// Server event types.
	
	kOBEXSessionEventTypeConnectCommandReceived				= 'OSEC',
	kOBEXSessionEventTypeDisconnectCommandReceived 			= 'OSED',
	kOBEXSessionEventTypePutCommandReceived					= 'OSEP',
	kOBEXSessionEventTypeGetCommandReceived					= 'OSEG',
	kOBEXSessionEventTypeSetPathCommandReceived				= 'OSES',
	kOBEXSessionEventTypeAbortCommandReceived				= 'OSEA',
	
	// Shared (Server/client) event types.
	
	kOBEXSessionEventTypeError								= 'OGEE',
};

typedef uint32_t	OBEXSessionEventType;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXSessionEvent
	@abstract	When a new session event occurs, your selector (or C callback) will be given an OBEXSessionEvent pointer,
				and in it will be information you might find interesting so that you can then reply back appropriately.
				For example, of you receive a kOBEXSessionEventTypeConnectCommandResponseReceived event, you can then
				parse out the information related to that event, and if all looks well to you, you could them send a
				"Get" command to get a file off of the OBEX server you just connected to.
*/

typedef struct OBEXSessionEvent				OBEXSessionEvent;
struct OBEXSessionEvent
{
	OBEXSessionEventType	type;
	OBEXSessionRef			session;
	void*					refCon;
	Boolean					isEndOfEventData;
	void*					reserved1;
	void*					reserved2;
	union
	{
		// Client session events.
		
		OBEXConnectCommandResponseData			connectCommandResponseData;
		OBEXDisconnectCommandResponseData		disconnectCommandResponseData;
		OBEXPutCommandResponseData				putCommandResponseData;
		OBEXGetCommandResponseData				getCommandResponseData;
		OBEXSetPathCommandResponseData			setPathCommandResponseData;
		OBEXAbortCommandResponseData			abortCommandResponseData;
		
		// Server session events.
		
		OBEXConnectCommandData					connectCommandData;
		OBEXDisconnectCommandData				disconnectCommandData;
		OBEXPutCommandData						putCommandData;
		OBEXGetCommandData						getCommandData;
		OBEXSetPathCommandData					setPathCommandData;
		OBEXAbortCommandData					abortCommandData;
		
		// Client & Server Session events.
		
		OBEXErrorData							errorData;
	} u;
};

// C API OBEXSessionEvent callback.

typedef	void	(*OBEXSessionEventCallback)	( const OBEXSessionEvent * inEvent );


#if 0
#pragma mark -
#pragma mark ======= Session Destroyers/Accessors =======
#endif

//===========================================================================================================================
//	Session Destroyers/Accessors
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionDelete
	@abstract	Destroy an OBEX session. If connections are open, they will (eventually) be terminated for you.
	@param		inSessionRef	A valid service reference.
	@result		An error code value. 0 if successful.
	@discussion	
				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionDelete( OBEXSessionRef inSessionRef )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionHasOpenOBEXConnection
	@abstract	Allows you to test the session for an open OBEX connection for a particular session.
	@param		inSessionRef	A valid session reference.
	@param		outIsConnected	A valid ptr to an OBEXSessionRef; will contain the newly created session if return
								value is kOBEXSuccess.
	@result		An error code value. 0 if successful.
	@discussion	This method will return true only if (a) you are transport-connected to another OBEX target and
				(b) an OBEX Connect command has been issued and received successfully.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionHasOpenOBEXConnection(	OBEXSessionRef	inSessionRef,
												Boolean *		outIsConnected )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionGetMaxPacketLength
	@abstract	Gets current max packet length.
	@param		inSessionRef	A valid session reference.
	@param		outLength		Max packet length.
	@result		An error code value. 0 if successful.
	@discussion	This value *could* change before and after a connect command has been sent or a connect
				command response has been received, since the recipient could negotiate a lower max packet size.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionGetMaxPacketLength( OBEXSessionRef inSessionRef, OBEXMaxPacketLength * outLength )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionGetAvailableCommandPayloadLength
	@abstract	Gets space available for your data for a particular command you are trying to send.
	@param		inSessionRef	A valid session reference.
	@param		inOpCode		An opcode of what command you are trying to send.
	@param		outLength		Space available for your header data in the payload area for a particular command. 
	@result		An error code value. 0 if successful.
	@discussion	The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format,
				allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting
				and datas requires a small bit of information that varies depending on what command or response you are
				sending. Thus, you should call this function to find out how much space will be left for your headers
				before you send the command, allowing you to properly chop up your headers before sending them. This will
				guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error
				trying to send too much information at once.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionGetAvailableCommandPayloadLength( OBEXSessionRef inSessionRef, OBEXOpCode inOpCode, OBEXMaxPacketLength * outLength )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionGetAvailableCommandResponsePayloadLength
	@abstract	Gets space available for your data for a particular command response you are trying to send.
	@param		inSessionRef	A valid session reference.
	@param		inOpCode		A command opcode that you are responding to. For example, if you receiving a Put command,
								and want to send back a "bad request" response, you should still pass in the Put command
								opcode for that response.
	@param		outLength		Space available for your header data in the payload area for a particular command. 
	@result		An error code value. 0 if successful.
	@discussion	The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format,
				allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting
				and datas requires a small bit of information that varies depending on what command or response you are
				sending. Thus, you should call this function to find out how much space will be left for your headers
				before you send the command, allowing you to properly chop up your headers before sending them. This will
				guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error
				trying to send too much information at once.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionGetAvailableCommandResponsePayloadLength( OBEXSessionRef inSessionRef, OBEXOpCode inOpCode, OBEXMaxPacketLength * outLength )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

#if 0
#pragma mark -
#pragma mark ======= Client Session API =======
#endif

//===========================================================================================================================
//	Client Session API
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionConnect
	@abstract	Establishes an OBEX connection to the target device for the session. If a transport connection is not
				open yet, it will be opened if possible.
	@param		inSessionRef			A valid session reference.
	@param		inFlags					Flags, as defined in the OBEX spec for this command.
	@param		inMaxPacketLength		Maximum packet length you wish to allow. May be negiotiated with host to be less
										or more than you specify.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback parameter will
				result in an error. If you have already established an OBEX connection and you call this again you will
				get an 'kOBEXSessionAlreadyConnectedError' as a result.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionConnect(	OBEXSessionRef	inSessionRef,
								OBEXFlags					inFlags,
								OBEXMaxPacketLength			inMaxPacketLength,
								void* 						inOptionalHeaders,
								size_t						inOptionalHeadersLength,
								OBEXSessionEventCallback	inCallback,
								void *						inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;
											
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionDisconnect
	@abstract	Send a disconnect command to a remote OBEX server.
	@param		inSessionRef			A valid session reference.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionDisconnect(	OBEXSessionRef					inSessionRef,
									void*	 						inOptionalHeaders,
									size_t							inOptionalHeadersLength,
									OBEXSessionEventCallback		inCallback,
									void *							inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionPut
	@abstract	Send a put command to a remote OBEX server.
	@param		inSessionRef		A valid session reference.
	@param		inIsFinalChunk		TRUE or FALSE - is this the last chunk of header data for this PUT.
	@param		inHeadersData		Headers containing data to PUT. Don't include your body header data here.
	@param		inHeadersDataLength	Size of header data. Don't include your body header data here.
	@param		inBodyData			Data for the BODY header to PUT. DO NOT package your data in an actual BODY header,
									this will be done for you, based on the finalChunk flag you pass in above (since based on
									this flag the header ID will be either a BODY or ENDOFBODY header).
	@param		inBodyDataLength	Size of Data for the BODY header to PUT.
	@param		inCallback			A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon		Optional parameter; can contain anything you wish. Will be returned in your callback
									just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionPut(	OBEXSessionRef					inSessionRef,
							Boolean							inIsFinalChunk,
							void* 							inHeadersData,
							size_t							inHeadersDataLength,
							void* 							inBodyData,
							size_t							inBodyDataLength,
							OBEXSessionEventCallback		inCallback,
							void *							inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;
										
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionGet
	@abstract	Send a get command to a remote OBEX server.
	@param		inSessionRef		A valid session reference.
	@param		inIsFinalChunk		TRUE or FALSE - is this the last chunk of header data for this GET.
	@param		inHeadersData		Headers containing data to GET.
	@param		inHeadersDataLength	Size of header data.
	@param		inCallback			A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon		Optional parameter; can contain anything you wish. Will be returned in your callback
								just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionGet(	OBEXSessionRef				inSessionRef,
							Boolean						inIsFinalChunk,
							void* 						inHeadersData,
							size_t						inHeadersDataLength,
							OBEXSessionEventCallback	inCallback,
							void*						inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;
										
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionAbort
	@abstract	Send an abort command to a remote OBEX server.
	@param		inSessionRef			A valid session reference.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionAbort(	OBEXSessionRef				inSessionRef,
								void* 						inOptionalHeaders,
								size_t						inOptionalHeadersLength,
								OBEXSessionEventCallback	inCallback,
								void *						inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;
											
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionSetPath
	@abstract	Send a set path command to a remote OBEX server.
	@param		inSessionRef			A valid session reference.
	@param		inFlags					Flags, as defined in the OBEX spec for this command.
	@param		inConstants				Constants, as defined in the OBEX spec for this command.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionSetPath(	OBEXSessionRef				inSessionRef,
								OBEXFlags					inFlags,
								OBEXConstants				inConstants,
								void* 						inOptionalHeaders,
								size_t						inOptionalHeadersLength,
								OBEXSessionEventCallback	inCallback,
								void*						inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

#if 0
#pragma mark -
#pragma mark ======= Server Session API =======
#endif

//===========================================================================================================================
//	Server Session API
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionConnectResponse
	@abstract	Send a response to a connect command to the remote client.
	@param		inSessionRef			A valid session reference.
	@param		inResponseOpCode		What response code you want to send to the remote client.
	@param		inFlags					Flags, as defined in the OBEX spec for this command.
	@param		inMaxPacketLength		Max packet length you want to support. Must be smaller or equal to the max packet
										length specified by the remote client. 
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionConnectResponse(	OBEXSessionRef						inSessionRef,
										OBEXOpCode							inResponseOpCode,
										OBEXFlags							inFlags,
										OBEXMaxPacketLength					inMaxPacketLength,
										void* 								inOptionalHeaders,
										size_t								inOptionalHeadersLength,
										OBEXSessionEventCallback			inCallback,
										void *								inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionDisconnectResponse
	@abstract	Send a response to a disconnect command to the remote client.
	@param		inSessionRef			A valid session reference.
	@param		inResponseOpCode		What response code you want to send to the remote client.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/
										
OBEXError	OBEXSessionDisconnectResponse(	OBEXSessionRef							inSessionRef,
											OBEXOpCode								inResponseOpCode,
											void* 									inOptionalHeaders,
											size_t									inOptionalHeadersLength,
											OBEXSessionEventCallback				inCallback,
											void *									inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;
											
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionGetResponse
	@abstract	Send a response to a get command to the remote client.
	@param		inSessionRef			A valid session reference.
	@param		inResponseOpCode		What response code you want to send to the remote client.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/
	
OBEXError	OBEXSessionGetResponse(	OBEXSessionRef						inSessionRef,
									OBEXOpCode							inResponseOpCode,
									void* 								inOptionalHeaders,
									size_t								inOptionalHeadersLength,
									OBEXSessionEventCallback			inCallback,
									void *								inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionPutResponse
	@abstract	Send a response to a put command to the remote client.
	@param		inSessionRef			A valid session reference.
	@param		inResponseOpCode		What response code you want to send to the remote client.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/
	
OBEXError	OBEXSessionPutResponse(	OBEXSessionRef						inSessionRef,
									OBEXOpCode							inResponseOpCode,
									void* 								inOptionalHeaders,
									size_t								inOptionalHeadersLength,
									OBEXSessionEventCallback			inCallback,
									void *								inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionAbortResponse
	@abstract	Send a response to a abort command to the remote client.
	@param		inSessionRef			A valid session reference.
	@param		inResponseOpCode		What response code you want to send to the remote client.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionAbortResponse(	OBEXSessionRef						inSessionRef,
										OBEXOpCode							inResponseOpCode,
										void* 								inOptionalHeaders,
										size_t								inOptionalHeadersLength,
										OBEXSessionEventCallback			inCallback,
										void *								inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;		

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionSetPathResponse
	@abstract	Send a response to a set path command to the remote client.
	@param		inSessionRef			A valid session reference.
	@param		inResponseOpCode		What response code you want to send to the remote client.
	@param		inOptionalHeaders		Ptr to optional headers you can supply to the command. DO NOT dispose of this
										pointer until you callback is called with a success.
	@param		inOptionalHeadersLength	Size of data at the specified ptr.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
				result in an error.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionSetPathResponse(	OBEXSessionRef						inSessionRef,
										OBEXOpCode							inResponseOpCode,
										void* 								inOptionalHeaders,
										size_t								inOptionalHeadersLength,
										OBEXSessionEventCallback			inCallback,
										void *								inUserRefCon )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionSetServerCallback
	@param		inSessionRef			A valid session reference.
	@param		inCallback				A valid callback. Will be called for progress, errors and completion by server
										sessions only.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	Sets callback to be used when an event occurs on an OBEXSession. This is important for OBEX servers, as you
				will need a way to be called back when the first command is sent to you. So, be sure to set yourself
				up to listen for events when you are ready to receive them.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	OBEXSessionSetServerCallback(	OBEXSessionRef						inSessionRef,
											OBEXSessionEventCallback			inCallback,
											void *								inUserRefCon	)	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;


#if 0
#pragma mark -
#pragma mark ======= Utilities API =======
#endif

// vCard charsets

#define		kCharsetStringISO88591			"CHARSET=ISO-8859-1"
#define		kCharsetStringUTF8				"UTF-8"

// vEvent encodings

#define		kEncodingStringQuotedPrintable	"QUOTED-PRINTABLE"
#define		kEncodingStringBase64			"BASE-64"
#define		kEncodingString8Bit				"8BIT"

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXCreateVCard
	@abstract	Creates a formatted vCard, ready to be sent over OBEX or whatever.
	@param		inNameCharset					A pointer to the charset data used for the name. Pass in a #defined charset
												for ease of use.
	@param		inNameCharsetLength				Length of name charset assed in above.
	@param		inFirstName						Pointer to data with Person's first name.
	@param		inFirstNameLength				Length of Person's first name passed in above.
	@param		inLastName						Pointer to data with Person's last name.
	@param		inLastNameLength				Length of Person's last name passed in above.
	@param		inFriendlyName					Pointer to data with Person's Friendly name.
	@param		inFriendlyNameLength			Length of Person's Friendly name passed in above.
	@param		inHomePhone						Pointer to data with Person's Home phone number.
	@param		inHomePhoneLength				Length of Person's Home phone number passed in above.
	@param		inWorkPhone						Work phone number.
	@param		inWorkPhoneLength				Length of Person's Work phone number passed in above.
	@param		inCellPhone						Cell phone number.
	@param		inCellPhoneLength				Length of Person's Cell phone number passed in above.
	@param		inFaxPhone						Fax phone number.
	@param		inFaxPhoneLength				Length of Person's Fax phone number passed in above.
	@param		inEMailAddress					EMailAddress of person.
	@param		inEMailAddressLength			Length of Person's EMailAddress passed in above.
	@param		inEMailAddressCharset			Charset of EMailAddress of person.
	@param		inEMailAddressCharsetLength		Length of Person's EMailAddress charset passed in above.
	@param		inOrganization					Pointer to Organization/business data.
	@param		inOrganizationLength			Length of Organization/business data.
	@param		inOrganizationCharset			Pointer to the charset the Organization/business is in.
	@param		inOrganizationCharsetLength		Length of data for the Organization/business charset.
	@param		inTitle							Pointer to data with Title of person in biz/org.
	@param		inTitleLength					Length of Title of person in biz/org.
	@param		inOrganizationCharset			Pointer to the charset the Title is in.
	@param		inOrganizationCharsetLength		Length of data for the Title charset.
	@result		An CFDataRef containing the compiled data. nil if we failed.
	@discussion	All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

CFDataRef	OBEXCreateVCard(	const void *	inFirstName,
							uint32_t		inFirstNameLength,
							const void *	inLastName,
							uint32_t		inLastNameLength,
							const void *	inFriendlyName,
							uint32_t		inFriendlyNameLength,
							const void *	inNameCharset,
							uint32_t		inNameCharsetLength,
							const void *	inHomePhone,
							uint32_t		inHomePhoneLength,
							const void *	inWorkPhone,
							uint32_t		inWorkPhoneLength,
							const void *	inCellPhone,
							uint32_t		inCellPhoneLength,
							const void *	inFaxPhone,
							uint32_t		inFaxPhoneLength,
							const void *	inEMailAddress,
							uint32_t		inEMailAddressLength,
							const void *	inEMailAddressCharset,
							uint32_t		inEMailAddressCharsetLength,
							const void *	inOrganization,
							uint32_t		inOrganizationLength,
							const void *	inOrganizationCharset,
							uint32_t		inOrganizationCharsetLength,
							const void *	inTitle,
							uint32_t		inTitleLength,
							const void *	inTitleCharset,
							uint32_t		inTitleCharsetLength	)	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXCreateVEvent
	@abstract	Creates a formatted vEvent, ready to be sent over OBEX or whatever. You probably will embed the output
				in a vCalendar event.
	@param		inCharset			The Charset the passed data is in. Pass in a #defined charset for ease of use.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inEncoding			The encoding of the summary and location fields.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inEventStartDate	Start of event date, in the (ISO8601) format: YYYYMMDDTHHMMSS. e.g. 19960415T083000 = 8:30 am on April 15, 1996. All time values should be in LOCAL time.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inEventEndDate		End of event date.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inAlarmDate			Date of Alarm for event, in the format: YYYYMMDDTHHMMSS.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inCategory			Category of event, such as "MEETING" or "PHONE CALL".
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inSummary			Summary of event. Max length is 36 bytes. Longer will result in a bad argument error.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inLocation			Summary of event. Max length is 20 bytes. Longer will result in a bad argument error.
	@param		inCharsetLength		The length of the Charset passed data.
	@param		inXIRMCLUID			The IRMC Local Unique Identifier Label, max length 12 bytes. Longer will result in
									a bad argument error.
	@param		inCharsetLength		The length of the Charset passed data.
	@result		A valid CFDataRef - nil if we failed.
	@discussion	All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.
				Be aware that certain devices such as Ericsson phones MUST have certain fields, such as a start and end date.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

CFDataRef		OBEXCreateVEvent(	const char *	inCharset,
								uint32_t		inCharsetLength,
								const char *	inEncoding,
								uint32_t		inEncodingLength,
								const char *	inEventStartDate,
								uint32_t		inEventStartDateLength,
								const char *	inEventEndDate,
								uint32_t		inEventEndDateLength,
								const char *	inAlarmDate,
								uint32_t		inAlarmDateLength,
								const char *	inCategory,
								uint32_t		inCategoryLength,
								const char *	inSummary,
								uint32_t		inSummaryLength,
								const char *	inLocation,
								uint32_t		inLocationLength,
								const char *	inXIRMCLUID,
								uint32_t		inXIRMCLUIDLength			)	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;



#pragma mark -
#pragma mark ======= Header Contruction Kit =======

/*
	Header Contruction Kit
	
	You can use the following functions to ease the burden of creating your properly formatted OBEX headers.
	Generally, the strategy is either you will have a ptr to some data full of headers, and you
	can use OBEXGetHeaders to get you a easily-accessed CFDictionary (or NSDictionary) full of headers and
	use the keys below to obtain the actual header values. Conversely, you can create a CFDictionary full
	of headers using the OBEXAddXXXXXHeader() functions, and then pass this to an OBEX command using the
	OBEXHeadersToBytes( headerDictionary ) function to get the raw bytes.
*/

//---------------------------------------------------------------------------------------------------------------------------
/*
	These are defined keys to assist in locating headers in the dictionary of headers returned from the OBEXGetHeaders()
	function, described below.
*/

extern CFStringRef	kOBEXHeaderIDKeyName;
extern CFStringRef	kOBEXHeaderIDKeyType;
extern CFStringRef	kOBEXHeaderIDKeyDescription;
extern CFStringRef	kOBEXHeaderIDKeyTimeISO;
extern CFStringRef	kOBEXHeaderIDKeyTime4Byte;
extern CFStringRef	kOBEXHeaderIDKeyTarget;
extern CFStringRef	kOBEXHeaderIDKeyHTTP;
extern CFStringRef	kOBEXHeaderIDKeyBody;
extern CFStringRef	kOBEXHeaderIDKeyEndOfBody;
extern CFStringRef	kOBEXHeaderIDKeyWho;
extern CFStringRef	kOBEXHeaderIDKeyAppParameters;
extern CFStringRef	kOBEXHeaderIDKeyAuthorizationChallenge;
extern CFStringRef	kOBEXHeaderIDKeyAuthorizationResponse;
extern CFStringRef	kOBEXHeaderIDKeyObjectClass;
extern CFStringRef	kOBEXHeaderIDKeyCount;
extern CFStringRef	kOBEXHeaderIDKeyLength;
extern CFStringRef	kOBEXHeaderIDKeyConnectionID;
extern CFStringRef	kOBEXHeaderIDKeyByteSequence;
extern CFStringRef	kOBEXHeaderIDKeyUnknownUnicodeText;
extern CFStringRef	kOBEXHeaderIDKeyUnknownByteSequence;
extern CFStringRef	kOBEXHeaderIDKeyUnknown1ByteQuantity;
extern CFStringRef	kOBEXHeaderIDKeyUnknown4ByteQuantity;
extern CFStringRef	kOBEXHeaderIDKeyUserDefined;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXGetHeaders
	@abstract		Take a data blob and looks for OBEX headers.
	@param			inData			The data chunk with the headers you are interested in.
	@param			inDataSize		The size of the buffer you are passing in.
	@result			A CFDictionary with the headers found in the data blob inside it.
	@discussion
	You should use this when your callback for PUTs, GETs, etc. give you a data chunk
	and a size. Pass these params to this function and you will receive a dictionary
	back full of the parse headers. You can use the CFDictionary calls to get objects
	out of it, based on the header keys defined above. You are responsible for releasing
	the CFDictionary returned to you.
	Example usage:
	<pre>
	CFDictionaryRef   dictionary = OBEXGetHeaders( data, dataLength );
	if( dictionary )
	{
		if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyName ) > 0 )
		{			
			CFStringRef theStringRef;
			
			theStringRef = (CFStringRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyName );
			if( theStringRef )
			{				
				// Display it, use it as a filename, whatever.
			}
		}
		
		if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyConnectionID ) > 0 )
		{
			CFDataRef theDataRef;
			
			theDataRef = (CFDataRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyConnectionID );
			if( theDataRef )
			{
				// now we have data representing the connection ID.
			}
		}
		
		CFRelease( dictionary );
	}
	</pre>
*/

CFDictionaryRef OBEXGetHeaders( const void* inData, size_t inDataSize ) CF_RETURNS_RETAINED;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXHeadersToBytes
	@abstract		Converts a dictionary of headers to a data pointer, from which you can extract as bytes and pass to
					the OBEX command/response functions.
	@param			dictionaryOfHeaders		dictionary that you have added headers to with the above OBEXAddXXXHeader functions.		
	@result			Mutable data ref containing the bytes of all headers.
	@discussion		Returns a CFMutableDataRef containing all the header data found in the dictionary, formatted according to
					the OBEX/IrMC spec. YOU MUST RELEASE IT when you are finished with it (ie. when the OBEX request is complete).
					All OBEX-specification defined headers are supported and should be returned to the dictionary. Use the
					keys defined above to get headers from dictionary. Example usage:
	<pre>
	Example usage:

	CFMutableDictionaryRef	dictionary;
	CFMutableDataRef		mGetHeadersDataRef;
	uint8_t* 				headerDataPtr;
	uint32_t 				headerDataLength;
	
	dictionary = CFDictionaryCreateMutable( kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks );
	
	// Package up desired headers.

	OBEXAddTypeHeader( CFSTR( "text/x-vCard" ), dictionary ); 

	mGetHeadersDataRef = OBEXHeadersToBytes( dictionary );

	headerDataPtr = CFDataGetBytePtr( mGetHeadersDataRef );
	headerDataLength = CFDataGetLength( mGetHeadersDataRef );
	
	// From here I can pass it to any OBEX command, such as OBEXPut...
	</pre>
					
*/

CFMutableDataRef OBEXHeadersToBytes( CFDictionaryRef dictionaryOfHeaders );

#pragma mark -

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddNameHeader
	@abstract		Add a CFStringRef to a dictionary of OBEXheaders.
	@param			name		name you want to add to the OBEX header dictionary.			
	@param			dictRef		dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Name header - OBEX Spec, 2.2.2: (2-byte) Null terminated unicode string.
*/

OBEXError OBEXAddNameHeader(	CFStringRef				name,
								CFMutableDictionaryRef	dictRef );
							
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddDescriptionHeader
	@abstract		Add a CFStringRef to a dictionary of OBEXheaders.
	@param			description		Description you want to add to the OBEX header dictionary.			
	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Description header - OBEX Spec, 2.2.6: (2-byte) Null terminated unicode string.
*/

OBEXError OBEXAddDescriptionHeader(	CFStringRef				description,
									CFMutableDictionaryRef	dictRef );
									
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddCountHeader
	@abstract		Add a CFStringRef to a dictionary of OBEXheaders.
	@param			count		Count value you want to add to the OBEX header dictionary.			
	@param			dictRef		dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Count header - OBEX Spec, 2.2.1: 4 byte unsigned integer
*/

OBEXError OBEXAddCountHeader(	uint32_t				count,
								CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddTime4ByteHeader
	@abstract		Add a CFStringRef to a dictionary of OBEXheaders.
	@param			time4Byte		4-byte time value you want to add to the OBEX header dictionary.			
	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Time4Byte headers - OBEX Spec, 2.2.5: 4 Bytes
*/

OBEXError OBEXAddTime4ByteHeader(	uint32_t				time4Byte,
									CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddLengthHeader
	@abstract		Add a CFStringRef to a dictionary of OBEXheaders.
	@param			length			Value of Length header you want to add to the OBEX header dictionary.			
	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Length header - OBEX Spec, 2.2.4: 4 byte unsigned integer
*/

OBEXError OBEXAddLengthHeader(	uint32_t				length,
								CFMutableDictionaryRef	dictRef );
								
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddTypeHeader
	@abstract		Add a CFStringRef to a dictionary of OBEXheaders.
	@param			type			String containing the type of header to add.
 	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Type header - OBEX Spec, 2.2.3: 1-byte Null terminated ascii string.
*/

OBEXError OBEXAddTypeHeader(	CFStringRef				type,
								CFMutableDictionaryRef	dictRef );
							
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddTimeISOHeader
	@abstract		Add bytes to a dictionary of OBEXheaders.
	@param			inHeaderData		Time ISO 8601 header data, local times in format YYYYMMDDTHHMMSS and UTC in the format YYYYMMDDTHHMMSSZ.
	@param			inHeaderDataLength	Length of header data.
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		TimeISO header - OBEX Spec, 2.2.5: Byte Sequence
*/

OBEXError OBEXAddTimeISOHeader(	const void*				inHeaderData,
								uint32_t				inHeaderDataLength,
								CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddTargetHeader
	@abstract		Add bytes of data to a dictionary of OBEXheaders.
	@param			inHeaderData		Target header data.			
	@param			inHeaderDataLength	Length of Target header data.
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Target header - OBEX Spec, 2.2.7: Byte Sequence
*/

OBEXError OBEXAddTargetHeader(	const void*				inHeaderData,
								uint32_t				inHeaderDataLength,
								CFMutableDictionaryRef	dictRef );
								
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddHTTPHeader
	@abstract		Add bytes of data to a dictionary of OBEXheaders.
	@param			inHeaderData		HTTP header data.			
	@param			inHeaderDataLength	Length of HTTP header data.
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		HTTP header - OBEX Spec, 2.2.8: Byte Sequence
*/

OBEXError OBEXAddHTTPHeader(	const void*				inHeaderData,
								uint32_t				inHeaderDataLength,
								CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddBodyHeader
	@abstract		Add bytes of data to a dictionary of OBEXheaders.
	@param			inHeaderData		Body header data.			
	@param			inHeaderDataLength	Length of Body header data.
	@param			isEndOfBody			Set this flag if you want an end of body header instead of a body header.
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Body,EndOfBody headers - OBEX Spec, 2.2.9: Byte Sequence
*/
							
OBEXError OBEXAddBodyHeader(	const void*				inHeaderData,
								uint32_t				inHeaderDataLength,
								Boolean					isEndOfBody,
								CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddWhoHeader
	@abstract		Add bytes of data to a dictionary of OBEXheaders.
	@param			inHeaderData		Who header data.			
	@param			inHeaderDataLength	Length of Who header data.	
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Who headers - OBEX Spec, 2.2.10: Byte Sequence
*/

OBEXError OBEXAddWhoHeader(	const void*				inHeaderData,
							uint32_t				inHeaderDataLength,
							CFMutableDictionaryRef	dictRef );
							
//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddConnectionIDHeader
	@abstract		Add bytes representing a connection ID to a dictionary of OBEX headers.
	@param			inHeaderData		Connection ID data. Should be 4 bytes in length only.
	@param			inHeaderDataLength	Length of Connection ID data. This should ONLY be set to equal 4.		
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		ConnectionID headers - OBEX Spec, 2.2.10: Byte Sequence
					
					*** IMPORTANT NOTE: In bluetooth 1.0, using this function will allow you to pass in any value.
										You should not pass more than 4 bytes ever. In later releases, if the length
										passed is not 4, a kOBEXBadArgumentError error will be returned. ***
*/

OBEXError OBEXAddConnectionIDHeader(	const void*				inHeaderData,
										uint32_t				inHeaderDataLength,
										CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddApplicationParameterHeader
	@abstract		Add bytes representing an application parameter to a dictionary of OBEX headers.
	@param			inHeaderData		Application parameter data - should be tag/length/value triplets.
	@param			inHeaderDataLength	Length of application parameter data.		
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Application Request/Response Parameter headers - OBEX Spec, 2.2.11: Byte Sequence
*/

OBEXError OBEXAddApplicationParameterHeader(	const void*				inHeaderData,
												uint32_t				inHeaderDataLength,
												CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddByteSequenceHeader
	@abstract		Add a byte sequence header to a dictionary of OBEXheaders.
	@param			inHeaderData		bytes you want to put in the byte sequence header.			
	@param			inHeaderDataLength	length of the bytes you want to put in the byte sequence header.			
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Byte Sequence header - OBEX Spec, 2.2.5: Byte sequence. One thing of important note here - since we
					don't know what Header Identifier and length you intend to use here, you MUST include your own
					identifier and length in the data you pass. Thus, your data must be in this format:
						<1:HI><2:LENGTH><n:(<TAG><LENGTH><VALUE>)>
					Also, note that LENGTH = (3 + n), (1 for HI, 2 for the 2 bytes of length information, plus your n bytes of custom data).
					Be careful here to not mess up these values, as it could adversely affect the ability of the remote-device's headers parser.
*/

OBEXError OBEXAddByteSequenceHeader(	const void*				inHeaderData,
										uint32_t				inHeaderDataLength,
										CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddObjectClassHeader
	@abstract		Add an object class header to a dictionary of OBEXheaders.
	@param			inHeaderData		bytes you want to put in the object class header.			
	@param			inHeaderDataLength	length of the bytes you want to put in the object class header.			
	@param			dictRef				dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Object Class header - OBEX Spec, 2.2.15: Byte sequence.
*/

OBEXError OBEXAddObjectClassHeader(	const void*				inHeaderData,
									uint32_t				inHeaderDataLength,
									CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddAuthorizationChallengeHeader
	@abstract		Add an authorization challenge header to a dictionary of OBEXheaders.
	@param			inHeaderData		bytes you want to put in the authorization challenge header.			
	@param			inHeaderDataLength	length of the bytes you want to put in authorization challenge header.			
	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Authorization Challenge header - OBEX Spec, 2.2.13: Authorization Challenge.
*/

OBEXError OBEXAddAuthorizationChallengeHeader(	const void*				inHeaderData,
												uint32_t				inHeaderDataLength,
												CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddAuthorizationResponseHeader
	@abstract		Add an authorization Response header to a dictionary of OBEXheaders.
	@param			inHeaderData		bytes you want to put in the authorization Response header.			
	@param			inHeaderDataLength	length of the bytes you want to put in authorization Response header.			
	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		Authorization Response header - OBEX Spec, 2.2.14: Authorization Response.
*/

OBEXError OBEXAddAuthorizationResponseHeader(	const void*				inHeaderData,
												uint32_t				inHeaderDataLength,
												CFMutableDictionaryRef	dictRef );

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function		OBEXAddUserDefinedHeader
	@abstract		Add a user-defined custom header to a dictionary of OBEXheaders.
	@param			inHeaderData		bytes you want to put in the user-defined header.			
	@param			inHeaderDataLength	length of the bytes you want to put in user-defined header.			
	@param			dictRef			dictionary you have allocated to hold the headers. Make sure it's mutable.		
	@result			Error code, kOBEXSuccess (0) if success.
	@discussion		User Defined header - OBEX Spec, 2.2.20: User Defined Headers.
*/

OBEXError OBEXAddUserDefinedHeader(	const void*				inHeaderData,
									uint32_t				inHeaderDataLength,
									CFMutableDictionaryRef	dictRef );

#ifdef	__cplusplus
	}
#endif

                                                                                                                                                                               OBEXBluetooth.h                                                                                     0100644 0001750 0001750 00000013662 12567444611 034627  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 /*
	File:		OBEXBluetooth.h
	Contains:	Technology interfaces for OBEX over Bluetooth. See OBEX.h for more details about OBEX.
	Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/

#pragma once

#import <IOBluetooth/OBEX.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

//---------------------------------------------------------------------------------------------------------------------------
/*!	@header		OBEXBluetooth
	Object Exchange over Bluetooth.
*/


#ifdef	__cplusplus
	extern "C" {
#endif


#if 0
#pragma mark ======= Bluetooth Session Creators =======
#endif


//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothOBEXSessionCreateWithIOBluetoothSDPServiceRecordRef
	@abstract	Create an OBEX session with a service ref, usually obtained from the device browser.
	@param		inSDPServiceRecordRef	A valid service reference.
	@param		outSessionRef			A valid ptr to an IOBluetoothOBEXSessionRef; will contain the newly created session if
										return value is kOBEXSuccess.
	@result		An error code value. 0 if successful.
	@discussion	You will use a session reference to do all OBEX interaction to a specific device. This method DOES NOT
				create a connection to the device of any kind.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	IOBluetoothOBEXSessionCreateWithIOBluetoothSDPServiceRecordRef(	IOBluetoothSDPServiceRecordRef	inSDPServiceRef,
																			OBEXSessionRef *				outSessionRef )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	IOBluetoothOBEXSessionCreateWithIOBluetoothDeviceRefAndChannelNumber
	@abstract	Create an OBEX session with a device ref and an RFCOMM channel ID. This allows you to bypass the browser
				if you already know the SDP information.
	@param		inDeviceRef		A valid IOBluetoothDeviceRef reference.
	@param		inChannelID		A valid RFCOMM channel ID on the target device.
	@param		outSessionRef	A valid ptr to an IOBluetoothOBEXSessionRef; will contain the newly created session
								if return value is kOBEXSuccess.
	@result		An error code value. 0 if successful.
	@discussion	You will use a session reference to do all OBEX interaction to a specific device. This method DOES NOT
				create a connection to the device of any kind.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	IOBluetoothOBEXSessionCreateWithIOBluetoothDeviceRefAndChannelNumber(	IOBluetoothDeviceRef 		inDeviceRef,
																					BluetoothRFCOMMChannelID	inChannelID,
																					OBEXSessionRef *			outSessionRef )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;


//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionCreateWithIncomingIOBluetoothRFCOMMChannel
	@abstract	Create an OBEX session with an IOBluetoothRFCOMMchannel. This implies you are creating a OBEX SERVER
				session that will dole out info to remote Bluetooth clients.
	@param		inRFCOMMChannel			A valid IOBluetoothRFCOMMChannel reference.
	@param		inGetResponseCallback	A callback for Get requests sent to your session by a remote device. Must be a
										valid function ptr, otherwise why even call this?
	@param		outSessionRef			A valid ptr to an IOBluetoothOBEXSessionRef; will contain the newly created
										session if return value is kOBEXSuccess.
	@result		An error code value. 0 if successful.
	@discussion	This assumes that the RFCOMM channel you have passed it is already open and ready to transmit data
				to the session.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/

OBEXError	IOBluetoothOBEXSessionCreateWithIncomingIOBluetoothRFCOMMChannel(	IOBluetoothRFCOMMChannelRef		inRFCOMMChannelRef,
																				OBEXSessionEventCallback		inCallback,
																				void *							inUserRefCon,
																				OBEXSessionRef *				outSessionRef )	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;


typedef	void	(*IOBluetoothOBEXSessionOpenConnectionCallback) ( OBEXSessionRef session, OBEXError status, void * refCon );


//---------------------------------------------------------------------------------------------------------------------------
/*!	@function	OBEXSessionOpenTransportConnection
	@param		inSessionRef			A valid session reference.
	@param		inCallback				A valid callback.
	@param		inUserRefCon			Optional parameter; can contain anything you wish. Will be returned in your
										callback just as you passed it.
	@result		An error code value. 0 if successful.
	@discussion	Opens a transport-level connection to a remote target. For example, if you are using a Bluetooth transport,
				this will establish the baseband/L2CAP/RFCOMM connection to a device. Once the callback is called, the
				connection will either be opened or have failed with a status code. That status code will most likely have
				originated from the transport layer being used, so you may receive a Bluetooth error, an IOKit error, etc,
				but a 0 status should indicate success in all cases.

				***		DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
				***		You should transition your code to Objective-C equivalents.
				***		This API may be removed any time in the future.
*/ 

OBEXError	IOBluetoothOBEXSessionOpenTransportConnection(	OBEXSessionRef									inSessionRef,
															IOBluetoothOBEXSessionOpenConnectionCallback	inCallback,
															void *											inUserRefCon	)	DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

#ifdef	__cplusplus
	}
#endif

                                                                              objc/                                                                                               0040755 0001750 0001750 00000000000 12612224741 032732  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers                                                                 IOBluetoothDevice.h                                                                                 0100644 0001750 0001750 00000145005 12567444611 036433  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothDevice.h
    Copyright:	(c) 2008 by Apple Computer, Inc. All rights reserved.
*/
 
#import <IOKit/IOKitLib.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>
#import <IOBluetooth/objc/IOBluetoothObject.h>
#import <IOBluetooth/objc/IOBluetoothUserNotification.h>

/*!	@header		IOBluetoothDevice.h
	@abstract	An instance of IOBluetoothDevice represents a single remote Bluetooth device.
	@discussion	An IOBluetoothDevice object may exist independent of the existence of a baseband connection
                with the target device.  Through this object you can request baseband connections to be made, 
                request opening and closing of L2CAP and RFCOMM channels.
*/

//====================================================================================================================
//	Defines
//====================================================================================================================

// These are the names of the notifications the device sends using NSNotificationCenter when it is connected
// and disconnected

#define	kIOBluetoothDeviceNotificationNameConnected			@"IOBluetoothDeviceConnected"
#define	kIOBluetoothDeviceNotificationNameDisconnected		@"IOBluetoothDeviceDisconnected"
#define kIOBluetoothDeviceNameChangedNotification			@"IOBluetoothDeviceNameChanged"
#define kIOBluetoothDeviceInquiryInfoChangedNotification	@"IOBluetoothDeviceInquiryInfoChanged"
#define kIOBluetoothDeviceServicesChangedNotification		@"IOBluetoothDeviceServicesChanged"

// These are for the configuration of L2CAP Channels:
#define kIOBluetoothL2CAPChannelMaxAllowedIncomingMTU		@"MaxAllowedIncomingMTU"
#define kIOBluetoothL2CAPChannelDesiredOutgoingMTU			@"DesiredOutgoingMTU"

//====================================================================================================================
//	Forward declarations
//====================================================================================================================

@class IOBluetoothDevice;
@class IOBluetoothL2CAPChannel;
@class IOBluetoothRFCOMMConnection;
@class IOBluetoothRFCOMMChannel;
@class IOBluetoothSDPServiceRecord;
@class IOBluetoothSDPUUID;

//====================================================================================================================
//	Async callbacks informal protocol
//====================================================================================================================

@protocol IOBluetoothDeviceAsyncCallbacks

- (void)remoteNameRequestComplete:(IOBluetoothDevice *)device status:(IOReturn)status;
- (void)connectionComplete:(IOBluetoothDevice *)device status:(IOReturn)status;
- (void)sdpQueryComplete:(IOBluetoothDevice *)device status:(IOReturn)status;

@end

//--------------------------------------------------------------------------------------------------------------------------
/*!
 	@class IOBluetoothDevice
	@abstract An instance of IOBluetoothDevice represents a single remote Bluetooth device.
	@discussion	An IOBluetoothDevice object may exist independent of the existence of a baseband connection
                with the target device.  Using this object, a client can request creation and destruction of baseband
                connections, and request the opening of L2CAP and RFCOMM channels on the remote device.  Many of the other
                APIs in the IOBluetooth framework will return this object, or it's C counterpart (IOBluetoothDeviceRef).
*/

//====================================================================================================================
//	IOBluetoothDevice
//====================================================================================================================

@interface IOBluetoothDevice : IOBluetoothObject <NSCoding, NSSecureCoding>
{
    id									mServerDevice;
    
    io_iterator_t						mDeviceConnectNotification;
    
	// Device info.
	
	BluetoothDeviceAddress				mAddress;				// 00 08 22 44 AB 56, etc.
    
	NSString							*mName;					// "Terry Bozzio's Phone", etc.
	NSDate								*mLastNameUpdate;		// The date/time of the last read name
    
    BluetoothClassOfDevice				mClassOfDevice;
	
	// Stuff for connecting to the device.
	
	BluetoothPageScanRepetitionMode		mPageScanRepetitionMode;
	BluetoothHCIPageScanPeriodMode		mPageScanPeriodMode;
	BluetoothHCIPageScanMode			mPageScanMode;
	BluetoothClockOffset				mClockOffset;
    
    NSDate								*mLastInquiryUpdate;	// Time/date of the last inquiry result
                                                                // including the above 5 attributes
	
	// Stuff for maintaining a connection to the device.
	
	BluetoothConnectionHandle			mConnectionHandle;		// HCI handle
	BluetoothLinkType					mLinkType;				// SCO or ACL
	BluetoothHCIEncryptionMode			mEncryptionMode;		// Disabled, only P2P, P2P and Broadcast.
    
    NSArray								*mServiceArray;
    NSDate								*mLastServicesUpdate;
    
    // RFCOMM support
    
    IOBluetoothRFCOMMConnection			*mRFCOMMConnection;
    
    id                                  _mReserved;
}

// Creation/deletion.

/*!
    @property	registerForConnectNotifications:selector:
	@abstract	Allows a client to register for device connect notifications for any connection.
	@discussion	The given selector will be called on the target observer whenever any device connection is made.
				The selector should accept two arguments.  The first is the user notification object.  The second
				is the device that was connected.
	@param		observer	Target observer object
	@param		inSelector	Selector to be sent to the observer when a new connection is made
	@result		Returns an IOBluetoothUserNotification representing the outstanding device connect notification.
				To unregister the notification, call -unregister on the returned IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.  The returned
				IOBluetoothUserNotification object will be valid for as long as the notification is registered.
				It is not necessary to retain the result.  Once -unregister is called on it, it will no longer
				be valid.
*/

+ (IOBluetoothUserNotification *)registerForConnectNotifications:(id)observer selector:(SEL)inSelector;

/*!
    @property	registerForDisconnectNotification:selector:
	@abstract	Allows a client to register for device disconnect notification.
	@discussion	The given selector will be called on the target observer when the target device's connection is 
				closed.  The selector should contain two arguments.  The first is the user notification object.  The second
				is the IOBluetoothDevice that was disconnected.
	@param		observer	Target observer object
	@param		inSelector	Selector to be sent to the observer when the connection is destroyed
	@result		Returns an IOBluetoothUserNotification representing the outstanding device disconnect notification.
				To unregister the notification, call -unregister of the returned IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.
*/

- (IOBluetoothUserNotification *)registerForDisconnectNotification:(id)observer selector:(SEL)inSelector;

/*!
    @property	deviceWithAddress:
	@abstract	Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
	@discussion	Within a single application, there will be only one instance of IOBluetoothDevice for a
                given remote device address.
	@param		address	Pointer to a BluetoothDeviceAddress for which an IOBluetoothDevice instance is desired
	@result		Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
*/

+ (instancetype)deviceWithAddress:(const BluetoothDeviceAddress *)address;
+ (instancetype)withAddress:(const BluetoothDeviceAddress *)address DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
 @property	deviceWithAddressString:
 @abstract	Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
 @discussion	Within a single application, there will be only one instance of IOBluetoothDevice for a
 given remote device address.
 @param		address	Pointer to an NSString containing the BD_ADDR for which an IOBluetoothDevice instance is desired.  The string should be of the form xx:xx:xx:xx:xx:xx
 @result		Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
 */

+ (instancetype)deviceWithAddressString:(NSString *)address ;

/*!
    @property	withDeviceRef:
	@abstract	Method call to convert an IOBluetoothDeviceRef into an IOBluetoothDevice *.
	@discussion	IOBluetoothDeviceRef and it's API are deprecated.  An IOBluetoothDeviceRef can be cast to a IOBluetoothDevice *
	@param		deviceRef IOBluetoothDeviceRef for which an IOBluetoothDevice * is desired.
	@result		Returns the IOBluetoothDevice * for the given IOBluetoothDeviceRef.
*/

+ (instancetype)withDeviceRef:(IOBluetoothDeviceRef)deviceRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getDeviceRef
	@abstract	Returns an IOBluetoothDeviceRef representation of the target IOBluetoothDevice object.
	@discussion	IOBluetoothDeviceRef and it's API are deprecated.  An IOBluetoothDeviceRef can be cast to a IOBluetoothDevice *
	@result		Returns an IOBluetoothDeviceRef representation of the target IOBluetoothDevice object.
*/

- (IOBluetoothDeviceRef)getDeviceRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

// L2CAP channel.

/*!
    @property	openL2CAPChannelSync:withPSM:delegate:
	@abstract	Opens a new L2CAP channel to the target device. Returns only after the channel is opened.
	@discussion	This method will begin the process of opening a new L2CAP channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The L2CAP
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel.  This prevents a situation where the channel succeeds
                in being configured and opened and receives data before the client is listening and
                is ready for it.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
	@param		newChannel		A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel 
                                requested to be opened.  The newChannel pointer will only be set if 
                                kIOReturnSuccess is returned.
	@param		withPSM			The L2CAP PSM value for the new channel.
	@param		channelDelegate the object that will play the role of delegate for the channel.
				A channel delegate is the object the l2cap uses as target for  data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
				of the protocol IOBluetoothL2CAPChannelDelegate.
				
	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                L2CAP channel was found). 
*/

- (IOReturn)openL2CAPChannelSync:(IOBluetoothL2CAPChannel **)newChannel withPSM:(BluetoothL2CAPPSM)psm delegate:(id)channelDelegate;

/*!
    @property	openL2CAPChannelAsync:withPSM:delegate:
	@abstract	Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.
	@discussion	This method will begin the process of opening a new L2CAP channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The L2CAP
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel.  This prevents a situation where the channel succeeds
                in being configured and opened and receives data before the client is listening and
                is ready for it.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
	@param		newChannel		A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel 
                                requested to be opened.  The newChannel pointer will only be set if 
                                kIOReturnSuccess is returned.
	@param		psm				The L2CAP PSM value for the new channel.
	@param		channelDelegate the object that will play the role of delegate for the channel.
				A channel delegate is the object the l2cap uses as target for  data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
				of the protocol IOBluetoothL2CAPChannelDelegate.
				
	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                L2CAP channel was found). 
*/

- (IOReturn)openL2CAPChannelAsync:(IOBluetoothL2CAPChannel **)newChannel withPSM:(BluetoothL2CAPPSM)psm delegate:(id)channelDelegate;

/*!
    @property	openL2CAPChannel:findExisting:newChannel:
	@abstract	Opens a new L2CAP channel to the target device. Returns immedialty after starting the opening process.
	@discussion	This method will begin the process of opening a new L2CAP channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The L2CAP
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel.  This prevents a situation where the channel succeeds
                in being configured and opened and receives data before the client is listening and
                is ready for it.
	@param		psm				The L2CAP PSM value for the new channel.
	@param		findExisting	This value should be set to TRUE if it should look for an existing channel 
                                with the PSM.  Typically this value will be FALSE.  It should be TRUE only
                                in the case where a single channel is allowed by the spec for the given PSM.
	@param		newChannel		A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel 
                                requested to be opened.  The newChannel pointer will only be set if 
                                kIOReturnSuccess is returned.
	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                L2CAP channel was found). 
*/

- (IOReturn)openL2CAPChannel:(BluetoothL2CAPPSM)psm findExisting:(BOOL)findExisting newChannel:(IOBluetoothL2CAPChannel **)newChannel DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
    @property	sendL2CAPEchoRequest:length:
	@abstract	Send an echo request over the L2CAP connection to a remote device.
	@discussion	The current implementation returns when the request has been sent, but does not indicate when
                a response is received.  Also, the baseband connection must be up for the echo request to be sent.
                In the future, this method will also open the connection if necessary.  The API will be updated
                to allow the client to be informed when the echo response has been received (both synchronously
                and asynchronously).
	@param		data	(void *) - Pointer to buffer to send.
	@param		length	(UInt16) - Length of the buffer to send
	@result		Returns kIOReturnSuccess if the echo request was able to be sent.
*/

- (IOReturn)sendL2CAPEchoRequest:(void *)data length:(UInt16)length;

/*!
    @property	openRFCOMMChannel:channel:
	@abstract	Opens a new RFCOMM channel to the target device. Returns only once the channel is open or failed to open.
	@discussion	This method will begin the process of opening a new RFCOMM channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The RFCOMM
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel.
	@param		channelID		The RFCOMM channel ID for the new channel.
	@param		rfcommChannel	A pointer to an IOBluetoothRFCOMMChannel object to receive the RFCOMM channel 
                                requested to be opened.  The rfcommChannel pointer will only be set if 
                                kIOReturnSuccess is returned.
	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                RFCOMM channel was found). 
*/

- (IOReturn)openRFCOMMChannel:(BluetoothRFCOMMChannelID)channelID channel:(IOBluetoothRFCOMMChannel **)rfcommChannel DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
    @property	openRFCOMMChannelSync:withChannelID:delegate:
	@abstract	Opens a new RFCOMM channel to the target device.  Returns only once the channel is open or failed to open.
	@discussion	This method will begin the process of opening a new RFCOMM channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The RFCOMM
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel. The RFCOMM channel object is already retained when this function returns success;
				the channel must be released when the caller is done with it.

				You should verify that the channel you wish to open exists on the remote device before attempting to open it,
				by performing an SDP query. This is recommended because the service might have been removed from the,
				remote device or the channel assignments for the service could have changed (this is rare, but it does happen
				frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
				situations where the method would return an error; in these instances, the desired RFCOMM channel could not
				be opened again until the calling app was restarted.

				NOTE:	This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
						
	@param		rfcommChannel	A pointer to an IOBluetoothRFCOMMChannel object to receive the RFCOMM channel 
                                requested to be opened.  The rfcommChannel pointer will only be set if 
                                kIOReturnSuccess is returned.

	@param		channelID		The RFCOMM channel ID for the new channel.
								
	@param		channelDelegate the object that will play the role of delegate for the channel.
				A channel delegate is the object the rfcomm uses as target for  data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of the file "IOBluetoothRFCOMMChannel.h" in the definition
				of the protocol IOBluetoothRFCOMMChannelDelegate.

	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                RFCOMM channel was found). The channel must be released when the caller is done with it.
*/

- (IOReturn)openRFCOMMChannelSync:(IOBluetoothRFCOMMChannel **)rfcommChannel withChannelID:(BluetoothRFCOMMChannelID)channelID delegate:(id)channelDelegate;

/*!
    @property	openRFCOMMChannelAsync:withChannelID:delegate:
	@abstract	Opens a new RFCOMM channel to the target device. Returns immediately.
	@discussion	This method will begin the process of opening a new RFCOMM channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The RFCOMM
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel. The RFCOMM channel object is already retained when this function returns success;
				the channel must be released when the caller is done with it.
					
				You should verify that the channel you wish to open exists on the remote device before attempting to open it,
				by performing an SDP query. This is recommended because the service might have been removed from the,
				remote device or the channel assignments for the service could have changed (this is rare, but it does happen
				frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
				situations where the method would return an error; in these instances, the desired RFCOMM channel could not
				be opened again until the calling app was restarted.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
				
	@param		rfcommChannel	A pointer to an IOBluetoothRFCOMMChannel object to receive the RFCOMM channel 
                                requested to be opened.  The rfcommChannel pointer will only be set if 
                                kIOReturnSuccess is returned.

	@param		channelID		The RFCOMM channel ID for the new channel.
								
	@param		channelDelegate the object that will play the role of delegate for the channel.
				A channel delegate is the object the rfcomm uses as target for  data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of the file "IOBluetoothRFCOMMChannel.h" in the definition
				of the protocol IOBluetoothRFCOMMChannelDelegate.

	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                RFCOMM channel was found). The channel must be released when the caller is done with it.
*/

- (IOReturn)openRFCOMMChannelAsync:(IOBluetoothRFCOMMChannel **)rfcommChannel withChannelID:(BluetoothRFCOMMChannelID)channelID delegate:(id)channelDelegate;

// Setting/getting device info.

/*!
    @property	getClassOfDevice
	@abstract	Gets the full class of device value for the remote device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the class of device for the remote device.
*/

@property(readonly) BluetoothClassOfDevice classOfDevice;
- (BluetoothClassOfDevice)getClassOfDevice DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getServiceClassMajor
	@abstract	Get the major service class of the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the major service class of the device.
*/

@property(readonly) BluetoothServiceClassMajor serviceClassMajor;
- (BluetoothServiceClassMajor)getServiceClassMajor DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getDeviceClassMajor
	@abstract	Get the major device class of the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the major device class of the remote device.
*/

@property(readonly) BluetoothDeviceClassMajor deviceClassMajor;
- (BluetoothDeviceClassMajor)getDeviceClassMajor DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getDeviceClassMinor
	@abstract	Get the minor service class of the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the minor device class of the remote device.
*/

@property(readonly) BluetoothDeviceClassMinor deviceClassMinor;
- (BluetoothDeviceClassMinor)getDeviceClassMinor DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getName
	@abstract	Get the human readable name of the remote device.
	@discussion	This only returns a value if a remote name request has been performed on the target device.  If a
                successful remote name request has not been completed, nil is returned.  To perform a remote
                name request, call -remoteNameRequest.  If a remote name request has been successfully completed, 
                the method -getLastNameUpdate will return the date/time of the last successful request.
	@result		Returns the name of the remote device name.  This value is an NSString generated from the UTF-8
                format of the most recent remote name request.
*/

@property(readonly, copy) NSString *name;
- (NSString *)getName DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
    @property	getNameOrAddress
	@abstract	Get the human readable name of the remote device.  If the name is not present, it will return a string
                containing the device's address.
	@discussion	If a remote name request has been successfully completed, the device name will be returned.  If not,
                a string containg the device address in the format of "XX-XX-XX-XX-XX-XX" will be returned.
    @result		Returns the device's name or a string containing the device's address.
*/

@property(readonly) NSString *nameOrAddress;
- (NSString *)getNameOrAddress DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
    @property	getLastNameUpdate
	@abstract	Get the date/time of the last successful remote name request.
	@result		Returns the date/time of the last successful remote name request.  If no remote name request has been
                completed on the target device, nil is returned.
*/

@property(readonly, retain) NSDate *lastNameUpdate;
- (NSDate *)getLastNameUpdate DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getAddress
	@abstract	Get the Bluetooth device address for the target device.
	@result		Returns a pointer to the Bluetooth device address of the target device.
*/

- (const BluetoothDeviceAddress *)getAddress;

/*!
    @property	getAddressString
	@abstract	Get a string representation of the Bluetooth device address for the target device.  The
				format of the string is the same as returned by IOBluetoothNSStringFromDeviceAddress().
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns an NSString containing the Bluetooth device address of the target device.
*/

@property(readonly) NSString *addressString;
- (NSString *)getAddressString DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

// Connecting to the device.

/*!
    @property	getPageScanRepetitionMode
	@abstract	Get the value of the page scan repetition mode for the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the page scan repetition mode value for this device.
*/

- (BluetoothPageScanRepetitionMode)getPageScanRepetitionMode;

/*!
    @property	getPageScanPeriodMode
	@abstract	Get the value of the page scan period mode for the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns page scan period mode value for the device.
*/

- (BluetoothPageScanPeriodMode)getPageScanPeriodMode;

/*!
    @property	getPageScanMode
	@abstract	Get the page scan mode for the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the value for the page scan mode for the device.
*/

- (BluetoothPageScanMode)getPageScanMode;

/*!
    @property	getClockOffset
	@abstract	Get the clock offset value of the device.
	@discussion	This value is only meaningful if the target device has been seen during an inquiry.  This can be
                by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
                seen.
	@result		Returns the clock offset value for the device.
*/

- (BluetoothClockOffset)getClockOffset;

/*!
    @property	getLastInquiryUpdate
	@abstract	Get the date/time of the last time the device was returned during an inquiry.
	@result		Returns the date/time of the last time the device was seen during an inquiry.
                If the device has never been seen during an inquiry, nil is returned.
*/

- (NSDate *)getLastInquiryUpdate;

/*!
    @property	RSSI
	@abstract	Get the RSSI device (if connected), above or below the golden range. If the RSSI is within the golden
				range, a value of 0 is returned. For the actual RSSI value, use getRawRSSI. For more information, see
				the Bluetooth 4.0 Core Specification.
	@result		Returns the RSSI of the device. If the value cannot be read (e.g. the device is disconnected), a value 
				of +127 will be returned.
*/

- (BluetoothHCIRSSIValue)RSSI AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	rawRSSI
	@abstract	Get the raw RSSI device (if connected).
	@result		Returns the raw RSSI of the device.
	@discussion	This value is the perceived RSSI value, not relative the the golden range (see getRSSI for that value).
				This value will not available on all Bluetooth modules. If the value cannot be read (e.g. the device
				is disconnected) or is not available on a module, a value of +127 will be returned.
*/

- (BluetoothHCIRSSIValue)rawRSSI AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	isConnected
	@abstract	Indicates whether a baseband connection to the device exists.
	@result		Returns YES if a baseband connection to the device exists.
*/

- (BOOL)isConnected;

/*!
    @property	openConnection
	@abstract	Create a baseband connection to the device.
	@discussion	This method is synchronous and will not return until either a connection has been established
                or the create connection has failed (perhaps timed out).  This method does the same thing as
				calling -openConnection: with a nil target.	 This call with proceed without authentication required, and
				using the default page timeout value.  If authentication or a non-default page timeout is required the method
				-openConnection:withPageTimeout:authenticationRequired: should be used instead.	
				
				As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' with a success result code;
				your code must account for the cases where the baseband connection is already open.
										
	@result		Returns kIOReturnSuccess if the connection was successfully created.
*/

- (IOReturn)openConnection;

/*!
    @property	openConnection:
	@abstract	Create a baseband connection to the device.
	@discussion	If a target is specified, the open connection call is asynchronous and on completion of the 
				CREATE_CONNECTION command, the method -connectionComplete:status: will be called on the specified target.  
				If no target is specified, the call is synchronous and will not return until the connection is open
				or the CREATE_CONNECTION call has failed.  This call with proceed without authentication required, and
				using the default page timeout value.  If authentication or a non-default page timeout is required the method
				-openConnection:withPageTimeout:authenticationRequired: should be used instead.

				As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' with a success result code;
				your code must account for the cases where the baseband connection is already open.

	@result		Returns kIOReturnSuccess if the connection was successfully created (or if asynchronous, if the
				CREATE_CONNECTION command was successfully issued).
*/

- (IOReturn)openConnection:(id)target;

/*!
    @property	openConnection:withPageTimeout:authenticationRequired:
	@abstract	Create a baseband connection to the device.
	@discussion	If a target is specified, the open connection call is asynchronous and on completion of the 
				CREATE_CONNECTION command, the method -connectionComplete:status: will be called on the specified target.  
				If no target is specified, the call is synchronous and will not return until the connection is open
				or the CREATE_CONNECTION call has failed.

				NOTE: This method is only available in Mac OS X 10.2.7 (Bluetooth v1.3) or later.

				As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' with a success result code;
				your code must account for the cases where the baseband connection is already open.

	@param		target The target to message when the create connection call is complete
	@param		pageTimeoutValue The page timeout value to use for this call
	@param		authenticationRequired BOOL value to indicate whether authentication should be required for the connection
	@result		Returns kIOReturnSuccess if the connection was successfully created (or if asynchronous, if the
				CREATE_CONNECTION command was successfully issued).
*/
- (IOReturn)openConnection:(id)target withPageTimeout:(BluetoothHCIPageTimeout)pageTimeoutValue authenticationRequired:(BOOL)authenticationRequired;

/*!
    @property	closeConnection
	@abstract	Close down the baseband connection to the device.
	@discussion	This method is synchronous and will not return until the connection has been closed (or the 
                command failed).  In the future this API will be changed to allow asynchronous operation.
    @result		Returns kIOReturnSuccess if the connection has successfully been closed.
*/

- (IOReturn)closeConnection;

/*!
    @property	remoteNameRequest:
	@abstract	Issues a remote name request to the target device.
	@discussion	If a target is specified, the request is asynchronous and on completion of the request, the method
 
				- (void)remoteNameRequestComplete:(IOBluetoothDevice *)device status:(IOReturn)status;

                will be called on the specified target. If no target is specified, the request is made synchronously
 				and won't return until the request is complete.  This call with operate with the default page
 				timeout value. If a different page timeout value is desired, the method -remoteNameRequest:withPageTimeout:
 				should be used instead.
	@param		target The target to message when the remote name request is complete
    @result		Returns kIOReturnSuccess if the remote name request was successfully issued (and if synchronous, if
                the request completed successfully).
*/

- (IOReturn)remoteNameRequest:(id)target;

/*!
    @property	remoteNameRequest:withPageTimeout:
	@abstract	Issues a remote name request to the target device.
	@discussion	If a target is specified, the request is asynchronous and on completion of the REMOTE_NAME_REQUEST
                command, the method -remoteNameRequestComplete:status:name: will be called on the specified target.
                If no target is specified, the request is made synchronously and won't return until the request is 
                complete.

				NOTE: This method is only available in Mac OS X 10.2.7 (Bluetooth v1.3) or later.
	@param		target The target to message when the remote name request is complete
	@param		pageTimeoutValue The page timeout value to use for this call
    @result		Returns kIOReturnSuccess if the remote name request was successfully issued (and if synchronous, if
                the request completed successfully).
*/

- (IOReturn)remoteNameRequest:(id)target withPageTimeout:(BluetoothHCIPageTimeout)pageTimeoutValue;

/*!
    @property	requestAuthentication
	@abstract	Requests that the existing baseband connection be authenticated.
	@discussion	In order to authenticate a baseband connection, a link key needs to be generated as a result of 
                the pairing process.  This call will synchronously initiate the pairing process with the target device
                and not return until the authentication process is complete.  This API will be updated to allow
                for asynchronous operation.
    @result		Returns kIOReturnSuccess if the connection has been successfully been authenticated.  Returns an error
                if authentication fails or no baseband connection exists.
*/

- (IOReturn)requestAuthentication;

/*!
    @property	getConnectionHandle
	@abstract	Get the connection handle for the baseband connection.
	@discussion	This method only returns a valid result if a baseband connection is present (-isConnected returns TRUE).
	@result		Returns the connection handle for the baseband connection.  If no baseband connection is present,
                kBluetoothConnectionHandleNone is returned.
*/

@property(readonly, assign) BluetoothConnectionHandle connectionHandle;
- (BluetoothConnectionHandle)getConnectionHandle DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	isIncoming
	@abstract	Returns TRUE if the device connection was generated by the remote host.
    @discussion	Returns TRUE if the device connection was generated by the remote host. False if the connection was generated by some other device that connected to the local host.

				NOTE: This method is only available in Mac OS X 10.2.7 (Bluetooth v1.3) or later.
	@result		Returns TRUE if the device connection was generated by the remote host.
*/

- (BOOL)isIncoming;

/*!
    @property	getLinkType
	@abstract	Get the link type for the baseband connection.
	@discussion	This method only returns a valid result if a baseband connection is present (-isConnected returns TRUE).
	@result		Returns the link type for the baseband connection.  If no baseband connection is present,
                kBluetoothLinkTypeNone is returned.
*/

- (BluetoothLinkType)getLinkType;

/*!
    @property	getEncryptionMode
	@abstract	Get the encryption mode for the baseband connection.
	@discussion	This method only returns a valid result if a baseband connection is present (-isConnected returns TRUE).
	@result		Returns the encryption mode for the baseband connection.  If no baseband connection is present,
                kEncryptionDisabled is returned.
*/

- (BluetoothHCIEncryptionMode)getEncryptionMode;

/*!
    @property	performSDPQuery:
	@abstract	Performs an SDP query on the target device.
	@discussion	As a result of this call, a baseband connection will be built to the device (if not already connected).
				Then, an L2CAP channel will be opened to the SDP server on the device.  At that point, a Service
				Search Attribute request will be issued with a UUID of 0x0100 (L2CAP) and an attribute range of
				0x0000 - 0xffff specified.  This will cause the SDP server to return all attributes of all L2CAP-derived 
				services on the device.  The results essentially encompass all services on the device.
				This function is always asynchronous.  If a target is specified, when the SDP query is complete (or
				an error is encountered), the method -sdpQueryComplete:status: will be called on the given target.  If no target 
				is specified, the request is still asynchronous, but no callback will be made.  That can be useful if the client 
				has	registered for SDP service changed notifications.
	@param		target The target to message when the SDP query is complete
    @result		Returns kIOReturnSuccess if the SDP query was successfully started.
*/

- (IOReturn)performSDPQuery:(id)target;

/*!
 @property	performSDPQuery:uuids:
 @abstract	Performs an SDP query on the target device with the specified service UUIDs.
 @discussion	As a result of this call, a baseband connection will be built to the device (if not already connected).
 Then, an L2CAP channel will be opened to the SDP server on the device.  At that point, a Service
 Search Attribute request will be issued for each service UUID specified in the UUID array.
 
 This function is always asynchronous.  If a target is specified, when the SDP query is complete (or
 an error is encountered), the method -sdpQueryComplete:status: will be called on the given target.  If no target 
 is specified, the request is still asynchronous, but no callback will be made.  That can be useful if the client 
 has	registered for SDP service changed notifications.
 @param		target The target to message when the SDP query is complete
 @param		uuidArray An array of IOBluetoothSDPUUID objects for each service the caller is interested in
 
 @result		Returns kIOReturnSuccess if the SDP query was successfully started.
 */

- (IOReturn)performSDPQuery:(id)target uuids:(NSArray *)uuidArray AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	services
	@abstract	Gets an array of service records for the device.
	@discussion	The resulting array contains IOBluetoothSDPServiceRecord objects.  The service records are only
                present if an SDP query has been done on the target object.  This can be determined by calling
                -getLastServicesUpdate.  It will return the last date/time of the SDP query. To initiate an
				SDP query on a device, use -performSDPQuery: as defined above.
                
                Instead of allowing individual clients to query for different services and service attributes,
                the system request all of the device's services and service attributes.
	@result		Returns an array of service records for the device if an SDP query has been performed.  If no
                SDP query has been performed, nil is returned.
*/

@property(readonly, retain) NSArray *services;
- (NSArray *)getServices DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @property	getLastServicesUpdate
	@abstract	Get the date/time of the last SDP query.
	@result		Returns the date/time of the last SDP query.  If an SDP query has never been performed on the
                device, nil is returned.
*/

- (NSDate *)getLastServicesUpdate;

/*!
    @property	getServiceRecordForUUID
	@abstract	Search for a service record containing the given UUID.
	@discussion	This method searches through the device's services to find a service that contains the given
                UUID.  Only the first service record will be returned.  This method only operates on services
                that have already been queried.  It will not initiate a new query.  This method should probably 
                be updated to return an array of service records if more than one contains the UUID.  
    @param		sdpUUID UUID value to search for.  
	@result		Returns the first service record that contains the given uuid.  If no service record is found,
                nil is returned.
*/

- (IOBluetoothSDPServiceRecord *)getServiceRecordForUUID:(IOBluetoothSDPUUID *)sdpUUID;

/*!
    @property	favoriteDevices
	@abstract	Gets an array of the user's favorite devices.
	@discussion	The resulting array contains IOBluetoothDevice objects.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns an array of device objects representing the user's favorite devices.  If the
				user has no favorites, nil is returned.
*/

+ (NSArray *)favoriteDevices;

/*!
    @property	isFavorite
	@abstract	Reports whether the target device is a favorite for the user.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns TRUE if the target device is a favorite for the user, FALSE if not.
*/

- (BOOL)isFavorite;

/*!
    @property	addToFavorites
	@abstract	Adds the target device to the user's favorite devices list.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns kIOReturnSuccess if the device was successfully added to the user's
				list of favorite devices.
*/

- (IOReturn)addToFavorites;

/*!
    @property	removeFromFavorites
	@abstract	Removes the target device from the user's favorite devices list.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns kIOReturnSuccess if the device was successfully removed from the user's
				list of favorite devices.
*/

- (IOReturn)removeFromFavorites;

/*!
    @property	recentDevices
	@abstract	Gets an array of recently used Bluetooth devices.
	@discussion	The resulting array contains IOBluetoothDevice objects sorted in reverse chronological order.
				The most recently accessed devices are first.  If the numDevices parameter is 0, all devices 
				accessed by the system are returned.  If numDevices is non-zero, only the most recent devices
				are returned.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
    @param		numDevices The number of devices to return.
	@result		Returns an array of device objects recently used by the system.  If no devices have been accessed,
				nil is returned.
*/

+ (NSArray *)recentDevices:(unsigned long)numDevices;

/*!
    @property	recentAccessDate
	@abstract	Returns the date/time of the most recent access of the target device.
	@discussion	This is the date that -recentDevices uses to sort its list of the most recently accessed
				devices.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the date/time of the most recent access of the target device.  If the device
				has not been accessed, nil is returned.
*/

- (NSDate *)recentAccessDate;

/*!
    @property	pairedDevices
	@abstract	Gets an array of all of the paired devices on the system.
	@discussion	The resulting array contains IOBluetoothDevice objects.  The paired devices are currently NOT stored
				per user, so this is all devices paired by any user.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
	@result		Returns an array of device objects for all of the paired devices on the system.  If there are
				no paired devices, nil is returned.
*/

+ (NSArray *)pairedDevices;

/*!
    @property	isPaired
	@abstract	Returns whether the target device is paired.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
	@result		Returns TRUE if the target device is paired, FALSE if not.
*/

- (BOOL)isPaired;

/*!
    @property	setSupervisionTimeout
	@abstract	Sets the connection supervision timeout.
	@discussion	NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
	@param		timeout A client-supplied link supervision timeout value to use to monitor the connection. The timeout
				value should be specified in slots, so you can use the BluetoothGetSlotsFromSeconds macro to get the proper
				value. e.g. BluetoothGetSlotsFromSeconds( 5.0 ) will give yield the proper number of slots (8000) for 5 seconds.
	@result		Returns kIOReturnSuccess if it was possible to set the connection supervision timeout.
*/

- (IOReturn)setSupervisionTimeout:(UInt16)timeout;

/*!
    @property	openL2CAPChannelSync:withPSM:withConfiguration:delegate:
	@abstract	Opens a new L2CAP channel to the target device. Returns only after the channel is opened.
	@discussion	This method will begin the process of opening a new L2CAP channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The L2CAP
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel.  This prevents a situation where the channel succeeds
                in being configured and opened and receives data before the client is listening and
                is ready for it. The L2CAP channel object is already retained when this function returns success;
				the channel must be released when the caller is done with it.

				NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
	@param		newChannel		A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel 
                                requested to be opened.  The newChannel pointer will only be set if 
                                kIOReturnSuccess is returned.
	@param		withPSM			The L2CAP PSM value for the new channel.
	@param		channelConfiguration the dictionary that describes the initial configuration for
				the channel.
	@param		channelDelegate the object that will play the role of delegate for the channel.
				A channel delegate is the object the l2cap uses as target for  data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
				of the protocol IOBluetoothL2CAPChannelDelegate.
			
	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                L2CAP channel was found). The channel must be released when the caller is done with it.
*/

- (IOReturn)openL2CAPChannelSync:(IOBluetoothL2CAPChannel **)newChannel withPSM:(BluetoothL2CAPPSM)psm withConfiguration:(NSDictionary*)channelConfiguration delegate:(id)channelDelegate;

/*!
    @property	openL2CAPChannelAsync:withPSM:withConfiguration:delegate:
	@abstract	Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.
	@discussion	This method will begin the process of opening a new L2CAP channel to the target device.  
                The baseband connection to the device will be opened if it is not open already.  The L2CAP
                channel open process will not complete until the client has registered an incoming data 
                listener on the new channel.  This prevents a situation where the channel succeeds
                in being configured and opened and receives data before the client is listening and
                is ready for it. The L2CAP channel object is already retained when this function returns success;
				the channel must be released when the caller is done with it.

				NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
	@param		newChannel		A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel 
                                requested to be opened.  The newChannel pointer will only be set if 
                                kIOReturnSuccess is returned.
	@param		psm				The L2CAP PSM value for the new channel.
	@param		channelConfiguration the dictionary that describes the initial configuration for
				the channel.
	@param		channelDelegate the object that will play the role of delegate for the channel.
				A channel delegate is the object the l2cap uses as target for  data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
				of the protocol IOBluetoothL2CAPChannelDelegate.
				
	@result		Returns kIOReturnSuccess if the open process was successfully started (or if an existing
                L2CAP channel was found). The channel must be released when the caller is done with it.
*/

- (IOReturn)openL2CAPChannelAsync:(IOBluetoothL2CAPChannel **)newChannel withPSM:(BluetoothL2CAPPSM)psm withConfiguration:(NSDictionary*)channelConfiguration delegate:(id)channelDelegate;

- (id)awakeAfterUsingCoder:(NSCoder *)coder;

@end


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           IOBluetoothDeviceInquiry.h                                                                          0100644 0001750 0001750 00000031262 12567444611 040013  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	Contains:	A way to find bluetooth devices.
	Copyright:	(c) 2008 by Apple Computer, Inc., all rights reserved.
*/

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

//===========================================================================================================================
//	Forward Declarations
//===========================================================================================================================

@class NSMutableArray;
@class IOBluetoothDevice;

//===========================================================================================================================
//	IOBluetoothDeviceInquiry
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@class			IOBluetoothDeviceInquiry
	@abstract		Object representing a device inquiry that finds Bluetooth devices in-range of the computer,
					and (optionally) retrieves name information for them.
	@discussion		You should only use this object if your application needs to know about in-range devices and cannot
					use the GUI provided by the IOBluetoothUI framework. It will not let you perform unlimited back-to-back
					inquiries, but will instead throttle the number of attempted inquiries if too many are attempted within
					a small window of time.
					Important Note: DO NOT perform remote name requests on devices from delegate methods or while this
					object is in use. If you wish to do your own remote name requests on devices, do them after you have
					stopped this object. If you do not heed this warning, you could potentially deadlock your process.
*/

@interface IOBluetoothDeviceInquiry : NSObject
{
@private
	
	void *							_nameRequestHintType;
	IOBluetoothDeviceSearchAttributes *_searchAttributes;
	void *							_deviceAttributes;

    id                              _mReserved;
    id                              _mUnused000;
    id                              _mUnused001;
    id                              _mUnused002;

	id								_delegate;

	BluetoothServiceClassMajor		_serviceClassMajor;
	BluetoothDeviceClassMajor		_deviceClassMajor;
	BluetoothDeviceClassMinor		_deviceClassMinor;
	
    uint8_t							_inquiryLength;
	BluetoothHCIResponseCount		_inquiryMaxItems;

    NSMutableArray  *				_deviceResults;
    NSMutableArray	*				_devicesPendingNames;
	
	uint8_t							_currentActivity;
	BOOL							_remoteNameRequestInProgress;
	BOOL							_infSearch;
	BOOL							_sendDuplicates;
	BOOL							_aborted;
	BOOL							_updateNewDeviceNames;
	
}

@property(assign) id delegate;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		inquiryWithDelegate
	@abstract	Class method to create an inquiry object.
	@param		delegate		A delegate object that wishes to receive messages from the inquiry object. Delegate methods are listed below, under IOBluetoothDeviceInquiryDelegate.
	@result		A pointer to the created IOBluetoothDeviceInquiry object.
	@discussion The inquiry is NOT automatically started. You musts call -start on it to start the search for in-range devices.
*/

+ (instancetype)inquiryWithDelegate:(id)delegate;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		initWithDelegate
	@abstract	Initializes an alloc'd inquiry object, and sets the delegate object, as if -setDelegate: were called on it.
	@param		delegate		A delegate object that wishes to receive messages from the inquiry object. Delegate methods are listed below, under IOBluetoothDeviceInquiryDelegate.
	@result		A pointer to the initialized IOBluetoothDeviceInquiry object.
*/

- (instancetype)initWithDelegate:(id)delegate;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		start
	@abstract	Tells inquiry object to begin the inquiry and name updating process, if specified.
	@result		Returns kIOReturnSuccess if start was successful. Returns kIOReturnBusy if the object is already in process. May return other IOReturn values, as appropriate.
	@discussion Calling start multiple times in rapid succession or back-to-back will probably not produce the intended
				results. Inquiries are throttled if they are called too quickly in succession.
*/

- (IOReturn)start;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		stop
	@abstract   Halts the inquiry object. Could either stop the search for new devices, or the updating of found device names.
	@result		Returns kIOReturnSuccess if the inquiry is successfully stopped. Returns kIOReturnNotPermitted if the inquiry object is already stopped. May return other IOReturn values, as appropriate.
*/

- (IOReturn)stop;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setInquiryLength
	@abstract   Set the length of the inquiry that is performed each time -start is used on an inquiry object. 
	@param		seconds			Number of seconds the inquiry will search for in-range devices before refreshing device names, if specified.
	@result		Number of seconds the search will be performed.
	@discussion A default of 10 seconds is used, unless a different value is specified using this method.  Note that if you
				have called -start again too quickly, your inquiry may actually take much longer than what length you
				specify, as inquiries are throttled in the system. Also note that if you have the inquiry object updating
				device names for you, the whole inquiry process could be much longer than the specified length, depending
				on the number of devices found and how responsive to name requests they are. If you -must- have a strict
				inquiry length, disable name updates. In other words, this "length" only refers to the actual device discovery
				portion of the whole inquiry process.
*/

@property(assign) uint8_t inquiryLength;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setSearchType
	@abstract   Set the devices that are found. 
	@param		searchType		Bluetooth versions the search will discover.
	@discussion A default of kIOBluetoothDeviceSearchClassic is used, unless a different value is specified using this method.
*/

@property(assign) IOBluetoothDeviceSearchTypes searchType;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setUpdateNewDeviceNames
	@abstract   Sets whether or not the inquiry object will retrieve the names of devices found during the search.
	@param		inValue		Pass TRUE if names are to be updated, otherwise pass FALSE.
	@discussion The default value for the inquiry object is TRUE, unless this method is used to change it.
*/

@property(assign) BOOL updateNewDeviceNames;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		foundDevices
	@abstract   Returns found IOBluetoothDevice objects as an array.
	@result		Returns an NSArray of IOBluetoothDevice objects.
	@discussion Will not return nil. If there are no devices found, returns an array with length of 0.
*/

- (NSArray*)foundDevices;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		clearFoundDevices
	@abstract   Removes all found devices from the inquiry object.
*/

- (void)clearFoundDevices;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setSearchCriteria
	@abstract   Use this method to set the criteria for the device search.
	@param		inServiceClassMajor		Set the major service class for found devices. Set to kBluetoothServiceClassMajorAny for all devices. See BluetoothAssignedNumbers.h for possible values.
	@param		inMajorDeviceClass		Set the major device class for found devices. Set to kBluetoothDeviceClassMajorAny for all devices. See BluetoothAssignedNumbers.h for possible values.
	@param		inMinorDeviceClass		Set the minor device class for found devices. Set to kBluetoothDeviceClassMinorAny for all devices. See BluetoothAssignedNumbers.h for possible values.
	@discussion The default inquiry object will search for all types of devices. If you wish to find only keyboards, for example, you might use this method like this:
	
				[myInquiryObject		setSearchCriteria:kBluetoothServiceClassMajorAny
										majorDeviceClass:kBluetoothDeviceClassMajorPeripheral
										minorDeviceClass:kBluetoothDeviceClassMinorPeripheral1Keyboard];
										
				However, we recommend only using this if you are certain of the device class you are looking for, as some
				devices may report a different/unexpected device class, and the search may miss the device you are interested in.
*/

- (void)setSearchCriteria:(BluetoothServiceClassMajor)inServiceClassMajor
				majorDeviceClass:(BluetoothDeviceClassMajor)inMajorDeviceClass
				minorDeviceClass:(BluetoothDeviceClassMinor)inMinorDeviceClass;
				
@end

/*!
    @category 		IOBluetoothDeviceInquiryDelegate
    @discussion		This category on NSObject describes the delegate methods for the IOBluetoothDeviceInquiry object. All
					methods are optional, but it is highly recommended you implement them all. Do NOT invoke remote name
					requests on found IOBluetoothDevice objects unless the inquiry object has been stopped. Doing so may
					deadlock your process.
*/

@protocol IOBluetoothDeviceInquiryDelegate
@optional
//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			deviceInquiryStarted
	@discussion 	This message will be delivered when the inquiry actually starts. Since the inquiry could be throttled, this
					message may not be received immediately after called -start.
	@param			sender				Inquiry object that sent this delegate message.
*/

- (void)	deviceInquiryStarted:(IOBluetoothDeviceInquiry*)sender;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			deviceInquiryDeviceFound
	@discussion 	A new device has been found. You do not need to retain the device - it will be held in the internal
					storage of the inquiry, and can be accessed later using -foundDevices.
	@param			sender				Inquiry object that sent this delegate message.
	@param			device				IOBluetoothDevice that was found.
*/

- (void)	deviceInquiryDeviceFound:(IOBluetoothDeviceInquiry*)sender	device:(IOBluetoothDevice*)device;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			deviceInquiryUpdatingDeviceNamesStarted
	@discussion 	The inquiry has begun updating device names that were found during the search.
	@param			sender				Inquiry object that sent this delegate message.
	@param			devicesRemaining	Number of devices remaining to update.
*/

- (void)	deviceInquiryUpdatingDeviceNamesStarted:(IOBluetoothDeviceInquiry*)sender	devicesRemaining:(uint32_t)devicesRemaining;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			deviceInquiryDeviceNameUpdated
	@discussion 	A device name has been retrieved. Also indicates how many devices are left to be updated.
	@param			sender				Inquiry object that sent this delegate message.
	@param			device				IOBluetoothDevice that was updated.
	@param			devicesRemaining	Number of devices remaining to update.
*/

- (void)	deviceInquiryDeviceNameUpdated:(IOBluetoothDeviceInquiry*)sender	device:(IOBluetoothDevice*)device devicesRemaining:(uint32_t)devicesRemaining;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			deviceInquiryComplete
	@discussion 	When the inquiry is completely stopped, this delegate method will be invoked. It will supply an error
					code value, kIOReturnSuccess if the inquiry stopped without problem, otherwise a non-kIOReturnSuccess
					error code will be supplied.
	@param			sender				Inquiry object that sent this delegate message.
	@param			error				Error code. kIOReturnSuccess if the inquiry completed without incident.
	@param			aborted				TRUE if user called -stop on the inquiry.
*/

- (void)	deviceInquiryComplete:(IOBluetoothDeviceInquiry*)sender	error:(IOReturn)error	aborted:(BOOL)aborted;

@end
                                                                                                                                                                                                                                                                                                                                              IOBluetoothDevicePair.h                                                                             0100644 0001750 0001750 00000017634 12567444611 037255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	Contains:	API to pair with a Bluetooth device.
	Copyright:	(C) 2008 by Apple, Inc., all rights reserved.
*/

#import <IOKit/IOReturn.h>
#import <IOBluetooth/Bluetooth.h>

//===========================================================================================================================
//	Forwards
//===========================================================================================================================

@class IOBluetoothDevice;
@class NSString;

//--------------------------------------------------------------------------------------------------------------------------
/*!
 	@class		IOBluetoothDevicePair
	@abstract	An instance of IOBluetoothDevicePair represents a pairing attempt to a remote Bluetooth device.
	@discussion	Use the IOBluetoothDevicePair object to attempt to pair with any Bluetooth device. Once -start is invoked
				on it, progress is returned to the delegate via the messages defined below. This object enables you to
				pair with devices within your application without having to use the standard panels provided by the
				IOBluetoothUI framework, allowing you to write custom UI to select devices, and still handle the ability
				to perform device pairings.
				
				Of note is that this object MAY attempt to perform two low-level pairings, depending on the type of device
				you are attempting to pair. This is inconsequential to your code, however, as it occurs automatically and
				does not change the messaging.
				
				Once started, the pairing can be stopped. This will set the delegate to nil and then attempt to disconnect
 				from the device if already connected.
*/

//===========================================================================================================================
//	IOBluetoothDevicePair
//===========================================================================================================================

@interface	IOBluetoothDevicePair : NSObject
{
	id							_delegate;
	IOBluetoothDevice *			_device;
	BOOL						_busy;
	BOOL						_isHandlerSetup;
	BOOL						_triedSpecNULLPIN;
	BOOL						_SDPQueryComplete;
	IOReturn					_connectionCompleteStatus;
	uint32_t					_totalAttempts;
	id                          _expansion;
}

@property(assign) id delegate;

/*!
    @method		pairWithDevice:
	@abstract	Creates an autorelease IOBluetoothDevicePair object with a device as the pairing target.
	@param		device		An IOBluetoothDevice to attept to pair with. The device is retained.
	@result		Returns an IOReturn or Bluetooth error code, if the pairing could not be started.
*/

+ (instancetype)pairWithDevice:(IOBluetoothDevice*)device;

/*!
    @method		start
	@abstract	Kicks off the pairing with the device.
	@result		Returns an IOReturn or Bluetooth error code, if the pairing could not be started.
*/

- (IOReturn)start;

/*!
 @method		stop
 @abstract		Stops the current pairing. Removes the delegate and disconnects if device was connected.
 */

- (void)stop;

/*!
    @method		device
	@abstract	Get the IOBluetoothDevice being used by the object.
	@result		device		The IOBluetoothDevice object that the IOBluetoothDevicePair object is pairing with, as
							specified in -setDevice: or pairWithDevice:
*/

- (IOBluetoothDevice*)device;

/*!
    @method		setDevice:
	@abstract	Set the device object to pair with. It is retained by the object.
	@param		device		The IOBluetoothDevice object that the IOBluetoothDevicePair object with which to perform a pairing.
*/

- (void)setDevice:(IOBluetoothDevice*)inDevice;

/*!
    @method		replyPINCode:
	@abstract	This is the required reply to the devicePairingPINCodeRequest delegate message.
				Set the PIN code to use during pairing if required.
	@param		PINCodeSize	The PIN code length in octets (8 bits).
	@param		PINcode		PIN code for the device.  Can be up to a maximum of 128 bits.
*/

- (void)replyPINCode:(ByteCount)PINCodeSize PINCode:(BluetoothPINCode *)PINCode;

/*!
    @method		replyUserConfirmation:
	@abstract	This is the required reply to the devicePairingUserConfirmationRequest delegate message.
	@param		reply		A yes/no answer provide by the user to the numeric comparison presented.
*/

- (void)replyUserConfirmation:(BOOL)reply;

@end

//===========================================================================================================================
//	Delegate methods
//===========================================================================================================================

@protocol IOBluetoothDevicePairDelegate <NSObject>
@optional

/*!
    @method		devicePairingStarted:
	@abstract	Indicates that the pairing has started.
	@param		sender		The IOBluetoothDevicePair object.
*/

- (void) devicePairingStarted:(id)sender;

/*!
    @method		devicePairingConnecting:
	@abstract	Indicates to the delegate that the pairing object is making the device (baseband) connection.
	@param		sender		The IOBluetoothDevicePair object.
*/

- (void) devicePairingConnecting:(id)sender;

/*!
    @method		devicePairingPINCodeRequest:
	@abstract	Indicates to the delegate that the pairing object has made the device (baseband) connection and is
				awaiting the PIN code (if specified) to be entered on the device. Thus, when you recieve this message,
				you should display to the user that they should enter the PIN code on the device.
				The method replyPINCode must be invoked in response and happen before the timeout period of the device.
	@param		sender		The IOBluetoothDevicePair object.
*/

- (void) devicePairingPINCodeRequest:(id)sender;

/*!
    @method		devicePairingUserConfirmationRequest:numericValue
	@abstract	Indicates to the delegate that the pairing object has made the device (baseband) connection and is
				awaiting the a yes/no answer for the Simple Secure Pairing numeric comparison. Thus, when you recieve this message,
				you should display to the user the numeric value and then accept the yes/no answer if it matches the value
				on the other device.
				The method replyUserConfirmation must be invoked in response and happen before the timeout period of the device.
	@param		sender			The IOBluetoothDevicePair object.
	@param		numericValue	Numeric value to be displayed.
*/

- (void) devicePairingUserConfirmationRequest:(id)sender numericValue:(BluetoothNumericValue)numericValue;

/*!
    @method		devicePairingUserPasskeyNotification:passkey
	@abstract	Indicates to the delegate that the pairing object has made the device (baseband) connection and is
				awaiting the passkey (if specified) to be entered on the device for the Secure Simple Pairing.
				Thus, when you recieve this message, you should display to the user that they should enter
				the passkey on the device.
	@param		sender			The IOBluetoothDevicePair object.
	@param		passkey			Passkey to be displayed.
*/

- (void) devicePairingUserPasskeyNotification:(id)sender passkey:(BluetoothPasskey)passkey;

/*!
    @method		devicePairingFinished:error:
	@abstract	Indicates to the delegate that the pairing object has fully completed the process. Can tell the delegate
				when and error occurred during the attempt to pair with the device.
	@discussion	The error passed to your delegate could be kBluetoothHCIErrorAuthenticationFailure,
				kBluetoothHCIErrorLMPResponseTimeout, etc. See Bluetooth.h for all the possibilities.
	@param		sender		The IOBluetoothDevicePair object.
	@param		error		An IOReturn or Bluetooth error code.
*/

- (void) devicePairingFinished:(id)sender error:(IOReturn)error;

/*!
 @method		deviceSimplePairingComplete:status:
 @abstract	Indicates to the delegate that the pairing object has fully completed the simple pairing process. Can tell the delegate
 when and error occurred during the attempt to pair with the device.
 @discussion	The status passed to your delegate could be BluetoothHCIEventStatus, etc. See Bluetooth.h for all the possibilities.
 @param		sender		The IOBluetoothDevicePair object.
 @param		status		A simple pairing complete error code.
 */

- (void) deviceSimplePairingComplete:(id)sender status:(BluetoothHCIEventStatus)status;

@end
                                                                                                    IOBluetoothHandsFree.h                                                                              0100644 0001750 0001750 00000047432 12567444611 037100  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
 File:		BluetoothHandsFree.h
 Copyright:	(c) 2010 by Apple Inc. All rights reserved.
 */

#import <Foundation/Foundation.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/objc/IOBluetoothDevice.h>
#import <IOBluetooth/objc/IOBluetoothSDPServiceRecord.h>

#import <CoreAudio/AudioHardware.h>

/*!
 @header
 @abstract	Hands free superclass. Superclass of IOBluetoothHandsFreeDevice or IOBluetoothHandsFreeAudioGateway.
 			Contains the common code used to support the Bluetoooth hands free profile.
 @copyright	(c) 2010 by Apple Inc. All rights reserved.
 */

// HFP spec 5.3
enum  {
	IOBluetoothHandsFreeDeviceFeatureNone					= (0),
	IOBluetoothHandsFreeDeviceFeatureECAndOrNRFunction		= (1<<0),
	IOBluetoothHandsFreeDeviceFeatureThreeWayCalling		= (1<<1),
	IOBluetoothHandsFreeDeviceFeatureCLIPresentation		= (1<<2),
	IOBluetoothHandsFreeDeviceFeatureVoiceRecognition		= (1<<3),
	IOBluetoothHandsFreeDeviceFeatureRemoteVolumeControl	= (1<<4),
	IOBluetoothHandsFreeDeviceFeatureEnhancedCallStatus		= (1<<5),
	IOBluetoothHandsFreeDeviceFeatureEnhancedCallControl	= (1<<6)
};

typedef NSUInteger IOBluetoothHandsFreeDeviceFeatures;

//HFP spec 5.3
enum {
	IOBluetoothHandsFreeAudioGatewayFeatureNone						= (0),
	IOBluetoothHandsFreeAudioGatewayFeatureThreeWayCalling			= (1<<0),
	IOBluetoothHandsFreeAudioGatewayFeatureECAndOrNRFunction		= (1<<1),
	IOBluetoothHandsFreeAudioGatewayFeatureVoiceRecognition			= (1<<2),
	IOBluetoothHandsFreeAudioGatewayFeatureInBandRingTone			= (1<<3),
	IOBluetoothHandsFreeAudioGatewayFeatureAttachedNumberToVoiceTag	= (1<<4),
	IOBluetoothHandsFreeAudioGatewayFeatureRejectCallCapability		= (1<<5),
	IOBluetoothHandsFreeAudioGatewayFeatureEnhancedCallStatus		= (1<<6),
	IOBluetoothHandsFreeAudioGatewayFeatureEnhancedCallControl		= (1<<7),
	IOBluetoothHandsFreeAudioGatewayFeatureExtendedErrorResultCodes	= (1<<8)
};

typedef NSUInteger IOBluetoothHandsFreeAudioGatewayFeatures;

// HFP spec 4.33.2
enum {
	IOBluetoothHandsFreeCallHoldMode0	= 1<<0,		// Releases all held calls or sets User Determined User Busy for a waiting call
	IOBluetoothHandsFreeCallHoldMode1	= 1<<1,		// Releases all active calls (if any exist) and accepts the other (held or waiting) call
	IOBluetoothHandsFreeCallHoldMode1idx= 1<<2,		// Releases specified active call only (<idx>)
	IOBluetoothHandsFreeCallHoldMode2	= 1<<3,		// Places all active calls (if any exist) on hold and accepts the other (held or waiting) call
	IOBluetoothHandsFreeCallHoldMode2idx= 1<<4,		// Request private consultation mode with specified call (<idx>). Place all calls on hold EXCEPT the call indicated by <idx>
	IOBluetoothHandsFreeCallHoldMode3	= 1<<5,		// Adds a held call to the conversation
	IOBluetoothHandsFreeCallHoldMode4	= 1<<6		// Connectes the two calls and disconnects the subscriber from both calls (Explicit call transfer).
};

typedef NSUInteger IOBluetoothHandsFreeCallHoldModes;

// HandsFreeIndicators (AT+CIND?) HFP spec 4.33.2
// Hands free indicator constants
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorService;	/* 0 if no service; 1 otherwise */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorCall;		/* 0 if no call active; 1 otherwise */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorCallSetup;	/* 0 if no call in setup, 1 for incoming, 2 for outgoing, 3 remote party is being alerted */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorCallHeld;	/* 0 if no call is held, 1 if a call is held and an active call exists, 2 if a call is held and no active call */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorSignal;	/* 0-5 0 represents a weak signal */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorRoam;		/* 0 if not roaming; 1 otherwise */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeIndicatorBattChg;	/* 0-5 0 represents a low battery charge */

// Hands free current call dictionary keys
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallIndex;			/* Index of the call starting with 1 - Calls hold their index and new calls get the lowest index */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallDirection;		/* 0 if outgoing, 1 if incoming */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallStatus;			/* 0 if active, 1 if held, 2 if dialing (outgoing), 3 if alerting (outgoing), 4 if incoming, 5 if waiting (incoming) */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallMode;			/* 0 if voice, 1 for data, 2 for fax */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallMultiparty;		/* 0 if not multiparty, 1 if multiparty */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallNumber;			/* Optional - the remote number */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallType;			/* Optional - the format of the number */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothHandsFreeCallName;			/* Optional - the remote caller's name */

enum {
	IOBluetoothSMSModePDU,
	IOBluetoothSMSModeText
};

typedef NSUInteger IOBluetoothSMSMode;

// 3GPP TS 07.05 v7.0.1
// +CSMS
enum {
	IOBluetoothHandsFreePhase2SMSSupport				= 1<<0,
	IOBluetoothHandsFreePhase2pSMSSupport				= 1<<1,
	IOBluetoothHandsFreeManufactureSpecificSMSSupport	= 1<<2
};

typedef NSUInteger IOBluetoothHandsFreeSMSSupport;

enum {
	IOBluetoothHandsFreePDUStatusRecUnread	= 0,
	IOBluetoothHandsFreePDUStatusRecRead	= 1,
	IOBluetoothHandsFreePDUStatusStoUnsent	= 2,
	IOBluetoothHandsFreePDUStatusStoSent	= 3,
	IOBluetoothHandsFreePDUStatusAll		= 4
};

typedef NSUInteger IOBluetoothHandsFreePDUMessageStatus;

// Hands free SMS dictionary keys
// 3GPP TS 03.40 9.2.2.1 and 9.2.3
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUServicCenterAddress;		/* Service Center's number */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUServiceCenterAddressType;	/* Format of the service center number */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUType;						/* TP-MTI TP-MMS TP-RP TP-UDHI TP-SRI */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUOriginatingAddress;		/* Sender's number */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUOriginatingAddressType;	/* Format of sender's number */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUProtocolID;				/* Protocol of the message content */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUTimestamp;				/* Time the PDU was sent */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUEncoding;					/* How the PDU is encoded */
IOBLUETOOTH_EXPORT NSString * const IOBluetoothPDUUserData;					/* PDU's payload */


@class IOBluetoothRFCOMMChannel;
@class IOBluetoothHandsFreeExpansion;

@protocol IOBluetoothHandsFreeDelegate;

/*!
 @class IOBluetoothHandsFree
 @abstract Hands free profile class.
 @discussion Superclass of IOBluetoothHandsFreeDevice and IOBluetoothHandsFreeAudioGateway classes.
			 Contains the common code used to support the bluetoooth hands free profile.
 @coclass IOBluetoothHandsFreeDevice
 @coclass IOBluetoothHandsFreeAudioGateway
 */
NS_CLASS_AVAILABLE(10_7, NA)
@interface IOBluetoothHandsFree : NSObject {
    IOBluetoothRFCOMMChannel *		_rfcommChannel;
	IOBluetoothUserNotification *	_rfcommChannelNotification;
    
	uint32_t						_supportedFeatures;
	
	void *							_reserved1;
    
	float							_previousInputVolume;
	float							_previousOutputVolume;
	BOOL							_previousOutputMuted;
    
	IOBluetoothDevice *				_device;
	BluetoothRFCOMMChannelID		_deviceRFCOMMChannelID;
	uint32_t						_deviceSupportedFeatures;
	uint32_t						_deviceCallHoldModes;
	uint32_t						_deviceSupportedSMSServices;
	
	NSMutableArray *				_statusIndicators;
	int								_handsFreeState;
	IOBluetoothSMSMode				_SMSMode;
	BOOL							_SMSEnabled;
    
    BOOL							_connectSCOAfterSLCConnected;

    IOBluetoothHandsFreeExpansion *	_reserved;
}


/*!
 @method		supportedFeatures
 @abstract		Return supported features
 @discussion	Returns the supported features bitmap. The values are described in IOBluetoothHandsFreeDeviceFeatures and IOBluetoothHandsFreeAudioGatewayFeatures.
 @result		The supported features bitmap
 */
/*!
 @method		setSupportedFeatures:featuresBitmap
 @abstract		Set the supported features
 @discussion	Sets the supported features bitmap. The values are described in IOBluetoothHandsFreeDeviceFeatures and IOBluetoothHandsFreeAudioGatewayFeatures.
 @param			featuresBitmap The features bitmap
 */
@property (assign)				uint32_t					supportedFeatures NS_AVAILABLE_MAC(10_7);

/*!
 @method		inputVolume
 @abstract		Return the input volume
 @discussion	Returns the input volume between 0 and 1. 0 is the same as mute.
 @result		The input volume
 */
/*!
 @method		setInputVolume:newVolume
 @abstract		Set the input volume
 @discussion	Sets the input volume between 0 and 1. 0 is the same as mute.
 @param			newVolume The new input volume
 */
@property (assign)				float						inputVolume NS_AVAILABLE_MAC(10_7);

/*!
 @method		isInputMuted
 @abstract		Return the input mute state.
 @discussion	Returns the inputs mute state.
 @result		YES if muted; otherwise NO.
 */
/*!
 @method		setInputMuted:muted
 @abstract		Set the input mute state.
 @discussion	Sets the inputs mute state.
 @param			muted YES if muted; otherwise NO.
 */
@property (assign, getter=isInputMuted)	BOOL				inputMuted NS_AVAILABLE_MAC(10_7);

/*!
 @method		outputVolume
 @abstract		Return the output volume
 @discussion	Returns the output volume between 0 and 1. 0 is the same as mute.
 @result		The output volume
 */
/*!
 @method		setOutputVolume:newVolume
 @abstract		Set the output volume
 @discussion	Sets the output volume between 0 and 1. 0 is the same as mute.
 @param			newVolume The new output volume
 */
@property (assign)				float						outputVolume NS_AVAILABLE_MAC(10_7);

/*!
 @method		isOutputMuted
 @abstract		Return the output mute state.
 @discussion	Returns the outputs mute state.
 @result		YES if muted; otherwise NO.
 */
/*!
 @method		setOutputMuted:muted
 @abstract		Set the output mute state.
 @discussion	Sets the outputs mute state.
 @param			muted YES if muted; otherwise NO.
 */
@property (assign, getter=isOutputMuted)	BOOL			outputMuted NS_AVAILABLE_MAC(10_7);

/*!
 @method		device
 @abstract		Return the IOBluetoothDevice.
 @discussion	Returns the IOBluetoothDevice to connect with.
 @result		The IOBluetoothDevice object
 */
@property (retain, readonly)	IOBluetoothDevice * 		device NS_AVAILABLE_MAC(10_7);

/*!
 @method		deviceSupportedFeatures
 @abstract		Return the device's supported features.
 @discussion	Returns the device's supported features bitmap. The values are described in IOBluetoothHandsFreeDeviceFeatures and IOBluetoothHandsFreeAudioGatewayFeatures.
 @result		The device features bitmap
 */
@property (readonly)			uint32_t					deviceSupportedFeatures NS_AVAILABLE_MAC(10_7);

/*!
 @method		deviceSupportedSMSServices
 @abstract		Return the device's supported SMS services.
 @discussion	Returns the device's supported SMS services bitmap. The values are described in IOBluetoothHandsFreeSMSSupport.
 @result		The SMS services supported
 */
@property (readonly)			uint32_t					deviceSupportedSMSServices NS_AVAILABLE_MAC(10_7);

/*!
 @method		deviceCallHoldModes
 @abstract		Return the device's supported call hold modes.
 @discussion	Returns the device's supported call hold modes bitmap. The values are described in IOBluetoothHandsFreeCallHoldModes.
 @result		The SMS services supported
 */
@property (readonly)			uint32_t					deviceCallHoldModes NS_AVAILABLE_MAC(10_7);

/*!
 @method		SMSMode
 @abstract		Return the device's SMS mode.
 @discussion	Returns the device's SMS mode. The values are described in IOBluetoothSMSMode.
 @result		The SMS mode
 */
@property (readonly)			IOBluetoothSMSMode			SMSMode NS_AVAILABLE_MAC(10_7);

/*!
 @method		isSMSEnabled
 @abstract		Return YES if the device has SMS enabled.
 @discussion	Returns YES if the device has SMS enabled (by responding to a CMGF command). NO if the device has not set an SMS mode or doesn't support SMS.
 @result		YES if the device has SMSEnabled; otherwise, NO.
 */
@property (readonly, getter=isSMSEnabled)	BOOL			SMSEnabled NS_AVAILABLE_MAC(10_7);

/*!
 @method		delegate
 @abstract		Return the delegate
 @discussion	Returns the hands free object's delegate.
 @result		The delegate for the hands free object or nil if it doesn't have a delegate.
 */
/*!
 @method		setDelegate:newDelegate
 @abstract		Sets the hands free objects delegate to a given object or removes an existing delegate.
 @discussion	A IOBluetoothHandsFree delegate can optionally respond to any of the delegate methods in IOBluetoothHandsFreeDelegate and any subclasses delegates.
 @param			newDelegate The delegate for the hands free object. Pass nil to remove an existing delegate.
 */
@property (assign)	id <IOBluetoothHandsFreeDelegate>	delegate NS_AVAILABLE_MAC(10_7);


/*!
 @method		indicator:indicatorName
 @abstract		Return an indicator's value
 @discussion	Returns an indicator's value.
 @param			indicatorName  See  Hands free indicator constants," for standard indicator names.
 */
- (int)indicator:(NSString *)indicatorName NS_AVAILABLE_MAC(10_7);

/*!
 @method		setIndicator:indicatorName:indicatorValue
 @abstract		Set an indicator's value
 @discussion	Sets an indicator's value.
 @param			indicatorName  See  Hands free indicator constants," for standard indicator names.
 @param			indicatorValue Will set the indicator value as long as it is within the min and max values allowed.
 */
- (void)setIndicator:(NSString *)indicatorName value:(int)indicatorValue NS_AVAILABLE_MAC(10_7);

/*!
 @method		initWithDevice:delegate:
 @abstract		Create a new IOBluetoothHandsFree object
 @discussion	This method should be called on a subclass (IOBluetoothHandsFreeDevice or IOBluetoothHandsFreeAudioGateway) to get full functionality.
 @param			device An IOBluetoothDevice
 @param			inDelegate An object to act as delegate that implements the IOBluetoothHandsFreeDelegate protocol.
 @result		A newly created IOBluetoothHandsFreeAudioGateway object on success, nil on failure
 */
- (instancetype)initWithDevice:(IOBluetoothDevice *)device delegate:(id <IOBluetoothHandsFreeDelegate>)inDelegate NS_AVAILABLE_MAC(10_7);

/*!
 @method		connect
 @abstract		Connect to the device
 @discussion	Connects to the device and sets up a service level connection (RFCOMM channel).
 				Delegate methods will be called once the connection is complete or a failure occurs.
 */
- (void)connect NS_AVAILABLE_MAC(10_7);

/*!
 @method		disconnect
 @abstract		Disconnect from the device
 @discussion	Disconnects from the device, closes the SCO and service level connection if they are connected.
 				Delegate methods will be called once the disconnection is complete.
 */
- (void)disconnect NS_AVAILABLE_MAC(10_7);

/*!
 @method		isConnected
 @abstract		Determine if there is a serivice level connection to the device
 @discussion	Determines if there is a serivice level connection to the device.
 @result		YES if there is a serivice level connection to the device; otherwise, NO.
 */
- (BOOL)isConnected NS_AVAILABLE_MAC(10_7);

/*!
 @method		connectSCO
 @abstract		Open a SCO connection with the device
 @discussion	Opens a SCO connection with the device. The device must already have a service level connection or this will return immediately.
 				Delegate methods will be called once the connection is complete of a failure occurs.
 */
- (void)connectSCO NS_AVAILABLE_MAC(10_7);

/*!
 @method		disconnectSCO
 @abstract		Disconnect the SCO connection with the device
 @discussion	Disconnects the SCO connection with the device (if one exists).
 				Delegate methods will be called once the disconnection is complete.
 */
- (void)disconnectSCO NS_AVAILABLE_MAC(10_7);

/*!
 @method		isSCOConnected
 @abstract		Determine if there is a SCO connection to the device
 @discussion	Determines if there is a SCO connection to the device.
 @result		YES if there is a SCO connection to the device; otherwise, NO.
 */
- (BOOL)isSCOConnected NS_AVAILABLE_MAC(10_7);

@end

@protocol IOBluetoothHandsFreeDelegate <NSObject>

@optional

/*!
 @method		handsFree:connected
 @discussion	Tells the delegate that the hands free service level connection is complete.
 @param			device The IOBluetoothHandsFree object that was being connected
 @param			status The result of the connection attempt. An IOReturn result returned in an NSNumber object.
 */
- (void)handsFree:(IOBluetoothHandsFree *)device connected:(NSNumber *)status NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:disconnected
 @discussion	Tells the delegate that the hands free service level connection was disconnected.
 @param			device The IOBluetoothHandsFree object whose service level connection was disconnected
 @param			status The result of the disconnection attempt. An IOReturn result returned in an NSNumber object.
 */
- (void)handsFree:(IOBluetoothHandsFree *)device disconnected:(NSNumber *)status NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:scoConnectionOpened
 @discussion	Tells the delegate that the SCO connection is complete.
 @param			device The IOBluetoothHandsFree object that was being connected
 @param			status The result of the connection attempt. An IOReturn result returned in an NSNumber object.
 */
- (void)handsFree:(IOBluetoothHandsFree *)device scoConnectionOpened:(NSNumber *)status NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:scoConnectionClosed
 @discussion	Tells the delegate that the SCO connection was closed.
 @param			device The IOBluetoothHandsFree object whose SCO connection was closed
 @param			status The result of the disconnection attempt. An IOReturn result returned in an NSNumber object.
 */
- (void)handsFree:(IOBluetoothHandsFree *)device scoConnectionClosed:(NSNumber *)status NS_AVAILABLE_MAC(10_7);

@end

@interface IOBluetoothDevice ( HandsFreeDeviceAdditions )

/*!
 @method		handsFreeAudioGatewayDriverID
 @abstract		Return the hands free gateway driver ID
 @discussion	Returns the hands free gateway driver ID which is unique based on BT Address.
 @result		The hands free gateway driver ID
 */
- (NSString *)handsFreeAudioGatewayDriverID NS_DEPRECATED_MAC(10_7, 10_8);

/*!
 @method		handsFreeAudioGatewayServiceRecord
 @abstract		Return the hands free gateway SDP record
 @discussion	Returns the hands free gateway SDP record.
 @result		The hands free gateway SDP record
 */
- (IOBluetoothSDPServiceRecord *)handsFreeAudioGatewayServiceRecord NS_AVAILABLE_MAC(10_7);

/*!
 @method		isHandsFreeAudioGateway
 @abstract		Return the devices support for hands free gateway
 @discussion	Returns the devices support for hands free gateway (obtained from the devices SDP record).
 @result		YES if the device supports hands free gateway; otherwise, NO.
 */
@property (readonly, getter = isHandsFreeAudioGateway) BOOL handsFreeAudioGateway NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFreeDeviceDriverID
 @abstract		Return the hands free device driver ID
 @discussion	Returns the hands free device driver ID which is unique based on BT Address.
 @result		The hands free device driver ID
 */
- (NSString *)handsFreeDeviceDriverID NS_DEPRECATED_MAC(10_7, 10_8);

/*!
 @method		handsFreeDeviceServiceRecord
 @abstract		Return the hands free device SDP record
 @discussion	Returns the hands free device SDP record.
 @result		The hands free device SDP record
 */
- (IOBluetoothSDPServiceRecord *)handsFreeDeviceServiceRecord NS_AVAILABLE_MAC(10_7);

/*!
 @method		isHandsFreeDevice
 @abstract		Return the devices support for hands free device
 @discussion	Returns the devices support for hands free device (obtained from the devices SDP record).
 @result		YES if the device supports hands free device; otherwise, NO.
 */
@property (readonly, getter = isHandsFreeDevice) BOOL handsFreeDevice NS_AVAILABLE_MAC(10_7);

@end

@interface IOBluetoothSDPServiceRecord ( HandsFreeSDPServiceRecordAdditions )

/*!
 @method		handsFreeSupportedFeatures
 @abstract		Return the hands free supported features
 @discussion	Returns the hands free supported features bitmap stored in the SDP record. See IOBluetoothHandsFreeDeviceFeatures and IOBluetoothHandsFreeAudioGatewayFeatures.
 @result		The supported features bitmap.
 */
- (uint16_t)handsFreeSupportedFeatures NS_AVAILABLE_MAC(10_7);

@end



                                                                                                                                                                                                                                      IOBluetoothHandsFreeAudioGateway.h                                                                  0100644 0001750 0001750 00000007152 12567444611 041377  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
 File:		IOBluetoothHandsFreeAudioGateway.h
 Copyright:	(c) 2010 by Apple Inc. All rights reserved.
 */

#import <IOBluetooth/objc/IOBluetoothHandsFree.h>

@class IOBluetoothHandsFreeAudioGatewayExpansion;

/*!
 @header
 @abstract	APIs for managing a hands free audio gateway
 @copyright	(c) 2010 by Apple Inc. All rights reserved.
 */
NS_CLASS_AVAILABLE(10_7, NA)
@interface IOBluetoothHandsFreeAudioGateway : IOBluetoothHandsFree {
	BOOL				_indicatorMode;
	BOOL				_indicatorEventReporting;
    
    IOBluetoothHandsFreeAudioGatewayExpansion *	_expansion;
}

/*!
 @method		initWithDevice:delegate:
 @abstract		Create a new IOBluetoothHandsFreeAudioGateway to act as a hands free gateway
 @discussion	This will register a listener for incoming connections.
 @param			device An IOBluetoothDevice
 @param			inDelegate An object to act as delegate
 @result		A newly created IOBluetoothHandsFreeAudioGateway object on success, nil on failure
 */
- (instancetype)initWithDevice:(IOBluetoothDevice *)device delegate: (id)inDelegate NS_AVAILABLE_MAC(10_7);

/*!
 @method		createIndicator:indicatorName:min:max:currentValue
 @abstract		Create an indicator
 @discussion	Creates an indicator with min and max values and sets the current value. The current value must be valid.
 @param			indicatorName  See  Hands free indicator constants," for standard indicator names.
 @param			minValue Minimum value allowed for the indicator
 @param			maxValue Maximum value allowed for the indicator
 @param			currentValue The current indicator value. Must be within the min and max values passed in or the indicator will not be created.
 */
- (void)createIndicator:(NSString *)indicatorName min:(int)minValue max:(int)maxValue currentValue:(int)currentValue NS_AVAILABLE_MAC(10_7);

/*!
 @method		processATCommand:atCommand
 @abstract		Handles AT commands sent from the hands free device
 @discussion	Implement this in a subclass if you wish to respond to additional AT commands or to change the default response.
 @param			atCommand The at command from the hands free device
 */
- (void)processATCommand:(NSString *)atCommand NS_AVAILABLE_MAC(10_7);

/*!
 @method		sendOKResponse
 @abstract		Sends an OK response
 @discussion	Use this to respond OK.
 */
- (void)sendOKResponse NS_AVAILABLE_MAC(10_7);

/*!
 @method		sendResponse:response
 @abstract		Sends a response to the hands free device
 @discussion	Use this to send a response followed by an OK. Equivalent to [sendResponse:response withOK:YES].
 @param			response The response to send to the hands free device
 */
- (void)sendResponse:(NSString *)response NS_AVAILABLE_MAC(10_7);

/*!
 @method		sendResponse:response:withOK
 @abstract		Sends a response to the hands free device
 @discussion	Use this to send a response and optionally followed by an OK.
 @param			response The response to send to the hands free device
 @param			withOK If yes, an OK response will also be sent.
 */
- (void)sendResponse:(NSString *)response withOK:(BOOL)withOK NS_AVAILABLE_MAC(10_7);

@end

@protocol IOBluetoothHandsFreeAudioGatewayDelegate
@optional

/*!
 @method		handsFree:hangup
 @discussion	Tells the delegate that the device is sending a hangup.
 @param			device The IOBluetoothHandsFreeAudioGateway object
 @param			redial Always 1.
 */
- (void)handsFree:(IOBluetoothHandsFreeAudioGateway *)device hangup:(NSNumber *)hangup NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:redial
 @discussion	Tells the delegate that the device is trying to redial.
 @param			device The IOBluetoothHandsFreeAudioGateway object
 @param			redial Always 1.
 */
- (void)handsFree:(IOBluetoothHandsFreeAudioGateway *)device redial:(NSNumber *)redial NS_AVAILABLE_MAC(10_7);

@end                                                                                                                                                                                                                                                                                                                                                                                                                      IOBluetoothHandsFreeDevice.h                                                                        0100644 0001750 0001750 00000027045 12567444611 040216  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
 File:		BluetoothHandsFreeDevice.h
 Copyright:	(c) 2010 by Apple Inc. All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <IOBluetooth/Bluetooth.h>

#import <IOBluetooth/objc/IOBluetoothDevice.h>
#import <IOBluetooth/objc/IOBluetoothHandsFree.h>

@class IOBluetoothDevice;
@class IOBluetoothHandsFreeDeviceExpansion;

/*!
 @header
 @abstract	APIs for managing a hands free device
 @copyright	(c) 2010 by Apple Inc. All rights reserved.
 */
NS_CLASS_AVAILABLE(10_7, NA)
@interface IOBluetoothHandsFreeDevice : IOBluetoothHandsFree {
	BOOL									_rejectSCOConnection;
	int										_ringAttempt;
	BOOL									_outstandingCommand;
	NSTimer *								_outstandingCommandTimer;
	IOBluetoothHandsFreeDeviceExpansion *   _expansion;
	NSMutableArray *						_commandQueue;
}

/*!
 @method		initWithDevice:delegate:
 @abstract		Create a new IOBluetoothHandsFreeDevice to act as a hands free device
 @discussion	This will register a listener for incoming connections.
 @param			device An IOBluetoothDevice
 @param			inDelegate An object to act as delegate
 @result		A newly created IOBluetoothHandsFreeDevice object on success, nil on failure
 */
- (instancetype)initWithDevice:(IOBluetoothDevice *)device delegate:(id)delegate NS_AVAILABLE_MAC(10_7);

/*!
 @method		dialNumber:aNumber
 @abstract		Dial a number
 @discussion	Calls aNumber
 @param			aNumber The number to call - the gateway determines acceptable formats.
 */
- (void)dialNumber:(NSString *)aNumber NS_AVAILABLE_MAC(10_7);

/*!
 @method		memoryDial:memoryLocation
 @abstract		Dial a number from memory
 @discussion	Calls a number from a memory (or speed dial) location.
 @param			memoryLocation The location in memory
 */
- (void)memoryDial:(int)memoryLocation NS_AVAILABLE_MAC(10_7);

/*!
 @method		redial
 @abstract		Redial a number
 @discussion	Redials the previous number stored by the hands free gateway.
 */
- (void)redial NS_AVAILABLE_MAC(10_7);

/*!
 @method		endCall
 @abstract		Hang up a call or reject an incoming call
 @discussion	Hangs up the current call, or rejects an incoming call.
 */
- (void)endCall NS_AVAILABLE_MAC(10_7);

/*!
 @method		acceptCall
 @abstract		Accept an incoming call
 @discussion	Accepts an incoming call.
 */
- (void)acceptCall NS_AVAILABLE_MAC(10_7);

/*!
 @method		acceptCallOnPhone
 @abstract		Accept an incoming call on the phone
 @discussion	Accepts an incoming call and then quickly transfer audio to the phone.
 */
- (void)acceptCallOnPhone NS_AVAILABLE_MAC(10_7);

/*!
 @method		sendDTMF:character
 @abstract		Send a key press
 @discussion	Sends a DTMF tone.
 @param			character A single character in the set 0-9, #,*,A-D
 */
- (void)sendDTMF:(NSString *)character NS_AVAILABLE_MAC(10_7);

/*!
 @method		subscriberNumber
 @abstract		Get the subscriber number(s)
 @discussion	Gets the subscriber number(s) stored on the gateway. Each subscriber number is returned on the delegate method handsFree:subscriberNumber.
				There is no guarantee that the gateway will have a subscriber number.
 */
- (void)subscriberNumber NS_AVAILABLE_MAC(10_7);

/*!
 @method		currentCallList
 @abstract		Get the current call list
 @discussion	Gets the current call list (active, held, and setup in process). Each call is returned on the delegate method handsFree:currentCall.
 */
- (void)currentCallList NS_AVAILABLE_MAC(10_7);

// TODO: Incomplete implementation for call hold features
/*!
 @method		releaseHeldCalls
 @abstract		Release all held calls
 @discussion	Releases all held calls or sets User Determined User Busy for a waiting call.
 */
- (void)releaseHeldCalls NS_AVAILABLE_MAC(10_7);

/*!
 @method		releaseActiveCalls
 @abstract		Release all active calls
 @discussion	Releases all active calls (if any exist) and accepts the other (held or waiting) call.
 */
- (void)releaseActiveCalls NS_AVAILABLE_MAC(10_7);

/*!
 @method		releaseCall:index
 @abstract		Release an active call.
 @discussion	Releases the active call with index.
 @param			index Index of the call to release
 */
- (void)releaseCall:(int)index NS_AVAILABLE_MAC(10_7);

/*!
 @method		holdCall
 @abstract		Place all active calls on hold
 @discussion	Places all active calls (if any exist) on hold and accepts the other (held or waiting) call.
 */
- (void)holdCall NS_AVAILABLE_MAC(10_7);

/*!
 @method		placeAllOthersOnHold:index
 @abstract		Place all other calls on hold.
 @discussion	Places all calls on hold except call with index.
 @param			index Index of the call to not place on hold
 */
- (void)placeAllOthersOnHold:(int)index NS_AVAILABLE_MAC(10_7);

/*!
 @method		addHeldCall
 @abstract		Add a held call to the current conversation
 @discussion	Adds a held call to the current conversation.
 */
- (void)addHeldCall NS_AVAILABLE_MAC(10_7);

/*!
 @method		callTransfer
 @abstract		Release all active calls
 @discussion	Releases all active calls (if any exist) and accepts the other (held or waiting) call.
 */
- (void)callTransfer NS_AVAILABLE_MAC(10_7);

/*!
 @method		transferAudioToComputer
 @abstract		Transfer audio source to the computer.
 @discussion	Transfers audio to the computer.
 */
- (void)transferAudioToComputer NS_AVAILABLE_MAC(10_7);

/*!
 @method		transferAudioToPhone
 @abstract		Transfer audio source to the phone.
 @discussion	Transfers audio to the phone.
 */
- (void)transferAudioToPhone NS_AVAILABLE_MAC(10_7);

/*!
 @method		sendSMS:aNumber:aMessage
 @abstract		Send an SMS to a number.
 @discussion	Sends an SMS to aNumber with content aMessage. Currently this does not handle long SMS (>160 characters) or unicode messages.
 */
- (void)sendSMS:(NSString *)aNumber message:(NSString *)aMessage NS_AVAILABLE_MAC(10_7);

#pragma mark -
/*!
 @method		sendATCommand:atCommand
 @abstract		Send an AT command to the hands free gateway.
 @discussion	Sends an AT command to the hands free gateway with a timeout of 10 seconds and handled by the built-in response handling.
				See sendAtCommand:timeout:selector:target for more details.
 @param			atCommand AT command to send
 */
- (void)sendATCommand:(NSString *)atCommand NS_AVAILABLE_MAC(10_7);

/*!
 @method		sendATCommand:atCommand:timeout:selector:target
 @abstract		Send an AT command to the hands free gateway.
 @discussion	Sends an AT command to the hands free gateway with timeout.
 				On command complete (OK, ERROR, TIMEOUT response or after timeout seconds) will perform selector on target.
 @param			atCommand AT command to send
 */
- (void)sendATCommand:(NSString *)atCommand timeout:(float)timeout selector:(SEL)selector target:(id)target NS_AVAILABLE_MAC(10_7);

@end

@protocol IOBluetoothHandsFreeDeviceDelegate <IOBluetoothHandsFreeDelegate>
@optional

/*!
 @method		handsFree:isServiceAvailable
 @discussion	Tells the delegate the service indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			isServiceAvailable 0 if no service available; 1 otherwise.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device isServiceAvailable:(NSNumber *)isServiceAvailable NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:isCallActive
 @discussion	Tells the delegate the call indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			isCallActive 0 if no call is active; 1 otherwise.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device isCallActive:(NSNumber *)isCallActive NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:callSetupMode
 @discussion	Tells the delegate the call setup indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			callSetupMode	0 if not currently in call setup.
 								1 if an incoming call is in call setup.
 								2 if an outgoing call is in call setup.
 								3 if the remote party is being alerted for an outgoing call.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device callSetupMode:(NSNumber *)callSetupMode NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:callHoldState
 @discussion	Tells the delegate the call held indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			callHoldState	0 if no calls are held.
 								1 if a call is on hold and an active call exists.
								2 if a call is on hold, but no active call exists.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device callHoldState:(NSNumber *)callHoldState NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:signalStrength
 @discussion	Tells the delegate the signal indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			signalStrength 0-5 where 0 represents a weak signal.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device signalStrength:(NSNumber *)signalStrength NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:isRoaming
 @discussion	Tells the delegate the roam indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			isRoaming 0 if not roaming; 1 otherwise.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device isRoaming:(NSNumber *)isRoaming NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:batteryCharge
 @discussion	Tells the delegate the battery charge indicator has changed.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			batteryCharge 0-5 where 0 represents a low battery charge.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device batteryCharge:(NSNumber *)batteryCharge NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:incomingCallFrom
 @discussion	Tells the delegate of an incoming call
 @param			device The IOBluetoothHandsFreeDevice object
 @param			number The remote caller's phone number
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device incomingCallFrom:(NSString *)number NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:ringAttempt
 @discussion	Tells the delegate of a ring alert
 @param			device The IOBluetoothHandsFreeDevice object
 @param			ringAttempt The number or ring alerts received
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device ringAttempt:(NSNumber *)ringAttempt NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:currentCall
 @discussion	Tells the delegate of a current call.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			currentCall A dictionary representing a call. See "Hands free current call dictionary keys" for the keys and their values.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device currentCall:(NSDictionary *)currentCall NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:subscriberNumber
 @discussion	Tells the delegate a subscriber number.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			subscriberNumber A subscriber number. Note that a gateway may have multiple subscriber numbers in which case this will be called for each number.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device subscriberNumber:(NSString *)subscriberNumber NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:incomingSMS
 @discussion	Tells the delegate an incoming SMS has arrived.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			incomingSMS A dictionary representing an SMS. See "Hands free SMS dictionary keys" for the keys and their values.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device incomingSMS:(NSDictionary *)sms NS_AVAILABLE_MAC(10_7);

/*!
 @method		handsFree:unhandledResultCode
 @discussion	Tells the delegate an unknown result code was received. Use this to add support additional response codes.
 				If a developer needs to change the handling of an implemented result code, they must use a subclass and override processResultCode:(NSString *)resultCode.
 @param			device The IOBluetoothHandsFreeDevice object
 @param			unhandledResultCode The result code.  "/r/n" are stripped from the begining and end of the result code.
 */
- (void)handsFree:(IOBluetoothHandsFreeDevice *)device unhandledResultCode:(NSString *)resultCode NS_AVAILABLE_MAC(10_7);

@end

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           IOBluetoothHostController.h                                                                         0100644 0001750 0001750 00000014437 12567444611 040221  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	Contains:	An object representation of a Bluetooth host controller (HCI).
	Copyright:	(C) 2006-2007 by Apple Computer, Inc., all rights reserved.
*/

#import <Foundation/Foundation.h>
#import <IOBluetooth/Bluetooth.h>

//===========================================================================================================================
//	Forward Declarations
//===========================================================================================================================

@class IOBluetoothDevice;

//===========================================================================================================================
//	IOBluetoothHostController
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@class			IOBluetoothHostController
	@abstract		This class is a representation of a Bluetooth Host Controller Interface that is present on the
					local computer (either plugged in externally or available internally).
	@discussion		This object can be used to ask a Bluetooth HCI for certain pieces of information, and be used to make
					it perform certain functions.
*/

@interface IOBluetoothHostController : NSObject
{
@private
	
	BluetoothHCIEventMask		_eventCodeMask;
	BluetoothClassOfDevice		_cachedClassOfDevice;
	id							_delegate;
	NSTimer *					_timerClassOfDeviceSetting;
	void *						_eventListener;

    id                          _mReserved;
    id                          _mUnused000;
    id                          _mUnused001;
    id                          _mUnused002;
}

@property(assign) id delegate;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		defaultController
	@abstract	Gets the default HCI controller object.
	@result		A (autoreleased) pointer to the created IOBluetoothHostController object.
*/

+ (instancetype)defaultController;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		powerState
	@abstract	Gets the controller power state
	@result		The current controller's power state.  This will be 1 for on, or 0 for off.  Only Apple Bluetooth adapters support power off
 */
@property(readonly) BluetoothHCIPowerState powerState;


//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		classOfDevice
	@abstract	Gets the current class of device value.
	@result		Returns the current class of device value.
*/

- (BluetoothClassOfDevice)classOfDevice;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setClassOfDevice:forTimeInterval:
	@abstract	Sets the current class of device value, for the specified amount of time. Note that the time interval *must*
				be set and valid. The range of acceptable values is 30-120 seconds. Anything above or below will be rounded
				up, or down, as appropriate.
	@result		Returns the whether setting the class of device value was successful. 0 if success, error code otherwise.
*/

- (IOReturn)setClassOfDevice:(BluetoothClassOfDevice)classOfDevice		forTimeInterval:(NSTimeInterval)seconds;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		addressAsString
	@abstract	Convience routine to get the HCI controller's Bluetooth address as an NSString object.
	@result		Returns NSString *. nil if the address could not be retrieved.
*/

- (NSString *)addressAsString;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		nameAsString
 @abstract	Gets the "friendly" name of HCI controller.
 @result		Returns NSString with the device name, nil if there is not one or it cannot be read.
 */

- (NSString *)nameAsString;

@end

#if 0
#pragma mark -
#endif

//===========================================================================================================================
//	IOBluetoothHostControllerDelegate
//===========================================================================================================================

/*!
    @category 		IOBluetoothHostControllerDelegate
    @discussion		This category on NSObject describes the delegate methods for the IOBluetoothHostController object. All
					methods are optional, but it is highly recommended you implement them all. Do NOT invoke remote name
					requests on found IOBluetoothDevice objects unless the controller object has been stopped. Doing so may
					deadlock your process.
*/

@interface NSObject( IOBluetoothHostControllerDelegate )

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			readRSSIForDeviceComplete:device:info:error:
	@discussion 	This delegate gets invoked when an RSSI command complete event occurs. This could occur because you
					invoked it by issuing an -readRSSIForDevice: command, or someone else did from another app on the
					same controller.
	@param			sender			Controller object that sent this delegate message.
*/

- (void)	readRSSIForDeviceComplete:(id)controller device:(IOBluetoothDevice*)device	info:(BluetoothHCIRSSIInfo*)info	error:(IOReturn)error;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method			readLinkQualityForDeviceComplete:device:info:error:
	@discussion 	This delegate gets invoked when an read link quality command complete event occurs. This could occur because you
					invoked it by issuing an -readLinkQualityForDevice: command, or someone else did from another app on the
					same controller.
	@param			sender			Controller object that sent this delegate message.
*/

- (void)	readLinkQualityForDeviceComplete:(id)controller device:(IOBluetoothDevice*)device	info:(BluetoothHCILinkQualityInfo*)info	error:(IOReturn)error;

@end

extern NSString * const IOBluetoothHostControllerPoweredOnNotification;
extern NSString * const IOBluetoothHostControllerPoweredOffNotification;
                                                                                                                                                                                                                                 IOBluetoothL2CAPChannel.h                                                                           0100644 0001750 0001750 00000043143 12567444611 037326  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothL2CAPChannel.h
    Copyright:	(c) 2012 by Apple, Inc. All rights reserved.
*/
 
#import <Foundation/Foundation.h>
#import <IOKit/IOKitLib.h>
#import <IOKit/IODataQueueShared.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>
#import <IOBluetooth/objc/IOBluetoothDevice.h>
#import <IOBluetooth/objc/IOBluetoothObject.h>


#if 0
#pragma mark -
#pragma mark === L2CAP ===
#endif

//===========================================================================================================================
// The following is left in for legacy reasons only. Please ignore.
//===========================================================================================================================

typedef enum IOBluetoothL2CAPChannelEventType {
	kIOBluetoothL2CAPChannelEventTypeData					=	0x0001,
	kIOBluetoothL2CAPChannelEventTypeOpenComplete			=	0x0002,
	kIOBluetoothL2CAPChannelEventTypeClosed					=	0x0003,
	kIOBluetoothL2CAPChannelEventTypeReconfigured			=	0x0004,
	kIOBluetoothL2CAPChannelEventTypeWriteComplete			=	0x0005,
	kIOBluetoothL2CAPChannelEventTypeQueueSpaceAvailable	=	0x0006
} IOBluetoothL2CAPChannelEventType;

typedef struct IOBluetoothL2CAPChannelDataBlock
{
	void 	*dataPtr;
	size_t	dataSize;
} IOBluetoothL2CAPChannelDataBlock;

typedef struct IOBluetoothL2CAPChannelEvent {
	IOBluetoothL2CAPChannelEventType	eventType;
	union
	{
		IOBluetoothL2CAPChannelDataBlock	data;
		void*								writeRefCon;
		UInt8								padding[32];
	} u;
	IOReturn							status;
} IOBluetoothL2CAPChannelEvent;

typedef void (*IOBluetoothL2CAPChannelIncomingDataListener)(IOBluetoothL2CAPChannelRef l2capChannel, void *data, UInt16 length, void *refCon);
typedef void (*IOBluetoothL2CAPChannelIncomingEventListener)(IOBluetoothL2CAPChannelRef l2capChannel, void *refCon, IOBluetoothL2CAPChannelEvent *event);


//--------------------------------------------------------------------------------------------------------------------------
/*!
 	@class IOBluetoothL2CAPChannel
	@abstract An instance of IOBluetoothL2CAPChannel represents a single open L2CAP channel.
	@discussion	A client won't create IOBluetoothL2CAPChannel objects directly.  Instead, the IOBluetoothDevice's 
                L2CAP channel open API is responsible for opening a new L2CAP channel and returning an
                IOBluetoothL2CAPChannel instance representing that newly opened channel.  Additionally, the IOBluetooth
                notification system will send notifications when new L2CAP channels are open (if requested).
                
                After a new L2CAP channel is opened, the L2CAP configuration process will not be completed until an
                incoming data listener is registered with the IOBluetoothL2CAPChannel object.  The reason for this is
                to due to the limited buffering done of incoming L2CAP data.  This way, we avoid the situation where 
                incoming data is received before the client is ready for it.  Once a client is done with an
                IOBluetoothL2CAPChannel that it opened, it should call -closeChannel.  Additionally, if the client
                does not intend to use the connection to the remote device any further, it should call -closeConnection
                on the IOBluetoothDevice object.
*/

@interface IOBluetoothL2CAPChannel : IOBluetoothObject <NSPortDelegate>
{
    NSPort										*mDataAvailablePort;
    IODataQueueMemory							*mIncomingDataQueue;
    IOBluetoothDevice							*mDevice;
    
	BOOL										mIncomingChannel;
	
	id											mL2CAPChannelConnectionHandler;

    IOBluetoothL2CAPChannelIncomingDataListener	mIncomingDataListener;
    void										*mIncomingDataListenerRefCon;

    IOBluetoothL2CAPChannelIncomingEventListener	mEventDataListener;
    void											*mEventDataListenerRefCon;
	
    BluetoothL2CAPPSM							mChannelPSM;
    
	BluetoothL2CAPChannelID						mLocalChannelID;
    BluetoothL2CAPChannelID						mRemoteChannelID;
    
	BOOL										mIsClosed;
    IOBluetoothObjectID							mObjectID;
    
    id                                          _mReserved;
}

/*!
    @method	registerForChannelOpenNotifications:selector:
	@abstract	Allows a client to register for L2CAP channel open notifications for any L2CAP channel.
	@discussion	The given selector will be called on the target object whenever any L2CAP channel is opened.
				The selector should accept two arguments.  The first is the user notification object.  The second
				is the IOBluetoothL2CAPChannel that was opened.
	@param		object		Target object
	@param		selector	Selector to be called on the target object when a new L2CAP channel is opened.
	@result		Returns an IOBluetoothUserNotification representing the outstanding L2CAP channel notification.
				To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.  The returned
				IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
				not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
*/

+ (IOBluetoothUserNotification *)registerForChannelOpenNotifications:(id)object selector:(SEL)selector;

/*!
    @method	registerForChannelOpenNotifications:selector:withPSM:direction:
	@abstract	Allows a client to register for L2CAP channel open notifications for certain types of
				L2CAP channels.
	@discussion	The given selector will be called on the target object whenever an L2CAP channel with the given
				attributes is opened.  The selector should accept two arguments.  The first is the user 
				notification object.  The second is the IOBluetoothL2CAPChannel that was opened.
	@param		object		Target object
	@param		selector	Selector to be called on the target object when a new L2CAP channel is opened.
	@param		psm			PSM to match a new L2CAP channel.  If the PSM doesn't matter, 0 may be passed in.
	@param		inDirection	The desired direction of the L2CAP channel - kIOBluetoothUserNotificationChannelDirectionAny
				if the direction doesn't matter.
	@result		Returns an IOBluetoothUserNotification representing the outstanding L2CAP channel notification.
				To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.  The returned
				IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
				not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
*/

+ (IOBluetoothUserNotification *)registerForChannelOpenNotifications:(id)object selector:(SEL)selector withPSM:(BluetoothL2CAPPSM)psm direction:(IOBluetoothUserNotificationChannelDirection)inDirection;

/*!
    @method	withObjectID:
	@abstract	Returns the IObluetoothL2CAPChannel with the given IOBluetoothObjectID.
	@discussion	The IOBluetoothObjectID can be used as a global reference for a given IOBluetoothL2CAPChannel.  It allows
				two separate applications to refer to the same IOBluetoothL2CAPChannel object.
	@param		objectID	IOBluetoothObjectID of the desired IOBluetoothL2CAPChannel.
	@result		Returns the IOBluetoothL2CAPChannel that matches the given IOBluetoothObjectID if one exists.
				If no matching L2CAP channel exists, nil is returned.
*/

+ (instancetype)withObjectID:(IOBluetoothObjectID)objectID;

/*!
    @method		closeChannel
	@abstract	Initiates the close process on an open L2CAP channel.
    @discussion	This method may only be called by the client that opened the channel in the first place.  In the future
                asynchronous and synchronous versions will be provided that let the client know when the close process
                has been finished.
	@result		Returns kIOReturnSuccess on success.
*/

- (IOReturn)closeChannel;

/*!
    @method		getOutgoingMTU
	@abstract	Returns the current outgoing MTU for the L2CAP channel.
    @discussion	The outgoing MTU represents the maximum L2CAP packet size for packets being sent to the remote device.
	@result		Returns the current outgoing MTU for the L2CAP channel.
*/

@property(readonly) BluetoothL2CAPMTU outgoingMTU;
- (BluetoothL2CAPMTU)getOutgoingMTU DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		getIncomingMTU
	@abstract	Returns the current incoming MTU for the L2CAP channel.
    @discussion	The incoming MTU represents the maximum L2CAP packet size for packets being sent by the remote device.
	@result		Returns the current incoming MTU for the L2CAP channel.
*/

@property(readonly) BluetoothL2CAPMTU incomingMTU;
- (BluetoothL2CAPMTU)getIncomingMTU DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		requestRemoteMTU:
	@abstract	Initiates the process to reconfigure the L2CAP channel with a new outgoing MTU.
    @discussion	Currently, this API does not give an indication that the re-config process has completed.  In
                the future additional API will be available to provide that information both synchronously and
                asynchronously.
    @param		remoteMTU	The desired outgoing MTU. 
	@result		Returns kIOReturnSuccess if the channel re-configure process was successfully initiated.
*/

- (IOReturn)requestRemoteMTU:(BluetoothL2CAPMTU)remoteMTU;

/*!
    @method		writeAsync:length:refcon:
	@abstract	Writes the given data over the target L2CAP channel asynchronously to the remote device.
    @discussion	The length of the data may not exceed the L2CAP channel's ougoing MTU.  When the data has 
				been successfully passed to the hardware to be transmitted, the delegate method 
				-l2capChannelWriteComplete:refcon:status: will be called with the refcon passed 
				into this method.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
    @param		data	Pointer to the buffer containing the data to send.
    @param		length 	The length of the given data buffer.
	@param		refcon	User supplied value that gets passed to the write callback.
	@result		Returns kIOReturnSuccess if the data was buffered successfully.
*/

- (IOReturn)writeAsync:(void *)data length:(UInt16)length refcon:(void*)refcon;

/*!
    @method		writeSync:length:
	@abstract	Writes the given data synchronously over the target L2CAP channel to the remote device.
    @discussion	The length of the data may not exceed the L2CAP channel's ougoing MTU.  This method will
				block until the data has been successfully sent to the hardware for transmission (or an error
				occurs).

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
    @param		data	Pointer to the buffer containing the data to send.
    @param		length 	The length of the given data buffer.
	@result		Returns kIOReturnSuccess if the data was written successfully.
*/

- (IOReturn)writeSync:(void *)data length:(UInt16)length;

/*!
    @method		setDelegate:
	@abstract	Allows an object to register itself as client of the L2CAP channel.
    @discussion A channel delegate is the object the L2CAP channel uses as target for data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of this file in the definition of the informal protocol
				IOBluetoothL2CAPChannelDelegate.
                A newly opened L2CAP channel will not complete its configuration process until the client
                that opened it registers a connectionHandler.  This prevents that case where incoming
                data is received before the client is ready. 

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
	@param		channelDelegate	the object that will play the role of channel delegate [NOTE the l2cap channel will retain the delegate].
	@result		Returns kIOReturnSuccess if the delegate is successfully registered.
*/

- (IOReturn)setDelegate:(id)channelDelegate;

/*!
    @method		setDelegate:withConfiguration:
	@abstract	Allows an object to register itself as client of the L2CAP channel.
    @discussion A channel delegate is the object the L2CAP channel uses as target for data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of this file in the definition of the informal protocol
				IOBluetoothL2CAPChannelDelegate.
                A newly opened L2CAP channel will not complete its configuration process until the client
                that opened it registers a connectionHandler.  This prevents that case where incoming
                data is received before the client is ready. 

				NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
	@param		channelDelegate	the object that will play the role of channel delegate.
	@param		channelConfiguration the dictionary that describes the initial configuration for
				the channel.
	@result		Returns kIOReturnSuccess if the delegate is successfully registered.
*/

- (IOReturn)setDelegate:(id)channelDelegate withConfiguration:(NSDictionary*)channelConfiguration;

/*!
 @method		delegate
 @abstract		Returns the currently assigned delegate
 @discussion	An incoming channel is one that was initiated by a remote device.
 @result		Returns the current delegate, or nil if one is not set.
 */
- (id) delegate;

/*!
    @method		getDevice
	@abstract	Returns the IOBluetoothDevice to which the target L2CAP channel is open.
	@result		Returns the IOBluetoothDevice to which the target L2CAP channel is open.
*/

@property(readonly, retain) IOBluetoothDevice *device;
- (IOBluetoothDevice *)getDevice DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		getObjectID
	@abstract	Returns the IOBluetoothObjectID of the given IOBluetoothL2CAPChannel.
    @discussion	The IOBluetoothObjectID can be used as a global reference for a given IOBluetoothL2CAPChannel.  It allows
				two separate applications to refer to the same IOBluetoothL2CAPChannel.
	@result		Returns the IOBluetoothObjectID of the given IOBluetoothL2CAPChannel.
*/

@property(readonly, assign) IOBluetoothObjectID objectID;
- (IOBluetoothObjectID)getObjectID DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		getPSM
	@abstract	Returns the PSM for the target L2CAP channel.
	@result		Returns the PSM for the target L2CAP channel.
*/

@property(readonly, assign) BluetoothL2CAPPSM PSM;
- (BluetoothL2CAPPSM)getPSM DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		getLocalChannelID
	@abstract	Returns the local L2CAP channel ID for the target L2CAP channel.
	@result		Returns the local L2CAP channel ID for the target L2CAP channel.
*/

@property(readonly, assign) BluetoothL2CAPChannelID localChannelID;
- (BluetoothL2CAPChannelID)getLocalChannelID DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		getRemoteChannelID
	@abstract	Returns the remote L2CAP channel ID for the target L2CAP channel.
	@result		Returns the remote L2CAP channel ID for the target L2CAP channel.
*/

@property(readonly, assign) BluetoothL2CAPChannelID remoteChannelID;
- (BluetoothL2CAPChannelID)getRemoteChannelID DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		isIncoming
	@abstract	Returns TRUE if the channel is an incoming channel.
    @discussion	An incoming channel is one that was initiated by a remote device.
	@result		Returns TRUE if the channel is an incoming channel.
*/

- (BOOL)isIncoming;

/*!
    @method		registerForChannelCloseNotification:selector:
	@abstract	Allows a client to register for a channel close notification.
    @discussion	The given selector will be called on the target observer when the L2CAP channel is closed.
				The selector should contain two arguments.  The first is the user notification object. The second
				is the IOBluetoothL2CAPChannel that was closed.
	@param		observer	Target observer object
	@param		inSelector	Selector to be sent to the observer when the L2CAP channel is closed.
	@result		Returns an IOBluetoothUserNotification representing the outstanding L2CAP channel close notification.
				To unregister the notification, call -unregister of the returned IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.
*/

- (IOBluetoothUserNotification *)registerForChannelCloseNotification:(id)observer selector:(SEL)inSelector;
@end

// Informal protocol to describe the L2CAP channel delegate methods:
// If the developer wishes to take advantage of the asynchronous API in Objective C
// these are the methods that may be implemented:

@protocol IOBluetoothL2CAPChannelDelegate
@optional
- (void)l2capChannelData:(IOBluetoothL2CAPChannel*)l2capChannel data:(void *)dataPointer length:(size_t)dataLength;
- (void)l2capChannelOpenComplete:(IOBluetoothL2CAPChannel*)l2capChannel status:(IOReturn)error;
- (void)l2capChannelClosed:(IOBluetoothL2CAPChannel*)l2capChannel;
- (void)l2capChannelReconfigured:(IOBluetoothL2CAPChannel*)l2capChannel;
- (void)l2capChannelWriteComplete:(IOBluetoothL2CAPChannel*)l2capChannel refcon:(void*)refcon status:(IOReturn)error;
- (void)l2capChannelQueueSpaceAvailable:(IOBluetoothL2CAPChannel*)l2capChannel;
@end

extern NSString * const IOBluetoothL2CAPChannelPublishedNotification;
extern NSString * const IOBluetoothL2CAPChannelTerminatedNotification;

/* Deprecated API */

@interface NSObject( IOBluetoothL2CAPChannelDeprecated )

- (IOReturn)registerIncomingDataListener:(IOBluetoothL2CAPChannelIncomingDataListener)listener refCon:(void *)refCon DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;
- (IOReturn)write:(void *)data length:(UInt16)length DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;
+ (IOBluetoothL2CAPChannel *)withL2CAPChannelRef:(IOBluetoothL2CAPChannelRef)l2capChannelRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
- (IOBluetoothL2CAPChannelRef)getL2CAPChannelRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                             IOBluetoothOBEXSession.h                                                                            0100644 0001750 0001750 00000033444 12567444611 037340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	File:		IOBluetoothOBEXSession.h
	Contains:	Bluetooth Transport subclass of the OBEXSession object. 
    Copyright:	(c) 2002-2003 by Apple Computer, Inc. All rights reserved.
	Writers:	Jason Giles
*/

#import <IOKit/IOKitLib.h>

#import <IOBluetooth/objc/IOBluetoothRFCOMMChannel.h>
#import <IOBluetooth/objc/IOBluetoothSDPServiceRecord.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

#import <IOBluetooth/OBEX.h>
#import <IOBluetooth/OBEXBluetooth.h>
#import <IOBluetooth/objc/OBEXSession.h>

//--------------------------------------------------------------------------------------------------------------------------
/*!	@class		IOBluetoothOBEXSession
	@abstract	An OBEX Session with a Bluetooth RFCOMM channel as the transport.
*/

	
//===========================================================================================================================
//	IOBluetoothOBEXSession Class
//===========================================================================================================================

#pragma mark === IOBluetoothOBEXSession ===

@interface IOBluetoothOBEXSession : OBEXSession <IOBluetoothRFCOMMChannelDelegate>
{
	/* All instance variables are protected. Use accessors to get to them if you need to. */
	
	IOBluetoothDevice *				mDevice;					// Bluetooth device we are conversing with.
	BluetoothRFCOMMChannelID		mRFCOMMChannelID;			// RFCOMM channel ID we're talking to.
	IOBluetoothRFCOMMChannel *		mRFCOMMChannel;				// RFCOMM channel we're talking to.
	
	// Buffer to write and varaibles to manage it:
	UInt8	*						outBuffer;
	size_t							bufferSize;
	size_t							currentOffsetInBuffer;
	BOOL							waitingForRfcommSpace;
	
	// Async Open Connection stuff.

	uint32_t										mOpenConnectionTimeout;
	SEL												mOpenConnectionSelector;
	id												mOpenConnectionSelectorTarget;
	void*											mOpenConnectionRefCon;
	IOBluetoothOBEXSessionOpenConnectionCallback	mOpenConnectionCallback;		// C API
	void*											mOpenConnectionCallbackRefCon;	// C API
}


//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		withSDPServiceRecord
	@abstract	Creates a Bluetooth-based OBEX Session using an SDP service record, typically obtained from a device/service
				browser window controller.
	@param		inSDPServiceRecord		A valid SDP service record describing the service (and RFCOMM channel) you want to
										connect to with Bluetooth/OBEX.
	@result		An OBEX session representing the device/rfcomm channel found in the service record. nil if we failed.
	@discussion	Note that this does NOT mean the transport connection was open. It will be opened when OBEXConnect is
				invoked on the session object.
				
				*IMPORTANT NOTE*	In Bluetooth framework version 1.0.0, the session returned will NOT be autoreleased as it
									should be according to objc convention. This has been changed starting in Bluetooth version
									1.0.1 and later, so it WILL be autoreleased upon return, so you will need to retain
									it if you want to reference it later.
*/

+(instancetype) withSDPServiceRecord:(IOBluetoothSDPServiceRecord*)inSDPServiceRecord;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method	withDevice
	@abstract	Creates a Bluetooth-based OBEX Session using a Bluetooth device and a Bluetooth RFCOMM channel ID.
	@param		inDevice				A valid Bluetooth device describing which device you want to connect to
										with Bluetooth/OBEX.
	@param		inRFCOMMChannelID		An RFCOMM Channel ID numbe that is available on the remote device. This channel will
										be used when the transport connection is attempted.
	@result		An OBEX session representing the device/rfcomm channel found in the service record. nil if we failed.
	@discussion	Note that this does NOT mean the transport connection was open. It will be opened when OBEXConnect is
				invoked on the session object.

				*IMPORTANT NOTE*	In Bluetooth framework version 1.0.0, the session returned will NOT be autoreleased as it
									should be according to objc convention. This has been changed starting in Bluetooth version
									1.0.1 and later, so it WILL be autoreleased upon return, so you will need to retain
									it if you want to reference it later.
*/
		
+(instancetype)withDevice:(IOBluetoothDevice*)inDevice
		channelID:(BluetoothRFCOMMChannelID)inRFCOMMChannelID;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		withIncomingRFCOMMChannel
	@abstract	Creates a Bluetooth-based OBEX Session using an incoming RFCOMM channel.
	@param		inChannel				The channel to use to create a connection to a device.
	@param		inEventSelector			The selector that gets called when an event occurs on the OBEX Session.
	@param		inEventSelectorTarget	The object that is used to call the above selector.
	@param		inUserRefCon			The reference constant. Pass whatever you wish - it will be returned to you in the selector.
	@result		
	@discussion	

				*IMPORTANT NOTE*	In Bluetooth framework version 1.0.0, the session returned will NOT be autoreleased as it
									should be according to objc convention. This has been changed starting in Bluetooth version
									1.0.1 and later, so it WILL be autoreleased upon return, so you will need to retain
									it if you want to reference it later.
*/
	
+(instancetype)withIncomingRFCOMMChannel:(IOBluetoothRFCOMMChannel*)inChannel
		eventSelector:(SEL)inEventSelector
		selectorTarget:(id)inEventSelectorTarget
		refCon:(void *)inUserRefCon;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		initWithSDPServiceRecord
	@abstract	Initializes a Bluetooth-based OBEX Session using an SDP service record.
	@param		inSDPServiceRecord		
	@result		
	@discussion	
*/
	
-(instancetype) initWithSDPServiceRecord:(IOBluetoothSDPServiceRecord*)inSDPServiceRecord;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		initWithDevice
	@abstract	Initializes a Bluetooth-based OBEX Session using a Bluetooth device.
	@param		inDevice		The bluetooth device on which to open the OBEXSession.
	@param		inChannelID		The RFCOMM channel ID to use when opening the connection.
	@result		
	@discussion	
*/
		
-(instancetype) initWithDevice:(IOBluetoothDevice*)inDevice
		channelID:(BluetoothRFCOMMChannelID)inChannelID;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		initWithIncomingRFCOMMChannel
	@abstract	Initializes a Bluetooth-based OBEX Session using an incoming RFCOMM channel.
	@param		inChannelID				RFCOMM channel ID of the desired channel to be used.
	@param		inEventSelector			The selector to be called when an event is received.
	@param		inEventSelectorTarget	The target object that get the selector message.
	@param		refCon					caller reference constant, pass whatever you want, it will be returned to you in the selector.		
	@result		
	@discussion	
*/
	
-(instancetype) initWithIncomingRFCOMMChannel:(IOBluetoothRFCOMMChannel*)inChannel
		eventSelector:(SEL)inEventSelector
		selectorTarget:(id)inEventSelectorTarget
		refCon:(void *)inUserRefCon;
		
//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		getRFCOMMChannel
	@abstract	Get the Bluetooth RFCOMM channel being used by the session object.
	@result		A IOBluetoothRFCOMMChannel object.
	@discussion	This could potentially be nil even though you have a valid OBEX session, because the RFCOMM channel is
				only valid when the session is connected.
*/
	
-(IOBluetoothRFCOMMChannel*)getRFCOMMChannel;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		getDevice
	@abstract	Get the Bluetooth Device being used by the session object.
	@result		An IOBluetoothDevice object.
	@discussion	
*/

-(IOBluetoothDevice*)getDevice;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		sendBufferTroughChannel
	@abstract	Sends the next block of data trough the rfcomm channel.
	@result
	@discussion	Since a send in the rfcomm channel is broken in multiple write calls (this actually is true only if the size is grater
	than the rfcomm MTU). Each write call is performed by sendBufferTroughChannel. This should never need to be overwritten.
*/
- (IOReturn)sendBufferTroughChannel;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		restartTransmission
	@abstract	If the transmission was stopeed due to the lack of buffers this call restarts it.
	@result
	@discussion	If the transmission was stopeed due to the lack of buffers this call restarts it.
*/
- (void)restartTransmission;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		isSessionTargetAMac
	@abstract	Tells whether the target device is a Mac by checking its service record.
	@result		TRUE only if device service record has Mac entry, FALSE for all else.
	@discussion	Tells whether the target device is a Mac by checking its service record.
*/
- (BOOL)isSessionTargetAMac;




/* OBEXSession overrides */

#pragma mark -
#pragma mark === OBEXSession overrides ===


//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		openTransportConnection
	@abstract	An OBEXSession override. When this is called by the session baseclass, we will attempt to open the
				transport connection. In our case, this would be an RFCOMM channel to another Bluetooth device.
	@result		Success or failure code.
	@discussion	Your selector should have the following signature:
	
					-(void)transportConnectionSelector:(id)refcon		status:(OBEXError)status;
				
				Thus you could use it with openTransportConnection like this:
				
					OBEXError	error = [anOBEXSession	openTransportConnection:@selector( transportConnectionSelector:status: )
														selectorTarget:self
														refCon:anOBEXSession];	// or whatever you want to pass as a refCon...
				
				Be sure to check the status code! Assume the connection was not opened unless status is kOBEXSuccess.
				
*/

-(OBEXError)openTransportConnection:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;
				
//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		hasOpenTransportConnection
	@abstract	An OBEXSession override. When this is called by the session baseclass, we will return whether or not we
				have a transport connection established to another OBEX server/client. In our case we will tell whether
				or not the RFCOMM channel to a remote device is still open.
	@result		True or false, whether there is already an open transport connection for this OBEX session.
	@discussion	
*/

-(BOOL)hasOpenTransportConnection;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		closeTransportConnection
	@abstract	An OBEXSession override. When this is called by the session baseclass, we will close the transport
				connection if it is opened. In our case, it will be the RFCOMM channel that needs closing.
	@result		Success or failure code, describing whether the call succeeded in closing the transport connection successfully.
	@discussion	
*/

-(OBEXError)closeTransportConnection;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@method		sendDataToTransport
	@abstract	An OBEXSession override. When this is called by the session baseclass, we will send the data we are given
				over our transport connection. If none is open, we could try to open it, or just return an error. In our
				case, it will be sent over the RFCOMM channel.
	@result		Success or failure code, describing whether the call succeeded in writing the data to the transport.
	@discussion	
*/

-(OBEXError)sendDataToTransport:(void *)inDataToSend
			dataLength:(size_t)inDataLength;
			

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setOpenTransportConnectionAsyncSelector
	@abstract	Allows you to set the selector to be used when a transport connection is opened, or fails to open.
	@param		inEventSelector				Selector to call on the target.
	@param		inEventSelectorTarget		Target to be called with the selector.
	@param		inUserRefCon				User's refCon that will get passed to them when their selector is invoked.
	@discussion	You do not need to call this on the session typically, unless you have subclassed the OBEXSession to
				implement a new transport and that transport supports async opening of connections. If it does not support
				async open, then using this is pointless.
*/

-(void)setOpenTransportConnectionAsyncSelector:(SEL)inSelector
			target:(id)inSelectorTarget
			refCon:(id)inUserRefCon;
			
//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setOBEXSessionOpenConnectionCallback
	@abstract	For C API support. Allows you to set the callback to be invoked when the OBEX connection is actually opened.
	@param		inCallback			function to call on the target.
	@param		inUserRefCon		user's reference constant, will be returned on the callback.
*/

-(void)setOBEXSessionOpenConnectionCallback:(IOBluetoothOBEXSessionOpenConnectionCallback)inCallback
			refCon:(void*)inUserRefCon;
			
			
@end
                                                                                                                                                                                                                            IOBluetoothObject.h                                                                                 0100644 0001750 0001750 00000000714 12567444611 036437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            //
//  IOBluetoothObject.h
//  IOBluetoothFamily
//
//  Copyright (c) 2002-2012 Apple Inc. All rights reserved.
//

#import <Foundation/Foundation.h>

#import <IOKit/IOKitLib.h>

@interface IOBluetoothObject : NSObject <NSCopying>
{
    io_service_t		mIOService;
    io_connect_t		mIOConnection;
    
    io_iterator_t		mIONotification;
}

@end

#define kBluetoothTargetDoesNotRespondToCallbackExceptionName	@"BluetoothTargetDoesNotRespondToCallbackException"
                                                    IOBluetoothRFCOMMChannel.h                                                                          0100644 0001750 0001750 00000036665 12567444611 037523  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothRFCOMMChannel.h
    Copyright:	 2002 by Apple Computer, Inc. All rights reserved.
*/
 
#import <Foundation/Foundation.h>
#import <IOKit/IOKitLib.h>
#import <IOKit/IODataQueueShared.h>
#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>
#import <IOBluetooth/objc/IOBluetoothObject.h>
#import <IOBluetooth/objc/IOBluetoothUserNotification.h>

@class IOBluetoothDevice;
@class IOBluetoothL2CAPChannel;
@class IOBluetoothRFCOMMConnection;


/*!
    @class IOBluetoothRFCOMMChannel
    @abstract An instance of this class represents an rfcomm channel as defined by the Bluetooth SDP spec..
    @discussion An RFCOMM channel object can be obtained by opening an rfcomm channel in a device, or
    by requesting a notification when a channel is created (this is commonly used to provide services).
*/

@interface IOBluetoothRFCOMMChannel : IOBluetoothObject <NSPortDelegate>
{
    BOOL											mChannelIsOpen;
    UInt16											mMTU;
    BOOL											mIsIncoming;

    IOBluetoothDevice								*mDevice;
    IOBluetoothL2CAPChannel							*mL2Channel;

    NSPort											*mDataAvailablePort;
    IODataQueueMemory								*mIncomingDataQueue;

	id												delegate;
	
    id												mIncomingDataListener; // legacy unused
    void											*mIncomingDataListenerRefCon;

    id												mEventDataListener; // legacy unused
    void											*mEventDataListenerRefCon;
    
    IOBluetoothObjectID								mObjectID;
    
    BluetoothRFCOMMChannelID                                                    mChannelID;
    
    void											*_mReserved;
}

/*!
	@method	registerForChannelOpenNotifications:selector:
	@abstract	Allows a client to register for RFCOMM channel open notifications for any RFCOMM channel.
	@discussion	The given selector will be called on the target object whenever any RFCOMM channel is opened.
				The selector should accept two arguments.  The first is the user notification object.  The second
				is the IOBluetoothRFCOMMChannel that was opened.
	@param		rfcommChannelRef IOBluetoothRFCOMMChannelRef for which an IOBluetoothRFCOMMChannel * is desired.
	@param		object		Target object
	@param		selector	Selector to be called on the target object when a new RFCOMM channel is opened.
				the format for the selector is: 
				-(void) selectorName:(IOBluetoothUserNotification *)inNotification channel:(IOBluetoothRFCOMMChannel *)newChannel
	@result		Returns an IOBluetoothUserNotification representing the outstanding RFCOMM channel notification.
				To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.  The returned
				IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
				not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
*/

+ (IOBluetoothUserNotification *)registerForChannelOpenNotifications:(id)object selector:(SEL)selector;

/*!
    @method	registerForChannelOpenNotifications:selector:
	@abstract	Allows a client to register for RFCOMM channel open notifications for certain types of
				RFCOMM channels.
	@discussion	The given selector will be called on the target object whenever an RFCOMM channel with the given
				attributes is opened.  The selector should accept two arguments.  The first is the user 
				notification object.  The second is the IOBluetoothRFCOMMChannel that was opened.
	@param		object		Target object
	@param		selector	Selector to be called on the target object when a new RFCOMM channel is opened.
				the format for the selector is: 
				-(void) selectorName:(IOBluetoothUserNotification *)inNotification channel:(IOBluetoothRFCOMMChannel *)newChannel
	@param		channeLID	RFCOMM channel ID to match a new RFCOMM channel.  If the channel ID doesn't matter, 0 may be passed in.
	@param		inDirection	The desired direction of the RFCOMM channel - kIOBluetoothUserNotificationChannelDirectionAny
				if the direction doesn't matter.
	@result		Returns an IOBluetoothUserNotification representing the outstanding RFCOMM channel notification.
				To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.  The returned
				IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
				not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
*/

+ (IOBluetoothUserNotification *)registerForChannelOpenNotifications:(id)object selector:(SEL)selector withChannelID:(BluetoothRFCOMMChannelID)channelID direction:(IOBluetoothUserNotificationChannelDirection)inDirection;

/*!	@method	withRFCOMMChannelRef:
	@abstract	Method call to convert an IOBluetoothRFCOMMChannelRef into an IOBluetoothRFCOMMChannel *.
        @param	rfcommChannelRef IOBluetoothRFCOMMChannelRef for which an IOBluetoothRFCOMMChannel * is desired.
	@result		Returns the IOBluetoothRFCOMMChannel * for the given IOBluetoothRFCOMMChannelRef.
*/
+ (instancetype)withRFCOMMChannelRef:(IOBluetoothRFCOMMChannelRef)rfcommChannelRef;

/*!
    @method	withObjectID:
	@abstract	Returns the IObluetoothRFCOMMChannel with the given IOBluetoothObjectID.
	@discussion	The IOBluetoothObjectID can be used as a global reference for a given IObluetoothRFCOMMChannel.  It allows
				two separate applications to refer to the same IObluetoothRFCOMMChannel object.
	@param		objectID	IOBluetoothObjectID of the desired IObluetoothRFCOMMChannel.
	@result		Returns the IObluetoothRFCOMMChannel that matches the given IOBluetoothObjectID if one exists.
				If no matching RFCOMM channel exists, nil is returned.
*/

+ (instancetype)withObjectID:(IOBluetoothObjectID)objectID;

/*!	@method	getRFCOMMChannelRef
	@abstract	Returns an IOBluetoothRFCOMMChannelRef representation of the target IOBluetoothRFCOMMChannel object.
	@result		Returns an IOBluetoothRFCOMMChannelRef representation of the target IOBluetoothRFCOMMChannel object.
*/
- (IOBluetoothRFCOMMChannelRef)getRFCOMMChannelRef;

/*!
    @method closeChannel
    @abstract Close the channel.
    @result An error code value. 0 if successful.
*/

- (IOReturn)closeChannel;

/*!
    @method isOpen
    @abstract Returns the state of the channel. 
    @discussion	note that "not open" means closed, opening and closing.
    @result TRUE if the channel state is open,  FALSE otherwise.
*/

- (BOOL)isOpen;

/*!
    @method getMTU
    @abstract Returns the channel maximum transfer unit.
    @discussion Returns the length of the largest chunk of data that this channel can carry. If the
    caller wishes to use the write:length:sleep: api the length of the data can not be bigger than
    the channel MTU (maximum transfer unit). 
    @result Channel MTU size .
*/

- (BluetoothRFCOMMMTU)getMTU;

/*!
    @method isTransmissionPaused
    @abstract Returns TRUE if flow control is off.
    @discussion Returns true if the remote device flow control is stopping out transmission. This is
            useful because we do not buffer data, we stop the transmitting actor. With this method
            the transmitter can check if sending data is going to be successful or is going to block.
    @result TRUE if the action of sending data will block the current thread, FALSE otherwise.

*/

- (BOOL)isTransmissionPaused;

/*!
    @method  write:length:sleep:
    @abstract Sends a block of data in the channel syncronously.
    @discussion	***WARNING*** This method is being deprecated in favor of -writeSync:... and -writeAsync:...
				Sends data through the channel. The number of bytes to be sent must not exceed the channel MTU. 
				If the return value is an error condition none of the data was sent.
    @param data is a pointer to the data buffer to be sent.
    @param length the length of the buffer to be sent (in bytes).
    @param sleep is a boolean if set to TRUE the call will wait until it is possible to send data.
    If set to FALSE and it is not possible to send data the method will return immediately with an
    error.
    @result An error code value. 0 if successful. 
*/

- (IOReturn)write:(void *)data length:(UInt16)length sleep:(BOOL)sleep DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
    @method  writeAsync:length:refcon:
    @abstract Sends a block of data in the channel asynchronously.
    @discussion The number of bytes to be sent must not exceed the channel MTU. 
				If the return value is an error condition none of the data was sent.  Once the data
				has been successfully passed to the hardware to be transmitted, the delegate method
				-rfcommChannelWriteComplete:refcon:status: will be called with the refcon that was passed
				to this method.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
    @param		data A pointer to the data buffer to be sent.
    @param		length The length of the buffer to be sent (in bytes).
	@param		refcon User supplied value that gets passed to the write callback.
    @result		Returns kIOReturnSuccess if the data was buffered successfully. 
*/

- (IOReturn)writeAsync:(void *)data length:(UInt16)length refcon:(void*)refcon;

/*!
    @method  writeSync:length:
    @abstract Sends a block of data in the channel synchronously.
    @discussion	Sends data through the channel. The number of bytes to be sent must not exceed the channel MTU. 
				If the return value is an error condition none of the data was sent.  This method will
				block until the data has been successfully sent to the hardware for transmission (or until
				an error occurs).

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
    @param		data A pointer to the data buffer to be sent.
    @param		length The length of the buffer to be sent (in bytes).
	@result		Returns kIOReturnSuccess if the data was written successfully.
*/

- (IOReturn)writeSync:(void *)data length:(UInt16)length;

/*!
    @method  writeSimple:length:sleep:
    @abstract Sends a block of data in the channel.
    @discussion ***WARNING*** This method is being deprecated in favor of -writeSync:... and -writeAsync:...
				Sends data through the channel. The number of bytes to be sent is arbitrary. The caller
				does not have to worry about the MTU. 
    @param data a pointer to the data buffer to be sent.
    @param length the length of the buffer to be sent (in bytes).
    @param sleep a boolean if set to TRUE the call will wait until it is possible to send all the data.
    @param a UInt32 pointer in which the caller received the nuber of bytes sent.
    If set to FALSE and it is not possible to send part of the data the method will return immediately.
    @result An error code value. 0 if successful.
*/

- (IOReturn)writeSimple:(void *)data length:(UInt16)length sleep:(BOOL)sleep bytesSent:(UInt32 *)numBytesSent DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
    @method  setSerialParameters:dataBits:parity:stopBits:
    @abstract Changes the parameters of the serial connection. 
    @param speed the baudrate.
    @param nBits number of data bits.
    @param parity the type of parity can be NoParity, OddParity, EvenParity or MaxParity.
    @param bitStop number of stop bits.
    @result An error code value. 0 if successful. 
*/

- (IOReturn)setSerialParameters:(UInt32)speed dataBits:(UInt8)nBits parity:(BluetoothRFCOMMParityType)parity stopBits:(UInt8)bitStop;

/*!
    @method  sendRemoteLineStatus:
    @abstract Sends an error to the remote side. 
    @param lineStatus the error type. The error code can be NoError, OverrunError, ParityError or FramingError.
    @result An error code value. 0 if successful. 
*/

- (IOReturn)sendRemoteLineStatus:(BluetoothRFCOMMLineStatus)lineStatus;


/*!
    @method		setDelegate:
	@abstract	Allows an object to register itself as a client of the RFCOMM channel.
    @discussion A channel delegate is the object the RFCOMM channel uses as target for data and events. The
				developer will implement only the the methods he/she is interested in. A list of the
				possible methods is at the end of this file in the definition of the informal protocol
				IOBluetoothRFCOMMChannelDelegate.

				NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
				NOTE: Before Mac OS X 10.6, the delegate was retained.  On 10.6 and later, it is not.
	@param		delegate	The object that will play the role of channel delegate [NOTE the rfcomm channel will reatin the delegate].
	@result		Returns kIOReturnSuccess if the delegate is successfully registered.
*/

- (IOReturn)setDelegate:(id)delegate;

/*!
 @method	delegate
 @abstract	Returns the object delegate
 @result	the current delegate, or nil
 */
- (id) delegate;

/*!
    @method channelNumber
    @abstract Returns the object rfcomm channel ID. 
    @result the RFCOMM channel number .
*/

- (BluetoothRFCOMMChannelID)getChannelID;

/*!
    @method isIncoming
    @abstract	Returns the direction of the channel.  An incoming channel is one that was opened by the remote
                device. 
    @result 	Returns TRUE if the channel was opened by the remote device, FALSE if the channel was opened by this object.
*/

- (BOOL)isIncoming;

/*!
    @method getDevice
    @abstract Returns the Bluetooth Device that carries the rfcomm data. 
    @result the IOBluetoothDevice object .
*/

- (IOBluetoothDevice *)getDevice;

/*!
    @method		getObjectID
	@abstract	Returns the IOBluetoothObjectID of the given IOBluetoothRFCOMMChannel.
    @discussion	The IOBluetoothObjectID can be used as a global reference for a given IOBluetoothRFCOMMChannel.  It allows
				two separate applications to refer to the same IOBluetoothRFCOMMChannel.
	@result		Returns the IOBluetoothObjectID of the given IOBluetoothRFCOMMChannel.
*/

- (IOBluetoothObjectID)getObjectID;

/*!
    @method		registerForChannelCloseNotification:selector:
	@abstract	Allows a client to register for a channel close notification.
    @discussion	The given selector will be called on the target observer when the RFCOMM channel is closed.
				The selector should contain two arguments.  The first is the user notification object. The second
				is the IOBluetoothRFCOMMChannel that was closed.
	@param		observer	Target observer object
	@param		inSelector	Selector to be sent to the observer when the RFCOMM channel is closed.
	@result		Returns an IOBluetoothUserNotification representing the outstanding RFCOMM channel close notification.
				To unregister the notification, call -unregister of the returned IOBluetoothUserNotification 
				object.  If an error is encountered creating the notification, nil is returned.
*/

- (IOBluetoothUserNotification *)registerForChannelCloseNotification:(id)observer selector:(SEL)inSelector;

@end

// protocol to describe the RFCOMM channel delegate methods:
// If the developer wishes to take advantage of the asynchronous API in Objective C
// these are the methods that may be implemented:

@protocol IOBluetoothRFCOMMChannelDelegate
@optional
- (void)rfcommChannelData:(IOBluetoothRFCOMMChannel*)rfcommChannel data:(void *)dataPointer length:(size_t)dataLength;
- (void)rfcommChannelOpenComplete:(IOBluetoothRFCOMMChannel*)rfcommChannel status:(IOReturn)error;
- (void)rfcommChannelClosed:(IOBluetoothRFCOMMChannel*)rfcommChannel;
- (void)rfcommChannelControlSignalsChanged:(IOBluetoothRFCOMMChannel*)rfcommChannel;
- (void)rfcommChannelFlowControlChanged:(IOBluetoothRFCOMMChannel*)rfcommChannel;
- (void)rfcommChannelWriteComplete:(IOBluetoothRFCOMMChannel*)rfcommChannel refcon:(void*)refcon status:(IOReturn)error;
- (void)rfcommChannelQueueSpaceAvailable:(IOBluetoothRFCOMMChannel*)rfcommChannel;

@end
                                                                           IOBluetoothSDPDataElement.h                                                                         0100644 0001750 0001750 00000034050 12567444611 037763  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothSDPDataElement.h
    Copyright:	 2002 by Apple Computer, Inc. All rights reserved.
	Writers:	Eric Brown
*/

#import <Foundation/Foundation.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

@class IOBluetoothSDPUUID;

/*!
    @class IOBluetoothSDPDataElement
    @abstract An instance of this class represents a single SDP data element as defined by the Bluetooth SDP spec.
    @discussion The data types described by the spec have been mapped onto the base Foundation classes NSNumber, 
                NSArray, NSData as well as IOBluetoothSDPUUID.  The number and boolean types (type descriptor 1, 2 
                and 5) are represented as NSNumber objects with the exception of 128-bit numbers which are 
                represented as NSData objects in their raw format.  The UUID type (type descriptor 3) is 
                represented by IOBluetoothSDPUUID.  The string and URL types (type descriptor 4 and 8) are 
                represented by NSString.  The sequence types (type descriptor 6 and 7) are represented by NSArray.
                
                Typically, you will not need to create an IOBluetoothSDPDataElement directly, the system will
                do that automatically for both client and server operations.  However, the current API for adding 
                SDP services to the system does allow the use of an NSDictionary based format for creating new 
                services.  The purpose for that is to allow a service to be built up completely in a text file
                (a plist for example) and then easily imported into an app and added to the system without a 
                lot of tedious code to build up the entire SDP service record.
                
                The basis for that NSDictionary structure comes from the IOBluetoothSDPDataElement.  At its
                simplest, a data element is made up of three parts: the type descriptor, the size (from which
                the size descriptor is generated) and the actual value.  To provide a complete representation
                of a data element, an NSDictionary with three entries can be used.  Each of the three entries
                has a key/value pair representing one of the three attributes of a data element.  The first
                key/value pair has a key 'DataElementType' that contains a number value with the actual
                type descriptor for the data element.  The second pair has a key 'DataElementSize' that
                contains the actual size of the element in bytes.  The size descriptor will be calculated
                based on the size and type of the element.  The third pair is the value itself whose key is
                'DataElementValue' and whose type corresponds to the type mapping above.
                
                In addition to this complete description of a data element, their are some shortcuts that
                can be used for some of the common types and sizes.
                
                If the 'DataElementType' value is one of the numeric types (1, 2), the 'DataElementValue' 
                can be an NSData instead of an NSNumber.  In that case, the numeric data is taken in network 
                byte order (MSB first).  Additionally, the 'DataElementSize' parameter may be omitted and the 
                size will be taken from the length of the data object.
                
                If the 'DataElementType' value is the nil type (0), no 'DataElementSize' or 'DataElementValue'
                entries are needed.
                
                If the 'DataElementType' value is any of the other types, the 'DataElementSize' entry is not
                needed since the size will be taken directly from the value (data, array, string).
                
                In the case where the element is an unsigned, 32-bit integer (type descriptor 1, size descriptor
                4), the value itself may simply be a number (instead of a dictionary as in the previous examples).
                
                In the case where the element is a UUID (type descriptor 3), the value itself may be a data object.  
                The UUID type will be inferred and the size taken from the length of the data object.
                
                In the case where the element is a text string (type descriptor 4), the value may be a string object.
                The text string type will be inferred and the size taken from the length of the string.
                
                In the case where the element is a data element sequence, the value may be an array object.  The
                type will be inferred and the size taken from the length of the array.  Additionally, the array
                must contain sub-elements that will be parsed out individually.
*/

@interface IOBluetoothSDPDataElement : NSObject <NSCoding> {
    BluetoothSDPDataElementTypeDescriptor	mTypeDescriptor;
    BluetoothSDPDataElementSizeDescriptor	mSizeDescriptor;
    uint32_t								mSize;
    NSObject								*mValue;
    
    void									*_mReserved;
}

/*!
    @method withElementValue:
    @abstract Creates a new IOBluetoothSDPDataElement with the given value.
    @discussion The value must follow the format listed above and must be an instance of NSData, NSString, NSNumber, 
                NSArray, NSDictionary, IOBluetoothSDPUUID.
    @param element	The data element value of one of the specified types. 
    @result Returns the newly allocated data element object.  Returns nil if there was an error parsing the element
            value.  The returned IOBluetoothSDPDataElement object has been autoreleased, so it is not necessary
            for the caller to release it.  If the object is to be referenced and kept around, retain should be
            called.
*/

+ (instancetype)withElementValue:(NSObject *)element;

/*!
    @method withType:sizeDescriptor:size:value:
    @abstract Creates a new IOBluetoothSDPDataElement with the given attributes.
    @discussion Warning - be careful using this method.  There is next to no error checking done on the 
                attributes.  It is entirely possible to construct an invalid data element.  It is recommended
                that +withElementValue: be used instead of this one.
    @param typeDescriptor The type descriptor for the data element.
    @param sizeDescriptor The size descriptor for the data element (verify it matches the size parameter).
    @param size The size of the data element in bytes (make sure it is a valid size for the given size descriptor).
    @param value The raw value itself.  This must be the base NSString, NSNumber, NSArray or NSData objects.  It
                    may not be NSDictionary.  If a dictionary format is present, use +withElementValue:.
    @result Returns the newly allocated data element object.  Returns nil if an error is encountered (not likely
                    due to the limited error checking currently done).  The returned IOBluetoothSDPDataElement 
                    object has been autoreleased, so it is not necessary for the caller to release it.  If the 
                    object is to be referenced and kept around, retain should be called.
*/

+ (instancetype)withType:(BluetoothSDPDataElementTypeDescriptor)type sizeDescriptor:(BluetoothSDPDataElementSizeDescriptor)newSizeDescriptor size:(uint32_t)newSize value:(NSObject *)newValue;

/*!
    @method	withSDPDataElementRef:
	@abstract	Method call to convert an IOBluetoothSDPDataElementRef into an IOBluetoothSDPDataElement *.
        @param	sdpDataElementRef IOBluetoothSDPDataElementRef for which an IOBluetoothSDPDataElement * is desired.
	@result		Returns the IOBluetoothSDPDataElement * for the given IOBluetoothSDPDataElementRef.
*/

+ (instancetype)withSDPDataElementRef:(IOBluetoothSDPDataElementRef)sdpDataElementRef;

/*!
    @method initWithElementValue:
    @abstract Initializes a new IOBluetoothSDPDataElement with the given value.
    @discussion The value must follow the format listed above and must be an instance of NSData, NSString, NSNumber, 
                NSArray, NSDictionary, IOBluetoothSDPUUID.
    @param element	The data element value of one of the specified types. 
    @result Returns self if successful.  Returns nil if there was an error parsing the element value.
*/

- (instancetype)initWithElementValue:(NSObject *)element;

/*!
    @method initWithType:sizeDescriptor:size:value:
    @abstract Initializes a new IOBluetoothSDPDataElement with the given attributes.
    @discussion Warning - be careful using this method.  There is next to no error checking done on the 
                attributes.  It is entirely possible to construct an invalid data element.  It is recommended
                that +withElementValue: be used instead of this one.
    @param typeDescriptor The type descriptor for the data element.
    @param sizeDescriptor The size descriptor for the data element (verify it matches the size parameter).
    @param size The size of the data element in bytes (make sure it is a valid size for the given size descriptor).
    @param value The raw value itself.  This must be the base NSString, NSNumber, NSArray or NSData objects.  It
                    may not be NSDictionary.  If a dictionary format is present, use +withElementValue:.
    @result Returns self if successful.  Returns nil if an error is encountered (not likely
                    due to the limited error checking currently done).
*/

- (instancetype)initWithType:(BluetoothSDPDataElementTypeDescriptor)newType sizeDescriptor:(BluetoothSDPDataElementSizeDescriptor)newSizeDescriptor size:(uint32_t)newSize value:(NSObject *)newValue;

/*!
    @method	getSDPDataElementRef
	@abstract	Returns an IOBluetoothSDPDataElementRef representation of the target IOBluetoothSDPDataElement object.
	@result		Returns an IOBluetoothSDPDataElementRef representation of the target IOBluetoothSDPDataElement object.
*/

- (IOBluetoothSDPDataElementRef)getSDPDataElementRef;

/*!
    @method getTypeDescriptor
    @abstract Returns the SDP spec defined data element type descriptor for the target data element.
    @result Returns the type descriptor for the target data element.
*/

- (BluetoothSDPDataElementTypeDescriptor)getTypeDescriptor;

/*!
    @method getSizeDescriptor
    @abstract Returns the SDP spec defined data element size descriptor for the target data element.
    @result Returns the size descriptor for the target data element.
*/

- (BluetoothSDPDataElementSizeDescriptor)getSizeDescriptor;

/*!
    @method getSize
    @abstract Returns the size in bytes of the target data element.
    @discussion The size is valid whether the data element has a fixed or variable size descriptor.
    @result Returns the size in bytes of the target data element.
*/

- (uint32_t)getSize;

/*!
    @method getNumberValue
    @abstract If the data element is represented by a number, it returns the value as an NSNumber.
    @discussion The data types represented by a number are 1 (unsigned int), 2 (signed int) and 5 (boolean) 
                except for 128-bit versions of 1 and 2.
    @result Returns an NSNumber representation of the data element if it is a numeric type.
*/

- (NSNumber *)getNumberValue;

/*!
    @method getDataValue
    @abstract If the data element is represented by a data object, it returns the value as an NSData.
    @discussion The data types represented by a data object are 128-bit versions of 1 (unsigned int) and 
                2 (signed int).
    @result Returns an NSData representation of the data element if it is a 128-bit number.
*/

- (NSData *)getDataValue;

/*!
    @method getStringValue
    @abstract If the data element is represented by a string object, it returns the value as an NSString.
    @discussion The data types represented by a string object are 4 (text string) and 8 (URL).
    @result Returns an NSString representation of the data element if it is a text or URL type.
*/

- (NSString *)getStringValue;

/*!
    @method getArrayValue
    @abstract If the data element is represented by an array object, it returns the value as an NSArray.
    @discussion The data types represented by an array object are 6 (data element sequence) and 7 (data
                element alternative).
    @result Returns an NSArray representation of the data element if it is a sequence type.
*/

- (NSArray *)getArrayValue;

/*!
    @method getUUIDValue
    @abstract If the data element is a UUID (type 3), it returns the value as an IOBluetoothSDPUUID.
    @result Returns an IOBluetoothSDPUUID representation of the data element if it is a UUID.
*/

- (IOBluetoothSDPUUID *)getUUIDValue;

/*!
    @method getValue
    @abstract Returns the object value of the data element.
    @discussion The value returned may be an NSNumber, NSString, NSData, NSArray or IOBluetoothSDPDataElement
                depending on the type of the data element.
    @result Returns the object value of the target data element.
*/

- (NSObject *)getValue;

/*!
    @method containsDataElement:
    @abstract Checks to see if the target data element is the same as the dataElement parameter or if it contains
                the dataElement parameter (if its a sequence type).
    @discussion If the target data element is not a sequence type, this method simply compares the two data elements.  If
                it is a sequence type, it will search through the sequence (and sub-sequences) for the dataElement
                parameter.
    @param dataElement The data element to compare with (and search for). 
    @result Returns TRUE if the target either matches the given data element or if it contains the given data element.
*/

- (BOOL)containsDataElement:(IOBluetoothSDPDataElement *)dataElement;

/*!
    @method containsValue:
    @abstract Checks to see if the target data element's value is the same as the value parameter or if it contains
                the value parameter.
    @discussion This method works just like -containsDataElement: except that it is comparing the value objects directly.
    @param cmpValue The value to compare with (and search for).
    @result Returns TRUE if the target's value either matches the given value or if it contains the given value.
*/

- (BOOL)containsValue:(NSObject *)cmpValue;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        IOBluetoothSDPServiceAttribute.h                                                                    0100644 0001750 0001750 00000010403 12567444611 041060  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothSDPServiceAttribute.h
    Copyright:	 2002 by Apple Computer, Inc. All rights reserved.
*/

#import <Foundation/Foundation.h>

#import <IOBluetooth/Bluetooth.h>

@class IOBluetoothSDPDataElement;

/*!
    @class IOBluetoothSDPServiceAttribute
    @abstract IOBluetoothSDPServiceAttribute represents a single SDP service attribute.
    @discussion A service attribute contains two components: an attribute ID and a data element.
*/

@interface IOBluetoothSDPServiceAttribute : NSObject <NSCoding> {
    BluetoothSDPServiceAttributeID	mAttributeID;
    IOBluetoothSDPDataElement		*mAttributeDataElement;
    IOBluetoothSDPDataElement		*mAttributeIDDataElement;
    
    void							*_mReserved;
}

/*!
    @method withID:attributeElementValue:
    @abstract Creates a new service attribute with the given ID and element value.
    @discussion See +[IOBluetoothSDPDataElement withElementValue:] for a description of the types that 
                may be passed in as the attributeElementValue.
    @param attributeID The attribute ID of the new service attribute.
    @param attributeElementValue The data element value of the new service attribute
    @result Returns the newly allocated service attribute object.  Returns nil if there was an error parsing the 				element value.  The returned IOBluetoothSDPDataElement object has been autoreleased, so it is not 
            necessary for the caller to release it.  If the object is to be referenced and kept around, retain 
            should be called.
*/

+ (instancetype)withID:(BluetoothSDPServiceAttributeID)newAttributeID attributeElementValue:(NSObject *)attributeElementValue;

/*!
    @method withID:attributeElement:
    @abstract Creates a new service attribute with the given ID and data element.
    @param attributeID The attribute ID of the new service attribute.
    @param attributeElement The data element of the new service attribute.
    @result Returns the newly allocated service attribute object.  Returns nil if there was an error.  
            The returned IOBluetoothSDPDataElement object has been autoreleased, so it is not 
            necessary for the caller to release it.  If the object is to be referenced and kept around, retain 
            should be called.
*/

+ (instancetype)withID:(BluetoothSDPServiceAttributeID)newAttributeID attributeElement:(IOBluetoothSDPDataElement *)attributeElement;

/*!
    @method initWithID:attributeElementValue:
    @abstract Initializes a new service attribute with the given ID and element value.
    @discussion See +[IOBluetoothSDPDataElement withElementValue:] for a description of the types that 
                may be passed in as the attributeElementValue.
    @param attributeID The attribute ID of the new service attribute.
    @param attributeElementValue The data element value of the new service attribute
    @result Returns self if successful.  Returns nil if there was an error parsing the element value.
*/

- (instancetype)initWithID:(BluetoothSDPServiceAttributeID)newAttributeID attributeElementValue:(NSObject *)attributeElementValue;

/*!
    @method initWithID:attributeElement:
    @abstract Initializes a new service attribute with the given ID and data element.
    @param attributeID The attribute ID of the new service attribute.
    @param attributeElement The data element of the new service attribute.
    @result Returns self if successful.  Returns nil if there was an error.
*/

- (instancetype)initWithID:(BluetoothSDPServiceAttributeID)newAttributeID attributeElement:(IOBluetoothSDPDataElement *)attributeElement;

/*!
    @method getAttributeID
    @abstract Returns the attribute ID for the target service attribute.
    @result Returns the attribute ID for the target service attribute.
*/

- (BluetoothSDPServiceAttributeID)getAttributeID;

/*!
    @method getDataElement
    @abstract Returns the data element for the target service attribute.
    @result Returns the data element for the target service attribute.
*/

- (IOBluetoothSDPDataElement *)getDataElement;

/*!
    @method getIDDataElement
    @abstract Returns the data element representing the attribute ID for the target service attribute.
    @result Returns the data element representing the attribute ID for the target service attribute.
*/

- (IOBluetoothSDPDataElement *)getIDDataElement;

@end
                                                                                                                                                                                                                                                             IOBluetoothSDPServiceRecord.h                                                                       0100644 0001750 0001750 00000032367 12567444611 040350  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothSDPServiceRecord.h
    Copyright:	 2002 by Apple Computer, Inc. All rights reserved.
	Writers:	Eric Brown
*/

#import <Foundation/Foundation.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

@class IOBluetoothDevice;
@class IOBluetoothSDPDataElement;

/*!
    @class IOBluetoothSDPServiceRecord
    @abstract An instance of this class represents a single SDP service record.
    @discussion As a service record, an instance of this class has an NSDictionary of service attributes.
                It also has a link to the IOBluetoothDevice that the service belongs to.  The service
                dictionary is keyed off of the attribute ID of each attribute represented as an NSNumber.
*/

@interface IOBluetoothSDPServiceRecord : NSObject <NSCoding> {
    NSDictionary		*mAttributeDictionary;
    IOBluetoothDevice	*mDeviceForService;
    
    NSArray *sortedAttributes;
}

/*!
 @method		publishedServiceRecordWithDictionary:
 @abstract      Adds a service to the local SDP server.
 @result		Returns an IOBluetoothSDPServiceRecord * with the attributes specified in the provided dictionary.

 @discussion	Each entry in the dictionary representing the service contains the individual attributes.  Each
 attribute in the dict is keyed by a string that must begin with a hex number representing the
 attribute ID.  The key string may contain additional characters if desired as long as they
 follow a space after the ID hex string.  The attribute value must follow the dictionary format
 described by IOBluetoothSDPDataElement.  This dictionary format allows a service dict to be
 created as a plist file and then loaded into the system rather than built up in code.  See the
 example code for an example of how can be done.
 
 If the service record handle, L2CAP PSM or RFCOMM channel ID specified in the dictionary are in
 use, an alternate one will be assigned.
 
 In addition to attributes that represent the service itself, additional attributes may be specified
 that control the local behavior of the service.  To specify these local attributes, an additional
 property titled "LocalAttributes" may be added to the root of the service dict.  The value of this
 property must be a dictionary that contains the individual local attributes.
 
 Currently, only two local attributes are supported: "Persistent" and "TargetApplication".
 
 The "Persistent" local attribute must be either a boolean or number representing whether the service
 should be persistent.  A persistent service will be saved off and restored any time the Bluetooth
 hardware is present.  It will persist through reboots and can only be removed by calling
 IOBluetoothRemoveServiceWithRecordHandle().  This attribute is optional.  By default, if no
 "Persistent" local property is present,	the service will only exist temporarily.  It will
 be removed either when IOBluetoothRemoveServiceWithRecordHandle() is called or when the client
 application exits.
 
 The "TargetApplication" local attribute is used to specify an application to be launched when a
 remote device attempts to connect to the service (by opening either an L2CAP or RFCOMM channel of
 the type specified in the service).  This value must be a string representing the absolute path to
 the target executable (not just the .app wrapper - i.e.
 /System/Library/CoreServices/OBEXAgent.app/Contents/MacOS/OBEXAgent).  This attribute is optional.
 If no "TargetApplication" local attribute is specified, no special action will take place when an
 incoming connection to the service is created.  It is up to the client to be monitoring for the
 connection and to do the right thing when one appears.
 
 The "LocalAttributes" property is optional.  If it is not specified, by default the created service
 is transient and will be removed when the client exits.
 
 Additional local attributes to further control incoming services will be added in the future.
 
 @param		serviceDict	A dictionary containing the attributes for the new service 
*/

+ (instancetype)publishedServiceRecordWithDictionary:(NSDictionary *)serviceDict;

//--------------------------------------------------------------------------------------------------------------------------
/*!	@function	removeServiceRecord
 @abstract	Removes the service from the local SDP server.
 @result		Returns kIOReturnSuccess if successful.
 */

- (IOReturn) removeServiceRecord;

/*!
    @method		withServiceDictionary:device:
	@abstract	Returns an IOBluetoothSDPServiceRecord * with the attributes specified in the provided service dictionary. Provide
				a pointer to an IOBlueotothDevice if you wish to associate the record to a specific IOBluetoothDevice.
	@result		Returns an IOBluetoothSDPServiceRecord * with the attributes specified in the provided dictionary.
*/

+ (instancetype)withServiceDictionary:(NSDictionary *)serviceDict	device:(IOBluetoothDevice *)device;

/*!
    @method		initWithServiceDictionary
	@abstract	Returns an initialized IOBluetoothSDPServiceRecord * with the attributes specified in the provided service dictionary. Provide
				a pointer to an IOBlueotothDevice if you wish to associate the record to a specific IOBluetoothDevice.
	@result		Returns an initialized IOBluetoothSDPServiceRecord * with the attributes specified in the provided dictionary.
*/

- (instancetype) initWithServiceDictionary:(NSDictionary *)serviceDict device:(IOBluetoothDevice *)device;

/*!
    @method		withSDPServiceRecordRef:
	@abstract	Method call to convert an IOBluetoothSDPServiceRecordRef into an IOBluetoothSDPServiceRecord *.
	@param		sdpServiceRecordRef IOBluetoothSDPServiceRecordRef for which an IOBluetoothSDPServiceRecord * is desired.
	@result		Returns the IOBluetoothSDPServiceRecord * for the given IOBluetoothSDPServiceRecordRef.
*/

+ (instancetype)withSDPServiceRecordRef:(IOBluetoothSDPServiceRecordRef)sdpServiceRecordRef;

/*!
    @method	getSDPServiceRecordRef
	@abstract	Returns an IOBluetoothSDPServiceRecordRef representation of the target IOBluetoothSDPServiceRecord object.
	@result		Returns an IOBluetoothSDPServiceRecordRef representation of the target IOBluetoothSDPServiceRecord object.
*/

- (IOBluetoothSDPServiceRecordRef)getSDPServiceRecordRef;

/*!
    @method		device
    @abstract	Returns the IOBluetoothDevice that the target service belongs to.
    @discussion If the service is a local service (i.e. one the current host is vending out), then nil is returned.
    @result		Returns the IOBluetoothDevice that the target service belongs to.  If the service is one the local host
				is vending, then nil is returned.
*/

@property(readonly, retain) IOBluetoothDevice *device;
- (IOBluetoothDevice *)getDevice DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
    @method		attributes
    @abstract	Returns an NSDictionary containing the attributes for the service.
    @discussion	The attribute dictionary is keyed off of the attribute id represented as an NSNumber.  The values
                in the NSDictionary are IOBluetoothSDPDataElement objects representing the data element for the
                given attribute.
    @result Returns an NSDictionary containing the attributes for the target service.
*/

@property(readonly, copy) NSDictionary *attributes;
- (NSDictionary *)getAttributes DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
    @method		getAttributeDataElement:
    @abstract	Returns the data element for the given attribute ID in the target service.
    @param		attributeID The attribute ID of the desired attribute.	 
    @result		Returns the data element for the given attribute ID in the target service.  If the service does not
				contain an attribute with the given ID, then nil is returned.
*/

- (IOBluetoothSDPDataElement *)getAttributeDataElement:(BluetoothSDPServiceAttributeID)attributeID;

/*!
    @method		getServiceName
    @abstract	Returns the name of the service.
    @discussion This is currently implemented to simply return the attribute with an id of 0x0100.  In
                the future, it will be extended to allow name localization based on the user's chosen
                language or other languages.
    @result		Returns the name of the target service.
*/

- (NSString *)getServiceName;

/*!
    @method		getRFCOMMChannelID:
    @abstract	Allows the discovery of the RFCOMM channel ID assigned to the service.
    @discussion This method will search through the ProtoclDescriptorList attribute to find an entry
                with the RFCOMM UUID (UUID16: 0x0003).  If one is found, it gets the second element of
                the data element sequence and sets the rfcommChannelID pointer to it.  The channel ID
                only gets set when kIOReturnSuccess is returned.
    @param		rfcommChannelID A pointer to the location that will get the found RFCOMM channel ID.
    @result		Returns kIOReturnSuccess if the channel ID is found.
*/

- (IOReturn)getRFCOMMChannelID:(BluetoothRFCOMMChannelID *)rfcommChannelID;

/*!
    @method		getL2CAPPSM:
    @abstract	Allows the discovery of the L2CAP PSM assigned to the service.
    @discussion This method will search through the ProtoclDescriptorList attribute to find an entry
                with the L2CAP UUID (UUID16: 0x0100).  If one is found, it gets the second element of
                the data element sequence and sets the outPSM pointer to it.  The PSM value
                only gets set when kIOReturnSuccess is returned.
    @param		outPSM A pointer to the location that will get the found L2CAP PSM.
    @result		Returns kIOReturnSuccess if the PSM is found.
*/

- (IOReturn)getL2CAPPSM:(BluetoothL2CAPPSM *)outPSM;

/*!
    @method		getServiceRecordHandle:
    @abstract	Allows the discovery of the service record handle assigned to the service.
    @discussion This method will search through the attributes to find the one representing the 
                service record handle.  If one is found the outServiceRecordHandle param is set
                with the value.  The outServiceRecordHandle value only gets set when kIOReturnSuccess 
                is returned.
    @param		outServiceRecordHandle A pointer to the location that will get the found service record handle.
    @result		Returns kIOReturnSuccess if the service record handle is found.
*/

- (IOReturn)getServiceRecordHandle:(BluetoothSDPServiceRecordHandle *)outServiceRecordHandle;

/*!
 @method		matchesUUID16:
 @abstract	Returns TRUE the UUID16 is found in the target service.
 
 			NOTE: This method is only available in Mac OS X 10.7 or later.
 @param uuid16 A BluetoothSDPUUID16 to search for in the target service.	 
 @result Returns TRUE if the UUID16 is present in the service.
 */
- (BOOL)matchesUUID16:(BluetoothSDPUUID16)uuid16;

/*!
    @method		matchesUUIDArray:
    @abstract	Returns TRUE if ALL of the UUIDs in the given array is found in the target service.
    @discussion The given array should contain IOBluetoothSDPUUID objects.  It only returns TRUE if all of
                the UUIDs are found.  This method is like hasServiceFromArray: except that it requires that
                all UUIDs match instead of any of them matching.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
    @param array An NSArray of IOBluetoothSDPUUID objects to search for in the target service.	 
    @result Returns TRUE if all of the given UUIDs are present in the service.
*/
- (BOOL)matchesUUIDArray:(NSArray *)uuidArray;

/*!
    @method		matchesSearchArray:
    @abstract	Returns TRUE any of the UUID arrays in the search array match the target service.
    @discussion The given array should contain NSArray objects.  Each sub-NSArray should contain
                IOBluetoothSDPUUID objects.  In turn, each sub-NSArray gets passed to -matchesUUIDArray:
                If any of those returns TRUE, then the search stops and TRUE is returned.
                Essentially the master NSArray contains the OR operations and each sub-array contains
                the AND operations.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
    @param		array An NSArray of NSArrays of IOBluetoothSDPUUID objects.	 
    @result		Returns TRUE if any of the UUID arrays match.
*/
- (BOOL)matchesSearchArray:(NSArray *)searchArray;

/*!
    @method		hasServiceFromArray:
    @abstract	Returns TRUE if any one of the UUIDs in the given array is found in the target service.
    @discussion The given array should contain IOBluetoothSDPUUID objects.  It is currently implemented
                such that it returns TRUE if any of the UUIDs are found.  However in the future, it is likely
                that this will change to more closely match the functionality in the SDP spec so that it only
                returns TRUE if all of the given UUIDs are present.  That way, both AND and OR comparisons
                can be implemented.  Please make a note of this potential change.
    @param		array An NSArray of IOBluetoothSDPUUID objects to search for in the target service.	 
    @result		Returns TRUE if any of the given UUIDs are present in the service.
*/

- (BOOL)hasServiceFromArray:(NSArray *)array;

/*!
 @method		sortedAttributes:
 @abstract		Returns a sorted array of SDP attributes
 @discussion	This method will walk all the elements of the service record and return an array of 
				IOBluetoothSDPServiceAttribute objects sorted by attributeID
 @result		Returns a sorted array of SDP attributes
 */

@property(readonly, copy) NSArray *sortedAttributes;

@end
                                                                                                                                                                                                                                                                         IOBluetoothSDPUUID.h                                                                                0100644 0001750 0001750 00000011354 12567444611 036350  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
    File:		IOBluetoothSDPUUID.h
    Copyright:	 2002 by Apple Computer, Inc. All rights reserved.
	Writers:	Eric Brown
*/

#import <Foundation/Foundation.h>

#import <IOBluetooth/Bluetooth.h>
#import <IOBluetooth/IOBluetoothUserLib.h>

/*!
    @class IOBluetoothSDPUUID
    @abstract An NSData subclass that represents a UUID as defined in the Bluetooth SDP spec.
    @discussion The IOBluetoothSDPUUID class can represent a UUID of any valid size (16, 32 or 128 bits).
            It provides the ability to compare two UUIDs no matter what their size as well as the ability
            to promote the size of a UUID to a larger one.
*/

@interface IOBluetoothSDPUUID : NSData {
    NSData	*mUUIDData;
    
    void	*_mReserved;
}

/*!
    @method uuidWithBytes:length:
    @abstract Creates a new IOBluetoothSDPUUID object with the given bytes of the given length.
    @discussion If the length is invalid for a UUID, nil is returned.
    @param bytes An array of bytes representing the UUID.
    @param length The length of the array of bytes.
    @result Returns the new IOBluetoothSDPUUID object or nil on failure.
*/

+ (instancetype)uuidWithBytes:(const void *)bytes length:(unsigned)length;

/*!
    @method uuidWithData:
    @abstract Creates a new IOBluetoothSDPUUID object from the given NSData.
    @discussion If the length of the NSData is invalid for a UUID, nil is returned.
    @param data The NSData containing the UUID bytes.
    @result Returns the new IOBluetoothSDPUUID object or nil on failure.
*/

+ (instancetype)uuidWithData:(NSData *)data;

/*!
    @method uuid16:
    @abstract Creates a new 16-bit IOBluetoothSDPUUID with the given UUID16
    @param uuid16 A scalar representing a 16-bit UUID
    @result Returns the new IOBluetoothSDPUUID object.
*/

+ (instancetype)uuid16:(BluetoothSDPUUID16)uuid16;

/*!
    @method uuid32:
    @abstract Creates a new 32-bit IOBluetoothSDPUUID with the given UUID32
    @param uuid32 A scalar representing a 32-bit UUID
    @result Returns the new IOBluetoothSDPUUID object.
*/

+ (instancetype)uuid32:(BluetoothSDPUUID32)uuid32;

/*!	@method	withSDPUUIDRef:
	@abstract	Method call to convert an IOBluetoothSDPUUIDRef into an IOBluetoothSDPUUID *.
        @param	sdpUUIDRef IOBluetoothSDPUUIDRef for which an IOBluetoothSDPUUID * is desired.
	@result		Returns the IOBluetoothSDPUUID * for the given IOBluetoothSDPUUIDRef.
*/
+ (instancetype)withSDPUUIDRef:(IOBluetoothSDPUUIDRef)sdpUUIDRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method initWithUUID16:
    @abstract Initializes a new 16-bit IOBluetoothSDPUUID with the given UUID16
    @param uuid16 A scalar representing a 16-bit UUID
    @result Returns self.
*/

- (instancetype)initWithUUID16:(BluetoothSDPUUID16)uuid16;

/*!
    @method initWithUUID32:
    @abstract Creates a new 32-bit IOBluetoothSDPUUID with the given UUID32
    @param uuid32 A scalar representing a 32-bit UUID
    @result Returns self.
*/

- (instancetype)initWithUUID32:(BluetoothSDPUUID32)uuid32;

/*!	@method	getSDPUUIDRef
	@abstract	Returns an IOBluetoothSDPUUIDRef representation of the target IOBluetoothSDPUUID object.
	@result		Returns an IOBluetoothSDPUUIDRef representation of the target IOBluetoothSDPUUID object.
*/
- (IOBluetoothSDPUUIDRef)getSDPUUIDRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method getUUIDWithLength:
    @abstract Returns an IOBluetoothSDPUUID object matching the target UUID, but with the given number of bytes.
    @discussion If the target object is the same length as newLength, it returns self.  If newLength is greater
                it creates a new IOBluetoothSDPUUID object with the correct value for the given length.  If
                newLength is smaller, it will attempt to create a new IOBluetoothSDPUUID that is smaller if
                the data matches the Bluetooth UUID base.  This downconversion is currently unimplemented.
    @param newLength The desired length for the UUID. 
    @result Returns an IOBluetoothSDPUUID object with the same data as the target but with the given length if it
            is possible to do so.  Otherwise, nil is returned.
*/

- (instancetype)getUUIDWithLength:(unsigned)newLength;

/*!
    @method isEqualToUUID:
    @abstract Compares the target IOBluetoothSDPUUID object with the given otherUUID object.
    @discussion This method will compare the two UUID values independent of their length.
    @param otherUUID The UUID object to be compared with the target.
    @result Returns true if the UUID values of each object are equal.  This includes the case where the sizes are different
            but the data itself is the same when the Bluetooth UUID base is applied.
*/

- (BOOL)isEqualToUUID:(IOBluetoothSDPUUID *)otherUUID;

- (Class)classForCoder;
- (Class)classForArchiver;
- (Class)classForPortCoder;

@end
                                                                                                                                                                                                                                                                                    IOBluetoothUserNotification.h                                                                       0100644 0001750 0001750 00000001321 12567444611 040511  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            #import <Foundation/NSObject.h>

/*!
    @class IOBluetoothUserNotification
    @abstract Represents a registered notification.
    @discussion When registering for various notifications in the system, an IOBluetoothUserNotification
				object is returned.  To unregister from the notification, call -unregister on the
				IOBluetoothUserNotification object.  Once -unregister is called, the object will no
				longer be valid.
*/

@interface IOBluetoothUserNotification : NSObject
{
}

/*!
    @method unregister
    @abstract Called to unregister the target notification.
    @discussion Once this method has completed, the target IOBluetoothUserNotification will
				no longer be valid.
*/

- (void)unregister;

@end

                                                                                                                                                                                                                                                                                                               NSDictionaryOBEXExtensions.h                                                                        0100644 0001750 0001750 00000005046 12567444611 040222  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	Contains:	OBEX Header construction routines.
	Copyright:	(C) 2010 by Apple, Inc., all rights reserved.
*/

#import <IOKit/IOKitLib.h>
#import <stdlib.h>

#import <IOBluetooth/OBEX.h>

//===========================================================================================================================
//	NSMutableDictionary
//===========================================================================================================================

@interface NSMutableDictionary (NSDictionaryOBEXExtensions)

/* creation */

+(instancetype)dictionaryWithOBEXHeadersData:(const void*)inHeadersData headersDataSize:(size_t)inDataSize;
+(instancetype)dictionaryWithOBEXHeadersData:(NSData*)inHeadersData;

/* Utilities */

-(NSMutableData *)getHeaderBytes;

/* Adding headers to the dictionary */

-(OBEXError)addTargetHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addHTTPHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addBodyHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength endOfBody:(BOOL)isEndOfBody;
-(OBEXError)addWhoHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addConnectionIDHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addApplicationParameterHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addByteSequenceHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addObjectClassHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addAuthorizationChallengeHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addAuthorizationResponseHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addTimeISOHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;
-(OBEXError)addTypeHeader:(NSString*)type;
-(OBEXError)addLengthHeader:(uint32_t)length;
-(OBEXError)addTime4ByteHeader:(uint32_t)time4Byte;
-(OBEXError)addCountHeader:(uint32_t)inCount;
-(OBEXError)addDescriptionHeader:(NSString*)inDescriptionString;
-(OBEXError)addNameHeader:(NSString*)inNameString;
-(OBEXError)addUserDefinedHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;

-(OBEXError)addImageHandleHeader:(NSString*)type;
-(OBEXError)addImageDescriptorHeader:(const void*)inHeaderData	length:(uint32_t)inHeaderDataLength;

+(instancetype)withOBEXHeadersData:(const void*)inHeadersData headersDataSize:(size_t)inDataSize DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          OBEXFileTransferServices.h                                                                          0100644 0001750 0001750 00000051364 12567444611 037670  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	Contains: 		OBEX File Transfer Services object for FTP and ObjectPush operations
	Copyright:		(c) 2010 by Apple, Inc., all rights reserved.
*/


#import <Foundation/Foundation.h>
		
#import <IOBluetooth/OBEX.h>
#import <IOBluetooth/objc/IOBluetoothOBEXSession.h>

//====================================================================================================================
//	OBEXFileTransferServices
//====================================================================================================================
/*!
    @class			OBEXFileTransferServices
    @abstract		Implements advanced OBEX operations in addition to simple PUT and GET.
    @discussion		All operations are asynchronous and will callback over a respective delegate 
					method if the initial return value is successful.  The initial return value 
					usually concerns the state of this object where as the delegate return value
					reflects the response of the remote device.
*/

@interface OBEXFileTransferServices : NSObject
{

@private

	id							mOBEXFileGet;
	id							mOBEXFilePut;
	
	id							mFolderListingFileRef;
	int							mActionCommand;
	int							mSavedCommand;
	NSString *					mActionArgument1;
	NSString *					mActionArgument2;
	NSString *					mActionArgument3;
	NSString *					mCurrentRemoteDirectory;

	// Misc status info.
	
	BOOL						mActionInProgress;
	BOOL						mWeOpenedTheOBEXConnection;
	BOOL						mHasTargetHeader;
	
	// Delegate stuff.

	id							mDelegate;
	
	// Activity timer.
	
	BOOL						mAbortedByOwner;
	BOOL						mWeAreAborting;
	NSTimer*					mInactivityTimer;

	// OBEX Session stuff.

	IOBluetoothOBEXSession*		mOBEXSession;
	OBEXMaxPacketLength			mMaxPacketLength;
	OBEXError					mConnectionID;
	
	// Progress stuff.
	
	id							mPUTProgress;
	id							mGETProgress;
			
	void *						mReserved1;
	void *						mReserved2;
 }

@property(assign) id delegate;

//------------------------------------------
// Object construction.
//------------------------------------------
/*!
	@method			withOBEXSession:
    @abstract		Create a new OBEXFileTransferServices object
    @discussion		This object must be constructed with a valid IOBluetoothOBEXSession. The given 
					IOBluetoothOBEXSession does not need to be connected to the remote server.  
					This module can be manually connected through the connect() method. 
	@param			inOBEXSession A valid IOBluetoothOBEXSession
	@result			A newly created OBEXFileTransferServices object on success, nil on failure
*/
+ (instancetype) withOBEXSession: (IOBluetoothOBEXSession*) inOBEXSession;


/*!
	@method			initWithOBEXSession:
	@abstract		Create a new OBEXFileTransferServices object
	@discussion		This object must be constructed with a valid IOBluetoothOBEXSession. The given 
					IOBluetoothOBEXSession does not need to be connected to the remote server.  
					OBEXFileTransferServices can be manually connected through the provided connection 
					methods.
	@param			inOBEXSession A valid IOBluetoothOBEXSession
	@result			A newly created OBEXFileTransferServices object on success, nil on failure
*/
- (instancetype) initWithOBEXSession:(IOBluetoothOBEXSession*)inOBEXSession;


#pragma mark -
#pragma mark === Accessors ===
//------------------------------------------
// Accessors
//------------------------------------------


/*!
	@method     currentPath
	@abstract   Get the remote current directory path during an FTP session
	@discussion This path is changed with each path-specific command called on OBEXFileTransferServices.
	@result		The current path being browsed over FTP
*/
- (NSString*) currentPath;

/*!
	@method     isBusy
	@abstract   Get the action state of the module
	@discussion OBEXFileTransferServices will be considered "busy" when an operation in taking place or
				has not completed.  Calling abort: on this module will not automatically reset its busy
				state.  The user will have to wait for the operation to complete or for the current
				operation to timeout.
	@result		Success or failure code.
*/
- (BOOL) isBusy;

/*!
	@method     isConnected
	@abstract   Get the connected state of this module.
	@discussion Asks the OBEXSession that was passed to it on creation if it has an open OBEX connection
	@result		Success or failure code.
*/
- (BOOL) isConnected;





#pragma mark -
#pragma mark === Actions ===
//------------------------------------------
// Actions
//------------------------------------------

/*!
	@method     connectToFTPService
	@abstract   Connect to a remote device for FTP operations
	@discussion If the OBEXSession given to OBEXFileTransferServices on creation is not connected it
				can be manually connected through this method. 
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXSessionAlreadyConnectedError, kOBEXNoResourcesError
				initially.  Further results returned through the fileTransferServicesConnectionComplete:
				delegate method if initially successful.
*/
- (OBEXError) connectToFTPService;

/*!
    @method     connectToObjectPushService
    @abstract   Connect to a remote device for ObjectPush operations.
				Most of the FTP functionality of this object will be disabled.
    @discussion If the OBEXSession given to OBEXFileTransferServices on creation is not connected it
				can be manually connected through this method. 
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXSessionAlreadyConnectedError, kOBEXNoResourcesError
				initially.  Further results returned through the fileTransferServicesConnectionComplete: 
				delegate method if initially successful.
*/
- (OBEXError) connectToObjectPushService;


/*!
    @method     disconnect
    @abstract   Disconnect from the remote device
    @discussion The user can manually disconnect the OBEXSession from the remote device if they want
				to.  OBEXFileTransferServices will disconnect the OBEXSession at release only if it was responsible 
				for opening the connection via a connect method.
	@result		kOBEXSuccess, kOBEXSessionNotConnectedError, or kOBEXSessionBusyError initially. Further results 
				returned through the fileTransferServicesDisconnectionComplete: delegate method if initially successful.
*/
- (OBEXError) disconnect;

/*!
    @method     changeCurrentFolderRoot
    @abstract   Asynchronously change to the remote root directory
    @discussion Equivalent to 'cd ~/'
	@result		kOBEXSuccess or kOBEXSessionBusyError initially.  Further results
				returned through the fileTransferServicesPathChangeComplete: delegate method if initially successful.
*/
- (OBEXError) changeCurrentFolderToRoot;

/*!
    @method     changeCurrentFolderBackward
    @abstract   Change to the directory above the current level if not at the root
    @discussion Equivalent to 'cd ..' only if remote path is not already at root.  
	@result		kOBEXSuccess or kOBEXSessionBusyError initially. Further results
				returned through the fileTransferServicesPathChangeComplete: delegate method if initially successful.
*/
- (OBEXError) changeCurrentFolderBackward;

/*!
    @method     changeCurrentFolderForwardToPath:
    @abstract   Change the remote path
    @discussion Equivalent to 'cd dirName'.  
	@param		inDirName The name of the remote folder to be set as current
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError initially. Further results
				returned through the fileTransferServicesPathChangeComplete: delegate method if initially successful.
*/
- (OBEXError) changeCurrentFolderForwardToPath: (NSString*) inDirName;

/*!
    @method     createFolder:
    @abstract   Create a folder on the remote target
    @discussion Equivalent to 'mkdir dirName'.  
	@param		inDirName The name of the folder to be created
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError initially. 
				Further results returned through the fileTransferServicesCreateFolderComplete delegate method
				if initially successful.
*/
- (OBEXError) createFolder: (NSString*) inDirName;

/*!
    @method     removeItem:
    @abstract   Remove a remote item.
    @discussion Not supported for use on Apple computer targets  
	@param		inItemName The name of the remote item to be removed
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError initially.  
				Further results returned through the fileTransferServicesRemoveItemComplete: delegate method 
				if initially successful.
*/					
- (OBEXError) removeItem: (NSString*) inItemName;

/*!
    @method     retrieveFolderListing
    @abstract   Get a remote directory listing
    @discussion Equivalent to 'ls'.  
	@result		kOBEXSuccess or kOBEXSessionBusyError initially.  Further results returned through 
				the fileTransferServicesRetrieveFolderListingComplete: delegate method if initially successful.
*/
- (OBEXError) retrieveFolderListing;

/*!
    @method     sendFile:
    @abstract   Put a local file to the remote target
    @discussion Equivalent to 'mv inLocalFilePath remoteCurrentPath'.
	@param		inLocalPathAndName The name and path of the file to be sent an instance of OBEXFilePut.  
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError initially. Further 
				results returned through the fileTransferServicesSendComplete: and 
				fileTransferServicesSendProgress: delegate methods if initially successful.
*/
- (OBEXError) sendFile: (NSString*) inLocalPathAndName;

/*!
    @method     copyRemoteFile:toLocalPath:
    @abstract   Copy a remote file to a local path
    @discussion Equivalent to 'cp remotePath/remoteFileName localPathAndName'.
	@param		inRemoteFileName The name of the remote file to get
	@param		inLocalPathAndName The path and name of where the received file will go
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError. initially.  Further 
				results returned through the fileTransferServicesGetComplete: and 
				fileTransferServicesGetProgress: delegate methods if initially successful.
*/
- (OBEXError) copyRemoteFile: (NSString*) inRemoteFileName
				 toLocalPath: (NSString*) inLocalPathAndName;

/*!
	@method     sendData:type:name:
	@abstract   Send data to a remote target
	@discussion Use this method when you have data to send but no file to read from.
	@param		inData The data to be sent
	@param		inType The type of the data to be sent that will be used in the OBEX type header,
				usually a mime-type.  For example, use "text/x-vCard" when sending vCards. This 
				argument is optional. 
	@param		inName The name of the file that the data can be referenced as.
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError initially. Further 
				results returned through the fileTransferServicesSendComplete: and 
				fileTransferServicesSendProgress: delegate methods if initially successful.
*/
- (OBEXError) sendData:(NSData*)inData
				  type:(NSString*)inType
				  name:(NSString*)inName;

/*!
	@method     getDefaultVCard:
	@abstract   Get the remote default VCard, if it is supported
	@discussion Some devices such as cellphones and computers support default VCards
	@param		inLocalPathAndName The path and name of where the received file will go
	@result		kOBEXSuccess, kOBEXSessionBusyError, or kOBEXBadArgumentError initially.  Further 
				results returned through the fileTransferServicesGetComplete: and 
				fileTransferServicesGetProgress: delegate methods if initially successful.
*/
- (OBEXError) getDefaultVCard:(NSString*) inLocalPathAndName;

/*!
    @method     abort
    @abstract   Abort the current operation
    @discussion Attempts send an abort request to the remote device.  Returns the OBEXFileTransferServices
				object to an idle state though the state of the remote device is not guaranteed.
	@result		kOBEXSuccess, or kOBEXGeneralError if no command is in progress. ABORT 
				commands can only be sent on our turn, meaning we may have to timeout if the
				target side never responds to the command in progress.  In that case this object
				will call back with a status of kOBEXTimeoutError and an error. Further results
				returned through the fileTransferServicesAbortComplete: delegate method if initially successful.
*/
- (OBEXError) abort;


@end



#pragma mark -
#pragma mark === Delegate Interface ===
//====================================================================================================================
//  Delegate Methods
//====================================================================================================================
@interface NSObject (OBEXFileTransferServicesDelegate)

#pragma mark -
#pragma mark Progress Keys
//------------------------------------------
//  Progress Keys
//------------------------------------------
//  These keys are used with the NSDictionary returned from the fileTransferServicesPutProgress:
// and fileTransferServicesGetProgress: delegate methods
//
/*!
 @const			kFTSProgressBytesTransferredKey
 @abstract		NSNumber integer value. This key is used with the NSDictionary returned from the fileTransferServicesPutProgress:
				and fileTransferServicesGetProgress: delegate methods
 */
extern CFStringRef kFTSProgressBytesTransferredKey;
/*!
 @const			kFTSProgressBytesTotalKey
 @abstract		NSNumber integer value. This key is used with the NSDictionary returned from the fileTransferServicesPutProgress:
				and fileTransferServicesGetProgress: delegate methods
 */
extern CFStringRef kFTSProgressBytesTotalKey;
/*!
 @const			kFTSProgressPercentageKey
 @abstract		NSNumber float value. This key is used with the NSDictionary returned from the fileTransferServicesPutProgress:
				and fileTransferServicesGetProgress: delegate methods
 */
extern CFStringRef kFTSProgressPercentageKey;
//  Spelled wrong, but it must be supported for backward compatibility
//
extern CFStringRef kFTSProgressPrecentageKey;


/*!
 @const			kFTSProgressEstimatedTimeKey
 @abstract		NSNumber double value. This key is used with the NSDictionary returned from the fileTransferServicesPutProgress:
				and fileTransferServicesGetProgress: delegate methods
 */
extern CFStringRef kFTSProgressEstimatedTimeKey;
/*!
 @const			kFTSProgressTimeElapsedKey
 @abstract		NSNumber int value. This key is used with the NSDictionary returned from the fileTransferServicesPutProgress:
				and fileTransferServicesGetProgress: delegate methods
 */
extern CFStringRef kFTSProgressTimeElapsedKey;
/*!
 @const			kFTSProgressTransferRateKey
 @abstract		NSNumber float value. This key is used with the NSDictionary returned from the fileTransferServicesPutProgress:
				and fileTransferServicesGetProgress: delegate methods
 */
extern CFStringRef kFTSProgressTransferRateKey;

#pragma mark -
#pragma mark Listing Keys
//------------------------------------------
//  Listing Keys
//------------------------------------------
//  These keys are used with the array of NSDictionary's returned through the delegate method
// fileTransferServicesGetListingComplete: after calling getFolderListing.  
//
/*!
	@const			kFTSListingNameKey
	@abstract		NSString value.  This key is used with the array of NSDictionary's returned through the delegate method
					fileTransferServicesGetListingComplete: after calling getFolderListing.  
 */
extern CFStringRef kFTSListingNameKey;
/*!
	@const			kFTSListingTypeKey
	@abstract		FTSFileType value.  This key is used with the array of NSDictionary's returned through the delegate method
					fileTransferServicesGetListingComplete: after calling getFolderListing.  
 */
extern CFStringRef kFTSListingTypeKey;
/*!
	@const			kFTSListingSizeKey
	@abstract		Int value.  This key is used with the array of NSDictionary's returned through the delegate method
					fileTransferServicesGetListingComplete: after calling getFolderListing.  
 */
extern CFStringRef kFTSListingSizeKey;



/*!
 @enum			FTSFileType
 @discussion	The type values associated with the kFTSListingTypeKey dictionary value
 @constant		kFTSFileTypeFolder Folder
 @constant		kFTSFileTypeFile File
 */
enum  FTSFileType
{
	kFTSFileTypeFolder = 1,
	kFTSFileTypeFile   = 2
};


#pragma mark -
#pragma mark Delegate Methods
//------------------------------------------
//  Delegate Methods
//------------------------------------------

/*!
	@method			fileTransferServicesConnectionComplete:error:
	@abstract		The delegate method that corresponds to the connect method
	@discussion		inError will either be kOBEXSuccess or it will be an error returned by the OBEX Session
*/
- (void) fileTransferServicesConnectionComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError;

/*!
	@method			fileTransferServicesDisconnectionComplete:error:
	@abstract		The delegate method that corresponds to the disconnect method
	@discussion		inError will be kOBEXSuccess on success.  This method will also be called if the connection
					is lost to the server.  Possible error codes include kOBEXSessionTransportDiedError, 
					kOBEXSessionNoTransportError, and kOBEXSessionNotConnectedError.
*/
- (void) fileTransferServicesDisconnectionComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError;

/*!
	@method			fileTransferServicesAbortComplete:error:
	@abstract		The delegate method that corresponds to the abort method
	@discussion		Possible inError values are kOBEXSuccess and kOBEXTimeoutError
*/
- (void) fileTransferServicesAbortComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError;

/*!
	@method			fileTransferServicesRemoveItemComplete:error:removedItem:
	@abstract		The delegate method that corresponds to the removeItemNamed: method.
	@discussion		
	@param			inItemName The name of the remote item that was removed
*/
- (void) fileTransferServicesRemoveItemComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError removedItem:(NSString*)inItemName;

/*!
	@method			fileTransferServicesCreateFolderComplete:error:folderName:
	@abstract		The delegate method that corresponds to the createFolderNamed: method.
	@discussion		
	@param			inFolderName The name of the newly created folder
*/
- (void) fileTransferServicesCreateFolderComplete:(OBEXFileTransferServices*)inServices		error:(OBEXError)inError folder:(NSString*)inFolderName;

/*!
	@method			fileTransferServicesPathChangeComplete:error:finalPath:
	@abstract		The delegate method that corresponds to the changeCurrentFolderToRoot:,
					changeCurrentFolderBackward:, and changeCurrentFolderForward: methods
	@discussion	
	@param			inPath The current remote path
*/
- (void) fileTransferServicesPathChangeComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError finalPath:(NSString*)inPath;

/*!
	@method			fileTransferServicesRetrieveFolderListingComplete:error:listing:
	@abstract		The delegate method that corresponds to the retrieveFolderListing method
	@discussion		
	@param			inListing An array of NSDictionary's that detail each file at the current path.  The keys
					to this dictionary are defined in the OBEXFileTransferServicesDelegate category.
*/
- (void) fileTransferServicesRetrieveFolderListingComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError listing:(NSArray*)inListing;

/*!
	 @method		fileTransferServicesFilePreparationComplete:error:
	 @abstract		The delegate method for receiving information on the preparation of each file to send
	 @discussion	This method will be called before the transfer operation.
*/
- (void) fileTransferServicesFilePreparationComplete: (OBEXFileTransferServices*) inServices	error: (OBEXError) inError;

/*!
	@method			fileTransferServicesSendFileProgress:transferProgress:
	@abstract		The delegate method for receiving information on the sendFile: transfer
	@discussion		This method will be called during the transfer operation.
	@param			inProgressDescription A dictionary containing information on the state of the transfer. The keys
					 to this dictionary are defined in the OBEXFileTransferServicesDelegate category.
*/
- (void) fileTransferServicesSendFileProgress:(OBEXFileTransferServices*)inServices		transferProgress:(NSDictionary*)inProgressDescription;

/*!
	@method			fileTransferServicesSendFileComplete:error:
	@abstract		The delegate method that corresponds to the sendFile: method.
	@discussion		This method will be called when the transfer operation has finished.
*/
- (void) fileTransferServicesSendFileComplete:(OBEXFileTransferServices*)inServices		error:(OBEXError)inError;


/*!
	@method			fileTransferServicesCopyRemoteFileProgress:transferProgress:
	@abstract		The delegate method for receiving information on the GET transfer
	@discussion		This method will be called during the transfer operation
	@param			inProgressDescription A dictionary containing information on the state of the transfer. The keys
					to this dictionary are defined in the OBEXFileTransferServicesDelegate category.
*/
- (void) fileTransferServicesCopyRemoteFileProgress:(OBEXFileTransferServices*)inServices	transferProgress:(NSDictionary*)inProgressDescription;

/*!
	@method			fileTransferServicesCopyRemoteFileComplete:error:
	@abstract		The delegate method that corresponds to the getFileNamed:toLocalPathAndName: method
	@discussion		This method will be called when the transfer operation has finished
*/
- (void) fileTransferServicesCopyRemoteFileComplete:(OBEXFileTransferServices*)inServices	error:(OBEXError)inError;



@end
                                                                                                                                                                                                                                                                            OBEXSession.h                                                                                       0100644 0001750 0001750 00000112134 12567444611 035214  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Headers/objc                                                            /*
	File:		OBEXSession.h
	Contains:	OBEX session object.
    Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/

#import <IOKit/IOKitLib.h>

#import <Foundation/Foundation.h>

#import <IOBluetooth/OBEX.h>

#pragma mark === Types ===

typedef struct OpaquePrivOBEXSessionData* PrivOBEXSessionDataRef;


//---------------------------------------------------------------------------------------------------------------------------
/*!	@class			OBEXSession
	@abstract		Object representing an OBEX connection to a remote target.
	@discussion		You will have no need for a obtaining/using a raw OBEXSession, since it requires an underlying
					transport to do anything useful. However, once you have an object that is a subclass of this
					class, you can use the functions herein to manipulate that OBEXSession. First off, you will want
					to use OBEXConnect (if you are a client session) to actually cause the transport to open a
					connection to a remote target and establish an OBEX connection over it. From there you can issue
					more commands based on the responses from a server.
					
					If you are a server session, the first thing you should receive is an OBEXConnect command packet,
					and you will want to issue an OBEXConnectResponse packet, with your reesponse to that command
					(success, denied, bad request, etc.).
					
					You can use the session accessors to access certain information, such as the negotiated max
					packet length.
					
					If you wish to implement your own OBEXSession over a transport such as ethernet, you will need to
					see the end of the file to determine which functions to override, and what to pass to those
					functions.
					
					No timeout mechanism has been implemented so far for an OBEXSessions. If you need timeouts, you
					will need to implement them yourself. This is being explored for a future revision. However, be aware
					that the OBEX Specification does not explicitly require timeouts, so be sure you allow ample time
					for commands to complete, as some devices may be slow when sending large amounts of data.
*/

#pragma mark -
#pragma mark === OBEXSession Interface ===

@interface OBEXSession : NSObject
{	
	/* All instance variables are private */
	
	BOOL							mHasOBEXConnection;					// Has the OBEX connection been established over the transport?
	BOOL							mIsServer;							// Is this session an OBEX client (we initiated the connection) or server?
	OBEXMaxPacketLength				mMaxPacketLength;					// Negotiated maximum packet size.
	uint8_t*						mReceivePacketBuffer;				// Desgmentation buffer.
	size_t							mResponsePacketDataLengthExpected;	// Desgmentation buffer support.
	size_t							mResponsePacketDataLengthSoFar;		// Desgmentation buffer support.
	OBEXOpCode						mIncompletePacketResponseCode;		// Desgmentation buffer support.
	PrivOBEXSessionDataRef			mPrivateOBEXSessionData;			// Truly-private session state data.
	OBEXMaxPacketLength				mTheirMaxPacketLength;				// Negotiated maximum packet size.
	OBEXMaxPacketLength				mOurMaxPacketLength;				// Negotiated maximum packet size we can handle.
}

#if 0
#pragma mark -
#pragma mark === Client Commands ===
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXConnect
	@abstract	Initiate an OBEX connection to a device. Causes underlying transport (Bluetooth, et al) to attempt to connect
				to a remote device. After success, an OBEX connect packet is sent to establish the OBEX Connection.
	@param		inFlags					OBEX connect flags. See OBEX.h for possibilities.
	@param		inMaxPacketLength		Maximum packet size you want to support. May be negotiated down, depending on
										target device.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use the
										provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXConnectHandler:(const OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				transport. You will receive a response to your command on your selector. If you have already established an OBEX
				connection and you call this again you will get an 'kOBEXSessionAlreadyConnectedError' as a result.
*/

-(OBEXError)OBEXConnect:(OBEXFlags)inFlags
				maxPacketLength:(OBEXMaxPacketLength)inMaxPacketLength
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXDisconnect
	@abstract	Send an OBEX Disconnect command to the session's target. THIS DOES NOT necessarily close the underlying transport
				connection. Deleting the session will ensure that closure.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXDisconnectHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				transport. You will receive a response to your command on your selector.
				Be careful not to exceed the max packet length in your optional headers, or your command will be rejected.
				It is recommended that you call getMaxPacketLength on your session before issuing this command so
				you know how much data the session's target will accept in a single transaction.
*/

-(OBEXError)OBEXDisconnect:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;
				
//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXPut
	@abstract	Send an OBEX Put command to the session's target.
	@param		isFinalChunk			Specify if this request is complete in one shot - that all the headers you are
										supplying will fit in the negotiated max packet length.
	@param		inHeadersData			Can be NULL. Ptr to some data you want to send as your headers, such as Length,
										Name, etc. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes()
										for convenience.
	@param		inHeadersDataLength		Length of data in ptr passed in above.
	@param		inBodyData				Can be NULL. Ptr to some data you want to send as your BODY header. Do not construct a
										real OBEX header here, it will be done for you - just pass a pointer to your
										data, we'll do the rest. HOWEVER, be aware that some overhead (3 bytes) will be added
										to the data in constructing the BODY header for you.
	@param		inBodyDataLength		Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXPutHandler:(const  OBEXSessionEvent*)inSessionEvent;


	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion	A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				transport. You will receive a response to your command on your selector. 
*/

-(OBEXError)OBEXPut:(Boolean)isFinalChunk
				headersData:(void*)inHeadersData
				headersDataLength:(size_t)inHeadersDataLength
				bodyData:(void*)inBodyData
				bodyDataLength:(size_t)inBodyDataLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXGet
	@abstract	Send an OBEX Get command to the session's target.
	@param		isFinalChunk			Specify if this request is complete in one shot - that all the headers you are
										supplying will fit in the negotiated max packet length.
	@param		inHeadersData			Can be NULL. Ptr to some data you want to send as your headers, such as Length,
										Name, etc. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes()
										for your convenience.
	@param		inHeadersDataLength		Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXGetHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion	A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				transport. You will receive a response to your command on your selector. 
*/

-(OBEXError)OBEXGet:(Boolean)isFinalChunk
				headers:(void*)inHeaders
				headersLength:(size_t)inHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXAbort
	@abstract	Send an OBEX Abort command to the session's target.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXAbortHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion	A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				transport. You will receive a response to your command on your selector. 
*/
			 		
-(OBEXError)OBEXAbort:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXSetPath
	@abstract	Send an OBEX SetPath command to the session's target.
	@param		inFlags					OBEX setpath flags. See OBEX.h for possibilities.
	@param		inConstants				OBEX setpath constants. See OBEX.h for possibilities.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXSetPathHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				transport. You will receive a response to your command on your selector.
*/

-(OBEXError)OBEXSetPath:(OBEXFlags)inFlags
				constants:(OBEXConstants)inConstants
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

#if 0
#pragma mark -
#pragma mark === Server Command Responses ===
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXConnectResponse
	@abstract	Send a connect response to a session's target.
	@param		inFlags					OBEX connect flags. See OBEX.h for possibilities.
	@param		inConstants				OBEX connect constants. See OBEX.h for possibilities.
	@param		inMaxPacketLength		Maximum packet size you want your OBEX session to communicate with. This MUST be
										lower than the max packet size the client has reported to you in the connect command
										you received from it.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXConnectResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				underlying OBEX transport. You will receive any responses to your command response on your selector.
*/

-(OBEXError)OBEXConnectResponse:(OBEXOpCode)inResponseOpCode
				flags:(OBEXFlags)inFlags
				maxPacketLength:(OBEXMaxPacketLength)inMaxPacketLength
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXDisconnectResponse
	@abstract	Send a disconnect response to a session's target.
	@param		inMaxPacketLength		Maximum packet size you want your OBEX session to communicate with. This MUST be
										lower than the max packet size the client has reported to you in the connect command
										you received from it.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXDisconnectResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				underlying OBEX transport. You will receive any responses to your command response on your selector.
*/

-(OBEXError)OBEXDisconnectResponse:(OBEXOpCode)inResponseOpCode
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXPutResponse
	@abstract	Send a put response to a session's target.
	@param		inMaxPacketLength		Maximum packet size you want your OBEX session to communicate with. This MUST be
										lower than the max packet size the client has reported to you in the connect command
										you received from it.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXPutResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				underlying OBEX transport. You will receive any responses to your command response on your selector.
*/

-(OBEXError)OBEXPutResponse:(OBEXOpCode)inResponseOpCode
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXGetResponse
	@abstract	Send a get response to a session's target.
	@param		inMaxPacketLength		Maximum packet size you want your OBEX session to communicate with. This MUST be
										lower than the max packet size the client has reported to you in the connect command
										you received from it.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXGetResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				underlying OBEX transport. You will receive any responses to your command response on your selector.
*/

-(OBEXError)OBEXGetResponse:(OBEXOpCode)inResponseOpCode
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXAbortResponse
	@abstract	Send a abort response to a session's target.
	@param		inMaxPacketLength		Maximum packet size you want your OBEX session to communicate with. This MUST be
										lower than the max packet size the client has reported to you in the connect command
										you received from it.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXAbortResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				underlying OBEX transport. You will receive any responses to your command response on your selector.
*/

-(OBEXError)OBEXAbortResponse:(OBEXOpCode)inResponseOpCode
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		OBEXSetPathResponse
	@abstract	Send a set path response to a session's target.
	@param		inMaxPacketLength		Maximum packet size you want your OBEX session to communicate with. This MUST be
										lower than the max packet size the client has reported to you in the connect command
										you received from it.
	@param		inOptionalHeaders		Can be NULL. Ptr to some data you want to send as your optional headers. Use
										the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.
	@param		inOptionalHeadersLength	Length of data in ptr passed in above.
	@param		inSelector				A VALID selector to be called when something interesting happens due to this call.
										Selector in your target object MUST have the following signature, or it
										will not be called properly (look for error messages in Console.app):

										- (void)OBEXSetPathResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;

	@param		inTarget				A VALID target object for the selector.
	@param		inUserRefCon			Whatever you want to pass here. It will be passed back to you in the refCon portion of the
										OBEXSessionEvent struct. nil is, of course, OK here.
	@result		An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
	@discussion A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
				underlying OBEX transport. You will receive any responses to your command response on your selector.
*/

-(OBEXError)OBEXSetPathResponse:(OBEXOpCode)inResponseOpCode
				optionalHeaders:(void*)inOptionalHeaders
				optionalHeadersLength:(size_t)inOptionalHeadersLength
				eventSelector:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;

#if 0
#pragma mark -
#pragma mark === Session Accessors ===
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		getAvailableCommandPayloadLength
	@abstract	Determine the maximum amount of data you can send in a particular command as an OBEX client session.
	@param		inOpCode		The opcode you are interested in sending (as a client).
	@result		The maximum amount of data a particular packet can handle, after accounting for any command overhead.
	@discussion	Each OBEX Command has a certain amount of overhead. Since the negotiated max packet length does
				not indicate what the maximum data amount you can send in a particular command's packet, you can
				use this function to determine how much data to provide in optional headers or body data headers.
*/

-(OBEXMaxPacketLength)getAvailableCommandPayloadLength:(OBEXOpCode)inOpCode;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		getAvailableCommandResponsePayloadLength
	@abstract	Determine the maximum amount of data you can send in a particular command response as an OBEX server session.
	@param		inOpCode		The opcode you are interested in responding to (as a server).
	@result		The maximum amount of data a particular packet can handle, after accounting for any command response overhead.
	@discussion	Each OBEX Command response has a certain amount of overhead. Since the negotiated max packet length does
				not indicate what the maximum data amount you can send in a particular response's packet, you can
				use this function to determine how much data to provide in optional headers or body data headers.
*/

-(OBEXMaxPacketLength)getAvailableCommandResponsePayloadLength:(OBEXOpCode)inOpCode;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		getMaxPacketLength
	@abstract	Gets current max packet length.
	@result		Max packet length.
	@discussion	This value *could* change before and after a connect command has been sent or a connect
				command response has been received, since the recipient could negotiate a lower max packet size.
*/

-(OBEXMaxPacketLength)getMaxPacketLength;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		hasOpenOBEXConnection
	@abstract	Has a successful connect packet been sent and received? This API tells you so.
	@result		True or false, we are OBEX-connected to another OBEX entity.
	@discussion	A "transport" connection may exist (such as a Bluetooth baseband connection), but the OBEX connection
				may not be established over that transport. If it has been, this function returns true.
*/

-(BOOL)hasOpenOBEXConnection;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setEventCallback
	@abstract	Sets the C-API callback used when the session recieves data.
	@param		inEventCallback		Function to callback. Should be non-NULL, unless you are attempting to clear the
									callback, but doing that doesn't make much sense.
	@discussion	This is really not intended for client sessions. Only subclasses would really be interested in using this. They
				should set these when their subclass object is created, because otherwise they will have no way of receiving
				the initial command data packet. This is a partner to setEventRefCon, described below.
*/

-(void)setEventCallback:(OBEXSessionEventCallback)inEventCallback;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setEventRefCon
	@abstract	Sets the C-API callback refCon used when the session recieves data.
	@param		inRefCon		User's refCon that will get passed when their event callback is invoked.
	@discussion	This is really not intended for client sessions. Only subclasses would really be interested in using this. They
				should set these when their subclass object is created, because otherwise they will have no context in their
				callback.
*/

-(void)setEventRefCon:(void*)inRefCon;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		setEventSelector
	@abstract	Allow you to set a selector to be called when events occur on the OBEX session.
	@param		inEventSelector				Selector to call on the target.
	@param		inEventSelectorTarget		Target to be called with the selector.
	@param		inUserRefCon				User's refCon that will get passed when their event callback is invoked.
	@discussion	Really not needed to be used, since the event selector will get set when an OBEX command is sent out.
*/

-(void)setEventSelector:(SEL)inEventSelector
			target:(id)inEventSelectorTarget
			refCon:(id)inUserRefCon;
	
#if 0
#pragma mark -
#pragma mark === Transport Subclassing ===
#endif

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		OBEXTransportEventTypes
	@discussion	Pass these types in the OBEXTransportEvent, and then pass the struct on to the session object once you
				have filled it out. This is how you can communicate with the session when events happen - if data is
				received, the type will be 'kOBEXTransportEventTypeDataReceived'. if an error has occurred on your transport,
				like the remote target died, you can send a status event with a non-zero value. Since session objects will
				receive this status code on their event handlers, you should try to pass a useful status/error code, such as
				an IOReturn value.
*/

typedef uint32_t	OBEXTransportEventType;
enum OBEXTransportEventTypes
{
	kOBEXTransportEventTypeDataReceived		= 'DatA',
	kOBEXTransportEventTypeStatus			= 'StaT'
};

//---------------------------------------------------------------------------------------------------------------------------
/*!	@struct		OBEXTransportEvent
	@discussion	You will need to construcy these when data is received, and then pass a pointer to it to one of the
				incoming data methods defined below. Pass 0 as your status if data was received OK. Otherwise, you can
				put your own error code in there. For the transport type, be sure to use one of the defined types above.
*/

typedef struct OBEXTransportEvent	OBEXTransportEvent;
struct OBEXTransportEvent
{	
	OBEXTransportEventType	type;
	OBEXError				status;	
	void *					dataPtr;
	size_t					dataLength;
};
	

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		serverHandleIncomingData
	@abstract	Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is
				received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch
				the data. If you do not handle this case, your server session will not work, guaranteed.
	@param		event			New event received from the transport.
	@discussion	Tranport subclasses must call this for OBEX server sessions to work!
*/

-(void) serverHandleIncomingData:(OBEXTransportEvent*)event;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		clientHandleIncomingData
	@abstract	Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is
				received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch
				the data. If you do not handle this case, your server session will not work, guaranteed.
	@param		event			New event received from the transport.
	@discussion	Tranport subclasses must call this for OBEX client sessions to work!
*/


-(void) clientHandleIncomingData:(OBEXTransportEvent*)event;


//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		sendDataToTransport
	@abstract	You must override this to send data over your transport. This does nothing by default, it will
				return a kOBEXUnsupportedError.
	@param		inDataToSend		Data to shove over the transport to a remote OBEX session.
	@param		inDataLength		Length of data passed in.
	@result		Return whether or not the transport could send the  data or not. If you are successful, return kOBEXSuccess,
				otherwise an interesting error code.
	@discussion	Tranport subclasses must override this! When called you should send the data over the transport to
				the remote session.
*/

-(OBEXError)sendDataToTransport:(void *)inDataToSend
			dataLength:(size_t)inDataLength;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		openTransportConnection
	@abstract	Opens a transport connection to a device. A Bluetooth connection is one example of a transport.
	@param		inSelector			Selector to call for success, failure or timeout.
	@param		inTarget			Target on which to call the selector.
	@param		inUserRefCon		Caller's reference constant.
	@result		Should return kOBEXSuccess ( 0 ) on success, otherwise an error code.
	@discussion	Tranport subclasses must override this! when called you should attempt to open your transport
				connection, and if you are successful, return kOBEXSuccess, otherwise an interesting error code.
*/

-(OBEXError)openTransportConnection:(SEL)inSelector
				selectorTarget:(id)inTarget
				refCon:(void *)inUserRefCon;
				
//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		hasOpenTransportConnection
	@abstract	You must override this - it will be called periodically to determine if a transport connection is open or not.
	@result		Return whether or not the transport connection is still open.
	@discussion	Tranport subclasses must override this! When called you simply return if the transport connection is still
				open or not.
*/

-(Boolean)hasOpenTransportConnection;

//---------------------------------------------------------------------------------------------------------------------------
/*!	@method		closeTransportConnection
	@abstract	You must override this - it will be called when the transport connection should be shutdown.
	@result		Return whether or not the transport connection was closed successfully or not. Return OBEXSuccess ( 0 ) on
				success, otherwise an error code.
	@discussion	Tranport subclasses must override this! When called you should take whatever steps are necessary to
				actually close down the transport connection.
*/

-(OBEXError)closeTransportConnection;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                    IOBluetooth.tbd                                                                                     0100644 0001750 0001750 00000155154 12571375064 033353  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A                                                                         ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/IOBluetooth.framework/Versions/A/IOBluetooth
exports:         
  - archs:           [ x86_64 ]
    objc-ivars:      [ _AppleBluetoothHIDDevice._featureDict, _AppleBluetoothHIDDeviceGen2._addressString, 
                       _AppleBluetoothHIDDeviceGen2._batteryPercent, _AppleBluetoothHIDDeviceGen2._batteryStatusFlags, 
                       _AppleBluetoothHIDDeviceGen2._driverClass, _AppleBluetoothHIDDeviceGen2._eventService, 
                       _AppleBluetoothHIDDeviceGen2._eventServiceInterestNotification, 
                       _AppleBluetoothHIDDeviceGen2._locationID, _AppleBluetoothHIDDeviceGen2._manufacturer, 
                       _AppleBluetoothHIDDeviceGen2._product, _AppleBluetoothHIDDeviceGen2._transport, 
                       _AppleBluetoothHIDDeviceGen2._versionNumber, _BluetoothHIDDevice._address, 
                       _BluetoothHIDDevice._bluetoothDevice, _BluetoothHIDDevice._classOfDevice, 
                       _BluetoothHIDDevice._hidDevice, _BluetoothHIDDevice._hidDeviceInterface, 
                       _BluetoothHIDDevice._hidDeviceInterfaceOpen, _BluetoothHIDDevice._interestNotification, 
                       _BluetoothHIDDevice._objectID, _BluetoothHIDDevice._productID, 
                       _BluetoothHIDDevice._queue, _BluetoothHIDDevice._runLoopSource, 
                       _BluetoothHIDDevice._timestamp, _BluetoothHIDDevice._vendorID, 
                       _BluetoothHIDDevice._vendorIDSource, _BluetoothHIDDeviceController._deviceConnectNotification, 
                       _BluetoothHIDDeviceController._deviceDisconnectNotification, 
                       _BluetoothHIDDeviceController._devices, _BluetoothHIDDeviceController._eventServiceConnectNotification, 
                       _BluetoothHIDDeviceController._eventServiceDisconnectNotification, 
                       _BluetoothHIDDeviceController._inactiveDevices, 
                       _BluetoothHIDDeviceController._queueing, _BluetoothHIDDeviceController._serviceFilter, 
                       _BluetoothHIDDeviceController._usageFilter, _BluetoothHIDDeviceController._usagePageFilter, 
                       _ConnectionCompleteCallbackDispatcher.mCallback, 
                       _ConnectionCompleteCallbackDispatcher.mRefCon, _FileReference.mAllDataIsReceived, 
                       _FileReference.mArchiveSize, _FileReference.mDLToTempDir, 
                       _FileReference.mDeleteOnRelease, _FileReference.mFlag1, 
                       _FileReference.mFlag2, _FileReference.mFlag3, _FileReference.mHandle, 
                       _FileReference.mIsArchived, _FileReference.mIsOutputFile, 
                       _FileReference.mIsPostProcessed, _FileReference.mIsPreProcessed, 
                       _FileReference.mName, _FileReference.mPathAndName, 
                       _FileReference.mPreArchiveName, _FileReference.mSize, 
                       _FileReference.mSizeReceived, _FileReference.mTargetIsAMac, 
                       _FileReference.mTempDirPathAndName, _FileReference.mWasFolder, 
                       _HardcopyCableReplacement.currentOffset, _HardcopyCableReplacement.dataTransportLayer, 
                       _HardcopyCableReplacement.eventListener, _HardcopyCableReplacement.eventRefcon, 
                       _HardcopyCableReplacement.hcrpDelegate, _HardcopyCableReplacement.idLen, 
                       _HardcopyCableReplacement.incomingDataBuffer, _HardcopyCableReplacement.incomingReadHead, 
                       _HardcopyCableReplacement.incomingWriteHead, _HardcopyCableReplacement.incomingdataBufferSize, 
                       _HardcopyCableReplacement.last1284ID, _HardcopyCableReplacement.numberOfRemoteCreditsGrantedSoFar, 
                       _HardcopyCableReplacement.numberOfRemoteCreditsSavedJustInCase, 
                       _HardcopyCableReplacement.pduHead, _HardcopyCableReplacement.pduTail, 
                       _HardcopyCableReplacement.pduTimer, _HardcopyCableReplacement.pendingTransactionID, 
                       _HardcopyCableReplacement.printer1284IDBuffer, _HardcopyCableReplacement.printerStatus, 
                       _HardcopyCableReplacement.transactionID, _HardcopyCableReplacement.transportIsOpen, 
                       _HardcopyCableReplacement.waitTime, _IOBluetoothAudioManager._WiFiClient, 
                       _IOBluetoothAudioManager._audioConnectAttempt, _IOBluetoothAudioManager._audioDeviceConnecting, 
                       _IOBluetoothAudioManager._audioDevicesToConnect, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupBluetoothKeyboardConnected, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupBluetoothMouseBeingPairedConnected, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupBluetoothMouseConnected, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupComplete, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupDiscoveringDevicesComplete, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupDiscoveringDevicesFound, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupDiscoveringDevicesStarted, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupDiscoveringDevicesUpdated, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingDeviceConnected, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingDeviceFailed, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingDeviceKeyPressNotification, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingDeviceStarted, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingDeviceSuccessful, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingDeviceUserPasskeyNotification, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupPairingWaitingForUserAck, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupStarted, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupStopped, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupUSBKeyboardConnected, 
                       _IOBluetoothAutomaticDeviceSetup._automaticDeviceSetupUSBMouseConnected, 
                       _IOBluetoothAutomaticDeviceSetup._delegate, _IOBluetoothAutomaticDeviceSetup._notifyOnKeyboard, 
                       _IOBluetoothAutomaticDeviceSetup._notifyOnMouse, 
                       _IOBluetoothAutomaticDeviceSetup._textFieldTestingStatus, 
                       _IOBluetoothConcreteUserNotification.mCallback, 
                       _IOBluetoothConcreteUserNotification.mDirection, 
                       _IOBluetoothConcreteUserNotification.mL2CAPPSM, 
                       _IOBluetoothConcreteUserNotification.mNotificationType, 
                       _IOBluetoothConcreteUserNotification.mRFCOMMChannelID, 
                       _IOBluetoothConcreteUserNotification.mRefCon, _IOBluetoothConcreteUserNotification.mRegisteredObject, 
                       _IOBluetoothConcreteUserNotification.mSelector, 
                       _IOBluetoothConcreteUserNotification.mSelfRegistered, 
                       _IOBluetoothConcreteUserNotification.mWatchedObject, 
                       _IOBluetoothDevice._mReserved, _IOBluetoothDevice.mAddress, 
                       _IOBluetoothDevice.mClassOfDevice, _IOBluetoothDevice.mClockOffset, 
                       _IOBluetoothDevice.mConnectionHandle, _IOBluetoothDevice.mDeviceConnectNotification, 
                       _IOBluetoothDevice.mEncryptionMode, _IOBluetoothDevice.mLastInquiryUpdate, 
                       _IOBluetoothDevice.mLastNameUpdate, _IOBluetoothDevice.mLastServicesUpdate, 
                       _IOBluetoothDevice.mLinkType, _IOBluetoothDevice.mName, 
                       _IOBluetoothDevice.mPageScanMode, _IOBluetoothDevice.mPageScanPeriodMode, 
                       _IOBluetoothDevice.mPageScanRepetitionMode, _IOBluetoothDevice.mRFCOMMConnection, 
                       _IOBluetoothDevice.mServerDevice, _IOBluetoothDevice.mServiceArray, 
                       _IOBluetoothDeviceExpansion.addressType, _IOBluetoothDeviceExpansion.authenticationRequired, 
                       _IOBluetoothDeviceExpansion.authenticationRetried, 
                       _IOBluetoothDeviceExpansion.channelBeingOpened, 
                       _IOBluetoothDeviceExpansion.connecting, _IOBluetoothDeviceExpansion.connectionRetried, 
                       _IOBluetoothDeviceExpansion.findExisting, _IOBluetoothDeviceExpansion.headsetBatteryPercent, 
                       _IOBluetoothDeviceExpansion.inquiryRSSI, _IOBluetoothDeviceExpansion.lmpSubversion, 
                       _IOBluetoothDeviceExpansion.lmpVersion, _IOBluetoothDeviceExpansion.lowEnergyDevice, 
                       _IOBluetoothDeviceExpansion.lowEnergyDeviceHID2, 
                       _IOBluetoothDeviceExpansion.manufacturerName, _IOBluetoothDeviceExpansion.nameComplete, 
                       _IOBluetoothDeviceExpansion.openConnectionTarget, 
                       _IOBluetoothDeviceExpansion.psm, _IOBluetoothDeviceExpansion.remoteNameRequestTarget, 
                       _IOBluetoothDeviceInfoGatherer.expansionData, _IOBluetoothDeviceInfoGatherer.mATCommandState, 
                       _IOBluetoothDeviceInfoGatherer.mATCommandTimer, 
                       _IOBluetoothDeviceInfoGatherer.mChannelID, _IOBluetoothDeviceInfoGatherer.mDevice, 
                       _IOBluetoothDeviceInfoGatherer.mGetATCommandInfo, 
                       _IOBluetoothDeviceInfoGatherer.mGetSDPInfo, _IOBluetoothDeviceInfoGatherer.mInfoGathered, 
                       _IOBluetoothDeviceInfoGatherer.mLastCommandPtr, 
                       _IOBluetoothDeviceInfoGatherer.mPhoneGMI, _IOBluetoothDeviceInfoGatherer.mPhoneGMM, 
                       _IOBluetoothDeviceInfoGatherer.mPhoneIMSI, _IOBluetoothDeviceInfoGatherer.mPhoneManufacturer, 
                       _IOBluetoothDeviceInfoGatherer.mPhoneModelNumber, 
                       _IOBluetoothDeviceInfoGatherer.mPhoneRevisionID, 
                       _IOBluetoothDeviceInfoGatherer.mProgressSelector, 
                       _IOBluetoothDeviceInfoGatherer.mProgressSelectorTarget, 
                       _IOBluetoothDeviceInfoGatherer.mRFCOMMChannel, _IOBluetoothDeviceInquiryCSupportObject._completeCallback, 
                       _IOBluetoothDeviceInquiryCSupportObject._deviceFoundCallback, 
                       _IOBluetoothDeviceInquiryCSupportObject._deviceNameUpdatedCallback, 
                       _IOBluetoothDeviceInquiryCSupportObject._refCon, 
                       _IOBluetoothDeviceInquiryCSupportObject._startedCallback, 
                       _IOBluetoothDeviceInquiryCSupportObject._updatingNamesStartedCallback, 
                       _IOBluetoothDeviceInquiryExpansion._searchUUIDs, 
                       _IOBluetoothDeviceInquiryExpansion.joinedToDaemon, 
                       _IOBluetoothDeviceInquiryExpansion.rssiThreshold, 
                       _IOBluetoothDeviceInquiryExpansion.searchType, _IOBluetoothDevicePair._SDPQueryComplete, 
                       _IOBluetoothDevicePair._busy, _IOBluetoothDevicePair._connectionCompleteStatus, 
                       _IOBluetoothDevicePair._delegate, _IOBluetoothDevicePair._device, 
                       _IOBluetoothDevicePair._expansion, _IOBluetoothDevicePair._isHandlerSetup, 
                       _IOBluetoothDevicePair._totalAttempts, _IOBluetoothDevicePair._triedSpecNULLPIN, 
                       _IOBluetoothDevicePairExpansion.Q6BDAddrRange, _IOBluetoothDevicePairExpansion._isWiiUProController, 
                       _IOBluetoothDevicePairExpansion.bluetoothHIDDeviceController, 
                       _IOBluetoothDevicePairExpansion.channel, _IOBluetoothDevicePairExpansion.hostController, 
                       _IOBluetoothDevicePairExpansion.isNeuroSwitch, _IOBluetoothDevicePairExpansion.isNonSSPKeypressNotificationCapable, 
                       _IOBluetoothDevicePairExpansion.isPolyVision, _IOBluetoothDevicePairExpansion.isWiiRemote, 
                       _IOBluetoothDevicePairExpansion.pageTimeout, _IOBluetoothDevicePairExpansion.supportsAuthentication, 
                       _IOBluetoothHandsFree._SMSEnabled, _IOBluetoothHandsFree._SMSMode, 
                       _IOBluetoothHandsFree._connectSCOAfterSLCConnected, 
                       _IOBluetoothHandsFree._device, _IOBluetoothHandsFree._deviceCallHoldModes, 
                       _IOBluetoothHandsFree._deviceRFCOMMChannelID, _IOBluetoothHandsFree._deviceSupportedFeatures, 
                       _IOBluetoothHandsFree._deviceSupportedSMSServices, 
                       _IOBluetoothHandsFree._handsFreeState, _IOBluetoothHandsFree._previousInputVolume, 
                       _IOBluetoothHandsFree._previousOutputMuted, _IOBluetoothHandsFree._previousOutputVolume, 
                       _IOBluetoothHandsFree._reserved, _IOBluetoothHandsFree._reserved1, 
                       _IOBluetoothHandsFree._rfcommChannel, _IOBluetoothHandsFree._rfcommChannelNotification, 
                       _IOBluetoothHandsFree._statusIndicators, _IOBluetoothHandsFree._supportedFeatures, 
                       _IOBluetoothHandsFreeAudioGateway._expansion, _IOBluetoothHandsFreeAudioGateway._indicatorEventReporting, 
                       _IOBluetoothHandsFreeAudioGateway._indicatorMode, 
                       _IOBluetoothHandsFreeAudioGatewayExpansion._batteryLevel, 
                       _IOBluetoothHandsFreeAudioGatewayExpansion._dockState, 
                       _IOBluetoothHandsFreeAudioGatewayExpansion._productID, 
                       _IOBluetoothHandsFreeAudioGatewayExpansion._vendorID, 
                       _IOBluetoothHandsFreeAudioGatewayExpansion._version, 
                       _IOBluetoothHandsFreeDevice._commandQueue, _IOBluetoothHandsFreeDevice._expansion, 
                       _IOBluetoothHandsFreeDevice._outstandingCommand, 
                       _IOBluetoothHandsFreeDevice._outstandingCommandTimer, 
                       _IOBluetoothHandsFreeDevice._rejectSCOConnection, 
                       _IOBluetoothHandsFreeDevice._ringAttempt, _IOBluetoothHandsFreeDeviceExpansion._SCOInputBuffer, 
                       _IOBluetoothHandsFreeDeviceExpansion._SCOOutputBuffer, 
                       _IOBluetoothHandsFreeDeviceExpansion._VPIOUnit, 
                       _IOBluetoothHandsFreeDeviceExpansion._driverConnect, 
                       _IOBluetoothHandsFreeDeviceExpansion._outputBufferList, 
                       _IOBluetoothHandsFreeDeviceExpansion._prevInputSampleTime, 
                       _IOBluetoothHandsFreeDeviceExpansion._prevOutputSampleTime, 
                       _IOBluetoothHandsFreeExpansion._SCOConnectionHandle, 
                       _IOBluetoothHandsFreeExpansion._delegate, _IOBluetoothHandsFreeExpansion._disconnectAfterDisconnectingSCO, 
                       _IOBluetoothHandsFreeExpansion._hostController, 
                       _IOBluetoothHandsFreeExpansion._lastUpdatedInputVolume, 
                       _IOBluetoothHandsFreeExpansion._lastUpdatedOutputVolume, 
                       _IOBluetoothHardcopyCableReplacement.command, _IOBluetoothHardcopyCableReplacement.commandChannel, 
                       _IOBluetoothHardcopyCableReplacement.commandChannelIsOpen, 
                       _IOBluetoothHardcopyCableReplacement.data, _IOBluetoothHardcopyCableReplacement.dataChannel, 
                       _IOBluetoothHardcopyCableReplacement.dataChannelIsOpen, 
                       _IOBluetoothHardcopyCableReplacement.mBufferForOutgoingData, 
                       _IOBluetoothHardcopyCableReplacement.mReadPointerInBuffer, 
                       _IOBluetoothHardcopyCableReplacement.mWritePointerInBuffer, 
                       _IOBluetoothHardcopyCableReplacement.printer, _IOBluetoothHardcopyCableReplacement.stringFor1284ID, 
                       _IOBluetoothHostControllerExpansion.delegateClassString, 
                       _IOBluetoothHostControllerExpansion.outstandingRequests, 
                       _IOBluetoothL2CAPChannel._mReserved, _IOBluetoothL2CAPChannel.mChannelPSM, 
                       _IOBluetoothL2CAPChannel.mDataAvailablePort, _IOBluetoothL2CAPChannel.mDevice, 
                       _IOBluetoothL2CAPChannel.mEventDataListener, _IOBluetoothL2CAPChannel.mEventDataListenerRefCon, 
                       _IOBluetoothL2CAPChannel.mIncomingChannel, _IOBluetoothL2CAPChannel.mIncomingDataListener, 
                       _IOBluetoothL2CAPChannel.mIncomingDataListenerRefCon, 
                       _IOBluetoothL2CAPChannel.mIncomingDataQueue, _IOBluetoothL2CAPChannel.mIsClosed, 
                       _IOBluetoothL2CAPChannel.mL2CAPChannelConnectionHandler, 
                       _IOBluetoothL2CAPChannel.mLocalChannelID, _IOBluetoothL2CAPChannel.mObjectID, 
                       _IOBluetoothL2CAPChannel.mRemoteChannelID, _IOBluetoothL2CAPChannelExpansion.configDictionary, 
                       _IOBluetoothLEA._LEAPChannel, _IOBluetoothLEA._LEASChannel, 
                       _IOBluetoothLEA._audioContent, _IOBluetoothLEA._audioMixing, 
                       _IOBluetoothLEA._bitrate, _IOBluetoothLEA._bluetoothDevice, 
                       _IOBluetoothLEA._central, _IOBluetoothLEA._codec, 
                       _IOBluetoothLEA._codecProperty, _IOBluetoothLEA._companyID, 
                       _IOBluetoothLEA._delegate, _IOBluetoothLEA._hardwareVersion, 
                       _IOBluetoothLEA._input, _IOBluetoothLEA._lastUpdatedVolume, 
                       _IOBluetoothLEA._latency, _IOBluetoothLEA._maxPacketSize, 
                       _IOBluetoothLEA._maxSupportedPacketSize, _IOBluetoothLEA._output, 
                       _IOBluetoothLEA._pendingState, _IOBluetoothLEA._peripheral, 
                       _IOBluetoothLEA._previousMuted, _IOBluetoothLEA._previousVolume, 
                       _IOBluetoothLEA._relatedDevice, _IOBluetoothLEA._renderingDelay, 
                       _IOBluetoothLEA._rightChannel, _IOBluetoothLEA._sampleRate, 
                       _IOBluetoothLEA._softwareVersion, _IOBluetoothLEA._state, 
                       _IOBluetoothLEA._stereo, _IOBluetoothLEA._streamReady, 
                       _IOBluetoothLEA._supportedCodecs, _IOBluetoothLEA._version, 
                       _IOBluetoothLocalSDPServiceRecord.mAllowedDevices, 
                       _IOBluetoothLocalSDPServiceRecord.mIncomingChannelNotification, 
                       _IOBluetoothLocalSDPServiceRecord.mLocalAttributeDictionary, 
                       _IOBluetoothLocalSDPServiceRecord.mRestrictedDevices, 
                       _IOBluetoothLocalSDPServiceRecord.mServerAttributeDictionary, 
                       _IOBluetoothNSCUserNotification.mCallback, _IOBluetoothNSCUserNotification.mRefCon, 
                       _IOBluetoothNSObjCUserNotification.mObserver, _IOBluetoothNSObjCUserNotification.mSelector, 
                       _IOBluetoothNSUserNotification.mObject, _IOBluetoothNotification.mCallback, 
                       _IOBluetoothNotification.mClass, _IOBluetoothNotification.mSubClass, 
                       _IOBluetoothNotification.mUserRefCon, _IOBluetoothOBEXSession.bufferSize, 
                       _IOBluetoothOBEXSession.currentOffsetInBuffer, _IOBluetoothOBEXSession.mDevice, 
                       _IOBluetoothOBEXSession.mOpenConnectionCallback, 
                       _IOBluetoothOBEXSession.mOpenConnectionCallbackRefCon, 
                       _IOBluetoothOBEXSession.mOpenConnectionRefCon, _IOBluetoothOBEXSession.mOpenConnectionSelector, 
                       _IOBluetoothOBEXSession.mOpenConnectionSelectorTarget, 
                       _IOBluetoothOBEXSession.mOpenConnectionTimeout, 
                       _IOBluetoothOBEXSession.mRFCOMMChannel, _IOBluetoothOBEXSession.mRFCOMMChannelID, 
                       _IOBluetoothOBEXSession.outBuffer, _IOBluetoothOBEXSession.waitingForRfcommSpace, 
                       _IOBluetoothObject.mIOConnection, _IOBluetoothObject.mIONotification, 
                       _IOBluetoothObject.mIOService, _IOBluetoothPreferences.bluetoothPrefs, 
                       _IOBluetoothRFCOMMChannel._mReserved, _IOBluetoothRFCOMMChannel.delegate, 
                       _IOBluetoothRFCOMMChannel.mChannelID, _IOBluetoothRFCOMMChannel.mChannelIsOpen, 
                       _IOBluetoothRFCOMMChannel.mDataAvailablePort, _IOBluetoothRFCOMMChannel.mDevice, 
                       _IOBluetoothRFCOMMChannel.mEventDataListener, _IOBluetoothRFCOMMChannel.mEventDataListenerRefCon, 
                       _IOBluetoothRFCOMMChannel.mIncomingDataListener, 
                       _IOBluetoothRFCOMMChannel.mIncomingDataListenerRefCon, 
                       _IOBluetoothRFCOMMChannel.mIncomingDataQueue, _IOBluetoothRFCOMMChannel.mIsIncoming, 
                       _IOBluetoothRFCOMMChannel.mL2Channel, _IOBluetoothRFCOMMChannel.mMTU, 
                       _IOBluetoothRFCOMMChannel.mObjectID, _IOBluetoothRFCOMMConnection.mMasterPort, 
                       _IOBluetoothRFCOMMConnection.mNotificationPort, 
                       _IOBluetoothRFCOMMConnection.mPendingChannels, _IOBluetoothRFCOMMConnection.mReferenceDevice, 
                       _IOBluetoothSDPDataElement._mReserved, _IOBluetoothSDPDataElement.mSize, 
                       _IOBluetoothSDPDataElement.mSizeDescriptor, _IOBluetoothSDPDataElement.mTypeDescriptor, 
                       _IOBluetoothSDPDataElement.mValue, _IOBluetoothSDPServiceAttribute._mReserved, 
                       _IOBluetoothSDPServiceAttribute.mAttributeDataElement, 
                       _IOBluetoothSDPServiceAttribute.mAttributeID, _IOBluetoothSDPServiceAttribute.mAttributeIDDataElement, 
                       _IOBluetoothSDPServiceRecord.mAttributeDictionary, 
                       _IOBluetoothSDPServiceRecord.mDeviceForService, 
                       _IOBluetoothSDPServiceRecord.sortedAttributes, _IOBluetoothSDPUUID._mReserved, 
                       _IOBluetoothSDPUUID.mUUIDData, _IOBluetoothSerialPort._originalName, 
                       _IOBluetoothSerialPort._properties, _IOBluetoothSerialPort._serviceDictionary, 
                       _IOBluetoothTransferProgress.mEndDate, _IOBluetoothTransferProgress.mMaxPacketLength, 
                       _IOBluetoothTransferProgress.mPercentDone, _IOBluetoothTransferProgress.mRateIndex, 
                       _IOBluetoothTransferProgress.mRemainingBytes, _IOBluetoothTransferProgress.mSavedTime, 
                       _IOBluetoothTransferProgress.mSecondsRemaining, 
                       _IOBluetoothTransferProgress.mSpeedAverages, _IOBluetoothTransferProgress.mSpeedIndex, 
                       _IOBluetoothTransferProgress.mThreshold, _IOBluetoothTransferProgress.mTimeOfTransferStart, 
                       _IOBluetoothTransferProgress.mTotalBytes, _IOBluetoothTransferProgress.mTransferRate, 
                       _IOBluetoothTransferProgress.mTransferState, _IOBluetoothTransferProgress.mTransferedBytes, 
                       _IOBluetoothTransferProgress.mUpdateTimer, _IORegistryObjectNotifier._IORegistryObjectNotifierNotificationPort, 
                       _IORegistryObjectNotifier._connectObserver, _IORegistryObjectNotifier._connectSelector, 
                       _IORegistryObjectNotifier._deviceConnectNotification, 
                       _IORegistryObjectNotifier._deviceDisconnectNotification, 
                       _IORegistryObjectNotifier._disconnectObserver, _IORegistryObjectNotifier._disconnectSelector, 
                       _NotificationInfo.mNotification, _NotificationInfo.object, 
                       _OBEXFileAction.mAbortedByOwner, _OBEXFileAction.mActionArgument, 
                       _OBEXFileAction.mActionInProgress, _OBEXFileAction.mArchiveOptions, 
                       _OBEXFileAction.mConnectionID, _OBEXFileAction.mCountHeader, 
                       _OBEXFileAction.mCurrentRemoteDirectory, _OBEXFileAction.mDataSentSoFar, 
                       _OBEXFileAction.mError, _OBEXFileAction.mEventSelector, 
                       _OBEXFileAction.mFileRef, _OBEXFileAction.mHeadersDataRef, 
                       _OBEXFileAction.mInactivityThreshold, _OBEXFileAction.mInactivityTimer, 
                       _OBEXFileAction.mMaxPacketLength, _OBEXFileAction.mOBEXSession, 
                       _OBEXFileAction.mOptions, _OBEXFileAction.mSelectorTarget, 
                       _OBEXFileAction.mSubclassIsGet, _OBEXFileAction.mTargetIsAMac, 
                       _OBEXFileAction.mTempDataBuffer, _OBEXFileAction.mTransferProgress, 
                       _OBEXFileAction.mUseConnectionID, _OBEXFileAction.mUserDefinedHeaderData, 
                       _OBEXFileAction.mWeAreAborting, _OBEXFileAction.mWeOpenedTheOBEXConnection, 
                       _OBEXSession.mHasOBEXConnection, _OBEXSession.mIncompletePacketResponseCode, 
                       _OBEXSession.mIsServer, _OBEXSession.mMaxPacketLength, 
                       _OBEXSession.mOurMaxPacketLength, _OBEXSession.mPrivateOBEXSessionData, 
                       _OBEXSession.mReceivePacketBuffer, _OBEXSession.mResponsePacketDataLengthExpected, 
                       _OBEXSession.mResponsePacketDataLengthSoFar, _OBEXSession.mTheirMaxPacketLength, 
                       _RegistryObjectNotificationWrapper._registryObject, 
                       _SDPQueryCallbackDispatcher.mRefCon, _SDPQueryCallbackDispatcher.mTarget, 
                       _SystemPowerNotifier._delegate, _SystemPowerNotifier._notificationPort, 
                       _SystemPowerNotifier._notifier, _SystemPowerNotifier._rootConnection ]
  - archs:           [ i386, x86_64 ]
    re-exports:      [ /System/Library/Frameworks/CoreBluetooth.framework/Versions/A/CoreBluetooth, 
                       /usr/lib/libobjc.A.dylib ]
    symbols:         [ _AAPServerUUID, _AAPServiceUUID, _AddEmptyDataRefToDictionary, 
                       _AddEmptyStringToDictionary, _AppleArchiveCreateUniquelyFromPath, 
                       _AppleArchiveExpandAtPath, _AppleSingleToUTCDateTime, 
                       _BCCMD16ToUInt16, _BCCMD16ToUInt8, _BCCMD32ToUInt32, 
                       _BTNSObjectFromXPCObject, _BTXPCObjectFromNSObject, 
                       _BluetoothAudioNotificationType, _BluetoothClearIdleTimerInNVRAM, 
                       _BluetoothDisableIdleTimer, _BluetoothDoReset, _BluetoothEnableIdleTimer, 
                       _BluetoothHCIAcceptSynchronousConnectionRequest, 
                       _BluetoothHCIChangeConnectionPacketType, _BluetoothHCIControllerGeneralInterestNotification, 
                       _BluetoothHCIControllerPublished, _BluetoothHCIControllerSupportsSleep, 
                       _BluetoothHCIDecodeError, _BluetoothHCIDecodeIOReturnError, 
                       _BluetoothHCIDisconnect, _BluetoothHCIDispatchUserClientRoutine, 
                       _BluetoothHCIDumpStats, _BluetoothHCIGetAsyncNotificationPort, 
                       _BluetoothHCIGetSynchronousConnectionPacketType, 
                       _BluetoothHCIGetTransportHardwareStatus, _BluetoothHCIGetTransportInfo, 
                       _BluetoothHCIKillAllPendingRequests, _BluetoothHCILMPLoggingEnabled, 
                       _BluetoothHCIRejectSynchronousConnectionRequest, 
                       _BluetoothHCIRequestCreate, _BluetoothHCIRequestDelete, 
                       _BluetoothHCIResetTransportHardwareStatus, _BluetoothHCISendRawACLData, 
                       _BluetoothHCISendRawCommand, _BluetoothHCISetAllowedChannels, 
                       _BluetoothHCISetDefaultChannelSettings, _BluetoothHCISetDefaultL2CAPChannelSettings, 
                       _BluetoothHCISetupAsyncNotifications, _BluetoothHCISetupSynchronousConnection, 
                       _BluetoothHCISetupUserClient, _BluetoothHCISwitchToSelectedHostController, 
                       _BluetoothHCITearDownUserClient, _BluetoothHCIToggleLMPLogging, 
                       _BluetoothHCIToggleSCOConnection, _BluetoothHCIToggleeSCOEV3Connection, 
                       _BluetoothHCIToggleeSCOEV4Connection, _BluetoothHCIToggleeSCOEV5Connection, 
                       _BluetoothHCIUserClientMethodNames, _BluetoothHCIVendorCommand, 
                       _BluetoothHCIWriteLinkPolicySettings, _BluetoothHCIWritePageTimeout, 
                       _BluetoothLECreateConnection, _BluetoothSetBTPD, 
                       _BluetoothSetBTPU, _BluetoothSetBTRS, _BluetoothSetIdleTimer, 
                       _BluetoothSetIdleTimerInNVRAM, _BluetoothUpdateFirmware, 
                       _CStringAppend, _ConvertPStringToUnicode, _ConvertUnicodeToPString, 
                       _CopyCToPascalString, _CreateHIDDeviceInterface, 
                       _DaemonHandlePINCodeRequestForDevice, _DaemonRemovePINCodeHandler, 
                       _DeviceConnectedCallback, _DeviceDisconnectedCallback, 
                       _DeviceManagerLibBuildDaemonConnection, _DeviceManagerLibGetDaemonConnection, 
                       _DumpHeaderBytes, _ElementCookieForUsage, _EventServiceConnectedCallback, 
                       _EventServiceDisconnectedCallback, _EventServiceInterestCallback, 
                       _FSAppendAppleSingleEncoded, _FSAppleSingleDecode, 
                       _FSAppleSingleDecodeData, _FSAppleSingleEncode, 
                       _FSArchiveAppendItem, _FSCopyForkData, _FSCreateAppleArchive, 
                       _FSCreateArchive, _FSCreateFileBuffer, _FSCreateUniqueArchive, 
                       _FSCreateUniqueFile, _FSCreateUniqueSpecialFolderArchive, 
                       _FSCreateUniquelyNamedAppleArchive, _FSDeleteFileBuffer, 
                       _FSExists, _FSExpandAppleArchive, _FSExpandArchive, 
                       _FSMakeFSRef, _FSMakeUniqueName, _FSNeedsArchiving, 
                       _FSReadForkSkip, _FSRefToNSStringPath, _FileHasResourceFork, 
                       _FileHasTypeAndCreator, _GetGMTDelta, _HCreateFile, 
                       _HExists, _HIDDeviceForIOBluetoothDevice, _HMakeFSRef, 
                       _HMakeUniqueName, _HostController_AsyncHCIEventsNotificationHandler, 
                       _IOBluetoothAddAllowedIncomingL2CAPChannel, _IOBluetoothAddAllowedIncomingRFCOMMChannel, 
                       _IOBluetoothAddPANDevice, _IOBluetoothAddPersistentSerialPort, 
                       _IOBluetoothAddPersistentSerialPortWithService, 
                       _IOBluetoothAddSCOAudioDevice, _IOBluetoothAddSecureIncomingRFCOMMChannel, 
                       _IOBluetoothAddServiceDict, _IOBluetoothAllowRoleSwitchForDevice, 
                       _IOBluetoothAudioChange, _IOBluetoothBroadcomSchedulerWorkaround, 
                       _IOBluetoothCFStringFromDeviceAddress, _IOBluetoothCFStringToDeviceAddress, 
                       _IOBluetoothCSRLibAccessToPSKey, _IOBluetoothCSRLibBCCMDGetNewSequenceNumber, 
                       _IOBluetoothCSRLibClearAllPSKeys, _IOBluetoothCSRLibClearPSKey, 
                       _IOBluetoothCSRLibGetBCCMDMessageLen, _IOBluetoothCSRLibGetBCCMDMessageNumberOfWords, 
                       _IOBluetoothCSRLibHCISendBCCMDMessage, _IOBluetoothCSRLibHandleBCCMDData, 
                       _IOBluetoothCSRLibReadPSKey, _IOBluetoothCSRLibSendBCCMDMessage, 
                       _IOBluetoothCSRLibSetPSCallback, _IOBluetoothCSRLibWritePSKey, 
                       _IOBluetoothClearCachedValues, _IOBluetoothClearIncomingChannelRules, 
                       _IOBluetoothClearRunInactivityTimerInNVRAM, _IOBluetoothConfigureHIDDevice, 
                       _IOBluetoothConsoleUserID, _IOBluetoothConsoleUserName, 
                       _IOBluetoothDeviceCloseConnection, _IOBluetoothDeviceCreateWithAddress, 
                       _IOBluetoothDeviceCreateWithService, _IOBluetoothDeviceGetAddress, 
                       _IOBluetoothDeviceGetAddressString, _IOBluetoothDeviceGetConfigurableTypes, 
                       _IOBluetoothDeviceGetConfiguredTypes, _IOBluetoothDeviceGetDeviceClassMajor, 
                       _IOBluetoothDeviceGetLastServicesUpdate, _IOBluetoothDeviceGetName, 
                       _IOBluetoothDeviceGetNameOrAddress, _IOBluetoothDeviceGetServiceRecordForUUID, 
                       _IOBluetoothDeviceGetServices, _IOBluetoothDeviceInquiryClearFoundDevices, 
                       _IOBluetoothDeviceInquiryCreateWithCallbackRefCon, 
                       _IOBluetoothDeviceInquiryDelete, _IOBluetoothDeviceInquiryGetFoundDevices, 
                       _IOBluetoothDeviceInquiryGetInquiryLength, _IOBluetoothDeviceInquiryGetUpdateNewDeviceNames, 
                       _IOBluetoothDeviceInquiryGetUserRefCon, _IOBluetoothDeviceInquirySetCompleteCallback, 
                       _IOBluetoothDeviceInquirySetDeviceFoundCallback, 
                       _IOBluetoothDeviceInquirySetDeviceNameUpdatedCallback, 
                       _IOBluetoothDeviceInquirySetInquiryLength, _IOBluetoothDeviceInquirySetSearchCriteria, 
                       _IOBluetoothDeviceInquirySetStartedCallback, _IOBluetoothDeviceInquirySetUpdateNewDeviceNames, 
                       _IOBluetoothDeviceInquirySetUpdatingNamesStartedCallback, 
                       _IOBluetoothDeviceInquirySetUserRefCon, _IOBluetoothDeviceInquiryStart, 
                       _IOBluetoothDeviceInquiryStop, _IOBluetoothDeviceIsConnected, 
                       _IOBluetoothDeviceOpenConnection, _IOBluetoothDeviceOpenConnectionWithOptions, 
                       _IOBluetoothDeviceOpenL2CAPChannelAsync, _IOBluetoothDeviceOpenL2CAPChannelAsyncWithConfiguration, 
                       _IOBluetoothDeviceOpenL2CAPChannelSync, _IOBluetoothDeviceOpenL2CAPChannelSyncWithConfiguration, 
                       _IOBluetoothDevicePerformSDPQuery, _IOBluetoothDeviceRegisterForDisconnectNotification, 
                       _IOBluetoothDeviceRemoteNameRequest, _IOBluetoothDeviceRemoteNameRequestWithTimeout, 
                       _IOBluetoothDeviceServiceAdded, _IOBluetoothDisallowRoleSwitchForDevice, 
                       _IOBluetoothEnableConsoleUserNotifications, _IOBluetoothFileLogHelper, 
                       _IOBluetoothFileLogHelperFlushFileCache, _IOBluetoothFindNumberOfRegistryEntriesOfClassName, 
                       _IOBluetoothFrameworkInit, _IOBluetoothFrameworkNotificationPort, 
                       _IOBluetoothGainAdministrationPrivileges, _IOBluetoothGetAddressFromService, 
                       _IOBluetoothGetAllOpenL2CAPChannelsForPSM, _IOBluetoothGetAllOpenRFCOMMChannelsForID, 
                       _IOBluetoothGetAllowedIncomingRFCOMMChannels, _IOBluetoothGetBluetoothHCIVersionString, 
                       _IOBluetoothGetBluetoothModemPortDictionary, _IOBluetoothGetBluetoothStackVersionString, 
                       _IOBluetoothGetCachedValues, _IOBluetoothGetChipsetID, 
                       _IOBluetoothGetChipsetString, _IOBluetoothGetConfiguredDeviceAddresses, 
                       _IOBluetoothGetConfiguredDevices, _IOBluetoothGetLocalServices, 
                       _IOBluetoothGetObjectIDFromArguments, _IOBluetoothGetObjectIDFromIOService, 
                       _IOBluetoothGetPANConnectionState, _IOBluetoothGetPairedDevices, 
                       _IOBluetoothGetUniqueFileNameAndPath, _IOBluetoothGetUniqueFileNameAndWithCFStringPath, 
                       _IOBluetoothGetVersion, _IOBluetoothHCIControllerDisableL2CAPKernelDrivers, 
                       _IOBluetoothHandsFreeCallDirection, _IOBluetoothHandsFreeCallIndex, 
                       _IOBluetoothHandsFreeCallMode, _IOBluetoothHandsFreeCallMultiparty, 
                       _IOBluetoothHandsFreeCallName, _IOBluetoothHandsFreeCallNumber, 
                       _IOBluetoothHandsFreeCallStatus, _IOBluetoothHandsFreeCallType, 
                       _IOBluetoothHandsFreeIndicatorBattChg, _IOBluetoothHandsFreeIndicatorCall, 
                       _IOBluetoothHandsFreeIndicatorCallHeld, _IOBluetoothHandsFreeIndicatorCallSetup, 
                       _IOBluetoothHandsFreeIndicatorRoam, _IOBluetoothHandsFreeIndicatorService, 
                       _IOBluetoothHandsFreeIndicatorSignal, _IOBluetoothHostControllerConfigStateChangeNotification, 
                       _IOBluetoothHostControllerConfigStateOnlineNotification, 
                       _IOBluetoothHostControllerDidResetNotification, 
                       _IOBluetoothHostControllerNameDidChangeNotification, 
                       _IOBluetoothHostControllerPoweredOffNotification, 
                       _IOBluetoothHostControllerPoweredOnNotification, 
                       _IOBluetoothHostControllerPublishedNotification, 
                       _IOBluetoothHostControllerScanEnableDidChangeNotification, 
                       _IOBluetoothHostControllerTerminatedNotification, 
                       _IOBluetoothIgnoreHIDDevice, _IOBluetoothIndicatorCurrentValue, 
                       _IOBluetoothIndicatorIndex, _IOBluetoothIndicatorName, 
                       _IOBluetoothIsBluetoothSecured, _IOBluetoothIsConfiguredHIDDevice, 
                       _IOBluetoothIsFileAppleDesignatedPIMData, _IOBluetoothIsFileAppleDesignatedPIMDataAtCFStringPath, 
                       _IOBluetoothIsMachinePortable, _IOBluetoothL2CAPChannelCloseChannel, 
                       _IOBluetoothL2CAPChannelGetIncomingMTU, _IOBluetoothL2CAPChannelGetOutgoingMTU, 
                       _IOBluetoothL2CAPChannelPublishedNotification, _IOBluetoothL2CAPChannelRegisterForChannelCloseNotification, 
                       _IOBluetoothL2CAPChannelRegisterIncomingEventListener, 
                       _IOBluetoothL2CAPChannelRegisterIncomingEventListenerWithConfiguration, 
                       _IOBluetoothL2CAPChannelTerminatedNotification, 
                       _IOBluetoothL2CAPChannelWrite, _IOBluetoothL2CAPChannelWriteAsync, 
                       _IOBluetoothLEAudioChange, _IOBluetoothLocalDeviceAvailable, 
                       _IOBluetoothLocalDeviceGetConfigState, _IOBluetoothLocalDeviceGetPowerState, 
                       _IOBluetoothLocalDeviceGetUSBProductID, _IOBluetoothLocalDeviceGetUSBVendorID, 
                       _IOBluetoothLocalDeviceReadName, _IOBluetoothLocalDeviceSetDiscoverable, 
                       _IOBluetoothLocalDeviceSetPowerState, _IOBluetoothLocalDeviceSupportsPowerOff, 
                       _IOBluetoothLogHelper, _IOBluetoothMaxIndicatorValue, 
                       _IOBluetoothMinIndicatorValue, _IOBluetoothModifyPersistentSerialPort, 
                       _IOBluetoothNSStringFromDeviceAddress, _IOBluetoothNSStringFromDeviceAddressColon, 
                       _IOBluetoothNSStringToDeviceAddress, _IOBluetoothNotificationLibAddHCIControllerRunLoopNotification, 
                       _IOBluetoothNotificationLibAddNotificationForClassName, 
                       _IOBluetoothNotificationLibCheckForExistingHCIControllersAndNotify, 
                       _IOBluetoothNotificationLibDoHCIClientNotification, 
                       _IOBluetoothNotificationLibHCIControllerInterestedCallback, 
                       _IOBluetoothNotificationLibHCIControllerPublishedCallback, 
                       _IOBluetoothNotificationLibHCIRawEventHandler, _IOBluetoothNotificationLibHCIRawEventsSetup, 
                       _IOBluetoothNotificationLibNotificationCreate, _IOBluetoothNotificationLibNotificationDelete, 
                       _IOBluetoothNotificationLibSetup, _IOBluetoothNumberOfAvailableHIDDevices, 
                       _IOBluetoothNumberOfKeyboardHIDDevices, _IOBluetoothNumberOfPointingHIDDevices, 
                       _IOBluetoothNumberOfTabletHIDDevices, _IOBluetoothOBEXSessionCreateWithIOBluetoothDeviceRefAndChannelNumber, 
                       _IOBluetoothOBEXSessionCreateWithIOBluetoothSDPServiceRecordRef, 
                       _IOBluetoothOBEXSessionCreateWithIncomingIOBluetoothRFCOMMChannel, 
                       _IOBluetoothOBEXSessionOpenTransportConnection, 
                       _IOBluetoothObjectRelease, _IOBluetoothObjectRetain, 
                       _IOBluetoothObjectServiceTerminated, _IOBluetoothPDUEncoding, 
                       _IOBluetoothPDUOriginatingAddress, _IOBluetoothPDUOriginatingAddressType, 
                       _IOBluetoothPDUProtocolID, _IOBluetoothPDUServicCenterAddress, 
                       _IOBluetoothPDUServiceCenterAddressType, _IOBluetoothPDUTimestamp, 
                       _IOBluetoothPDUType, _IOBluetoothPDUUserData, _IOBluetoothPackData, 
                       _IOBluetoothPackDataList, _IOBluetoothPreferenceAddFavoriteAddressString, 
                       _IOBluetoothPreferenceBuildPrefsServerConnection, 
                       _IOBluetoothPreferenceGetAutoSeekForKeyboard, _IOBluetoothPreferenceGetAutoSeekForPointingDevice, 
                       _IOBluetoothPreferenceGetBrowseConnectionHandling, 
                       _IOBluetoothPreferenceGetControllerPowerState, _IOBluetoothPreferenceGetDiscoverableState, 
                       _IOBluetoothPreferenceGetFTPRequiresPairing, _IOBluetoothPreferenceGetFavoriteAddressStrings, 
                       _IOBluetoothPreferenceGetOBEXFTPRootFolderLocation, 
                       _IOBluetoothPreferenceGetOBEXFileExchangeSaveToLocation, 
                       _IOBluetoothPreferenceGetOBEXFileHandling, _IOBluetoothPreferenceGetOBEXFileTransferEnabled, 
                       _IOBluetoothPreferenceGetOBEXOtherDataDisposition, 
                       _IOBluetoothPreferenceGetOPPRequiresPairing, _IOBluetoothPreferenceGetRemoteWakeEnabled, 
                       _IOBluetoothPreferenceGetServicesEnabled, _IOBluetoothPreferenceIsFavoriteAddressString, 
                       _IOBluetoothPreferenceRemoveFavoriteAddressString, 
                       _IOBluetoothPreferenceSetAutoSeekForKeyboard, _IOBluetoothPreferenceSetAutoSeekForPointingDevice, 
                       _IOBluetoothPreferenceSetBluetoothPrefPaneOpen, 
                       _IOBluetoothPreferenceSetBrowseConnectionHandling, 
                       _IOBluetoothPreferenceSetControllerPowerState, _IOBluetoothPreferenceSetDiscoverableState, 
                       _IOBluetoothPreferenceSetFTPRequiresPairing, _IOBluetoothPreferenceSetOBEXFTPRootFolderLocation, 
                       _IOBluetoothPreferenceSetOBEXFileExchangeSaveToLocation, 
                       _IOBluetoothPreferenceSetOBEXFileHandling, _IOBluetoothPreferenceSetOBEXFileTransferEnabled, 
                       _IOBluetoothPreferenceSetOBEXOtherDataDisposition, 
                       _IOBluetoothPreferenceSetOPPRequiresPairing, _IOBluetoothPreferenceSetRemoteWakeEnabled, 
                       _IOBluetoothPreferenceSetServicesEnabled, _IOBluetoothPreferencesAvailable, 
                       _IOBluetoothPreferencesGetValueForKey, _IOBluetoothPreferencesSetValueForKey, 
                       _IOBluetoothRFCOMMChannelIsInitiatorLocal, _IOBluetoothRFCOMMChannelRegisterForChannelCloseNotification, 
                       _IOBluetoothRecentDevices, _IOBluetoothRegisterForDeviceConnectNotifications, 
                       _IOBluetoothRegisterForFilteredL2CAPChannelOpenNotifications, 
                       _IOBluetoothRegisterForFilteredRFCOMMChannelOpenNotifications, 
                       _IOBluetoothRegisterForL2CAPChannelOpenNotifications, 
                       _IOBluetoothRegisterForNotifications, _IOBluetoothRegisterForRFCOMMChannelOpenNotifications, 
                       _IOBluetoothRemoveAllowedIncomingL2CAPChannel, _IOBluetoothRemoveAllowedIncomingRFCOMMChannel, 
                       _IOBluetoothRemoveCachedValue, _IOBluetoothRemoveConfiguredDevice, 
                       _IOBluetoothRemoveIgnoredHIDDevice, _IOBluetoothRemoveLinkKeyForDevice, 
                       _IOBluetoothRemovePANDevice, _IOBluetoothRemovePersistentSerialPort, 
                       _IOBluetoothRemoveRegistrationForNotifications, 
                       _IOBluetoothRemoveSCOAudioDevice, _IOBluetoothRemoveServiceWithRecordHandle, 
                       _IOBluetoothRingBufferInit, _IOBluetoothRingBufferRead, 
                       _IOBluetoothRingBufferReadAtOffset, _IOBluetoothRingBufferRelease, 
                       _IOBluetoothRingBufferWrite, _IOBluetoothRingBufferWriteAtOffset, 
                       _IOBluetoothSDPDataElementContainsDataElement, _IOBluetoothSDPDataElementGetArrayValue, 
                       _IOBluetoothSDPDataElementGetDataValue, _IOBluetoothSDPDataElementGetNumberValue, 
                       _IOBluetoothSDPDataElementGetSize, _IOBluetoothSDPDataElementGetSizeDescriptor, 
                       _IOBluetoothSDPDataElementGetStringValue, _IOBluetoothSDPDataElementGetTypeDescriptor, 
                       _IOBluetoothSDPDataElementGetUUIDValue, _IOBluetoothSDPDataElementIsEqualToDataElement, 
                       _IOBluetoothSDPServiceRecordGetAttributeDataElement, 
                       _IOBluetoothSDPUUIDCreateUUID16, _IOBluetoothSDPUUIDGetBytes, 
                       _IOBluetoothSDPUUIDGetLength, _IOBluetoothSDPUUIDIsEqualToUUID, 
                       _IOBluetoothSVNVersion, _IOBluetoothSecureBluetooth, 
                       _IOBluetoothSelectBTPD, _IOBluetoothSelectBTPU, 
                       _IOBluetoothSelectBTRS, _IOBluetoothSelectReset, 
                       _IOBluetoothSetPANConnectionState, _IOBluetoothSetRunInactivityTimer, 
                       _IOBluetoothSetRunInactivityTimerInNVRAM, _IOBluetoothShouldRunInactivityTimer, 
                       _IOBluetoothSystemHasOnlyBluetoothPointingDevices, 
                       _IOBluetoothSystemModelIdentifier, _IOBluetoothTearDownPreferencesServer, 
                       _IOBluetoothUnpackData, _IOBluetoothUnpackDataList, 
                       _IOBluetoothUnregisterHIDDevice, _IOBluetoothUpdateSystemActivity, 
                       _IOBluetoothUserNotificationUnregister, _ItemAtPathNeedsArchiving, 
                       _LEAValidLength, _NSStringPathResolveAliasesAndLinks, 
                       _NSStringPathToCFURL, _NSStringPathToFSRef, _OBEXAddApplicationParameterHeader, 
                       _OBEXAddAuthorizationChallengeHeader, _OBEXAddAuthorizationResponseHeader, 
                       _OBEXAddBodyHeader, _OBEXAddByteSequenceHeader, 
                       _OBEXAddConnectionIDHeader, _OBEXAddCountHeader, 
                       _OBEXAddDescriptionHeader, _OBEXAddHTTPHeader, _OBEXAddImageDescriptorHeader, 
                       _OBEXAddImageHandleHeader, _OBEXAddLengthHeader, 
                       _OBEXAddNameHeader, _OBEXAddObjectClassHeader, _OBEXAddTargetHeader, 
                       _OBEXAddTime4ByteHeader, _OBEXAddTimeISOHeader, 
                       _OBEXAddTypeHeader, _OBEXAddUserDefinedHeader, _OBEXAddWhoHeader, 
                       _OBEXCreateVCalendar, _OBEXCreateVCard, _OBEXCreateVEvent, 
                       _OBEXFolderListingCreateFromFile, _OBEXFolderListingGetObjectArray, 
                       _OBEXFolderListingPrintDictionary, _OBEXGetHeaders, 
                       _OBEXHeadersToBytes, _OBEXPatchXMLData, _OBEXSessionAbort, 
                       _OBEXSessionAbortResponse, _OBEXSessionConnect, 
                       _OBEXSessionConnectResponse, _OBEXSessionDelete, 
                       _OBEXSessionDisconnect, _OBEXSessionDisconnectResponse, 
                       _OBEXSessionGet, _OBEXSessionGetAvailableCommandPayloadLength, 
                       _OBEXSessionGetAvailableCommandResponsePayloadLength, 
                       _OBEXSessionGetMaxPacketLength, _OBEXSessionGetResponse, 
                       _OBEXSessionHasOpenOBEXConnection, _OBEXSessionPut, 
                       _OBEXSessionPutResponse, _OBEXSessionSetPath, _OBEXSessionSetPathResponse, 
                       _OBEXSessionSetServerCallback, _OBEXSetDebugLogVerbosity, 
                       _PStringAppend, _PStringAppendChar, _PStringAppendNumber, 
                       _PStringAppendText, _PStringCopy, _PStringToUnicodeSimple, 
                       _PackData, _PackDataList, _ParseOBEXPacket, _ParseServerConnectResponse, 
                       _PostNotification, _QueueNonEmptyCallback, _RegistryObject_ConnectedCallback, 
                       _RegistryObject_DisconnectedCallback, _ReturnAllCurrentDevices, 
                       _ReturnAllCurrentL2Channels, _ReturnAllCurrentRFCOMMChannels, 
                       _ServiceInterestCallback, _SetupDevicePublicationNotifications, 
                       _StringByRemovingCharactersInString, _SystemPowerNotificationLib_SleepNotificationCallback, 
                       _TextFindExtension, _UInt16ToBCCMD16, _UInt32ToBCCMD32, 
                       _UInt8ToBCCMD16, _UTCDateTimeToAppleSingleSeconds, 
                       _UTF8ToUnicode, _UnicodeAppend, _UnicodeFindFilenameExtension, 
                       _UnicodeIsAlpha, _UnicodeIsPrint, _UnicodeReverseCharSearch, 
                       _UnicodeToUTF8, _UnpackData, _UnpackDataList, _UnpackExtendedInquiryResponse, 
                       __IOBluetoothRingBufferBytesAvailable, __IOBluetoothRingBufferBytesInBuffer, 
                       __IOBluetoothRingBufferSequentialBytesAvailable, 
                       __IOBluetoothRingBufferSequentialBytesInBuffer, 
                       __IORegistryObjectNotifierNotificationPort, __recurseElements, 
                       _btNotificationAddNotificationForClass, _btNotificationDevicePublished, 
                       _btNotificationDeviceTerminated, _btNotificationL2ChannelPublished, 
                       _btNotificationL2ChannelTerminated, _btNotificationRFCOMMChannelPublished, 
                       _btNotificationRFCOMMChannelTerminated, _findServiceWithObjectID, 
                       _gAppleMacintoshAttributesUUID, _gAppleMacintoshAttributesUUIDLength, 
                       _gAppleMacintoshClassUUID, _gAppleMacintoshClassUUIDSize, 
                       _gBluetoothHCIDataPort, _gBluetoothHCIObject, _gDaemonServer, 
                       _gHCIAyncNotificationPort, _gHCINotifPortRef, _gHCIServiceNotification, 
                       _gIsNewController, _gNotificationLibAsyncIDRefCon, 
                       _gNotificationLibIsSetup, _gNotificationLibRunLoopSourceRef, 
                       _gOBEXDebugLogVerbosityLevel, _gRunningInDaemon, 
                       _gSerialPortCreationIndex, _internetSharingIsEnabledForBluetooth, 
                       _kBasic_Imaging_Image_Pull_Profile_UUID, _kBasic_Imaging_Image_Pull_Profile_UUID_Size, 
                       _kBasic_Imaging_Image_Push_Profile_UUID, _kBasic_Imaging_Image_Push_Profile_UUID_Size, 
                       _kCodecTable40, _kCodecTable56, _kCodecTable60, 
                       _kFTSListingNameKey, _kFTSListingSizeKey, _kFTSListingTypeKey, 
                       _kFTSProgressBytesTotalKey, _kFTSProgressBytesTransferredKey, 
                       _kFTSProgressEstimatedTimeKey, _kFTSProgressPercentageKey, 
                       _kFTSProgressPrecentageKey, _kFTSProgressTimeElapsedKey, 
                       _kFTSProgressTransferRateKey, _kFile_Transfer_Profile_UUID, 
                       _kFile_Transfer_Profile_UUID_Size, _kOBEXHeaderIDKeyAppParameters, 
                       _kOBEXHeaderIDKeyAuthorizationChallenge, _kOBEXHeaderIDKeyAuthorizationResponse, 
                       _kOBEXHeaderIDKeyBody, _kOBEXHeaderIDKeyByteSequence, 
                       _kOBEXHeaderIDKeyConnectionID, _kOBEXHeaderIDKeyCount, 
                       _kOBEXHeaderIDKeyDescription, _kOBEXHeaderIDKeyEndOfBody, 
                       _kOBEXHeaderIDKeyHTTP, _kOBEXHeaderIDKeyImgDescriptor, 
                       _kOBEXHeaderIDKeyImgHandle, _kOBEXHeaderIDKeyLength, 
                       _kOBEXHeaderIDKeyName, _kOBEXHeaderIDKeyObjectClass, 
                       _kOBEXHeaderIDKeyTarget, _kOBEXHeaderIDKeyTime4Byte, 
                       _kOBEXHeaderIDKeyTimeISO, _kOBEXHeaderIDKeyType, 
                       _kOBEXHeaderIDKeyUnknown1ByteQuantity, _kOBEXHeaderIDKeyUnknown4ByteQuantity, 
                       _kOBEXHeaderIDKeyUnknownByteSequence, _kOBEXHeaderIDKeyUnknownUnicodeText, 
                       _kOBEXHeaderIDKeyUserDefined, _kOBEXHeaderIDKeyWho, 
                       _mDeviceManagerObject, _memcpySwap, _memrchr, _newConnectionShowedUp, 
                       _sendDaemonXPCMessageWithCFArrayAndReply, _sendDaemonXPCMessageWithCFObject, 
                       _sendDaemonXPCMessageWithNSArray, _sendDaemonXPCMessageWithReply, 
                       _sendDaemonXPCMessageWithReplySync, _sendRawHCIRequest, 
                       _servicePublished, _unpackEIRorAdvertisementData, 
                       _waitForMatchingService ]
    objc-classes:    [ _AppleBluetoothHIDDevice, _AppleBluetoothHIDDeviceGen2, 
                       _AtherosHostController, _BNEPControl, _BTPrivilegedMachBootstrapServer, 
                       _BluetoothHIDDevice, _BluetoothHIDDeviceController, 
                       _BluetoothUIServer, _BroadcomHostController, _CSRBlueICEHostController, 
                       _CSRHostController, _ConnectionCompleteCallbackDispatcher, 
                       _FileReference, _HardcopyCableReplacement, _IOBluetoothAudioManager, 
                       _IOBluetoothAutomaticDeviceSetup, _IOBluetoothCloudServerClient, 
                       _IOBluetoothConcreteUserNotification, _IOBluetoothDevice, 
                       _IOBluetoothDeviceExpansion, _IOBluetoothDeviceInfoGatherer, 
                       _IOBluetoothDeviceInquiry, _IOBluetoothDeviceInquiryCSupportObject, 
                       _IOBluetoothDeviceInquiryExpansion, _IOBluetoothDeviceManager, 
                       _IOBluetoothDevicePair, _IOBluetoothDevicePairExpansion, 
                       _IOBluetoothHandsFree, _IOBluetoothHandsFreeAudioGateway, 
                       _IOBluetoothHandsFreeAudioGatewayExpansion, _IOBluetoothHandsFreeDevice, 
                       _IOBluetoothHandsFreeDeviceExpansion, _IOBluetoothHandsFreeExpansion, 
                       _IOBluetoothHardcopyCableReplacement, _IOBluetoothHeadsetAudioGateway, 
                       _IOBluetoothHostController, _IOBluetoothHostControllerExpansion, 
                       _IOBluetoothL2CAPChannel, _IOBluetoothL2CAPChannelExpansion, 
                       _IOBluetoothLEA, _IOBluetoothLocalSDPServiceRecord, 
                       _IOBluetoothNSCUserNotification, _IOBluetoothNSObjCUserNotification, 
                       _IOBluetoothNSUserNotification, _IOBluetoothNotification, 
                       _IOBluetoothOBEXSession, _IOBluetoothObject, _IOBluetoothPreferences, 
                       _IOBluetoothRFCOMMChannel, _IOBluetoothRFCOMMConnection, 
                       _IOBluetoothSDPDataElement, _IOBluetoothSDPServiceAttribute, 
                       _IOBluetoothSDPServiceRecord, _IOBluetoothSDPUUID, 
                       _IOBluetoothSerialPort, _IOBluetoothSerialPortManager, 
                       _IOBluetoothTransferProgress, _IOBluetoothUserNotification, 
                       _IORegistryObjectNotifier, _NotificationInfo, _OBEXFileAction, 
                       _OBEXFileGet, _OBEXFilePut, _OBEXFileTransferServices, 
                       _OBEXSession, _RegistryObjectNotificationWrapper, 
                       _SDPQueryCallbackDispatcher, _SystemPowerNotifier ]
...
                                                                                                                                                                                                                                                                                                                                                                                                                    Modules/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032052  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A                                                                         module.modulemap                                                                                    0100644 0001750 0001750 00000000166 12567444636 035264  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/A/Modules                                                                 framework module IOBluetooth [extern_c] {
    umbrella header "IOBluetooth.h"
    export *
    module * { export * }
}                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetooth.framework/Versions/Current0120777 0001750 0001750 00000000000 12620245063 032004  2A                                                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/              0040755 0001750 0001750 00000000000 12612224741 026767  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Headers       0120777 0001750 0001750 00000000000 12620245063 035010  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        IOBluetoothUI.tbd                                                                                   0120777 0001750 0001750 00000000000 12620245063 040411  2Versions/Current/IOBluetoothUI.tbd                                                                  ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Modules       0120777 0001750 0001750 00000000000 12620245063 035102  2Versions/Current/Modules                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/     0040755 0001750 0001750 00000000000 12612224741 030577  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/   0040755 0001750 0001750 00000000000 12612224741 030757  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032253  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A                                                                       IOBluetoothUI.h                                                                                     0100644 0001750 0001750 00000001162 12566223064 035061  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers                                                               //
//  IOBluetoothUI.h
//  IOBluetoothUI Framework
//
//  Copyright (c) 2010 Apple, Inc. All rights reserved.
//

#if __OBJC__

	// Objective C API (Preferred for IOBluetoothUI.framework use)

	#if defined(__cplusplus)
	extern "C" {
	#endif
				
		#import <IOBluetoothUI/objc/IOBluetoothDeviceSelectorController.h>
		#import <IOBluetoothUI/objc/IOBluetoothPairingController.h>
		#import <IOBluetoothUI/objc/IOBluetoothServiceBrowserController.h>
		#import <IOBluetoothUI/objc/IOBluetoothObjectPushUIController.h>
        #import <IOBluetoothUI/objc/IOBluetoothPasskeyDisplay.h>

	#if defined(__cplusplus)
	}
	#endif
	
#endif

                                                                                                                                                                                                                                                                                                                                                                                                              IOBluetoothUIUserLib.h                                                                              0100644 0001750 0001750 00000007015 12566223064 036352  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers                                                               /*
	File:		IOBluetoothUIUserLib.h
	Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/

#pragma once

#import <IOBluetooth/IOBluetoothUserLib.h>

#ifdef	__cplusplus
	extern "C" {
#endif

typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothDeviceSelectorControllerRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothPairingControllerRef;
typedef struct OpaqueIOBluetoothObjectRef *			IOBluetoothServiceBrowserControllerRef;

// Common UI functions

#if 0
#pragma mark -
#pragma mark === Bluetooth Service Browser Controller ===
#endif

/*!
  @enum IOBluetoothServiceBrowserControllerOptions
  @discussion Option values to customize the behavior of an IOBluetoothServiceBrowserController object.
  @constant kIOBluetoothServiceBrowserControllerOptionsNone - no options set.
  @constant kIOBluetoothServiceBrowserControllerOptionsAutoStartInquiry - automatically start an inquiry when the panel is displayed.  This has been deprecated in 10.5
  @constant kIOBluetoothServiceBrowserControllerOptionsDisconnectWhenDone - disconnect from the device when UI operations are finished.
  
*/
typedef uint32_t IOBluetoothServiceBrowserControllerOptions;

enum
{
	kIOBluetoothServiceBrowserControllerOptionsNone					= 0L,
	kIOBluetoothServiceBrowserControllerOptionsAutoStartInquiry		= (1L << 0), // this has been deprecated in 10.5, all panels will AutoStart
    kIOBluetoothServiceBrowserControllerOptionsDisconnectWhenDone	= (1L << 1)
};

enum
{
	kIOBluetoothUISuccess			= (-1000),	// Same as NSRunStoppedResponse
	kIOBluetoothUIUserCanceledErr	= (-1001)	// Same as NSRunAbortedResponse
};

IOReturn IOBluetoothValidateHardware( CFStringRef cancelButtonTitle ) DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
		
IOReturn IOBluetoothValidateHardwareWithDescription( CFStringRef cancelButtonTitle,  CFStringRef descriptionText) AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;
		
		
// Deprecated API; use obj-c equivalents.

IOBluetoothServiceBrowserControllerRef	IOBluetoothServiceBrowserControllerCreate(IOBluetoothServiceBrowserControllerOptions inOptions) DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
IOReturn IOBluetoothServiceBrowserControllerBrowseDevices(IOBluetoothSDPServiceRecordRef *outRecord,  IOBluetoothServiceBrowserControllerOptions inOptions)  DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
void IOBluetoothServiceBrowserControllerSetOptions(IOBluetoothServiceBrowserControllerRef controller, IOBluetoothServiceBrowserControllerOptions inOptions)  DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
IOReturn IOBluetoothServiceBrowserControllerDiscover(IOBluetoothServiceBrowserControllerRef controller, IOBluetoothSDPServiceRecordRef *outRecord)  DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
IOReturn IOBluetoothServiceBrowserControllerDiscoverWithDeviceAttributes(IOBluetoothServiceBrowserControllerRef controller, IOBluetoothSDPServiceRecordRef *outRecord, IOBluetoothDeviceSearchAttributes *deviceAttributes, CFArrayRef serviceArray)  DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
IOBluetoothPairingControllerRef	IOBluetoothGetPairingController();
void	IOBluetoothPairingControllerRunPanelWithAttributes(IOBluetoothPairingControllerRef pairingController, IOBluetoothDeviceSearchAttributes *attributes)  DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;
IOBluetoothDeviceSelectorControllerRef	IOBluetoothGetDeviceSelectorController();
CFArrayRef	IOBluetoothDeviceSelectorRunPanelWithAttributes(IOBluetoothDeviceSelectorControllerRef deviceSelector, IOBluetoothDeviceSearchAttributes *attributes)  DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

#ifdef	__cplusplus
	}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   objc/                                                                                               0040755 0001750 0001750 00000000000 12612224741 033170  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers                                                               IOBluetoothDeviceSelectorController.h                                                               0100644 0001750 0001750 00000033241 12566223064 042430  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers/objc                                                          /*
    File:		IOBluetoothDeviceSelectorController.h
    Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/
 
#import <Cocoa/Cocoa.h>
#import <IOBluetooth/objc/IOBluetoothDevice.h>
#import <IOBluetooth/objc/IOBluetoothSDPServiceRecord.h>
#import <IOBluetoothUI/IOBluetoothUIUserLib.h>

//--------------------------------------------------------------------------------------------------------------------------
/*!	@header		IOBluetoothDeviceSelectorController.h
	@abstract	Public Interfaces for Apple's implementation of a pairing window for Bluetooth technology.
	@discussion	This implements a WindowController accessible from Cocoa applications to select a device, and
                        initiate pairing.
*/



/*!
 	@class IOBluetoothDeviceSelectorController
	@abstract A NSWindowController subclass to display a window to initiate pairing to other bluetooth devices.
	@discussion Implementation of a window controller to return a NSArray of selected bluetooth devices.  This
                    class will handle connecting to the Bluetooth Daemon for the purposes of searches, and displaying
                    the results.  This controller will return a NSArray of IOBluetoothDevice objects to the user.

*/
@interface IOBluetoothDeviceSelectorController : NSWindowController
{
}

// Public methods
//--------------------------------------------------------------------------------------------------------------------------
/*!	@method	deviceSelector
	@abstract	
	@discussion	Method call to instantiate a new IOBluetoothDeviceSelectorController object.
	@result
                        Success - a new instance of the device selector Controller
                        Failure	- nil
*/
+ (IOBluetoothDeviceSelectorController *)deviceSelector;

/*!	@method	withDeviceSelectorControllerRef:
	@abstract	Method call to convert an IOBluetoothDeviceSelectorControllerRef into an IOBluetoothDeviceSelectorController *.
        @param	deviceSelectorControllerRef IOBluetoothDeviceSelectorControllerRef for which an IOBluetoothDeviceSelectorController * is desired.
	@result		Returns the IOBluetoothDeviceSelectorController * for the given IOBluetoothDeviceSelectorControllerRef.
*/
+ (IOBluetoothDeviceSelectorController *)withDeviceSelectorControllerRef:(IOBluetoothDeviceSelectorControllerRef)deviceSelectorControllerRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!	@method	getDeviceSelectorControllerRef
	@abstract	Returns an IOBluetoothDeviceSelectorControllerRef representation of the target IOBluetoothDeviceSelectorController object.
	@result		Returns an IOBluetoothDeviceSelectorControllerRef representation of the target IOBluetoothDeviceSelectorController object.
*/
- (IOBluetoothDeviceSelectorControllerRef)getDeviceSelectorControllerRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;


/*!
    @method		runModal
	@abstract	Runs the device selector panel in a modal session to allow the user to select a Bluetooth device.
	@discussion	The controller will use the panel attributes to filter what devices the user sees.  The allowed UUIDs
				will be used to validate the selection the user makes.  Only when a selection has been validated (or
				the panel cancelled), will this method return.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns kIOBluetoothUISuccess if a successful, validated device selection was made by the user.
				Returns kIOBluetoothUIUserCanceledErr if the user cancelled the panel.  These return values are the
				same as NSRunStoppedResponse and NSRunAbortedResponse respectively.  They are the standard values
				used in a modal session.
*/

- (int)runModal;

/*!
    @method		beginSheetModalForWindow:modalDelegate:didEndSelector:contextInfo:
	@abstract	Runs the device selector panel as a sheet on the target window.
	@discussion	This function works the same way as -[NSApplication beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:].
				The didEndSelector has a similar prototype as in NSApplication except that the first argument is the 
				IOBluetoothDeviceSelectorController object instead of the window: 
				-(void)sheetDidEnd:(IOBluetoothDeviceSelectorController *)controller returnCode:(int)returnCode contextInfo:(void *)contextInfo.
				The returnCode parameter will either be kIOBluetoothUISuccess or kIOBluetoothUIUserCancelledErr as described in
				-runModal.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		sheetWindow		NSWindow to attach the device selector panel to as a sheet.
	@param		modalDelegate	Delegate object that gets sent the didEndSelector when the sheet modal session is finished.
	@param		didEndSelector	Selector sent to the modalDelegate when the sheet modal session is finished.
	@param		contextInfo		User-definied value passed to the modalDelegate in the didEndSelector.
	@result		Returns kIOReturnSuccess if the sheet modal session was started.
*/

- (IOReturn)beginSheetModalForWindow:(NSWindow *)sheetWindow modalDelegate:(id)modalDelegate didEndSelector:(SEL)didEndSelector contextInfo:(void *)contextInfo;

/*!
    @method		getResults
	@abstract	Returns the result of the user's selection.
	@discussion	There will only be results if the panel has been run, the user has successfully made a selection and that 
				selection has been validated.  If kIOBluetoothUISuccess was returned for the session, there should be valid 
				results.  Currently only a single device is allowed to be selected, so the results array will only contain 
				one object.  However in the future multiple selection will be supported.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns an NSArray of IOBluetoothDevice objects corresponding to the user's selection.  If the user cancelled
				the panel, nil will be returned.
*/

- (NSArray *)getResults;

/*!
    @method		setOptions:
	@abstract	Sets the option bits that control the panel's behavior.
	@discussion	The service browser controller options control the behavior of the panel.  Currently
				kIOBluetoothServiceBrowserControllerOptionsAutoStartInquiry is the only supported option.
				In the future more options will be added to control things like whether the connection to
				the device is closed when the controller is finished or if multiple selection is allowed.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		options	Options to control the panel's behavior.
*/

- (void)setOptions:(IOBluetoothServiceBrowserControllerOptions)options;

/*!
    @method		getOptions
	@abstract	Returns the option bits that control the panel's behavior.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the option bits set by setOptions:
*/

- (IOBluetoothServiceBrowserControllerOptions)getOptions;

/*!
    @method		setSearchAttributes:
	@abstract	Sets the search attributes that control the panel's search/inquiry behavior.
	@discussion	The device search attributes control the inquiry behavior of the panel.  They allow only devices
				that match the specified attributes (i.e. class of device) to be displayed to the user.  Note that
				this only covers attributes returned in an inquiry result and not actual SDP services on the device.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		searchAttributes Attributes to control the panel's inquiry behavior.
*/

- (void)setSearchAttributes:(const IOBluetoothDeviceSearchAttributes *)searchAttributes;

/*!
    @method		getSearchAttributes
	@abstract	Returns the search attributes that control the panel's search/inquiry behavior.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the search attributes set by setSearchAttributes:
*/

- (const IOBluetoothDeviceSearchAttributes *)getSearchAttributes;

/*!
    @method		addAllowedUUID:
	@abstract	Adds a UUID to the list of UUIDs that are used to validate the user's selection.
	@discussion	The user's device selection gets validated against the UUIDs passed to -addAllowedUUID:
				addAllowedUUIDArray:.  Each call to those methods essentially adds a filter that the
				selected device gets validated with.  If any of the filters match, the device is considered
				valid.  If they all fail, the device is not valid and the user is presented with an
				error code that the device does not support the required services.  The UUID passed to
				-addAllowedUUID: is the only UUID that must be present in the device's SDP service records.
				Alternatively, all of the UUIDs in the UUID array passed to -addAllowedUUIDArray must be
				present.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		allowedUUID UUID that a device may contain to be selected
*/

- (void)addAllowedUUID:(IOBluetoothSDPUUID *)allowedUUID;

/*!
    @method		addAllowedUUIDArray:
	@abstract	Adds an array of UUIDs to the list of UUIDs that are used to validate the user's selection.
	@discussion	The user's device selection gets validated against the UUIDs passed to -addAllowedUUID:
				addAllowedUUIDArray:.  Each call to those methods essentially adds a filter that the
				selected device gets validated with.  If any of the filters match, the device is considered
				valid.  If they all fail, the device is not valid and the user is presented with an
				error code that the device does not support the required services.  The UUID passed to
				-addAllowedUUID: is the only UUID that must be present in the device's SDP service records.
				Alternatively, all of the UUIDs in the UUID array passed to -addAllowedUUIDArray must be
				present.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		allowedUUIDArray An NSArray of UUIDs that all must be present in a device for it to be selectable.
*/

- (void)addAllowedUUIDArray:(NSArray *)allowedUUIDArray;

/*!
    @method		clearAllowedUUIDs
	@abstract	Resets the controller back to the default state where it will accept any device the user selects.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
*/

- (void)clearAllowedUUIDs;

/*!
    @method		setTitle:
	@abstract	Sets the title of the panel when not run as a sheet.
	@discussion	The panel title should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		windowTitle Title of the device selector panel.
*/

- (void)setTitle:(NSString *)windowTitle;

/*!
    @method		getTitle
	@abstract	Returns the title of the device selector panel (i.e. what was set in -setTitle:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the title of the device selector panel.
*/

- (NSString *)getTitle;

/*!
 @method		setHeader:
 @abstract	Sets the header text that appears in the device selector panel.
 @discussion	The description text should be localized for best user experience.
 
 NOTE: This method is only available in Mac OS X 10.9 or later.
 @param		headerText String that appears in the description section of the device selector panel.
 */

- (void)setHeader:(NSString *)headerText;

/*!
 @method		getHeader
 @abstract	Returns the header text that appears in the device selector panel (i.e. what was set in -setHeader:).
 @discussion	NOTE: This method is only available in Mac OS X 10.9 or later.
 @result		Returns the header text of the device selector panel.
 */

- (NSString *)getHeader;

/*!
    @method		setDescriptionText:
	@abstract	Sets the description text that appears in the device selector panel.
	@discussion	The description text should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		descriptionText String that appears in the description section of the device selector panel.
*/

- (void)setDescriptionText:(NSString *)descriptionText;

/*!
    @method		getDescriptionText
	@abstract	Returns the description text that appears in the device selector panel (i.e. what was set in -setDescriptionText:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the description text of the device selector panel.
*/

- (NSString *)getDescriptionText;

/*!
    @method		setPrompt:
	@abstract	Sets the title of the default/select button in the device selector panel.
	@discussion	The prompt text should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		prompt String that appears in the default/select button in the device selector panel.
*/

- (void)setPrompt:(NSString *)prompt;

/*!
    @method		getPrompt
	@abstract	Returns the title of the default/select button in the device selector panel (i.e. what was set in -setPrompt:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the default button title of the device selector panel.
*/

- (NSString *)getPrompt;

/*!
 @method		setCancel:
 @abstract	Sets the title of the default/cancel button in the device selector panel.
 @discussion	The prompt text should be localized for best user experience.
 
 NOTE: This method is only available in Mac OS X 10.9 or later.
 @param		prompt String that appears in the default/cancel button in the device selector panel.
 */

- (void)setCancel:(NSString *)prompt;

/*!
 @method		getCancel
 @abstract	Returns the title of the default/cancel button in the device selector panel (i.e. what was set in -setPrompt:).
 @discussion	NOTE: This method is only available in Mac OS X 10.9 or later.
 @result		Returns the default cancel button title of the device selector panel.
 */

- (NSString *)getCancel;


@end
                                                                                                                                                                                                                                                                                                                                                               IOBluetoothObjectPushUIController.h                                                                 0100644 0001750 0001750 00000012072 12566223064 042033  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers/objc                                                          //
//  IOBluetoothObjectPushUIController.h
//  IOBluetoothFamily
//
//  Copyright (c) 2010 Apple, Inc. All rights reserved.
//

#import <Cocoa/Cocoa.h>

@class IOBluetoothDevice;

/*!
	An NSWindowController subclass that supports the creation of an IOBluetoothObjectPushUIController object.
 */

@interface IOBluetoothObjectPushUIController : NSWindowController
{

}


/*!
	@method		initObjectPushWithBluetoothDevice: withFiles: delegate:
	@abstract	Creates and returns a new IOBluetoothObjectPush object
	@discussion	The event delegate should implement a single delegate method:
 
				- (void) objectPushComplete: (IOBluetoothObjectPushUIController*) inPusher
 
				The method will be called when the transaction is complete and
				should be used to release the push object by the delegate. If no delegate is set
				the object will release itself when the transfer is finished.
	@param		inDevice	The remote device to send the files to
	@param		inFiles		An array of file paths to send
	@param		inDelegate  A delegate object that implements the single method above.  If no delegate
							is specified this object will release itself when the transaction is complete.
	@result		An IOBluetoothObjectPushUIController object on success, nil on fail.
 */
- (IOBluetoothObjectPushUIController*) initObjectPushWithBluetoothDevice: (IOBluetoothDevice*) inDevice 
															   withFiles: (NSArray *) inFiles 
																delegate: (id) inDelegate;

/*!
    @method		runModal
	@abstract	Runs the transfer UI panel in a modal session
	@discussion	Returns when the modal session has ended. This object will call back over the 
				delegate method (above) when the transfer is complete.  Users should release 
				the object then. If no delegate is set the object will release itself.
	@result		The call will stall in this method until the modal session is complete.
*/
- (void) runModal;


/*!
	@method		runPanel
	@abstract	Runs the transfer UI as a panel with no modal session
	@discussion	Returns immediately.  The object will callback over the delegate method (above)
				when the transfer is completed.  If no delegate is set the object will release itself.
	@result		The method will return immediately.
*/
- (void) runPanel;


/*!
    @method		beginSheetModalForWindow:modalDelegate:didEndSelector:contextInfo:
	@abstract	Runs the  transfer UI as a sheet on the target window.
	@discussion	This function works the same way as -[NSApplication beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:].
				The didEndSelector has a similar prototype as in NSApplication except that the first argument is the 
				IOBluetoothDeviceSelectorController object instead of the window: 
 
				-(void)sheetDidEnd:(IOBluetoothDeviceSelectorController *)controller returnCode:(int)returnCode contextInfo:(void *)contextInfo.
				The returnCode parameter will either be kIOBluetoothUISuccess or kIOBluetoothUIUserCancelledErr as described in
				-runModal.

	@param		sheetWindow		NSWindow to attach the device selector panel to as a sheet.
	@param		modalDelegate	Delegate object that gets sent the didEndSelector when the sheet modal session is finished.
	@param		didEndSelector	Selector sent to the modalDelegate when the sheet modal session is finished.
	@param		contextInfo		User-definied value passed to the modalDelegate in the didEndSelector.
	@result		Returns kIOReturnSuccess if the sheet modal session was started.
*/

- (IOReturn) beginSheetModalForWindow: (NSWindow *) sheetWindow 
						modalDelegate: (id) modalDelegate 
					   didEndSelector: (SEL) didEndSelector 
						  contextInfo: (void *) contextInfo;


/*!
	@method		stop
	@abstract	Stops the transfer UI
	@discussion	Returns immediately. The object will callback over the delegate method (above)
				when the transfer is completed, or will release itself if no delegate is set.
	@result		The method will return immediately.
*/
- (void) stop;


/*!
    @method		setTitle:
	@abstract	Sets the title of the panel when not run as a sheet.
	@discussion	The panel title should be localized for best user experience.
	@param		windowTitle Title of the device selector panel.
*/
- (void) setTitle: (NSString *) windowTitle;


/*!
    @method		getTitle
	@abstract	Returns the title of the transfer panel (i.e. what was set in -setTitle:).
	@discussion	
	@result		Returns the title of the transfer panel.
*/
- (NSString *) getTitle;


/*!
	@method		setIconImage:
	@abstract	Manually sets the icon used in the panel.
	@discussion	The panel icon should be set to the icon of the calling application.  If not set, the panel
				will try to load up the correct icon for the target device, and will default to the icon of
				the running application on fail.
	@param		image Image to use as the icon.
*/
- (void) setIconImage:(NSImage*)image;


/*!
	@method		getDevice:
	@abstract	Gets the object representing the remote target device in the transfer.
	@discussion	
	@result		The remote device of the transfer.
*/
- (IOBluetoothDevice*) getDevice;


/*!
	@method		isTransferInProgress:
	@abstract	Gets state of the transfer
	@discussion	
	@result		The state of the transfer
*/
- (BOOL) isTransferInProgress;


@end





                                                                                                                                                                                                                                                                                                                                                                                                                                                                      IOBluetoothPairingController.h                                                                      0100644 0001750 0001750 00000025552 12566223064 041127  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers/objc                                                          /*
	File:		IOBluetoothPairingController.h
	Copyright (c) 2010 Apple, Inc. All rights reserved.
*/
 
#import <Cocoa/Cocoa.h>
#import <IOBluetooth/objc/IOBluetoothDevice.h>
#import <IOBluetooth/objc/IOBluetoothSDPServiceRecord.h>
#import <IOBluetoothUI/IOBluetoothUIUserLib.h>

//--------------------------------------------------------------------------------------------------------------------------
/*!	@header			IOBluetoothPairingController.h
	@abstract		Public Interfaces for Apple's implementation of a pairing window for Bluetooth technology.
	@discussion		This implements a WindowController accessible from Cocoa applications to select a device, and
					initiate pairing.
*/


/*!
 	@class			IOBluetoothPairingController
	@abstract		A NSWindowController subclass to display a window to initiate pairing to other bluetooth devices.
	@discussion		Implementation of a window controller to handle pairing with a bluetooth device.  This
					class will handle connecting to the Bluetooth Daemon for the purposes of searches, and displaying the results.
					When necessary this class will display a sheet asking the user for a PIN code.  This window will not return
					anything to the caller if it is canceled or if pairing occurs.
*/

@interface IOBluetoothPairingController : NSWindowController
{
}

// Public methods
//--------------------------------------------------------------------------------------------------------------------------
/*!	@method	pairingController
	@abstract	
	@discussion	Method call to instantiate a new IOBluetoothPairingController object.
	@result		An IOBluetoothPairingController instance.  Call runPanelWithAttributes
        
                        Success - a new instance of the Pairing Controller
                        Failure	- nil
*/
+ (IOBluetoothPairingController *)pairingController;

/*!	@method	withPairingControllerRef:
	@abstract	Method call to convert an IOBluetoothPairingControllerRef into an IOBluetoothPairingController *.
        @param	pairingControllerRef IOBluetoothPairingControllerRef for which an IOBluetoothPairingController * is desired.
	@result		Returns the IOBluetoothPairingController * for the given IOBluetoothPairingControllerRef.
*/
+ (IOBluetoothPairingController *)withPairingControllerRef:(IOBluetoothPairingControllerRef)pairingControllerRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!	@method	getPairingControllerRef
	@abstract	Returns an IOBluetoothPairingControllerRef representation of the target IOBluetoothPairingController object.
	@result		Returns an IOBluetoothPairingControllerRef representation of the target IOBluetoothPairingController object.
*/
- (IOBluetoothPairingControllerRef)getPairingControllerRef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
    @method		runModal
	@abstract	Runs the pairing panel in a modal session to allow the user to select a Bluetooth device.
	@discussion	The controller will use the panel attributes to filter what devices the user sees.  The allowed UUIDs
				will be used to validate the selection the user makes.  Only when a selection has been validated (or
				the panel cancelled) and the device paired, will this method return.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns kIOBluetoothUISuccess if a successful, validated device selection was made by the user and
				that device successfully paired.
				Returns kIOBluetoothUIUserCanceledErr if the user cancelled the panel.  These return values are the
				same as NSRunStoppedResponse and NSRunAbortedResponse respectively.  They are the standard values
				used in a modal session.
*/

- (int)runModal;

/*!
    @method		getResults
	@abstract	Returns an NSArray of the devices that were paired.
	@discussion	There will only be results if the panel has been run, the user has successfully made a selection, that 
				selection has been validated and the selected device paired.  If kIOBluetoothUISuccess was returned for 
				the session, there should be valid results.  Currently only a single device is allowed to be selected, 
				so the results array will only contain one object.  However in the future multiple selection may be supported.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns an NSArray of IOBluetoothDevice objects of devices that were paired.  If the user cancelled
				the panel, nil will be returned.
*/

- (NSArray *)getResults;

/*!
    @method		setOptions:
	@abstract	Sets the option bits that control the panel's behavior.
	@discussion	The pairing controller options control the behavior of the panel.  Currently
				kIOBluetoothServiceBrowserControllerOptionsAutoStartInquiry is the only supported option.
				In the future more options will be added to control things like whether the connection to
				the device is closed when the controller is finished or if multiple selection is allowed.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		options	Options to control the panel's behavior.
*/

- (void)setOptions:(IOBluetoothServiceBrowserControllerOptions)options;

/*!
    @method		getOptions
	@abstract	Returns the option bits that control the panel's behavior.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the option bits set by setOptions:
*/

- (IOBluetoothServiceBrowserControllerOptions)getOptions;

/*!
    @method		setSearchAttributes:
	@abstract	Sets the search attributes that control the panel's search/inquiry behavior.
	@discussion	The device search attributes control the inquiry behavior of the panel.  They allow only devices
				that match the specified attributes (i.e. class of device) to be displayed to the user.  Note that
				this only covers attributes returned in an inquiry result and not actual SDP services on the device.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		searchAttributes Attributes to control the panel's inquiry behavior.
*/

- (void)setSearchAttributes:(const IOBluetoothDeviceSearchAttributes *)searchAttributes;

/*!
    @method		getSearchAttributes
	@abstract	Returns the search attributes that control the panel's search/inquiry behavior.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the search attributes set by setSearchAttributes:
*/

- (const IOBluetoothDeviceSearchAttributes *)getSearchAttributes;

/*!
    @method		addAllowedUUID:
	@abstract	Adds a UUID to the list of UUIDs that are used to validate the user's selection.
	@discussion	The user's device selection gets validated against the UUIDs passed to -addAllowedUUID:
				addAllowedUUIDArray:.  Each call to those methods essentially adds a filter that the
				selected device gets validated with.  If any of the filters match, the device is considered
				valid.  If they all fail, the device is not valid and the user is presented with an
				error code that the device does not support the required services.  The UUID passed to
				-addAllowedUUID: is the only UUID that must be present in the device's SDP service records.
				Alternatively, all of the UUIDs in the UUID array passed to -addAllowedUUIDArray must be
				present.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		allowedUUID UUID that a device may contain to be selected
*/

- (void)addAllowedUUID:(IOBluetoothSDPUUID *)allowedUUID;

/*!
    @method		addAllowedUUIDArray:
	@abstract	Adds an array of UUIDs to the list of UUIDs that are used to validate the user's selection.
	@discussion	The user's device selection gets validated against the UUIDs passed to -addAllowedUUID:
				addAllowedUUIDArray:.  Each call to those methods essentially adds a filter that the
				selected device gets validated with.  If any of the filters match, the device is considered
				valid.  If they all fail, the device is not valid and the user is presented with an
				error code that the device does not support the required services.  The UUID passed to
				-addAllowedUUID: is the only UUID that must be present in the device's SDP service records.
				Alternatively, all of the UUIDs in the UUID array passed to -addAllowedUUIDArray must be
				present.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		allowedUUIDArray An NSArray of UUIDs that all must be present in a device for it to be selectable.
*/

- (void)addAllowedUUIDArray:(NSArray *)allowedUUIDArray;

/*!
    @method		clearAllowedUUIDs
	@abstract	Resets the controller back to the default state where it will accept any device the user selects.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
*/

- (void)clearAllowedUUIDs;

/*!
    @method		setTitle:
	@abstract	Sets the title of the panel when not run as a sheet.
	@discussion	The panel title should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		windowTitle Title of the device selector panel.
*/

- (void)setTitle:(NSString *)windowTitle;
/*!
    @method		getTitle
	@abstract	Returns the title of the device selector panel (i.e. what was set in -setTitle:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the title of the device selector panel.
*/

- (NSString *)getTitle;

/*!
    @method		setDescriptionText:
	@abstract	Sets the description text that appears in the device selector panel.
	@discussion	The description text should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		descriptionText String that appears in the description section of the device selector panel.
*/

- (void)setDescriptionText:(NSString *)descriptionText;

/*!
    @method		getDescriptionText
	@abstract	Returns the description text that appears in the device selector panel (i.e. what was set in -setDescriptionText:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the description text of the device selector panel.
*/

- (NSString *)getDescriptionText;

/*!
    @method		setPrompt:
	@abstract	Sets the title of the default/select button in the device selector panel.
	@discussion	The prompt text should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		prompt String that appears in the default/select button in the device selector panel.
*/

- (void)setPrompt:(NSString *)prompt;

/*!
    @method		getPrompt
	@abstract	Returns the title of the default/select button in the device selector panel (i.e. what was set in -setPrompt:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the default button title of the device selector panel.
*/

- (NSString *)getPrompt;

@end
                                                                                                                                                      IOBluetoothPasskeyDisplay.h                                                                         0100644 0001750 0001750 00000004276 12566223064 040437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers/objc                                                          //
//  IOBluetoothPasskeyDisplay.h
//  Copyright 2010 Apple, Inc.. All rights reserved.
//

#import <Cocoa/Cocoa.h>


@class IOBluetoothDevice;

typedef enum {
    kBluetoothKeyboardANSIReturn,
	kBluetoothKeyboardISOReturn,
    kBluetoothKeyboardJISReturn,
    kBluetoothKeyboardNoReturn
} BluetoothKeyboardReturnType;

@interface IOBluetoothPasskeyDisplay : NSView
{
	IBOutlet NSImageView *		mReturnImageView;
	NSImage *					mReturnImage;
	NSImage *					mReturnHighlightImage;
	IBOutlet NSImageView *		mBackgroundImage;
	
	BOOL						usePasskeyNotifications;
    BOOL                        isIncomingRequest;
    BOOL						showFeedback;
    NSString *					passkey;
    IBOutlet NSTextField *		mPasskeyString;
    
	NSMutableArray *			mPasskeyCharacters;
	NSUInteger					mPasskeyIndex;
    
    NSLayoutConstraint *		backgroundImageConstraint;
    NSView *centeredView;
}

// Private
@property (assign)	BOOL			usePasskeyNotificaitons;
@property (assign)	BOOL			isIncomingRequest;
@property (copy)	NSString *		passkey;
@property (retain)	NSImage *		returnImage;
@property (retain)	NSImage *		returnHighlightImage;

@property (assign) IBOutlet NSView *centeredView;
@property (assign) IBOutlet NSLayoutConstraint *backgroundImageConstraint;


// Public
+ (IOBluetoothPasskeyDisplay *) sharedDisplayView;

- (void) setPasskey:(NSString *)inString forDevice:(IOBluetoothDevice *)device usingSSP:(BOOL)isSSP;

- (void) advancePasskeyIndicator;
- (void) retreatPasskeyIndicator;
- (void) resetPasskeyIndicator;



// Deprecated methods
- (void) setupUIForDevice:(IOBluetoothDevice *)device DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER;
- (void) setupUIForSSPDevice:(IOBluetoothDevice *)device DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER;

// Must be called after setupUIFor(SSP)Device is called
- (void) setPasskeyString:(NSString *)inString DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER;
- (void) setPasskeyIndicatorEnabled:(BOOL)inEnabled DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER;
- (void) resetAll DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER;

@end

// Accessiblity support
@interface IOBluetoothAccessibilityIgnoredTextFieldCell : NSTextFieldCell {}
@end

@interface IOBluetoothAccessibilityIgnoredImageCell: NSImageCell {}
@end

                                                                                                                                                                                                                                                                                                                                  IOBluetoothServiceBrowserController.h                                                               0100644 0001750 0001750 00000044162 12566223064 042500  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Headers/objc                                                          /*
    File:		IOBluetoothServiceBrowserController.h
    Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/
 
#import <Cocoa/Cocoa.h>
#import <IOBluetooth/objc/IOBluetoothDevice.h>
#import <IOBluetooth/objc/IOBluetoothSDPServiceRecord.h>
#import <IOBluetoothUI/IOBluetoothUIUserLib.h>

//--------------------------------------------------------------------------------------------------------------------------
/*!	@header		IOBluetoothServiceBrowserController.h
	@abstract	Public Interfaces for Apple's implementation of a service browser window for Bluetooth technology.
	@discussion	This implements a WindowController accessible from Cocoa applications to find a device, and
                        initiate Service Discovery queries on devices.  The user can select a particular service which
                        they want to use for the application.
*/

/*!
 	@class IOBluetoothServiceBrowserController
	@abstract A NSWindowController subclass to display a window to search for and perform SDP queries on bluetooth
                    devices within range.
	@discussion This NSWindowController subclass will bring up a generic Bluetooth search and SDP browsing window
                    allowing the user to find devices within range, perform SDP queries on a particular device, and
                    select a SDP service to connect to.  The client application can provide NSArrays of valid service
                    UUIDs to allow, and an NSArray of valid device types to allow.  The device type filter is not
                    yet implemented.
*/
@interface IOBluetoothServiceBrowserController : NSWindowController
{
}

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	serviceBrowserController:
	@abstract	Allocator work Bluetooth Service Browser window controller.
	@param		inOptions	Bit field for options to set in the newly allocated controller.  Currently no options are available.				
	@result		a new instance of the IOBluetoothServiceBrowserController Controller, nil if unsuccessful.
	@discussion	
*/
+(IOBluetoothServiceBrowserController *)serviceBrowserController:(IOBluetoothServiceBrowserControllerOptions)inOptions;

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	browseDevices:options:
	@abstract	
	@discussion	***WARNING*** This method has been deprecated in favor of -setOptions:, -runModal and -getResults.
	@param		outRecord 	Pointer to a (IOBluetoothSDPServiceRecord *) object.  This will get allocated and returned to the client if the user selects a service.
	@param		inOptions	For future expansion.  Currently no options defined.
	@result		IOReturn - 
        
                            * kIOReturnSuccess  - on successful completion.
                            
                            * kCanceledErr - User canceled.
                            
	@discussion	This method allocates and runs the browser window as a modal window waiting for the user to either select a
                        service, or cancel the browser window.  
*/
+(IOReturn)browseDevices:(IOBluetoothSDPServiceRecord**)outRecord options:(IOBluetoothServiceBrowserControllerOptions)inOptions	DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	browseDevicesAsSheetForWindow:options:window:
	@abstract	
	@discussion	***WARNING*** This method has been deprecated in favor of - beginSheetModalForWindow:modalDelegate:didEndSelector:contextInfo:.
	@param		outRecord 	Pointer to a (IOBluetoothSDPServiceRecord *) object.  This will get allocated and returned to the client if the user selects a service.
	@param		inOptions	For future expansion.  Currently no options defined.
	@param		inWindow	The window to be used as the anchor of the sheet.
	@result		IOReturn - 
                            * kIOReturnSuccess  - on successful completion.
                            * kCanceledErr - User canceled.
	@discussion	This method will allocate and run the IOBluetoothServiceBrowserController browser window as a sheet for a window.
*/
+(IOReturn)browseDevicesAsSheetForWindow:(IOBluetoothSDPServiceRecord**)outRecord
								 options:(IOBluetoothServiceBrowserControllerOptions)inOptions
								  window:(NSWindow*)inWindow	DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;


/*!	@method	withServiceBrowserControllerRef:
	@abstract	Method call to convert an IOBluetoothServiceBrowserControllerRef into an IOBluetoothServiceBrowserController *.
        @param	serviceBrowserControllerRef IOBluetoothServiceBrowserControllerRef for which an IOBluetoothServiceBrowserController * is desired.
	@result		Returns the IOBluetoothServiceBrowserController * for the given IOBluetoothServiceBrowserControllerRef.
*/
+ (IOBluetoothServiceBrowserController *)withServiceBrowserControllerRef:(IOBluetoothServiceBrowserControllerRef)serviceBrowserControllerRef;

/*!	@method	getServiceBrowserControllerRef
	@abstract	Returns an IOBluetoothServiceBrowserControllerRef representation of the target IOBluetoothServiceBrowserController object.
	@result		Returns an IOBluetoothServiceBrowserControllerRef representation of the target IOBluetoothServiceBrowserController object.
*/
- (IOBluetoothServiceBrowserControllerRef)getServiceBrowserControllerRef;

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	discover:
	@abstract	Invoke an already created window controller to display, and run the modal dialog.	
	@discussion	***WARNING*** This method has been deprecated in favor of -runModal and -getResults.
	@param		outRecord 	Pointer to a (IOBluetoothSDPServiceRecord *) object.  This will get allocated and returned to the client if the user selects a service.
	@result		IOReturn - 
                            * kIOReturnSuccess  - on successful completion.
                            * kCanceledErr - User canceled.
	@discussion	This method will run the IOBluetoothServiceBrowserController browser window modally.
*/
-(IOReturn)discover:(IOBluetoothSDPServiceRecord **)outRecord	DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	discoverAsSheetForWindow:withRecord:
	@abstract	Invoke an already created window controller to display, and run the modal dialog.	
	@discussion	***WARNING*** This method has been deprecated in favor of -beginSheetModalForWindow:... and -getResults.
	@param		sheetWindow 	The window to use for the anchor of the sheet..
	@param		outRecord 	Pointer to a (IOBluetoothSDPServiceRecord *) object.  This will get allocated and returned to the client if the user selects a service.
	@result		IOReturn - 
                            * kIOReturnSuccess  - on successful completion.
                            * kCanceledErr - User canceled.
	@discussion	This method will run the IOBluetoothServiceBrowserController browser window as a sheet for the window passed to it in sheetWindow.
*/
-(IOReturn)discoverAsSheetForWindow:(NSWindow *)sheetWindow withRecord:(IOBluetoothSDPServiceRecord **)outRecord	DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	discoverWithDeviceAttributes:serviceList:serviceRecord:
	@abstract	Invoke an already created window controller to display, and run the modal dialog.	
	@discussion	***WARNING*** This method has been deprecated in favor of -setSearchAttributes:, -addAllowedUUID:, -runModal and -getResults.
	@param		deviceArray 	A NSArray of valid device type objects to allow.  Not implemented yet.
	@param		serviceArray 	A NSArray of valid UUIDs to allow. The array should contain NSData objects
                                specifying the UUID to allow.  We currently only support 16-bit short UUID forms, but
                                will allow for any of the 16, 32 or full 128-bit UUID forms.
	@param		outRecord 	Pointer to a (IOBluetoothSDPServiceRecord *) object.  This will get allocated
                                and returned to the client if the user selects a service.
	@result		IOReturn - 
                            * kIOReturnSuccess  - on successful completion.
                            * kCanceledErr - User canceled.
	@discussion	This method will run the IOBluetoothServiceBrowserController browser window as a sheet for the window passed to it in sheetWindow.
*/
-(IOReturn)discoverWithDeviceAttributes:(IOBluetoothDeviceSearchAttributes *)deviceAttributes serviceList:(NSArray *)serviceArray serviceRecord:(IOBluetoothSDPServiceRecord**)outRecord	DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER;

//--------------------------------------------------------------------------------------------------------------------------
/*!
	@method	setOptions:
	@abstract	Modify the options for the window controller.	
	@param		inOptions 	Bit field to set the options to.
	@result		None.
	@discussion	This method will set the options for the browser to new values.
*/
-(void)setOptions:(IOBluetoothServiceBrowserControllerOptions)inOptions;

/*!
    @method		runModal
	@abstract	Runs the service browser panel in a modal session to allow the user to select a service on a Bluetooth device.
	@discussion	The controller will use the panel attributes to filter what devices the user sees.  The allowed UUIDs
				will be used to validate the selection the user makes.  The user will only be able to select services
				that match the allowed UUIDs.  Only when a selection has been validated (or
				the panel cancelled), will this method return.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns kIOBluetoothUISuccess if a successful, validated service selection was made by the user.
				Returns kIOBluetoothUIUserCanceledErr if the user cancelled the panel.  These return values are the
				same as NSRunStoppedResponse and NSRunAbortedResponse respectively.  They are the standard values
				used in a modal session.
*/

- (int)runModal;

/*!
    @method		beginSheetModalForWindow:modalDelegate:didEndSelector:contextInfo:
	@abstract	Runs the service browser panel as a sheet on the target window.
	@discussion	This function works the same way as -[NSApplication beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:].
				The didEndSelector has a similar prototype as in NSApplication except that the first argument is the 
				IOBluetoothServiceBrowserController object instead of the window: 
				-(void)sheetDidEnd:(IOBluetoothServiceBrowserController *)controller returnCode:(int)returnCode contextInfo:(void *)contextInfo.
				The returnCode parameter will either be kIOBluetoothUISuccess or kIOBluetoothUIUserCancelledErr as described in
				-runModal.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		sheetWindow		NSWindow to attach the service browser panel to as a sheet.
	@param		modalDelegate	Delegate object that gets sent the didEndSelector when the sheet modal session is finished.
	@param		didEndSelector	Selector sent to the modalDelegate when the sheet modal session is finished.
	@param		contextInfo		User-definied value passed to the modalDelegate in the didEndSelector.
	@result		Returns kIOReturnSuccess if the sheet modal session was started.
*/

- (IOReturn)beginSheetModalForWindow:(NSWindow *)sheetWindow modalDelegate:(id)modalDelegate didEndSelector:(SEL)didEndSelector contextInfo:(void *)contextInfo;

/*!
    @method		getResults
	@abstract	Returns the result of the user's selection.
	@discussion	There will only be results if the panel has been run, the user has successfully made a selection and that 
				selection has been validated.  If kIOBluetoothUISuccess was returned for the session, there should be valid 
				results.  Currently only a single device is allowed to be selected, so the results array will only contain 
				one object.  However in the future multiple selection will be supported.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns an NSArray of IOBluetoothSDPServiceRecord objects corresponding to the user's selection.  If the user cancelled
				the panel, nil will be returned.
*/

- (NSArray *)getResults;

/*!
    @method		getOptions
	@abstract	Returns the option bits that control the panel's behavior.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the option bits set by setOptions:
*/

- (IOBluetoothServiceBrowserControllerOptions)getOptions;

/*!
    @method		setSearchAttributes:
	@abstract	Sets the search attributes that control the panel's search/inquiry behavior.
	@discussion	The device search attributes control the inquiry behavior of the panel.  They allow only devices
				that match the specified attributes (i.e. class of device) to be displayed to the user.  Note that
				this only covers attributes returned in an inquiry result and not actual SDP services on the device.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		searchAttributes Attributes to control the panel's inquiry behavior.
*/

- (void)setSearchAttributes:(const IOBluetoothDeviceSearchAttributes *)searchAttributes;

/*!
    @method		getSearchAttributes
	@abstract	Returns the search attributes that control the panel's search/inquiry behavior.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the search attributes set by setSearchAttributes:
*/

- (const IOBluetoothDeviceSearchAttributes *)getSearchAttributes;

/*!
    @method		addAllowedUUID:
	@abstract	Adds a UUID to the list of UUIDs that are used to validate the user's selection.
	@discussion	The user's device selection gets validated against the UUIDs passed to -addAllowedUUID:
				addAllowedUUIDArray:.  Each call to those methods essentially adds a filter that the
				selected device gets validated with.  If any of the filters match, the device is considered
				valid.  If they all fail, the device is not valid and the user is presented with an
				error code that the device does not support the required services.  The UUID passed to
				-addAllowedUUID: is the only UUID that must be present in the device's SDP service records.
				Alternatively, all of the UUIDs in the UUID array passed to -addAllowedUUIDArray must be
				present.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		allowedUUID UUID that a device may contain to be selected
*/

- (void)addAllowedUUID:(IOBluetoothSDPUUID *)allowedUUID;

/*!
    @method		addAllowedUUIDArray:
	@abstract	Adds an array of UUIDs to the list of UUIDs that are used to validate the user's selection.
	@discussion	The user's device selection gets validated against the UUIDs passed to -addAllowedUUID:
				addAllowedUUIDArray:.  Each call to those methods essentially adds a filter that the
				selected device gets validated with.  If any of the filters match, the device is considered
				valid.  If they all fail, the device is not valid and the user is presented with an
				error code that the device does not support the required services.  The UUID passed to
				-addAllowedUUID: is the only UUID that must be present in the device's SDP service records.
				Alternatively, all of the UUIDs in the UUID array passed to -addAllowedUUIDArray must be
				present.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		allowedUUIDArray An NSArray of UUIDs that all must be present in a device for it to be selectable.
*/

- (void)addAllowedUUIDArray:(NSArray *)allowedUUIDArray;

/*!
    @method		clearAllowedUUIDs
	@abstract	Resets the controller back to the default state where it will accept any device the user selects.
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
*/

- (void)clearAllowedUUIDs;

/*!
    @method		setTitle:
	@abstract	Sets the title of the panel when not run as a sheet.
	@discussion	The panel title should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		windowTitle Title of the device selector panel.
*/

- (void)setTitle:(NSString *)windowTitle;
/*!
    @method		getTitle
	@abstract	Returns the title of the device selector panel (i.e. what was set in -setTitle:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the title of the device selector panel.
*/

- (NSString *)getTitle;

/*!
    @method		setDescriptionText:
	@abstract	Sets the description text that appears in the device selector panel.
	@discussion	The description text should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		descriptionText String that appears in the description section of the device selector panel.
*/

- (void)setDescriptionText:(NSString *)descriptionText;

/*!
    @method		getDescriptionText
	@abstract	Returns the description text that appears in the device selector panel (i.e. what was set in -setDescriptionText:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the description text of the device selector panel.
*/

- (NSString *)getDescriptionText;

/*!
    @method		setPrompt:
	@abstract	Sets the title of the default/select button in the device selector panel.
	@discussion	The prompt text should be localized for best user experience.

				NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@param		prompt String that appears in the default/select button in the device selector panel.
*/

- (void)setPrompt:(NSString *)prompt;

/*!
    @method		getPrompt
	@abstract	Returns the title of the default/select button in the device selector panel (i.e. what was set in -setPrompt:).
	@discussion	NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
	@result		Returns the default button title of the device selector panel.
*/

- (NSString *)getPrompt;

@end

                                                                                                                                                                                                                                                                                                                                                                                                              IOBluetoothUI.tbd                                                                                   0100644 0001750 0001750 00000036213 12571375064 034041  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A                                                                       ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/IOBluetoothUI
exports:         
  - archs:           [ x86_64 ]
    objc-ivars:      [ _FauxUIElement.parent, _FauxUIElement.role, _IOBluetoothConcreteDeviceController._collectionView, 
                       _IOBluetoothConcreteDeviceController._placeHolderView, 
                       _IOBluetoothConcreteDeviceController.mAllowedServiceArray, 
                       _IOBluetoothConcreteDeviceController.mBTNotificationRef, 
                       _IOBluetoothConcreteDeviceController.mCancel, _IOBluetoothConcreteDeviceController.mCancelButton, 
                       _IOBluetoothConcreteDeviceController.mContextInfo, 
                       _IOBluetoothConcreteDeviceController.mDelayedScanTimer, 
                       _IOBluetoothConcreteDeviceController.mDescriptionText, 
                       _IOBluetoothConcreteDeviceController.mDescriptionTextField, 
                       _IOBluetoothConcreteDeviceController.mDeviceCategory, 
                       _IOBluetoothConcreteDeviceController.mDeviceInquiryTableView, 
                       _IOBluetoothConcreteDeviceController.mDeviceType, 
                       _IOBluetoothConcreteDeviceController.mDidEndSelector, 
                       _IOBluetoothConcreteDeviceController.mFavoriteButton, 
                       _IOBluetoothConcreteDeviceController.mHeaderText, 
                       _IOBluetoothConcreteDeviceController.mIconView, 
                       _IOBluetoothConcreteDeviceController.mInquiryInProgress, 
                       _IOBluetoothConcreteDeviceController.mIsFirstIteration, 
                       _IOBluetoothConcreteDeviceController.mIsValidatingDevice, 
                       _IOBluetoothConcreteDeviceController.mModalDelegate, 
                       _IOBluetoothConcreteDeviceController.mOptions, _IOBluetoothConcreteDeviceController.mPanelEndCode, 
                       _IOBluetoothConcreteDeviceController.mPanelRunDate, 
                       _IOBluetoothConcreteDeviceController.mProgressIndicator, 
                       _IOBluetoothConcreteDeviceController.mPrompt, _IOBluetoothConcreteDeviceController.mRemoteNameReadsInProgress, 
                       _IOBluetoothConcreteDeviceController.mRunState, 
                       _IOBluetoothConcreteDeviceController.mSearchAttributes, 
                       _IOBluetoothConcreteDeviceController.mSelectButton, 
                       _IOBluetoothConcreteDeviceController.mShowBDAddrs, 
                       _IOBluetoothConcreteDeviceController.mStatusTextField, 
                       _IOBluetoothConcreteDeviceController.mTitleTextField, 
                       _IOBluetoothConcreteDeviceController.mWarningImageView, 
                       _IOBluetoothConcreteDeviceController.mWindowTitle, 
                       _IOBluetoothConcreteDeviceSelectorController.mBTAddrTextBox, 
                       _IOBluetoothConcreteDeviceSelectorController.mPerformSDPCheck, 
                       _IOBluetoothConcreteDeviceSelectorController.mShowAdvancedButton, 
                       _IOBluetoothConcretePairingController.mDevicePair, 
                       _IOBluetoothConcretePairingController.mNextState, 
                       _IOBluetoothConcretePairingController.mPINCodeSheetState, 
                       _IOBluetoothConcretePairingController.mPairedDevice, 
                       _IOBluetoothConcretePairingController.otherAppsPanel, 
                       _IOBluetoothConcretePairingController.otherAppsPanelBR, 
                       _IOBluetoothConcretePairingController.pinCodeDeviceNameField, 
                       _IOBluetoothConcretePairingController.pinCodeRequestPanel, 
                       _IOBluetoothConcretePairingController.pinCodeRespondButton, 
                       _IOBluetoothConcretePairingController.pinCodeResponseField, 
                       _IOBluetoothConcretePairingController.useForAB, 
                       _IOBluetoothConcretePairingController.useForABPreBR, 
                       _IOBluetoothConcretePairingController.useForBladeRunner, 
                       _IOBluetoothConcretePairingController.useForDUN, 
                       _IOBluetoothConcretePairingController.useForDUNPreBR, 
                       _IOBluetoothConcreteServiceBrowserController.mRefreshServicesButton, 
                       _IOBluetoothConcreteServiceBrowserController.mSDPQueryInProgress, 
                       _IOBluetoothConcreteServiceBrowserController.mServicesTableDataSource, 
                       _IOBluetoothConcreteServiceBrowserController.mServicesTableView, 
                       _IOBluetoothDeviceImageVault.mImageMajorDict, _IOBluetoothDeviceImageVault.mMacImageMajorDict, 
                       _IOBluetoothDeviceInquiryTableView._addressColumn, 
                       _IOBluetoothDeviceInquiryTableView._busy, _IOBluetoothDeviceInquiryTableView._currentTableViewStorage, 
                       _IOBluetoothDeviceInquiryTableView._deviceCategoryFilter, 
                       _IOBluetoothDeviceInquiryTableView._deviceTypeFilter, 
                       _IOBluetoothDeviceInquiryTableView._discoveredDevices, 
                       _IOBluetoothDeviceInquiryTableView._displayExtendedInfoBits, 
                       _IOBluetoothDeviceInquiryTableView._expansion, _IOBluetoothDeviceInquiryTableView._expansion2, 
                       _IOBluetoothDeviceInquiryTableView._favoriteDevices, 
                       _IOBluetoothDeviceInquiryTableView._infSearch, _IOBluetoothDeviceInquiryTableView._inquiry, 
                       _IOBluetoothDeviceInquiryTableView._inquiryIterations, 
                       _IOBluetoothDeviceInquiryTableView._lastColumnSelected, 
                       _IOBluetoothDeviceInquiryTableView._majorDeviceClass, 
                       _IOBluetoothDeviceInquiryTableView._majorServiceClass, 
                       _IOBluetoothDeviceInquiryTableView._minorDeviceClass, 
                       _IOBluetoothDeviceInquiryTableView._recentDevices, 
                       _IOBluetoothDeviceInquiryTableView._suppressPrefillFavorites, 
                       _IOBluetoothDeviceInquiryTableView._suppressPrefillRecents, 
                       _IOBluetoothDeviceInquiryTableView._tableViewStorageAllDevices, 
                       _IOBluetoothDeviceInquiryTableView._tableViewStorageFiltered, 
                       _IOBluetoothDeviceInquiryTableView._tmpDevicesRemaining, 
                       _IOBluetoothDeviceInquiryTableView._updateNewDeviceNames, 
                       _IOBluetoothDeviceInquiryTableView._updatingNameOfDevice, 
                       _IOBluetoothDevicePairViewController._PINCode, _IOBluetoothDevicePairViewController._delegate, 
                       _IOBluetoothDevicePairViewController._device, _IOBluetoothDevicePairViewController._devicePair, 
                       _IOBluetoothDevicePairViewController._expansion, 
                       _IOBluetoothDevicePairViewController._passkeyDisplay, 
                       _IOBluetoothDevicePairViewController._useCustomPINCode, 
                       _IOBluetoothHardwareValidation.mCancelText, _IOBluetoothHardwareValidation.mHWOffCancelButton, 
                       _IOBluetoothHardwareValidation.mHWOffIcon, _IOBluetoothHardwareValidation.mHWOffOkButton, 
                       _IOBluetoothHardwareValidation.mHWOffText, _IOBluetoothHardwareValidation.mHardwareOffPanel, 
                       _IOBluetoothHardwareValidation.mNoHWCancelButton, 
                       _IOBluetoothHardwareValidation.mNoHWIcon, _IOBluetoothHardwareValidation.mNoHWText, 
                       _IOBluetoothHardwareValidation.mNoHardarePanel, 
                       _IOBluetoothPasskeyDisplay.backgroundImageConstraint, 
                       _IOBluetoothPasskeyDisplay.centeredView, _IOBluetoothPasskeyDisplay.isIncomingRequest, 
                       _IOBluetoothPasskeyDisplay.mBackgroundImage, _IOBluetoothPasskeyDisplay.mPasskeyCharacters, 
                       _IOBluetoothPasskeyDisplay.mPasskeyIndex, _IOBluetoothPasskeyDisplay.mPasskeyString, 
                       _IOBluetoothPasskeyDisplay.mReturnHighlightImage, 
                       _IOBluetoothPasskeyDisplay.mReturnImage, _IOBluetoothPasskeyDisplay.mReturnImageView, 
                       _IOBluetoothPasskeyDisplay.passkey, _IOBluetoothPasskeyDisplay.showFeedback, 
                       _IOBluetoothPasskeyDisplay.usePasskeyNotifications, 
                       _IOBluetoothPasskeyDisplayNibOwner.mPasskeyDisplay, 
                       _IOBluetoothTransferProgressUI.mBytesTransferredField, 
                       _IOBluetoothTransferProgressUI.mDeviceName, _IOBluetoothTransferProgressUI.mFileName, 
                       _IOBluetoothTransferProgressUI.mFileNameField, _IOBluetoothTransferProgressUI.mProgressIndicator, 
                       _IOBluetoothTransferProgressUI.mStatusField, _IOBluetoothTransferProgressUI.mTimeRemainingField, 
                       _IOBluetoothTransferProgressUI.mTimeRemainingFieldLabel, 
                       _IOBluetoothTransferProgressUI.mTransferType, _IOBluetoothTransferProgressUI.mUsesFileNameField, 
                       _IOBluetoothTransferProgressUI.mWindowFrames, _IOBluetoothUICollectionView.mAutoAdjustButtonSize, 
                       _IOBluetoothUICollectionView.mUserPasscode, _IOBluetoothUI_BatteryControl.batteryImage, 
                       _IOBluetoothUI_BatteryControl.batteryState, _IOBluetoothUI_BatteryControl.floatVal, 
                       _IOBluetoothUI_BatteryControl.floatValue, _IOBluetoothUI_BatteryControl.isUsingRedLevel, 
                       _IOBluetoothUI_BatteryControl.levelImage0, _IOBluetoothUI_BatteryControl.levelImage1, 
                       _IOBluetoothUI_BatteryControl.levelImage2, _IOBluetoothUI_BatteryControl.mBT_Row, 
                       _IOBluetoothUI_BatteryControl.mDeviceName, _IOBluetoothUI_BatteryControl.mDrawNow, 
                       _IOBluetoothUI_BatteryControl.mSelected, _IOBluetoothUI_BatteryControl.receivedValue, 
                       _IOBluetoothUI_BatteryControl.redLevelThreshold, 
                       _IOBluetoothUI_BatteryControl.scalesWhenResized, 
                       _IOBluetooth_HIDNameFormatter._maxLength, _ObjectTableDataSource._comparisonType, 
                       _ObjectTableDataSource._data, _ObjectTableDataSource._delegate, 
                       _ObjectTableDataSource._descendingSort, _ObjectTableDataSource._lastSortHeader, 
                       _ObjectTableDataSource._readOnly, _PlainFormatter._allowDashesAndUnderscores, 
                       _PlainFormatter._allowDigits, _PlainFormatter._allowLetters, 
                       _PlainFormatter._characterSet, _PlainFormatter._maxChars ]
  - archs:           [ i386, x86_64 ]
    symbols:         [ _BluetoothAudioNotificationType, _BluetoothInquiryCacheTimeout, 
                       _BluetoothPreferencesChanged, _DeviceControllerHCIControllerNotificationHandler, 
                       _IOBluetoothAlertHCIControllerPublished, _IOBluetoothAlertHCIPowerStateOn, 
                       _IOBluetoothDecodeCommand, _IOBluetoothDecodeEvent, 
                       _IOBluetoothDecodeGroup, _IOBluetoothDecodeManufacturerName, 
                       _IOBluetoothDecodeStatus, _IOBluetoothDeviceSelectorRunPanelWithAttributes, 
                       _IOBluetoothGetDefaultNameOfL2CAPPSMString, _IOBluetoothGetDefaultNameOfServiceString, 
                       _IOBluetoothGetDeviceSelectorController, _IOBluetoothGetGenericTypeStringForDevice, 
                       _IOBluetoothGetGenericTypeStringForDeviceClasses, 
                       _IOBluetoothGetLocalizedUIStringForKey, _IOBluetoothGetMajorClassOfDeviceString, 
                       _IOBluetoothGetMajorClassOfDeviceStringClass, _IOBluetoothGetMinorClassOfDeviceString, 
                       _IOBluetoothGetMinorClassOfDeviceStringClass, _IOBluetoothGetPairingController, 
                       _IOBluetoothIsOptionKeyDown, _IOBluetoothIsServiceUsableByUser, 
                       _IOBluetoothIsShiftKeyDown, _IOBluetoothOpenBluetoothHelpAtPath, 
                       _IOBluetoothPairingControllerRunPanelWithAttributes, 
                       _IOBluetoothPreferenceGetMenuExtraShowState, _IOBluetoothPreferenceSetMenuExtraShowState, 
                       _IOBluetoothServiceBrowserControllerBrowseDevices, 
                       _IOBluetoothServiceBrowserControllerBrowseDevicesAsSheet, 
                       _IOBluetoothServiceBrowserControllerCreate, _IOBluetoothServiceBrowserControllerDiscover, 
                       _IOBluetoothServiceBrowserControllerDiscoverAsSheet, 
                       _IOBluetoothServiceBrowserControllerDiscoverWithDeviceAttributes, 
                       _IOBluetoothServiceBrowserControllerSetOptions, 
                       _IOBluetoothValidateHardware, _IOBluetoothValidateHardwareWithDescription, 
                       _ISCopyDeviceIconPath, _ISShouldProposeToAddDeviceToISync, 
                       _ImageForModelString, _ObjectTableDataSource_ColumnSorter, 
                       __IOBluetoothUI_AlignCGPointToUserSpace, __IOBluetoothUI_AlignCGRectToUserSpace, 
                       __IOBluetoothUI_AlignPointToUserSpace, __IOBluetoothUI_AlignRectToUserSpace, 
                       _gAppleObjectPushServiceClassUUID, _isDebugLogEnabled, 
                       _registerValueTransformers, _sOBEXObjectPushSupportFormatsListNameMapping ]
    objc-classes:    [ _FauxUIElement, _IOBluetoothAccessibilityIgnoredImageCell, 
                       _IOBluetoothAccessibilityIgnoredTextFieldCell, _IOBluetoothConcreteDeviceController, 
                       _IOBluetoothConcreteDeviceSelectorController, _IOBluetoothConcreteObjectPush, 
                       _IOBluetoothConcretePairingController, _IOBluetoothConcreteServiceBrowserController, 
                       _IOBluetoothDeviceImageVault, _IOBluetoothDeviceInquiryTableView, 
                       _IOBluetoothDevicePairViewController, _IOBluetoothDevicePairViewControllerExpansion, 
                       _IOBluetoothDeviceSelectorController, _IOBluetoothHardwareValidation, 
                       _IOBluetoothObjectPushUIController, _IOBluetoothPairingController, 
                       _IOBluetoothPasskeyDisplay, _IOBluetoothPasskeyDisplayNibOwner, 
                       _IOBluetoothServiceBrowserController, _IOBluetoothTransferProgressUI, 
                       _IOBluetoothUIBackgroundStyle2AlternateRemoveButton, 
                       _IOBluetoothUIBackgroundStyle2GrayColorTransformer, 
                       _IOBluetoothUIBackgroundStyle2RemoveButton, _IOBluetoothUIBool2BWColorTransformer, 
                       _IOBluetoothUICollectionView, _IOBluetoothUIConnected2ImageIndicatorTransformer, 
                       _IOBluetoothUIConnected2StatusTransformer, _IOBluetoothUIDisableProgressBar, 
                       _IOBluetoothUIPaired2ActionTitle, _IOBluetoothUIPairedColorTransformer, 
                       _IOBluetoothUISortedArrayController, _IOBluetoothUI_BatteryControl, 
                       _IOBluetooth_HIDNameFormatter, _OBEXObjectReceiveConcreteWindowController, 
                       _OBEXObjectReceiveWindowController, _ObjectTableDataSource, 
                       _PlainFormatter, _TerminateEnabledModalPanel ]
...
                                                                                                                                                                                                                                                                                                                                                                                     Modules/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032310  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A                                                                       module.modulemap                                                                                    0100644 0001750 0001750 00000000172 12566223233 035502  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions/A/Modules                                                               framework module IOBluetoothUI [extern_c] {
    umbrella header "IOBluetoothUI.h"
    export *
    module * { export * }
}                                                                                                                                                                                                                                                                                                                                                                                                      Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 032163  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/Versions                                                                         osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOBluetoothUI.framework/module.map    0100644 0001750 0001750 00000000334 12566173265 030764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        framework module IOBluetoothUI [extern_c] {
  umbrella header "IOBluetoothUI.h"

  export *
  module * { export * }

  module IOBluetoothPasskeyDisplay {
    header "objc/IOBluetoothPasskeyDisplay.h"
    export *
  }
}

                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/                      0040755 0001750 0001750 00000000000 12612224741 025313  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Headers               0120777 0001750 0001750 00000000000 12620245063 033334  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/IOKit.tbd             0120777 0001750 0001750 00000000000 12620245063 033664  2Versions/Current/IOKit.tbd                                                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/             0040755 0001750 0001750 00000000000 12612224741 027123  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/           0040755 0001750 0001750 00000000000 12612224741 027303  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/   0040755 0001750 0001750 00000000000 12612224741 030656  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/DV/0040755 0001750 0001750 00000000000 12612224741 031167  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        DVFamily.h                                                                                          0100644 0001750 0001750 00000026236 12566223116 032745  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/DV                                                                    /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
	File:		DVFamily.h

	Copyright:	 2001 by Apple Computer, Inc., all rights reserved.

*/
//
//	DVFamily.h
//

#ifndef __DVFAMILY__
#define __DVFAMILY__

#include <IOKit/avc/IOFireWireAVCConsts.h>
#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////
//
// constants
//
///////////////////////////////////////////////////////////////////////

enum 
{
	kInvalidDVDeviceID		= 0,
	kEveryDVDeviceID		= 0xFFFFFFFF,
	kInvalidDVConnectionID		= 0,
        kInvalidDVDeviceRefNum		= 0,
	kEveryDVDeviceRefNum		= 0xFFFFFFFF
};

enum
{
	kDVDisconnectedErr			= -14101,
	kDVBadIDErr				= -14102,
	kUnknownStandardErr			= -14103,
	kAlreadyEnabledErr			= -14104,
	kNotEnabledErr				= -14105,
	kDVDeviceBusyErr			= -14106,
        kDVNoNotificationsErr			= -14107
};

enum
{
	kUnknownStandard	= 0,
	kNTSCStandard		= 1,
	kPALStandard 		= 2
};

// DV events
enum
{
	kInvalidDVDeviceEvent		= 0,
	
	kDVDeviceAdded				= 1 << 0,
	kDVDeviceRemoved			= 1 << 1,
	KDVDeviceInfoChanged		= 1 << 2,
	
	kDVIsochReadEnabled			= 1 << 3,
	kDVIsochReadComplete		= 1 << 4,
	kDVIsochReadDisabled	 	= 1 << 5,

	kDVIsochWriteEnabled		= 1 << 6,
	kDVIsochWriteComplete		= 1 << 7,
	kDVIsochWriteDisabled		= 1 << 8,

	kDVAVCEnabled				= 1 << 9,
	kDVAVCDisabled				= 1 << 10,
	kDVAVCTransactionComplete	= 1 << 11,

	// Tempory new event for input. Goes away DVFamily is dead.
	kDVInputEvent = 1 << 12,

	kDVEveryEvent				= 0x00001fff
};

enum
{
	kDVGlobalEventConnectionID	= 0xffffffff,
	kEventSpecificDataSize		= 16
};

///////////////////////////////////////////////////////////////////////
//
// types
//
///////////////////////////////////////////////////////////////////////

// holds our device identification...
typedef UInt32 DVDeviceID;			

// holds our device connection identification...
typedef UInt32 DVDeviceRefNum;

typedef UInt32 DVClientID;

// AVC
enum {
    kAVCSupportInquiryCommand       	= 0x02,
    kAVCReportInquiryCommand        	= 0x03,

    // Opcodes and parameters
    kAVCWindOpcode                          = 0xc4,
    kAVCWindHighSpeedRewind                 = 0x45,
    kAVCWindStop                            = 0x60,
    kAVCWindRewind                          = 0x65,
    kAVCWindFastForward                     = 0x75,

    kAVCPlayOpcode                          = 0xc3,
    kAVCPlayNextFrame                       = 0x30,
    kAVCPlaySlowest                         = 0x31,
    kAVCPlaySlow6                           = 0x32, 
    kAVCPlaySlow5                           = 0x33,
    kAVCPlaySlow4                           = 0x34,
    kAVCPlaySlow3                           = 0x35,
    kAVCPlaySlow2                           = 0x36,
    kAVCPlaySlow1                           = 0x37,
    kAVCPlay1x                              = 0x38,
    kAVCPlayFast1                           = 0x39, 
    kAVCPlayFast2                           = 0x3a,
    kAVCPlayFast3                           = 0x3b,
    kAVCPlayFast4                           = 0x3c,
    kAVCPlayFast5                           = 0x3d,
    kAVCPlayFast6                           = 0x3e,
    kAVCPlayFastest                         = 0x3f,
    kAVCPlayPreviousFrame                   = 0x40,
    kAVCPlayRevSlowest                      = 0x41,
    kAVCPlayRevSlow6                        = 0x42,
    kAVCPlayRevSlow5                        = 0x43,
    kAVCPlayRevSlow4                        = 0x44,
    kAVCPlayRevSlow3                        = 0x45,
    kAVCPlayRevSlow2                        = 0x46,
    kAVCPlayRevSlow1                        = 0x47,
    kAVCPlayRev1x                           = 0x48,
    kAVCPlayRevFast1                        = 0x49,
    kAVCPlayRevFast2                        = 0x4a,
    kAVCPlayRevFast3                        = 0x4b,
    kAVCPlayRevFast4                        = 0x4c,
    kAVCPlayRevFast5                        = 0x4d,
    kAVCPlayRevFast6                        = 0x4e,
    kAVCPlayRevFastest                      = 0x4f,
    kAVCPlayForward                         = 0x75,
    kAVCPlayForwardPause                    = 0x7d,
    kAVCPlayReverse                         = 0x65,
    kAVCPlayReversePause                    = 0x6d,

    kAVCMediumOpcode                        = 0xc1,
    kAVCMediumEject                         = 0x60,
    kAVCMediumTrayOpen                      = 0x31,
    kAVCMediumTrayClose                     = 0x32,

    kAVCRecordOpcode                        = 0xc2,
    kAVCRecVideoInsert                      = 0x31,
    kAVCRecAudioInsert                      = 0x32,
    kAVCRecAVInsert                         = 0x33,
    kAVCRecSubcodeInsert                    = 0x34,
    kAVCRecord                              = 0x75,
    kAVCRecPause                            = 0x7d,
    kAVCRecVideoInsertPause                 = 0x41,
    kAVCRecAudioInsertPause                 = 0x42,
    kAVCRecAVInsertPause                    = 0x43,
    kAVCRecSubcodeInsertPause               = 0x44,

    kAVCRecSpeedOpcode                      = 0xdb,
    kAVCRecSpeedLowSpeed                    = 0x00,
    kAVCRecSpeed32                          = 0x20, 
    kAVCRecSpeedStandard                    = 0x6f,
    kAVCRecSpeedHighSpeed                   = 0xfe,
    kAVCRecSpeedDummyOperand                = 0x7f,

    kAVCEditPresetOpcode                    = 0x45,
    kAVCEditPreRollAndStandby               = 0x00,
    kAVCEditVideoInsert                     = 0x21,
    kAVCEditAudioInsert                     = 0x22,
    kAVCEditAVInsert                        = 0x23,
    kAVCEditSubcodeInsert                   = 0x24,
    kAVCEditSyncRecord                      = 0x25,
    kAVCEditSyncPlay                        = 0x35,
    kAVCEditOtherMode                       = 0x60,
    kAVCEditInPoint                         = 0x00,
    kAVCEditOutPoint                        = 0x01,
    kAVCEditPreRollTime                     = 0x02,
    kAVCEditDummyOperand                    = 0xff,

    kAVCPositionDummyOperand                = 0xff,

    kAVCPositionTimeCodeOpcode              = 0x51,
    kAVCPositionValueInquiry                = 0x71,

    kAVCMechaModeInquiryOpcode              = 0xd0,
    kAVCMechaModeDummyOperand               = 0x7f

};

typedef struct AVCCTSFrameStruct {
        UInt8           cmdType_respCode;     // cmd type/resp onse code
        UInt8           headerAddress;
        UInt8           opcode;
        UInt8           operand[5];
} AVCCTSFrameStruct, *AVCCTSFrameStructPtr;

// for sending AVC commands
typedef struct AVCTransactionParamsStruct {
	Ptr						commandBufferPtr;
	UInt32					commandLength;
	Ptr						responseBufferPtr;
	UInt32					responseBufferSize;
	void *		responseHandler;	// Obsolete
} AVCTransactionParams, *AVCTransactionParamsPtr;

///////////////////////////////////////////////////////////////////////
//
// DV Event Notification
//

typedef struct OpaqueRef	*DVNotificationID;

typedef struct DVEventHeaderStruct {
	DVDeviceID			deviceID;			// who it's from
	DVNotificationID	notifID;
	UInt32				theEvent;			// what the event was
} DVEventHeader, *DVEventHeaderPtr;

typedef struct DVEventRecordStruct {		// generalized form
	DVEventHeader		eventHeader;
	UInt8				eventData[kEventSpecificDataSize];
} DVEventRecord, *DVEventRecordPtr;

typedef struct DVConnectionEventStruct {
	DVEventHeader		eventHeader;
} DVConnectionEvent, *DVConnectionEventPtr;

typedef struct DVIsochCompleteEventStruct {
	DVEventHeader		eventHeader;
	Ptr					pFrameBuffer;
	unsigned long		bufferSize;
	UInt32				fwCycleTime;
} DVIsochCompleteEvent, *DVIsochCompleteEventPtr;

typedef struct DVAVTransactionCompleteEventStruct {
	DVEventHeader			eventHeader;
	Ptr						commandBufferPtr;
	UInt32					commandLength;
	Ptr						responseBufferPtr;
	UInt32					responseBufferSize;
} DVAVCTransactionCompleteEvent, *DVAVCTransactionCompleteEventPtr;

// DV notification proc
typedef OSStatus (*DVNotifyProc)(DVEventRecordPtr event, void *userData );
								
///////////////////////////////////////////////////////////////////////
//
// external prototypes
//
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// general device management
//
UInt32 DVCountDevices( void );
OSErr DVGetIndDevice( DVDeviceID * pDVDevice, UInt32 index );

OSErr DVSetDeviceName( DVDeviceID deviceID, char * str );
OSErr DVGetDeviceName( DVDeviceID deviceID, char * str );

OSErr DVOpenDriver( DVDeviceID deviceID, DVDeviceRefNum *pRefNum );
OSErr DVCloseDriver( DVDeviceRefNum refNum );

//OSErr DVGetDeviceInfo( DVDeviceID deviceID, DVDeviceInfoPtr pInfo );
//OSErr DVGetDeviceClock( DVDeviceID deviceID, Component *clock );

///////////////////////////////////////////////////////////////////////
//
// DV event notification
//
// kEveryDVDeviceRefNum can be used as a wild card refNum, for notifications about all
// devices - especially handy when there aren't any yet!
//
OSErr DVNewNotification( DVDeviceRefNum refNum, DVNotifyProc notifyProc,
						void *userData, DVNotificationID *pNotifyID );
	
OSErr DVNotifyMeWhen( DVDeviceRefNum refNum, DVNotificationID notifyID, UInt32 events);
OSErr DVCancelNotification( DVDeviceRefNum refNum, DVNotificationID notifyID );
OSErr DVDisposeNotification( DVDeviceRefNum refNum, DVNotificationID notifyID );

///////////////////////////////////////////////////////////////////////
//
// DV Isoch Read
//
OSErr DVEnableRead( DVDeviceRefNum refNum );
OSErr DVDisableRead( DVDeviceRefNum refNum );
OSErr DVReadFrame( DVDeviceRefNum refNum, Ptr *ppReadBuffer, UInt32 * pSize );
OSErr DVReleaseFrame( DVDeviceRefNum refNum, Ptr pReadBuffer );

///////////////////////////////////////////////////////////////////////
//
// DV Isoch Write
//
OSErr DVEnableWrite( DVDeviceRefNum refNum );
OSErr DVDisableWrite( DVDeviceRefNum refNum );
OSErr DVGetEmptyFrame( DVDeviceRefNum refNum, Ptr *ppEmptyFrameBuffer, UInt32 * pSize );
OSErr DVWriteFrame( DVDeviceRefNum refNum, Ptr pWriteBuffer );
OSErr DVSetWriteSignalMode( DVDeviceRefNum refNum, UInt8 mode);

///////////////////////////////////////////////////////////////////////
//
// AVC transactions
//
OSErr DVDoAVCTransaction( DVDeviceRefNum refNum, AVCTransactionParamsPtr pParams );

OSErr DVIsEnabled( DVDeviceRefNum refNum, Boolean *isEnabled);
OSErr DVGetDeviceStandard( DVDeviceRefNum refNum, UInt32 * pStandard );




#ifdef __cplusplus
}
#endif

#endif __DVFAMILY__


                                                                                                                                                                                                                                                                                                                                                                  IOBSD.h                                                                                             0100644 0001750 0001750 00000003304 12567450741 031617  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _IOBSD_H
#define _IOBSD_H

/*
 * bsd-related registry properties
 */

#define kIOBSDNameKey  "BSD Name"  // (an OSString)
#define kIOBSDNamesKey "BSD Names" // (an OSDictionary of OSString's, for links)
#define kIOBSDMajorKey "BSD Major" // (an OSNumber)
#define kIOBSDMinorKey "BSD Minor" // (an OSNumber)
#define kIOBSDUnitKey  "BSD Unit"  // (an OSNumber)



#endif /* !_IOBSD_H */
                                                                                                                                                                                                                                                                                                                            IOCFBundle.h                                                                                        0100644 0001750 0001750 00000002720 12566177313 032632  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __IOKIT_IOCFBUNDLE_H
#define __IOKIT_IOCFBUNDLE_H

#include <CoreFoundation/CoreFoundation.h>

#define kIOBundleInfoDictionaryVersionKey	CFSTR("CFBundleInfoDictionaryVersion")
#define kIOBundleExecutableKey			CFSTR("CFBundleExecutable")
#define kIOBundleIdentifierKey			CFSTR("CFBundleIdentifier")
#define kIOBundleVersionKey			CFSTR("CFBundleVersion")
#define kIOBundleDevelopmentRegionKey		CFSTR("CFBundleDevelopmentRegion")
#define kIOBundleNameKey			CFSTR("CFBundleName")

#endif /* __IOKIT_IOCFBUNDLE_H */
                                                IOCFPlugIn.h                                                                                        0100644 0001750 0001750 00000004375 12566177313 032627  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOCFPLUGIN_H_
#define _IOKIT_IOCFPLUGIN_H_

/* IOCFPlugIn.h
 */
#include <sys/cdefs.h>

__BEGIN_DECLS

#include <CoreFoundation/CFPlugIn.h>
#if COREFOUNDATION_CFPLUGINCOM_SEPARATE
#include <CoreFoundation/CFPlugInCOM.h>
#endif

#include <IOKit/IOKitLib.h>

/* C244E858-109C-11D4-91D4-0050E4C6426F */
#define kIOCFPlugInInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0xC2, 0x44, 0xE8, 0x58, 0x10, 0x9C, 0x11, 0xD4,			\
    0x91, 0xD4, 0x00, 0x50, 0xE4, 0xC6, 0x42, 0x6F)


#define IOCFPLUGINBASE							\
    UInt16	version;						\
    UInt16	revision;						\
    IOReturn (*Probe)(void *thisPointer, CFDictionaryRef propertyTable,	\
                    io_service_t service, SInt32 * order);		\
    IOReturn (*Start)(void *thisPointer, CFDictionaryRef propertyTable,	\
                      io_service_t service);				\
    IOReturn (*Stop)(void *thisPointer)

typedef struct IOCFPlugInInterfaceStruct {
    IUNKNOWN_C_GUTS;
    IOCFPLUGINBASE;
} IOCFPlugInInterface;


kern_return_t
IOCreatePlugInInterfaceForService(io_service_t service,
                CFUUIDRef pluginType, CFUUIDRef interfaceType,
                IOCFPlugInInterface *** theInterface, SInt32 * theScore);

kern_return_t
IODestroyPlugInInterface(IOCFPlugInInterface ** interface);

__END_DECLS

#endif /* !_IOKIT_IOCFPLUGIN_H_ */
                                                                                                                                                                                                                                                                   IOCFSerialize.h                                                                                     0100644 0001750 0001750 00000002725 12566177313 033355  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1999-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * HISTORY
 *
 */

/* IOCFSerialize serializes CFObjects to a format suitable for passing
 * to the kernel. */

#ifndef __IOKIT_IOCFSERIALIZE_H
#define __IOKIT_IOCFSERIALIZE_H

#include <CoreFoundation/CFBase.h>
#include <CoreFoundation/CFData.h>

#if defined(__cplusplus)
extern "C" {
#endif

enum {
    kIOCFSerializeToBinary	= 0x00000001
};

CF_RETURNS_RETAINED
CFDataRef
IOCFSerialize( CFTypeRef object, CFOptionFlags options );

#if defined(__cplusplus)
}
#endif

#endif /* __IOKIT_IOCFSERIALIZE_H */
                                           IOCFURLAccess.h                                                                                     0100644 0001750 0001750 00000006661 12566177313 033215  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __IOKIT_IOCFURLACCESS_H
#define __IOKIT_IOCFURLACCESS_H

#include <CoreFoundation/CoreFoundation.h>

CFTypeRef IOURLCreatePropertyFromResource(CFAllocatorRef alloc, CFURLRef url, CFStringRef property, SInt32 *errorCode);

Boolean IOURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode);

Boolean IOURLWriteDataAndPropertiesToResource(CFURLRef url, CFDataRef dataToWrite, CFDictionaryRef propertiesToWrite, int32_t *errorCode);

#ifdef HAVE_CFURLACCESS

#define kIOURLFileExists		kCFURLFileExists
#define kIOURLFileDirectoryContents	kCFURLFileDirectoryContents
#define kIOURLFileLength		kCFURLFileLength
#define kIOURLFileLastModificationTime	kCFURLFileLastModificationTime
#define kIOURLFilePOSIXMode		kCFURLFilePOSIXMode
#define kIOURLFileOwnerID		kCFURLFileOwnerID

/* Common error codes; this list is expected to grow */

typedef CFURLError IOURLError;

enum {
    kIOURLUnknownError 			= kCFURLUnknownError,
    kIOURLUnknownSchemeError 		= kCFURLUnknownSchemeError,
    kIOURLResourceNotFoundError 	= kCFURLResourceNotFoundError,
    kIOURLResourceAccessViolationError 	= kCFURLResourceAccessViolationError,
    kIOURLRemoteHostUnavailableError 	= kCFURLRemoteHostUnavailableError,
    kIOURLImproperArgumentsError 	= kCFURLImproperArgumentsError,
    kIOURLUnknownPropertyKeyError 	= kCFURLUnknownPropertyKeyError,
    kIOURLPropertyKeyUnavailableError 	= kCFURLPropertyKeyUnavailableError,
    kIOURLTimeoutError 			= kCFURLTimeoutError
};

#else /* !HAVE_CFURLACCESS */

#define kIOURLFileExists		CFSTR("kIOURLFileExists")
#define kIOURLFileDirectoryContents	CFSTR("kIOURLFileDirectoryContents")
#define kIOURLFileLength		CFSTR("kIOURLFileLength")
#define kIOURLFileLastModificationTime	CFSTR("kIOURLFileLastModificationTime")
#define kIOURLFilePOSIXMode		CFSTR("kIOURLFilePOSIXMode")
#define kIOURLFileOwnerID		CFSTR("kIOURLFileOwnerID")

/* Common error codes; this list is expected to grow */

typedef enum {
      kIOURLUnknownError = -10,
          kIOURLUnknownSchemeError = -11,
          kIOURLResourceNotFoundError = -12,
          kIOURLResourceAccessViolationError = -13,
          kIOURLRemoteHostUnavailableError = -14,
          kIOURLImproperArgumentsError = -15,
          kIOURLUnknownPropertyKeyError = -16,
          kIOURLPropertyKeyUnavailableError = -17,
          kIOURLTimeoutError = -18
} IOURLError;

#endif /* !HAVE_CFURLACCESS */

#endif /* __IOKIT_IOCFURLACCESS_H */
                                                                               IOCFUnserialize.h                                                                                   0100644 0001750 0001750 00000004240 12566177313 033712  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* IOUnserialize.h created by rsulack on Mon 23-Nov-1998 */
/* IOCFUnserialize.h creates CF collections Mon 30-Aug-1999 */

#ifndef __IOKIT_IOCFUNSERIALIZE_H
#define __IOKIT_IOCFUNSERIALIZE_H

#include <CoreFoundation/CFBase.h>
#include <CoreFoundation/CFString.h>

#if defined(__cplusplus)
extern "C" {
#endif

// on success IOCFUnserialize sets errorString to 0 and returns
// the unserialized object.

// on failure IOCFUnserialize sets errorString to a CFString object 
// containing a error message suitable for logging and returns 0

CF_RETURNS_RETAINED
CFTypeRef
IOCFUnserialize(const char *buffer,
                CFAllocatorRef allocator,
                CFOptionFlags options,
                CFStringRef *errorString);

CF_RETURNS_RETAINED
CFTypeRef
IOCFUnserializeBinary(const char	* buffer,
					  size_t          bufferSize,
					  CFAllocatorRef  allocator,
					  CFOptionFlags	  options,
					  CFStringRef	* errorString);

CF_RETURNS_RETAINED
CFTypeRef
IOCFUnserializeWithSize(const char	  * buffer,
						size_t          bufferSize,
						CFAllocatorRef	allocator,
						CFOptionFlags	options,
						CFStringRef	  * errorString);

#if defined(__cplusplus)
}
#endif

#endif /* __IOKIT_IOCFUNSERIALIZE_H */
                                                                                                                                                                                                                                                                                                                                                                IODataQueueClient.h                                                                                 0100644 0001750 0001750 00000016022 12566177313 034225  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKITUSER_IODATAQUEUE_H
#define _IOKITUSER_IODATAQUEUE_H

#include <sys/cdefs.h>

__BEGIN_DECLS
#include <AvailabilityMacros.h>
#include <libkern/OSTypes.h>
#include <mach/port.h>
#include <IOKit/IOReturn.h>
#include <IOKit/IODataQueueShared.h>

/*!
 * @function IODataQueueDataAvailable
 * @abstract Used to determine if more data is avilable on the queue.
 * @param dataQueue The IODataQueueMemory region mapped from the kenel.
 * @result Returns true if data is available and false if not.
 */
Boolean IODataQueueDataAvailable(IODataQueueMemory *dataQueue);

/*!
 * @function IODataQueuePeek
 * @abstract Used to peek at the next entry on the queue.
 * @discussion This function can be used to look at the next entry which allows the entry to be received without having to copy it with IODataQueueDequeue.  In order to do this, call IODataQueuePeek to get the entry.  Then call IODataQueueDequeue with a NULL data pointer.  That will cause the head to be moved to the next entry, but no memory to be copied.
 * @param dataQueue The IODataQueueMemory region mapped from the kernel.
 * @result Returns a pointer to the next IODataQueueEntry if one is available.  Zero is returned if the queue is empty.
 */
IODataQueueEntry *IODataQueuePeek(IODataQueueMemory *dataQueue);

/*!
 * @function IODataQueueDequeue
 * @abstract Dequeues the next available entry on the queue and copies it into the given data pointer.
 * @discussion This function will dequeue the next available entry on the queue.  If a data pointer is provided, it will copy the data into the memory region if there is enough space available as specified in the dataSize parameter.  If no data pointer is provided, it will simply move the head value past the current entry.
 * @param dataQueue The IODataQueueMemory region mapped from the kernel.
 * @param data A pointer to the data memory region in which to copy the next entry data on the queue.  If this parameter is 0 (NULL), it will simply move to the next entry.
 * @param dataSize A pointer to the size of the data parameter.  On return, this contains the size of the actual entry data - even if the original size was not large enough.
 * @result Returns kIOReturnSuccess on success.  Other return values possible are: kIOReturnUnderrun - queue is empty, kIOReturnBadArgument - no dataQueue or no dataSize, kIOReturnNoSpace - dataSize is too small for entry.
 */
IOReturn IODataQueueDequeue(IODataQueueMemory *dataQueue, void *data, uint32_t *dataSize);

/*!
 * @function IODataQueueWaitForAvailableData
 * @abstract Wait for an incoming dataAvailable message on the given notifyPort.
 * @discussion This method will simply wait for an incoming message on the given notifyPort.  Once it is received, the return from mach_msg() is returned.
 * @param dataQueue The IODataQueueMemory region mapped from the kernel.
 * @param notificationPort Mach port on which to listen for incoming messages.
 * @result Returns kIOReturnSuccess on success.  Returns kIOReturnBadArgument if either dataQueue is 0 (NULL) or notiryPort is MACH_PORT_NULL.  Returns the result of the mach_msg() listen call on the given port.
 */
IOReturn IODataQueueWaitForAvailableData(IODataQueueMemory *dataQueue, mach_port_t notificationPort);

/*!
 * @function IODataQueueAllocateNotificationPort
 * @abstract Allocates and returns a new mach port able to receive data available notifications from an IODataQueue.
 * @discussion This port is intended to be passed down into the kernel and into an IODataQueue to allow it to send the appropriate notification.  The returned mach port is allocated with a queue limit of one message.  This allows only one mach message to be queued up at a time.  The IODataQueue code is written with the restriction in mind and will only queue up a message if no messages alread have been sent.
 * @result Returns a newly allocated mach port on success.  On failure, it returns MACH_PORT_NULL.
 */
mach_port_t IODataQueueAllocateNotificationPort();

/*!
 * @function IODataQueueEnqueue
 * @abstract Enqueues a new entry on the queue.
 * @discussion This method adds a new data entry of dataSize to the queue.  It sets the size parameter of the entry pointed to by the tail value and copies the memory pointed to by the data parameter in place in the queue.  Once that is done, it moves the tail to the next available location.  When attempting to add a new entry towards the end of the queue and there isn't enough space at the end, it wraps back to the beginning.<br>  If the queue is empty when a new entry is added, the port specified in IODataQueueSetNotificationPort will be used to send a message to the client process that data is now available. <br> <b>Please note that using this method without mapped memory create from an IOSharedDataQueue will result in undefined behavior. </b>
 * @param dataQueue The IODataQueueMemory region mapped from the kernel created from an IOSharedDataQueue.
 * @param data Pointer to the data to be added to the queue.
 * @param dataSize Size of the data pointed to by data.
 * @result Returns kIOReturnSuccess on success.  Other return values possible are: kIOReturnOverrun - queue is full.
 */
IOReturn IODataQueueEnqueue(IODataQueueMemory *dataQueue, void *data, uint32_t dataSize) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
 * @function IODataQueueSetNotificationPort
 * @abstract Creates a simple mach message targeting the mach port specified in port.
 * @discussion This message is sent when data is added to an empty queue.  It is to notify another user process that new data has become available.  <b>Please note that using this method without mapped memory create from an IOSharedDataQueue will result in undefined behavior. </b>
 * @param dataQueue The IODataQueueMemory region mapped from the kernel created from an IOSharedDataQueue.
 * @param notifyPort The mach port to target with the notification message.
 * @result Returns kIOReturnSuccess on success.  Returns kIOReturnBadArgument if either dataQueue is 0 (NULL).
 */
IOReturn IODataQueueSetNotificationPort(IODataQueueMemory *dataQueue, mach_port_t notifyPort) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

__END_DECLS

#endif /* _IOKITUSER_IODATAQUEUE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              IODataQueueShared.h                                                                                 0100644 0001750 0001750 00000011711 12567450742 034216  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IODATAQUEUESHARED_H
#define _IOKIT_IODATAQUEUESHARED_H

#include <libkern/OSTypes.h>
#include <mach/port.h>
#include <mach/message.h>

/*!
 * @typedef IODataQueueEntry
 * @abstract Represents an entry within the data queue
 * @discussion This is a variable sized struct.  The data field simply represents the start of the data region.  The size of the data region is stored in the size field.  The whole size of the specific entry is the size of a UInt32 plus the size of the data region.  
 * @field size The size of the following data region.
 * @field data Represents the beginning of the data region.  The address of the data field is a pointer to the start of the data region.
 */
typedef struct _IODataQueueEntry{
    UInt32  size;
    UInt8   data[4];
} IODataQueueEntry;

/*!
 * @typedef IODataQueueMemory
 * @abstract A struct mapping to the header region of a data queue.
 * @discussion This struct is variable sized.  The struct represents the data queue header information plus a pointer to the actual data queue itself.  The size of the struct is the combined size of the header fields (3 * sizeof(UInt32)) plus the actual size of the queue region.  This size is stored in the queueSize field.
 * @field queueSize The size of the queue region pointed to by the queue field.
 * @field head The location of the queue head.  This field is represented as a byte offset from the beginning of the queue memory region.
 * @field tail The location of the queue tail.  This field is represented as a byte offset from the beginning of the queue memory region.
 * @field queue Represents the beginning of the queue memory region.  The size of the region pointed to by queue is stored in the queueSize field.
 */
typedef struct _IODataQueueMemory {
    UInt32            queueSize;
    volatile UInt32   head;
    volatile UInt32   tail;
    IODataQueueEntry  queue[1];
} IODataQueueMemory;

/*!
 * @typedef IODataQueueAppendix
 * @abstract A struct mapping to the appendix region of a data queue.
 * @discussion This struct is variable sized dependent on the version.  The struct represents the data queue appendix information.
 * @field version The version of the queue appendix.
 * @field msgh Mach message header containing the notification mach port associated with this queue.
 */
typedef struct _IODataQueueAppendix {
    UInt32            version;
    mach_msg_header_t msgh;
} IODataQueueAppendix;

/*!
 * @defined DATA_QUEUE_ENTRY_HEADER_SIZE Represents the size of the data queue entry header independent of the actual size of the data in the entry.  This is the overhead of each entry in the queue.  The total size of an entry is equal to this value plus the size stored in the entry's size field (in IODataQueueEntry).
 */
#define DATA_QUEUE_ENTRY_HEADER_SIZE (sizeof(IODataQueueEntry) - 4)

/*!
 * @defined DATA_QUEUE_MEMORY_HEADER_SIZE Represents the size of the data queue memory header independent of the actual size of the queue data itself.  The total size of the queue memory is equal to this value plus the size of the queue appendix and the size of the queue data region which is stored in the queueSize field of IODataQueueMeory.
 */
#define DATA_QUEUE_MEMORY_HEADER_SIZE (sizeof(IODataQueueMemory) - sizeof(IODataQueueEntry))

/*!
 * @defined DATA_QUEUE_MEMORY_APPENDIX_SIZE Represents the size of the data queue memory appendix independent of the actual size of the queue data itself.  The total size of the queue memory is equal to this value plus the size of queue header and size of the queue data region which is stored in the queueSize field of IODataQueueMeory.
 */
#define DATA_QUEUE_MEMORY_APPENDIX_SIZE (sizeof(IODataQueueAppendix))

#endif /* _IOKIT_IODATAQUEUESHARED_H */

                                                       IOInterruptAccounting.h                                                                             0100644 0001750 0001750 00000020234 12567450742 035220  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __IOKIT_IOINTERRUPTACCOUNTING_H
#define __IOKIT_IOINTERRUPTACCOUNTING_H

/*
 * This header contains definitions that will be needed by userspace clients of the interrupt accounting
 * mechanisms.
 */

#define IA_INDEX_MAX (255)
#define IA_INDEX_MASK (0xFFULL)
#define IA_STATISTIC_INDEX_SHIFT (0ULL)
#define IA_INTERRUPT_INDEX_SHIFT (16ULL)

/*
 * For the moment, the indices aren't preprocessor visible, so any changes to this code will need to be
 * careful to ensure that the defined number of statistics matches (or is greater than) the actual number
 * of statistics, to avoid channel ID collisions... because that would be bad.
 */
#define IA_NUM_INTERRUPT_ACCOUNTING_STATISTICS (10)

/*
 * Channel ID related definitions.  These serve to denote the namespace of interrupt accounting in the
 * context of IOReporter-based clients.  Interrupt accounting distinguishes between interrupts based on
 * the nub the interrupt was registered relative to, and the nub relative interrupt index (i.e, the
 * namespace for interrupt accounting is {nub ID, interrupt index}).  IOReporting already knows about
 * nubs (in the context of IOService), however it has no built in knowledge of interrupt accounting.
 * As a result of this, it is the responsibility of the IOReporting client to request any desired
 * statistics on a per-index basis (i.e, if you want to get the first level interrupt count for all
 * interrupts, you must express an interest in the first level interrupt count statistic for index 0, 1,
 * 2, and so on, to a reasonable maximum).
 */

/*
 * These delimit the channel ID namespace for interrupt accounting.
 */
#define IA_BASE_CHANNEL_ID IOREPORT_MAKEID('I', 'n', 't', 'r', 0, 0, 0, 0) /* First valid channel ID */
#define IA_MAX_CHANNEL_ID IOREPORT_MAKEID('I', 'n', 't', 'r', 0xFF, 0xFF, 0xFF, 0xFF) /* Last valid channel ID */

/*
 * Given a nub-relative interrupt index (an index into the interrupt specifiers), and the index of a
 * interrupt accounting statistic, returns the channel id for that statistic.
 */
#define IA_GET_CHANNEL_ID(interruptIndex, statisticIndex) \
    ((IA_BASE_CHANNEL_ID) + \
    ((interruptIndex % IA_INDEX_MASK) << IA_INTERRUPT_INDEX_SHIFT) + \
    ((statisticIndex % IA_INDEX_MASK) << IA_STATISTIC_INDEX_SHIFT))

/*
 * Extracts the interrupt index, given a channel ID.
 */
#define IA_GET_INTERRUPT_INDEX(channelID) \
    (((channelID - IA_BASE_CHANNEL_ID) >> IA_INTERRUPT_INDEX_SHIFT) % IA_INDEX_MASK)

/*
 * Extracts the statistic index, given a channel ID.
 */
#define IA_GET_STATISTIC_INDEX(channelID) \
    (((channelID - IA_BASE_CHANNEL_ID) >> IA_STATISTIC_INDEX_SHIFT) % IA_INDEX_MASK)

/*
 * This enum defines the basic statistics we gather for each interrupt.  Currently, the information
 * we gather falls into roughly three buckets: interrupt related (counts, times), scheduler related
 * (thread wakeups), and power related (package/cpu state changes).
 *
 * First Level Count: This represents the number of times that this interrupt has fired (more
 *   specifically, the number of times we have run the handler we expect to run in interrupt context).
 *
 * Second Level Count: This represents the number of times we have run any second level handler for
 *   this interrupt (more specifically, the handler we expect to be run in the regular kernel context).
 *
 * First Level Time: This represents the aggregate time spent running the first level handler.  For
 *   some interrupts, this value will be 0, as this is not meant to track time spent running generic
 *   IOKit code for the interrupt (i.e, IOInterruptEventSource code), but instead any custom code run
 *   at the interrupt context (i.e, the filter installed for an IOFilterInterruptEventSource).
 *
 * Second Level CPU Time: This represents the aggregate time spent actually running the second level
 *   handler on the CPU.  As the second level handler may block or be preempted, it is meaningful to
 *   distinguish this from the system time spent handling the interrupt.  As was the case for the
 *   first level handler, this does not attempt to track the time spent running generic IOKit code
 *   (i.e, IOInterruptEventSource code or IOWorkLoop code), but instead attempts to track the time
 *   spent running the handler that was installed.
 *
 * Second Level System Time: This represents the aggregate time spent in the second level handler;
 *   this will include time where the handler was blocked or had been preempted.  This should equate
 *   to the wall time spent handling an interrupt (as long as we don't allow the system to go to
 *   sleep while a second level handler is running).
 *
 * No Thread Wakeups: The number of times that the interrupt did not attempt to wake up a thread
 *   (typically the work loop for the interrupt source is woken up).
 *
 * Total Thread Wakeups: The aggregate number of threads (non-unique) woken up by the interrupt.
 *   If no threads were actually woken up for an interrupt (i.e, the work loop thread was already
 *   runnable), this value will not change.
 *
 * Package Wakeups: The number of times that this interrupt woke up the package (as defined by the
 *   scheduler).
 *
 * CPU Wakeups: The number of times that this interrupt woke up a CPU (forcing it to go through the
 *   reset path).
 *
 * Idle Exits: The number of times that this interrupt forced a CPU out of the idle loop (the CPU
 *   had to exit an idle state to handle the interrupt, but it did not need to go through the reset
 *   path).
 */
enum {
    kInterruptAccountingFirstLevelCountIndex = 0, /* Number of times we invoked the top level handler */
    kInterruptAccountingSecondLevelCountIndex, /* Number of times we invoked the workloop action */
    kInterruptAccountingFirstLevelTimeIndex, /* Time spent in the top level handler, if one was installed */
    kInterruptAccountingSecondLevelCPUTimeIndex, /* CPU time spent in the workloop action */
    kInterruptAccountingSecondLevelSystemTimeIndex, /* System time spent in the workloop action */
    kInterruptAccountingNoThreadWakeupsIndex, /* Number of first level (filter) invocations that did not wake up a thread */
    kInterruptAccountingTotalThreadWakeupsIndex, /* Number of actual thread wakeups caused by this interrupt */
    kInterruptAccountingPackageWakeupsIndex, /* Number of times this interrupt woke up the package */
    kInterruptAccountingCPUWakeupsIndex, /* Number of times this interrupt woke up a CPU */
    kInterruptAccountingIdleExitsIndex, /* Number of times this interrupt forced a CPU out of the idle loop */
    kInterruptAccountingInvalidStatisticIndex /* Sentinel value for checking for a nonsensical index */
};

/*
 * IOReporting group name; exposed publicly for the purpose of getting channels by group
 * name; other strings (subgroup names, statistic names) are not exposed, as we may want
 * to change them in the future.
 */
#define kInterruptAccountingGroupName "Interrupt Statistics (by index)"

#endif /* __IOKIT_IOINTERRUPTACCOUNTING_PRIVATE_H */

                                                                                                                                                                                                                                                                                                                                                                    IOKitKeys.h                                                                                         0100644 0001750 0001750 00000015527 12567450741 032604  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved. 
 *
 * Common symbol definitions for IOKit. 
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOKITKEYS_H
#define _IOKIT_IOKITKEYS_H

// properties found in the registry root
#define kIOKitBuildVersionKey		"IOKitBuildVersion"
#define kIOKitDiagnosticsKey		"IOKitDiagnostics"
	// a dictionary keyed by plane name
#define kIORegistryPlanesKey		"IORegistryPlanes"
#define kIOCatalogueKey			"IOCatalogue"

// registry plane names
#define kIOServicePlane			"IOService"
#define kIOPowerPlane			"IOPower"
#define kIODeviceTreePlane		"IODeviceTree"
#define kIOAudioPlane			"IOAudio"
#define kIOFireWirePlane		"IOFireWire"
#define kIOUSBPlane			"IOUSB"

// registry ID number
#define kIORegistryEntryIDKey		"IORegistryEntryID"

// IOService class name
#define kIOServiceClass			"IOService"

// IOResources class name
#define kIOResourcesClass		"IOResources"

// IOService driver probing property names
#define kIOClassKey			"IOClass"
#define kIOProbeScoreKey		"IOProbeScore"
#define kIOKitDebugKey			"IOKitDebug"

// IOService matching property names
#define kIOProviderClassKey		"IOProviderClass"
#define kIONameMatchKey			"IONameMatch"
#define kIOPropertyMatchKey		"IOPropertyMatch"
#define kIOPathMatchKey			"IOPathMatch"
#define kIOLocationMatchKey		"IOLocationMatch"
#define kIOParentMatchKey		"IOParentMatch"
#define kIOResourceMatchKey		"IOResourceMatch"
#define kIOMatchedServiceCountKey	"IOMatchedServiceCountMatch"

#define kIONameMatchedKey		"IONameMatched"

#define kIOMatchCategoryKey		"IOMatchCategory"
#define kIODefaultMatchCategoryKey	"IODefaultMatchCategory"

// IOService default user client class, for loadable user clients
#define kIOUserClientClassKey		"IOUserClientClass"

// key to find IOMappers
#define kIOMapperIDKey				"IOMapperID"

#define kIOUserClientCrossEndianKey		"IOUserClientCrossEndian"
#define kIOUserClientCrossEndianCompatibleKey	"IOUserClientCrossEndianCompatible"
#define kIOUserClientSharedInstanceKey		"IOUserClientSharedInstance"
// diagnostic string describing the creating task
#define kIOUserClientCreatorKey		"IOUserClientCreator"

// IOService notification types
#define kIOPublishNotification		"IOServicePublish"
#define kIOFirstPublishNotification	"IOServiceFirstPublish"
#define kIOMatchedNotification		"IOServiceMatched"
#define kIOFirstMatchNotification	"IOServiceFirstMatch"
#define kIOTerminatedNotification	"IOServiceTerminate"

// IOService interest notification types
#define kIOGeneralInterest		"IOGeneralInterest"
#define kIOBusyInterest			"IOBusyInterest"
#define kIOAppPowerStateInterest	"IOAppPowerStateInterest"
#define kIOPriorityPowerStateInterest	"IOPriorityPowerStateInterest"

#define kIOPlatformDeviceMessageKey     "IOPlatformDeviceMessage"

// IOService interest notification types
#define kIOCFPlugInTypesKey		"IOCFPlugInTypes"

// properties found in services that implement command pooling
#define kIOCommandPoolSizeKey		"IOCommandPoolSize"		// (OSNumber)

// properties found in services that implement priority
#define kIOMaximumPriorityCountKey	"IOMaximumPriorityCount"	// (OSNumber)

// properties found in services that have transfer constraints
#define kIOMaximumBlockCountReadKey             "IOMaximumBlockCountRead"             // (OSNumber)
#define kIOMaximumBlockCountWriteKey            "IOMaximumBlockCountWrite"            // (OSNumber)
#define kIOMaximumByteCountReadKey              "IOMaximumByteCountRead"              // (OSNumber)
#define kIOMaximumByteCountWriteKey             "IOMaximumByteCountWrite"             // (OSNumber)
#define kIOMaximumSegmentCountReadKey           "IOMaximumSegmentCountRead"           // (OSNumber)
#define kIOMaximumSegmentCountWriteKey          "IOMaximumSegmentCountWrite"          // (OSNumber)
#define kIOMaximumSegmentByteCountReadKey       "IOMaximumSegmentByteCountRead"       // (OSNumber)
#define kIOMaximumSegmentByteCountWriteKey      "IOMaximumSegmentByteCountWrite"      // (OSNumber)
#define kIOMinimumSegmentAlignmentByteCountKey  "IOMinimumSegmentAlignmentByteCount"  // (OSNumber)
#define kIOMaximumSegmentAddressableBitCountKey "IOMaximumSegmentAddressableBitCount" // (OSNumber)

// properties found in services that wish to describe an icon
//
// IOIcon = 
// {
//     CFBundleIdentifier   = "com.example.driver.example";
//     IOBundleResourceFile = "example.icns";
// };
//
// where IOBundleResourceFile is the filename of the resource

#define kIOIconKey               "IOIcon"               // (OSDictionary)
#define kIOBundleResourceFileKey "IOBundleResourceFile" // (OSString)

#define kIOBusBadgeKey           "IOBusBadge"           // (OSDictionary)
#define kIODeviceIconKey         "IODeviceIcon"         // (OSDictionary)

// property of root that describes the machine's serial number as a string
#define kIOPlatformSerialNumberKey	"IOPlatformSerialNumber"	// (OSString)

// property of root that describes the machine's UUID as a string
#define kIOPlatformUUIDKey	"IOPlatformUUID"	// (OSString)

// IODTNVRAM property keys
#define kIONVRAMDeletePropertyKey	"IONVRAM-DELETE-PROPERTY"
#define kIONVRAMSyncNowPropertyKey	"IONVRAM-SYNCNOW-PROPERTY"
#define kIONVRAMActivateCSRConfigPropertyKey	"IONVRAM-ARMCSR-PROPERTY"
#define kIODTNVRAMPanicInfoKey		"aapl,panic-info"

// keys for complex boot information
#define kIOBootDeviceKey          "IOBootDevice"		// dict | array of dicts
#define kIOBootDevicePathKey      "IOBootDevicePath"	// arch-neutral OSString
#define kIOBootDeviceSizeKey      "IOBootDeviceSize"	// OSNumber of bytes

// keys for OS Version information
#define kOSBuildVersionKey		"OS Build Version"

#endif /* ! _IOKIT_IOKITKEYS_H */
                                                                                                                                                                         IOKitLib.h                                                                                          0100644 0001750 0001750 00000224721 12566177313 032375  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * HISTORY
 *
 */

/*
 * IOKit user library
 */

#ifndef _IOKIT_IOKITLIB_H
#define _IOKIT_IOKITLIB_H

#ifdef KERNEL
#error This file is not for kernel use
#endif

#include <sys/cdefs.h>
#include <sys/types.h>

#include <mach/mach_types.h>
#include <mach/mach_init.h>

#include <CoreFoundation/CFBase.h>
#include <CoreFoundation/CFDictionary.h>
#include <CoreFoundation/CFRunLoop.h>

#include <IOKit/IOTypes.h>
#include <IOKit/IOKitKeys.h>

#include <IOKit/OSMessageNotification.h>

#include <AvailabilityMacros.h>

#include <dispatch/dispatch.h>

__BEGIN_DECLS

/*! @header IOKitLib
IOKitLib implements non-kernel task access to common IOKit object types - IORegistryEntry, IOService, IOIterator etc. These functions are generic - families may provide API that is more specific.<br>
IOKitLib represents IOKit objects outside the kernel with the types io_object_t, io_registry_entry_t, io_service_t, & io_connect_t. Function names usually begin with the type of object they are compatible with - eg. IOObjectRelease can be used with any io_object_t. Inside the kernel, the c++ class hierarchy allows the subclasses of each object type to receive the same requests from user level clients, for example in the kernel, IOService is a subclass of IORegistryEntry, which means any of the IORegistryEntryXXX functions in IOKitLib may be used with io_service_t's as well as io_registry_t's. There are functions available to introspect the class of the kernel object which any io_object_t et al. represents.
IOKit objects returned by all functions should be released with IOObjectRelease.
*/
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

typedef struct IONotificationPort * IONotificationPortRef;


/*! @typedef IOServiceMatchingCallback
    @abstract Callback function to be notified of IOService publication.
    @param refcon The refcon passed when the notification was installed.
    @param iterator The notification iterator which now has new objects.
*/
typedef void
(*IOServiceMatchingCallback)(
	void *			refcon,
	io_iterator_t		iterator );

/*! @typedef IOServiceInterestCallback
    @abstract Callback function to be notified of changes in state of an IOService.
    @param refcon The refcon passed when the notification was installed.
    @param service The IOService whose state has changed.
    @param messageType A messageType enum, defined by IOKit/IOMessage.h or by the IOService's family.
    @param messageArgument An argument for the message, dependent on the messageType.  If the message data is larger than sizeof(void*), then messageArgument contains a pointer to the message data; otherwise, messageArgument contains the message data.
*/

typedef void
(*IOServiceInterestCallback)(
	void *			refcon,
	io_service_t		service,
	uint32_t		messageType,
	void *			messageArgument );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @const kIOMasterPortDefault
    @abstract The default mach port used to initiate communication with IOKit.
    @discussion When specifying a master port to IOKit functions, the NULL argument indicates "use the default". This is a synonym for NULL, if you'd rather use a named constant.
*/

extern
const mach_port_t kIOMasterPortDefault;

/*! @function IOMasterPort
    @abstract Returns the mach port used to initiate communication with IOKit.
    @discussion Functions that don't specify an existing object require the IOKit master port to be passed. This function obtains that port.
    @param bootstrapPort Pass MACH_PORT_NULL for the default.
    @param masterPort The master port is returned.
    @result A kern_return_t error code. */

kern_return_t
IOMasterPort( mach_port_t	bootstrapPort,
	      mach_port_t *	masterPort );


/*! @function IONotificationPortCreate
    @abstract Creates and returns a notification object for receiving IOKit notifications of new devices or state changes.
    @discussion Creates the notification object to receive notifications from IOKit of new device arrivals or state changes. The notification object can be supply a CFRunLoopSource, or mach_port_t to be used to listen for events.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @result A reference to the notification object. */

IONotificationPortRef
IONotificationPortCreate(
	mach_port_t		masterPort );

/*! @function IONotificationPortDestroy
    @abstract Destroys a notification object created with IONotificationPortCreate.
                Also destroys any mach_port's or CFRunLoopSources obatined from 
                <code>@link IONotificationPortGetRunLoopSource @/link</code>
                or <code>@link IONotificationPortGetMachPort @/link</code>
    @param notify A reference to the notification object. */

void
IONotificationPortDestroy(
	IONotificationPortRef	notify );

/*! @function IONotificationPortGetRunLoopSource
    @abstract Returns a CFRunLoopSource to be used to listen for notifications.
    @discussion A notification object may deliver notifications to a CFRunLoop 
                by adding the run loop source returned by this function to the run loop.

                The caller should not release this CFRunLoopSource. Just call 
                <code>@link IONotificationPortDestroy @/link</code> to dispose of the
                IONotificationPortRef and the CFRunLoopSource when done.
    @param notify The notification object.
    @result A CFRunLoopSourceRef for the notification object. */

CFRunLoopSourceRef
IONotificationPortGetRunLoopSource(
	IONotificationPortRef	notify );

/*! @function IONotificationPortGetMachPort
    @abstract Returns a mach_port to be used to listen for notifications.
    @discussion A notification object may deliver notifications to a mach messaging client 
                if they listen for messages on the port obtained from this function. 
                Callbacks associated with the notifications may be delivered by calling 
                IODispatchCalloutFromMessage with messages received.
                
                The caller should not release this mach_port_t. Just call 
                <code>@link IONotificationPortDestroy @/link</code> to dispose of the
                mach_port_t and IONotificationPortRef when done.
    @param notify The notification object.
    @result A mach_port for the notification object. */

mach_port_t
IONotificationPortGetMachPort(
	IONotificationPortRef	notify );

/*! @function IONotificationPortSetDispatchQueue
    @abstract Sets a dispatch queue to be used to listen for notifications.
    @discussion A notification object may deliver notifications to a dispatch client.
    @param notify The notification object.
    @param queue A dispatch queue. */

void
IONotificationPortSetDispatchQueue(
	IONotificationPortRef notify, dispatch_queue_t queue )
__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_4_3);

/*! @function IODispatchCalloutFromMessage
    @abstract Dispatches callback notifications from a mach message.
    @discussion A notification object may deliver notifications to a mach messaging client, 
                which should call this function to generate the callbacks associated with the notifications arriving on the port.
    @param unused Not used, set to zero.
    @param msg A pointer to the message received.
    @param reference Pass the IONotificationPortRef for the object. */

void
IODispatchCalloutFromMessage(
        void 			*unused,
        mach_msg_header_t	*msg,
        void			*reference );

/*! @function IOCreateReceivePort
    @abstract Creates and returns a mach port suitable for receiving IOKit messages of the specified type.
    @discussion In the future IOKit may use specialized messages and ports
    instead of the standard ports created by mach_port_allocate(). Use this
    function instead of mach_port_allocate() to ensure compatibility with future
    revisions of IOKit.
    @param msgType Type of message to be sent to this port
    (kOSNotificationMessageID or kOSAsyncCompleteMessageID)
    @param recvPort The created port is returned.
    @result A kern_return_t error code. */

kern_return_t
IOCreateReceivePort( uint32_t msgType, mach_port_t * recvPort );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IOObject
 */

/*! @function IOObjectRelease
    @abstract Releases an object handle previously returned by IOKitLib.
    @discussion All objects returned by IOKitLib should be released with this function when access to them is no longer needed. Using the object after it has been released may or may not return an error, depending on how many references the task has to the same object in the kernel.
    @param object The IOKit object to release.
    @result A kern_return_t error code. */

kern_return_t
IOObjectRelease(
	io_object_t	object );

/*! @function IOObjectRetain
    @abstract Retains an object handle previously returned by IOKitLib.
    @discussion Gives the caller an additional reference to an existing object handle previously returned by IOKitLib.
    @param object The IOKit object to retain.
    @result A kern_return_t error code. */

kern_return_t
IOObjectRetain(
	io_object_t	object );

/*! @function IOObjectGetClass
    @abstract Return the class name of an IOKit object.
    @discussion This function uses the OSMetaClass system in the kernel to derive the name of the class the object is an instance of.
    @param object The IOKit object.
    @param className Caller allocated buffer to receive the name string.
    @result A kern_return_t error code. */

kern_return_t
IOObjectGetClass(
	io_object_t	object,
	io_name_t	className );
	
/*! @function IOObjectCopyClass
    @abstract Return the class name of an IOKit object.
	@discussion This function does the same thing as IOObjectGetClass, but returns the result as a CFStringRef.
	@param object The IOKit object.
	@result The resulting CFStringRef. This should be released by the caller. If a valid object is not passed in, then NULL is returned.*/
	
CFStringRef 
IOObjectCopyClass(io_object_t object)
AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

/*! @function IOObjectCopySuperclassForClass
    @abstract Return the superclass name of the given class.
    @discussion This function uses the OSMetaClass system in the kernel to derive the name of the superclass of the class.
	@param classname The name of the class as a CFString.
	@result The resulting CFStringRef. This should be released by the caller. If there is no superclass, or a valid class name is not passed in, then NULL is returned.*/

CFStringRef 
IOObjectCopySuperclassForClass(CFStringRef classname)
AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

/*! @function IOObjectCopyBundleIdentifierForClass
    @abstract Return the bundle identifier of the given class.
	@discussion This function uses the OSMetaClass system in the kernel to derive the name of the kmod, which is the same as the bundle identifier.
	@param classname The name of the class as a CFString.
	@result The resulting CFStringRef. This should be released by the caller. If a valid class name is not passed in, then NULL is returned.*/

CFStringRef 
IOObjectCopyBundleIdentifierForClass(CFStringRef classname)
AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;

/*! @function IOObjectConformsTo
    @abstract Performs an OSDynamicCast operation on an IOKit object.
    @discussion This function uses the OSMetaClass system in the kernel to determine if the object will dynamic cast to a class, specified as a C-string. In other words, if the object is of that class or a subclass.
    @param object An IOKit object.
    @param className The name of the class, as a C-string.
    @result If the object handle is valid, and represents an object in the kernel that dynamic casts to the class true is returned, otherwise false. */

boolean_t
IOObjectConformsTo(
	io_object_t	object,
	const io_name_t	className );

/*! @function IOObjectIsEqualTo
    @abstract Checks two object handles to see if they represent the same kernel object.
    @discussion If two object handles are returned by IOKitLib functions, this function will compare them to see if they represent the same kernel object.
    @param object An IOKit object.
    @param anObject Another IOKit object.
    @result If both object handles are valid, and represent the same object in the kernel true is returned, otherwise false. */

boolean_t
IOObjectIsEqualTo(
	io_object_t	object,
	io_object_t	anObject );

/*! @function IOObjectGetKernelRetainCount
    @abstract Returns kernel retain count of an IOKit object.
    @discussion This function may be used in diagnostics to determine the current retain count of the kernel object at the kernel level.
    @param object An IOKit object.
    @result If the object handle is valid, the kernel objects retain count is returned, otherwise zero is returned. */

uint32_t
IOObjectGetKernelRetainCount(
	io_object_t	object )
AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;

/*! @function IOObjectGetUserRetainCount
    @abstract Returns the retain count for the current process of an IOKit object.
    @discussion This function may be used in diagnostics to determine the current retain count for the calling process of the kernel object.
    @param object An IOKit object.
    @result If the object handle is valid, the objects user retain count is returned, otherwise zero is returned. */

uint32_t
IOObjectGetUserRetainCount(
	io_object_t	object )
AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;

/*! @function IOObjectGetRetainCount
    @abstract Returns kernel retain count of an IOKit object. Identical to IOObjectGetKernelRetainCount() but available prior to Mac OS 10.6.
    @discussion This function may be used in diagnostics to determine the current retain count of the kernel object at the kernel level.
    @param object An IOKit object.
    @result If the object handle is valid, the kernel objects retain count is returned, otherwise zero is returned. */

uint32_t
IOObjectGetRetainCount(
	io_object_t	object );


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IOIterator, subclass of IOObject
 */

/*! @function IOIteratorNext
    @abstract Returns the next object in an iteration.
    @discussion This function returns the next object in an iteration, or zero if no more remain or the iterator is invalid.
    @param iterator An IOKit iterator handle.
    @result If the iterator handle is valid, the next element in the iteration is returned, otherwise zero is returned. The element should be released by the caller when it is finished. */

io_object_t
IOIteratorNext(
	io_iterator_t	iterator );

/*! @function IOIteratorReset
    @abstract Resets an iteration back to the beginning.
    @discussion If an iterator is invalid, or if the caller wants to start over, IOIteratorReset will set the iteration back to the beginning.
    @param iterator An IOKit iterator handle. */

void
IOIteratorReset(
	io_iterator_t	iterator );

/*! @function IOIteratorIsValid
    @abstract Checks an iterator is still valid.
    @discussion Some iterators will be made invalid if changes are made to the structure they are iterating over. This function checks the iterator is still valid and should be called when IOIteratorNext returns zero. An invalid iterator can be reset and the iteration restarted.
    @param iterator An IOKit iterator handle.
    @result True if the iterator handle is valid, otherwise false is returned. */

boolean_t
IOIteratorIsValid(
	io_iterator_t	iterator );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IOService, subclass of IORegistryEntry
 */

/*!
    @function IOServiceGetMatchingService
    @abstract Look up a registered IOService object that matches a matching dictionary.
    @discussion This is the preferred method of finding IOService objects currently registered by IOKit (that is, objects that have had their registerService() methods invoked). To find IOService objects that aren't yet registered, use an iterator as created by IORegistryEntryCreateIterator(). IOServiceAddMatchingNotification can also supply this information and install a notification of new IOServices. The matching information used in the matching dictionary may vary depending on the class of service being looked up.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param matching A CF dictionary containing matching information, of which one reference is always consumed by this function (Note prior to the Tiger release there was a small chance that the dictionary might not be released if there was an error attempting to serialize the dictionary). IOKitLib can construct matching dictionaries for common criteria with helper functions such as IOServiceMatching, IOServiceNameMatching, IOBSDNameMatching.
    @result The first service matched is returned on success. The service must be released by the caller.
  */

io_service_t
IOServiceGetMatchingService(
	mach_port_t	masterPort,
	CFDictionaryRef	matching CF_RELEASES_ARGUMENT);

/*! @function IOServiceGetMatchingServices
    @abstract Look up registered IOService objects that match a matching dictionary.
    @discussion This is the preferred method of finding IOService objects currently registered by IOKit (that is, objects that have had their registerService() methods invoked). To find IOService objects that aren't yet registered, use an iterator as created by IORegistryEntryCreateIterator(). IOServiceAddMatchingNotification can also supply this information and install a notification of new IOServices. The matching information used in the matching dictionary may vary depending on the class of service being looked up.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param matching A CF dictionary containing matching information, of which one reference is always consumed by this function (Note prior to the Tiger release there was a small chance that the dictionary might not be released if there was an error attempting to serialize the dictionary). IOKitLib can construct matching dictionaries for common criteria with helper functions such as IOServiceMatching, IOServiceNameMatching, IOBSDNameMatching.
    @param existing An iterator handle is returned on success, and should be released by the caller when the iteration is finished.
    @result A kern_return_t error code. */

kern_return_t
IOServiceGetMatchingServices(
	mach_port_t	masterPort,
	CFDictionaryRef	matching CF_RELEASES_ARGUMENT,
	io_iterator_t * existing );


kern_return_t
IOServiceAddNotification(
	mach_port_t	masterPort,
	const io_name_t	notificationType,
	CFDictionaryRef	matching,
	mach_port_t	wakePort,
	uintptr_t	reference,
	io_iterator_t *	notification )  DEPRECATED_ATTRIBUTE;

/*! @function IOServiceAddMatchingNotification
    @abstract Look up registered IOService objects that match a matching dictionary, and install a notification request of new IOServices that match.
    @discussion This is the preferred method of finding IOService objects that may arrive at any time. The type of notification specifies the state change the caller is interested in, on IOService's that match the match dictionary. Notification types are identified by name, and are defined in IOKitKeys.h. The matching information used in the matching dictionary may vary depending on the class of service being looked up.
    @param notifyPort A IONotificationPortRef object that controls how messages will be sent when the armed notification is fired. When the notification is delivered, the io_iterator_t representing the notification should be iterated through to pick up all outstanding objects. When the iteration is finished the notification is rearmed. See IONotificationPortCreate.
    @param notificationType A notification type from IOKitKeys.h
<br>	kIOPublishNotification Delivered when an IOService is registered.
<br>	kIOFirstPublishNotification Delivered when an IOService is registered, but only once per IOService instance. Some IOService's may be reregistered when their state is changed.
<br>	kIOMatchedNotification Delivered when an IOService has had all matching drivers in the kernel probed and started.
<br>	kIOFirstMatchNotification Delivered when an IOService has had all matching drivers in the kernel probed and started, but only once per IOService instance. Some IOService's may be reregistered when their state is changed.
<br>	kIOTerminatedNotification Delivered after an IOService has been terminated.
    @param matching A CF dictionary containing matching information, of which one reference is always consumed by this function (Note prior to the Tiger release there was a small chance that the dictionary might not be released if there was an error attempting to serialize the dictionary). IOKitLib can construct matching dictionaries for common criteria with helper functions such as IOServiceMatching, IOServiceNameMatching, IOBSDNameMatching.
    @param callback A callback function called when the notification fires.
    @param refCon A reference constant for the callbacks use.
    @param notification An iterator handle is returned on success, and should be released by the caller when the notification is to be destroyed. The notification is armed when the iterator is emptied by calls to IOIteratorNext - when no more objects are returned, the notification is armed. Note the notification is not armed when first created.
    @result A kern_return_t error code. */

kern_return_t
IOServiceAddMatchingNotification(
	IONotificationPortRef	notifyPort,
	const io_name_t		notificationType,
	CFDictionaryRef		matching CF_RELEASES_ARGUMENT,
        IOServiceMatchingCallback callback,
        void *			refCon,
	io_iterator_t * 	notification );

/*! @function IOServiceAddInterestNotification
    @abstract Register for notification of state changes in an IOService.
    @discussion IOService objects deliver notifications of their state changes to their clients via the IOService::messageClients API, and to other interested parties including callers of this function. Message types are defined IOKit/IOMessage.h.
    @param notifyPort A IONotificationPortRef object that controls how messages will be sent when the notification is fired. See IONotificationPortCreate.
    @param interestType A notification type from IOKitKeys.h
<br>	kIOGeneralInterest General state changes delivered via the IOService::messageClients API.
<br>	kIOBusyInterest Delivered when the IOService changes its busy state to or from zero. The message argument contains the new busy state causing the notification.
    @param callback A callback function called when the notification fires, with messageType and messageArgument for the state change.
    @param refCon A reference constant for the callbacks use.
    @param notification An object handle is returned on success, and should be released by the caller when the notification is to be destroyed.
    @result A kern_return_t error code. */

kern_return_t
IOServiceAddInterestNotification(
	IONotificationPortRef	notifyPort,
        io_service_t		service,
	const io_name_t 	interestType,
        IOServiceInterestCallback callback,
        void *			refCon,
        io_object_t *		notification );

/*! @function IOServiceMatchPropertyTable
    @abstract Match an IOService objects with matching dictionary.
    @discussion This function calls the matching method of an IOService object and returns the boolean result.
    @param service The IOService object to match.
    @param matching A CF dictionary containing matching information. IOKitLib can construct matching dictionaries for common criteria with helper functions such as IOServiceMatching, IOServiceNameMatching, IOBSDNameMatching.
    @param matches The boolean result is returned.
    @result A kern_return_t error code. */

kern_return_t
IOServiceMatchPropertyTable(
        io_service_t	service,
        CFDictionaryRef matching,
        boolean_t *	matches );

/*! @function IOServiceGetBusyState
    @abstract Returns the busyState of an IOService.
    @discussion Many activities in IOService are asynchronous. When registration, matching, or termination is in progress on an IOService, its busyState is increased by one. Change in busyState to or from zero also changes the IOService's provider's busyState by one, which means that an IOService is marked busy when any of the above activities is ocurring on it or any of its clients.
    @param service The IOService whose busyState to return.
    @param busyState The busyState count is returned.
    @result A kern_return_t error code. */

kern_return_t
IOServiceGetBusyState(
	io_service_t    service,
	uint32_t *	busyState );

/*! @function IOServiceWaitQuiet
    @abstract Wait for an IOService's busyState to be zero.
    @discussion Blocks the caller until an IOService is non busy, see IOServiceGetBusyState.
    @param service The IOService wait on.
    @param waitTime Specifies a maximum time to wait.
    @result Returns an error code if mach synchronization primitives fail, kIOReturnTimeout, or kIOReturnSuccess. */

kern_return_t
IOServiceWaitQuiet(
	io_service_t      service,
	mach_timespec_t * waitTime );

/*! @function IOKitGetBusyState
    @abstract Returns the busyState of all IOServices.
    @discussion Many activities in IOService are asynchronous. When registration, matching, or termination is in progress on an IOService, its busyState is increased by one. Change in busyState to or from zero also changes the IOService's provider's busyState by one, which means that an IOService is marked busy when any of the above activities is ocurring on it or any of its clients. IOKitGetBusyState returns the busy state of the root of the service plane which reflects the busy state of all IOServices.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param busyState The busyState count is returned.
    @result A kern_return_t error code. */

kern_return_t
IOKitGetBusyState(
	mach_port_t	masterPort,
	uint32_t *	busyState );

/*! @function IOKitWaitQuiet
    @abstract Wait for a all IOServices' busyState to be zero.
    @discussion Blocks the caller until all IOServices are non busy, see IOKitGetBusyState.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param waitTime Specifies a maximum time to wait.
    @result Returns an error code if mach synchronization primitives fail, kIOReturnTimeout, or kIOReturnSuccess. */

kern_return_t
IOKitWaitQuiet(
	mach_port_t	  masterPort,
	mach_timespec_t * waitTime );

/*! @function IOServiceOpen
    @abstract A request to create a connection to an IOService.
    @discussion A non kernel client may request a connection be opened via the IOServiceOpen() library function, which will call IOService::newUserClient in the kernel. The rules & capabilities of user level clients are family dependent, the default IOService implementation returns kIOReturnUnsupported.
    @param service The IOService object to open a connection to, usually obtained via the IOServiceGetMatchingServices or IOServiceAddNotification APIs.
    @param owningTask The mach task requesting the connection.
    @param type A constant specifying the type of connection to be created,  interpreted only by the IOService's family.
    @param connect An io_connect_t handle is returned on success, to be used with the IOConnectXXX APIs. It should be destroyed with IOServiceClose().
    @result A return code generated by IOService::newUserClient. */

kern_return_t
IOServiceOpen(
	io_service_t    service,
	task_port_t	owningTask,
	uint32_t	type,
	io_connect_t  *	connect );

/*! @function IOServiceRequestProbe
    @abstract A request to rescan a bus for device changes.
    @discussion A non kernel client may request a bus or controller rescan for added or removed devices, if the bus family does automatically notice such changes. For example, SCSI bus controllers do not notice device changes. The implementation of this routine is family dependent, and the default IOService implementation returns kIOReturnUnsupported.
    @param service The IOService object to request a rescan, usually obtained via the IOServiceGetMatchingServices or IOServiceAddNotification APIs.
    @param options An options mask, interpreted only by the IOService's family.
    @result A return code generated by IOService::requestProbe. */

kern_return_t
IOServiceRequestProbe(
	io_service_t    service,
	uint32_t	options );

// options for IOServiceAuthorize()
enum {
    kIOServiceInteractionAllowed	= 0x00000001
};

/*! @function IOServiceAuthorize
    @abstract Authorize access to an IOService.
    @discussion Determine whether this application is authorized to invoke IOServiceOpen() for a given IOService, either by confirming that it has been previously authorized by the user, or by soliciting the console user.
    @param service The IOService object to be authorized, usually obtained via the IOServiceGetMatchingServices or IOServiceAddNotification APIs.
    @param options kIOServiceInteractionAllowed may be set to permit user interaction, if required.
    @result kIOReturnSuccess if the IOService is authorized, kIOReturnNotPermitted if the IOService is not authorized. */

kern_return_t
IOServiceAuthorize(
	io_service_t	service,
	uint32_t	options );

int
IOServiceOpenAsFileDescriptor(
	io_service_t	service,
	int		oflag );

/* * * * * * * * * * * * * * *ff * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IOService connection
 */

/*! @function IOServiceClose
    @abstract Close a connection to an IOService and destroy the connect handle.
    @discussion A connection created with the IOServiceOpen should be closed when the connection is no longer to be used with IOServiceClose.
    @param connect The connect handle created by IOServiceOpen. It will be destroyed by this function, and should not be released with IOObjectRelease.
    @result A kern_return_t error code. */

kern_return_t
IOServiceClose(
	io_connect_t	connect );

/*! @function IOConnectAddRef
    @abstract Adds a reference to the connect handle.
    @discussion Adds a reference to the connect handle.
    @param connect The connect handle created by IOServiceOpen.
    @result A kern_return_t error code. */

kern_return_t
IOConnectAddRef(
	io_connect_t	connect );

/*! @function IOConnectRelease
    @abstract Remove a reference to the connect handle.
    @discussion Removes a reference to the connect handle.  If the last reference is removed an implicit IOServiceClose is performed.
    @param connect The connect handle created by IOServiceOpen.
    @result A kern_return_t error code. */

kern_return_t
IOConnectRelease(
	io_connect_t	connect );

/*! @function IOConnectGetService
    @abstract Returns the IOService a connect handle was opened on.
    @discussion Finds the service object a connection was opened on.
    @param connect The connect handle created by IOServiceOpen.
    @param service On succes, the service handle the connection was opened on, which should be released with IOObjectRelease.
    @result A kern_return_t error code. */

kern_return_t
IOConnectGetService(
	io_connect_t	connect,
	io_service_t  *	service );

/*! @function IOConnectSetNotificationPort
    @abstract Set a port to receive family specific notifications.
    @discussion This is a generic method to pass a mach port send right to be be used by family specific notifications. 
    @param connect The connect handle created by IOServiceOpen.
    @param type The type of notification requested, not interpreted by IOKit and family defined.
    @param port The port to which to send notifications.
    @param reference Some families may support passing a reference parameter for the callers use with the notification.
    @result A kern_return_t error code. */

kern_return_t
IOConnectSetNotificationPort(
	io_connect_t	connect,
	uint32_t	type,
	mach_port_t	port,
	uintptr_t	reference );

/*! @function IOConnectMapMemory
    @abstract Map hardware or shared memory into the caller's task.
    @discussion This is a generic method to create a mapping in the callers task. The family will interpret the type parameter to determine what sort of mapping is being requested. Cache modes and placed mappings may be requested by the caller.
    @param connect The connect handle created by IOServiceOpen.
    @param memoryType What is being requested to be mapped, not interpreted by IOKit and family defined. The family may support physical hardware or shared memory mappings.
    @param intoTask The task port for the task in which to create the mapping. This may be different to the task which the opened the connection.
    @param atAddress An in/out parameter - if the kIOMapAnywhere option is not set, the caller should pass the address where it requests the mapping be created, otherwise nothing need to set on input. The address of the mapping created is passed back on sucess.
    @param ofSize The size of the mapping created is passed back on success.
    @result A kern_return_t error code. */

#if !__LP64__ || defined(IOCONNECT_MAPMEMORY_10_6)

kern_return_t
IOConnectMapMemory(
	io_connect_t	connect,
	uint32_t	memoryType,
	task_port_t	intoTask,
	vm_address_t	*atAddress,
	vm_size_t	*ofSize,
	IOOptionBits	 options );

#else

kern_return_t
IOConnectMapMemory(
	 io_connect_t		connect,
	 uint32_t		memoryType,
	 task_port_t		intoTask,
	 mach_vm_address_t	*atAddress,
	 mach_vm_size_t		*ofSize,
	 IOOptionBits		 options );

#endif /* !__LP64__ || defined(IOCONNECT_MAPMEMORY_10_6) */


/*! @function IOConnectMapMemory64
    @abstract Map hardware or shared memory into the caller's task.
    @discussion This is a generic method to create a mapping in the callers task. The family will interpret the type parameter to determine what sort of mapping is being requested. Cache modes and placed mappings may be requested by the caller.
    @param connect The connect handle created by IOServiceOpen.
    @param memoryType What is being requested to be mapped, not interpreted by IOKit and family defined. The family may support physical hardware or shared memory mappings.
    @param intoTask The task port for the task in which to create the mapping. This may be different to the task which the opened the connection.
    @param atAddress An in/out parameter - if the kIOMapAnywhere option is not set, the caller should pass the address where it requests the mapping be created, otherwise nothing need to set on input. The address of the mapping created is passed back on sucess.
    @param ofSize The size of the mapping created is passed back on success.
    @result A kern_return_t error code. */

kern_return_t IOConnectMapMemory64(
	 io_connect_t		connect,
	 uint32_t		memoryType,
	 task_port_t		intoTask,
	 mach_vm_address_t	*atAddress,
	 mach_vm_size_t		*ofSize,
	 IOOptionBits		 options );

/*! @function IOConnectUnmapMemory
    @abstract Remove a mapping made with IOConnectMapMemory.
    @discussion This is a generic method to remove a mapping in the callers task.
    @param connect The connect handle created by IOServiceOpen.
    @param memoryType The memory type originally requested in IOConnectMapMemory.
    @param fromTask The task port for the task in which to remove the mapping. This may be different to the task which the opened the connection.
    @param atAddress The address of the mapping to be removed.
    @result A kern_return_t error code. */

#if !__LP64__ || defined(IOCONNECT_MAPMEMORY_10_6)

kern_return_t
IOConnectUnmapMemory(
	io_connect_t	connect,
	uint32_t	memoryType,
	task_port_t	fromTask,
	vm_address_t	atAddress );

#else

kern_return_t
IOConnectUnmapMemory(
	io_connect_t	connect,
	uint32_t	memoryType,
	task_port_t	fromTask,
	mach_vm_address_t	atAddress );


#endif /* !__LP64__ || defined(IOCONNECT_MAPMEMORY_10_6) */

/*! @function IOConnectUnmapMemory64
    @abstract Remove a mapping made with IOConnectMapMemory64.
    @discussion This is a generic method to remove a mapping in the callers task.
    @param connect The connect handle created by IOServiceOpen.
    @param memoryType The memory type originally requested in IOConnectMapMemory.
    @param fromTask The task port for the task in which to remove the mapping. This may be different to the task which the opened the connection.
    @param atAddress The address of the mapping to be removed.
    @result A kern_return_t error code. */

kern_return_t IOConnectUnmapMemory64(
	io_connect_t		connect,
	 uint32_t		memoryType,
	 task_port_t		fromTask,
	 mach_vm_address_t	atAddress );


/*! @function IOConnectSetCFProperties
    @abstract Set CF container based properties on a connection.
    @discussion This is a generic method to pass a CF container of properties to the connection. The properties are interpreted by the family and commonly represent configuration settings, but may be interpreted as anything.
    @param connect The connect handle created by IOServiceOpen.
    @param properties A CF container - commonly a CFDictionary but this is not enforced. The container should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    @result A kern_return_t error code returned by the family. */

kern_return_t
IOConnectSetCFProperties(
	io_connect_t	connect,
	CFTypeRef	properties );

/*! @function IOConnectSetCFProperty
    @abstract Set a CF container based property on a connection.
    @discussion This is a generic method to pass a CF property to the connection. The property is interpreted by the family and commonly represent configuration settings, but may be interpreted as anything.
    @param connect The connect handle created by IOServiceOpen.
    @param propertyName The name of the property as a CFString.
    @param property A CF container - should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    @result A kern_return_t error code returned by the object. */

kern_return_t
IOConnectSetCFProperty(
	io_connect_t	connect,
        CFStringRef	propertyName,
	CFTypeRef	property );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Combined LP64 & ILP32 Extended IOUserClient::externalMethod

kern_return_t
IOConnectCallMethod(
	mach_port_t	 connection,		// In
	uint32_t	 selector,		// In
	const uint64_t	*input,			// In
	uint32_t	 inputCnt,		// In
	const void      *inputStruct,		// In
	size_t		 inputStructCnt,	// In
	uint64_t	*output,		// Out
	uint32_t	*outputCnt,		// In/Out
	void		*outputStruct,		// Out
	size_t		*outputStructCnt)	// In/Out
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

kern_return_t
IOConnectCallAsyncMethod(
	mach_port_t	 connection,		// In
	uint32_t	 selector,		// In
	mach_port_t	 wake_port,		// In
	uint64_t	*reference,		// In
	uint32_t	 referenceCnt,		// In
	const uint64_t	*input,			// In
	uint32_t	 inputCnt,		// In
	const void	*inputStruct,		// In
	size_t		 inputStructCnt,	// In
	uint64_t	*output,		// Out
	uint32_t	*outputCnt,		// In/Out
	void		*outputStruct,		// Out
	size_t		*outputStructCnt)	// In/Out
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

kern_return_t
IOConnectCallStructMethod(
	mach_port_t	 connection,		// In
	uint32_t	 selector,		// In
	const void	*inputStruct,		// In
	size_t		 inputStructCnt,	// In
	void		*outputStruct,		// Out
	size_t		*outputStructCnt)	// In/Out
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

kern_return_t
IOConnectCallAsyncStructMethod(
	mach_port_t	 connection,		// In
	uint32_t	 selector,		// In
	mach_port_t	 wake_port,		// In
	uint64_t	*reference,		// In
	uint32_t	 referenceCnt,		// In
	const void	*inputStruct,		// In
	size_t		 inputStructCnt,	// In
	void		*outputStruct,		// Out
	size_t		*outputStructCnt)	// In/Out
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

kern_return_t
IOConnectCallScalarMethod(
	mach_port_t	 connection,		// In
	uint32_t	 selector,		// In
	const uint64_t	*input,			// In
	uint32_t	 inputCnt,		// In
	uint64_t	*output,		// Out
	uint32_t	*outputCnt)		// In/Out
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

kern_return_t
IOConnectCallAsyncScalarMethod(
	mach_port_t	 connection,		// In
	uint32_t	 selector,		// In
	mach_port_t	 wake_port,		// In
	uint64_t	*reference,		// In
	uint32_t	 referenceCnt,		// In
	const uint64_t	*input,			// In
	uint32_t	 inputCnt,		// In
	uint64_t	*output,		// Out
	uint32_t	*outputCnt)		// In/Out
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

kern_return_t
IOConnectTrap0(io_connect_t	connect,
	       uint32_t		index );

kern_return_t
IOConnectTrap1(io_connect_t	connect,
	       uint32_t		index,
	       uintptr_t	p1 );

kern_return_t
IOConnectTrap2(io_connect_t	connect,
	       uint32_t		index,
	       uintptr_t	p1,
	       uintptr_t	p2);

kern_return_t
IOConnectTrap3(io_connect_t	connect,
	       uint32_t		index,
	       uintptr_t	p1,
	       uintptr_t	p2,
	       uintptr_t	p3);

kern_return_t
IOConnectTrap4(io_connect_t	connect,
	       uint32_t		index,
	       uintptr_t	p1,
	       uintptr_t	p2,
	       uintptr_t	p3,
	       uintptr_t	p4);

kern_return_t
IOConnectTrap5(io_connect_t	connect,
	       uint32_t		index,
	       uintptr_t	p1,
	       uintptr_t	p2,
	       uintptr_t	p3,
	       uintptr_t	p4,
	       uintptr_t	p5);

kern_return_t
IOConnectTrap6(io_connect_t	connect,
	       uint32_t		index,
	       uintptr_t	p1,
	       uintptr_t	p2,
	       uintptr_t	p3,
	       uintptr_t	p4,
	       uintptr_t	p5,
	       uintptr_t	p6);

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @function IOConnectAddClient
    @abstract Inform a connection of a second connection.
    @discussion This is a generic method to inform a family connection of a second connection, and is rarely used.
    @param connect The connect handle created by IOServiceOpen.
    @param client Another connect handle created by IOServiceOpen.
    @result A kern_return_t error code returned by the family. */

kern_return_t
IOConnectAddClient(
	io_connect_t	connect,
	io_connect_t	client );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IORegistry accessors
 */

/*! @function IORegistryGetRootEntry
    @abstract Return a handle to the registry root.
    @discussion This method provides an accessor to the root of the registry for the machine. The root may be passed to a registry iterator when iterating a plane, and contains properties that describe the available planes, and diagnostic information for IOKit.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @result A handle to the IORegistryEntry root instance, to be released with IOObjectRelease by the caller, or MACH_PORT_NULL on failure. */

io_registry_entry_t
IORegistryGetRootEntry(
	mach_port_t	masterPort );

/*! @function IORegistryEntryFromPath
    @abstract Looks up a registry entry by path.
    @discussion This function parses paths to lookup registry entries. The path should begin with '<plane name>:' If there are characters remaining unparsed after an entry has been looked up, this is considered an invalid lookup. Paths are further documented in IORegistryEntry.h
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param path A C-string path.
    @result A handle to the IORegistryEntry witch was found with the path, to be released with IOObjectRelease by the caller, or MACH_PORT_NULL on failure. */

io_registry_entry_t
IORegistryEntryFromPath(
	mach_port_t		masterPort,
	const io_string_t	path );


/*! @function IORegistryEntryFromPathCFString
    @abstract Looks up a registry entry by path.
    @discussion This function parses paths to lookup registry entries. The path should begin with '<plane name>:' If there are characters remaining unparsed after an entry has been looked up, this is considered an invalid lookup. Paths are further documented in IORegistryEntry.h
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param path A CFString path.
    @result A handle to the IORegistryEntry witch was found with the path, to be released with IOObjectRelease by the caller, or MACH_PORT_NULL on failure. */

io_registry_entry_t
IORegistryEntryCopyFromPath(
	mach_port_t	masterPort,
	CFStringRef	path )
#if defined(__MAC_10_11)
__OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_9_0)
#endif
;

// options for IORegistryCreateIterator(), IORegistryEntryCreateIterator, IORegistryEntrySearchCFProperty()
enum {
    kIORegistryIterateRecursively	= 0x00000001,
    kIORegistryIterateParents		= 0x00000002
};

/*! @function IORegistryCreateIterator
    @abstract Create an iterator rooted at the registry root.
    @discussion This method creates an IORegistryIterator in the kernel that is set up with options to iterate children of the registry root entry, and to recurse automatically into entries as they are returned, or only when instructed with calls to IORegistryIteratorEnterEntry. The iterator object keeps track of entries that have been recursed into previously to avoid loops.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param options kIORegistryIterateRecursively may be set to recurse automatically into each entry as it is returned from IOIteratorNext calls on the registry iterator. 
    @param iterator A created iterator handle, to be released by the caller when it has finished with it.
    @result A kern_return_t error code. */

kern_return_t
IORegistryCreateIterator(
	mach_port_t	masterPort,
	const io_name_t	plane,
	IOOptionBits	options,
	io_iterator_t * iterator );

/*! @function IORegistryEntryCreateIterator
    @abstract Create an iterator rooted at a given registry entry.
    @discussion This method creates an IORegistryIterator in the kernel that is set up with options to iterate children or parents of a root entry, and to recurse automatically into entries as they are returned, or only when instructed with calls to IORegistryIteratorEnterEntry. The iterator object keeps track of entries that have been recursed into previously to avoid loops.
    @param entry The root entry to begin the iteration at.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param options kIORegistryIterateRecursively may be set to recurse automatically into each entry as it is returned from IOIteratorNext calls on the registry iterator. kIORegistryIterateParents may be set to iterate the parents of each entry, by default the children are iterated.
    @param iterator A created iterator handle, to be released by the caller when it has finished with it.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryCreateIterator(
	io_registry_entry_t	entry,
	const io_name_t		plane,
	IOOptionBits		options,
	io_iterator_t 	      * iterator );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IORegistryIterator, subclass of IOIterator
 */

/*! @function IORegistryIteratorEnterEntry
    @abstract Recurse into the current entry in the registry iteration.
    @discussion This method makes the current entry, ie. the last entry returned by IOIteratorNext, the root in a new level of recursion.
    @result A kern_return_t error code. */

kern_return_t
IORegistryIteratorEnterEntry(
	io_iterator_t	iterator );

/*! @function IORegistryIteratorExitEntry
    @abstract Exits a level of recursion, restoring the current entry.
    @discussion This method undoes an IORegistryIteratorEnterEntry, restoring the current entry. If there are no more levels of recursion to exit false is returned, otherwise true is returned.
    @result kIOReturnSuccess if a level of recursion was undone, kIOReturnNoDevice if no recursive levels are left in the iteration. */

kern_return_t
IORegistryIteratorExitEntry(
	io_iterator_t	iterator );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * IORegistryEntry, subclass of IOObject
 */

/*! @function IORegistryEntryGetName
    @abstract Returns a C-string name assigned to a registry entry.
    @discussion Registry entries can be named in a particular plane, or globally. This function returns the entry's global name. The global name defaults to the entry's meta class name if it has not been named.
    @param entry The registry entry handle whose name to look up.
    @param name The caller's buffer to receive the name.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetName(
	io_registry_entry_t	entry,
	io_name_t 	        name );

/*! @function IORegistryEntryGetNameInPlane
    @abstract Returns a C-string name assigned to a registry entry, in a specified plane.
    @discussion Registry entries can be named in a particular plane, or globally. This function returns the entry's name in the specified plane or global name if it has not been named in that plane. The global name defaults to the entry's meta class name if it has not been named.
    @param entry The registry entry handle whose name to look up.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param name The caller's buffer to receive the name.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetNameInPlane(
	io_registry_entry_t	entry,
	const io_name_t 	plane,
	io_name_t 	        name );

/*! @function IORegistryEntryGetLocationInPlane
    @abstract Returns a C-string location assigned to a registry entry, in a specified plane.
    @discussion Registry entries can given a location string in a particular plane, or globally. If the entry has had a location set in the specified plane that location string will be returned, otherwise the global location string is returned. If no global location string has been set, an error is returned.
    @param entry The registry entry handle whose name to look up.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param location The caller's buffer to receive the location string.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetLocationInPlane(
	io_registry_entry_t	entry,
	const io_name_t 	plane,
	io_name_t 	        location );

/*! @function IORegistryEntryGetPath
    @abstract Create a path for a registry entry.
    @discussion The path for a registry entry is copied to the caller's buffer. The path describes the entry's attachment in a particular plane, which must be specified. The path begins with the plane name followed by a colon, and then followed by '/' separated path components for each of the entries between the root and the registry entry. An alias may also exist for the entry, and will be returned if available.
    @param entry The registry entry handle whose path to look up.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param path A char buffer allocated by the caller.
    @result IORegistryEntryGetPath will fail if the entry is not attached in the plane, or if the buffer is not large enough to contain the path. */

kern_return_t
IORegistryEntryGetPath(
	io_registry_entry_t	entry,
	const io_name_t         plane,
	io_string_t		path );

/*! @function IORegistryEntryCopyPath
    @abstract Create a path for a registry entry.
    @discussion The path for a registry entry is returned as a CFString The path describes the entry's attachment in a particular plane, which must be specified. The path begins with the plane name followed by a colon, and then followed by '/' separated path components for each of the entries between the root and the registry entry. An alias may also exist for the entry, and will be returned if available.
    @param entry The registry entry handle whose path to look up.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @result An instance of CFString on success, to be released by the caller. IORegistryEntryCopyPath will fail if the entry is not attached in the plane. */

CFStringRef
IORegistryEntryCopyPath(
	io_registry_entry_t	entry,
	const io_name_t         plane)
#if defined(__MAC_10_11)
__OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_9_0)
#endif
;

/*! @function IORegistryEntryGetRegistryEntryID
    @abstract Returns an ID for the registry entry that is global to all tasks.
    @discussion The entry ID returned by IORegistryEntryGetRegistryEntryID can be used to identify a registry entry across all tasks. A registry entry may be looked up by its entryID by creating a matching dictionary with IORegistryEntryIDMatching() to be used with the IOKit matching functions. The ID is valid only until the machine reboots.
    @param entry The registry entry handle whose ID to look up.
    @param entryID The resulting ID.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetRegistryEntryID(
	io_registry_entry_t	entry,
	uint64_t *		entryID );

/*! @function IORegistryEntryCreateCFProperties
    @abstract Create a CF dictionary representation of a registry entry's property table.
    @discussion This function creates an instantaneous snapshot of a registry entry's property table, creating a CFDictionary analogue in the caller's task. Not every object available in the kernel is represented as a CF container; currently OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, OSBoolean are created as their CF counterparts. 
    @param entry The registry entry handle whose property table to copy.
    @param properties A CFDictionary is created and returned the caller on success. The caller should release with CFRelease.
    @param allocator The CF allocator to use when creating the CF containers.
    @param options No options are currently defined.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryCreateCFProperties(
	io_registry_entry_t	entry,
	CFMutableDictionaryRef * properties,
        CFAllocatorRef		allocator,
	IOOptionBits		options );

/*! @function IORegistryEntryCreateCFProperty
    @abstract Create a CF representation of a registry entry's property.
    @discussion This function creates an instantaneous snapshot of a registry entry property, creating a CF container analogue in the caller's task. Not every object available in the kernel is represented as a CF container; currently OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, OSBoolean are created as their CF counterparts. 
    @param entry The registry entry handle whose property to copy.
    @param key A CFString specifying the property name.
    @param allocator The CF allocator to use when creating the CF container.
    @param options No options are currently defined.
    @result A CF container is created and returned the caller on success. The caller should release with CFRelease. */

CFTypeRef
IORegistryEntryCreateCFProperty(
	io_registry_entry_t	entry,
	CFStringRef		key,
        CFAllocatorRef		allocator,
	IOOptionBits		options );

/*! @function IORegistryEntrySearchCFProperty
    @abstract Create a CF representation of a registry entry's property.
    @discussion This function creates an instantaneous snapshot of a registry entry property, creating a CF container analogue in the caller's task. Not every object available in the kernel is represented as a CF container; currently OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, OSBoolean are created as their CF counterparts. 
This function will search for a property, starting first with specified registry entry's property table, then iterating recusively through either the parent registry entries or the child registry entries of this entry. Once the first occurrence is found, it will lookup and return the value of the property, using the same semantics as IORegistryEntryCreateCFProperty. The iteration keeps track of entries that have been recursed into previously to avoid loops.
    @param entry The registry entry at which to start the search.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param key A CFString specifying the property name.
    @param allocator The CF allocator to use when creating the CF container.
    @param options kIORegistryIterateRecursively may be set to recurse automatically into the registry hierarchy. Without this option, this method degenerates into the standard IORegistryEntryCreateCFProperty() call. kIORegistryIterateParents may be set to iterate the parents of the entry, in place of the children.
    @result A CF container is created and returned the caller on success. The caller should release with CFRelease. */

CFTypeRef
IORegistryEntrySearchCFProperty(
	io_registry_entry_t	entry,
	const io_name_t		plane,
	CFStringRef		key,
        CFAllocatorRef		allocator,
	IOOptionBits		options ) CF_RETURNS_RETAINED;

/*  @function IORegistryEntryGetProperty - deprecated,
    use IORegistryEntryCreateCFProperty */

kern_return_t
IORegistryEntryGetProperty(
	io_registry_entry_t	entry,
	const io_name_t		propertyName,
	io_struct_inband_t	buffer,
	uint32_t	      * size );

/*! @function IORegistryEntrySetCFProperties
    @abstract Set CF container based properties in a registry entry.
    @discussion This is a generic method to pass a CF container of properties to an object in the registry. Setting properties in a registry entry is not generally supported, it is more common to support IOConnectSetCFProperties for connection based property setting. The properties are interpreted by the object.
    @param entry The registry entry whose properties to set.
    @param properties A CF container - commonly a CFDictionary but this is not enforced. The container should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    @result A kern_return_t error code returned by the object. */

kern_return_t
IORegistryEntrySetCFProperties(
	io_registry_entry_t	entry,
	CFTypeRef	 	properties );

/*! @function IORegistryEntrySetCFProperty
    @abstract Set a CF container based property in a registry entry.
    @discussion This is a generic method to pass a CF container as a property to an object in the registry. Setting properties in a registry entry is not generally supported, it is more common to support IOConnectSetCFProperty for connection based property setting. The property is interpreted by the object.
    @param entry The registry entry whose property to set.
    @param propertyName The name of the property as a CFString.
    @param property A CF container - should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    @result A kern_return_t error code returned by the object. */

kern_return_t
IORegistryEntrySetCFProperty(
	io_registry_entry_t	entry,
        CFStringRef		propertyName,
	CFTypeRef	 	property );

/*! @function IORegistryEntryGetChildIterator
    @abstract Returns an iterator over an registry entry's child entries in a plane.
    @discussion This method creates an iterator which will return each of a registry entry's child entries in a specified plane.
    @param entry The registry entry whose children to iterate over.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param iterator The created iterator over the children of the entry, on success. The iterator must be released when the iteration is finished.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetChildIterator(
	io_registry_entry_t	entry,
	const io_name_t		plane,
	io_iterator_t	      * iterator );

/*! @function IORegistryEntryGetChildEntry
    @abstract Returns the first child of a registry entry in a plane.
    @discussion This function will return the child which first attached to a registry entry in a plane.
    @param entry The registry entry whose child to look up.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param child The first child of the registry entry, on success. The child must be released by the caller.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetChildEntry(
	io_registry_entry_t	entry,
	const io_name_t		plane,
	io_registry_entry_t   * child );

/*! @function IORegistryEntryGetParentIterator
    @abstract Returns an iterator over an registry entry's parent entries in a plane.
    @discussion This method creates an iterator which will return each of a registry entry's parent entries in a specified plane.
    @param entry The registry entry whose parents to iterate over.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param iterator The created iterator over the parents of the entry, on success. The iterator must be released when the iteration is finished.
    @result A kern_return_t error. */

kern_return_t
IORegistryEntryGetParentIterator(
	io_registry_entry_t	entry,
	const io_name_t		plane,
	io_iterator_t	      * iterator );

/*! @function IORegistryEntryGetParentEntry
    @abstract Returns the first parent of a registry entry in a plane.
    @discussion This function will return the parent to which the registry entry was first attached in a plane.
    @param entry The registry entry whose parent to look up.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @param parent The first parent of the registry entry, on success. The parent must be released by the caller.
    @result A kern_return_t error code. */

kern_return_t
IORegistryEntryGetParentEntry(
	io_registry_entry_t	entry,
	const io_name_t		plane,
	io_registry_entry_t   * parent );

/*! @function IORegistryEntryInPlane
    @abstract Determines if the registry entry is attached in a plane.
    @discussion This method determines if the entry is attached in a plane to any other entry.
    @param entry The registry entry.
    @param plane The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    @result If the entry has a parent in the plane, true is returned, otherwise false is returned. */

boolean_t
IORegistryEntryInPlane(
	io_registry_entry_t	entry,
	const io_name_t		plane );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * Matching dictionary creation helpers
 */

/*! @function IOServiceMatching
    @abstract Create a matching dictionary that specifies an IOService class match.
    @discussion A very common matching criteria for IOService is based on its class. IOServiceMatching will create a matching dictionary that specifies any IOService of a class, or its subclasses. The class is specified by C-string name.
    @param name The class name, as a const C-string. Class matching is successful on IOService's of this class or any subclass.
    @result The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller. */

CFMutableDictionaryRef
IOServiceMatching(
	const char *	name ) CF_RETURNS_RETAINED;

/*! @function IOServiceNameMatching
    @abstract Create a matching dictionary that specifies an IOService name match.
    @discussion A common matching criteria for IOService is based on its name. IOServiceNameMatching will create a matching dictionary that specifies an IOService with a given name. Some IOServices created from the device tree will perform name matching on the standard compatible, name, model properties.
    @param name The IOService name, as a const C-string.
    @result The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller. */

CFMutableDictionaryRef
IOServiceNameMatching(
	const char *	name ) CF_RETURNS_RETAINED;

/*! @function IOBSDNameMatching
    @abstract Create a matching dictionary that specifies an IOService match based on BSD device name.
    @discussion IOServices that represent BSD devices have an associated BSD name. This function creates a matching dictionary that will match IOService's with a given BSD name.
    @param masterPort The master port obtained from IOMasterPort(). Pass kIOMasterPortDefault to look up the default master port.
    @param options No options are currently defined.
    @param bsdName The BSD name, as a const char *.
    @result The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller. */

CFMutableDictionaryRef
IOBSDNameMatching(
	mach_port_t	masterPort,
	uint32_t	options,
	const char *	bsdName ) CF_RETURNS_RETAINED;

CFMutableDictionaryRef
IOOpenFirmwarePathMatching(
	mach_port_t	masterPort,
	uint32_t	options,
	const char *	path ) DEPRECATED_ATTRIBUTE;

/*! @function IORegistryEntryIDMatching
    @abstract Create a matching dictionary that specifies an IOService match based on a registry entry ID.
    @discussion This function creates a matching dictionary that will match a registered, active IOService found with the given registry entry ID. The entry ID for a registry entry is returned by IORegistryEntryGetRegistryEntryID().
    @param entryID The registry entry ID to be found. 
    @result The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller. */

CFMutableDictionaryRef
IORegistryEntryIDMatching(
	uint64_t	entryID ) CF_RETURNS_RETAINED;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

kern_return_t
IOServiceOFPathToBSDName(mach_port_t		masterPort,
                         const io_name_t	openFirmwarePath,
                         io_name_t		bsdName) DEPRECATED_ATTRIBUTE;
						 
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @typedef IOAsyncCallback0
    @abstract standard callback function for asynchronous I/O requests with
    no extra arguments beyond a refcon and result code.
    @param refcon The refcon passed into the original I/O request
    @param result The result of the I/O operation
*/
typedef void (*IOAsyncCallback0)(void *refcon, IOReturn result);

/*! @typedef IOAsyncCallback1
    @abstract standard callback function for asynchronous I/O requests with
    one extra argument beyond a refcon and result code.
    This is often a count of the number of bytes transferred
    @param refcon The refcon passed into the original I/O request
    @param result The result of the I/O operation
    @param arg0	Extra argument
*/
typedef void (*IOAsyncCallback1)(void *refcon, IOReturn result, void *arg0);

/*! @typedef IOAsyncCallback2
    @abstract standard callback function for asynchronous I/O requests with
    two extra arguments beyond a refcon and result code.
    @param refcon The refcon passed into the original I/O request
    @param result The result of the I/O operation
    @param arg0	Extra argument
    @param arg1	Extra argument
*/
typedef void (*IOAsyncCallback2)(void *refcon, IOReturn result, void *arg0, void *arg1);

/*! @typedef IOAsyncCallback
    @abstract standard callback function for asynchronous I/O requests with
    lots of extra arguments beyond a refcon and result code.
    @param refcon The refcon passed into the original I/O request
    @param result The result of the I/O operation
    @param args	Array of extra arguments
    @param numArgs Number of extra arguments
*/
typedef void (*IOAsyncCallback)(void *refcon, IOReturn result, void **args,
                                uint32_t numArgs);


/* Internal use */

kern_return_t
OSGetNotificationFromMessage(
	mach_msg_header_t     * msg,
	uint32_t	  	index,
        uint32_t    	      * type,
        uintptr_t	      * reference,
	void		     ** content,
        vm_size_t	      * size );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* Internal use */

kern_return_t
IOCatalogueSendData(
        mach_port_t             masterPort,
        uint32_t                flag,
        const char             *buffer,
        uint32_t                size );

kern_return_t
IOCatalogueTerminate(
        mach_port_t		masterPort,
        uint32_t                flag,
	io_name_t		description );

kern_return_t
IOCatalogueGetData(
        mach_port_t             masterPort,
        uint32_t                flag,
        char                  **buffer,
        uint32_t               *size );

kern_return_t
IOCatalogueModuleLoaded(
        mach_port_t             masterPort,
        io_name_t               name );

/* Use IOCatalogueSendData(), with kIOCatalogResetDrivers, to replace catalogue
 * rather than emptying it. Doing so keeps instance counts down by uniquing
 * existing personalities.
 */
kern_return_t
IOCatalogueReset(
        mach_port_t             masterPort,
        uint32_t                flag );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// obsolete API

#if !defined(__LP64__)

// for Power Mgt

typedef struct IOObject IOObject;

// for MacOS.app

kern_return_t
IORegistryDisposeEnumerator(
	io_enumerator_t	enumerator ) DEPRECATED_ATTRIBUTE;

kern_return_t
IOMapMemory(
	io_connect_t	connect,
	uint32_t	memoryType,
	task_port_t	intoTask,
	vm_address_t *	atAddress,
	vm_size_t    *	ofSize,
	uint32_t	flags ) DEPRECATED_ATTRIBUTE;

// for CGS

kern_return_t
IOCompatibiltyNumber(
	mach_port_t	connect,
	uint32_t *	objectNumber ) DEPRECATED_ATTRIBUTE;

// Traditional IOUserClient transport routines
kern_return_t
IOConnectMethodScalarIScalarO( 
	io_connect_t	connect,
        uint32_t	index,
        IOItemCount	scalarInputCount,
        IOItemCount	scalarOutputCount,
        ... ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

kern_return_t
IOConnectMethodScalarIStructureO(
	io_connect_t	connect,
        uint32_t	index,
        IOItemCount	scalarInputCount,
        IOByteCount *	structureSize,
        ... ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

kern_return_t
IOConnectMethodScalarIStructureI(
	io_connect_t	connect,
        uint32_t	index,
        IOItemCount	scalarInputCount,
        IOByteCount	structureSize,
        ... ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

kern_return_t
IOConnectMethodStructureIStructureO(
	io_connect_t	connect,
        uint32_t	index,
        IOItemCount	structureInputSize,
        IOByteCount *	structureOutputSize,
        void *		inputStructure,
        void *		ouputStructure ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

// Compatability with earlier Mig interface routines
#if IOCONNECT_NO_32B_METHODS

kern_return_t
io_connect_map_memory(
	io_connect_t		connect,
	uint32_t		memoryType,
	task_port_t		intoTask,
	vm_address_t		*atAddress,
	vm_size_t		*ofSize,
	IOOptionBits		options) DEPRECATED_ATTRIBUTE;

kern_return_t
io_connect_unmap_memory(
	io_connect_t		connect,
	uint32_t		memoryType,
	task_port_t		fromTask,
	vm_address_t		atAddress) DEPRECATED_ATTRIBUTE;

kern_return_t
io_connect_method_scalarI_scalarO(
	mach_port_t connection,
	int selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_scalar_inband_t output,
	mach_msg_type_number_t *outputCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_connect_method_scalarI_structureO(
	mach_port_t connection,
	int selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_connect_method_scalarI_structureI(
	mach_port_t connection,
	int selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t inputStruct,
	mach_msg_type_number_t inputStructCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_connect_method_structureI_structureO(
	mach_port_t connection,
	int selector,
	io_struct_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_async_method_scalarI_scalarO(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	int selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_scalar_inband_t output,
	mach_msg_type_number_t *outputCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_async_method_scalarI_structureO(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	int selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_async_method_scalarI_structureI(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	int selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t inputStruct,
	mach_msg_type_number_t inputStructCnt) DEPRECATED_ATTRIBUTE;

kern_return_t
io_async_method_structureI_structureO(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	int selector,
	io_struct_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt) DEPRECATED_ATTRIBUTE;
#endif // IOCONNECT_NO_32B_METHODS

#endif /* defined(__LP64__) */

__END_DECLS

#endif /* ! _IOKIT_IOKITLIB_H */
                                               IOKitServer.h                                                                                       0100644 0001750 0001750 00000010440 12567450741 033124  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2011 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */

/*
 * Internal definitions used between the iokit user library and
 * server routines.
 */

#ifndef _IOKIT_IOKITSERVER_H
#define _IOKIT_IOKITSERVER_H

#include <IOKit/IOTypes.h>
#include <IOKit/IOKitKeys.h>
#include <IOKit/OSMessageNotification.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <mach/kmod.h>
#ifdef __cplusplus
}
#endif

// IOCatalogueSendData
/*!
    @enum IOCatalogueSendData user-client flags.
    @constant kIOCatalogAddDrivers  Signals a call to the addDrivers function in IOCatalogue.
    @constant kIOCatalogAddDriversNoMatch  Signals a call to the addDrivers function in IOCatalogue but does not start a matching thread.
    @constant kIOCatalogRemoveDrivers  Signals a call to the removeDrivers function in IOCatalogue.
    @constant kIOCatalogRemoveDriversNoMatch  Signals a call to the removedrivers function in IOCatalogue but does not start a matching thread. 
    @constant kIOCatalogStartMatching  Signals the IOCatalogue to start an IOService matching thread.
    @constant kIOCatalogRemoveKernelLinker  Deprecated; does nothing.
    @constant kIOCatalogKextdActive  Signals the kernel that kextd is running.
    @constant kIOCatalogKextdFinishedLaunching  Signals the IOCatalogue that kextd has finished sending it information at startup.
    @constant kIOCatalogResetDrivers  Resets the IOCatalogue with a new set of personalities.
    @constant kIOCatalogResetDriversNoMatch  Resets the IOCatalogue with a new set of personalities but does not start a matching thread.
*/
enum {
    kIOCatalogAddDrivers	= 1,
    kIOCatalogAddDriversNoMatch,
    kIOCatalogRemoveDrivers,
    kIOCatalogRemoveDriversNoMatch,
    kIOCatalogStartMatching,
    kIOCatalogRemoveKernelLinker,
    kIOCatalogKextdActive,
    kIOCatalogKextdFinishedLaunching,
    kIOCatalogResetDrivers,
    kIOCatalogResetDriversNoMatch
};

// IOCatalogueGetData
/*!
    @enum IOCatalogueGetData user-client flags
    @constant kIOCatalogGetContents  Returns a snapshot of the database to the caller.
*/
enum {
    kIOCatalogGetContents	  = 1,
    kIOCatalogGetModuleDemandList = 2,
    kIOCatalogGetCacheMissList	  = 3,
    kIOCatalogGetROMMkextList     = 4
};

// IOCatalogueReset
/*!
    @enum IOCatalogueReset user-client flag
    @constant kIOCatalogResetDefault  Removes all entries from IOCatalogue except those used for booting the system.
*/
enum {
    kIOCatalogResetDefault	= 1
};

// IOCatalogueTerminate
/*!
    @enum IOCatalogueTerminate user-client flags.
    @constant kIOCatalogModuleUnload Terminates all services which depend on a particular module and unloads the module.
    @constant kIOCatalogModuleTerminate Terminates all services which depend on a particular module but does not unload the module.
    @constant kIOCatalogServiceTerminate Terminates a particular service by name.
*/
enum {
    kIOCatalogModuleUnload      = 1,
    kIOCatalogModuleTerminate,
    kIOCatalogServiceTerminate
};

#endif /* ! _IOKIT_IOKITSERVER_H */

                                                                                                                                                                                                                                IOMessage.h                                                                                         0100644 0001750 0001750 00000022410 12567450742 032573  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __IOKIT_IOMESSAGE_H
#define __IOKIT_IOMESSAGE_H

#include <IOKit/IOReturn.h>
#include <IOKit/IOTypes.h>

/*!
 * @header IOMessage.h
 *
 * Defines message type constants for several IOKit messaging API's.
 *
 */

typedef UInt32 IOMessage;

#define iokit_common_msg(message)          (UInt32)(sys_iokit|sub_iokit_common|message)
#define iokit_family_msg(sub,message)      (UInt32)(sys_iokit|sub|message)

/*! 
 * @defined         iokit_vendor_specific_msg
 * @discussion      iokit_vendor_specific_msg passes messages in the sub_iokit_vendor_specific
 *                  subsystem. It can be used to generate messages that are used for private 
 *                  communication between vendor specific code with the IOService::message() etc. APIs.
 */
#define iokit_vendor_specific_msg(message) (UInt32)(sys_iokit|sub_iokit_vendor_specific|message)

#define kIOMessageServiceIsTerminated      iokit_common_msg(0x010)
#define kIOMessageServiceIsSuspended       iokit_common_msg(0x020)
#define kIOMessageServiceIsResumed         iokit_common_msg(0x030)

#define kIOMessageServiceIsRequestingClose iokit_common_msg(0x100)
#define kIOMessageServiceIsAttemptingOpen  iokit_common_msg(0x101)
#define kIOMessageServiceWasClosed         iokit_common_msg(0x110)

#define kIOMessageServiceBusyStateChange   iokit_common_msg(0x120)

#define kIOMessageConsoleSecurityChange    iokit_common_msg(0x128)

#define kIOMessageServicePropertyChange    iokit_common_msg(0x130)

#define kIOMessageCopyClientID             iokit_common_msg(0x330)

#define kIOMessageSystemCapabilityChange   iokit_common_msg(0x340)
#define kIOMessageDeviceSignaledWakeup     iokit_common_msg(0x350)


/*!
 * @defined         kIOMessageDeviceWillPowerOff
 * @discussion      Indicates the device is about to move to a lower power state.
 *                  Sent to IOKit interest notification clients of type <code>kIOAppPowerStateInterest</code>
 *                  and <code>kIOGeneralInterest</code>.
 */
#define kIOMessageDeviceWillPowerOff       iokit_common_msg(0x210)

/*!
 * @defined         kIOMessageDeviceHasPoweredOn
 * @discussion      Indicates the device has just moved to a higher power state.
 *                  Sent to IOKit interest notification clients of type <code>kIOAppPowerStateInterest</code>
 *                  and <code>kIOGeneralInterest</code>.
 */
#define kIOMessageDeviceHasPoweredOn       iokit_common_msg(0x230)

/*! @group          In-kernel system shutdown and restart notifications
 */

/*!
 * @defined         kIOMessageSystemWillPowerOff
 * @discussion      Indicates an imminent system shutdown. Recipients have a limited 
 *                  amount of time to respond, otherwise the system will timeout and 
 *                  shutdown even without a response.
 *                  Delivered to in-kernel IOKit drivers via <code>IOService::systemWillShutdown()</code>, 
 *                  and to clients of <code>registerPrioritySleepWakeInterest()</code>.
 *                  Never delivered to user space notification clients.
 */
#define kIOMessageSystemWillPowerOff       iokit_common_msg(0x250)

/*!
 * @defined         kIOMessageSystemWillRestart
 * @discussion      Indicates an imminent system restart. Recipients have a limited 
 *                  amount of time to respond, otherwise the system will timeout and 
 *                  restart even without a response.
 *                  Delivered to in-kernel IOKit drivers via <code>IOService::systemWillShutdown()</code>, 
 *                  and to clients of <code>registerPrioritySleepWakeInterest()</code>.
 *                  Never delivered to user space notification clients.
 */
#define kIOMessageSystemWillRestart        iokit_common_msg(0x310)

/*!
 * @defined         kIOMessageSystemPagingOff
 * @discussion      Indicates an imminent system shutdown, paging device now unavailable.
 *					Recipients have a limited amount of time to respond, otherwise the
 *					system will timeout and shutdown even without a response.
 *                  Delivered to clients of <code>registerPrioritySleepWakeInterest()</code>.
 *                  Never delivered to user space notification clients.
 */
#define kIOMessageSystemPagingOff       iokit_common_msg(0x255)


/*! @group          System sleep and wake notifications
 */

/*!
 * @defined         kIOMessageCanSystemSleep
 * @discussion      Announces/Requests permission to proceed to system sleep.
 *                  Delivered to in-kernel IOKit drivers via <code>kIOGeneralInterest</code>
 *                  and <code>kIOPriorityPowerStateInterest</code>.
 *                  Delivered to user clients of <code>IORegisterForSystemPower</code>.
 */
#define kIOMessageCanSystemSleep           iokit_common_msg(0x270)

/*!
 * @defined         kIOMessageSystemWillNotSleep
 * @discussion      Announces that the system has retracted a previous attempt to sleep; 
 *                  it follows <code>kIOMessageCanSystemSleep</code>.
 *                  Delivered to in-kernel IOKit drivers via <code>kIOGeneralInterest</code>
 *                  and <code>kIOPriorityPowerStateInterest</code>.
 *                  Delivered to user clients of <code>IORegisterForSystemPower</code>.
 */
#define kIOMessageSystemWillNotSleep       iokit_common_msg(0x290)

/*!
 * @defined         kIOMessageSystemWillSleep
 * @discussion      Announces that sleep is beginning.
 *                  Delivered to in-kernel IOKit drivers via <code>kIOGeneralInterest</code>
 *                  and <code>kIOPriorityPowerStateInterest</code>.
 *                  Delivered to user clients of <code>IORegisterForSystemPower</code>.
 */
#define kIOMessageSystemWillSleep          iokit_common_msg(0x280)

/*!
 * @defined         kIOMessageSystemWillPowerOn
 * @discussion      Announces that the system is beginning to power the device tree; most 
 *                  devices are unavailable at this point..
 *                  Delivered to in-kernel IOKit drivers via <code>kIOGeneralInterest</code>
 *                  and <code>kIOPriorityPowerStateInterest</code>.
 *                  Delivered to user clients of <code>IORegisterForSystemPower</code>.
 */
#define kIOMessageSystemWillPowerOn        iokit_common_msg(0x320)

/*!
 * @defined         kIOMessageSystemHasPoweredOn
 * @discussion      Announces that the system and its devices have woken up.
 *                  Delivered to in-kernel IOKit drivers via <code>kIOGeneralInterest</code>
 *                  and <code>kIOPriorityPowerStateInterest</code>.
 *                  Delivered to user clients of <code>IORegisterForSystemPower</code>.
 */
#define kIOMessageSystemHasPoweredOn       iokit_common_msg(0x300)

/*! @group          Unused and deprecated notifications
 */

/*! 
 * @defined         kIOMessageCanDevicePowerOff
 * @discussion      Delivered to <code>kIOAppPowerStateInterest</code> clients of 
 *                  devices that implement their own idle timeouts.
 *                  This message type is almost never used.
 */
#define kIOMessageCanDevicePowerOff        iokit_common_msg(0x200)

/*! 
 * @defined         kIOMessageDeviceWillNotPowerOff
 * @discussion      This IOKit interest notification is largely unused; 
 *                  it's not very interesting.
 */
#define kIOMessageDeviceWillNotPowerOff    iokit_common_msg(0x220)

/*! 
 * @defined         kIOMessageSystemWillNotPowerOff
 * @deprecated      This IOKit message is unused.
 */
#define kIOMessageSystemWillNotPowerOff    iokit_common_msg(0x260)

/*!
 * @defined         kIOMessageCanSystemPowerOff
 * @deprecated      This IOKit message is unused.
 */
#define kIOMessageCanSystemPowerOff        iokit_common_msg(0x240)

/*!
 * @defined         kIOMessageDeviceWillPowerOn
 * @discussion      IOService power mgt does not send kIOMessageDeviceWillPowerOn.
 */
#define kIOMessageDeviceWillPowerOn        iokit_common_msg(0x215)

/*!
 * @defined         kIOMessageDeviceHasPoweredOff
 * @discussion      IOService power mgt does not send kIOMessageDeviceHasPoweredOff.
 */
#define kIOMessageDeviceHasPoweredOff      iokit_common_msg(0x225)


#endif /* ! __IOKIT_IOMESSAGE_H */
                                                                                                                                                                                                                                                        IOReturn.h                                                                                          0100644 0001750 0001750 00000017520 12567450741 032473  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * HISTORY
 */
 
/*
 * Core IOReturn values. Others may be family defined.
 */

#ifndef __IOKIT_IORETURN_H
#define __IOKIT_IORETURN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <mach/error.h>

typedef	kern_return_t		IOReturn;

#ifndef sys_iokit
#define sys_iokit                         err_system(0x38)
#endif /* sys_iokit */
#define sub_iokit_common                  err_sub(0)
#define sub_iokit_usb                     err_sub(1)
#define sub_iokit_firewire                err_sub(2)
#define sub_iokit_block_storage           err_sub(4)
#define sub_iokit_graphics                err_sub(5)
#define sub_iokit_networking		  err_sub(6)
#define sub_iokit_bluetooth               err_sub(8)
#define sub_iokit_pmu                     err_sub(9)
#define sub_iokit_acpi                    err_sub(10)
#define sub_iokit_smbus                   err_sub(11)
#define sub_iokit_ahci                    err_sub(12)
#define sub_iokit_powermanagement         err_sub(13)
#define sub_iokit_hidsystem             err_sub(14)
#define sub_iokit_scsi                    err_sub(16)
#define sub_iokit_usbaudio                err_sub(17)
//#define sub_iokit_pccard                err_sub(21)
#define sub_iokit_thunderbolt             err_sub(29)
#define sub_iokit_platform				  err_sub(0x2A)
#define sub_iokit_audio_video             err_sub(0x45)
#define sub_iokit_baseband                err_sub(0x80)
#define sub_iokit_HDA                     err_sub(254)
#define sub_iokit_hsic                    err_sub(0x147)
#define sub_iokit_sdio                    err_sub(0x174)
#define sub_iokit_wlan                    err_sub(0x208)

#define sub_iokit_vendor_specific         err_sub(-2)
#define sub_iokit_reserved                err_sub(-1)

#define	iokit_common_err(return)          (sys_iokit|sub_iokit_common|return)
#define	iokit_family_err(sub,return)      (sys_iokit|sub|return)
#define iokit_vendor_specific_err(return) (sys_iokit|sub_iokit_vendor_specific|return)

#define kIOReturnSuccess         KERN_SUCCESS            // OK
#define kIOReturnError           iokit_common_err(0x2bc) // general error 	
#define kIOReturnNoMemory        iokit_common_err(0x2bd) // can't allocate memory 
#define kIOReturnNoResources     iokit_common_err(0x2be) // resource shortage 
#define kIOReturnIPCError        iokit_common_err(0x2bf) // error during IPC 
#define kIOReturnNoDevice        iokit_common_err(0x2c0) // no such device 
#define kIOReturnNotPrivileged   iokit_common_err(0x2c1) // privilege violation 
#define kIOReturnBadArgument     iokit_common_err(0x2c2) // invalid argument 
#define kIOReturnLockedRead      iokit_common_err(0x2c3) // device read locked 
#define kIOReturnLockedWrite     iokit_common_err(0x2c4) // device write locked 
#define kIOReturnExclusiveAccess iokit_common_err(0x2c5) // exclusive access and
                                                         //   device already open 
#define kIOReturnBadMessageID    iokit_common_err(0x2c6) // sent/received messages
                                                         //   had different msg_id
#define kIOReturnUnsupported     iokit_common_err(0x2c7) // unsupported function 
#define kIOReturnVMError         iokit_common_err(0x2c8) // misc. VM failure 
#define kIOReturnInternalError   iokit_common_err(0x2c9) // internal error 
#define kIOReturnIOError         iokit_common_err(0x2ca) // General I/O error 
//#define kIOReturn???Error      iokit_common_err(0x2cb) // ??? 
#define kIOReturnCannotLock      iokit_common_err(0x2cc) // can't acquire lock
#define kIOReturnNotOpen         iokit_common_err(0x2cd) // device not open 
#define kIOReturnNotReadable     iokit_common_err(0x2ce) // read not supported 
#define kIOReturnNotWritable     iokit_common_err(0x2cf) // write not supported 
#define kIOReturnNotAligned      iokit_common_err(0x2d0) // alignment error 
#define kIOReturnBadMedia        iokit_common_err(0x2d1) // Media Error 
#define kIOReturnStillOpen       iokit_common_err(0x2d2) // device(s) still open 
#define kIOReturnRLDError        iokit_common_err(0x2d3) // rld failure 
#define kIOReturnDMAError        iokit_common_err(0x2d4) // DMA failure 
#define kIOReturnBusy            iokit_common_err(0x2d5) // Device Busy 
#define kIOReturnTimeout         iokit_common_err(0x2d6) // I/O Timeout 
#define kIOReturnOffline         iokit_common_err(0x2d7) // device offline 
#define kIOReturnNotReady        iokit_common_err(0x2d8) // not ready 
#define kIOReturnNotAttached     iokit_common_err(0x2d9) // device not attached 
#define kIOReturnNoChannels      iokit_common_err(0x2da) // no DMA channels left
#define kIOReturnNoSpace         iokit_common_err(0x2db) // no space for data 
//#define kIOReturn???Error      iokit_common_err(0x2dc) // ??? 
#define kIOReturnPortExists      iokit_common_err(0x2dd) // port already exists
#define kIOReturnCannotWire      iokit_common_err(0x2de) // can't wire down 
                                                         //   physical memory
#define kIOReturnNoInterrupt     iokit_common_err(0x2df) // no interrupt attached
#define kIOReturnNoFrames        iokit_common_err(0x2e0) // no DMA frames enqueued
#define kIOReturnMessageTooLarge iokit_common_err(0x2e1) // oversized msg received
                                                         //   on interrupt port
#define kIOReturnNotPermitted    iokit_common_err(0x2e2) // not permitted
#define kIOReturnNoPower         iokit_common_err(0x2e3) // no power to device
#define kIOReturnNoMedia         iokit_common_err(0x2e4) // media not present
#define kIOReturnUnformattedMedia iokit_common_err(0x2e5)// media not formatted
#define kIOReturnUnsupportedMode iokit_common_err(0x2e6) // no such mode
#define kIOReturnUnderrun        iokit_common_err(0x2e7) // data underrun
#define kIOReturnOverrun         iokit_common_err(0x2e8) // data overrun
#define kIOReturnDeviceError	 iokit_common_err(0x2e9) // the device is not working properly!
#define kIOReturnNoCompletion	 iokit_common_err(0x2ea) // a completion routine is required
#define kIOReturnAborted	 iokit_common_err(0x2eb) // operation aborted
#define kIOReturnNoBandwidth	 iokit_common_err(0x2ec) // bus bandwidth would be exceeded
#define kIOReturnNotResponding	 iokit_common_err(0x2ed) // device not responding
#define kIOReturnIsoTooOld	 iokit_common_err(0x2ee) // isochronous I/O request for distant past!
#define kIOReturnIsoTooNew	 iokit_common_err(0x2ef) // isochronous I/O request for distant future
#define kIOReturnNotFound        iokit_common_err(0x2f0) // data was not found
#define kIOReturnInvalid         iokit_common_err(0x1)   // should never be seen

#ifdef __cplusplus
}
#endif

#endif /* ! __IOKIT_IORETURN_H */
                                                                                                                                                                                IOSharedLock.h                                                                                      0100644 0001750 0001750 00000002244 12567450742 033231  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOSHAREDLOCK_H
#define _IOKIT_IOSHAREDLOCK_H

#include <libkern/OSAtomic.h>

#define IOSharedLockData OSSpinLock
#define ev_lock_data_t   OSSpinLock


#endif /* ! _IOKIT_IOSHAREDLOCK_H */
                                                                                                                                                                                                                                                                                                                                                            IOTypes.h                                                                                           0100644 0001750 0001750 00000013542 12567450742 032321  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2012 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef	__IOKIT_IOTYPES_H
#define __IOKIT_IOTYPES_H

#ifndef IOKIT
#define IOKIT 1
#endif /* !IOKIT */

#include <mach/message.h>
#include <mach/vm_types.h>

#include <IOKit/IOReturn.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef	NULL
#if defined (__cplusplus)
#define	NULL	0
#else
#define NULL ((void *)0)
#endif
#endif
	
/*
 * Simple data types.
 */
#include <stdbool.h>
#include <libkern/OSTypes.h>


typedef UInt32		IOOptionBits;
typedef SInt32		IOFixed;
typedef UInt32		IOVersion;
typedef UInt32		IOItemCount;
typedef UInt32  	IOCacheMode;

typedef UInt32	 	IOByteCount32;
typedef UInt64	 	IOByteCount64;

typedef UInt32	IOPhysicalAddress32;
typedef UInt64	IOPhysicalAddress64;
typedef UInt32	IOPhysicalLength32;
typedef UInt64	IOPhysicalLength64;

#if !defined(__arm__) && !defined(__i386__)
typedef mach_vm_address_t	IOVirtualAddress;
#else
typedef vm_address_t		IOVirtualAddress;
#endif

#if !defined(__arm__) && !defined(__i386__) && !(defined(__x86_64__) && !defined(KERNEL))
typedef IOByteCount64		IOByteCount;
#else
typedef IOByteCount32	 	IOByteCount;
#endif

typedef IOVirtualAddress    IOLogicalAddress;

#if !defined(__arm__) && !defined(__i386__) && !(defined(__x86_64__) && !defined(KERNEL))

typedef IOPhysicalAddress64	 IOPhysicalAddress;
typedef IOPhysicalLength64	 IOPhysicalLength;
#define IOPhysical32( hi, lo )		((UInt64) lo + ((UInt64)(hi) << 32))
#define IOPhysSize	64

#else

typedef IOPhysicalAddress32	 IOPhysicalAddress;
typedef IOPhysicalLength32	 IOPhysicalLength;
#define IOPhysical32( hi, lo )		(lo)
#define IOPhysSize	32

#endif


typedef struct
{
    IOPhysicalAddress	address;
    IOByteCount		length;
} IOPhysicalRange;

typedef struct 
{
    IOVirtualAddress	address;
    IOByteCount		length;
} IOVirtualRange;

#if !defined(__arm__) && !defined(__i386__)
typedef IOVirtualRange	IOAddressRange;
#else
typedef struct 
{
    mach_vm_address_t	address;
    mach_vm_size_t	length;
} IOAddressRange;
#endif

/*
 * Map between #defined or enum'd constants and text description.
 */
typedef struct {
	int value;
	const char *name;
} IONamedValue;


/*
 * Memory alignment -- specified as a power of two.
 */
typedef unsigned int	IOAlignment;

#define IO_NULL_VM_TASK		((vm_task_t)0)


/*
 * Pull in machine specific stuff.
 */

//#include <IOKit/machine/IOTypes.h>

#ifndef MACH_KERNEL

#ifndef __IOKIT_PORTS_DEFINED__
#define __IOKIT_PORTS_DEFINED__
typedef mach_port_t	io_object_t;
#endif /* __IOKIT_PORTS_DEFINED__ */

#include <device/device_types.h>

typedef io_object_t	io_connect_t;
typedef io_object_t	io_enumerator_t;
typedef io_object_t	io_iterator_t;
typedef io_object_t	io_registry_entry_t;
typedef io_object_t	io_service_t;

#define	IO_OBJECT_NULL	((io_object_t) 0)

#endif /* MACH_KERNEL */

// IOConnectMapMemory memoryTypes
enum {
    kIODefaultMemoryType	= 0
};

enum {
    kIODefaultCache		= 0,
    kIOInhibitCache		= 1,
    kIOWriteThruCache		= 2,
    kIOCopybackCache		= 3,
    kIOWriteCombineCache	= 4,
    kIOCopybackInnerCache	= 5
};

// IOMemory mapping options
enum {
    kIOMapAnywhere		= 0x00000001,

    kIOMapCacheMask		= 0x00000700,
    kIOMapCacheShift		= 8,
    kIOMapDefaultCache		= kIODefaultCache       << kIOMapCacheShift,
    kIOMapInhibitCache		= kIOInhibitCache       << kIOMapCacheShift,
    kIOMapWriteThruCache	= kIOWriteThruCache     << kIOMapCacheShift,
    kIOMapCopybackCache		= kIOCopybackCache      << kIOMapCacheShift,
    kIOMapWriteCombineCache	= kIOWriteCombineCache  << kIOMapCacheShift,
    kIOMapCopybackInnerCache	= kIOCopybackInnerCache << kIOMapCacheShift,

    kIOMapUserOptionsMask	= 0x00000fff,

    kIOMapReadOnly		= 0x00001000,

    kIOMapStatic		= 0x01000000,
    kIOMapReference		= 0x02000000,
    kIOMapUnique		= 0x04000000,
    kIOMapPrefault		= 0x10000000,
    kIOMapOverwrite     = 0x20000000
};

/*! @enum Scale Factors
    @discussion Used when a scale_factor parameter is required to define a unit of time.
    @constant kNanosecondScale Scale factor for nanosecond based times.
    @constant kMicrosecondScale Scale factor for microsecond based times.
    @constant kMillisecondScale Scale factor for millisecond based times.
    @constant kTickScale Scale factor for the standard (100Hz) tick.
    @constant kSecondScale Scale factor for second based times. */

enum {
    kNanosecondScale  = 1,
    kMicrosecondScale = 1000,
    kMillisecondScale = 1000 * 1000,
    kSecondScale      = 1000 * 1000 * 1000,
    kTickScale        = (kSecondScale / 100)
};

enum {
    kIOConnectMethodVarOutputSize = -3
};

/* compatibility types */


typedef unsigned int IODeviceNumber;


#ifdef __cplusplus
}
#endif

#endif /* ! __IOKIT_IOTYPES_H */
                                                                                                                                                              OSMessageNotification.h                                                                             0100644 0001750 0001750 00000010542 12567450742 035157  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */

#ifndef	__OS_OSMESSAGENOTIFICATION_H
#define __OS_OSMESSAGENOTIFICATION_H

#ifdef __cplusplus
extern "C" {
#endif

#include <mach/mach_types.h>
#include <device/device_types.h>
#include <IOKit/IOReturn.h>

enum {
    kFirstIOKitNotificationType 		= 100,
    kIOServicePublishNotificationType 		= 100,
    kIOServiceMatchedNotificationType		= 101,
    kIOServiceTerminatedNotificationType	= 102,
    kIOAsyncCompletionNotificationType		= 150,
    kIOServiceMessageNotificationType		= 160,
    kLastIOKitNotificationType 			= 199,

    // reserved bits
    kIOKitNoticationTypeMask                    = 0x00000FFF,
    kIOKitNoticationTypeSizeAdjShift            = 30,
    kIOKitNoticationMsgSizeMask                 = 3,
};

enum {
    kOSNotificationMessageID		= 53,
    kOSAsyncCompleteMessageID		= 57,
    kMaxAsyncArgs			= 16
};

enum {
    kIOAsyncReservedIndex 	= 0,
    kIOAsyncReservedCount,

    kIOAsyncCalloutFuncIndex 	= kIOAsyncReservedCount,
    kIOAsyncCalloutRefconIndex,
    kIOAsyncCalloutCount,

    kIOMatchingCalloutFuncIndex	= kIOAsyncReservedCount,
    kIOMatchingCalloutRefconIndex,
    kIOMatchingCalloutCount,
    
    kIOInterestCalloutFuncIndex	= kIOAsyncReservedCount,
    kIOInterestCalloutRefconIndex,
    kIOInterestCalloutServiceIndex,
    kIOInterestCalloutCount
};



// --------------
enum {
    kOSAsyncRef64Count	= 8,
    kOSAsyncRef64Size 	= kOSAsyncRef64Count * ((int) sizeof(io_user_reference_t))
};
typedef io_user_reference_t OSAsyncReference64[kOSAsyncRef64Count];

struct OSNotificationHeader64 {
    mach_msg_size_t	size;		/* content size */
    natural_t		type;
    OSAsyncReference64	reference;

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
    unsigned char	content[];
#else
    unsigned char	content[0];
#endif
};

#pragma pack(4)
struct IOServiceInterestContent64 {
    natural_t		messageType;
    io_user_reference_t	messageArgument[1];
};
#pragma pack()
// --------------

#if !KERNEL_USER32

enum {
    kOSAsyncRefCount	= 8,
    kOSAsyncRefSize 	= 32
};
typedef natural_t OSAsyncReference[kOSAsyncRefCount];

struct OSNotificationHeader {
    mach_msg_size_t	size;		/* content size */
    natural_t		type;
    OSAsyncReference	reference;

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
    unsigned char	content[];
#else
    unsigned char	content[0];
#endif
};

#pragma pack(4)
struct IOServiceInterestContent {
    natural_t	messageType;
    void *	messageArgument[1];
};
#pragma pack()

#endif /* KERNEL_USER32  */

struct IOAsyncCompletionContent {
    IOReturn result;
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
    void * args[] __attribute__ ((packed));
#else
    void * args[0] __attribute__ ((packed));
#endif
};

#ifndef __cplusplus
typedef struct OSNotificationHeader OSNotificationHeader;
typedef struct IOServiceInterestContent IOServiceInterestContent;
typedef struct IOAsyncCompletionContent IOAsyncCompletionContent;
#endif

#ifdef __cplusplus
}
#endif

#endif /*  __OS_OSMESSAGENOTIFICATION_H */

                                                                                                                                                              audio/                                                                                              0040755 0001750 0001750 00000000000 12612224741 031700  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOAudioDefines.h                                                                                    0100644 0001750 0001750 00000044400 12567452612 034650  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/audio                                                                 /*
 * Copyright (c) 1998-2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOAUDIODEFINES_H
#define _IOAUDIODEFINES_H

#define kIOAudioDeviceClassName		"IOAudioDevice"
#define kIOAudioEngineClassName		"IOAudioEngine"
#define kIOAudioStreamClassName		"IOAudioStream"
#define kIOAudioPortClassName		"IOAudioPort"
#define kIOAudioControlClassName	"IOAudioControl"

/*!
 * @defined kIOAudioSampleRateKey
 * @abstract The key in the IORegistry for the IOAudioEngine sample rate attribute
 * @discussion This value is represented as an integer in samples per second.
 */
#define kIOAudioSampleRateKey				"IOAudioSampleRate"

#define kIOAudioSampleRateWholeNumberKey	"IOAudioSampleRateWholeNumber"
#define kIOAudioSampleRateFractionKey		"IOAudioSampleRateFraction"



/******
 *
 * IOAudioDevice  defines
 *
 *****/


/*!
 * @defined kIOAudioDeviceNameKey
 * @abstract The key in the IORegistry for the IOAudioDevice name attribute.
 */
#define kIOAudioDeviceNameKey				"IOAudioDeviceName"

#define kIOAudioDeviceShortNameKey			"IOAudioDeviceShortName"

/*!
 * @defined kIOAudioDeviceManufacturerNameKey
 * @abstract The key in the IORegistry for the IOAudioDevice manufacturer name attribute.
 */
#define kIOAudioDeviceManufacturerNameKey	"IOAudioDeviceManufacturerName"

#define kIOAudioDeviceLocalizedBundleKey	"IOAudioDeviceLocalizedBundle"

#define kIOAudioDeviceTransportTypeKey		"IOAudioDeviceTransportType"

#define kIOAudioDeviceConfigurationAppKey	"IOAudioDeviceConfigurationApplication"

#define kIOAudioDeviceCanBeDefaults			"IOAudioDeviceCanBeDefaults"

#define kIOAudioDeviceModelIDKey			"IOAudioDeviceModelID"


/*!
 * @defined kIOAudioDeviceIconName
 * @abstract The key in the IORegistry for the IOAudioDevice icon name attribute.
 */
#define kIOAudioDeviceIconNameKey		"IOAudioDeviceIconName"

#define kIOAudioDeviceIconTypeKey		"IOAudioDeviceIconType"

#define kIOAudioDeviceIconSubDirKey	"IOAudioDeviceIconSubDir"

/*****
 *
 * IOAudioEngine defines
 *
 *****/


 /*!
 * @defined kIOAudioEngineStateKey
 * @abstract The key in the IORegistry for the IOAudioEngine state atrribute
 * @discussion The value for this key may be one of: "Running", "Stopped" or "Paused".  Currently the "Paused"
 *  state is unimplemented.
 */
#define kIOAudioEngineStateKey		"IOAudioEngineState"

/*!
 * @defined kIOAudioEngineOutputSampleLatencyKey
 * @abstract The key in the IORegistry for the IOAudioEngine output sample latency key
 * @discussion 
 */
#define kIOAudioEngineOutputSampleLatencyKey		"IOAudioEngineOutputSampleLatency"

/*!
 * @defined kIOAudioStreamSampleLatencyKey
 * @abstract The key in the IORegistry for the IOAudioStream output sample latency key
 * @discussion Tells the HAL how much latency is on a particular stream.  If two streams
 * on the same engine have different latencies (e.g. one is analog, one is digital), then
 * set this property on both streams to inform the HAL of the latency differences.  Alternately,
 * you can set the engine latency, and just include the latency additional to that for the particular
 * stream.  The HAL will add the engine and stream latency numbers together to get the total latency.
 */
#define kIOAudioStreamSampleLatencyKey				"IOAudioStreamSampleLatency"

#define kIOAudioEngineInputSampleLatencyKey			"IOAudioEngineInputSampleLatency"

#define kIOAudioEngineSampleOffsetKey				"IOAudioEngineSampleOffset"

#define kIOAudioEngineInputSampleOffsetKey			"IOAudioEngineInputSampleOffset"

#define kIOAudioEngineNumSampleFramesPerBufferKey	"IOAudioEngineNumSampleFramesPerBuffer"

#define kIOAudioEngineCoreAudioPlugInKey			"IOAudioEngineCoreAudioPlugIn"

#define kIOAudioEngineNumActiveUserClientsKey		"IOAudioEngineNumActiveUserClients"

#define kIOAudioEngineUserClientActiveKey			"IOAudioEngineUserClientActive"

#define kIOAudioEngineGlobalUniqueIDKey				"IOAudioEngineGlobalUniqueID"

#define kIOAudioEngineDescriptionKey				"IOAudioEngineDescription"

#define kIOAudioEngineClockIsStableKey				"IOAudioEngineClockIsStable"

#define kIOAudioEngineClockDomainKey				"IOAudioEngineClockDomain"

#define kIOAudioEngineIsHiddenKey               "IOAudioEngineIsHidden"
/*!
 * @defined kIOAudioEngineFullChannelNamesKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary of fully constructed names for each channel keyed by the device channel
 * @discussion 
 */
#define	kIOAudioEngineFullChannelNamesKey			"IOAudioEngineChannelNames"

/*!
 * @defined kIOAudioEngineFullChannelCategoryNamesKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary of category names for each channel keyed by the device channel
 * @discussion 
 */
#define	kIOAudioEngineFullChannelCategoryNamesKey	"IOAudioEngineChannelCategoryNames"

/*!
 * @defined kIOAudioEngineFullChannelNamesKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary of number names for each channel keyed by the device channel
 * @discussion 
 */
#define	kIOAudioEngineFullChannelNumberNamesKey			"IOAudioEngineChannelNumberNames"

#define	kIOAudioEngineFullChannelNameKeyInputFormat		"InputChannel%u"

#define	kIOAudioEngineFullChannelNameKeyOutputFormat	"OutputChannel%u"

#define kIOAudioEngineFlavorKey							"IOAudioEngineFlavor"

#define	kIOAudioEngineAlwaysLoadCoreAudioPlugInKey		"IOAudioEngineAlwaysLoadCoreAudioPlugIn"

/*!
 * @defined kIOAudioEngineInputChannelLayoutKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary describes an array of OSNumber data that describe the spatial position of each channel.  See IOAudioTypes.h.
 * @discussion
 */

#ifndef __OPEN_SOURCE__
//	<rdar://6868206>
#endif
#define kIOAudioEngineInputChannelLayoutKey				"IOAudioEngineInputChannelLayout"

/*!
 * @defined kIOAudioEngineOutputChannelLayoutKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary describes an array of OSNumber data that describe the spatial position of each channel.  See IOAudioTypes.h.
 * @discussion
 */

#ifndef __OPEN_SOURCE__
//	<rdar://6868206>
#endif
#define kIOAudioEngineOutputChannelLayoutKey			"IOAudioEngineOutputChannelLayout"

/*!
 * @defined kIOAudioEngineDisableClockBoundsCheck
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary implemented as an OSBoolean that is used to disable the bounds checking on timestamps being passed to the HAL.
 * @discussion By using this key and setting the value to true the driver is asserting that it guarantees that all zero timestamps passed to the HAL increment appropriately at the 
				correct period. This key is used to disable the HAL test that the timestamp is within 1ms of the current time, so that a driver may pass a timestamp that is more than
				1ms in the future. This may be useful when a timestamp is based on a large DMA read/write which encompasses the wrap point but occurs many samples before the end of that point.
 */
#define kIOAudioEngineDisableClockBoundsCheck		"IOAudioEngineDisableClockBoundsCheck"

/*****
 *
 * IOAudioStream defines
 *
 *****/
 
 
#define kIOAudioStreamIDKey					"IOAudioStreamID"
#define kIOAudioStreamDescriptionKey		"IOAudioStreamDescription"
#define kIOAudioStreamNumClientsKey			"IOAudioStreamNumClients"

/*!
 * @defined kIOAudioStreamDirectionKey
 * @abstract The key in the IORegistry for the IOAudioStream direction attribute.
 * @discussion The value for this key may be either "Output" or "Input".
 */
#define kIOAudioStreamDirectionKey				"IOAudioStreamDirection"

#define kIOAudioStreamStartingChannelIDKey		"IOAudioStreamStartingChannelID"
#define kIOAudioStreamStartingChannelNumberKey	"IOAudioStreamStartingChannelNumber"
#define kIOAudioStreamAvailableKey				"IOAudioStreamAvailable"

#define kIOAudioStreamFormatKey					"IOAudioStreamFormat"
#define kIOAudioStreamAvailableFormatsKey		"IOAudioStreamAvailableFormats"

#define kIOAudioStreamNumChannelsKey			"IOAudioStreamNumChannels"
#define kIOAudioStreamSampleFormatKey			"IOAudioStreamSampleFormat"

#define kIOAudioStreamNumericRepresentationKey	"IOAudioStreamNumericRepresentation"

#define kIOAudioStreamFormatFlagsKey			"IOAudioStreamFormatFlags"
#define kIOAudioStreamFramesPerPacketKey		"IOAudioStreamFramesPerPacket"
#define kIOAudioStreamBytesPerPacketKey			"IOAudioStreamBytesPerPacket"


#define kIOAudioStreamBitDepthKey				"IOAudioStreamBitDepth"
#define kIOAudioStreamBitWidthKey				"IOAudioStreamBitWidth"
    
#define kIOAudioStreamAlignmentKey				"IOAudioStreamAlignment"

#define kIOAudioStreamByteOrderKey				"IOAudioStreamByteOrder"

#define kIOAudioStreamIsMixableKey				"IOAudioStreamIsMixable"

#define kIOAudioStreamMinimumSampleRateKey		"IOAudioStreamMinimumSampleRate"
#define kIOAudioStreamMaximumSampleRateKey		"IOAudioStreamMaximumSampleRate"

#define kIOAudioStreamDriverTagKey				"IOAudioStreamDriverTag"

#define kIOAudioStreamTerminalTypeKey			"IOAudioStreamTerminalType"

/*****
 *
 * IOAudioPort defines
 *
 *****/
 
 
 /*!
 * @defined kIOAudioPortTypeKey
 * @abstract The key in the IORegistry for the IOAudioPort type attribute.
 * @discussion This is a driver-defined text attribute that may contain any type.
 *  Common types are defined as: "Speaker", "Headphones", "Microphone", "CD", "Line", "Digital", "Mixer", "PassThru".
 */
#define kIOAudioPortTypeKey			"IOAudioPortType"

/*!
 * @defined kIOAudioPortSubTypeKey
 * @abstract The key in the IORegistry for the IOAudioPort subtype attribute.
 * @discussion The IOAudioPort subtype is a driver-defined text attribute designed to complement the type
 *  attribute.
 */
#define kIOAudioPortSubTypeKey		"IOAudioPortSubType"

/*!
 * @defined kIOAudioPortNameKey
 * @abstract The key in the IORegistry for the IOAudioPort name attribute.
 */
#define kIOAudioPortNameKey			"IOAudioPortName"



/*****
 *
 * IOAudioControl defines
 *
 *****/
 
 
 /*!
 * @defined kIOAudioControlTypeKey
 * @abstract The key in the IORegistry for the IOAudioCntrol type attribute.
 * @discussion The value of this text attribute may be defined by the driver, however system-defined
 *  types recognized by the upper-level software are "Level", "Mute", "Selector".
 */
#define kIOAudioControlTypeKey		"IOAudioControlType"

#define kIOAudioControlSubTypeKey	"IOAudioControlSubType"

#define kIOAudioControlUsageKey		"IOAudioControlUsage"

#define kIOAudioControlIDKey		"IOAudioControlID"

/*!
 * @defined kIOAudioControlChannelIDKey
 * @abstract The key in the IORegistry for the IOAudioControl channel ID attribute
 * @discussion The value for this key is an integer which may be driver defined.  Default values for
 *  common channel types are provided in the following defines.
 */
#define kIOAudioControlChannelIDKey		"IOAudioControlChannelID"

#define kIOAudioControlChannelNumberKey			"IOAudioControlChannelNumber"

#define kIOAudioControlCoreAudioPropertyIDKey	"IOAudioControlCoreAudioPropertyID"
/*!
 * @defined kIOAudioControlChannelNameKey
 * @abstract The key in the IORegistry for the IOAudioControl name attribute.
 * @discussion This name should be a human-readable name for the channel(s) represented by the port.
 *  *** NOTE *** We really need to make all of the human-readable attributes that have potential to
 *  be used in a GUI localizable.  There will need to be localized strings in the kext bundle matching
 *  the text.
 */
#define kIOAudioControlChannelNameKey		"IOAudioControlChannelName"

/*!
 * @defined kIOAudioControlChannelNameAll
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for all channels.
 */
#define kIOAudioControlChannelNameAll		"All Channels"

/*!
 * @defined kIOAudioControlChannelNameLeft
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the left channel.
 */
#define kIOAudioControlChannelNameLeft		"Left"

/*!
 * @defined kIOAudioControlChannelNameRight
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the right channel.
 */
#define kIOAudioControlChannelNameRight		"Right"

/*!
 * @defined kIOAudioControlChannelNameCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the center channel.
 */
#define kIOAudioControlChannelNameCenter	"Center"

/*!
 * @defined kIOAudioControlChannelNameLeftRear
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the left rear channel.
 */
#define kIOAudioControlChannelNameLeftRear	"LeftRear"

/*!
 * @defined kIOAudioControlChannelNameRightRear
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the right rear channel.
 */
#define kIOAudioControlChannelNameRightRear	"RightRear"

/*!
 * @defined kIOAudioControlChannelNameSub
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the sub/LFE channel.
 */
#define kIOAudioControlChannelNameSub		"Sub"

/*!
 * @defined kIOAudioControlChannelNameFrontLeftCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the FrontLeftCenter channel.
 */
#define kIOAudioControlChannelNameFrontLeftCenter		"FrontLeftCenter"

/*!
 * @defined kIOAudioControlChannelNameFrontRightCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the FrontRightCenter channel.
 */
#define kIOAudioControlChannelNameFrontRightCenter		"FrontRightCenter"

/*!
 * @defined kIOAudioControlChannelNameRearCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the RearCenter channel.
 */
#define kIOAudioControlChannelNameRearCenter		"RearCenter"

/*!
 * @defined kIOAudioControlChannelNameSurroundLeft
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the SurroundLeft channel.
 */
#define kIOAudioControlChannelNameSurroundLeft		"SurroundLeft"

/*!
 * @defined kIOAudioControlChannelNameSurroundRight
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the SurroundRight channel.
 */
#define kIOAudioControlChannelNameSurroundRight		"SurroundRight"


/*!
 * @defined kIOAudioControlValueKey
 * @abstract The key in the IORegistry for the IOAudioControl value attribute.
 * @discussion The value returned by this key is a 32-bit integer representing the current value of the IOAudioControl.
 */
#define kIOAudioControlValueKey				"IOAudioControlValue"

/*!
 * @defined kIOAudioControlValueIsReadOnlyKey
 * @abstract The key in the IORegistry for the IOAudioControl value-is-read-only attribute.
 * @discussion The value returned by this key is a 32-bit integer but the value doesn't have any direct meaning.
 *  Instead, the presence of this key indicates that the value for the control is read-only
 */
#define kIOAudioControlValueIsReadOnlyKey	"IOAudioControlValueIsReadOnly"

/*!
 * @defined kIOAudioLevelControlMinValueKey
 * @abstract The key in the IORegistry for the IOAudioControl minimum value attribute.
 * @discussion The value returned by this key is a 32-bit integer representing the minimum value for the IOAudioControl.
 *  This is currently only valid for Level controls or other driver-defined controls that have a minimum and maximum
 *  value.
 */
#define kIOAudioLevelControlMinValueKey		"IOAudioLevelControlMinValue"

/*!
 * @defined kIOAudioLevelControlMaxValueKey
 * @abstract The key in the IORegistry for the IOAudioControl maximum value attribute.
 * @discussion The value returned by this key is a 32-bit integer representing the maximum value for the IOAudioControl.
 *  This is currently only valid for Level controls or other driver-defined controls that have a minimum and maximum
 *  value.
 */
#define kIOAudioLevelControlMaxValueKey		"IOAudioLevelControlMaxValue"

/*!
 * @defined kIOAudioLevelControlMinDBKey
 * @abstract The key in the IORgistry for the IOAudioControl minimum db value attribute.
 * @discussion The value returned by this key is a fixed point value in 16.16 format represented as a 32-bit
 *  integer.  It represents the minimum value in db for the IOAudioControl.  This value matches the minimum
 *  value attribute.  This is currently valid for Level controls or other driver-defined controls that have a
 *  minimum and maximum db value.
 */
#define kIOAudioLevelControlMinDBKey		"IOAudioLevelControlMinDB"

/*!
 * @defined kIOAudioLevelControlMaxDBKey
 * @abstract The key in the IORgistry for the IOAudioControl maximum db value attribute.
 * @discussion The value returned by this key is a fixed point value in 16.16 format represented as a 32-bit
 *  integer.  It represents the maximum value in db for the IOAudioControl.  This value matches the maximum
 *  value attribute.  This is currently valid for Level controls or other driver-defined controls that have a
 *  minimum and maximum db value.
 */
#define kIOAudioLevelControlMaxDBKey		"IOAudioLevelControlMaxDB"

#define kIOAudioLevelControlRangesKey		"IOAudioLevelControlRanges"

#define kIOAudioLevelControlUseLinearScale	"IOAudioLevelControlUseLinearScale"

#define kIOAudioSelectorControlAvailableSelectionsKey	"IOAudioSelectorControlAvailableSelections"
#define kIOAudioSelectorControlSelectionValueKey		"IOAudioSelectorControlSelectionValue"
#define kIOAudioSelectorControlSelectionDescriptionKey	"IOAudioSelectorControlSelectionDescriptionKey"
#define kIOAudioSelectorControlTransportValueKey		"IOAudioSelectorControlTransportValue"					// <rdar://8202424>

#define kIOAudioSelectorControlClockSourceKey			"IOAudioSelectorControlClockSourceKey"


#endif /* _IOAUDIODEFINES_H */
                                                                                                                                                                                                                                                                IOAudioLib.h                                                                                        0100644 0001750 0001750 00000004127 12566177313 034004  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/audio                                                                 /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 */

/*!
 * @header IOAudioLib
 * C interface to IOAudio functions
 */

#ifndef _IOAUDIOLIB_H
#define _IOAUDIOLIB_H

#include <IOKit/audio/IOAudioTypes.h>

#if 0

#ifdef __cplusplus
extern "C" {
#endif

/*!
 * @function IOAudioIsOutput
 * @abstract Determines if the audio stream is an output stream
 * @param service
 * @param out
 * @result kern_return_t
 */
kern_return_t IOAudioIsOutput(io_service_t service, int *out);

/*!
 * @function IOAudioFlush
 * @abstract Indicate the position at which the audio stream can be stopped.
 * @param connect the audio stream
 * @param end the position
 * @result kern_return_t
 */
kern_return_t IOAudioFlush(io_connect_t connect, IOAudioStreamPosition *end);

/*!
 * @function IOAudioSetErase
 * @abstract Set autoerase flag, returns old value
 * @param connect the audio stream
 * @param erase true to turn off, false otherwise
 * @param oldVal previous value
 * @result kern_return_t
 */
kern_return_t IOAudioSetErase(io_connect_t connect, int erase, int *oldVal);

#ifdef __cplusplus
}
#endif

#endif /* 0 */

#endif /* ! _IOAUDIOLIB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                         IOAudioTypes.h                                                                                      0100644 0001750 0001750 00000061632 12567452612 034405  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/audio                                                                 /*
 * Copyright (c) 1998-2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOTYPES_H
#define _IOKIT_IOAUDIOTYPES_H

#include <libkern/OSTypes.h>
#include <mach/message.h>


/*!
 * @enum IOAudioEngineMemory
 * @abstract Used to identify the type of memory requested by a client process to be mapped into its process space
 * @discussion This is the parameter to the type field of IOMapMemory when called on an IOAudioEngine.  This is
 *  only intended for use by the Audio Device API library.
 * @constant kIOAudioSampleBuffer This requests the IOAudioEngine's sample buffer
 * @constant kIOAudioStatusBuffer This requests the IOAudioEngine's status buffer.  It's type is IOAudioEngineStatus.
 * @constant kIOAudioMixBuffer This requests the IOAudioEngine's mix buffer
*/
typedef enum _IOAudioEngineMemory {
    kIOAudioStatusBuffer 			= 0,
    kIOAudioSampleBuffer			= 1,
    kIOAudioMixBuffer				= 2,
	kIOAudioBytesInInputBuffer		= 3,
	kIOAudioBytesInOutputBuffer		= 4
} IOAudioEngineMemory;

/*!
 * @enum IOAudioEngineCalls
 * @abstract The set of constants passed to IOAudioEngineUserClient::getExternalMethodForIndex() when making calls
 *  from the IOAudioFamily user client code.
 */
typedef enum _IOAudioEngineCalls {
    kIOAudioEngineCallRegisterClientBuffer			= 0,
    kIOAudioEngineCallUnregisterClientBuffer		= 1,
    kIOAudioEngineCallGetConnectionID				= 2,
    kIOAudioEngineCallStart							= 3,
    kIOAudioEngineCallStop							= 4,
	kIOAudioEngineCallGetNearestStartTime			= 5
} IOAudioEngineCalls;

/*! @defined kIOAudioEngineNumCalls The number of elements in the IOAudioEngineCalls enum. */
#define kIOAudioEngineNumCalls		6

typedef enum _IOAudioEngineTraps {
    kIOAudioEngineTrapPerformClientIO				= 0
} IOAudioEngineTraps;

typedef enum _IOAudioEngineNotifications {
    kIOAudioEngineAllNotifications 					= 0,
    kIOAudioEngineStreamFormatChangeNotification	= 1,
    kIOAudioEngineChangeNotification 				= 2,
    kIOAudioEngineStartedNotification 				= 3,
    kIOAudioEngineStoppedNotification 				= 4,
    kIOAudioEnginePausedNotification				= 5,
    kIOAudioEngineResumedNotification				= 6
} IOAudioEngineNotifications;

/*!
 * @enum IOAudioEngineState
 * @abstract Represents the state of an IOAudioEngine
 * @constant kIOAudioEngineRunning The IOAudioEngine is currently running - it is transferring data to or 
 *           from the device.
 * @constant kIOAudioEngineStopped The IOAudioEngine is currently stopped - no activity is occurring.
 */

typedef enum _IOAudioEngineState {
    kIOAudioEngineStopped							= 0,
    kIOAudioEngineRunning							= 1,
    kIOAudioEnginePaused							= 2,
    kIOAudioEngineResumed							= 3
} IOAudioEngineState;


/*!
 * @typedef