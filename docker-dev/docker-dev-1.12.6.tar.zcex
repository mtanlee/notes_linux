, uint64_t Size,
                                  int TagType, void *TagBuf);

/**
 * The initial support in LLVM MC for the most general form of a relocatable
 * expression is "AddSymbol - SubtractSymbol + Offset".  For some Darwin targets
 * this full form is encoded in the relocation information so that AddSymbol and
 * SubtractSymbol can be link edited independent of each other.  Many other
 * platforms only allow a relocatable expression of the form AddSymbol + Offset
 * to be encoded.
 * 
 * The LLVMOpInfoCallback() for the TagType value of 1 uses the struct
 * LLVMOpInfo1.  The value of the relocatable expression for the operand,
 * including any PC adjustment, is passed in to the call back in the Value
 * field.  The symbolic information about the operand is returned using all
 * the fields of the structure with the Offset of the relocatable expression
 * returned in the Value field.  It is possible that some symbols in the
 * relocatable expression were assembly temporary symbols, for example
 * "Ldata - LpicBase + constant", and only the Values of the symbols without
 * symbol names are present in the relocation information.  The VariantKind
 * type is one of the Target specific #defines below and is used to print
 * operands like "_foo@GOT", ":lower16:_foo", etc.
 */
struct LLVMOpInfoSymbol1 {
  uint64_t Present;  /* 1 if this symbol is present */
  const char *Name;  /* symbol name if not NULL */
  uint64_t Value;    /* symbol value if name is NULL */
};

struct LLVMOpInfo1 {
  struct LLVMOpInfoSymbol1 AddSymbol;
  struct LLVMOpInfoSymbol1 SubtractSymbol;
  uint64_t Value;
  uint64_t VariantKind;
};

/**
 * The operand VariantKinds for symbolic disassembly.
 */
#define LLVMDisassembler_VariantKind_None 0 /* all targets */

/**
 * The ARM target VariantKinds.
 */
#define LLVMDisassembler_VariantKind_ARM_HI16 1 /* :upper16: */
#define LLVMDisassembler_VariantKind_ARM_LO16 2 /* :lower16: */

/**
 * The ARM64 target VariantKinds.
 */
#define LLVMDisassembler_VariantKind_ARM64_PAGE       1 /* @page */
#define LLVMDisassembler_VariantKind_ARM64_PAGEOFF    2 /* @pageoff */
#define LLVMDisassembler_VariantKind_ARM64_GOTPAGE    3 /* @gotpage */
#define LLVMDisassembler_VariantKind_ARM64_GOTPAGEOFF 4 /* @gotpageoff */
#define LLVMDisassembler_VariantKind_ARM64_TLVP       5 /* @tvlppage */
#define LLVMDisassembler_VariantKind_ARM64_TLVOFF     6 /* @tvlppageoff */

/**
 * The type for the symbol lookup function.  This may be called by the
 * disassembler for things like adding a comment for a PC plus a constant
 * offset load instruction to use a symbol name instead of a load address value.
 * It is passed the block information is saved when the disassembler context is
 * created and the ReferenceValue to look up as a symbol.  If no symbol is found
 * for the ReferenceValue NULL is returned.  The ReferenceType of the
 * instruction is passed indirectly as is the PC of the instruction in
 * ReferencePC.  If the output reference can be determined its type is returned
 * indirectly in ReferenceType along with ReferenceName if any, or that is set
 * to NULL.
 */
typedef const char *(*LLVMSymbolLookupCallback)(void *DisInfo,
                                                uint64_t ReferenceValue,
                                                uint64_t *ReferenceType,
                                                uint64_t ReferencePC,
                                                const char **ReferenceName);
/**
 * The reference types on input and output.
 */
/* No input reference type or no output reference type. */
#define LLVMDisassembler_ReferenceType_InOut_None 0

/* The input reference is from a branch instruction. */
#define LLVMDisassembler_ReferenceType_In_Branch 1
/* The input reference is from a PC relative load instruction. */
#define LLVMDisassembler_ReferenceType_In_PCrel_Load 2

/* The input reference is from an ARM64::ADRP instruction. */
#define LLVMDisassembler_ReferenceType_In_ARM64_ADRP 0x100000001
/* The input reference is from an ARM64::ADDXri instruction. */
#define LLVMDisassembler_ReferenceType_In_ARM64_ADDXri 0x100000002
/* The input reference is from an ARM64::LDRXui instruction. */
#define LLVMDisassembler_ReferenceType_In_ARM64_LDRXui 0x100000003
/* The input reference is from an ARM64::LDRXl instruction. */
#define LLVMDisassembler_ReferenceType_In_ARM64_LDRXl 0x100000004
/* The input reference is from an ARM64::ADR instruction. */
#define LLVMDisassembler_ReferenceType_In_ARM64_ADR 0x100000005

/* The output reference is to as symbol stub. */
#define LLVMDisassembler_ReferenceType_Out_SymbolStub 1
/* The output reference is to a symbol address in a literal pool. */
#define LLVMDisassembler_ReferenceType_Out_LitPool_SymAddr 2
/* The output reference is to a cstring address in a literal pool. */
#define LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr 3

/* The output reference is to a Objective-C CoreFoundation string. */
#define LLVMDisassembler_ReferenceType_Out_Objc_CFString_Ref 4
/* The output reference is to a Objective-C message. */
#define LLVMDisassembler_ReferenceType_Out_Objc_Message 5
/* The output reference is to a Objective-C message ref. */
#define LLVMDisassembler_ReferenceType_Out_Objc_Message_Ref 6
/* The output reference is to a Objective-C selector ref. */
#define LLVMDisassembler_ReferenceType_Out_Objc_Selector_Ref 7
/* The output reference is to a Objective-C class ref. */
#define LLVMDisassembler_ReferenceType_Out_Objc_Class_Ref 8

/* The output reference is to a C++ symbol name. */
#define LLVMDisassembler_ReferenceType_DeMangled_Name 9

#ifdef __cplusplus
extern "C" {
#endif /* !defined(__cplusplus) */

/**
 * Create a disassembler for the TripleName.  Symbolic disassembly is supported
 * by passing a block of information in the DisInfo parameter and specifying the
 * TagType and callback functions as described above.  These can all be passed
 * as NULL.  If successful, this returns a disassembler context.  If not, it
 * returns NULL. This function is equivalent to calling LLVMCreateDisasmCPU()
 * with an empty CPU name.
 */
LLVMDisasmContextRef LLVMCreateDisasm(const char *TripleName, void *DisInfo,
                                      int TagType, LLVMOpInfoCallback GetOpInfo,
                                      LLVMSymbolLookupCallback SymbolLookUp);

/**
 * Create a disassembler for the TripleName and a specific CPU.  Symbolic
 * disassembly is supported by passing a block of information in the DisInfo
 * parameter and specifying the TagType and callback functions as described
 * above.  These can all be passed * as NULL.  If successful, this returns a
 * disassembler context.  If not, it returns NULL.
 */
LLVMDisasmContextRef LLVMCreateDisasmCPU(const char *Triple, const char *CPU,
                                         void *DisInfo, int TagType,
                                         LLVMOpInfoCallback GetOpInfo,
                                         LLVMSymbolLookupCallback SymbolLookUp);

/**
 * Set the disassembler's options.  Returns 1 if it can set the Options and 0
 * otherwise.
 */
int LLVMSetDisasmOptions(LLVMDisasmContextRef DC, uint64_t Options);

/* The option to produce marked up assembly. */
#define LLVMDisassembler_Option_UseMarkup 1
/* The option to print immediates as hex. */
#define LLVMDisassembler_Option_PrintImmHex 2
/* The option use the other assembler printer variant */
#define LLVMDisassembler_Option_AsmPrinterVariant 4
/* The option to set comment on instructions */
#define LLVMDisassembler_Option_SetInstrComments 8
  /* The option to print latency information alongside instructions */
#define LLVMDisassembler_Option_PrintLatency 16

/**
 * Dispose of a disassembler context.
 */
void LLVMDisasmDispose(LLVMDisasmContextRef DC);

/**
 * Disassemble a single instruction using the disassembler context specified in
 * the parameter DC.  The bytes of the instruction are specified in the
 * parameter Bytes, and contains at least BytesSize number of bytes.  The
 * instruction is at the address specified by the PC parameter.  If a valid
 * instruction can be disassembled, its string is returned indirectly in
 * OutString whose size is specified in the parameter OutStringSize.  This
 * function returns the number of bytes in the instruction or zero if there was
 * no valid instruction.
 */
size_t LLVMDisasmInstruction(LLVMDisasmContextRef DC, uint8_t *Bytes,
                             uint64_t BytesSize, uint64_t Pc,
                             char *OutString, size_t OutStringSize);

/**
 * @}
 */

#ifdef __cplusplus
}
#endif /* !defined(__cplusplus) */

#endif /* !defined(LLVM_C_DISASSEMBLER_H) */
                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/                               0040755 0001750 0001750 00000000000 12612724206 022776  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/arm/                           0040755 0001750 0001750 00000000000 12612724206 023555  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/arm/_structs.h                 0100644 0001750 0001750 00000006624 12612724206 025601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2007 Apple Inc. All rights reserved.
 */
/*
 * @OSF_COPYRIGHT@
 */
#ifndef	_MACH_ARM__STRUCTS_H_
#define	_MACH_ARM__STRUCTS_H_

#define _STRUCT_ARM_EXCEPTION_STATE	struct __darwin_arm_exception_state
_STRUCT_ARM_EXCEPTION_STATE
{
	__uint32_t	__exception; /* number of arm exception taken */
	__uint32_t	__fsr; /* Fault status */
	__uint32_t	__far; /* Virtual Fault Address */
};

#define _STRUCT_ARM_EXCEPTION_STATE64	struct __darwin_arm_exception_state64
_STRUCT_ARM_EXCEPTION_STATE64
{
	__uint64_t	__far; /* Virtual Fault Address */
	__uint32_t	__esr; /* Exception syndrome */
	__uint32_t	__exception; /* number of arm exception taken */
};

#define _STRUCT_ARM_THREAD_STATE	struct __darwin_arm_thread_state
_STRUCT_ARM_THREAD_STATE
{
	__uint32_t	__r[13];	/* General purpose register r0-r12 */
	__uint32_t	__sp;		/* Stack pointer r13 */
	__uint32_t	__lr;		/* Link register r14 */
	__uint32_t	__pc;		/* Program counter r15 */
	__uint32_t	__cpsr;		/* Current program status register */
};

#define _STRUCT_ARM_THREAD_STATE64	struct __darwin_arm_thread_state64
_STRUCT_ARM_THREAD_STATE64
{
	__uint64_t    __x[29];	/* General purpose registers x0-x28 */
	__uint64_t    __fp;		/* Frame pointer x29 */
	__uint64_t    __lr;		/* Link register x30 */
	__uint64_t    __sp;		/* Stack pointer x31 */
	__uint64_t    __pc;		/* Program counter */
	__uint32_t    __cpsr;	/* Current program status register */
};

#define _STRUCT_ARM_VFP_STATE		struct __darwin_arm_vfp_state
_STRUCT_ARM_VFP_STATE
{
	__uint32_t        __r[64];
	__uint32_t        __fpscr;

};

#define _STRUCT_ARM_NEON_STATE64		struct __darwin_arm_neon_state64
#define _STRUCT_ARM_NEON_STATE		struct __darwin_arm_neon_state

#if defined(__arm64__)
_STRUCT_ARM_NEON_STATE64
{
	__uint128_t       __v[32];
	__uint32_t        __fpsr;
	__uint32_t        __fpcr;
};

_STRUCT_ARM_NEON_STATE
{
	__uint128_t       __v[16];
	__uint32_t        __fpsr;
	__uint32_t        __fpcr;
};

#elif defined(__arm__)
/*
 * No 128-bit intrinsic for ARM; leave it opaque for now.
 */
_STRUCT_ARM_NEON_STATE64 
{
	char opaque[(32 * 16) + (2 * sizeof(__uint32_t))];
} __attribute__((aligned(16)));

_STRUCT_ARM_NEON_STATE
{
	char opaque[(16 * 16) + (2 * sizeof(__uint32_t))];
} __attribute__((aligned(16)));

#else
/* #error Unknown architecture. */
#endif


/*
 * Debug State
 */
#if defined(__arm__)
#define _STRUCT_ARM_DEBUG_STATE	struct __darwin_arm_debug_state
_STRUCT_ARM_DEBUG_STATE
{
	__uint32_t        __bvr[16];
	__uint32_t        __bcr[16];
	__uint32_t        __wvr[16];
	__uint32_t        __wcr[16];
};

#elif defined(__arm64__)
#define _STRUCT_ARM_LEGACY_DEBUG_STATE	struct arm_legacy_debug_state
_STRUCT_ARM_LEGACY_DEBUG_STATE
{
	__uint32_t        __bvr[16];
	__uint32_t        __bcr[16];
	__uint32_t        __wvr[16];
	__uint32_t        __wcr[16];
};

#define _STRUCT_ARM_DEBUG_STATE32	struct __darwin_arm_debug_state32
_STRUCT_ARM_DEBUG_STATE32
{
	__uint32_t        __bvr[16];
	__uint32_t        __bcr[16];
	__uint32_t        __wvr[16];
	__uint32_t        __wcr[16];
	__uint64_t	  __mdscr_el1; /* Bit 0 is SS (Hardware Single Step) */
};

#define _STRUCT_ARM_DEBUG_STATE64	struct __darwin_arm_debug_state64
_STRUCT_ARM_DEBUG_STATE64
{
	__uint64_t        __bvr[16];
	__uint64_t        __bcr[16];
	__uint64_t        __wvr[16];
	__uint64_t        __wcr[16];
	__uint64_t	  __mdscr_el1; /* Bit 0 is SS (Hardware Single Step) */
};

#else
/* #error unknown architecture */
#endif

#endif /* _MACH_ARM__STRUCTS_H_ */
                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/arm/thread_state.h             0100644 0001750 0001750 00000000644 12612724206 026376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef _MACH_ARM_THREAD_STATE_H_
#define _MACH_ARM_THREAD_STATE_H_

#define ARM_THREAD_STATE_MAX	(272)

#if defined (__arm__)
#define THREAD_STATE_MAX	ARM_THREAD_STATE_MAX
#endif

#if defined(__arm64__) && !defined(THREAD_STATE_MAX)
#define THREAD_STATE_MAX	ARM_THREAD_STATE_MAX
#endif

#endif	/* _MACH_ARM_THREAD_STATE_H_ */
                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/arm/thread_status.h            0100644 0001750 0001750 00000032507 12612724206 026604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2007 Apple Inc. All rights reserved.
 */
/*
 * FILE_ID: thread_status.h
 */


#ifndef _ARM_THREAD_STATUS_H_
#define _ARM_THREAD_STATUS_H_

#include <mach/arm/_structs.h>
#include <mach/message.h>
#include <mach/arm/thread_state.h>

/*
 *    Support for determining the state of a thread
 */


/*
 *  Flavors
 */

#define ARM_THREAD_STATE		1
#define ARM_VFP_STATE			2
#define ARM_EXCEPTION_STATE		3
#define ARM_DEBUG_STATE			4 /* pre-armv8 */
#define THREAD_STATE_NONE		5
#define ARM_THREAD_STATE64		6
#define ARM_EXCEPTION_STATE64	7

/* ARM64_TODO: ref. ARM_SAVED_STATE64.  Separate these namespaces!  */

#ifdef XNU_KERNEL_PRIVATE
#define THREAD_STATE_LAST		8
#endif

/* For kernel use */
#define ARM_SAVED_STATE32		(THREAD_STATE_LAST+1)
#define ARM_SAVED_STATE64		(THREAD_STATE_LAST+2)
#define ARM_NEON_SAVED_STATE32		(THREAD_STATE_LAST+3)
#define ARM_NEON_SAVED_STATE64		(THREAD_STATE_LAST+4)
/* ARM_VFP_STATE64			(THREAD_STATE_LAST+5)  */
/* API */
#define ARM_DEBUG_STATE32		(THREAD_STATE_LAST+6)
#define ARM_DEBUG_STATE64		(THREAD_STATE_LAST+7)
#define ARM_NEON_STATE64		(THREAD_STATE_LAST+9)

#define VALID_THREAD_STATE_FLAVOR(x)\
((x == ARM_THREAD_STATE) 		||	\
 (x == ARM_VFP_STATE) 			||	\
 (x == ARM_EXCEPTION_STATE) 	||	\
 (x == ARM_DEBUG_STATE) 		||	\
 (x == THREAD_STATE_NONE)		||  \
 (x == ARM_NEON_STATE)		||	\
 (x == ARM_DEBUG_STATE32)	||	\
 (x == ARM_THREAD_STATE64)		||	\
 (x == ARM_EXCEPTION_STATE64)	||	\
 (x == ARM_NEON_STATE64)		||	\
 (x == ARM_DEBUG_STATE64))

typedef _STRUCT_ARM_THREAD_STATE		arm_thread_state_t;
typedef _STRUCT_ARM_THREAD_STATE64		arm_thread_state64_t;
typedef _STRUCT_ARM_VFP_STATE			arm_vfp_state_t;
typedef _STRUCT_ARM_NEON_STATE			arm_neon_state_t;
typedef _STRUCT_ARM_NEON_STATE64		arm_neon_state64_t;
typedef _STRUCT_ARM_EXCEPTION_STATE		arm_exception_state_t;
typedef _STRUCT_ARM_EXCEPTION_STATE64	arm_exception_state64_t;

#if defined(XNU_KERNEL_PRIVATE) && defined(__arm64__)
/* See below for ARM64 kernel structure definition for arm_debug_state. */
#else
/*
 * Otherwise not ARM64 kernel and we must preserve legacy ARM definitions of
 * arm_debug_state for binary compatability of userland consumers of this file.
 */
#if defined(__arm__)
typedef _STRUCT_ARM_DEBUG_STATE			arm_debug_state_t;
#elif defined(__arm64__)
typedef _STRUCT_ARM_LEGACY_DEBUG_STATE		arm_debug_state_t;
#else
/* #error Undefined architecture */
#endif
#endif

#define ARM_THREAD_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_thread_state_t)/sizeof(uint32_t)))

#define ARM_THREAD_STATE64_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_thread_state64_t)/sizeof(uint32_t)))

#define ARM_VFP_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_vfp_state_t)/sizeof(uint32_t)))

#define ARM_EXCEPTION_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_exception_state_t)/sizeof(uint32_t)))

#define ARM_EXCEPTION_STATE64_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_exception_state64_t)/sizeof(uint32_t)))

#define ARM_DEBUG_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_debug_state_t)/sizeof(uint32_t)))

#define MACHINE_THREAD_STATE ARM_THREAD_STATE64
#define MACHINE_THREAD_STATE_COUNT  ARM_THREAD_STATE_COUNT64

/*
 * Largest state on this machine:
 */
#define THREAD_MACHINE_STATE_MAX	THREAD_STATE_MAX

#ifdef XNU_KERNEL_PRIVATE

#if defined(__arm__)

#define ARM_SAVED_STATE			THREAD_STATE_NONE + 1

struct arm_saved_state {
    uint32_t    r[13];      /* General purpose register r0-r12 */
    uint32_t    sp;     /* Stack pointer r13 */
    uint32_t    lr;     /* Link register r14 */
    uint32_t    pc;     /* Program counter r15 */
    uint32_t    cpsr;       /* Current program status register */
    uint32_t    fsr;        /* Fault status */
    uint32_t    far;        /* Virtual Fault Address */
    uint32_t    exception;  /* exception number */
};
typedef struct arm_saved_state arm_saved_state_t;

#ifdef XNU_KERNEL_PRIVATE
typedef struct arm_saved_state arm_saved_state32_t;

/*
 * Just for coexistence with AArch64 code.
 */
static inline arm_saved_state32_t*
saved_state32(arm_saved_state_t *iss)
{
    return iss;
}

static inline boolean_t
is_saved_state32(arm_saved_state_t *iss __unused)
{
    return TRUE;
}

#endif

struct arm_saved_state_tagged {
	uint32_t					tag;
	struct arm_saved_state		state;
};
typedef struct arm_saved_state_tagged arm_saved_state_tagged_t;

#define ARM_SAVED_STATE32_COUNT ((mach_msg_type_number_t) \
		(sizeof (arm_saved_state_t)/sizeof(unsigned int)))

#elif defined(__arm64__)

#include <kern/assert.h>
#include <arm64/proc_reg.h>
#define CAST_ASSERT_SAFE(type, val) (assert((val) == ((type)(val))), (type)(val))

/*
 * GPR context
 */


struct arm_saved_state32 {
	uint32_t	r[13];		/* General purpose register r0-r12 */
	uint32_t	sp;			/* Stack pointer r13 */
	uint32_t	lr;			/* Link register r14 */
	uint32_t	pc;			/* Program counter r15 */
	uint32_t	cpsr;		/* Current program status register */
	uint32_t	far;		/* Virtual fault address */
	uint32_t	esr;		/* Exception syndrome register */
	uint32_t	exception;	/* Exception number */
};
typedef struct arm_saved_state32 arm_saved_state32_t;

struct arm_saved_state32_tagged {
	uint32_t					tag;
	struct arm_saved_state32	state;
};
typedef struct arm_saved_state32_tagged arm_saved_state32_tagged_t;

#define ARM_SAVED_STATE32_COUNT ((mach_msg_type_number_t) \
		(sizeof (arm_saved_state32_t)/sizeof(unsigned int)))

struct arm_saved_state64 {
	uint64_t    x[29];		/* General purpose registers x0-x28 */
	uint64_t    fp;			/* Frame pointer x29 */
	uint64_t    lr;			/* Link register x30 */
	uint64_t    sp;			/* Stack pointer x31 */
	uint64_t    pc;			/* Program counter */
	uint32_t    cpsr;		/* Current program status register */
	uint32_t	reserved;	/* Reserved padding */
	uint64_t	far;		/* Virtual fault address */
	uint32_t	esr;		/* Exception syndrome register */
	uint32_t	exception;	/* Exception number */
};
typedef struct arm_saved_state64 arm_saved_state64_t;

#define ARM_SAVED_STATE64_COUNT ((mach_msg_type_number_t) \
		(sizeof (arm_saved_state64_t)/sizeof(unsigned int)))

struct arm_saved_state64_tagged {
	uint32_t					tag;
	struct arm_saved_state64	state;
};
typedef struct arm_saved_state64_tagged arm_saved_state64_tagged_t;

struct arm_saved_state {
	uint32_t	flavor;
	union {
		struct arm_saved_state32 ss_32;
		struct arm_saved_state64 ss_64;
	} uss;
} __attribute__((aligned(16)));
#define	ss_32	uss.ss_32
#define	ss_64	uss.ss_64

typedef struct arm_saved_state arm_saved_state_t;


static inline boolean_t
is_saved_state32(arm_saved_state_t *iss)
{
	return (iss->flavor == ARM_SAVED_STATE32);
}

static inline boolean_t
is_saved_state64(arm_saved_state_t *iss)
{
	return (iss->flavor == ARM_SAVED_STATE64);
}

static inline arm_saved_state32_t*
saved_state32(arm_saved_state_t *iss)
{
	return &iss->ss_32;
}

static inline arm_saved_state64_t*
saved_state64(arm_saved_state_t *iss)
{
	return &iss->ss_64;
}

static inline register_t
get_saved_state_pc(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->pc : saved_state64(iss)->pc);
}

static inline void
set_saved_state_pc(arm_saved_state_t *iss, register_t pc)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->pc = CAST_ASSERT_SAFE(uint32_t, pc);
	} else {
		saved_state64(iss)->pc = pc;
	}
}

static inline register_t
get_saved_state_sp(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->sp : saved_state64(iss)->sp);
}

static inline void
set_saved_state_sp(arm_saved_state_t *iss, register_t sp)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->sp = CAST_ASSERT_SAFE(uint32_t, sp);
	} else {
		saved_state64(iss)->sp = sp;
	}
}

static inline register_t
get_saved_state_lr(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->lr : saved_state64(iss)->lr);
}

static inline void
set_saved_state_lr(arm_saved_state_t *iss, register_t lr)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->lr = CAST_ASSERT_SAFE(uint32_t, lr);
	} else {
		saved_state64(iss)->lr = lr;
	}
}

static inline register_t
get_saved_state_fp(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->r[7] : saved_state64(iss)->fp);
}

static inline void
set_saved_state_fp(arm_saved_state_t *iss, register_t fp)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->r[7] = CAST_ASSERT_SAFE(uint32_t, fp);
	} else {
		saved_state64(iss)->fp = fp;
	}
}

static inline int
check_saved_state_reglimit(arm_saved_state_t *iss, unsigned reg) 
{
	return (is_saved_state32(iss) ? (reg < ARM_SAVED_STATE32_COUNT) : (reg < ARM_SAVED_STATE64_COUNT));
}

static inline register_t
get_saved_state_reg(arm_saved_state_t *iss, unsigned reg)
{
	if (!check_saved_state_reglimit(iss, reg)) return 0;

	return (is_saved_state32(iss) ? (saved_state32(iss)->r[reg]) : (saved_state64(iss)->x[reg]));
}

static inline void
set_saved_state_reg(arm_saved_state_t *iss, unsigned reg, register_t value)
{
	if (!check_saved_state_reglimit(iss, reg)) return;

	if (is_saved_state32(iss)) {
		saved_state32(iss)->r[reg] = CAST_ASSERT_SAFE(uint32_t, value);
	} else {
		saved_state64(iss)->x[reg] = value;
	}
}

static inline uint32_t
get_saved_state_cpsr(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->cpsr : saved_state64(iss)->cpsr);
}

static inline void
set_saved_state_cpsr(arm_saved_state_t *iss, uint32_t cpsr)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->cpsr = cpsr;
	} else {
		saved_state64(iss)->cpsr = cpsr;
	}
}

static inline register_t
get_saved_state_far(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->far : saved_state64(iss)->far);
}

static inline void
set_saved_state_far(arm_saved_state_t *iss, register_t far)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->far = CAST_ASSERT_SAFE(uint32_t, far);
	} else {
		saved_state64(iss)->far = far;
	}
}

static inline uint32_t
get_saved_state_esr(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->esr : saved_state64(iss)->esr);
}

static inline void
set_saved_state_esr(arm_saved_state_t *iss, uint32_t esr)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->esr = esr;
	} else {
		saved_state64(iss)->esr = esr;
	}
}

static inline uint32_t
get_saved_state_exc(arm_saved_state_t *iss)
{
	return (is_saved_state32(iss) ? saved_state32(iss)->exception : saved_state64(iss)->exception);
}

static inline void
set_saved_state_exc(arm_saved_state_t *iss, uint32_t exc)
{
	if (is_saved_state32(iss)) {
		saved_state32(iss)->exception = exc;
	} else {
		saved_state64(iss)->exception = exc;
	}
}

/*
 * ARM64_TODO: what register holds syscall number?
 */
extern void panic_unimplemented(void);

static inline int
get_saved_state_svc_number(arm_saved_state_t *iss) 
{
	return (is_saved_state32(iss) ? (int)saved_state32(iss)->r[12] : (int)saved_state64(iss)->x[ARM64_SYSCALL_CODE_REG_NUM]); /* Only first word counts here */
}


typedef _STRUCT_ARM_LEGACY_DEBUG_STATE		arm_legacy_debug_state_t;
typedef _STRUCT_ARM_DEBUG_STATE32		arm_debug_state32_t;
typedef _STRUCT_ARM_DEBUG_STATE64		arm_debug_state64_t;

struct arm_state_hdr {
    int flavor;
    int count;
};
typedef struct arm_state_hdr arm_state_hdr_t;

struct arm_debug_aggregate_state {
    arm_state_hdr_t         dsh;
    union {
        arm_debug_state32_t ds32;
        arm_debug_state64_t ds64;
    } uds;
} __attribute__((aligned(16)));

typedef struct arm_debug_aggregate_state arm_debug_state_t;

#define ARM_LEGACY_DEBUG_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_legacy_debug_state_t)/sizeof(uint32_t)))

#define ARM_DEBUG_STATE32_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_debug_state32_t)/sizeof(uint32_t)))

#define ARM_DEBUG_STATE64_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_debug_state64_t)/sizeof(uint32_t)))

/*
 * NEON context
 */
typedef __uint128_t uint128_t;
typedef uint64_t uint64x2_t __attribute__((ext_vector_type(2)));
typedef uint32_t uint32x4_t __attribute__((ext_vector_type(4)));

struct arm_neon_saved_state32 {
	union {
		uint128_t	q[16];
		uint64_t	d[32];
		uint32_t	s[32];
	} v;
	uint32_t		fpsr;
	uint32_t		fpcr;
};
typedef struct arm_neon_saved_state32 arm_neon_saved_state32_t;

struct arm_neon_saved_state64 {
	union {
		uint128_t		q[32];
		uint64x2_t		d[32];
		uint32x4_t		s[32];
	} v;
	uint32_t		fpsr;
	uint32_t		fpcr;
};
typedef struct arm_neon_saved_state64 arm_neon_saved_state64_t;


#define ARM_NEON_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_neon_state_t)/sizeof(uint32_t)))
#define ARM_NEON_STATE64_COUNT ((mach_msg_type_number_t) \
   (sizeof (arm_neon_state64_t)/sizeof(uint32_t)))

struct arm_neon_saved_state {
	uint32_t flavor;
	union {
		struct arm_neon_saved_state32 ns_32;
		struct arm_neon_saved_state64 ns_64;
	} uns;
};
typedef struct arm_neon_saved_state arm_neon_saved_state_t;
#define	ns_32	uns.ns_32
#define	ns_64	uns.ns_64

static inline boolean_t
is_neon_saved_state32(arm_neon_saved_state_t *state)
{
	return (state->flavor == ARM_NEON_SAVED_STATE32);
}

static inline boolean_t
is_neon_saved_state64(arm_neon_saved_state_t *state)
{
	return (state->flavor == ARM_NEON_SAVED_STATE64);
}

static inline arm_neon_saved_state32_t *
neon_state32(arm_neon_saved_state_t *state)
{
	return &state->ns_32;
}

static inline arm_neon_saved_state64_t *
neon_state64(arm_neon_saved_state_t *state)
{
	return &state->ns_64;
}


/*
 * Aggregated context
 */

struct arm_context {
	struct arm_saved_state ss;
	struct arm_neon_saved_state ns;
};
typedef struct arm_context arm_context_t;

#else
#error Unknown arch
#endif

#endif /* XNU_KERNEL_PRIVATE */

#endif    /* _ARM_THREAD_STATUS_H_ */
                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/hppa/                          0040755 0001750 0001750 00000000000 12612724206 023726  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/hppa/thread_status.h           0100644 0001750 0001750 00000015101 12612724206 026744  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * @HP_COPYRIGHT@
 */
/*
 * HISTORY
 * Revision 1.1.1.1  1997/09/03 20:53:39  roland
 * Initial checkin of SGS release 244
 *
 * Revision 1.4.3.2  1992/01/09  20:05:31  sharpe
 * 	initial 1.1 vers from 1.0
 * 	[1992/01/09  19:29:20  sharpe]
 *
 * Revision 1.4  1991/07/03  17:25:42  osfrcs
 * 	06/19/90 rand       Add THREAD_STATE_FLAVOR_LIST to getstatus
 * 	[91/06/21  17:29:52  brezak]
 * 
 * Revision 1.3.2.2  91/06/21  18:05:17  brezak
 * 	06/19/90 rand       Add THREAD_STATE_FLAVOR_LIST to getstatus
 * 	[91/06/21  17:29:52  brezak]
 * 
 * Revision 1.2.2.2  91/04/30  09:48:00  brezak
 * 	rand         04/19/91 Add options to control reflection of assist/unalign exceptions
 * 	[91/04/29  11:46:12  brezak]
 * 
 * Revision 1.2  91/04/14  20:47:10  osfrcs
 * 	Initial version.
 * 	[91/03/30  09:32:42  brezak]
 * 
 */

#ifndef	_HPPA_THREAD_STATE_ 
#define	_HPPA_THREAD_STATE_

#include <mach/machine/boolean.h>


#define	HPPA_INTEGER_THREAD_STATE     1
#define	HPPA_FRAME_THREAD_STATE     2
#define	HPPA_FP_THREAD_STATE     3

/*
 * Flow control information that can
 * be changed from user state (with
 * some restrictions on psw).
 */
struct hp_pa_frame_thread_state {
	uint32_t	ts_pcsq_front;	/* instruction address space front */
	uint32_t	ts_pcsq_back;	/* instruction address space back */
	uint32_t	ts_pcoq_front;	/* instruction offset space front */
	uint32_t	ts_pcoq_back;	/* instruction offset space back */
	uint32_t	ts_psw;		/* process status word */
	uint32_t	ts_unaligned_faults;	/* number of unaligned data references READ-ONLY */
	uint32_t	ts_fault_address;	/* address of failing page fault READ-ONLY */
/*
 * A step range is a range of address that
 * will be executed with out generating a single
 * step event. If both values are 0 no stepping
 * will occur. Otherwise the program will run while:
 *
 *	if (step_range_start <= step_range_stop)
 *		pcoq0 >= step_range_start && pcoq0 < step_range_stop 
 *	if (step_range_start > step_range_stop)
 *		pcoq0 < step_range_stop && pcoq0 >= step_range_start 
 *
 * notice that setting step_range_start and step_range_stop to the
 * same non-zero value will execute only one instruction due to action
 * of the pc queue. (Yes, nullified instructions count)
 */
	uint32_t	ts_step_range_start;
	uint32_t	ts_step_range_stop;

	/* Generate an exception when OS assists with an alignment fault */
	boolean_t	ts_alignment_trap_reflect;

	/* Generate an exception when OS assists with an FP fault */
	boolean_t	ts_execution_trap_reflect;
};

/*
 * Get rid of as soon as all users of frame_thread_state 
 * have been recompiled. XXX
 */
struct hp_pa_old_frame_thread_state {
	uint32_t	ts_pcsq_front;	/* instruction address space front */
	uint32_t	ts_pcsq_back;	/* instruction address space back */
	uint32_t	ts_pcoq_front;	/* instruction offset space front */
	uint32_t	ts_pcoq_back;	/* instruction offset space back */
	uint32_t	ts_psw;		/* process status word */
};

/*
 * The hp_pa_integer_thread_state that may be changed by any
 * process in user space.
 */
typedef struct hp_pa_integer_thread_state {
	uint32_t	ts_gr1;		/* the user's general registers */
	uint32_t	ts_gr2;
	uint32_t	ts_gr3;
	uint32_t	ts_gr4;
	uint32_t	ts_gr5;
	uint32_t	ts_gr6;
	uint32_t	ts_gr7;
	uint32_t	ts_gr8;
	uint32_t	ts_gr9;
	uint32_t	ts_gr10;
	uint32_t	ts_gr11;
	uint32_t	ts_gr12;
	uint32_t	ts_gr13;
	uint32_t	ts_gr14;
	uint32_t	ts_gr15;
	uint32_t	ts_gr16;
	uint32_t	ts_gr17;
	uint32_t	ts_gr18;
	uint32_t	ts_gr19;
	uint32_t	ts_gr20;
	uint32_t	ts_gr21;
	uint32_t	ts_gr22;
	uint32_t	ts_gr23;
	uint32_t	ts_gr24;
	uint32_t	ts_gr25;
	uint32_t	ts_gr26;
	uint32_t	ts_gr27;
	uint32_t	ts_gr28;
	uint32_t	ts_gr29;
	uint32_t	ts_gr30;
	uint32_t	ts_gr31;
	uint32_t	ts_sr0;		/* the user's space registgers */
	uint32_t	ts_sr1;
	uint32_t	ts_sr2;
	uint32_t	ts_sr3;
	uint32_t	ts_sar;		/* the user's shift amount register */
} hp_pa_integer_thread_state_t;

/*
 * The floating point state that may be changed by any
 * process in user space.
 */
typedef struct hp_pa_fp_thread_state {
	double	ts_fp0;		/* all of the execution unit registers */
	double	ts_fp1;
	double	ts_fp2;
	double	ts_fp3;
	double	ts_fp4;
	double	ts_fp5;
	double	ts_fp6;
	double	ts_fp7;
	double	ts_fp8;
	double	ts_fp9;
	double	ts_fp10;
	double	ts_fp11;
	double	ts_fp12;
	double	ts_fp13;
	double	ts_fp14;
	double	ts_fp15;
	double	ts_fp16;
	double	ts_fp17;
	double	ts_fp18;
	double	ts_fp19;
	double	ts_fp20;
	double	ts_fp21;
	double	ts_fp22;
	double	ts_fp23;
	double	ts_fp24;
	double	ts_fp25;
	double	ts_fp26;
	double	ts_fp27;
	double	ts_fp28;
	double	ts_fp29;
	double	ts_fp30;
	double	ts_fp31;
} hp_pa_fp_thread_state_t;

#define	HPPA_INTEGER_THREAD_STATE_COUNT (sizeof(struct hp_pa_integer_thread_state) / sizeof(uint32_t))
#define	HPPA_FRAME_THREAD_STATE_COUNT (sizeof(struct hp_pa_frame_thread_state) / sizeof(uint32_t))
#define	HPPA_FP_THREAD_STATE_COUNT (sizeof(struct hp_pa_fp_thread_state) / sizeof(uint32_t))

/* Get rid of as soon as all users of thread_frame_state have been recompiled XXX */
#define	HPPA_OLD_FRAME_THREAD_STATE_COUNT (sizeof(struct hp_pa_old_frame_thread_state) / sizeof(uint32_t))

#endif	/* _HPPA_THREAD_STATE_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i386/                          0040755 0001750 0001750 00000000000 12612724206 023467  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i386/_structs.h                0100644 0001750 0001750 00000061321 12612724206 025506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_MACH_I386__STRUCTS_H_
#define	_MACH_I386__STRUCTS_H_

/*
 * i386 is the structure that is exported to user threads for 
 * use in status/mutate calls.  This structure should never change.
 *
 */

#if __DARWIN_UNIX03
#define	_STRUCT_X86_THREAD_STATE32	struct __darwin_i386_thread_state
_STRUCT_X86_THREAD_STATE32
{
    unsigned int	__eax;
    unsigned int	__ebx;
    unsigned int	__ecx;
    unsigned int	__edx;
    unsigned int	__edi;
    unsigned int	__esi;
    unsigned int	__ebp;
    unsigned int	__esp;
    unsigned int	__ss;
    unsigned int	__eflags;
    unsigned int	__eip;
    unsigned int	__cs;
    unsigned int	__ds;
    unsigned int	__es;
    unsigned int	__fs;
    unsigned int	__gs;
};
#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_THREAD_STATE32	struct i386_thread_state
_STRUCT_X86_THREAD_STATE32
{
    unsigned int	eax;
    unsigned int	ebx;
    unsigned int	ecx;
    unsigned int	edx;
    unsigned int	edi;
    unsigned int	esi;
    unsigned int	ebp;
    unsigned int	esp;
    unsigned int	ss;
    unsigned int	eflags;
    unsigned int	eip;
    unsigned int	cs;
    unsigned int	ds;
    unsigned int	es;
    unsigned int	fs;
    unsigned int	gs;
};
#endif /* !__DARWIN_UNIX03 */

/* This structure should be double-word aligned for performance */

#if __DARWIN_UNIX03
#define _STRUCT_FP_CONTROL	struct __darwin_fp_control
_STRUCT_FP_CONTROL
{
    unsigned short		__invalid	:1,
    				__denorm	:1,
				__zdiv		:1,
				__ovrfl		:1,
				__undfl		:1,
				__precis	:1,
						:2,
				__pc		:2,
#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define FP_PREC_24B		0
#define	FP_PREC_53B		2
#define FP_PREC_64B		3
#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */
				__rc		:2,
#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define FP_RND_NEAR		0
#define FP_RND_DOWN		1
#define FP_RND_UP		2
#define FP_CHOP			3
#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */
					/*inf*/	:1,
						:3;
};
typedef _STRUCT_FP_CONTROL	__darwin_fp_control_t;
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_FP_CONTROL	struct fp_control
_STRUCT_FP_CONTROL
{
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
					:2,
				pc	:2,
#define FP_PREC_24B		0
#define	FP_PREC_53B		2
#define FP_PREC_64B		3
				rc	:2,
#define FP_RND_NEAR		0
#define FP_RND_DOWN		1
#define FP_RND_UP		2
#define FP_CHOP			3
				/*inf*/	:1,
					:3;
};
typedef _STRUCT_FP_CONTROL	fp_control_t;
#endif /* !__DARWIN_UNIX03 */

/*
 * Status word.
 */

#if __DARWIN_UNIX03
#define _STRUCT_FP_STATUS	struct __darwin_fp_status
_STRUCT_FP_STATUS
{
    unsigned short		__invalid	:1,
    				__denorm	:1,
				__zdiv		:1,
				__ovrfl		:1,
				__undfl		:1,
				__precis	:1,
				__stkflt	:1,
				__errsumm	:1,
				__c0		:1,
				__c1		:1,
				__c2		:1,
				__tos		:3,
				__c3		:1,
				__busy		:1;
};
typedef _STRUCT_FP_STATUS	__darwin_fp_status_t;
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_FP_STATUS	struct fp_status
_STRUCT_FP_STATUS
{
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
				stkflt	:1,
				errsumm	:1,
				c0	:1,
				c1	:1,
				c2	:1,
				tos	:3,
				c3	:1,
				busy	:1;
};
typedef _STRUCT_FP_STATUS	fp_status_t;
#endif /* !__DARWIN_UNIX03 */
				
/* defn of 80bit x87 FPU or MMX register  */

#if __DARWIN_UNIX03
#define _STRUCT_MMST_REG	struct __darwin_mmst_reg
_STRUCT_MMST_REG
{
	char	__mmst_reg[10];
	char	__mmst_rsrv[6];
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_MMST_REG	struct mmst_reg
_STRUCT_MMST_REG
{
	char	mmst_reg[10];
	char	mmst_rsrv[6];
};
#endif /* !__DARWIN_UNIX03 */


/* defn of 128 bit XMM regs */

#if __DARWIN_UNIX03
#define _STRUCT_XMM_REG		struct __darwin_xmm_reg
_STRUCT_XMM_REG
{
	char		__xmm_reg[16];
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_XMM_REG		struct xmm_reg
_STRUCT_XMM_REG
{
	char		xmm_reg[16];
};
#endif /* !__DARWIN_UNIX03 */

/* 
 * Floating point state.
 */

#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define FP_STATE_BYTES		512	/* number of chars worth of data from fpu_fcw */
#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */

#if __DARWIN_UNIX03
#define	_STRUCT_X86_FLOAT_STATE32	struct __darwin_i386_float_state
_STRUCT_X86_FLOAT_STATE32
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
	__uint16_t		__fpu_rsrv2;		/* reserved */
	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	char			__fpu_rsrv4[14*16];	/* reserved */
	int 			__fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE32	struct __darwin_i386_avx_state
_STRUCT_X86_AVX_STATE32
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
	__uint16_t		__fpu_rsrv2;		/* reserved */
	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	char			__fpu_rsrv4[14*16];	/* reserved */
	int 			__fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_FLOAT_STATE32	struct i386_float_state
_STRUCT_X86_FLOAT_STATE32
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		fpu_ip;			/* x87 FPU Instruction Pointer offset */
	__uint16_t		fpu_cs;			/* x87 FPU Instruction Pointer Selector */
	__uint16_t		fpu_rsrv2;		/* reserved */
	__uint32_t		fpu_dp;			/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		fpu_ds;			/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	char			fpu_rsrv4[14*16];	/* reserved */
	int 			fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE32	struct i386_avx_state
_STRUCT_X86_AVX_STATE32
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		fpu_ip;			/* x87 FPU Instruction Pointer offset */
	__uint16_t		fpu_cs;			/* x87 FPU Instruction Pointer Selector */
	__uint16_t		fpu_rsrv2;		/* reserved */
	__uint32_t		fpu_dp;			/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		fpu_ds;			/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	char			fpu_rsrv4[14*16];	/* reserved */
	int 			fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
};

#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_EXCEPTION_STATE32	struct __darwin_i386_exception_state
_STRUCT_X86_EXCEPTION_STATE32
{
	__uint16_t	__trapno;
	__uint16_t	__cpu;
	__uint32_t	__err;
	__uint32_t	__faultvaddr;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_EXCEPTION_STATE32	struct i386_exception_state
_STRUCT_X86_EXCEPTION_STATE32
{
	__uint16_t	trapno;
	__uint16_t	cpu;
	__uint32_t	err;
	__uint32_t	faultvaddr;
};
#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_DEBUG_STATE32	struct __darwin_x86_debug_state32
_STRUCT_X86_DEBUG_STATE32
{
	unsigned int	__dr0;
	unsigned int	__dr1;
	unsigned int	__dr2;
	unsigned int	__dr3;
	unsigned int	__dr4;
	unsigned int	__dr5;
	unsigned int	__dr6;
	unsigned int	__dr7;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_DEBUG_STATE32	struct x86_debug_state32
_STRUCT_X86_DEBUG_STATE32
{
	unsigned int	dr0;
	unsigned int	dr1;
	unsigned int	dr2;
	unsigned int	dr3;
	unsigned int	dr4;
	unsigned int	dr5;
	unsigned int	dr6;
	unsigned int	dr7;
};
#endif /* !__DARWIN_UNIX03 */

/*
 * 64 bit versions of the above
 */

#if __DARWIN_UNIX03
#define	_STRUCT_X86_THREAD_STATE64	struct __darwin_x86_thread_state64
_STRUCT_X86_THREAD_STATE64
{
	__uint64_t	__rax;
	__uint64_t	__rbx;
	__uint64_t	__rcx;
	__uint64_t	__rdx;
	__uint64_t	__rdi;
	__uint64_t	__rsi;
	__uint64_t	__rbp;
	__uint64_t	__rsp;
	__uint64_t	__r8;
	__uint64_t	__r9;
	__uint64_t	__r10;
	__uint64_t	__r11;
	__uint64_t	__r12;
	__uint64_t	__r13;
	__uint64_t	__r14;
	__uint64_t	__r15;
	__uint64_t	__rip;
	__uint64_t	__rflags;
	__uint64_t	__cs;
	__uint64_t	__fs;
	__uint64_t	__gs;
};
#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_THREAD_STATE64	struct x86_thread_state64
_STRUCT_X86_THREAD_STATE64
{
	__uint64_t	rax;
	__uint64_t	rbx;
	__uint64_t	rcx;
	__uint64_t	rdx;
	__uint64_t	rdi;
	__uint64_t	rsi;
	__uint64_t	rbp;
	__uint64_t	rsp;
	__uint64_t	r8;
	__uint64_t	r9;
	__uint64_t	r10;
	__uint64_t	r11;
	__uint64_t	r12;
	__uint64_t	r13;
	__uint64_t	r14;
	__uint64_t	r15;
	__uint64_t	rip;
	__uint64_t	rflags;
	__uint64_t	cs;
	__uint64_t	fs;
	__uint64_t	gs;
};
#endif /* !__DARWIN_UNIX03 */


#if __DARWIN_UNIX03
#define	_STRUCT_X86_FLOAT_STATE64	struct __darwin_x86_float_state64
_STRUCT_X86_FLOAT_STATE64
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		__fpu_ip;		/* offset */
	__uint16_t		__fpu_cs;		/* Selector */

	__uint16_t		__fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		__fpu_dp;		/* offset */
	__uint16_t		__fpu_ds;		/* Selector */

	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
	char			__fpu_rsrv4[6*16];	/* reserved */
	int 			__fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE64	struct __darwin_x86_avx_state64
_STRUCT_X86_AVX_STATE64
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		__fpu_ip;		/* offset */
	__uint16_t		__fpu_cs;		/* Selector */

	__uint16_t		__fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		__fpu_dp;		/* offset */
	__uint16_t		__fpu_ds;		/* Selector */

	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
	char			__fpu_rsrv4[6*16];	/* reserved */
	int 			__fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
	_STRUCT_XMM_REG		__fpu_ymmh8;		/* YMMH 8  */
	_STRUCT_XMM_REG		__fpu_ymmh9;		/* YMMH 9  */
	_STRUCT_XMM_REG		__fpu_ymmh10;		/* YMMH 10  */
	_STRUCT_XMM_REG		__fpu_ymmh11;		/* YMMH 11  */
	_STRUCT_XMM_REG		__fpu_ymmh12;		/* YMMH 12  */
	_STRUCT_XMM_REG		__fpu_ymmh13;		/* YMMH 13  */
	_STRUCT_XMM_REG		__fpu_ymmh14;		/* YMMH 14  */
	_STRUCT_XMM_REG		__fpu_ymmh15;		/* YMMH 15  */
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_FLOAT_STATE64	struct x86_float_state64
_STRUCT_X86_FLOAT_STATE64
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		fpu_ip;			/* offset */
	__uint16_t		fpu_cs;			/* Selector */

	__uint16_t		fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		fpu_dp;			/* offset */
	__uint16_t		fpu_ds;			/* Selector */

	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		fpu_xmm15;		/* XMM 15  */
	char			fpu_rsrv4[6*16];	/* reserved */
	int 			fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE64	struct x86_avx_state64
_STRUCT_X86_AVX_STATE64
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		fpu_ip;			/* offset */
	__uint16_t		fpu_cs;			/* Selector */

	__uint16_t		fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		fpu_dp;			/* offset */
	__uint16_t		fpu_ds;			/* Selector */

	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		fpu_xmm15;		/* XMM 15  */
	char			fpu_rsrv4[6*16];	/* reserved */
	int 			fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
	_STRUCT_XMM_REG		__fpu_ymmh8;		/* YMMH 8  */
	_STRUCT_XMM_REG		__fpu_ymmh9;		/* YMMH 9  */
	_STRUCT_XMM_REG		__fpu_ymmh10;		/* YMMH 10  */
	_STRUCT_XMM_REG		__fpu_ymmh11;		/* YMMH 11  */
	_STRUCT_XMM_REG		__fpu_ymmh12;		/* YMMH 12  */
	_STRUCT_XMM_REG		__fpu_ymmh13;		/* YMMH 13  */
	_STRUCT_XMM_REG		__fpu_ymmh14;		/* YMMH 14  */
	_STRUCT_XMM_REG		__fpu_ymmh15;		/* YMMH 15  */
};

#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_EXCEPTION_STATE64	struct __darwin_x86_exception_state64
_STRUCT_X86_EXCEPTION_STATE64
{
    __uint16_t	__trapno;
    __uint16_t	__cpu;
    __uint32_t	__err;
    __uint64_t	__faultvaddr;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_EXCEPTION_STATE64	struct x86_exception_state64
_STRUCT_X86_EXCEPTION_STATE64
{
    __uint16_t	trapno;
    __uint16_t	cpu;
    __uint32_t	err;
    __uint64_t	faultvaddr;
};
#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_DEBUG_STATE64	struct __darwin_x86_debug_state64
_STRUCT_X86_DEBUG_STATE64
{
	__uint64_t	__dr0;
	__uint64_t	__dr1;
	__uint64_t	__dr2;
	__uint64_t	__dr3;
	__uint64_t	__dr4;
	__uint64_t	__dr5;
	__uint64_t	__dr6;
	__uint64_t	__dr7;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_DEBUG_STATE64	struct x86_debug_state64
_STRUCT_X86_DEBUG_STATE64
{
	__uint64_t	dr0;
	__uint64_t	dr1;
	__uint64_t	dr2;
	__uint64_t	dr3;
	__uint64_t	dr4;
	__uint64_t	dr5;
	__uint64_t	dr6;
	__uint64_t	dr7;
};
#endif /* !__DARWIN_UNIX03 */

#endif /* _MACH_I386__STRUCTS_H_ */
                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i386/fp_reg.h                  0100644 0001750 0001750 00000010663 12612724206 025105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1992-1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_I386_FP_SAVE_H_
#define	_I386_FP_SAVE_H_

/*
 * Control register
 */
#define	FPC_IE		0x0001		/* enable invalid operation
					   exception */
#define FPC_IM		FPC_IE
#define	FPC_DE		0x0002		/* enable denormalized operation
					   exception */
#define FPC_DM		FPC_DE
#define	FPC_ZE		0x0004		/* enable zero-divide exception */
#define FPC_ZM		FPC_ZE
#define	FPC_OE		0x0008		/* enable overflow exception */
#define FPC_OM		FPC_OE
#define	FPC_UE		0x0010		/* enable underflow exception */
#define	FPC_PE		0x0020		/* enable precision exception */
#define	FPC_PC		0x0300		/* precision control: */
#define	FPC_PC_24	0x0000			/* 24 bits */
#define	FPC_PC_53	0x0200			/* 53 bits */
#define	FPC_PC_64	0x0300			/* 64 bits */
#define	FPC_RC		0x0c00		/* rounding control: */
#define	FPC_RC_RN	0x0000			/* round to nearest or even */
#define	FPC_RC_RD	0x0400			/* round down */
#define	FPC_RC_RU	0x0800			/* round up */
#define	FPC_RC_CHOP	0x0c00			/* chop */
#define	FPC_IC		0x1000		/* infinity control (obsolete) */
#define	FPC_IC_PROJ	0x0000			/* projective infinity */
#define	FPC_IC_AFF	0x1000			/* affine infinity (std) */

/*
 * Status register
 */
#define	FPS_IE		0x0001		/* invalid operation */
#define	FPS_DE		0x0002		/* denormalized operand */
#define	FPS_ZE		0x0004		/* divide by zero */
#define	FPS_OE		0x0008		/* overflow */
#define	FPS_UE		0x0010		/* underflow */
#define	FPS_PE		0x0020		/* precision */
#define	FPS_SF		0x0040		/* stack flag */
#define	FPS_ES		0x0080		/* error summary */
#define	FPS_C0		0x0100		/* condition code bit 0 */
#define	FPS_C1		0x0200		/* condition code bit 1 */
#define	FPS_C2		0x0400		/* condition code bit 2 */
#define	FPS_TOS		0x3800		/* top-of-stack pointer */
#define	FPS_TOS_SHIFT	11
#define	FPS_C3		0x4000		/* condition code bit 3 */
#define	FPS_BUSY	0x8000		/* FPU busy */

/*
 * Kind of floating-point support provided by kernel.
 */
#define	FP_NO		0		/* no floating point */
#define	FP_SOFT		1		/* software FP emulator */
#define	FP_287		2		/* 80287 */
#define	FP_387		3		/* 80387 or 80486 */
#define FP_FXSR		4		/* Fast save/restore SIMD Extension */

#endif	/* _I386_FP_SAVE_H_ */
                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i386/thread_state.h            0100644 0001750 0001750 00000003254 12612724206 026310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef _MACH_I386_THREAD_STATE_H_
#define _MACH_I386_THREAD_STATE_H_

/* Size of maximum exported thread state in words */
#define I386_THREAD_STATE_MAX	(224)    /* Size of biggest state possible */

#if defined (__i386__) || defined(__x86_64__)
#define THREAD_STATE_MAX	I386_THREAD_STATE_MAX
#endif

#endif	/* _MACH_I386_THREAD_STATE_H_ */
                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i386/thread_status.h           0100644 0001750 0001750 00000022402 12612724206 026507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	File:	thread_status.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1985
 *
 *	This file contains the structure definitions for the thread
 *	state as applied to I386 processors.
 */

#ifndef	_MACH_I386_THREAD_STATUS_H_
#define _MACH_I386_THREAD_STATUS_H_

#include <mach/i386/_structs.h>
#include <mach/message.h>
#include <mach/i386/fp_reg.h>
#include <mach/i386/thread_state.h>
#include <i386/eflags.h>

/*
 * the i386_xxxx form is kept for legacy purposes since these types
 * are externally known... eventually they should be deprecated.
 * our internal implementation has moved to the following naming convention
 *
 *   x86_xxxx32 names are used to deal with 32 bit states
 *   x86_xxxx64 names are used to deal with 64 bit states
 *   x86_xxxx   names are used to deal with either 32 or 64 bit states
 *	via a self-describing mechanism
 */

/*
 * these are the legacy names which should be deprecated in the future
 * they are externally known which is the only reason we don't just get
 * rid of them
 */
#define i386_THREAD_STATE		1
#define i386_FLOAT_STATE		2
#define i386_EXCEPTION_STATE		3

/*
 * THREAD_STATE_FLAVOR_LIST 0
 * 	these are the supported flavors
 */
#define x86_THREAD_STATE32		1
#define x86_FLOAT_STATE32		2
#define x86_EXCEPTION_STATE32		3
#define x86_THREAD_STATE64		4
#define x86_FLOAT_STATE64		5
#define x86_EXCEPTION_STATE64		6
#define x86_THREAD_STATE		7
#define x86_FLOAT_STATE			8
#define x86_EXCEPTION_STATE		9
#define x86_DEBUG_STATE32		10
#define x86_DEBUG_STATE64		11
#define x86_DEBUG_STATE			12
#define THREAD_STATE_NONE		13
/* 15 and 16 are used for the internal x86_SAVED_STATE flavours */
#define x86_AVX_STATE32			16
#define x86_AVX_STATE64			17


/*
 * Largest state on this machine:
 * (be sure mach/machine/thread_state.h matches!)
 */
#define THREAD_MACHINE_STATE_MAX	THREAD_STATE_MAX

/*
 * VALID_THREAD_STATE_FLAVOR is a platform specific macro that when passed
 * an exception flavor will return if that is a defined flavor for that
 * platform. The macro must be manually updated to include all of the valid
 * exception flavors as defined above.
 */
#define VALID_THREAD_STATE_FLAVOR(x)       \
	 ((x == x86_THREAD_STATE32)	|| \
	  (x == x86_FLOAT_STATE32)	|| \
	  (x == x86_EXCEPTION_STATE32)	|| \
	  (x == x86_DEBUG_STATE32)	|| \
	  (x == x86_THREAD_STATE64)	|| \
	  (x == x86_FLOAT_STATE64)	|| \
	  (x == x86_EXCEPTION_STATE64)	|| \
	  (x == x86_DEBUG_STATE64)	|| \
	  (x == x86_THREAD_STATE)	|| \
	  (x == x86_FLOAT_STATE)	|| \
	  (x == x86_EXCEPTION_STATE)	|| \
	  (x == x86_DEBUG_STATE)	|| \
	  (x == x86_AVX_STATE32)	|| \
	  (x == x86_AVX_STATE64)	|| \
	  (x == THREAD_STATE_NONE))

struct x86_state_hdr {
	int	flavor;
	int	count;
};
typedef struct x86_state_hdr x86_state_hdr_t;

/*
 * Default segment register values.
 */
    
#define USER_CODE_SELECTOR	0x0017
#define USER_DATA_SELECTOR	0x001f
#define KERN_CODE_SELECTOR	0x0008
#define KERN_DATA_SELECTOR	0x0010

/*
 * to be deprecated in the future
 */
typedef _STRUCT_X86_THREAD_STATE32 i386_thread_state_t;
#define i386_THREAD_STATE_COUNT	((mach_msg_type_number_t) \
    ( sizeof (i386_thread_state_t) / sizeof (int) ))

typedef _STRUCT_X86_THREAD_STATE32 x86_thread_state32_t;
#define x86_THREAD_STATE32_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_thread_state32_t) / sizeof (int) ))

/*
 * to be deprecated in the future
 */
typedef _STRUCT_X86_FLOAT_STATE32 i386_float_state_t;
#define i386_FLOAT_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(i386_float_state_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_FLOAT_STATE32 x86_float_state32_t;
#define x86_FLOAT_STATE32_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_float_state32_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_AVX_STATE32 x86_avx_state32_t;
#define x86_AVX_STATE32_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_avx_state32_t)/sizeof(unsigned int)))

/*
 * to be deprecated in the future
 */
typedef _STRUCT_X86_EXCEPTION_STATE32 i386_exception_state_t;
#define i386_EXCEPTION_STATE_COUNT	((mach_msg_type_number_t) \
    ( sizeof (i386_exception_state_t) / sizeof (int) ))

typedef _STRUCT_X86_EXCEPTION_STATE32 x86_exception_state32_t;
#define x86_EXCEPTION_STATE32_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_exception_state32_t) / sizeof (int) ))

#define I386_EXCEPTION_STATE_COUNT i386_EXCEPTION_STATE_COUNT

typedef _STRUCT_X86_DEBUG_STATE32 x86_debug_state32_t;
#define x86_DEBUG_STATE32_COUNT       ((mach_msg_type_number_t) \
	( sizeof (x86_debug_state32_t) / sizeof (int) ))

#define X86_DEBUG_STATE32_COUNT x86_DEBUG_STATE32_COUNT

typedef _STRUCT_X86_THREAD_STATE64 x86_thread_state64_t;
#define x86_THREAD_STATE64_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_thread_state64_t) / sizeof (int) ))

typedef _STRUCT_X86_FLOAT_STATE64 x86_float_state64_t;
#define x86_FLOAT_STATE64_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_float_state64_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_AVX_STATE64 x86_avx_state64_t;
#define x86_AVX_STATE64_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_avx_state64_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_EXCEPTION_STATE64 x86_exception_state64_t;
#define x86_EXCEPTION_STATE64_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_exception_state64_t) / sizeof (int) ))

#define X86_EXCEPTION_STATE64_COUNT x86_EXCEPTION_STATE64_COUNT

typedef _STRUCT_X86_DEBUG_STATE64 x86_debug_state64_t;
#define x86_DEBUG_STATE64_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_debug_state64_t) / sizeof (int) ))

#define X86_DEBUG_STATE64_COUNT x86_DEBUG_STATE64_COUNT

/*
 * Combined thread, float and exception states
 */
struct x86_thread_state {
	x86_state_hdr_t			tsh;
	union {
	    x86_thread_state32_t	ts32;
	    x86_thread_state64_t	ts64;
	} uts;
};

struct x86_float_state {
	x86_state_hdr_t			fsh;
	union {
		x86_float_state32_t	fs32;
		x86_float_state64_t	fs64;
	} ufs;
};

struct x86_exception_state {
	x86_state_hdr_t			esh;
	union {
		x86_exception_state32_t	es32;
		x86_exception_state64_t	es64;
	} ues;
};

struct x86_debug_state {
	x86_state_hdr_t			dsh;
	union {
		x86_debug_state32_t	ds32;
		x86_debug_state64_t	ds64;
	} uds;
};

typedef struct x86_thread_state x86_thread_state_t;
#define x86_THREAD_STATE_COUNT	((mach_msg_type_number_t) \
		( sizeof (x86_thread_state_t) / sizeof (int) ))

typedef struct x86_float_state x86_float_state_t;
#define x86_FLOAT_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_float_state_t)/sizeof(unsigned int)))

typedef struct x86_exception_state x86_exception_state_t;
#define x86_EXCEPTION_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_exception_state_t)/sizeof(unsigned int)))

typedef struct x86_debug_state x86_debug_state_t;
#define x86_DEBUG_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_debug_state_t)/sizeof(unsigned int)))

/*
 * Machine-independent way for servers and Mach's exception mechanism to
 * choose the most efficient state flavor for exception RPC's:
 */
#define MACHINE_THREAD_STATE		x86_THREAD_STATE
#define MACHINE_THREAD_STATE_COUNT	x86_THREAD_STATE_COUNT


#endif	/* _MACH_I386_THREAD_STATUS_H_ */
                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i860/                          0040755 0001750 0001750 00000000000 12612724206 023464  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/i860/thread_status.h           0100644 0001750 0001750 00000005263 12612724206 026512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* 
 * Copyright (c) 1987, 1988 NeXT, Inc.
 */ 

#ifndef	_I860_THREAD_STATE_
#define	_I860_THREAD_STATE_

/*
 * I860_thread_state_regs		this is the structure that is exported
 *					to user threads for use in set/get
 *					status calls.  This structure should
 *					never change.
 */

#define	I860_THREAD_STATE_REGS	(4)	/* normal registers */

struct i860_thread_state_regs {
	int	ireg[31];  /* core registers (incl stack pointer, but not r0) */
	int	freg[30];  /* FPU registers, except f0 and f1 */
	int	psr;	   /* user's processor status register */
	int	epsr;	   /* user's extended processor status register */
	int	db;	   /* user's data breakpoint register */
	int	pc;	   /* user's program counter */
	int	_padding_; /* not used */
	/* Pipeline state for FPU */
	double	Mres3;
	double	Ares3;
	double	Mres2;
	double	Ares2;
	double	Mres1;
	double	Ares1;
	double	Ires1;
	double	Lres3m;
	double	Lres2m;
	double	Lres1m;
	double	KR;
	double	KI;
	double	T;
	int	Fsr3;
	int 	Fsr2;
	int	Fsr1;
	int	Mergelo32;
	int	Mergehi32;
};

#define	I860_THREAD_STATE_REGS_COUNT \
	(sizeof (struct i860_thread_state_regs) / sizeof (int))

#endif	/* _I860_THREAD_STATE_ */
                                                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/m68k/                          0040755 0001750 0001750 00000000000 12612724206 023563  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/m68k/thread_status.h           0100644 0001750 0001750 00000007254 12612724206 026613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* 
 * Copyright (c) 1987, 1988 NeXT, Inc.
 *
 * HISTORY
 * 15-May-91  Gregg Kellogg (gk) at NeXT
 *	Use m68k_saved_state instead of NeXT_saved_state.
 *	Use m68k_thread_state_regs NeXT_regs.
 *	Use m68k_thread_state_68882 NeXT_thread_state_68882.
 *	Use m68k_thread_state_user_reg NeXT_thread_state_user_reg.
 *	Moved m68k_saved_state and USER_REGS to pcb.h.
 *
 */ 

#ifndef	_MACH_M68K_THREAD_STATUS_
#define	_MACH_M68K_THREAD_STATUS_

/*
 *	m68k_thread_state_regs	this is the structure that is exported
 *				to user threads for use in set/get status
 *				calls.  This structure should never
 *				change.
 *
 *	m68k_thread_state_68882	this structure is exported to user threads
 *				to allow the to set/get 68882 floating
 *				pointer register state.
 *
 *	m68k_saved_state	this structure corresponds to the state
 *				of the user registers as saved on the
 *				stack upon kernel entry.  This structure
 *				is used internally only.  Since this
 *				structure may change from version to
 *				version, it is hidden from the user.
 */

#define	M68K_THREAD_STATE_REGS	(1)	/* normal registers */
#define M68K_THREAD_STATE_68882	(2)	/* 68882 registers */
#define M68K_THREAD_STATE_USER_REG (3)	/* additional user register */

#define M68K_THREAD_STATE_MAXFLAVOR (3)

struct m68k_thread_state_regs {
	int	dreg[8];	/* data registers */
	int	areg[8];	/* address registers (incl stack pointer) */
	short	pad0;		/* not used */
	short	sr;		/* user's status register */
	int	pc;		/* user's program counter */
};

#define	M68K_THREAD_STATE_REGS_COUNT \
	(sizeof (struct m68k_thread_state_regs) / sizeof (int))

struct m68k_thread_state_68882 {
	struct {
		int	fp[3];		/* 96-bit extended format */
	} regs[8];
	int	cr;			/* control */
	int	sr;			/* status */
	int	iar;			/* instruction address */
	int	state;			/* execution state */
};

#define	M68K_THREAD_STATE_68882_COUNT \
	(sizeof (struct m68k_thread_state_68882) / sizeof (int))

struct m68k_thread_state_user_reg {
	int	user_reg;		/* user register (used by cthreads) */
};

#define M68K_THREAD_STATE_USER_REG_COUNT \
	(sizeof (struct m68k_thread_state_user_reg) / sizeof (int))

#endif	/* _MACH_M68K_THREAD_STATUS_ */
                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/m88k/                          0040755 0001750 0001750 00000000000 12612724206 023565  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/m88k/thread_status.h           0100644 0001750 0001750 00000021637 12612724206 026616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	mach/m88k/thread_status.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *
 *	This include file defines the per-thread state
 *	for NeXT 88K-based products.
 *
 * HISTORY
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 *
 * FIXME:
 *	All of these types should be pulled from architecture.
 *	Solve possible conflicting types problem for implementations
 *	by making user define an implementation (e.g. #define __M88110__)
 *	to get a implementation specific features.
 *
 *	Put fp envelope stuff in mach/m88k/m88110_fpee.h.
 */

#ifndef	_MACH_M88K_THREAD_STATE_
#define	_MACH_M88K_THREAD_STATE_

#import <architecture/m88k/fp_regs.h>
#import <architecture/m88k/reg_help.h>

/**************************************************************************
 * Data Typedefs used by thread_getstatus() and thread_setstatus()        *
 * NOTE: FP control and status regs described in <mach/m88k/fp_regs.h>    *
 **************************************************************************/

#define	M88K_THREAD_STATE_GRF		(1)	// general registers
#define M88K_THREAD_STATE_XRF		(2)	// extended and fp registers
#define	M88K_THREAD_STATE_USER		(3)	// non-architectural user state
#define M88110_THREAD_STATE_IMPL	(4)	// 88110 impl specific

#define	M88K_THREAD_STATE_MAXFLAVOR	(M88110_THREAD_STATE_IMPL)

/*
 * m88k_thread_state_grf -- basic thread state for NeXT 88K-based products
 */
typedef struct _m88k_thread_state_grf {
	unsigned	r1;		// rpc: return pc, caller-saved
	unsigned	r2;		// a0: argument 0, caller-saved
	unsigned	r3;		// a1
	unsigned	r4;		// a2
	unsigned	r5;		// a3
	unsigned	r6;		// a4
	unsigned	r7;		// a5
	unsigned	r8;		// a6
	unsigned	r9;		// a7
	unsigned	r10;		// t0: temporary, caller-saved
	unsigned	r11;		// t1
	unsigned	r12;		// t2: struct return ptr, 
	unsigned	r13;		// t3
	unsigned	r14;		// s0: saved, callee-saved
	unsigned	r15;		// s1
	unsigned	r16;		// s2
	unsigned	r17;		// s3
	unsigned	r18;		// s4
	unsigned	r19;		// s5
	unsigned	r20;		// s6
	unsigned	r21;		// s7
	unsigned	r22;		// s8
	unsigned	r23;		// s9
	unsigned	r24;		// s10
	unsigned	r25;		// s11
	unsigned	r26;		// t4
	unsigned	r27;		// at: temp, used by asm macros
	unsigned	r28;		// lk0: reserved for link editor
	unsigned	r29;		// lk1
	unsigned	r30;		// fp: frame ptr, callee-saved
	unsigned	r31;		// sp: stack ptr, callee-saved
	unsigned	xip;		// executing instruction pointer
	unsigned	xip_in_bd;	// non-zero => xip in branch delay slot
	/*
	 * nip is only valid if xip_in_bd is TRUE
	 */
	unsigned	nip;		// next instruction pointer
} m88k_thread_state_grf_t;

#define	M88K_THREAD_STATE_GRF_COUNT 	\
	(sizeof(m88k_thread_state_grf_t)/sizeof(int))

/*
 * m88k_thread_state_xrf -- extended register file contents and floating point
 * control registers for NeXT 88K-based products.
 */
typedef struct _m88k_thread_state_xrf {
	m88k_xrf_t	x1;			// caller-saved
	m88k_xrf_t	x2;
	m88k_xrf_t	x3;
	m88k_xrf_t	x4;
	m88k_xrf_t	x5;
	m88k_xrf_t	x6;
	m88k_xrf_t	x7;
	m88k_xrf_t	x8;
	m88k_xrf_t	x9;
	m88k_xrf_t	x10;
	m88k_xrf_t	x11;
	m88k_xrf_t	x12;
	m88k_xrf_t	x13;
	m88k_xrf_t	x14;
	m88k_xrf_t	x15;
	m88k_xrf_t	x16;
	m88k_xrf_t	x17;
	m88k_xrf_t	x18;
	m88k_xrf_t	x19;
	m88k_xrf_t	x20;
	m88k_xrf_t	x21;
	m88k_xrf_t	x22;			// callee-saved
	m88k_xrf_t	x23;
	m88k_xrf_t	x24;
	m88k_xrf_t	x25;
	m88k_xrf_t	x26;
	m88k_xrf_t	x27;
	m88k_xrf_t	x28;
	m88k_xrf_t	x29;
	m88k_xrf_t	x30;			// reserved
	m88k_xrf_t	x31;
	m88k_fpsr_t	fpsr;			// fp status, fcr62
	m88k_fpcr_t	fpcr;			// fp control, fcr63
} m88k_thread_state_xrf_t;

#define	M88K_THREAD_STATE_XRF_COUNT 		\
	(sizeof(m88k_thread_state_xrf_t)/sizeof(int))

typedef struct _m88k_thread_state_user {
	int		user;			// user register (for cthreads)
} m88k_thread_state_user_t;

#define M88K_THREAD_STATE_USER_COUNT 		\
	(sizeof(m88k_thread_state_user_t)/sizeof(int))

/*
 * Motorola 88110 specific state
 * (Can't count on this being in all m88k implementations.)
 */

#define	M88110_N_DATA_BP	2		// 88110 supports 2 data bp's

/*
 * Data Breakpoint Address Match Mask -- actually indicates don't
 * care bits in addr
 */
typedef enum {
	M88110_MATCH_BYTE = 0,
	M88110_MATCH_SHORT = 0x1,
	M88110_MATCH_WORD = 0x3,
	M88110_MATCH_DOUBLE = 0x7,
	M88110_MATCH_QUAD = 0xf,
	M88110_MATCH_32 = 0x1f,
	M88110_MATCH_64 = 0x3f,
	M88110_MATCH_128 = 0x7f,
	M88110_MATCH_256 = 0xff,
	M88110_MATCH_512 = 0x1ff,
	M88110_MATCH_1024 = 0x3ff,
	M88110_MATCH_2048 = 0x7ff,
	M88110_MATCH_4096 = 0xfff
} m88110_match_t;

/*
 * Data Breakpoint Control Word
 */
typedef	struct {
	unsigned	:BITS_WIDTH(31,29);
	unsigned	rw:BIT_WIDTH(28);		// 1 => read access
	unsigned	rwm:BIT_WIDTH(27);		// 0 => rw is don't care
	unsigned	:BITS_WIDTH(26,13);
	m88110_match_t	addr_match:BITS_WIDTH(12,1);	// addr(12,1) don't cares
	unsigned	v:BIT_WIDTH(0);
} m88110_bp_ctrl_t;

/*
 * A complete Data Breakpoint spec
 */
typedef	struct {
	unsigned		addr;		// data address
	m88110_bp_ctrl_t	ctrl;
} m88110_data_bp_t;

/*
 * m88110_psr_t -- 88110 Processor Status Register
 * System prohibits modification of supr, le, se, sgn_imd, sm and mxm_dis
 * bits for user threads.
 */
typedef struct {
	unsigned	supr:BIT_WIDTH(31);
	unsigned	le:BIT_WIDTH(30);	// little endian mode
	unsigned	se:BIT_WIDTH(29);	// serial exec mode
	unsigned	c:BIT_WIDTH(28);	// carry
	unsigned	:BIT_WIDTH(27);
	unsigned	sgn_imd:BIT_WIDTH(26);	// signed immediates
	unsigned	sm:BIT_WIDTH(25);	// serialize mem refs
	unsigned	:BIT_WIDTH(24);
	unsigned	trace:BIT_WIDTH(23);
	unsigned	:BITS_WIDTH(22,5);
	unsigned	sfu2dis:BIT_WIDTH(4);	// gpu (sfu2) disable
	unsigned	sfu1dis:BIT_WIDTH(3);	// fpu (sfu1) disable
	unsigned	mxm_dis:BIT_WIDTH(2);	// misaligned dis
	unsigned	:BITS_WIDTH(1,0);
} m88110_psr_t;

/*
 * Information for IEEE floating point user trap handlers
 */
typedef enum {
	M88110_IRESULT_SIZE_NONE = 0,		// no intermediate result
	M88110_IRESULT_SIZE_SINGLE = 1,		// single precision result
	M88110_IRESULT_SIZE_DOUBLE = 2,		// double precision result
	M88110_IRESULT_SIZE_EXTENDED = 3	// double extended result
} m88110_iresult_size_t;

typedef struct {
	unsigned	:BITS_WIDTH(31,16);		// unused
	m88110_iresult_size_t	iresult_size:BITS_WIDTH(15,14);
							// size of iresult
	unsigned	:BITS_WIDTH(13,9);		// unused
	unsigned	sfu1_disabled:BIT_WIDTH(8);	// sfu disabled
	unsigned	int:BIT_WIDTH(7);		// invalid int conv
	unsigned	unimp:BIT_WIDTH(6);		// unimp ctrl reg
	unsigned	priv:BIT_WIDTH(5);		// priv violation
	unsigned	efinv:BIT_WIDTH(4);		// IEEE EFINV
	unsigned	efdvz:BIT_WIDTH(3);		// IEEE EFDVZ
	unsigned	efunf:BIT_WIDTH(2);		// IEEE EFUNF
	unsigned	efovf:BIT_WIDTH(1);		// IEEE EFOVF
	unsigned	efinx:BIT_WIDTH(0);		// IEEE EFINX
} m88110_fp_trap_status_t;

/*
 * m88110_thread_state_impl -- 88110 implementation-specific
 * control registers for NeXT 88K-based products.
 */
typedef struct _m88110_thread_state_impl {
	m88110_data_bp_t	data_bp[M88110_N_DATA_BP];

	/*
	 * Certain of the 88110 psr bits may be modified
	 */
	m88110_psr_t		psr;		// processor status
	/*
	 * IEEE floating point user trap information.  Read only.
	 * (Only valid immediately after an EXC_ARITHMETIC
	 * exception with code EXC_M88K_SFU1_EXCP.  Trap
	 * handlers must determine operation, source and
	 * destination registers by fetching instruction at
	 * exip.)
	 */
	m88k_xrf_t		intermediate_result;
	m88110_fp_trap_status_t	fp_trap_status;
} m88110_thread_state_impl_t;

#define	M88110_THREAD_STATE_IMPL_COUNT	\
	(sizeof(m88110_thread_state_impl_t)/sizeof(int))

#endif	/* _MACH_M88K_THREAD_STATE_ */
                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/machine.h                      0100644 0001750 0001750 00000032410 12612724206 024550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * Revision 1.1.1.1  1997/09/03 20:53:37  roland
 * Initial checkin of SGS release 244
 *
 *  2 July 1992	Mac Gillon at NeXT
 *	Changed HPPA subtypes to follow our practice. 
 *
 * 11 September 1992 David E. Bohman at NeXT
 *	Added CPU_SUBTYPE_486SX to the i386 family.
 *
 * 16 July 1992 David E. Bohman at NeXT
 *	Added CPU_SUBTYPE_586 to the i386 family.
 *
 * 17-Dec-91  Peter King (king) at NeXT
 *	Added support for the XXX_ALL subtypes.  These are used to
 *	tag object files that can run on any implementation of a
 *	particular family.
 *
 *  1-Mar-90  John Seamons (jks) at NeXT
 *	Redefined cpu_type and cpu_subtype definitions to indicate processor
 *	architecture instead of product types for the MC680x0.
 *
 * Revision 2.15  89/10/11  14:39:56  dlb
 * 	Removed should_exit - replaced by action thread.
 * 	[89/01/25            dlb]
 * 
 * Revision 2.14  89/07/14  17:21:39  rvb
 * 	Added CPU types and subtypes for MC68030, MC68040, MC88000,
 * 	HPPA, ARM and Sun4-SPARC.
 * 	[89/07/13            mrt]
 * 
 * Revision 2.12  89/05/30  10:38:58  rvb
 * 	Add R2000 machine types.
 * 	[89/05/30  08:28:53  rvb]
 * 
 * Revision 2.11  89/04/18  16:43:32  mwyoung
 * 	Use <machine/vm_types.h> rather than <vm/vm_param.h> to get
 * 	VM types.  Remove old history... none of it was insightful.
 * 
 * 	The variable declarations should be moved elsewhere.
 * 	[89/01/24            mwyoung]
 * 
 */
/*
 *	Machine independent machine abstraction.
 *	Copyright (C) 1986, Avadis Tevanian, Jr.
 */

#ifndef	_MACH_MACHINE_H_
#define _MACH_MACHINE_H_

#import <mach/machine/vm_types.h>
#import <mach/boolean.h>

/*
 *	For each host, there is a maximum possible number of
 *	cpus that may be available in the system.  This is the
 *	compile-time constant NCPUS, which is defined in cpus.h.
 *
 *	In addition, there is a machine_slot specifier for each
 *	possible cpu in the system.
 */

struct machine_info {
	int		major_version;	/* kernel major version id */
	int		minor_version;	/* kernel minor version id */
	int		max_cpus;	/* max number of cpus compiled */
	int		avail_cpus;	/* number actually available */
	vm_size_t	memory_size;	/* size of memory in bytes */
};

typedef struct machine_info	*machine_info_t;
typedef struct machine_info	machine_info_data_t;	/* bogus */

typedef int	cpu_type_t;
typedef int	cpu_subtype_t;
typedef integer_t	cpu_threadtype_t;

#define CPU_STATE_MAX		3

#define CPU_STATE_USER		0
#define CPU_STATE_SYSTEM	1
#define CPU_STATE_IDLE		2

struct machine_slot {
	boolean_t	is_cpu;		/* is there a cpu in this slot? */
	cpu_type_t	cpu_type;	/* type of cpu */
	cpu_subtype_t	cpu_subtype;	/* subtype of cpu */
	volatile boolean_t running;	/* is cpu running */
	long		cpu_ticks[CPU_STATE_MAX];
	int		clock_freq;	/* clock interrupt frequency */
};

typedef struct machine_slot	*machine_slot_t;
typedef struct machine_slot	machine_slot_data_t;	/* bogus */

#ifdef	KERNEL
extern struct machine_info	machine_info;
extern struct machine_slot	machine_slot[];

extern vm_offset_t		interrupt_stack[];
#endif	/* KERNEL */

/*
 *	Machine types known by all.
 */
 
#define CPU_TYPE_ANY		((cpu_type_t) -1)

#define CPU_TYPE_VAX		((cpu_type_t) 1)
#define CPU_TYPE_ROMP		((cpu_type_t) 2)
#define CPU_TYPE_NS32032	((cpu_type_t) 4)
#define CPU_TYPE_NS32332        ((cpu_type_t) 5)
#define	CPU_TYPE_MC680x0	((cpu_type_t) 6)
#define CPU_TYPE_I386		((cpu_type_t) 7)
#define CPU_TYPE_X86_64		((cpu_type_t) (CPU_TYPE_I386 | CPU_ARCH_ABI64))
#define CPU_TYPE_MIPS		((cpu_type_t) 8)
#define CPU_TYPE_NS32532        ((cpu_type_t) 9)
#define CPU_TYPE_HPPA           ((cpu_type_t) 11)
#define CPU_TYPE_ARM		((cpu_type_t) 12)
#define CPU_TYPE_MC88000	((cpu_type_t) 13)
#define CPU_TYPE_SPARC		((cpu_type_t) 14)
#define CPU_TYPE_I860		((cpu_type_t) 15) // big-endian
#define	CPU_TYPE_I860_LITTLE	((cpu_type_t) 16) // little-endian
#define CPU_TYPE_RS6000		((cpu_type_t) 17)
#define CPU_TYPE_MC98000	((cpu_type_t) 18)
#define CPU_TYPE_POWERPC	((cpu_type_t) 18)
#define CPU_ARCH_ABI64		 0x1000000
#define CPU_TYPE_POWERPC64	((cpu_type_t)(CPU_TYPE_POWERPC | CPU_ARCH_ABI64))
#define CPU_TYPE_VEO		((cpu_type_t) 255)
#define CPU_TYPE_ARM64		((cpu_type_t)(CPU_TYPE_ARM | CPU_ARCH_ABI64))
		

/*
 *	Machine subtypes (these are defined here, instead of in a machine
 *	dependent directory, so that any program can get all definitions
 *	regardless of where is it compiled).
 */

/*
 * Capability bits used in the definition of cpu_subtype.
 */
#define CPU_SUBTYPE_MASK       0xff000000      /* mask for feature flags */
#define CPU_SUBTYPE_LIB64      0x80000000      /* 64 bit libraries */


/*
 *	Object files that are hand-crafted to run on any
 *	implementation of an architecture are tagged with
 *	CPU_SUBTYPE_MULTIPLE.  This functions essentially the same as
 *	the "ALL" subtype of an architecture except that it allows us
 *	to easily find object files that may need to be modified
 *	whenever a new implementation of an architecture comes out.
 *
 *	It is the responsibility of the implementor to make sure the
 *	software handles unsupported implementations elegantly.
 */
#define	CPU_SUBTYPE_MULTIPLE	((cpu_subtype_t) -1)


/*
 *	VAX subtypes (these do *not* necessary conform to the actual cpu
 *	ID assigned by DEC available via the SID register).
 */

#define	CPU_SUBTYPE_VAX_ALL	((cpu_subtype_t) 0) 
#define CPU_SUBTYPE_VAX780	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_VAX785	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_VAX750	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_VAX730	((cpu_subtype_t) 4)
#define CPU_SUBTYPE_UVAXI	((cpu_subtype_t) 5)
#define CPU_SUBTYPE_UVAXII	((cpu_subtype_t) 6)
#define CPU_SUBTYPE_VAX8200	((cpu_subtype_t) 7)
#define CPU_SUBTYPE_VAX8500	((cpu_subtype_t) 8)
#define CPU_SUBTYPE_VAX8600	((cpu_subtype_t) 9)
#define CPU_SUBTYPE_VAX8650	((cpu_subtype_t) 10)
#define CPU_SUBTYPE_VAX8800	((cpu_subtype_t) 11)
#define CPU_SUBTYPE_UVAXIII	((cpu_subtype_t) 12)

/*
 *	ROMP subtypes.
 */

#define	CPU_SUBTYPE_RT_ALL	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_RT_PC	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_RT_APC	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_RT_135	((cpu_subtype_t) 3)

/*
 *	32032/32332/32532 subtypes.
 */

#define	CPU_SUBTYPE_MMAX_ALL	    ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MMAX_DPC	    ((cpu_subtype_t) 1)	/* 032 CPU */
#define CPU_SUBTYPE_SQT		    ((cpu_subtype_t) 2)
#define CPU_SUBTYPE_MMAX_APC_FPU    ((cpu_subtype_t) 3)	/* 32081 FPU */
#define CPU_SUBTYPE_MMAX_APC_FPA    ((cpu_subtype_t) 4)	/* Weitek FPA */
#define CPU_SUBTYPE_MMAX_XPC	    ((cpu_subtype_t) 5)	/* 532 CPU */

/*
 *	I386 subtypes.
 */

#define	CPU_SUBTYPE_I386_ALL	((cpu_subtype_t) 3)
#define	CPU_SUBTYPE_X86_64_ALL	CPU_SUBTYPE_I386_ALL
#define CPU_SUBTYPE_386		((cpu_subtype_t) 3)
#define CPU_SUBTYPE_486		((cpu_subtype_t) 4)
#define CPU_SUBTYPE_486SX	((cpu_subtype_t) 4 + 128)
#define CPU_SUBTYPE_586		((cpu_subtype_t) 5)
#define CPU_SUBTYPE_INTEL(f, m)	((cpu_subtype_t) (f) + ((m) << 4))
#define CPU_SUBTYPE_PENT	CPU_SUBTYPE_INTEL(5, 0)
#define CPU_SUBTYPE_PENTPRO	CPU_SUBTYPE_INTEL(6, 1)
#define CPU_SUBTYPE_PENTII_M3	CPU_SUBTYPE_INTEL(6, 3)
#define CPU_SUBTYPE_PENTII_M5	CPU_SUBTYPE_INTEL(6, 5)
#define CPU_SUBTYPE_PENTIUM_4	CPU_SUBTYPE_INTEL(10, 0)

#define CPU_SUBTYPE_INTEL_FAMILY(x)	((x) & 15)
#define CPU_SUBTYPE_INTEL_FAMILY_MAX	15

#define CPU_SUBTYPE_INTEL_MODEL(x)	((x) >> 4)
#define CPU_SUBTYPE_INTEL_MODEL_ALL	0

#define CPU_SUBTYPE_X86_64_H	((cpu_subtype_t)8) /* Haswell and compatible */

/*
 *	Mips subtypes.
 */

#define	CPU_SUBTYPE_MIPS_ALL	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MIPS_R2300	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MIPS_R2600	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_MIPS_R2800	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_MIPS_R2000a	((cpu_subtype_t) 4)

/*
 * 	680x0 subtypes
 *
 * The subtype definitions here are unusual for historical reasons.
 * NeXT used to consider 68030 code as generic 68000 code.  For
 * backwards compatability:
 * 
 *	CPU_SUBTYPE_MC68030 symbol has been preserved for source code
 *	compatability.
 *
 *	CPU_SUBTYPE_MC680x0_ALL has been defined to be the same
 *	subtype as CPU_SUBTYPE_MC68030 for binary comatability.
 *
 *	CPU_SUBTYPE_MC68030_ONLY has been added to allow new object
 *	files to be tagged as containing 68030-specific instructions.
 */

#define	CPU_SUBTYPE_MC680x0_ALL		((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MC68030		((cpu_subtype_t) 1) /* compat */
#define CPU_SUBTYPE_MC68040		((cpu_subtype_t) 2) 
#define	CPU_SUBTYPE_MC68030_ONLY	((cpu_subtype_t) 3)

/*
 *	HPPA subtypes for Hewlett-Packard HP-PA family of
 *	risc processors. Port by NeXT to 700 series. 
 */

#define	CPU_SUBTYPE_HPPA_ALL		((cpu_subtype_t) 0)
#define CPU_SUBTYPE_HPPA_7100		((cpu_subtype_t) 0) /* compat */
#define CPU_SUBTYPE_HPPA_7100LC		((cpu_subtype_t) 1)

/* 
 * 	Acorn subtypes - Acorn Risc Machine port done by
 *		Olivetti System Software Laboratory
 */

#define	CPU_SUBTYPE_ARM_ALL		((cpu_subtype_t) 0)
#define CPU_SUBTYPE_ARM_A500_ARCH	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_ARM_A500		((cpu_subtype_t) 2)
#define CPU_SUBTYPE_ARM_A440		((cpu_subtype_t) 3)
#define CPU_SUBTYPE_ARM_M4		((cpu_subtype_t) 4)
#define CPU_SUBTYPE_ARM_V4T		((cpu_subtype_t) 5)
#define CPU_SUBTYPE_ARM_V6		((cpu_subtype_t) 6)
#define CPU_SUBTYPE_ARM_V5TEJ		((cpu_subtype_t) 7)
#define CPU_SUBTYPE_ARM_XSCALE		((cpu_subtype_t) 8)
#define CPU_SUBTYPE_ARM_V7		((cpu_subtype_t) 9)
#define CPU_SUBTYPE_ARM_V7F		((cpu_subtype_t) 10) /* Cortex A9 */
#define CPU_SUBTYPE_ARM_V7S		((cpu_subtype_t) 11) /* Swift */
#define CPU_SUBTYPE_ARM_V7K		((cpu_subtype_t) 12) /* Kirkwood40 */
#define CPU_SUBTYPE_ARM_V6M		((cpu_subtype_t) 14) /* Not meant to be run under xnu */
#define CPU_SUBTYPE_ARM_V7M		((cpu_subtype_t) 15) /* Not meant to be run under xnu */
#define CPU_SUBTYPE_ARM_V7EM		((cpu_subtype_t) 16) /* Not meant to be run under xnu */
#define CPU_SUBTYPE_ARM_V8		((cpu_subtype_t) 13)

#define	CPU_SUBTYPE_ARM64_ALL		((cpu_subtype_t) 0)
#define	CPU_SUBTYPE_ARM64_V8		((cpu_subtype_t) 1)

/*
 *	MC88000 subtypes
 */
#define	CPU_SUBTYPE_MC88000_ALL	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MMAX_JPC	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MC88100	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MC88110	((cpu_subtype_t) 2)

/*
 *	MC98000 (PowerPC) subtypes
 */
#define	CPU_SUBTYPE_MC98000_ALL	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MC98601	((cpu_subtype_t) 1)

/*
 *	I860 subtypes
 */
#define CPU_SUBTYPE_I860_ALL	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_I860_860	((cpu_subtype_t) 1)

/*
 * 	I860 subtypes for NeXT-internal backwards compatability.
 *	These constants will be going away.  DO NOT USE THEM!!!
 */
#define CPU_SUBTYPE_LITTLE_ENDIAN	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_BIG_ENDIAN		((cpu_subtype_t) 1)

/*
 *	I860_LITTLE subtypes
 */
#define	CPU_SUBTYPE_I860_LITTLE_ALL	((cpu_subtype_t) 0)
#define	CPU_SUBTYPE_I860_LITTLE	((cpu_subtype_t) 1)

/*
 *	RS6000 subtypes
 */
#define	CPU_SUBTYPE_RS6000_ALL	((cpu_subtype_t) 0)
#define CPU_SUBTYPE_RS6000	((cpu_subtype_t) 1)

/*
 *	Sun4 subtypes - port done at CMU
 */
#define	CPU_SUBTYPE_SUN4_ALL		((cpu_subtype_t) 0)
#define CPU_SUBTYPE_SUN4_260		((cpu_subtype_t) 1)
#define CPU_SUBTYPE_SUN4_110		((cpu_subtype_t) 2)

#define	CPU_SUBTYPE_SPARC_ALL		((cpu_subtype_t) 0)

/*
 *      PowerPC subtypes
 */
#define CPU_SUBTYPE_POWERPC_ALL		((cpu_subtype_t) 0)
#define CPU_SUBTYPE_POWERPC_601		((cpu_subtype_t) 1)
#define CPU_SUBTYPE_POWERPC_602		((cpu_subtype_t) 2)
#define CPU_SUBTYPE_POWERPC_603		((cpu_subtype_t) 3)
#define CPU_SUBTYPE_POWERPC_603e	((cpu_subtype_t) 4)
#define CPU_SUBTYPE_POWERPC_603ev	((cpu_subtype_t) 5)
#define CPU_SUBTYPE_POWERPC_604		((cpu_subtype_t) 6)
#define CPU_SUBTYPE_POWERPC_604e	((cpu_subtype_t) 7)
#define CPU_SUBTYPE_POWERPC_620		((cpu_subtype_t) 8)
#define CPU_SUBTYPE_POWERPC_750		((cpu_subtype_t) 9)
#define CPU_SUBTYPE_POWERPC_7400	((cpu_subtype_t) 10)
#define CPU_SUBTYPE_POWERPC_7450	((cpu_subtype_t) 11)
#define CPU_SUBTYPE_POWERPC_970		((cpu_subtype_t) 100)

/*
 * VEO subtypes
 * Note: the CPU_SUBTYPE_VEO_ALL will likely change over time to be defined as
 * one of the specific subtypes.
 */
#define CPU_SUBTYPE_VEO_1	((cpu_subtype_t) 1)
#define CPU_SUBTYPE_VEO_2	((cpu_subtype_t) 2)
#define CPU_SUBTYPE_VEO_3	((cpu_subtype_t) 3)
#define CPU_SUBTYPE_VEO_4	((cpu_subtype_t) 4)
#define CPU_SUBTYPE_VEO_ALL	CPU_SUBTYPE_VEO_2


#endif	/* _MACH_MACHINE_H_ */
                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/ppc/                           0040755 0001750 0001750 00000000000 12612724206 023560  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/ppc/_structs.h                 0100644 0001750 0001750 00000027027 12612724206 025604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_MACH_PPC__STRUCTS_H_
#define	_MACH_PPC__STRUCTS_H_

#include <sys/cdefs.h>

/*
 * ppc_thread_state is the structure that is exported to user threads for 
 * use in status/mutate calls.  This structure should never change.
 *
 */

#if __DARWIN_UNIX03
#define	_STRUCT_PPC_THREAD_STATE	struct __darwin_ppc_thread_state
_STRUCT_PPC_THREAD_STATE
{
	unsigned int __srr0;	/* Instruction address register (PC) */
	unsigned int __srr1;	/* Machine state register (supervisor) */
	unsigned int __r0;
	unsigned int __r1;
	unsigned int __r2;
	unsigned int __r3;
	unsigned int __r4;
	unsigned int __r5;
	unsigned int __r6;
	unsigned int __r7;
	unsigned int __r8;
	unsigned int __r9;
	unsigned int __r10;
	unsigned int __r11;
	unsigned int __r12;
	unsigned int __r13;
	unsigned int __r14;
	unsigned int __r15;
	unsigned int __r16;
	unsigned int __r17;
	unsigned int __r18;
	unsigned int __r19;
	unsigned int __r20;
	unsigned int __r21;
	unsigned int __r22;
	unsigned int __r23;
	unsigned int __r24;
	unsigned int __r25;
	unsigned int __r26;
	unsigned int __r27;
	unsigned int __r28;
	unsigned int __r29;
	unsigned int __r30;
	unsigned int __r31;

	unsigned int __cr;	/* Condition register */
	unsigned int __xer;	/* User's integer exception register */
	unsigned int __lr;	/* Link register */
	unsigned int __ctr;	/* Count register */
	unsigned int __mq;	/* MQ register (601 only) */

	unsigned int __vrsave;	/* Vector Save Register */
};
#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_PPC_THREAD_STATE	struct ppc_thread_state
_STRUCT_PPC_THREAD_STATE
{
	unsigned int srr0;	/* Instruction address register (PC) */
	unsigned int srr1;	/* Machine state register (supervisor) */
	unsigned int r0;
	unsigned int r1;
	unsigned int r2;
	unsigned int r3;
	unsigned int r4;
	unsigned int r5;
	unsigned int r6;
	unsigned int r7;
	unsigned int r8;
	unsigned int r9;
	unsigned int r10;
	unsigned int r11;
	unsigned int r12;
	unsigned int r13;
	unsigned int r14;
	unsigned int r15;
	unsigned int r16;
	unsigned int r17;
	unsigned int r18;
	unsigned int r19;
	unsigned int r20;
	unsigned int r21;
	unsigned int r22;
	unsigned int r23;
	unsigned int r24;
	unsigned int r25;
	unsigned int r26;
	unsigned int r27;
	unsigned int r28;
	unsigned int r29;
	unsigned int r30;
	unsigned int r31;

	unsigned int cr;	/* Condition register */
	unsigned int xer;	/* User's integer exception register */
	unsigned int lr;	/* Link register */
	unsigned int ctr;	/* Count register */
	unsigned int mq;	/* MQ register (601 only) */

	unsigned int vrsave;	/* Vector Save Register */
};
#endif /* __DARWIN_UNIX03 */

/* cctools-port: commented */
//#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)

#pragma pack(4)			/* Make sure the structure stays as we defined it */

#if __DARWIN_UNIX03
#define _STRUCT_PPC_THREAD_STATE64	struct __darwin_ppc_thread_state64
_STRUCT_PPC_THREAD_STATE64
{
	unsigned long long __srr0;	/* Instruction address register (PC) */
	unsigned long long __srr1;	/* Machine state register (supervisor) */
	unsigned long long __r0;
	unsigned long long __r1;
	unsigned long long __r2;
	unsigned long long __r3;
	unsigned long long __r4;
	unsigned long long __r5;
	unsigned long long __r6;
	unsigned long long __r7;
	unsigned long long __r8;
	unsigned long long __r9;
	unsigned long long __r10;
	unsigned long long __r11;
	unsigned long long __r12;
	unsigned long long __r13;
	unsigned long long __r14;
	unsigned long long __r15;
	unsigned long long __r16;
	unsigned long long __r17;
	unsigned long long __r18;
	unsigned long long __r19;
	unsigned long long __r20;
	unsigned long long __r21;
	unsigned long long __r22;
	unsigned long long __r23;
	unsigned long long __r24;
	unsigned long long __r25;
	unsigned long long __r26;
	unsigned long long __r27;
	unsigned long long __r28;
	unsigned long long __r29;
	unsigned long long __r30;
	unsigned long long __r31;

	unsigned int __cr;		/* Condition register */
	unsigned long long __xer;	/* User's integer exception register */
	unsigned long long __lr;	/* Link register */
	unsigned long long __ctr;	/* Count register */

	unsigned int __vrsave;		/* Vector Save Register */
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_PPC_THREAD_STATE64	struct ppc_thread_state64
_STRUCT_PPC_THREAD_STATE64
{
	unsigned long long srr0;	/* Instruction address register (PC) */
	unsigned long long srr1;	/* Machine state register (supervisor) */
	unsigned long long r0;
	unsigned long long r1;
	unsigned long long r2;
	unsigned long long r3;
	unsigned long long r4;
	unsigned long long r5;
	unsigned long long r6;
	unsigned long long r7;
	unsigned long long r8;
	unsigned long long r9;
	unsigned long long r10;
	unsigned long long r11;
	unsigned long long r12;
	unsigned long long r13;
	unsigned long long r14;
	unsigned long long r15;
	unsigned long long r16;
	unsigned long long r17;
	unsigned long long r18;
	unsigned long long r19;
	unsigned long long r20;
	unsigned long long r21;
	unsigned long long r22;
	unsigned long long r23;
	unsigned long long r24;
	unsigned long long r25;
	unsigned long long r26;
	unsigned long long r27;
	unsigned long long r28;
	unsigned long long r29;
	unsigned long long r30;
	unsigned long long r31;

	unsigned int cr;		/* Condition register */
	unsigned long long xer;		/* User's integer exception register */
	unsigned long long lr;		/* Link register */
	unsigned long long ctr;		/* Count register */

	unsigned int vrsave;		/* Vector Save Register */
};
#endif /* __DARWIN_UNIX03 */

#pragma pack()

/* cctools-port: commented */
//#endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

/* This structure should be double-word aligned for performance */

#if __DARWIN_UNIX03
#define	_STRUCT_PPC_FLOAT_STATE	struct __darwin_ppc_float_state
_STRUCT_PPC_FLOAT_STATE
{
	double  __fpregs[32];

	unsigned int __fpscr_pad; /* fpscr is 64 bits, 32 bits of rubbish */
	unsigned int __fpscr;	/* floating point status register */
};
#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_PPC_FLOAT_STATE	struct ppc_float_state
_STRUCT_PPC_FLOAT_STATE
{
	double  fpregs[32];

	unsigned int fpscr_pad; /* fpscr is 64 bits, 32 bits of rubbish */
	unsigned int fpscr;	/* floating point status register */
};
#endif /* __DARWIN_UNIX03 */

#pragma pack(4)		/* Make sure the structure stays as we defined it */

#if __DARWIN_UNIX03
#define _STRUCT_PPC_VECTOR_STATE	struct __darwin_ppc_vector_state
_STRUCT_PPC_VECTOR_STATE
{
#if defined(__LP64__)
	unsigned int	__save_vr[32][4];
	unsigned int	__save_vscr[4];
#else
	unsigned long	__save_vr[32][4];
	unsigned long	__save_vscr[4];
#endif
	unsigned int	__save_pad5[4];
	unsigned int	__save_vrvalid;			/* VRs that have been saved */
	unsigned int	__save_pad6[7];
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_PPC_VECTOR_STATE	struct ppc_vector_state
_STRUCT_PPC_VECTOR_STATE
{
#if defined(__LP64__)
	unsigned int	save_vr[32][4];
	unsigned int	save_vscr[4];
#else
	unsigned long	save_vr[32][4];
	unsigned long	save_vscr[4];
#endif
	unsigned int	save_pad5[4];
	unsigned int	save_vrvalid;			/* VRs that have been saved */
	unsigned int	save_pad6[7];
};
#endif /* __DARWIN_UNIX03 */

#pragma pack()

/*
 * ppc_exception_state
 *
 * This structure corresponds to some additional state of the user
 * registers as saved in the PCB upon kernel entry. They are only
 * available if an exception is passed out of the kernel, and even
 * then not all are guaranteed to be updated.
 *
 * Some padding is included in this structure which allows space for
 * servers to store temporary values if need be, to maintain binary
 * compatiblity.
 */

/* Exception state for 32-bit thread (on 32-bit processor) */
/* Still available on 64-bit processors, but may fall short */
/* of covering the full potential state (hi half available). */

#pragma pack(4)	/* Make sure the structure stays as we defined it */

#if __DARWIN_UNIX03
#define _STRUCT_PPC_EXCEPTION_STATE	struct __darwin_ppc_exception_state
_STRUCT_PPC_EXCEPTION_STATE
{
#if defined(__LP64__)
	unsigned int __dar;		/* Fault registers for coredump */
	unsigned int __dsisr;
	unsigned int __exception;	/* number of powerpc exception taken */
	unsigned int __pad0;		/* align to 16 bytes */
	unsigned int __pad1[4];		/* space in PCB "just in case" */
#else
	unsigned long __dar;		/* Fault registers for coredump */
	unsigned long __dsisr;
	unsigned long __exception;	/* number of powerpc exception taken */
	unsigned long __pad0;		/* align to 16 bytes */
	unsigned long __pad1[4];	/* space in PCB "just in case" */
#endif
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_PPC_EXCEPTION_STATE	struct ppc_exception_state
_STRUCT_PPC_EXCEPTION_STATE
{
#if defined(__LP64__)
	unsigned int dar;		/* Fault registers for coredump */
	unsigned int dsisr;
	unsigned int exception;		/* number of powerpc exception taken */
	unsigned int pad0;		/* align to 16 bytes */
	unsigned int pad1[4];		/* space in PCB "just in case" */
#else
	unsigned long dar;		/* Fault registers for coredump */
	unsigned long dsisr;
	unsigned long exception;	/* number of powerpc exception taken */
	unsigned long pad0;		/* align to 16 bytes */
	unsigned long pad1[4];		/* space in PCB "just in case" */
#endif
};
#endif /* __DARWIN_UNIX03 */

/* cctools-port: commented */
//#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#if __DARWIN_UNIX03
#define _STRUCT_PPC_EXCEPTION_STATE64	struct __darwin_ppc_exception_state64
_STRUCT_PPC_EXCEPTION_STATE64
{
	unsigned long long __dar;	/* Fault registers for coredump */
#if defined(__LP64__)
	unsigned int  __dsisr;
	unsigned int  __exception;	/* number of powerpc exception taken */
	unsigned int  __pad1[4];	/* space in PCB "just in case" */
#else
	unsigned long __dsisr;
	unsigned long __exception;	/* number of powerpc exception taken */
	unsigned long __pad1[4];	/* space in PCB "just in case" */
#endif
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_PPC_EXCEPTION_STATE64	struct ppc_exception_state64
_STRUCT_PPC_EXCEPTION_STATE64
{
	unsigned long long dar;		/* Fault registers for coredump */
#if defined(__LP64__)
	unsigned int  dsisr;
	unsigned int  exception;	/* number of powerpc exception taken */
	unsigned int  pad1[4];		/* space in PCB "just in case" */
#else
	unsigned long dsisr;
	unsigned long exception;	/* number of powerpc exception taken */
	unsigned long pad1[4];		/* space in PCB "just in case" */
#endif
};
#endif /* __DARWIN_UNIX03 */
/* cctools-port: commented */
//#endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

#pragma pack()

#endif /* _MACH_PPC__STRUCTS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/ppc/thread_status.h            0100644 0001750 0001750 00000012071 12612724206 026601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_MACH_PPC_THREAD_STATUS_H_
#define _MACH_PPC_THREAD_STATUS_H_

#include <mach/ppc/_structs.h>
#include <mach/message.h>

/*
 * ppc_thread_state is the structure that is exported to user threads for 
 * use in status/mutate calls.  This structure should never change.
 *
 */

#define PPC_THREAD_STATE        1
#define PPC_FLOAT_STATE         2
#define PPC_EXCEPTION_STATE		3
#define PPC_VECTOR_STATE		4
#define PPC_THREAD_STATE64		5
#define PPC_EXCEPTION_STATE64	6
/*
#define THREAD_STATE_NONE		7
*/
	       
/*
 * VALID_THREAD_STATE_FLAVOR is a platform specific macro that when passed
 * an exception flavor will return whether that is a defined flavor for
 * that platform.
 * The macro must be manually updated to include all of the valid exception
 * flavors as defined above.
 */
/*
#define VALID_THREAD_STATE_FLAVOR(x)       \
        ((x == PPC_THREAD_STATE)        || \
         (x == PPC_FLOAT_STATE)         || \
	 (x == PPC_EXCEPTION_STATE)     	|| \
         (x == PPC_VECTOR_STATE)        || \
         (x == PPC_THREAD_STATE64)      || \
         (x == PPC_EXCEPTION_STATE64)   || \
         (x == THREAD_STATE_NONE))
*/

typedef _STRUCT_PPC_THREAD_STATE	ppc_thread_state_t;
/* cctools-port: commented */
//#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
typedef _STRUCT_PPC_THREAD_STATE64	ppc_thread_state64_t;
/* cctools-port: commented */
//#endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */
typedef _STRUCT_PPC_FLOAT_STATE		ppc_float_state_t;
typedef _STRUCT_PPC_VECTOR_STATE	ppc_vector_state_t;

/*
 * saved state structure
 *
 * This structure corresponds to the saved state. 
 *
 */

#ifdef	MACH__POSIX_C_SOURCE_PRIVATE

#include <ppc/savearea.h>

typedef struct savearea				ppc_saved_state_t;

#else	/* MACH__POSIX_C_SOURCE_PRIVATE */

typedef struct ppc_thread_state			ppc_saved_state_t;

#endif	/* MACH__POSIX_C_SOURCE_PRIVATE */

/*
 * ppc_exception_state
 *
 * This structure corresponds to some additional state of the user
 * registers as saved in the PCB upon kernel entry. They are only
 * available if an exception is passed out of the kernel, and even
 * then not all are guaranteed to be updated.
 *
 * Some padding is included in this structure which allows space for
 * servers to store temporary values if need be, to maintain binary
 * compatiblity.
 */

/* Exception state for 32-bit thread (on 32-bit processor) */
/* Still available on 64-bit processors, but may fall short */
/* of covering the full potential state (hi half available). */

typedef _STRUCT_PPC_EXCEPTION_STATE	ppc_exception_state_t;
#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
typedef _STRUCT_PPC_EXCEPTION_STATE64	ppc_exception_state64_t;
#endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

/*
 * Save State Flags
 */

#define PPC_THREAD_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof(ppc_thread_state_t) / sizeof(int)))

#define PPC_THREAD_STATE64_COUNT ((mach_msg_type_number_t) \
   (sizeof(ppc_thread_state64_t) / sizeof(int)))

#define PPC_EXCEPTION_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof(ppc_exception_state_t) / sizeof(int)))

#define PPC_EXCEPTION_STATE64_COUNT ((mach_msg_type_number_t) \
   (sizeof(ppc_exception_state64_t) / sizeof(int)))

#define PPC_FLOAT_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof(ppc_float_state_t) / sizeof(int)))

#define PPC_VECTOR_STATE_COUNT ((mach_msg_type_number_t) \
   (sizeof(ppc_vector_state_t) / sizeof(int)))

/*
 * Machine-independent way for servers and Mach's exception mechanism to
 * choose the most efficient state flavor for exception RPC's:
 */
/*
#define MACHINE_THREAD_STATE		PPC_THREAD_STATE
#define MACHINE_THREAD_STATE_COUNT	PPC_THREAD_STATE_COUNT
*/

/*
 * Largest state on this machine:
 */
#define THREAD_MACHINE_STATE_MAX	THREAD_STATE_MAX

#endif /* _MACH_PPC_THREAD_STATUS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/sparc/                         0040755 0001750 0001750 00000000000 12612724206 024106  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach/sparc/thread_status.h          0100644 0001750 0001750 00000005547 12612724206 027141  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 *  Copyright (c) 1994 by Sun Microsystems, Inc
 */

#ifndef	_MACH_SPARC_THREAD_STATUS_H_
#define	_MACH_SPARC_THREAD_STATUS_H_

#include <architecture/sparc/reg.h>

/*
 *	sparc_thread_state_regs
 *		This is the structure that is exported
 *      to user threads for use in set/get status
 *      calls.  This structure should never change.
 *		The "local" and "in" registers of the corresponding 
 *		register window	are saved in the stack frame pointed
 *		to by sp -> %o6.
 *
 *	sparc_thread_state_fpu
 *		This is the structure that is exported
 *      to user threads for use in set/get FPU register 
 *		status calls.
 *
 */

#define	SPARC_THREAD_STATE_REGS	1

struct sparc_thread_state_regs {
	struct regs regs;
};

#define	SPARC_THREAD_STATE_REGS_COUNT \
			(sizeof(struct sparc_thread_state_regs) / sizeof(int))

/*
 *	Floating point unit registers
 */

#define SPARC_THREAD_STATE_FPU	2


struct sparc_thread_state_fpu {
	struct fpu fpu;	/* floating point registers/status */
};

#define	SPARC_THREAD_STATE_FPU_COUNT \
			(sizeof(struct sparc_thread_state_fpu) / sizeof(int))

#define	SPARC_THREAD_STATE_FLAVOR_COUNT  2

#define SPARC_THREAD_STATE_FLAVOR_LIST_COUNT         \
	( SPARC_THREAD_STATE_FLAVOR_COUNT *              \
		(sizeof (struct thread_state_flavor) / sizeof(int)))

#endif	/* _MACH_SPARC_THREAD_STATUS_H_ */
                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/                             0040755 0001750 0001750 00000000000 12612724206 023232  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/arch.h                       0100644 0001750 0001750 00000010137 12612724206 024317  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_ARCH_H_
#define _MACH_O_ARCH_H_
/*
 * Copyright (c) 1997 Apple Computer, Inc.
 *
 * Functions that deal with information about architectures.
 *
 */

#include <stdint.h>
#include <mach/machine.h>
#include <architecture/byte_order.h>

/* The NXArchInfo structs contain the architectures symbolic name
 * (such as "ppc"), its CPU type and CPU subtype as defined in
 * mach/machine.h, the byte order for the architecture, and a
 * describing string (such as "PowerPC").
 * There will both be entries for specific CPUs (such as ppc604e) as
 * well as generic "family" entries (such as ppc).
 */
typedef struct {
    const char *name;
    cpu_type_t cputype;
    cpu_subtype_t cpusubtype;
    enum NXByteOrder byteorder;
    const char *description;
} NXArchInfo;

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* NXGetAllArchInfos() returns a pointer to an array of all known
 * NXArchInfo structures.  The last NXArchInfo is marked by a NULL name.
 */
extern const NXArchInfo *NXGetAllArchInfos(void);

/* NXGetLocalArchInfo() returns the NXArchInfo for the local host, or NULL
 * if none is known. 
 */
extern const NXArchInfo *NXGetLocalArchInfo(void);

/* NXGetArchInfoFromName() and NXGetArchInfoFromCpuType() return the
 * NXArchInfo from the architecture's name or cputype/cpusubtype
 * combination.  A cpusubtype of CPU_SUBTYPE_MULTIPLE can be used
 * to request the most general NXArchInfo known for the given cputype.
 * NULL is returned if no matching NXArchInfo can be found.
 */
extern const NXArchInfo *NXGetArchInfoFromName(const char *name);
extern const NXArchInfo *NXGetArchInfoFromCpuType(cpu_type_t cputype,
						  cpu_subtype_t cpusubtype);

/* NXFindBestFatArch() is passed a cputype and cpusubtype and a set of
 * fat_arch structs and selects the best one that matches (if any) and returns
 * a pointer to that fat_arch struct (or NULL).  The fat_arch structs must be
 * in the host byte order and correct such that the fat_archs really points to
 * enough memory for nfat_arch structs.  It is possible that this routine could
 * fail if new cputypes or cpusubtypes are added and an old version of this
 * routine is used.  But if there is an exact match between the cputype and
 * cpusubtype and one of the fat_arch structs this routine will always succeed.
 */
extern struct fat_arch *NXFindBestFatArch(cpu_type_t cputype,
					  cpu_subtype_t cpusubtype,
					  struct fat_arch *fat_archs,
					  uint32_t nfat_archs);

/* NXCombineCpuSubtypes() returns the resulting cpusubtype when combining two
 * different cpusubtypes for the specified cputype.  If the two cpusubtypes
 * can't be combined (the specific subtypes are mutually exclusive) -1 is
 * returned indicating it is an error to combine them.  This can also fail and
 * return -1 if new cputypes or cpusubtypes are added and an old version of
 * this routine is used.  But if the cpusubtypes are the same they can always
 * be combined and this routine will return the cpusubtype pass in.
 */
extern cpu_subtype_t NXCombineCpuSubtypes(cpu_type_t cputype,
					  cpu_subtype_t cpusubtype1,
					  cpu_subtype_t cpusubtype2);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_ARCH_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/arm/                         0040755 0001750 0001750 00000000000 12612724206 024011  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/arm/reloc.h                  0100644 0001750 0001750 00000005246 12612724206 025272  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Relocation types used in the arm implementation.  Relocation entries for
 * things other than instructions use the same generic relocation as discribed
 * in <mach-o/reloc.h> and their r_type is ARM_RELOC_VANILLA, one of the
 * *_SECTDIFF or the *_PB_LA_PTR types.  The rest of the relocation types are
 * for instructions.  Since they are for instructions the r_address field
 * indicates the 32 bit instruction that the relocation is to be preformed on.
 */
enum reloc_type_arm
{
    ARM_RELOC_VANILLA,	/* generic relocation as discribed above */
    ARM_RELOC_PAIR,	/* the second relocation entry of a pair */
    ARM_RELOC_SECTDIFF,	/* a PAIR follows with subtract symbol value */
    ARM_RELOC_LOCAL_SECTDIFF, /* like ARM_RELOC_SECTDIFF, but the symbol
				 referenced was local.  */
    ARM_RELOC_PB_LA_PTR,/* prebound lazy pointer */
    ARM_RELOC_BR24,	/* 24 bit branch displacement (to a word address) */
    ARM_THUMB_RELOC_BR22, /* 22 bit branch displacement (to a half-word
			     address) */
    ARM_THUMB_32BIT_BRANCH, /* obsolete - a thumb 32-bit branch instruction
			     possibly needing page-spanning branch workaround */

    /*
     * For these two r_type relocations they always have a pair following them
     * and the r_length bits are used differently.  The encoding of the
     * r_length is as follows:
     * low bit of r_length:
     *  0 - :lower16: for movw instructions
     *  1 - :upper16: for movt instructions
     * high bit of r_length:
     *  0 - arm instructions
     *  1 - thumb instructions   
     * the other half of the relocated expression is in the following pair
     * relocation entry in the the low 16 bits of r_address field.
     */
    ARM_RELOC_HALF,
    ARM_RELOC_HALF_SECTDIFF
};
                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/arm64/                       0040755 0001750 0001750 00000000000 12612724206 024163  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/arm64/reloc.h                0100644 0001750 0001750 00000003651 12612724206 025442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Relocation types used in the arm64 implementation.
 */
enum reloc_type_arm64
{
    ARM64_RELOC_UNSIGNED,	  // for pointers
    ARM64_RELOC_SUBTRACTOR,       // must be followed by a ARM64_RELOC_UNSIGNED
    ARM64_RELOC_BRANCH26,         // a B/BL instruction with 26-bit displacement
    ARM64_RELOC_PAGE21,           // pc-rel distance to page of target
    ARM64_RELOC_PAGEOFF12,        // offset within page, scaled by r_length
    ARM64_RELOC_GOT_LOAD_PAGE21,  // pc-rel distance to page of GOT slot
    ARM64_RELOC_GOT_LOAD_PAGEOFF12, // offset within page of GOT slot,
                                    //  scaled by r_length
    ARM64_RELOC_POINTER_TO_GOT,   // for pointers to GOT slots
    ARM64_RELOC_TLVP_LOAD_PAGE21, // pc-rel distance to page of TLVP slot
    ARM64_RELOC_TLVP_LOAD_PAGEOFF12, // offset within page of TLVP slot,
                                     //  scaled by r_length
    ARM64_RELOC_ADDEND		  // must be followed by PAGE21 or PAGEOFF12
};
                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/dyld.h                       0100644 0001750 0001750 00000025230 12612724206 024336  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_DYLD_H_
#define _MACH_O_DYLD_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#include <mach-o/loader.h>
#include <AvailabilityMacros.h>
#ifndef AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
#endif

#ifndef ENUM_DYLD_BOOL
#define ENUM_DYLD_BOOL
#undef FALSE
#undef TRUE
enum DYLD_BOOL {
    FALSE,
    TRUE
};
#endif /* ENUM_DYLD_BOOL */

/*
 * The high level NS... API.
 */

/* Object file image API */
typedef enum {
    NSObjectFileImageFailure, /* for this a message is printed on stderr */
    NSObjectFileImageSuccess,
    NSObjectFileImageInappropriateFile,
    NSObjectFileImageArch,
    NSObjectFileImageFormat, /* for this a message is printed on stderr */
    NSObjectFileImageAccess
} NSObjectFileImageReturnCode;

typedef void * NSObjectFileImage;

/* limited implementation, only MH_BUNDLE files can be used */
extern NSObjectFileImageReturnCode NSCreateObjectFileImageFromFile(
    const char *pathName,
    NSObjectFileImage *objectFileImage);
extern NSObjectFileImageReturnCode NSCreateCoreFileImageFromFile(
    const char *pathName,
    NSObjectFileImage *objectFileImage);
/* not yet implemented */
extern NSObjectFileImageReturnCode NSCreateObjectFileImageFromMemory(
    void *address,
    unsigned long size, 
    NSObjectFileImage *objectFileImage);
extern enum DYLD_BOOL NSDestroyObjectFileImage(
    NSObjectFileImage objectFileImage);
/*
 * API on NSObjectFileImage's for:
 *   "for Each Symbol Definition In Object File Image" (for Dynamic Bundles)
 *   and the same thing for references
 */
extern unsigned long NSSymbolDefinitionCountInObjectFileImage(
    NSObjectFileImage objectFileImage);
extern const char * NSSymbolDefinitionNameInObjectFileImage(
    NSObjectFileImage objectFileImage,
    unsigned long ordinal);
extern unsigned long NSSymbolReferenceCountInObjectFileImage(
    NSObjectFileImage objectFileImage);
extern const char * NSSymbolReferenceNameInObjectFileImage(
    NSObjectFileImage objectFileImage,
    unsigned long ordinal,
    enum DYLD_BOOL *tentative_definition); /* can be NULL */
/*
 * API on NSObjectFileImage:
 *   "does Object File Image define symbol name X" (using sorted symbol table)
 *   and a way to get the named objective-C section
 */
extern enum DYLD_BOOL NSIsSymbolDefinedInObjectFileImage(
    NSObjectFileImage objectFileImage,
    const char *symbolName);
extern void * NSGetSectionDataInObjectFileImage(
    NSObjectFileImage objectFileImage,
    const char *segmentName,
    const char *sectionName,
    unsigned long *size); /* can be NULL */
/* SPI first appeared in Mac OS X 10.3 */
extern enum DYLD_BOOL NSHasModInitObjectFileImage(
    NSObjectFileImage objectFileImage)
    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;

/* module API */
typedef void * NSModule;
extern const char * NSNameOfModule(
    NSModule m); 
extern const char * NSLibraryNameForModule(
    NSModule m);

/* limited implementation, only MH_BUNDLE files can be linked */
extern NSModule NSLinkModule(
    NSObjectFileImage objectFileImage, 
    const char *moduleName,
    unsigned long options);
#define NSLINKMODULE_OPTION_NONE		0x0
#define NSLINKMODULE_OPTION_BINDNOW		0x1
#define NSLINKMODULE_OPTION_PRIVATE		0x2
#define NSLINKMODULE_OPTION_RETURN_ON_ERROR	0x4
#define NSLINKMODULE_OPTION_DONT_CALL_MOD_INIT_ROUTINES 0x8
#define NSLINKMODULE_OPTION_TRAILING_PHYS_NAME	0x10

/* limited implementation, only modules loaded with NSLinkModule() can be
   unlinked */
extern enum DYLD_BOOL NSUnLinkModule(
    NSModule module, 
    unsigned long options);
#define NSUNLINKMODULE_OPTION_NONE			0x0
#define NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED	0x1
#define NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES	0x2

/* not yet implemented */
extern NSModule NSReplaceModule(
    NSModule moduleToReplace,
    NSObjectFileImage newObjectFileImage, 
    unsigned long options);

/* symbol API */
typedef void * NSSymbol;
extern enum DYLD_BOOL NSIsSymbolNameDefined(
    const char *symbolName);
extern enum DYLD_BOOL NSIsSymbolNameDefinedWithHint(
    const char *symbolName,
    const char *libraryNameHint);
extern enum DYLD_BOOL NSIsSymbolNameDefinedInImage(
    const struct mach_header *image,
    const char *symbolName);
extern NSSymbol NSLookupAndBindSymbol(
    const char *symbolName);
extern NSSymbol NSLookupAndBindSymbolWithHint(
    const char *symbolName,
    const char *libraryNameHint);
extern NSSymbol NSLookupSymbolInModule(
    NSModule module,
    const char *symbolName);
extern NSSymbol NSLookupSymbolInImage(
    const struct mach_header *image,
    const char *symbolName,
    unsigned long options);
#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND            0x0
#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW        0x1
#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY      0x2
#define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4
extern const char * NSNameOfSymbol(
    NSSymbol symbol);
extern void * NSAddressOfSymbol(
    NSSymbol symbol);
extern NSModule NSModuleForSymbol(
    NSSymbol symbol);

/* error handling API */
typedef enum {
    NSLinkEditFileAccessError,
    NSLinkEditFileFormatError,
    NSLinkEditMachResourceError,
    NSLinkEditUnixResourceError,
    NSLinkEditOtherError,
    NSLinkEditWarningError,
    NSLinkEditMultiplyDefinedError,
    NSLinkEditUndefinedError
} NSLinkEditErrors;

/*
 * For the NSLinkEditErrors value NSLinkEditOtherError these are the values
 * passed to the link edit error handler as the errorNumber (what would be an
 * errno value for NSLinkEditUnixResourceError or a kern_return_t value for
 * NSLinkEditMachResourceError).
 */
typedef enum {
    NSOtherErrorRelocation, 
    NSOtherErrorLazyBind,
    NSOtherErrorIndrLoop,
    NSOtherErrorLazyInit,
    NSOtherErrorInvalidArgs
} NSOtherErrorNumbers;

extern void NSLinkEditError(
    NSLinkEditErrors *c,
    int *errorNumber, 
    const char **fileName,
    const char **errorString);

typedef struct {
     void     (*undefined)(const char *symbolName);
     NSModule (*multiple)(NSSymbol s, NSModule oldModule, NSModule newModule); 
     void     (*linkEdit)(NSLinkEditErrors errorClass, int errorNumber,
                          const char *fileName, const char *errorString);
} NSLinkEditErrorHandlers;

extern void NSInstallLinkEditErrorHandlers(
    NSLinkEditErrorHandlers *handlers);

/* other API */
extern enum DYLD_BOOL NSAddLibrary(
    const char *pathName);
extern enum DYLD_BOOL NSAddLibraryWithSearching(
    const char *pathName);
extern const struct mach_header * NSAddImage(
    const char *image_name,
    unsigned long options);
#define NSADDIMAGE_OPTION_NONE                  	0x0
#define NSADDIMAGE_OPTION_RETURN_ON_ERROR       	0x1
#define NSADDIMAGE_OPTION_WITH_SEARCHING        	0x2
#define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED 	0x4
#define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME	0x8
extern long NSVersionOfRunTimeLibrary(
    const char *libraryName);
extern long NSVersionOfLinkTimeLibrary(
    const char *libraryName);
extern int _NSGetExecutablePath( /* SPI first appeared in Mac OS X 10.2 */
    char *buf,
    uint32_t *bufsize);

/*
 * The low level _dyld_... API.
 * (used by the objective-C runtime primarily)
 */
extern unsigned long _dyld_present(
    void);

extern unsigned long _dyld_image_count(
    void);
#ifdef __LP64__
extern struct mach_header_64 * _dyld_get_image_header(
    uint32_t image_index);
#else /* !defined(__LP64__) */
extern struct mach_header * _dyld_get_image_header(
    unsigned long image_index);
#endif /* !defined(__LP64__) */
extern unsigned long _dyld_get_image_vmaddr_slide(
    unsigned long image_index);
extern char * _dyld_get_image_name(
    unsigned long image_index);

extern void _dyld_register_func_for_add_image(
    void (*func)(struct mach_header *mh, unsigned long vmaddr_slide));
extern void _dyld_register_func_for_remove_image(
    void (*func)(struct mach_header *mh, unsigned long vmaddr_slide));
extern void _dyld_register_func_for_link_module(
    void (*func)(NSModule module));
/* not yet implemented */
extern void _dyld_register_func_for_unlink_module(
    void (*func)(NSModule module));
/* not yet implemented */
extern void _dyld_register_func_for_replace_module(
    void (*func)(NSModule oldmodule, NSModule newmodule));
extern void _dyld_get_objc_module_sect_for_module(
    NSModule module,
    void **objc_module,
    unsigned long *size);
extern void _dyld_bind_objc_module(
    void *objc_module);
extern enum DYLD_BOOL _dyld_bind_fully_image_containing_address(
    unsigned long *address);
extern enum DYLD_BOOL _dyld_image_containing_address(
    unsigned long address);
/* SPI first appeared in Mac OS X 10.3 */
extern struct mach_header * _dyld_get_image_header_containing_address(
    unsigned long address)
    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;

extern void _dyld_moninit(
    void (*monaddition)(char *lowpc, char *highpc));
extern enum DYLD_BOOL _dyld_launched_prebound(
    void);
/* SPI first appeared in Mac OS X 10.3 */
extern enum DYLD_BOOL _dyld_all_twolevel_modules_prebound(
    void)
    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;

extern void _dyld_lookup_and_bind(
    const char *symbol_name,
    unsigned long *address,
    void **module);
extern void _dyld_lookup_and_bind_with_hint(
    const char *symbol_name,
    const char *library_name_hint,
    unsigned long *address,
    void **module);
extern void _dyld_lookup_and_bind_objc(
    const char *symbol_name,
    unsigned long *address,
    void **module);
extern void _dyld_lookup_and_bind_fully(
    const char *symbol_name,
    unsigned long *address,
    void **module);

__private_extern__ int _dyld_func_lookup(
    const char *dyld_func_name,
    unsigned long *address);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_DYLD_H_ */
                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/dyld_debug.h                 0100644 0001750 0001750 00000016556 12612724206 025517  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _DYLD_DEBUG_
#define _DYLD_DEBUG_

#include <mach/mach.h>
#ifndef DYLD_BUILD /* do not include this when building dyld itself */
#include <mach-o/dyld.h>
#endif /* !defined(DYLD_BUILD) */
/*
 * The dyld debugging API.
 */
enum dyld_debug_return {
    DYLD_SUCCESS,
    DYLD_INCONSISTENT_DATA,
    DYLD_INVALID_ARGUMENTS,
    DYLD_FAILURE
};

struct dyld_debug_module {
    struct mach_header *header;
    unsigned long vmaddr_slide;
    unsigned long module_index;
};

enum dyld_event_type {
    DYLD_IMAGE_ADDED,
    DYLD_MODULE_BOUND,
    DYLD_MODULE_REMOVED,
    DYLD_MODULE_REPLACED,
    DYLD_PAST_EVENTS_END,
    DYLD_IMAGE_REMOVED
};

struct dyld_event {
    enum dyld_event_type type;
    struct dyld_debug_module arg[2];
};

extern enum dyld_debug_return _dyld_debug_defining_module(
    mach_port_t target_task,
    unsigned long send_timeout,
    unsigned long rcv_timeout,
    boolean_t inconsistent_data_ok,
    char *name,
    struct dyld_debug_module *module);

extern enum dyld_debug_return _dyld_debug_is_module_bound(
    mach_port_t target_task,
    unsigned long send_timeout,
    unsigned long rcv_timeout,
    boolean_t inconsistent_data_ok,
    struct dyld_debug_module module,
    boolean_t *bound);

extern enum dyld_debug_return _dyld_debug_bind_module(
    mach_port_t target_task,
    unsigned long send_timeout,
    unsigned long rcv_timeout,
    boolean_t inconsistent_data_ok,
    struct dyld_debug_module module);

extern enum dyld_debug_return _dyld_debug_module_name(
    mach_port_t target_task,
    unsigned long send_timeout,
    unsigned long rcv_timeout,
    boolean_t inconsistent_data_ok,
    struct dyld_debug_module module,
    char **image_name,
    unsigned long *image_nameCnt,
    char **module_name,
    unsigned long *module_nameCnt);

extern enum dyld_debug_return _dyld_debug_subscribe_to_events(
    mach_port_t target_task,
    unsigned long send_timeout,
    unsigned long rcv_timeout,
    boolean_t inconsistent_data_ok,
    void (*dyld_event_routine)(struct dyld_event event));

/*
 * _dyld_debug_add_event_subscriber() uses the mig interface functions below
 * to dispatch the dyld event messages from the subscriber port specified.
 */
extern enum dyld_debug_return _dyld_debug_add_event_subscriber(
    mach_port_t target_task,
    unsigned long send_timeout,
    unsigned long rcv_timeout,
    boolean_t inconsistent_data_ok,
    mach_port_t subscriber);

/*
 * These structures should be produced by mig(1) from the mig generated files
 * but they are not.  These are really only needed so the correct size of the
 * request and reply messages can be allocated.
 */
struct _dyld_event_message_request {
#ifdef __MACH30__
    mach_msg_header_t head;
    NDR_record_t NDR;
    struct dyld_event event;
    mach_msg_trailer_t trailer;
#else
    msg_header_t head;
    msg_type_t eventType;
    struct dyld_event event;
#endif
};
struct _dyld_event_message_reply {
#ifdef __MACH30__
    mach_msg_header_t head;
    NDR_record_t NDR;
    struct dyld_event event;
#else
    msg_header_t head;
    msg_type_t RetCodeType;
    kern_return_t RetCode;
#endif
};
#ifndef	mig_internal
/*
 * _dyld_event_server() is the mig generated routine to dispatch dyld event
 * messages.
 */
extern boolean_t _dyld_event_server(
#ifdef __MACH30__
    mach_msg_header_t *request,
    mach_msg_header_t *reply);
#else
    struct _dyld_event_message_request *request,
    struct _dyld_event_message_reply *reply);
#endif
#endif /* mig_internal */

#ifndef SHLIB
/*
 * _dyld_event_server_callback() is the routine called by _dyld_event_server()
 * that must be written by users of _dyld_event_server().
 */
extern
#ifdef __MACH30__
kern_return_t
#else
void
#endif
_dyld_event_server_callback(
#ifdef __MACH30__
    mach_port_t subscriber,
#else
    port_t subscriber,
#endif
    struct dyld_event event);
#endif /* SHLIB */

/*
 * This is the state of the target task while we are sending a message to it.
 */
struct _dyld_debug_task_state {
    mach_port_t	   debug_port;
    mach_port_t    debug_thread;
    unsigned int   debug_thread_resume_count;
    unsigned int   task_resume_count;
    mach_port_t   *threads;
    unsigned int   thread_count;
};

/*
 * _dyld_debug_make_runnable() is called before sending messages to the
 * dynamic link editor.  Basically it assures that the debugging
 * thread is the only runnable thread in the task to receive the
 * message.  It also assures that the debugging thread is indeed
 * runnable if it was suspended.  The function will make sure each 
 * thread in the remote task is suspended and resumed the same number
 * of times, so in the end the suspend count of each individual thread
 * is the same.
 */
extern enum dyld_debug_return _dyld_debug_make_runnable(
    mach_port_t target_task,
    struct _dyld_debug_task_state *state);

/*
 * _dyld_debug_restore_runnable() is called after sending messages to the
 * dynamic link editor.  It undoes what _dyld_debug_make_runnable() did to the
 * task and put it back the way it was.
 */
extern enum dyld_debug_return _dyld_debug_restore_runnable(
    mach_port_t target_task,
    struct _dyld_debug_task_state *state);

/*
 * To provide more detailed information when the APIs of the dyld debug
 * interfaces fail (return DYLD_FAILURE) the following structure is filled in.
 * After it is filled in the function registered with
 * set_dyld_debug_error_func() is called with a pointer to that struct.
 *
 * The local_error field is a unique number for each possible error condition
 * in the source code in that makes up the dyld debug APIs.  The source file
 * and line number in the cctools libdyld directory where the dyld debug APIs
 * are implemented are set into the file_name and line_number fields.  The
 * field dyld_debug_return is filled in with that would be returned by the
 * API (usually DYLD_FAILURE).  The other fields will be zero or filled in by
 * the error code from the mach system call, or UNIX system call that failed.
 */
struct dyld_debug_error_data {
    enum dyld_debug_return dyld_debug_return;
    kern_return_t mach_error;
    int dyld_debug_errno;
    unsigned long local_error;
    char *file_name;
    unsigned long line_number;
};

extern void _dyld_debug_set_error_func(
    void (*func)(struct dyld_debug_error_data *e));

#ifndef DYLD_BUILD /* do not include this when building dyld itself */

extern enum dyld_debug_return _dyld_debug_task_from_core(
    NSObjectFileImage coreFileImage,
    mach_port_t *core_task);

#endif /* !defined(DYLD_BUILD) */

#endif /* _DYLD_DEBUG_ */
                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/dyld_gdb.h                   0100644 0001750 0001750 00000010103 12612724206 025143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _DYLD_GDB_
#define _DYLD_GDB_
/*
 * This file describes the interface between gdb and dyld created for
 * MacOS X GM.  Prior to MacOS X GM gdb used the dyld_debug interfaces
 * described in <mach-o/dyld_debug.h>.
 */

/*
 * gdb_dyld_version is the version of gdb interface that dyld is currently
 * exporting.  For the interface described in this header file gdb_dyld_version
 * is 2.  As the gdb/dyld interface changes this number will be incremented and
 * comments will be added as to what are the are changes for the various
 * versions.
 */
extern unsigned int gdb_dyld_version;

/* 
 * gdb_dyld_state_changed is the internal dyld routine called by dyld to notify
 * gdb that the state of the data structures has changed.  gdb is expected to
 * put a break point on this routine and re-read the internal dyld data
 * structures below when this break point is hit.
 */
extern void gdb_dyld_state_changed(void);

/*
 * gdb looks directly at parts of two of dyld's internal data structures.  The
 * list of object file images and the list of library images.  The parts of
 * these structures that gdb looks at will not change unless the value of
 * gdb_dyld_version changes.  The size of these structures and the other fields
 * that gdb does not look at may change.
 *
 *  struct object_images {
 *      struct object_image images[NOBJECT_IMAGES];
 *      unsigned long nimages; 
 *      struct object_images *next_images; 
 *      ...
 *  };
 *
 *  struct library_images { 
 *      struct library_image images[NLIBRARY_IMAGES];
 *      unsigned long nimages;
 *      struct library_images *next_images;
 *      ...
 *  };
 *
 * Both the object_image structure and the library_image structure
 * start with a structure containing the following fields:
 *
 *  struct image {   
 *      char *physical_name;        physical image name (file name)
 *      unsigned long vmaddr_slide; the slide from the staticly linked address
 *      struct mach_header *mh;     address of the mach header of the image
 *	unsigned long valid;        TRUE if this is struct is valid
 *      char *name;                 image name for reporting errors
 *      ...
 *  };
 *
 * In gdb_dyld_version 1 the first field was "name".  In gdb_dyld_version 2 the
 * first field was changed to "physical_name" and a new fifth field "name" was
 * added.  These two fields are set to the same values except in the case of
 * zero-link.  In zero-link the NSLinkModule() option
 * NSLINKMODULE_OPTION_TRAILING_PHYS_NAME is used and then the physical_name is
 * the file name of the module zero-link loaded that is part of the logical
 * image "name".
 */

/* object_images is the global object_images structure */

/* the number of gdb_object_image structures present per bucket */
extern unsigned int gdb_nobject_images;

/* the size of each gdb_object_image structure */
extern unsigned int gdb_object_image_size;

/* library_images is the global library_images structure */

/* the number of gdb_library_image structures present per bucket */
extern unsigned int gdb_nlibrary_images;

/* the size of each gdb_library_image structure */
extern unsigned int gdb_library_image_size;

#endif /* _DYLD_GDB_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/dyld_priv.h                  0100644 0001750 0001750 00000003575 12612724206 025406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_DYLD_PRIV_H_
#define _MACH_O_DYLD_PRIV_H_


#include <mach-o/dyld.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/*
 * Given an imageOffset into an ObjectFileImage, returns 
 * the segment/section name and offset into that section of
 * that imageOffset.  Returns FALSE if the imageOffset is not 
 * in any section.  You can used the resulting sectionOffset to
 * index into the data returned by NSGetSectionDataInObjectFileImage.
 * 
 * First appeared in Mac OS X 10.3 
 *
 * SPI: currently only used by ZeroLink to detect +load methods
 */
enum DYLD_BOOL 
NSFindSectionAndOffsetInObjectFileImage(
    NSObjectFileImage objectFileImage, 
    unsigned long imageOffset,
    const char** segmentName, 	/* can be NULL */
    const char** sectionName, 	/* can be NULL */
    unsigned long* sectionOffset);	/* can be NULL */




#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_DYLD_PRIV_H_ */
                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/fat.h                        0100644 0001750 0001750 00000004746 12612724206 024165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_FAT_H_
#define _MACH_O_FAT_H_
/*
 * This header file describes the structures of the file format for "fat"
 * architecture specific file (wrapper design).  At the begining of the file
 * there is one fat_header structure followed by a number of fat_arch
 * structures.  For each architecture in the file, specified by a pair of
 * cputype and cpusubtype, the fat_header describes the file offset, file
 * size and alignment in the file of the architecture specific member.
 * The padded bytes in the file to place each member on it's specific alignment
 * are defined to be read as zeros and can be left as "holes" if the file system
 * can support them as long as they read as zeros.
 *
 * All structures defined here are always written and read to/from disk
 * in big-endian order.
 */

/*
 * <mach/machine.h> is needed here for the cpu_type_t and cpu_subtype_t types
 * and contains the constants for the possible values of these types.
 */
#include <stdint.h>
#include <mach/machine.h>
#include <architecture/byte_order.h>

#define FAT_MAGIC	0xcafebabe
#define FAT_CIGAM	0xbebafeca	/* NXSwapLong(FAT_MAGIC) */

struct fat_header {
	uint32_t	magic;		/* FAT_MAGIC */
	uint32_t	nfat_arch;	/* number of structs that follow */
};

struct fat_arch {
	cpu_type_t	cputype;	/* cpu specifier (int) */
	cpu_subtype_t	cpusubtype;	/* machine specifier (int) */
	uint32_t	offset;		/* file offset to this object file */
	uint32_t	size;		/* size of this object file */
	uint32_t	align;		/* alignment as a power of 2 */
};

#endif /* _MACH_O_FAT_H_ */
                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/getsect.h                    0100644 0001750 0001750 00000007462 12612724206 025047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_GETSECT_H_
#define _MACH_O_GETSECT_H_

#include <stdint.h>
#include <mach-o/loader.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * Runtime interfaces for Mach-O programs.  For both 32-bit and 64-bit programs,
 * where the sizes returned will be 32-bit or 64-bit based on the size of
 * 'unsigned long'.
 */
extern char *getsectdata(
    const char *segname,
    const char *sectname,
    unsigned long *size);

extern char *getsectdatafromFramework(
    const char *FrameworkName,
    const char *segname,
    const char *sectname,
    unsigned long *size);

extern unsigned long get_end(void);
extern unsigned long get_etext(void);
extern unsigned long get_edata(void);

#ifndef __LP64__
/*
 * Runtime interfaces for 32-bit Mach-O programs.
 */
extern const struct section *getsectbyname(
    const char *segname,
    const char *sectname);

extern uint8_t *getsectiondata(
    const struct mach_header *mhp,
    const char *segname,
    const char *sectname,
    unsigned long *size);

extern const struct segment_command *getsegbyname(
    const char *segname);

extern uint8_t *getsegmentdata(
    const struct mach_header *mhp,
    const char *segname,
    unsigned long *size);

#else /* defined(__LP64__) */
/*
 * Runtime interfaces for 64-bit Mach-O programs.
 */
extern const struct section_64 *getsectbyname(
    const char *segname,
    const char *sectname);

extern uint8_t *getsectiondata(
    const struct mach_header_64 *mhp,
    const char *segname,
    const char *sectname,
    unsigned long *size);

extern const struct segment_command_64 *getsegbyname(
    const char *segname);

extern uint8_t *getsegmentdata(
    const struct mach_header_64 *mhp,
    const char *segname,
    unsigned long *size);

#endif /* defined(__LP64__) */

/*
 * Interfaces for tools working with 32-bit Mach-O files.
 */
extern char *getsectdatafromheader(
    const struct mach_header *mhp,
    const char *segname,
    const char *sectname,
    uint32_t *size);

extern const struct section *getsectbynamefromheader(
    const struct mach_header *mhp,
    const char *segname,
    const char *sectname);

extern const struct section *getsectbynamefromheaderwithswap(
    struct mach_header *mhp,
    const char *segname,
    const char *sectname,
    int fSwap);

/*
 * Interfaces for tools working with 64-bit Mach-O files.
 */
extern char *getsectdatafromheader_64(
    const struct mach_header_64 *mhp,
    const char *segname,
    const char *sectname,
    uint64_t *size);

extern const struct section_64 *getsectbynamefromheader_64(
    const struct mach_header_64 *mhp,
    const char *segname,
    const char *sectname);

extern const struct section *getsectbynamefromheaderwithswap_64(
    struct mach_header_64 *mhp,
    const char *segname,
    const char *sectname,
    int fSwap);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_GETSECT_H_ */
                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/gmon.h                       0100644 0001750 0001750 00000020613 12612724206 024342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: gmon.h,v 1.3 1996/04/21 22:31:46 deraadt Exp $	*/
/*	$NetBSD: gmon.h,v 1.5 1996/04/09 20:55:30 cgd Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)gmon.h	8.2 (Berkeley) 1/4/94
 */
/*
 * This was derived from above and modified to add different profiling info.
 */

/*
 * Histogram counters are unsigned shorts (according to the kernel).
 */
#define	HISTCOUNTER	unsigned short

/*
 * Fraction of text space to allocate for histogram counters here, 1/2
 */
#define	HISTFRACTION	2

/*
 * Fraction of text space to allocate for from hash buckets.
 * The value of HASHFRACTION is based on the minimum number of bytes
 * of separation between two subroutine call points in the object code.
 * Given MIN_SUBR_SEPARATION bytes of separation the value of
 * HASHFRACTION is calculated as:
 *
 * 	HASHFRACTION = MIN_SUBR_SEPARATION / (2 * sizeof(short) - 1);
 *
 * For the VAX,
 *	the shortest two call sequence is:
 * 		calls	$0,(r0)
 *		calls	$0,(r0)
 * 	which is separated by only three bytes, thus HASHFRACTION is 
 *	calculated as:
 *		HASHFRACTION = 3 / (2 * 2 - 1) = 1
 *
 * For the m68k,
 *	the shortest two call sequence is:
 * 		jsr	a0
 *		jsr	a0
 * 	which is separated by only four bytes, thus HASHFRACTION is 
 *	calculated as:
 *		HASHFRACTION = 4 / (2 * 2 - 1) = 1
 *
 * For all RISC machines
 *	the shortest two call sequence is 2 32-bit instructions,
 * 	which is separated by only four bytes, thus HASHFRACTION is 
 *	calculated as:
 *		HASHFRACTION = 4 / (2 * 2 - 1) = 1
 *
 * For the i386,
 *	the shortest two call sequence is:
 * 		call	%eax
 *		call	%eax
 * 	which is separated by only two bytes, thus HASHFRACTION is 
 *	calculated as:
 *		HASHFRACTION = 2 / (2 * 2 - 1) = 0
 *	So on the i386 we use a HASHFRACTION of 1 instead and it can fail
 *	to determine that two call sites are different.  But since all
 *	the call site address in gprof(1) is currently used for is
 *	to determine which routine was doing the calling it works for now.
 *
 * Note that the division above rounds down, thus if MIN_SUBR_FRACTION
 * is less than three, this algorithm will not work!
 */
#define	HASHFRACTION	1

/*
 * percent of text space to allocate for tostructs with a minimum.
 */
#define ARCDENSITY	4
#define MINARCS		50

#ifndef ASSEMBLER
/*
 * The tostruct is used internal to the monitor library routines to implement
 * the recording of calls via mcount().
 */
struct tostruct {
    char		*selfpc;
    long		count;
    unsigned short	link;
    unsigned short	order;
};

/*
 * The phdr (profile header) structure is what appears at the beginning of a
 * mon.out (cc(1) -p) and gmon.out (cc(1) -pg) file and describes the histogram
 * counters.  The histogram counters are unsigned shorts which follow after the
 * header for ncnt - sizeof(struct phdr) bytes.
 */
struct phdr {
    char	*lpc; 	/* low program counter */
    char	*hpc; 	/* high program counter */
    int		ncnt;	/* number of bytes of histogram counters minius
			   sizeof(struct phdr) that follow */
};

/*
 * In a gmon.out (cc(1) -pg) file what follows the above histogram counters are
 * the raw arcs.  A raw arc contains pointers to the calling site, the called
 * site and a count.  These repeat in the gmon.out file after the histogram
 * counters to the end of the file.
 */
struct rawarc {
    unsigned long	raw_frompc;
    unsigned long	raw_selfpc;
    unsigned long	raw_count;
};

/*
 * In order to support more information than in the original mon.out and
 * gmon.out files there is an alternate gmon.out file format.  The alternate
 * gmon.out file format starts with a magic number then separates the
 * information with gmon_data structs.
 */
#define GMON_MAGIC 0xbeefbabe
struct gmon_data {
    unsigned long type; /* constant for type of data following this struct */
    unsigned long size; /* size in bytes of the data following this struct */
};

/*
 * The GMONTYPE_SAMPLES gmon_data.type is for the histogram counters described
 * above and has a struct phdr followed by the counters.
 */
#define GMONTYPE_SAMPLES	1
/*
 * The GMONTYPE_RAWARCS gmon_data.type is for the raw arcs described above.
 */
#define GMONTYPE_RAWARCS	2
/*
 * The GMONTYPE_ARCS_ORDERS gmon_data.type is for the raw arcs with a call
 * order field.  The order is the order is a sequence number for the order each
 * call site was executed.  Raw_order values start at 1 not zero.  Other than
 * the raw_order field this is the same information as in the struct rawarc.
 */
#define GMONTYPE_ARCS_ORDERS	3
struct rawarc_order {
    unsigned long	raw_frompc;
    unsigned long	raw_selfpc;
    unsigned long	raw_count;
    unsigned long	raw_order;
};
/*
 * The GMONTYPE_RLD_STATE gmon_data.type is for the rld_load()'ed state of the
 * program.
 * The informations starts with an unsigned long with the count of states:
 *	rld_nloaded_states
 * Then each state follows in the file.  The state is made up of 
 *	header_addr (where rld loaded this set of objects)
 *	nobjectfiles (the number of objects in this set)
 *		offsets into the string table (one for each object in the set)
 *	nbytes of string table
 *		the file name strings null terminated.
 */
#define GMONTYPE_RLD_STATE	4
/*
 * The GMONTYPE_DYLD_STATE gmon_data.type is for the dynamic link editor state
 * of the program.
 * The informations starts with an unsigned long with the count of states:
 *      image_count
 * Then each state follows in the file.  The state is made up of 
 *      image_header (the address where dyld loaded this image)
 *      vmaddr_slide (the amount dyld slid this image from it's vmaddress)
 *      name (the file name dyld loaded this image from)
 */
#define GMONTYPE_DYLD_STATE     5
#endif /* !ASSEMBLER */

/*
 * general rounding functions.
 */
#define ROUNDDOWN(x,y)	(((x)/(y))*(y))
#define ROUNDUP(x,y)	((((x)+(y)-1)/(y))*(y))
                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/hppa/                        0040755 0001750 0001750 00000000000 12612724206 024162  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/hppa/reloc.h                 0100644 0001750 0001750 00000011026 12612724206 025434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*    reloc.h   -  assemble for HP-PA    */
/*    Defines machine specific relocation entries */

#ifndef HPPA_RELOC_INCLUDED
#define HPPA_RELOC_INCLUDED

/*
 * Relocation types used in the hppa implementation.  Relocation entries for
 * things other than instructions use the same generic relocation as discribed
 * in <mach-o/reloc.h> and their r_type is HPPA_RELOC_VANILLA.  The rest of the
 * relocation types are for instructions.  Since they are for instructions the
 * r_address field indicates the 32 bit instruction that the relocation is to
 * be preformed on.  The field r_pcrel is set only for the HPPA_RELOC_BR17.
 * And r_length is set to long for all non-RELOC_VANILLA r_types.
 */
enum reloc_type_hppa
{
    HPPA_RELOC_VANILLA,	/* generic relocation as discribed in <mach-o/reloc.h>*/
    HPPA_RELOC_PAIR,	/* the second relocation entry of a pair */
    HPPA_RELOC_HI21,	/* a PAIR follows with the low part */
    HPPA_RELOC_LO14,	/* a PAIR follows with the high part */
    HPPA_RELOC_BR17,	/* 17 bit branch displacement (to a word address)
			   a PAIR follows with the high part */
    HPPA_RELOC_BL17,	/* a bl instruction (overlow causes an error) */
    HPPA_RELOC_JBSR, 	/* a bl instruction that is targeted at a long branch
			   stub, a PAIR follows with the high part */
    HPPA_RELOC_SECTDIFF,	/* a PAIR follows with subtract symbol value */
    HPPA_RELOC_HI21_SECTDIFF,	/* a PAIR follows with subtract symbol value */
    HPPA_RELOC_LO14_SECTDIFF,	/* a PAIR follows with subtract symbol value */
    HPPA_RELOC_PB_LA_PTR	/* prebound lazy pointer */
};

/*
 * For the HI and LO relocation types the two parts of the relocated expression
 * (symbol + offset) are calculated as follows:
 *
 *	rounded = round(offset, 0x2000);
 *	left21 =   (symbol + rounded) & 0xfffff800;
 *	right14 = ((symbol + rounded) & 0x000007ff) + (offset - rounded);
 *
 * This allows the left part to be shared between references with different
 * offsets as long as the rounded offsets are the same.
 *
 * The HPPA_RELOC_BR17 r_type also uses the above calculation and the right14
 * bits, sign extened to fill the displacement, and converted to a word
 * displacement by droping the low bits (after checking they are zero).
 */

/*
 * For relocation types that use pairs the part of the relocated expression that
 * is not stored in the instruction is stored in the r_address feild of the
 * PAIR's entry.
 *
 * All low parts are stored as sign extened byte addressed values in the PAIR's
 * r_address field as 32 bit values.  This allows the HI21 not to have to know
 * which type of low it is used with.
 *
 * The high parts are left justified 21 bit values zero filled to 32 bits and 
 * stored in the PAIR's r_address field.
 */

/*
 * The instructions that use the non-RELOC_VANILLA r_types are and the r_types
 * they use are as follows:
 *	instructions	r_type
 *
 *	LDIL,ADDIL	HPPA_RELOC_HI21
 *	LDx, STx, LDO	HPPA_RELOC_LO14
 *	BE, BLE		HPPA_RELOC_BR17
 *	BL		HPPA_RELOC_BL17
 *
 * For the HPPA_RELOC_JBSR the BL instruction must be targeted at a long branch
 * stub that can be reached with 17 bits of signed word displacement.  Also the
 * stub must be in the same block as the BL instruction so that scattered
 * loading done by the link editor will not move them apart.  For example in
 * assembly code:
 *	jbsr	foo,%r2,L1	; creates a bl inst with a HPPA_RELOC_JBSR
 *				;  relocation entry for the symbol foo and the
 *				;  instruction is targeted to L1
 *	...
 * L1:	ldil	L'foo,%r1	; a HPPA_RELOC_HI21 entry for symbol foo
 *	ble,n	R'foo(%sr4,%r1)	; a HPPA_RELOC_BR17 entry for symbol foo
 */

#endif    /* HPPA_RELOC_INCLUDED */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/hppa/swap.h                  0100644 0001750 0001750 00000002625 12612724206 025307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#import <architecture/byte_order.h>
#import <mach/hppa/thread_status.h>

extern void swap_hppa_integer_thread_state(
    struct hp_pa_integer_thread_state *regs,
    enum NXByteOrder target_byte_order);

extern void swap_hppa_frame_thread_state(
    struct hp_pa_frame_thread_state *frame,
    enum NXByteOrder target_byte_order);

extern void swap_hppa_fp_thread_state(
    struct hp_pa_fp_thread_state *fp,
    enum NXByteOrder target_byte_order);
                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/i386/                        0040755 0001750 0001750 00000000000 12612724206 023723  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/i386/swap.h                  0100644 0001750 0001750 00000006015 12612724206 025045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <architecture/byte_order.h>
#include <mach/i386/thread_status.h>

extern void swap_i386_thread_state(
    i386_thread_state_t *cpu,
    enum NXByteOrder target_byte_order);

/* current i386 thread states */
#if i386_THREAD_STATE == 1
extern void swap_i386_float_state(
    struct i386_float_state *fpu,
    enum NXByteOrder target_byte_order);

extern void swap_i386_exception_state(
    i386_exception_state_t *exc,
    enum NXByteOrder target_byte_order);
#endif /* i386_THREAD_STATE == 1 */

/* i386 thread states on older releases */
#if i386_THREAD_STATE == -1
extern void swap_i386_thread_fpstate(
    i386_thread_fpstate_t *fpu,
    enum NXByteOrder target_byte_order);

extern void swap_i386_thread_exceptstate(
    i386_thread_exceptstate_t *exc,
    enum NXByteOrder target_byte_order);

extern void swap_i386_thread_cthreadstate(
    i386_thread_cthreadstate_t *user,
    enum NXByteOrder target_byte_order);
#endif /* i386_THREAD_STATE == -1 */

#ifdef x86_THREAD_STATE64
extern void swap_x86_thread_state64(
    x86_thread_state64_t *cpu,
    enum NXByteOrder target_byte_order);

extern void swap_x86_state_hdr(
    x86_state_hdr_t *hdr,
    enum NXByteOrder target_byte_order);

extern void swap_x86_float_state64(
    x86_float_state64_t *fpu,
    enum NXByteOrder target_byte_order);

extern void swap_x86_exception_state64(
    x86_exception_state64_t *exc,
    enum NXByteOrder target_byte_order);

extern void swap_x86_thread_state(
    x86_thread_state_t *cpu,
    enum NXByteOrder target_byte_order);

extern void swap_x86_float_state(
    x86_float_state_t *fpu,
    enum NXByteOrder target_byte_order);

extern void swap_x86_exception_state(
    x86_exception_state_t *exc,
    enum NXByteOrder target_byte_order);

extern void swap_x86_debug_state32(
    x86_debug_state32_t *debug,
    enum NXByteOrder target_byte_order);

extern void swap_x86_debug_state64(
    x86_debug_state64_t *debug,
    enum NXByteOrder target_byte_order);

extern void swap_x86_debug_state(
    x86_debug_state_t *debug,
    enum NXByteOrder target_byte_order);
#endif /* x86_THREAD_STATE64 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/i860/                        0040755 0001750 0001750 00000000000 12612724206 023720  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/i860/reloc.h                 0100644 0001750 0001750 00000007350 12612724206 025177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Relocation types used in the I860 implementation.  Relocation entries for
 * things other than instructions use the same generic relocation as discribed
 * above and their r_type is RELOC_VANILLA.  The rest of the relocation types
 * are for instructions.  Since they are for instructions the r_address field
 * indicates the 32 bit instruction that the relocation is to be preformed on.
 * The fields r_pcrel and r_length are ignored for non-RELOC_VANILLA r_types
 * except RELOC_SPLIT0 as discribed below.
 */
enum reloc_type_i860
{
    I860_RELOC_VANILLA,	/* generic relocation as discribed above */

    I860_RELOC_PAIR,	/* Only follows a I860_RELOC_HIGH or a
			 * I860_RELOC_HIGHADJ and only the r_address has any
			 * meaning.
			 */ 
    I860_RELOC_HIGH,	/* The low 16 bits of the instruction contains the high
			 * 16 bits of the item being refered to.  This
			 * relocation type must be followed by a I860_RELOC_PAIR
			 * relocation type.  The low 16 bits of the item being
			 * refered to is stored in the r_address of the
			 * I860_RELOC_PAIR entry.
			 */
    I860_RELOC_LOW0,	/* For all of these the low 16 bits of the instruction*/
    I860_RELOC_LOW1,	/* (minus the low 0, 1, 2, 3, or 4 bits) contain the  */
    I860_RELOC_LOW2,	/* low 16 bits of the item being refered to.  The bits*/
    I860_RELOC_LOW3,	/* of the reference that are missing are 0 and the    */
    I860_RELOC_LOW4,	/* bits in the instruction are part of the encoding of*/
			/* instruction.  The resulting low 16 bits of the item*/
			/* being refered to is sign extended to 32 bits.      */

    I860_RELOC_SPLIT0,	/* For all of these the bits 20-14 and bits 10-0 of   */
    I860_RELOC_SPLIT1,	/* the instruction (minus the low 0, 1 or 2 bits)     */
    I860_RELOC_SPLIT2,	/* contain the low 16 bits of the item to being       */
			/* refered to.  The bits of the reference that are    */
			/* missing are 0 and the bits of the instruction are  */
			/* part of the encoding of the instruction.  The      */
			/* resulting low 16 bits of the item being relocated  */
			/* is sign extened to 32 bits.  A special case of the */
			/* I860_RELOC_SPLIT0 is when r_pcrel is non-zero (for */
			/* branch displacements).  In this case the 16 bits   */
			/* from the instruction is a 32 bit word displacement.*/

    I860_RELOC_HIGHADJ,	/* Same as the RELOC_HIGH except the low 16 bits and the
			 * high 16 bits are added together with the low 16 bits
			 * sign extened first.  This means if bit 15 of the low
			 * 16 bits is set the high 16 bits stored in the
			 * instruction will be adjusted.
			 */
    I860_RELOC_BRADDR,	/* The low 26 bits of the instruction is a 32 bit
			 * word displacement from the pc to the item to being
			 * refered to.
			 */
    I860_RELOC_SECTDIFF /* a PAIR follows with subtract symbol value */
};
                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/i860/swap.h                  0100644 0001750 0001750 00000002224 12612724206 025040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#import <architecture/byte_order.h>
#import <mach/i860/thread_status.h>

extern void swap_i860_thread_state_regs(
    struct i860_thread_state_regs *cpu,
    enum NXByteOrder target_byte_sex);
                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/kld.h                        0100644 0001750 0001750 00000006052 12612724206 024155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _MACHO_KLD_H_
#define _MACHO_KLD_H_

#include <mach-o/loader.h>
#include <stdarg.h>

/*
 * These API's are in libkld.  Both kextload(8) and /mach_kernel should
 * link with -lkld and then ld(1) will expand -lkld to libkld.dylib or
 * libkld.a depending on if -dynamic or -static is in effect.
 *
 * Note: we are using the __DYNAMIC__ flag to indicate user space kernel
 * linking and __STATIC__ as a synonym of KERNEL.
 */

/*
 * Note that you must supply the following function for error reporting when
 * using any of the functions listed here.
 */
extern void kld_error_vprintf(const char *format, va_list ap);

/*
 * These two are only in libkld.dylib for use by kextload(8) (user code compiled
 * with the default -dynamic).
 */
#ifdef __DYNAMIC__
extern long kld_load_basefile(
    const char *base_filename);

/* Note: this takes only one object file name */
extern long kld_load(
    struct mach_header **header_addr,
    const char *object_filename,
    const char *output_filename);

extern long kld_load_from_memory(
    struct mach_header **header_addr,
    const char *object_name,
    char *object_addr,
    long object_size,
    const char *output_filename);
#endif /* __DYNAMIC__ */

/*
 * This one is only in libkld.a use by /mach_kernel (kernel code compiled with
 * -static).
 */
#ifdef __STATIC__
/* Note: this api does not write an output file */
extern long kld_load_from_memory(
    struct mach_header **header_addr,
    const char *object_name,
    char *object_addr,
    long object_size);
#endif /* __STATIC__ */

extern long kld_load_basefile_from_memory(
    const char *base_filename,
    char *base_addr,
    long base_size);

extern long kld_unload_all(
    long deallocate_sets);

extern long kld_lookup(
    const char *symbol_name,
    unsigned long *value);

extern long kld_forget_symbol(
    const char *symbol_name);

extern void kld_address_func(
    unsigned long (*func)(unsigned long size, unsigned long headers_size));

#define KLD_STRIP_ALL	0x00000000
#define KLD_STRIP_NONE	0x00000001

extern void kld_set_link_options(
    unsigned long link_options);

#endif /* _MACHO_KLD_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/ldsyms.h                     0100644 0001750 0001750 00000012434 12612724206 024717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _MACHO_LDSYMS_H_
#define _MACHO_LDSYMS_H_

#include <mach-o/loader.h>

/*
 * This file describes the link editor defined symbols.  The semantics of a
 * link editor symbol is that it is defined by the link editor only if it is
 * referenced and it is an error for the user to define them (see the man page
 * ld(1)).  The standard UNIX link editor symbols: __end, __etext and __edata
 * are not not supported by the Apple Mach-O link editor.  These symbols are
 * really not meaningful in a Mach-O object file and the link editor symbols
 * that are supported (described here) replace them.  In the case of the
 * standard UNIX link editor symbols the program can use the symbol
 * __mh_execute_header and walk the load commands of it's program to determine
 * the ending (or beginning) of any section or segment in the program.  Note
 * that the compiler prepends an underbar to all external symbol names coded
 * in a high level language.  Thus in 'C' names are coded without an underbar
 * and symbol names in the symbol table have an underbar.  There are two cpp
 * macros for each link editor defined name in this file.  The macro with a
 * leading underbar is the symbol name and the one without is the name as
 * coded in 'C'.
 */

/*
 * The value of the link editor defined symbol _MH_EXECUTE_SYM is the address
 * of the mach header in a Mach-O executable file type.  It does not appear in
 * any file type other than a MH_EXECUTE file type.  The type of the symbol is
 * absolute as the header is not part of any section.
 */
#define _MH_EXECUTE_SYM	"__mh_execute_header"
#define MH_EXECUTE_SYM	"_mh_execute_header"
extern const struct
#ifdef __LP64__
mach_header_64
#else
mach_header
#endif
_mh_execute_header;

/*
 * The value of the link editor defined symbol _MH_BUNDLE_SYM is the address
 * of the mach header in a Mach-O bundle file type.  It does not appear in
 * any file type other than a MH_BUNDLE file type.  The type of the symbol is
 * an N_SECT symbol even thought the header is not part of any section.  This
 * symbol is private to the code in the bundle it is a part of.
 */
#define _MH_BUNDLE_SYM	"__mh_bundle_header"
#define MH_BUNDLE_SYM	"_mh_bundle_header"
extern const struct
#ifdef __LP64__
mach_header_64
#else
mach_header
#endif
_mh_bundle_header;

/*
 * The value of the link editor defined symbol _MH_DYLIB_SYM is the address
 * of the mach header in a Mach-O dylib file type.  It does not appear in
 * any file type other than a MH_DYLIB file type.  The type of the symbol is
 * an N_SECT symbol even thought the header is not part of any section.  This
 * symbol is private to the code in the library it is a part of.
 */
#define _MH_DYLIB_SYM	"__mh_dylib_header"
#define MH_DYLIB_SYM	"_mh_dylib_header"
extern const struct
#ifdef __LP64__
mach_header_64
#else
mach_header
#endif
_mh_dylib_header;

/*
 * The value of the link editor defined symbol _MH_DYLINKER_SYM is the address
 * of the mach header in a Mach-O dylinker file type.  It does not appear in
 * any file type other than a MH_DYLINKER file type.  The type of the symbol is
 * an N_SECT symbol even thought the header is not part of any section.  This
 * symbol is private to the code in the dynamic linker it is a part of.
 */
#define _MH_DYLINKER_SYM	"__mh_dylinker_header"
#define MH_DYLINKER_SYM		"_mh_dylinker_header"
extern const struct
#ifdef __LP64__
mach_header_64
#else
mach_header
#endif
_mh_dylinker_header;

/*
 * For the MH_PRELOAD file type the headers are not loaded as part of any
 * segment so the link editor defines symbols defined for the beginning
 * and ending of each segment and each section in each segment.  The names for
 * the symbols for a segment's beginning and end will have the form:
 * __SEGNAME__begin and  __SEGNAME__end where __SEGNAME is the name of the
 * segment.  The names for the symbols for a section's beginning and end will
 * have the form: __SEGNAME__sectname__begin and __SEGNAME__sectname__end
 * where __sectname is the name of the section and __SEGNAME is the segment it
 * is in.
 * 
 * The above symbols' types are those of the section they are referring to.
 * This is true even for symbols who's values are end's of a section and
 * that value is next address after that section and not really in that
 * section.  This results in these symbols having types referring to sections
 * who's values are not in that section.
 */

#endif /* _MACHO_LDSYMS_H_ */
                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/loader.h                     0100644 0001750 0001750 00000203371 12612724206 024654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2010 Apple Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACHO_LOADER_H_
#define _MACHO_LOADER_H_

/*
 * This file describes the format of mach object files.
 */
#include <stdint.h>

/*
 * <mach/machine.h> is needed here for the cpu_type_t and cpu_subtype_t types
 * and contains the constants for the possible values of these types.
 */
#include <mach/machine.h>

/*
 * <mach/vm_prot.h> is needed here for the vm_prot_t type and contains the 
 * constants that are or'ed together for the possible values of this type.
 */
#include <mach/vm_prot.h>

/*
 * <machine/thread_status.h> is expected to define the flavors of the thread
 * states and the structures of those flavors for each machine.
 */
#include <mach/machine/thread_status.h>
#include <architecture/byte_order.h>

/*
 * The 32-bit mach header appears at the very beginning of the object file for
 * 32-bit architectures.
 */
struct mach_header {
	uint32_t	magic;		/* mach magic number identifier */
	cpu_type_t	cputype;	/* cpu specifier */
	cpu_subtype_t	cpusubtype;	/* machine specifier */
	uint32_t	filetype;	/* type of file */
	uint32_t	ncmds;		/* number of load commands */
	uint32_t	sizeofcmds;	/* the size of all the load commands */
	uint32_t	flags;		/* flags */
};

/* Constant for the magic field of the mach_header (32-bit architectures) */
#define	MH_MAGIC	0xfeedface	/* the mach magic number */
#define MH_CIGAM	0xcefaedfe	/* NXSwapInt(MH_MAGIC) */

/*
 * The 64-bit mach header appears at the very beginning of object files for
 * 64-bit architectures.
 */
struct mach_header_64 {
	uint32_t	magic;		/* mach magic number identifier */
	cpu_type_t	cputype;	/* cpu specifier */
	cpu_subtype_t	cpusubtype;	/* machine specifier */
	uint32_t	filetype;	/* type of file */
	uint32_t	ncmds;		/* number of load commands */
	uint32_t	sizeofcmds;	/* the size of all the load commands */
	uint32_t	flags;		/* flags */
	uint32_t	reserved;	/* reserved */
};

/* Constant for the magic field of the mach_header_64 (64-bit architectures) */
#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */
#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */

/*
 * The layout of the file depends on the filetype.  For all but the MH_OBJECT
 * file type the segments are padded out and aligned on a segment alignment
 * boundary for efficient demand pageing.  The MH_EXECUTE, MH_FVMLIB, MH_DYLIB,
 * MH_DYLINKER and MH_BUNDLE file types also have the headers included as part
 * of their first segment.
 * 
 * The file type MH_OBJECT is a compact format intended as output of the
 * assembler and input (and possibly output) of the link editor (the .o
 * format).  All sections are in one unnamed segment with no segment padding. 
 * This format is used as an executable format when the file is so small the
 * segment padding greatly increases its size.
 *
 * The file type MH_PRELOAD is an executable format intended for things that
 * are not executed under the kernel (proms, stand alones, kernels, etc).  The
 * format can be executed under the kernel but may demand paged it and not
 * preload it before execution.
 *
 * A core file is in MH_CORE format and can be any in an arbritray legal
 * Mach-O file.
 *
 * Constants for the filetype field of the mach_header
 */
#define	MH_OBJECT	0x1		/* relocatable object file */
#define	MH_EXECUTE	0x2		/* demand paged executable file */
#define	MH_FVMLIB	0x3		/* fixed VM shared library file */
#define	MH_CORE		0x4		/* core file */
#define	MH_PRELOAD	0x5		/* preloaded executable file */
#define	MH_DYLIB	0x6		/* dynamically bound shared library */
#define	MH_DYLINKER	0x7		/* dynamic link editor */
#define	MH_BUNDLE	0x8		/* dynamically bound bundle file */
#define	MH_DYLIB_STUB	0x9		/* shared library stub for static */
					/*  linking only, no section contents */
#define	MH_DSYM		0xa		/* companion file with only debug */
					/*  sections */
#define	MH_KEXT_BUNDLE	0xb		/* x86_64 kexts */

/* Constants for the flags field of the mach_header */
#define	MH_NOUNDEFS	0x1		/* the object file has no undefined
					   references */
#define	MH_INCRLINK	0x2		/* the object file is the output of an
					   incremental link against a base file
					   and can't be link edited again */
#define MH_DYLDLINK	0x4		/* the object file is input for the
					   dynamic linker and can't be staticly
					   link edited again */
#define MH_BINDATLOAD	0x8		/* the object file's undefined
					   references are bound by the dynamic
					   linker when loaded. */
#define MH_PREBOUND	0x10		/* the file has its dynamic undefined
					   references prebound. */
#define MH_SPLIT_SEGS	0x20		/* the file has its read-only and
					   read-write segments split */
#define MH_LAZY_INIT	0x40		/* the shared library init routine is
					   to be run lazily via catching memory
					   faults to its writeable segments
					   (obsolete) */
#define MH_TWOLEVEL	0x80		/* the image is using two-level name
					   space bindings */
#define MH_FORCE_FLAT	0x100		/* the executable is forcing all images
					   to use flat name space bindings */
#define MH_NOMULTIDEFS	0x200		/* this umbrella guarantees no multiple
					   defintions of symbols in its
					   sub-images so the two-level namespace
					   hints can always be used. */
#define MH_NOFIXPREBINDING 0x400	/* do not have dyld notify the
					   prebinding agent about this
					   executable */
#define MH_PREBINDABLE  0x800           /* the binary is not prebound but can
					   have its prebinding redone. only used
                                           when MH_PREBOUND is not set. */
#define MH_ALLMODSBOUND 0x1000		/* indicates that this binary binds to
                                           all two-level namespace modules of
					   its dependent libraries. only used
					   when MH_PREBINDABLE and MH_TWOLEVEL
					   are both set. */ 
#define MH_SUBSECTIONS_VIA_SYMBOLS 0x2000/* safe to divide up the sections into
					    sub-sections via symbols for dead
					    code stripping */
#define MH_CANONICAL    0x4000		/* the binary has been canonicalized
					   via the unprebind operation */
#define MH_WEAK_DEFINES	0x8000		/* the final linked image contains
					   external weak symbols */
#define MH_BINDS_TO_WEAK 0x10000	/* the final linked image uses
					   weak symbols */

#define MH_ALLOW_STACK_EXECUTION 0x20000/* When this bit is set, all stacks 
					   in the task will be given stack
					   execution privilege.  Only used in
					   MH_EXECUTE filetypes. */
#define MH_ROOT_SAFE 0x40000           /* When this bit is set, the binary 
					  declares it is safe for use in
					  processes with uid zero */
                                         
#define MH_SETUID_SAFE 0x80000         /* When this bit is set, the binary 
					  declares it is safe for use in
					  processes when issetugid() is true */

#define MH_NO_REEXPORTED_DYLIBS 0x100000 /* When this bit is set on a dylib, 
					  the static linker does not need to
					  examine dependent dylibs to see
					  if any are re-exported */
#define	MH_PIE 0x200000			/* When this bit is set, the OS will
					   load the main executable at a
					   random address.  Only used in
					   MH_EXECUTE filetypes. */
#define	MH_DEAD_STRIPPABLE_DYLIB 0x400000 /* Only for use on dylibs.  When
					     linking against a dylib that
					     has this bit set, the static linker
					     will automatically not create a
					     LC_LOAD_DYLIB load command to the
					     dylib if no symbols are being
					     referenced from the dylib. */
#define MH_HAS_TLV_DESCRIPTORS 0x800000 /* Contains a section of type 
					    S_THREAD_LOCAL_VARIABLES */

#define MH_NO_HEAP_EXECUTION 0x1000000	/* When this bit is set, the OS will
					   run the main executable with
					   a non-executable heap even on
					   platforms (e.g. i386) that don't
					   require it. Only used in MH_EXECUTE
					   filetypes. */

#define MH_APP_EXTENSION_SAFE 0x02000000 /* The code was linked for use in an
					    application extension. */

/*
 * The load commands directly follow the mach_header.  The total size of all
 * of the commands is given by the sizeofcmds field in the mach_header.  All
 * load commands must have as their first two fields cmd and cmdsize.  The cmd
 * field is filled in with a constant for that command type.  Each command type
 * has a structure specifically for it.  The cmdsize field is the size in bytes
 * of the particular load command structure plus anything that follows it that
 * is a part of the load command (i.e. section structures, strings, etc.).  To
 * advance to the next load command the cmdsize can be added to the offset or
 * pointer of the current load command.  The cmdsize for 32-bit architectures
 * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple
 * of 8 bytes (these are forever the maximum alignment of any load commands).
 * The padded bytes must be zero.  All tables in the object file must also
 * follow these rules so the file can be memory mapped.  Otherwise the pointers
 * to these tables will not work well or at all on some machines.  With all
 * padding zeroed like objects will compare byte for byte.
 */
struct load_command {
	uint32_t cmd;		/* type of load command */
	uint32_t cmdsize;	/* total size of command in bytes */
};

/*
 * After MacOS X 10.1 when a new load command is added that is required to be
 * understood by the dynamic linker for the image to execute properly the
 * LC_REQ_DYLD bit will be or'ed into the load command constant.  If the dynamic
 * linker sees such a load command it it does not understand will issue a
 * "unknown load command required for execution" error and refuse to use the
 * image.  Other load commands without this bit that are not understood will
 * simply be ignored.
 */
#define LC_REQ_DYLD 0x80000000

/* Constants for the cmd field of all load commands, the type */
#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */
#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */
#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */
#define	LC_THREAD	0x4	/* thread */
#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */
#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */
#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */
#define	LC_IDENT	0x8	/* object identification info (obsolete) */
#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */
#define LC_PREPAGE      0xa     /* prepage command (internal use) */
#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */
#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */
#define	LC_ID_DYLIB	0xd	/* dynamically linked shared lib ident */
#define LC_LOAD_DYLINKER 0xe	/* load a dynamic linker */
#define LC_ID_DYLINKER	0xf	/* dynamic linker identification */
#define	LC_PREBOUND_DYLIB 0x10	/* modules prebound for a dynamically */
				/*  linked shared library */
#define	LC_ROUTINES	0x11	/* image routines */
#define	LC_SUB_FRAMEWORK 0x12	/* sub framework */
#define	LC_SUB_UMBRELLA 0x13	/* sub umbrella */
#define	LC_SUB_CLIENT	0x14	/* sub client */
#define	LC_SUB_LIBRARY  0x15	/* sub library */
#define	LC_TWOLEVEL_HINTS 0x16	/* two-level namespace lookup hints */
#define	LC_PREBIND_CKSUM  0x17	/* prebind checksum */

/*
 * load a dynamically linked shared library that is allowed to be missing
 * (all symbols are weak imported).
 */
#define	LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)

#define	LC_SEGMENT_64	0x19	/* 64-bit segment of this file to be
				   mapped */
#define	LC_ROUTINES_64	0x1a	/* 64-bit image routines */
#define LC_UUID		0x1b	/* the uuid */
#define LC_RPATH       (0x1c | LC_REQ_DYLD)    /* runpath additions */
#define LC_CODE_SIGNATURE 0x1d	/* local of code signature */
#define LC_SEGMENT_SPLIT_INFO 0x1e /* local of info to split segments */
#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD) /* load and re-export dylib */
#define	LC_LAZY_LOAD_DYLIB 0x20	/* delay load of dylib until first use */
#define	LC_ENCRYPTION_INFO 0x21	/* encrypted segment information */
#define	LC_DYLD_INFO 	0x22	/* compressed dyld information */
#define	LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)	/* compressed dyld information only */
#define	LC_LOAD_UPWARD_DYLIB (0x23 | LC_REQ_DYLD) /* load upward dylib */
#define LC_VERSION_MIN_MACOSX 0x24   /* build for MacOSX min OS version */
#define LC_VERSION_MIN_IPHONEOS 0x25 /* build for iPhoneOS min OS version */
#define LC_FUNCTION_STARTS 0x26 /* compressed table of function start addresses */
#define LC_DYLD_ENVIRONMENT 0x27 /* string for dyld to treat
				    like environment variable */
#define LC_MAIN (0x28|LC_REQ_DYLD) /* replacement for LC_UNIXTHREAD */
#define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */
#define LC_SOURCE_VERSION 0x2A /* source version used to build binary */
#define LC_DYLIB_CODE_SIGN_DRS 0x2B /* Code signing DRs copied from linked dylibs */
#define	LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */
#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */
#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */
#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */

/*
 * A variable length string in a load command is represented by an lc_str
 * union.  The strings are stored just after the load command structure and
 * the offset is from the start of the load command structure.  The size
 * of the string is reflected in the cmdsize field of the load command.
 * Once again any padded bytes to bring the cmdsize field to a multiple
 * of 4 bytes must be zero.
 */
union lc_str {
	uint32_t	offset;	/* offset to the string */
#ifndef __LP64__
	char		*ptr;	/* pointer to the string */
#endif 
};

/*
 * The segment load command indicates that a part of this file is to be
 * mapped into the task's address space.  The size of this segment in memory,
 * vmsize, maybe equal to or larger than the amount to map from this file,
 * filesize.  The file is mapped starting at fileoff to the beginning of
 * the segment in memory, vmaddr.  The rest of the memory of the segment,
 * if any, is allocated zero fill on demand.  The segment's maximum virtual
 * memory protection and initial virtual memory protection are specified
 * by the maxprot and initprot fields.  If the segment has sections then the
 * section structures directly follow the segment command and their size is
 * reflected in cmdsize.
 */
struct segment_command { /* for 32-bit architectures */
	uint32_t	cmd;		/* LC_SEGMENT */
	uint32_t	cmdsize;	/* includes sizeof section structs */
	char		segname[16];	/* segment name */
	uint32_t	vmaddr;		/* memory address of this segment */
	uint32_t	vmsize;		/* memory size of this segment */
	uint32_t	fileoff;	/* file offset of this segment */
	uint32_t	filesize;	/* amount to map from the file */
	vm_prot_t	maxprot;	/* maximum VM protection */
	vm_prot_t	initprot;	/* initial VM protection */
	uint32_t	nsects;		/* number of sections in segment */
	uint32_t	flags;		/* flags */
};

/*
 * The 64-bit segment load command indicates that a part of this file is to be
 * mapped into a 64-bit task's address space.  If the 64-bit segment has
 * sections then section_64 structures directly follow the 64-bit segment
 * command and their size is reflected in cmdsize.
 */
struct segment_command_64 { /* for 64-bit architectures */
	uint32_t	cmd;		/* LC_SEGMENT_64 */
	uint32_t	cmdsize;	/* includes sizeof section_64 structs */
	char		segname[16];	/* segment name */
	uint64_t	vmaddr;		/* memory address of this segment */
	uint64_t	vmsize;		/* memory size of this segment */
	uint64_t	fileoff;	/* file offset of this segment */
	uint64_t	filesize;	/* amount to map from the file */
	vm_prot_t	maxprot;	/* maximum VM protection */
	vm_prot_t	initprot;	/* initial VM protection */
	uint32_t	nsects;		/* number of sections in segment */
	uint32_t	flags;		/* flags */
};

/* Constants for the flags field of the segment_command */
#define	SG_HIGHVM	0x1	/* the file contents for this segment is for
				   the high part of the VM space, the low part
				   is zero filled (for stacks in core files) */
#define	SG_FVMLIB	0x2	/* this segment is the VM that is allocated by
				   a fixed VM library, for overlap checking in
				   the link editor */
#define	SG_NORELOC	0x4	/* this segment has nothing that was relocated
				   in it and nothing relocated to it, that is
				   it maybe safely replaced without relocation*/
#define SG_PROTECTED_VERSION_1	0x8 /* This segment is protected.  If the
				       segment starts at file offset 0, the
				       first page of the segment is not
				       protected.  All other pages of the
				       segment are protected. */

/*
 * A segment is made up of zero or more sections.  Non-MH_OBJECT files have
 * all of their segments with the proper sections in each, and padded to the
 * specified segment alignment when produced by the link editor.  The first
 * segment of a MH_EXECUTE and MH_FVMLIB format file contains the mach_header
 * and load commands of the object file before its first section.  The zero
 * fill sections are always last in their segment (in all formats).  This
 * allows the zeroed segment padding to be mapped into memory where zero fill
 * sections might be. The gigabyte zero fill sections, those with the section
 * type S_GB_ZEROFILL, can only be in a segment with sections of this type.
 * These segments are then placed after all other segments.
 *
 * The MH_OBJECT format has all of its sections in one segment for
 * compactness.  There is no padding to a specified segment boundary and the
 * mach_header and load commands are not part of the segment.
 *
 * Sections with the same section name, sectname, going into the same segment,
 * segname, are combined by the link editor.  The resulting section is aligned
 * to the maximum alignment of the combined sections and is the new section's
 * alignment.  The combined sections are aligned to their original alignment in
 * the combined section.  Any padded bytes to get the specified alignment are
 * zeroed.
 *
 * The format of the relocation entries referenced by the reloff and nreloc
 * fields of the section structure for mach object files is described in the
 * header file <reloc.h>.
 */
struct section { /* for 32-bit architectures */
	char		sectname[16];	/* name of this section */
	char		segname[16];	/* segment this section goes in */
	uint32_t	addr;		/* memory address of this section */
	uint32_t	size;		/* size in bytes of this section */
	uint32_t	offset;		/* file offset of this section */
	uint32_t	align;		/* section alignment (power of 2) */
	uint32_t	reloff;		/* file offset of relocation entries */
	uint32_t	nreloc;		/* number of relocation entries */
	uint32_t	flags;		/* flags (section type and attributes)*/
	uint32_t	reserved1;	/* reserved (for offset or index) */
	uint32_t	reserved2;	/* reserved (for count or sizeof) */
};

struct section_64 { /* for 64-bit architectures */
	char		sectname[16];	/* name of this section */
	char		segname[16];	/* segment this section goes in */
	uint64_t	addr;		/* memory address of this section */
	uint64_t	size;		/* size in bytes of this section */
	uint32_t	offset;		/* file offset of this section */
	uint32_t	align;		/* section alignment (power of 2) */
	uint32_t	reloff;		/* file offset of relocation entries */
	uint32_t	nreloc;		/* number of relocation entries */
	uint32_t	flags;		/* flags (section type and attributes)*/
	uint32_t	reserved1;	/* reserved (for offset or index) */
	uint32_t	reserved2;	/* reserved (for count or sizeof) */
	uint32_t	reserved3;	/* reserved */
};

/*
 * The flags field of a section structure is separated into two parts a section
 * type and section attributes.  The section types are mutually exclusive (it
 * can only have one type) but the section attributes are not (it may have more
 * than one attribute).
 */
#define SECTION_TYPE		 0x000000ff	/* 256 section types */
#define SECTION_ATTRIBUTES	 0xffffff00	/*  24 section attributes */

/* Constants for the type of a section */
#define	S_REGULAR		0x0	/* regular section */
#define	S_ZEROFILL		0x1	/* zero fill on demand section */
#define	S_CSTRING_LITERALS	0x2	/* section with only literal C strings*/
#define	S_4BYTE_LITERALS	0x3	/* section with only 4 byte literals */
#define	S_8BYTE_LITERALS	0x4	/* section with only 8 byte literals */
#define	S_LITERAL_POINTERS	0x5	/* section with only pointers to */
					/*  literals */
/*
 * For the two types of symbol pointers sections and the symbol stubs section
 * they have indirect symbol table entries.  For each of the entries in the
 * section the indirect symbol table entries, in corresponding order in the
 * indirect symbol table, start at the index stored in the reserved1 field
 * of the section structure.  Since the indirect symbol table entries
 * correspond to the entries in the section the number of indirect symbol table
 * entries is inferred from the size of the section divided by the size of the
 * entries in the section.  For symbol pointers sections the size of the entries
 * in the section is 4 bytes and for symbol stubs sections the byte size of the
 * stubs is stored in the reserved2 field of the section structure.
 */
#define	S_NON_LAZY_SYMBOL_POINTERS	0x6	/* section with only non-lazy
						   symbol pointers */
#define	S_LAZY_SYMBOL_POINTERS		0x7	/* section with only lazy symbol
						   pointers */
#define	S_SYMBOL_STUBS			0x8	/* section with only symbol
						   stubs, byte size of stub in
						   the reserved2 field */
#define	S_MOD_INIT_FUNC_POINTERS	0x9	/* section with only function
						   pointers for initialization*/
#define	S_MOD_TERM_FUNC_POINTERS	0xa	/* section with only function
						   pointers for termination */
#define	S_COALESCED			0xb	/* section contains symbols that
						   are to be coalesced */
#define	S_GB_ZEROFILL			0xc	/* zero fill on demand section
						   (that can be larger than 4
						   gigabytes) */
#define	S_INTERPOSING			0xd	/* section with only pairs of
						   function pointers for
						   interposing */
#define	S_16BYTE_LITERALS		0xe	/* section with only 16 byte
						   literals */
#define	S_DTRACE_DOF			0xf	/* section contains 
						   DTrace Object Format */
#define	S_LAZY_DYLIB_SYMBOL_POINTERS	0x10	/* section with only lazy
						   symbol pointers to lazy
						   loaded dylibs */
/*
 * Section types to support thread local variables
 */
#define S_THREAD_LOCAL_REGULAR                   0x11  /* template of initial 
							  values for TLVs */
#define S_THREAD_LOCAL_ZEROFILL                  0x12  /* template of initial 
							  values for TLVs */
#define S_THREAD_LOCAL_VARIABLES                 0x13  /* TLV descriptors */
#define S_THREAD_LOCAL_VARIABLE_POINTERS         0x14  /* pointers to TLV 
                                                          descriptors */
#define S_THREAD_LOCAL_INIT_FUNCTION_POINTERS    0x15  /* functions to call
							  to initialize TLV
							  values */

/*
 * Constants for the section attributes part of the flags field of a section
 * structure.
 */
#define SECTION_ATTRIBUTES_USR	 0xff000000	/* User setable attributes */
#define S_ATTR_PURE_INSTRUCTIONS 0x80000000	/* section contains only true
						   machine instructions */
#define S_ATTR_NO_TOC 		 0x40000000	/* section contains coalesced
						   symbols that are not to be
						   in a ranlib table of
						   contents */
#define S_ATTR_STRIP_STATIC_SYMS 0x20000000	/* ok to strip static symbols
						   in this section in files
						   with the MH_DYLDLINK flag */
#define S_ATTR_NO_DEAD_STRIP	 0x10000000	/* no dead stripping */
#define S_ATTR_LIVE_SUPPORT	 0x08000000	/* blocks are live if they
						   reference live blocks */
#define S_ATTR_SELF_MODIFYING_CODE 0x04000000	/* Used with i386 code stubs
						   written on by dyld */
/*
 * If a segment contains any sections marked with S_ATTR_DEBUG then all
 * sections in that segment must have this attribute.  No section other than
 * a section marked with this attribute may reference the contents of this
 * section.  A section with this attribute may contain no symbols and must have
 * a section type S_REGULAR.  The static linker will not copy section contents
 * from sections with this attribute into its output file.  These sections
 * generally contain DWARF debugging info.
 */ 
#define	S_ATTR_DEBUG		 0x02000000	/* a debug section */
#define SECTION_ATTRIBUTES_SYS	 0x00ffff00	/* system setable attributes */
#define S_ATTR_SOME_INSTRUCTIONS 0x00000400	/* section contains some
						   machine instructions */
#define S_ATTR_EXT_RELOC	 0x00000200	/* section has external
						   relocation entries */
#define S_ATTR_LOC_RELOC	 0x00000100	/* section has local
						   relocation entries */


/*
 * The names of segments and sections in them are mostly meaningless to the
 * link-editor.  But there are few things to support traditional UNIX
 * executables that require the link-editor and assembler to use some names
 * agreed upon by convention.
 *
 * The initial protection of the "__TEXT" segment has write protection turned
 * off (not writeable).
 *
 * The link-editor will allocate common symbols at the end of the "__common"
 * section in the "__DATA" segment.  It will create the section and segment
 * if needed.
 */

/* The currently known segment names and the section names in those segments */

#define	SEG_PAGEZERO	"__PAGEZERO"	/* the pagezero segment which has no */
					/* protections and catches NULL */
					/* references for MH_EXECUTE files */


#define	SEG_TEXT	"__TEXT"	/* the tradition UNIX text segment */
#define	SECT_TEXT	"__text"	/* the real text part of the text */
					/* section no headers, and no padding */
#define SECT_FVMLIB_INIT0 "__fvmlib_init0"	/* the fvmlib initialization */
						/*  section */
#define SECT_FVMLIB_INIT1 "__fvmlib_init1"	/* the section following the */
					        /*  fvmlib initialization */
						/*  section */

#define	SEG_DATA	"__DATA"	/* the tradition UNIX data segment */
#define	SECT_DATA	"__data"	/* the real initialized data section */
					/* no padding, no bss overlap */
#define	SECT_BSS	"__bss"		/* the real uninitialized data section*/
					/* no padding */
#define SECT_COMMON	"__common"	/* the section common symbols are */
					/* allocated in by the link editor */

#define	SEG_OBJC	"__OBJC"	/* objective-C runtime segment */
#define SECT_OBJC_SYMBOLS "__symbol_table"	/* symbol table */
#define SECT_OBJC_MODULES "__module_info"	/* module information */
#define SECT_OBJC_STRINGS "__selector_strs"	/* string table */
#define SECT_OBJC_REFS "__selector_refs"	/* string table */

#define	SEG_ICON	 "__ICON"	/* the icon segment */
#define	SECT_ICON_HEADER "__header"	/* the icon headers */
#define	SECT_ICON_TIFF   "__tiff"	/* the icons in tiff format */

#define	SEG_LINKEDIT	"__LINKEDIT"	/* the segment containing all structs */
					/* created and maintained by the link */
					/* editor.  Created with -seglinkedit */
					/* option to ld(1) for MH_EXECUTE and */
					/* FVMLIB file types only */

#define SEG_UNIXSTACK	"__UNIXSTACK"	/* the unix stack segment */

#define SEG_IMPORT	"__IMPORT"	/* the segment for the self (dyld) */
					/* modifing code stubs that has read, */
					/* write and execute permissions */

/*
 * Fixed virtual memory shared libraries are identified by two things.  The
 * target pathname (the name of the library as found for execution), and the
 * minor version number.  The address of where the headers are loaded is in
 * header_addr. (THIS IS OBSOLETE and no longer supported).
 */
struct fvmlib {
	union lc_str	name;		/* library's target pathname */
	uint32_t	minor_version;	/* library's minor version number */
	uint32_t	header_addr;	/* library's header address */
};

/*
 * A fixed virtual shared library (filetype == MH_FVMLIB in the mach header)
 * contains a fvmlib_command (cmd == LC_IDFVMLIB) to identify the library.
 * An object that uses a fixed virtual shared library also contains a
 * fvmlib_command (cmd == LC_LOADFVMLIB) for each library it uses.
 * (THIS IS OBSOLETE and no longer supported).
 */
struct fvmlib_command {
	uint32_t	cmd;		/* LC_IDFVMLIB or LC_LOADFVMLIB */
	uint32_t	cmdsize;	/* includes pathname string */
	struct fvmlib	fvmlib;		/* the library identification */
};

/*
 * Dynamicly linked shared libraries are identified by two things.  The
 * pathname (the name of the library as found for execution), and the
 * compatibility version number.  The pathname must match and the compatibility
 * number in the user of the library must be greater than or equal to the
 * library being used.  The time stamp is used to record the time a library was
 * built and copied into user so it can be use to determined if the library used
 * at runtime is exactly the same as used to built the program.
 */
struct dylib {
    union lc_str  name;			/* library's path name */
    uint32_t timestamp;			/* library's build time stamp */
    uint32_t current_version;		/* library's current version number */
    uint32_t compatibility_version;	/* library's compatibility vers number*/
};

/*
 * A dynamically linked shared library (filetype == MH_DYLIB in the mach header)
 * contains a dylib_command (cmd == LC_ID_DYLIB) to identify the library.
 * An object that uses a dynamically linked shared library also contains a
 * dylib_command (cmd == LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, or
 * LC_REEXPORT_DYLIB) for each library it uses.
 */
struct dylib_command {
	uint32_t	cmd;		/* LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB,
					   LC_REEXPORT_DYLIB */
	uint32_t	cmdsize;	/* includes pathname string */
	struct dylib	dylib;		/* the library identification */
};

/*
 * A dynamically linked shared library may be a subframework of an umbrella
 * framework.  If so it will be linked with "-umbrella umbrella_name" where
 * Where "umbrella_name" is the name of the umbrella framework. A subframework
 * can only be linked against by its umbrella framework or other subframeworks
 * that are part of the same umbrella framework.  Otherwise the static link
 * editor produces an error and states to link against the umbrella framework.
 * The name of the umbrella framework for subframeworks is recorded in the
 * following structure.
 */
struct sub_framework_command {
	uint32_t	cmd;		/* LC_SUB_FRAMEWORK */
	uint32_t	cmdsize;	/* includes umbrella string */
	union lc_str 	umbrella;	/* the umbrella framework name */
};

/*
 * For dynamically linked shared libraries that are subframework of an umbrella
 * framework they can allow clients other than the umbrella framework or other
 * subframeworks in the same umbrella framework.  To do this the subframework
 * is built with "-allowable_client client_name" and an LC_SUB_CLIENT load
 * command is created for each -allowable_client flag.  The client_name is
 * usually a framework name.  It can also be a name used for bundles clients
 * where the bundle is built with "-client_name client_name".
 */
struct sub_client_command {
	uint32_t	cmd;		/* LC_SUB_CLIENT */
	uint32_t	cmdsize;	/* includes client string */
	union lc_str 	client;		/* the client name */
};

/*
 * A dynamically linked shared library may be a sub_umbrella of an umbrella
 * framework.  If so it will be linked with "-sub_umbrella umbrella_name" where
 * Where "umbrella_name" is the name of the sub_umbrella framework.  When
 * staticly linking when -twolevel_namespace is in effect a twolevel namespace 
 * umbrella framework will only cause its subframeworks and those frameworks
 * listed as sub_umbrella frameworks to be implicited linked in.  Any other
 * dependent dynamic libraries will not be linked it when -twolevel_namespace
 * is in effect.  The primary library recorded by the static linker when
 * resolving a symbol in these libraries will be the umbrella framework.
 * Zero or more sub_umbrella frameworks may be use by an umbrella framework.
 * The name of a sub_umbrella framework is recorded in the following structure.
 */
struct sub_umbrella_command {
	uint32_t	cmd;		/* LC_SUB_UMBRELLA */
	uint32_t	cmdsize;	/* includes sub_umbrella string */
	union lc_str 	sub_umbrella;	/* the sub_umbrella framework name */
};

/*
 * A dynamically linked shared library may be a sub_library of another shared
 * library.  If so it will be linked with "-sub_library library_name" where
 * Where "library_name" is the name of the sub_library shared library.  When
 * staticly linking when -twolevel_namespace is in effect a twolevel namespace 
 * shared library will only cause its subframeworks and those frameworks
 * listed as sub_umbrella frameworks and libraries listed as sub_libraries to
 * be implicited linked in.  Any other dependent dynamic libraries will not be
 * linked it when -twolevel_namespace is in effect.  The primary library
 * recorded by the static linker when resolving a symbol in these libraries
 * will be the umbrella framework (or dynamic library). Zero or more sub_library
 * shared libraries may be use by an umbrella framework or (or dynamic library).
 * The name of a sub_library framework is recorded in the following structure.
 * For example /usr/lib/libobjc_profile.A.dylib would be recorded as "libobjc".
 */
struct sub_library_command {
	uint32_t	cmd;		/* LC_SUB_LIBRARY */
	uint32_t	cmdsize;	/* includes sub_library string */
	union lc_str 	sub_library;	/* the sub_library name */
};

/*
 * A program (filetype == MH_EXECUTE) that is
 * prebound to its dynamic libraries has one of these for each library that
 * the static linker used in prebinding.  It contains a bit vector for the
 * modules in the library.  The bits indicate which modules are bound (1) and
 * which are not (0) from the library.  The bit for module 0 is the low bit
 * of the first byte.  So the bit for the Nth module is:
 * (linked_modules[N/8] >> N%8) & 1
 */
struct prebound_dylib_command {
	uint32_t	cmd;		/* LC_PREBOUND_DYLIB */
	uint32_t	cmdsize;	/* includes strings */
	union lc_str	name;		/* library's path name */
	uint32_t	nmodules;	/* number of modules in library */
	union lc_str	linked_modules;	/* bit vector of linked modules */
};

/*
 * A program that uses a dynamic linker contains a dylinker_command to identify
 * the name of the dynamic linker (LC_LOAD_DYLINKER).  And a dynamic linker
 * contains a dylinker_command to identify the dynamic linker (LC_ID_DYLINKER).
 * A file can have at most one of these.
 * This struct is also used for the LC_DYLD_ENVIRONMENT load command and
 * contains string for dyld to treat like environment variable.
 */
struct dylinker_command {
	uint32_t	cmd;		/* LC_ID_DYLINKER, LC_LOAD_DYLINKER or
					   LC_DYLD_ENVIRONMENT */
	uint32_t	cmdsize;	/* includes pathname string */
	union lc_str    name;		/* dynamic linker's path name */
};

/*
 * Thread commands contain machine-specific data structures suitable for
 * use in the thread state primitives.  The machine specific data structures
 * follow the struct thread_command as follows.
 * Each flavor of machine specific data structure is preceded by an unsigned
 * long constant for the flavor of that data structure, an uint32_t
 * that is the count of longs of the size of the state data structure and then
 * the state data structure follows.  This triple may be repeated for many
 * flavors.  The constants for the flavors, counts and state data structure
 * definitions are expected to be in the header file <machine/thread_status.h>.
 * These machine specific data structures sizes must be multiples of
 * 4 bytes  The cmdsize reflects the total size of the thread_command
 * and all of the sizes of the constants for the flavors, counts and state
 * data structures.
 *
 * For executable objects that are unix processes there will be one
 * thread_command (cmd == LC_UNIXTHREAD) created for it by the link-editor.
 * This is the same as a LC_THREAD, except that a stack is automatically
 * created (based on the shell's limit for the stack size).  Command arguments
 * and environment variables are copied onto that stack.
 */
struct thread_command {
	uint32_t	cmd;		/* LC_THREAD or  LC_UNIXTHREAD */
	uint32_t	cmdsize;	/* total size of this command */
	/* uint32_t flavor		   flavor of thread state */
	/* uint32_t count		   count of longs in thread state */
	/* struct XXX_thread_state state   thread state for this flavor */
	/* ... */
};

/*
 * The routines command contains the address of the dynamic shared library 
 * initialization routine and an index into the module table for the module
 * that defines the routine.  Before any modules are used from the library the
 * dynamic linker fully binds the module that defines the initialization routine
 * and then calls it.  This gets called before any module initialization
 * routines (used for C++ static constructors) in the library.
 */
struct routines_command { /* for 32-bit architectures */
	uint32_t	cmd;		/* LC_ROUTINES */
	uint32_t	cmdsize;	/* total size of this command */
	uint32_t	init_address;	/* address of initialization routine */
	uint32_t	init_module;	/* index into the module table that */
				        /*  the init routine is defined in */
	uint32_t	reserved1;
	uint32_t	reserved2;
	uint32_t	reserved3;
	uint32_t	reserved4;
	uint32_t	reserved5;
	uint32_t	reserved6;
};

/*
 * The 64-bit routines command.  Same use as above.
 */
struct routines_command_64 { /* for 64-bit architectures */
	uint32_t	cmd;		/* LC_ROUTINES_64 */
	uint32_t	cmdsize;	/* total size of this command */
	uint64_t	init_address;	/* address of initialization routine */
	uint64_t	init_module;	/* index into the module table that */
					/*  the init routine is defined in */
	uint64_t	reserved1;
	uint64_t	reserved2;
	uint64_t	reserved3;
	uint64_t	reserved4;
	uint64_t	reserved5;
	uint64_t	reserved6;
};

/*
 * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD
 * "stab" style symbol table information as described in the header files
 * <nlist.h> and <stab.h>.
 */
struct symtab_command {
	uint32_t	cmd;		/* LC_SYMTAB */
	uint32_t	cmdsize;	/* sizeof(struct symtab_command) */
	uint32_t	symoff;		/* symbol table offset */
	uint32_t	nsyms;		/* number of symbol table entries */
	uint32_t	stroff;		/* string table offset */
	uint32_t	strsize;	/* string table size in bytes */
};

/*
 * This is the second set of the symbolic information which is used to support
 * the data structures for the dynamically link editor.
 *
 * The original set of symbolic information in the symtab_command which contains
 * the symbol and string tables must also be present when this load command is
 * present.  When this load command is present the symbol table is organized
 * into three groups of symbols:
 *	local symbols (static and debugging symbols) - grouped by module
 *	defined external symbols - grouped by module (sorted by name if not lib)
 *	undefined external symbols (sorted by name if MH_BINDATLOAD is not set,
 *	     			    and in order the were seen by the static
 *				    linker if MH_BINDATLOAD is set)
 * In this load command there are offsets and counts to each of the three groups
 * of symbols.
 *
 * This load command contains a the offsets and sizes of the following new
 * symbolic information tables:
 *	table of contents
 *	module table
 *	reference symbol table
 *	indirect symbol table
 * The first three tables above (the table of contents, module table and
 * reference symbol table) are only present if the file is a dynamically linked
 * shared library.  For executable and object modules, which are files
 * containing only one module, the information that would be in these three
 * tables is determined as follows:
 * 	table of contents - the defined external symbols are sorted by name
 *	module table - the file contains only one module so everything in the
 *		       file is part of the module.
 *	reference symbol table - is the defined and undefined external symbols
 *
 * For dynamically linked shared library files this load command also contains
 * offsets and sizes to the pool of relocation entries for all sections
 * separated into two groups:
 *	external relocation entries
 *	local relocation entries
 * For executable and object modules the relocation entries continue to hang
 * off the section structures.
 */
struct dysymtab_command {
    uint32_t cmd;	/* LC_DYSYMTAB */
    uint32_t cmdsize;	/* sizeof(struct dysymtab_command) */

    /*
     * The symbols indicated by symoff and nsyms of the LC_SYMTAB load command
     * are grouped into the following three groups:
     *    local symbols (further grouped by the module they are from)
     *    defined external symbols (further grouped by the module they are from)
     *    undefined symbols
     *
     * The local symbols are used only for debugging.  The dynamic binding
     * process may have to use them to indicate to the debugger the local
     * symbols for a module that is being bound.
     *
     * The last two groups are used by the dynamic binding process to do the
     * binding (indirectly through the module table and the reference symbol
     * table when this is a dynamically linked shared library file).
     */
    uint32_t ilocalsym;	/* index to local symbols */
    uint32_t nlocalsym;	/* number of local symbols */

    uint32_t iextdefsym;/* index to externally defined symbols */
    uint32_t nextdefsym;/* number of externally defined symbols */

    uint32_t iundefsym;	/* index to undefined symbols */
    uint32_t nundefsym;	/* number of undefined symbols */

    /*
     * For the for the dynamic binding process to find which module a symbol
     * is defined in the table of contents is used (analogous to the ranlib
     * structure in an archive) which maps defined external symbols to modules
     * they are defined in.  This exists only in a dynamically linked shared
     * library file.  For executable and object modules the defined external
     * symbols are sorted by name and is use as the table of contents.
     */
    uint32_t tocoff;	/* file offset to table of contents */
    uint32_t ntoc;	/* number of entries in table of contents */

    /*
     * To support dynamic binding of "modules" (whole object files) the symbol
     * table must reflect the modules that the file was created from.  This is
     * done by having a module table that has indexes and counts into the merged
     * tables for each module.  The module structure that these two entries
     * refer to is described below.  This exists only in a dynamically linked
     * shared library file.  For executable and object modules the file only
     * contains one module so everything in the file belongs to the module.
     */
    uint32_t modtaboff;	/* file offset to module table */
    uint32_t nmodtab;	/* number of module table entries */

    /*
     * To support dynamic module binding the module structure for each module
     * indicates the external references (defined and undefined) each module
     * makes.  For each module there is an offset and a count into the
     * reference symbol table for the symbols that the module references.
     * This exists only in a dynamically linked shared library file.  For
     * executable and object modules the defined external symbols and the
     * undefined external symbols indicates the external references.
     */
    uint32_t extrefsymoff;	/* offset to referenced symbol table */
    uint32_t nextrefsyms;	/* number of referenced symbol table entries */

    /*
     * The sections that contain "symbol pointers" and "routine stubs" have
     * indexes and (implied counts based on the size of the section and fixed
     * size of the entry) into the "indirect symbol" table for each pointer
     * and stub.  For every section of these two types the index into the
     * indirect symbol table is stored in the section header in the field
     * reserved1.  An indirect symbol table entry is simply a 32bit index into
     * the symbol table to the symbol that the pointer or stub is referring to.
     * The indirect symbol table is ordered to match the entries in the section.
     */
    uint32_t indirectsymoff; /* file offset to the indirect symbol table */
    uint32_t nindirectsyms;  /* number of indirect symbol table entries */

    /*
     * To support relocating an individual module in a library file quickly the
     * external relocation entries for each module in the library need to be
     * accessed efficiently.  Since the relocation entries can't be accessed
     * through the section headers for a library file they are separated into
     * groups of local and external entries further grouped by module.  In this
     * case the presents of this load command who's extreloff, nextrel,
     * locreloff and nlocrel fields are non-zero indicates that the relocation
     * entries of non-merged sections are not referenced through the section
     * structures (and the reloff and nreloc fields in the section headers are
     * set to zero).
     *
     * Since the relocation entries are not accessed through the section headers
     * this requires the r_address field to be something other than a section
     * offset to identify the item to be relocated.  In this case r_address is
     * set to the offset from the vmaddr of the first LC_SEGMENT command.
     * For MH_SPLIT_SEGS images r_address is set to the the offset from the
     * vmaddr of the first read-write LC_SEGMENT command.
     *
     * The relocation entries are grouped by module and the module table
     * entries have indexes and counts into them for the group of external
     * relocation entries for that the module.
     *
     * For sections that are merged across modules there must not be any
     * remaining external relocation entries for them (for merged sections
     * remaining relocation entries must be local).
     */
    uint32_t extreloff;	/* offset to external relocation entries */
    uint32_t nextrel;	/* number of external relocation entries */

    /*
     * All the local relocation entries are grouped together (they are not
     * grouped by their module since they are only used if the object is moved
     * from it staticly link edited address).
     */
    uint32_t locreloff;	/* offset to local relocation entries */
    uint32_t nlocrel;	/* number of local relocation entries */

};	

/*
 * An indirect symbol table entry is simply a 32bit index into the symbol table 
 * to the symbol that the pointer or stub is refering to.  Unless it is for a
 * non-lazy symbol pointer section for a defined symbol which strip(1) as 
 * removed.  In which case it has the value INDIRECT_SYMBOL_LOCAL.  If the
 * symbol was also absolute INDIRECT_SYMBOL_ABS is or'ed with that.
 */
#define INDIRECT_SYMBOL_LOCAL	0x80000000
#define INDIRECT_SYMBOL_ABS	0x40000000


/* a table of contents entry */
struct dylib_table_of_contents {
    uint32_t symbol_index;	/* the defined external symbol
				   (index into the symbol table) */
    uint32_t module_index;	/* index into the module table this symbol
				   is defined in */
};	

/* a module table entry */
struct dylib_module {
    uint32_t module_name;	/* the module name (index into string table) */

    uint32_t iextdefsym;	/* index into externally defined symbols */
    uint32_t nextdefsym;	/* number of externally defined symbols */
    uint32_t irefsym;		/* index into reference symbol table */
    uint32_t nrefsym;		/* number of reference symbol table entries */
    uint32_t ilocalsym;		/* index into symbols for local symbols */
    uint32_t nlocalsym;		/* number of local symbols */

    uint32_t iextrel;		/* index into external relocation entries */
    uint32_t nextrel;		/* number of external relocation entries */

    uint32_t iinit_iterm;	/* low 16 bits are the index into the init
				   section, high 16 bits are the index into
			           the term section */
    uint32_t ninit_nterm;	/* low 16 bits are the number of init section
				   entries, high 16 bits are the number of
				   term section entries */

    uint32_t			/* for this module address of the start of */
	objc_module_info_addr;  /*  the (__OBJC,__module_info) section */
    uint32_t			/* for this module size of */
	objc_module_info_size;	/*  the (__OBJC,__module_info) section */
};	

/* a 64-bit module table entry */
struct dylib_module_64 {
    uint32_t module_name;	/* the module name (index into string table) */

    uint32_t iextdefsym;	/* index into externally defined symbols */
    uint32_t nextdefsym;	/* number of externally defined symbols */
    uint32_t irefsym;		/* index into reference symbol table */
    uint32_t nrefsym;		/* number of reference symbol table entries */
    uint32_t ilocalsym;		/* index into symbols for local symbols */
    uint32_t nlocalsym;		/* number of local symbols */

    uint32_t iextrel;		/* index into external relocation entries */
    uint32_t nextrel;		/* number of external relocation entries */

    uint32_t iinit_iterm;	/* low 16 bits are the index into the init
				   section, high 16 bits are the index into
				   the term section */
    uint32_t ninit_nterm;      /* low 16 bits are the number of init section
				  entries, high 16 bits are the number of
				  term section entries */

    uint32_t			/* for this module size of */
        objc_module_info_size;	/*  the (__OBJC,__module_info) section */
    uint64_t			/* for this module address of the start of */
        objc_module_info_addr;	/*  the (__OBJC,__module_info) section */
};

/* 
 * The entries in the reference symbol table are used when loading the module
 * (both by the static and dynamic link editors) and if the module is unloaded
 * or replaced.  Therefore all external symbols (defined and undefined) are
 * listed in the module's reference table.  The flags describe the type of
 * reference that is being made.  The constants for the flags are defined in
 * <mach-o/nlist.h> as they are also used for symbol table entries.
 */
struct dylib_reference {
    uint32_t isym:24,		/* index into the symbol table */
    		  flags:8;	/* flags to indicate the type of reference */
};

/*
 * The twolevel_hints_command contains the offset and number of hints in the
 * two-level namespace lookup hints table.
 */
struct twolevel_hints_command {
    uint32_t cmd;	/* LC_TWOLEVEL_HINTS */
    uint32_t cmdsize;	/* sizeof(struct twolevel_hints_command) */
    uint32_t offset;	/* offset to the hint table */
    uint32_t nhints;	/* number of hints in the hint table */
};

/*
 * The entries in the two-level namespace lookup hints table are twolevel_hint
 * structs.  These provide hints to the dynamic link editor where to start
 * looking for an undefined symbol in a two-level namespace image.  The
 * isub_image field is an index into the sub-images (sub-frameworks and
 * sub-umbrellas list) that made up the two-level image that the undefined
 * symbol was found in when it was built by the static link editor.  If
 * isub-image is 0 the the symbol is expected to be defined in library and not
 * in the sub-images.  If isub-image is non-zero it is an index into the array
 * of sub-images for the umbrella with the first index in the sub-images being
 * 1. The array of sub-images is the ordered list of sub-images of the umbrella
 * that would be searched for a symbol that has the umbrella recorded as its
 * primary library.  The table of contents index is an index into the
 * library's table of contents.  This is used as the starting point of the
 * binary search or a directed linear search.
 */
struct twolevel_hint {
    uint32_t 
	isub_image:8,	/* index into the sub images */
	itoc:24;	/* index into the table of contents */
};

/*
 * The prebind_cksum_command contains the value of the original check sum for
 * prebound files or zero.  When a prebound file is first created or modified
 * for other than updating its prebinding information the value of the check sum
 * is set to zero.  When the file has it prebinding re-done and if the value of
 * the check sum is zero the original check sum is calculated and stored in
 * cksum field of this load command in the output file.  If when the prebinding
 * is re-done and the cksum field is non-zero it is left unchanged from the
 * input file.
 */
struct prebind_cksum_command {
    uint32_t cmd;	/* LC_PREBIND_CKSUM */
    uint32_t cmdsize;	/* sizeof(struct prebind_cksum_command) */
    uint32_t cksum;	/* the check sum or zero */
};

/*
 * The uuid load command contains a single 128-bit unique random number that
 * identifies an object produced by the static link editor.
 */
struct uuid_command {
    uint32_t	cmd;		/* LC_UUID */
    uint32_t	cmdsize;	/* sizeof(struct uuid_command) */
    uint8_t	uuid[16];	/* the 128-bit uuid */
};

/*
 * The rpath_command contains a path which at runtime should be added to
 * the current run path used to find @rpath prefixed dylibs.
 */
struct rpath_command {
    uint32_t	 cmd;		/* LC_RPATH */
    uint32_t	 cmdsize;	/* includes string */
    union lc_str path;		/* path to add to run path */
};

/*
 * The linkedit_data_command contains the offsets and sizes of a blob
 * of data in the __LINKEDIT segment.  
 */
struct linkedit_data_command {
    uint32_t	cmd;		/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,
                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,
				   LC_DYLIB_CODE_SIGN_DRS or
				   LC_LINKER_OPTIMIZATION_HINT. */
    uint32_t	cmdsize;	/* sizeof(struct linkedit_data_command) */
    uint32_t	dataoff;	/* file offset of data in __LINKEDIT segment */
    uint32_t	datasize;	/* file size of data in __LINKEDIT segment  */
};

/*
 * The encryption_info_command contains the file offset and size of an
 * of an encrypted segment.
 */
struct encryption_info_command {
   uint32_t	cmd;		/* LC_ENCRYPTION_INFO */
   uint32_t	cmdsize;	/* sizeof(struct encryption_info_command) */
   uint32_t	cryptoff;	/* file offset of encrypted range */
   uint32_t	cryptsize;	/* file size of encrypted range */
   uint32_t	cryptid;	/* which enryption system,
				   0 means not-encrypted yet */
};

/*
 * The encryption_info_command_64 contains the file offset and size of an
 * of an encrypted segment (for use in x86_64 targets).
 */
struct encryption_info_command_64 {
   uint32_t	cmd;		/* LC_ENCRYPTION_INFO_64 */
   uint32_t	cmdsize;	/* sizeof(struct encryption_info_command_64) */
   uint32_t	cryptoff;	/* file offset of encrypted range */
   uint32_t	cryptsize;	/* file size of encrypted range */
   uint32_t	cryptid;	/* which enryption system,
				   0 means not-encrypted yet */
   uint32_t	pad;		/* padding to make this struct's size a multiple
				   of 8 bytes */
};

/*
 * The version_min_command contains the min OS version on which this 
 * binary was built to run.
 */
struct version_min_command {
    uint32_t	cmd;		/* LC_VERSION_MIN_MACOSX or
				   LC_VERSION_MIN_IPHONEOS
				   LC_VERSION_MIN_WATCHOS */
    uint32_t	cmdsize;	/* sizeof(struct min_version_command) */
    uint32_t	version;	/* X.Y.Z is encoded in nibbles xxxx.yy.zz */
    uint32_t	sdk;		/* X.Y.Z is encoded in nibbles xxxx.yy.zz */
};

/*
 * The dyld_info_command contains the file offsets and sizes of 
 * the new compressed form of the information dyld needs to 
 * load the image.  This information is used by dyld on Mac OS X
 * 10.6 and later.  All information pointed to by this command
 * is encoded using byte streams, so no endian swapping is needed
 * to interpret it. 
 */
struct dyld_info_command {
   uint32_t   cmd;		/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */
   uint32_t   cmdsize;		/* sizeof(struct dyld_info_command) */

    /*
     * Dyld rebases an image whenever dyld loads it at an address different
     * from its preferred address.  The rebase information is a stream
     * of byte sized opcodes whose symbolic names start with REBASE_OPCODE_.
     * Conceptually the rebase information is a table of tuples:
     *    <seg-index, seg-offset, type>
     * The opcodes are a compressed way to encode the table by only
     * encoding when a column changes.  In addition simple patterns
     * like "every n'th offset for m times" can be encoded in a few
     * bytes.
     */
    uint32_t   rebase_off;	/* file offset to rebase info  */
    uint32_t   rebase_size;	/* size of rebase info   */
    
    /*
     * Dyld binds an image during the loading process, if the image
     * requires any pointers to be initialized to symbols in other images.  
     * The bind information is a stream of byte sized 
     * opcodes whose symbolic names start with BIND_OPCODE_.
     * Conceptually the bind information is a table of tuples:
     *    <seg-index, seg-offset, type, symbol-library-ordinal, symbol-name, addend>
     * The opcodes are a compressed way to encode the table by only
     * encoding when a column changes.  In addition simple patterns
     * like for runs of pointers initialzed to the same value can be 
     * encoded in a few bytes.
     */
    uint32_t   bind_off;	/* file offset to binding info   */
    uint32_t   bind_size;	/* size of binding info  */
        
    /*
     * Some C++ programs require dyld to unique symbols so that all
     * images in the process use the same copy of some code/data.
     * This step is done after binding. The content of the weak_bind
     * info is an opcode stream like the bind_info.  But it is sorted
     * alphabetically by symbol name.  This enable dyld to walk 
     * all images with weak binding information in order and look
     * for collisions.  If there are no collisions, dyld does
     * no updating.  That means that some fixups are also encoded
     * in the bind_info.  For instance, all calls to "operator new"
     * are first bound to libstdc++.dylib using the information
     * in bind_info.  Then if some image overrides operator new
     * that is detected when the weak_bind information is processed
     * and the call to operator new is then rebound.
     */
    uint32_t   weak_bind_off;	/* file offset to weak binding info   */
    uint32_t   weak_bind_size;  /* size of weak binding info  */
    
    /*
     * Some uses of external symbols do not need to be bound immediately.
     * Instead they can be lazily bound on first use.  The lazy_bind
     * are contains a stream of BIND opcodes to bind all lazy symbols.
     * Normal use is that dyld ignores the lazy_bind section when
     * loading an image.  Instead the static linker arranged for the
     * lazy pointer to initially point to a helper function which 
     * pushes the offset into the lazy_bind area for the symbol
     * needing to be bound, then jumps to dyld which simply adds
     * the offset to lazy_bind_off to get the information on what 
     * to bind.  
     */
    uint32_t   lazy_bind_off;	/* file offset to lazy binding info */
    uint32_t   lazy_bind_size;  /* size of lazy binding infs */
    
    /*
     * The symbols exported by a dylib are encoded in a trie.  This
     * is a compact representation that factors out common prefixes.
     * It also reduces LINKEDIT pages in RAM because it encodes all  
     * information (name, address, flags) in one small, contiguous range.
     * The export area is a stream of nodes.  The first node sequentially
     * is the start node for the trie.  
     *
     * Nodes for a symbol start with a uleb128 that is the length of
     * the exported symbol information for the string so far.
     * If there is no exported symbol, the node starts with a zero byte. 
     * If there is exported info, it follows the length.  
	 *
	 * First is a uleb128 containing flags. Normally, it is followed by
     * a uleb128 encoded offset which is location of the content named
     * by the symbol from the mach_header for the image.  If the flags
     * is EXPORT_SYMBOL_FLAGS_REEXPORT, then following the flags is
     * a uleb128 encoded library ordinal, then a zero terminated
     * UTF8 string.  If the string is zero length, then the symbol
     * is re-export from the specified dylib with the same name.
	 * If the flags is EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER, then following
	 * the flags is two uleb128s: the stub offset and the resolver offset.
	 * The stub is used by non-lazy pointers.  The resolver is used
	 * by lazy pointers and must be called to get the actual address to use.
     *
     * After the optional exported symbol information is a byte of
     * how many edges (0-255) that this node has leaving it, 
     * followed by each edge.
     * Each edge is a zero terminated UTF8 of the addition chars
     * in the symbol, followed by a uleb128 offset for the node that
     * edge points to.
     *  
     */
    uint32_t   export_off;	/* file offset to lazy binding info */
    uint32_t   export_size;	/* size of lazy binding infs */
};

/*
 * The following are used to encode rebasing information
 */
#define REBASE_TYPE_POINTER					1
#define REBASE_TYPE_TEXT_ABSOLUTE32				2
#define REBASE_TYPE_TEXT_PCREL32				3

#define REBASE_OPCODE_MASK					0xF0
#define REBASE_IMMEDIATE_MASK					0x0F
#define REBASE_OPCODE_DONE					0x00
#define REBASE_OPCODE_SET_TYPE_IMM				0x10
#define REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB		0x20
#define REBASE_OPCODE_ADD_ADDR_ULEB				0x30
#define REBASE_OPCODE_ADD_ADDR_IMM_SCALED			0x40
#define REBASE_OPCODE_DO_REBASE_IMM_TIMES			0x50
#define REBASE_OPCODE_DO_REBASE_ULEB_TIMES			0x60
#define REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB			0x70
#define REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB	0x80


/*
 * The following are used to encode binding information
 */
#define BIND_TYPE_POINTER					1
#define BIND_TYPE_TEXT_ABSOLUTE32				2
#define BIND_TYPE_TEXT_PCREL32					3

#define BIND_SPECIAL_DYLIB_SELF					 0
#define BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE			-1
#define BIND_SPECIAL_DYLIB_FLAT_LOOKUP				-2

#define BIND_SYMBOL_FLAGS_WEAK_IMPORT				0x1
#define BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION			0x8

#define BIND_OPCODE_MASK					0xF0
#define BIND_IMMEDIATE_MASK					0x0F
#define BIND_OPCODE_DONE					0x00
#define BIND_OPCODE_SET_DYLIB_ORDINAL_IMM			0x10
#define BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB			0x20
#define BIND_OPCODE_SET_DYLIB_SPECIAL_IMM			0x30
#define BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM		0x40
#define BIND_OPCODE_SET_TYPE_IMM				0x50
#define BIND_OPCODE_SET_ADDEND_SLEB				0x60
#define BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB			0x70
#define BIND_OPCODE_ADD_ADDR_ULEB				0x80
#define BIND_OPCODE_DO_BIND					0x90
#define BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB			0xA0
#define BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED			0xB0
#define BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB		0xC0


/*
 * The following are used on the flags byte of a terminal node
 * in the export information.
 */
#define EXPORT_SYMBOL_FLAGS_KIND_MASK				0x03
#define EXPORT_SYMBOL_FLAGS_KIND_REGULAR			0x00
#define EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL			0x01
#define EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION			0x04
#define EXPORT_SYMBOL_FLAGS_REEXPORT				0x08
#define EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER			0x10

/*
 * The linker_option_command contains linker options embedded in object files.
 */
struct linker_option_command {
    uint32_t  cmd;	/* LC_LINKER_OPTION only used in MH_OBJECT filetypes */
    uint32_t  cmdsize;
    uint32_t  count;	/* number of strings */
    /* concatenation of zero terminated UTF8 strings.
       Zero filled at end to align */
};

/*
 * The symseg_command contains the offset and size of the GNU style
 * symbol table information as described in the header file <symseg.h>.
 * The symbol roots of the symbol segments must also be aligned properly
 * in the file.  So the requirement of keeping the offsets aligned to a
 * multiple of a 4 bytes translates to the length field of the symbol
 * roots also being a multiple of a long.  Also the padding must again be
 * zeroed. (THIS IS OBSOLETE and no longer supported).
 */
struct symseg_command {
	uint32_t	cmd;		/* LC_SYMSEG */
	uint32_t	cmdsize;	/* sizeof(struct symseg_command) */
	uint32_t	offset;		/* symbol segment offset */
	uint32_t	size;		/* symbol segment size in bytes */
};

/*
 * The ident_command contains a free format string table following the
 * ident_command structure.  The strings are null terminated and the size of
 * the command is padded out with zero bytes to a multiple of 4 bytes/
 * (THIS IS OBSOLETE and no longer supported).
 */
struct ident_command {
	uint32_t cmd;		/* LC_IDENT */
	uint32_t cmdsize;	/* strings that follow this command */
};

/*
 * The fvmfile_command contains a reference to a file to be loaded at the
 * specified virtual address.  (Presently, this command is reserved for
 * internal use.  The kernel ignores this command when loading a program into
 * memory).
 */
struct fvmfile_command {
	uint32_t cmd;			/* LC_FVMFILE */
	uint32_t cmdsize;		/* includes pathname string */
	union lc_str	name;		/* files pathname */
	uint32_t	header_addr;	/* files virtual address */
};


/*
 * The entry_point_command is a replacement for thread_command.
 * It is used for main executables to specify the location (file offset)
 * of main().  If -stack_size was used at link time, the stacksize
 * field will contain the stack size need for the main thread.
 */
struct entry_point_command {
    uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */
    uint32_t  cmdsize;	/* 24 */
    uint64_t  entryoff;	/* file (__TEXT) offset of main() */
    uint64_t  stacksize;/* if not zero, initial stack size */
};


/*
 * The source_version_command is an optional load command containing
 * the version of the sources used to build the binary.
 */
struct source_version_command {
    uint32_t  cmd;	/* LC_SOURCE_VERSION */
    uint32_t  cmdsize;	/* 16 */
    uint64_t  version;	/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */
};


/*
 * The LC_DATA_IN_CODE load commands uses a linkedit_data_command 
 * to point to an array of data_in_code_entry entries. Each entry
 * describes a range of data in a code section.
 */
struct data_in_code_entry {
    uint32_t	offset;  /* from mach_header to start of data range*/
    uint16_t	length;  /* number of bytes in data range */
    uint16_t	kind;    /* a DICE_KIND_* value  */
};
#define DICE_KIND_DATA              0x0001
#define DICE_KIND_JUMP_TABLE8       0x0002
#define DICE_KIND_JUMP_TABLE16      0x0003
#define DICE_KIND_JUMP_TABLE32      0x0004
#define DICE_KIND_ABS_JUMP_TABLE32  0x0005



/*
 * Sections of type S_THREAD_LOCAL_VARIABLES contain an array 
 * of tlv_descriptor structures.
 */
struct tlv_descriptor
{
	void*		(*thunk)(struct tlv_descriptor*);
	unsigned long	key;
	unsigned long	offset;
};

#endif /* _MACHO_LOADER_H_ */
                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/m68k/                        0040755 0001750 0001750 00000000000 12612724206 024017  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/m68k/swap.h                  0100644 0001750 0001750 00000002633 12612724206 025143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#import <architecture/byte_order.h>
#import <mach/m68k/thread_status.h>

extern void swap_m68k_thread_state_regs(
    struct m68k_thread_state_regs *cpu,
    enum NXByteOrder target_byte_order);

extern void swap_m68k_thread_state_68882(
    struct m68k_thread_state_68882 *fpu,
    enum NXByteOrder target_byte_order);

extern void swap_m68k_thread_state_user_reg(
    struct m68k_thread_state_user_reg *user_reg,
    enum NXByteOrder target_byte_order);
                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/m88k/                        0040755 0001750 0001750 00000000000 12612724206 024021  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/m88k/reloc.h                 0100644 0001750 0001750 00000003555 12612724206 025303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Relocation types used in the m88k implementation.  Relocation entries for
 * things other than instructions use the same generic relocation as discribed
 * above and their r_type is RELOC_VANILLA.  The rest of the relocation types
 * are for instructions.  Since they are for instructions the r_address field
 * indicates the 32 bit instruction that the relocation is to be preformed on.
 * The fields r_pcrel and r_length are ignored for non-RELOC_VANILLA r_types.
 */
enum reloc_type_m88k
{
    M88K_RELOC_VANILLA,	/* generic relocation as discribed above */
    M88K_RELOC_PAIR,	/* the second relocation entry of a pair */
    M88K_RELOC_PC16,
    M88K_RELOC_PC26,
    M88K_RELOC_HI16,	/* a PAIR follows with the low half */
    M88K_RELOC_LO16,	/* a PAIR follows with the high half */
    M88K_RELOC_SECTDIFF,/* a PAIR follows with subtract symbol value */
    M88K_RELOC_PB_LA_PTR/* prebound lazy pointer */
};
                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/m88k/swap.h                  0100644 0001750 0001750 00000002765 12612724206 025153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#import <architecture/byte_order.h>
#import <mach/m88k/thread_status.h>

extern void swap_m88k_thread_state_grf_t(
    m88k_thread_state_grf_t *cpu,
    enum NXByteOrder target_byte_sex);

extern void swap_m88k_thread_state_xrf_t(
    m88k_thread_state_xrf_t *fpu,
    enum NXByteOrder target_byte_sex);

extern void swap_m88k_thread_state_user_t(
    m88k_thread_state_user_t *user,
    enum NXByteOrder target_byte_sex);


extern void swap_m88110_thread_state_impl_t(
    m88110_thread_state_impl_t *spu,
    enum NXByteOrder target_byte_sex);
           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/nlist.h                      0100644 0001750 0001750 00000032741 12612724206 024540  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACHO_NLIST_H_
#define _MACHO_NLIST_H_
/*	$NetBSD: nlist.h,v 1.5 1994/10/26 00:56:11 cgd Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nlist.h	8.2 (Berkeley) 1/21/94
 */
#include <stdint.h>

/*
 * Format of a symbol table entry of a Mach-O file for 32-bit architectures.
 * Modified from the BSD format.  The modifications from the original format
 * were changing n_other (an unused field) to n_sect and the addition of the
 * N_SECT type.  These modifications are required to support symbols in a larger
 * number of sections not just the three sections (text, data and bss) in a BSD
 * file.
 */
struct nlist {
	union {
#ifndef __LP64__
		char *n_name;	/* for use when in-core */
#endif
		uint32_t n_strx;	/* index into the string table */
	} n_un;
	uint8_t n_type;		/* type flag, see below */
	uint8_t n_sect;		/* section number or NO_SECT */
	int16_t n_desc;		/* see <mach-o/stab.h> */
	uint32_t n_value;	/* value of this symbol (or stab offset) */
};

/*
 * This is the symbol table entry structure for 64-bit architectures.
 */
struct nlist_64 {
    union {
        uint32_t  n_strx; /* index into the string table */
    } n_un;
    uint8_t n_type;        /* type flag, see below */
    uint8_t n_sect;        /* section number or NO_SECT */
    uint16_t n_desc;       /* see <mach-o/stab.h> */
    uint64_t n_value;      /* value of this symbol (or stab offset) */
};

/*
 * Symbols with a index into the string table of zero (n_un.n_strx == 0) are
 * defined to have a null, "", name.  Therefore all string indexes to non null
 * names must not have a zero string index.  This is bit historical information
 * that has never been well documented.
 */

/*
 * The n_type field really contains four fields:
 *	unsigned char N_STAB:3,
 *		      N_PEXT:1,
 *		      N_TYPE:3,
 *		      N_EXT:1;
 * which are used via the following masks.
 */
#define	N_STAB	0xe0  /* if any of these bits set, a symbolic debugging entry */
#define	N_PEXT	0x10  /* private external symbol bit */
#define	N_TYPE	0x0e  /* mask for the type bits */
#define	N_EXT	0x01  /* external symbol bit, set for external symbols */

/*
 * Only symbolic debugging entries have some of the N_STAB bits set and if any
 * of these bits are set then it is a symbolic debugging entry (a stab).  In
 * which case then the values of the n_type field (the entire field) are given
 * in <mach-o/stab.h>
 */

/*
 * Values for N_TYPE bits of the n_type field.
 */
#define	N_UNDF	0x0		/* undefined, n_sect == NO_SECT */
#define	N_ABS	0x2		/* absolute, n_sect == NO_SECT */
#define	N_SECT	0xe		/* defined in section number n_sect */
#define	N_PBUD	0xc		/* prebound undefined (defined in a dylib) */
#define N_INDR	0xa		/* indirect */

/* 
 * If the type is N_INDR then the symbol is defined to be the same as another
 * symbol.  In this case the n_value field is an index into the string table
 * of the other symbol's name.  When the other symbol is defined then they both
 * take on the defined type and value.
 */

/*
 * If the type is N_SECT then the n_sect field contains an ordinal of the
 * section the symbol is defined in.  The sections are numbered from 1 and 
 * refer to sections in order they appear in the load commands for the file
 * they are in.  This means the same ordinal may very well refer to different
 * sections in different files.
 *
 * The n_value field for all symbol table entries (including N_STAB's) gets
 * updated by the link editor based on the value of it's n_sect field and where
 * the section n_sect references gets relocated.  If the value of the n_sect 
 * field is NO_SECT then it's n_value field is not changed by the link editor.
 */
#define	NO_SECT		0	/* symbol is not in any section */
#define MAX_SECT	255	/* 1 thru 255 inclusive */

/*
 * Common symbols are represented by undefined (N_UNDF) external (N_EXT) types
 * who's values (n_value) are non-zero.  In which case the value of the n_value
 * field is the size (in bytes) of the common symbol.  The n_sect field is set
 * to NO_SECT.  The alignment of a common symbol may be set as a power of 2
 * between 2^1 and 2^15 as part of the n_desc field using the macros below. If
 * the alignment is not set (a value of zero) then natural alignment based on
 * the size is used.
 */
#define GET_COMM_ALIGN(n_desc) (((n_desc) >> 8) & 0x0f)
#define SET_COMM_ALIGN(n_desc,align) \
    (n_desc) = (((n_desc) & 0xf0ff) | (((align) & 0x0f) << 8))

/*
 * To support the lazy binding of undefined symbols in the dynamic link-editor,
 * the undefined symbols in the symbol table (the nlist structures) are marked
 * with the indication if the undefined reference is a lazy reference or
 * non-lazy reference.  If both a non-lazy reference and a lazy reference is
 * made to the same symbol the non-lazy reference takes precedence.  A reference
 * is lazy only when all references to that symbol are made through a symbol
 * pointer in a lazy symbol pointer section.
 *
 * The implementation of marking nlist structures in the symbol table for
 * undefined symbols will be to use some of the bits of the n_desc field as a
 * reference type.  The mask REFERENCE_TYPE will be applied to the n_desc field
 * of an nlist structure for an undefined symbol to determine the type of
 * undefined reference (lazy or non-lazy).
 *
 * The constants for the REFERENCE FLAGS are propagated to the reference table
 * in a shared library file.  In that case the constant for a defined symbol,
 * REFERENCE_FLAG_DEFINED, is also used.
 */
/* Reference type bits of the n_desc field of undefined symbols */
#define REFERENCE_TYPE				0x7
/* types of references */
#define REFERENCE_FLAG_UNDEFINED_NON_LAZY		0
#define REFERENCE_FLAG_UNDEFINED_LAZY			1
#define REFERENCE_FLAG_DEFINED				2
#define REFERENCE_FLAG_PRIVATE_DEFINED			3
#define REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY	4
#define REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY		5

/*
 * To simplify stripping of objects that use are used with the dynamic link
 * editor, the static link editor marks the symbols defined an object that are
 * referenced by a dynamicly bound object (dynamic shared libraries, bundles).
 * With this marking strip knows not to strip these symbols.
 */
#define REFERENCED_DYNAMICALLY	0x0010

/*
 * For images created by the static link editor with the -twolevel_namespace
 * option in effect the flags field of the mach header is marked with
 * MH_TWOLEVEL.  And the binding of the undefined references of the image are
 * determined by the static link editor.  Which library an undefined symbol is
 * bound to is recorded by the static linker in the high 8 bits of the n_desc
 * field using the SET_LIBRARY_ORDINAL macro below.  The ordinal recorded
 * references the libraries listed in the Mach-O's LC_LOAD_DYLIB,
 * LC_LOAD_WEAK_DYLIB, LC_REEXPORT_DYLIB, LC_LOAD_UPWARD_DYLIB, and
 * LC_LAZY_LOAD_DYLIB, etc. load commands in the order they appear in the
 * headers.   The library ordinals start from 1.
 * For a dynamic library that is built as a two-level namespace image the
 * undefined references from module defined in another use the same nlist struct
 * an in that case SELF_LIBRARY_ORDINAL is used as the library ordinal.  For
 * defined symbols in all images they also must have the library ordinal set to
 * SELF_LIBRARY_ORDINAL.  The EXECUTABLE_ORDINAL refers to the executable
 * image for references from plugins that refer to the executable that loads
 * them.
 * 
 * The DYNAMIC_LOOKUP_ORDINAL is for undefined symbols in a two-level namespace
 * image that are looked up by the dynamic linker with flat namespace semantics.
 * This ordinal was added as a feature in Mac OS X 10.3 by reducing the
 * value of MAX_LIBRARY_ORDINAL by one.  So it is legal for existing binaries
 * or binaries built with older tools to have 0xfe (254) dynamic libraries.  In
 * this case the ordinal value 0xfe (254) must be treated as a library ordinal
 * for compatibility. 
 */
#define GET_LIBRARY_ORDINAL(n_desc) (((n_desc) >> 8) & 0xff)
#define SET_LIBRARY_ORDINAL(n_desc,ordinal) \
	(n_desc) = (((n_desc) & 0x00ff) | (((ordinal) & 0xff) << 8))
#define SELF_LIBRARY_ORDINAL 0x0
#define MAX_LIBRARY_ORDINAL 0xfd
#define DYNAMIC_LOOKUP_ORDINAL 0xfe
#define EXECUTABLE_ORDINAL 0xff

/*
 * The bit 0x0020 of the n_desc field is used for two non-overlapping purposes
 * and has two different symbolic names, N_NO_DEAD_STRIP and N_DESC_DISCARDED.
 */

/*
 * The N_NO_DEAD_STRIP bit of the n_desc field only ever appears in a 
 * relocatable .o file (MH_OBJECT filetype). And is used to indicate to the
 * static link editor it is never to dead strip the symbol.
 */
#define N_NO_DEAD_STRIP 0x0020 /* symbol is not to be dead stripped */

/*
 * The N_DESC_DISCARDED bit of the n_desc field never appears in linked image.
 * But is used in very rare cases by the dynamic link editor to mark an in
 * memory symbol as discared and longer used for linking.
 */
#define N_DESC_DISCARDED 0x0020	/* symbol is discarded */

/*
 * The N_WEAK_REF bit of the n_desc field indicates to the dynamic linker that
 * the undefined symbol is allowed to be missing and is to have the address of
 * zero when missing.
 */
#define N_WEAK_REF	0x0040 /* symbol is weak referenced */

/*
 * The N_WEAK_DEF bit of the n_desc field indicates to the static and dynamic
 * linkers that the symbol definition is weak, allowing a non-weak symbol to
 * also be used which causes the weak definition to be discared.  Currently this
 * is only supported for symbols in coalesed sections.
 */
#define N_WEAK_DEF	0x0080 /* coalesed symbol is a weak definition */

/*
 * The N_REF_TO_WEAK bit of the n_desc field indicates to the dynamic linker
 * that the undefined symbol should be resolved using flat namespace searching.
 */
#define	N_REF_TO_WEAK	0x0080 /* reference to a weak symbol */

/*
 * The N_ARM_THUMB_DEF bit of the n_desc field indicates that the symbol is
 * a defintion of a Thumb function.
 */
#define N_ARM_THUMB_DEF	0x0008 /* symbol is a Thumb function (ARM) */

/*
 * The N_SYMBOL_RESOLVER bit of the n_desc field indicates that the
 * that the function is actually a resolver function and should
 * be called to get the address of the real function to use.
 * This bit is only available in .o files (MH_OBJECT filetype)
 */
#define N_SYMBOL_RESOLVER  0x0100 

/*
 * The N_ALT_ENTRY bit of the n_desc field indicates that the
 * symbol is pinned to the previous content.
 */
#define N_ALT_ENTRY 0x0200

#ifndef __STRICT_BSD__
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
/*
 * The function nlist(3) from the C library.
 */
extern int nlist (const char *filename, struct nlist *list);
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* __STRICT_BSD__ */

#endif /* _MACHO_LIST_H_ */
                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/ppc/                         0040755 0001750 0001750 00000000000 12612724206 024014  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/ppc/reloc.h                  0100644 0001750 0001750 00000006173 12612724206 025275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Relocation types used in the ppc implementation.  Relocation entries for
 * things other than instructions use the same generic relocation as discribed
 * above and their r_type is RELOC_VANILLA.  The rest of the relocation types
 * are for instructions.  Since they are for instructions the r_address field
 * indicates the 32 bit instruction that the relocation is to be preformed on.
 * The fields r_pcrel and r_length are ignored for non-RELOC_VANILLA r_types
 * except for PPC_RELOC_BR14.
 *
 * For PPC_RELOC_BR14 if the r_length is the unused value 3, then the branch was
 * statically predicted setting or clearing the Y-bit based on the sign of the
 * displacement or the opcode.  If this is the case the static linker must flip
 * the value of the Y-bit if the sign of the displacement changes for non-branch
 * always conditions.
 */
enum reloc_type_ppc
{
    PPC_RELOC_VANILLA,	/* generic relocation as discribed above */
    PPC_RELOC_PAIR,	/* the second relocation entry of a pair */
    PPC_RELOC_BR14,	/* 14 bit branch displacement (to a word address) */
    PPC_RELOC_BR24,	/* 24 bit branch displacement (to a word address) */
    PPC_RELOC_HI16,	/* a PAIR follows with the low half */
    PPC_RELOC_LO16,	/* a PAIR follows with the high half */
    PPC_RELOC_HA16,	/* Same as the RELOC_HI16 except the low 16 bits and the
			 * high 16 bits are added together with the low 16 bits
			 * sign extened first.  This means if bit 15 of the low
			 * 16 bits is set the high 16 bits stored in the
			 * instruction will be adjusted.
			 */
    PPC_RELOC_LO14,	/* Same as the LO16 except that the low 2 bits are not
			 * stored in the instruction and are always zero.  This
			 * is used in double word load/store instructions.
			 */
    PPC_RELOC_SECTDIFF,	/* a PAIR follows with subtract symbol value */
    PPC_RELOC_PB_LA_PTR,/* prebound lazy pointer */
    PPC_RELOC_HI16_SECTDIFF, /* section difference forms of above.  a PAIR */
    PPC_RELOC_LO16_SECTDIFF, /* follows these with subtract symbol value */
    PPC_RELOC_HA16_SECTDIFF,
    PPC_RELOC_JBSR,
    PPC_RELOC_LO14_SECTDIFF,
    PPC_RELOC_LOCAL_SECTDIFF  /* like PPC_RELOC_SECTDIFF, but the symbol
				 referenced was local.  */
};
                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/ppc/swap.h                   0100644 0001750 0001750 00000002540 12612724206 025135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <architecture/byte_order.h>
#include <mach/ppc/thread_status.h>

extern void swap_ppc_thread_state_t(
    ppc_thread_state_t *cpu,
    enum NXByteOrder target_byte_sex);

extern void swap_ppc_float_state_t(
    ppc_float_state_t *fpu,
    enum NXByteOrder target_byte_sex);

extern void swap_ppc_exception_state_t(
    ppc_exception_state_t *state,
    enum NXByteOrder target_byte_sex);
                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/ranlib.h                     0100644 0001750 0001750 00000005671 12612724206 024660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	ranlib.h	4.1	83/05/03	*/
#ifndef _MACH_O_RANLIB_H_
#define _MACH_O_RANLIB_H_

#include <stdint.h>
#include <sys/types.h>		/* off_t */

/*
 * There are two known orders of table of contents for archives.  The first is
 * the order ranlib(1) originally produced and still produces without any
 * options.  This table of contents has the archive member name "__.SYMDEF"
 * This order has the ranlib structures in the order the objects appear in the
 * archive and the symbol names of those objects in the order of symbol table.
 * The second know order is sorted by symbol name and is produced with the -s
 * option to ranlib(1).  This table of contents has the archive member name
 * "__.SYMDEF SORTED" and many programs (notably the 1.0 version of ld(1) can't
 * tell the difference between names because of the imbedded blank in the name
 * and works with either table of contents).  This second order is used by the
 * post 1.0 link editor to produce faster linking.  The original 1.0 version of
 * ranlib(1) gets confused when it is run on a archive with the second type of
 * table of contents because it and ar(1) which it uses use different ways to
 * determined the member name (ar(1) treats all blanks in the name as
 * significant and ranlib(1) only checks for the first one).
 */
#define SYMDEF		"__.SYMDEF"
#define SYMDEF_SORTED	"__.SYMDEF SORTED"

/*
 * Structure of the __.SYMDEF table of contents for an archive.
 * __.SYMDEF begins with a long giving the size in bytes of the ranlib
 * structures which immediately follow, and then continues with a string
 * table consisting of a long giving the number of bytes of strings which
 * follow and then the strings themselves.  The ran_strx fields index the
 * string table whose first byte is numbered 0.
 */
struct	ranlib {
    union {
	uint32_t	ran_strx;	/* string table index of */
#ifndef __LP64__
	char		*ran_name;	/* symbol defined by */
#endif
    } ran_un;
    uint32_t		ran_off;	/* library member at this offset */
};
#endif /* _MACH_O_RANLIB_H_ */
                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/redo_prebinding.h            0100644 0001750 0001750 00000027077 12612724206 026547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_REDO_PREBINDING_H_
#define _MACH_O_REDO_PREBINDING_H_

#define REDO_PREBINDING_VERSION 3
#include <mach/machine.h>
/*
 * For all APIs in this file the parameters program_name and error_message
 * are used the same.  For unrecoverable resource errors like being unable to
 * allocate memory each API prints a message to stderr precede with program_name
 * then calls exit(2) with the value EXIT_FAILURE.  If an API is unsuccessful
 * and if error_message pass to it is not NULL it is set to a malloc(3)'ed
 * buffer with a NULL terminated string with the error message.  For all APIs 
 * when they return they release all resources (memory, open file descriptors,
 * etc). 
 * 
 * The file_name parameter for these APIs may be of the form "foo(bar)" which is
 * NOT interpreted as an archive name and a member name in that archive.  As
 * these API deal with prebinding and prebound binaries ready for execution
 * can't be in archives.
 * 
 * If the executable_path parameter for these APIs is not NULL it is used for
 * any dependent library has a path that starts with "@executable_path". Then
 * "@executable_path" is replaced with executable_path. 
 * 
 * If the root_dir parameter is not NULL it is prepended to all the rooted
 * dependent library paths. 
 */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * dependent_libs() takes a file_name of a binary and returns a malloc(3)'ed
 * array of pointers (NULL terminated) to names (also malloc(3)'ed and '\0'
 * terminated names) of all the dependent libraries for that binary (not
 * recursive) for all of the architectures of that binary.  If successful
 * dependent_libs() returns a non NULL value (at minimum a pointer to one NULL
 * pointer). If unsuccessful dependent_libs() returns NULL.
 */ 
extern
char **
dependent_libs(
const char *file_name,
const char *program_name,
char **error_message);

/*
 * install_name() takes a file_name of a binary and returns a malloc(3)'ed
 * pointer to a NULL terminated string containing the install_name value for
 * the binary. If unsuccessful install_name() returns NULL.  In particular,
 * NULL is returned if the binary is not a dylib and there is no error_message
 * set.  If the all of the arch's are dylibs but all the install names don't
 * match NULL is returned and a error_message is set.  If some but not all of
 * the archs are dylibs NULL is returned and a error_message is set.
 */ 
extern
char *
install_name(
const char *file_name,
const char *program_name,
char **error_message);

/* return values for redo_prebinding() */
enum redo_prebinding_retval {
    REDO_PREBINDING_SUCCESS,
    REDO_PREBINDING_FAILURE,
    /* the following can only be returned if the parameter only_if_needed set */
    REDO_PREBINDING_NOT_NEEDED,
    REDO_PREBINDING_NOT_PREBOUND,
    REDO_PREBINDING_NEEDS_REBUILDING
};

/*
 * redo_prebinding() takes a file_name of a binary and redoes the prebinding on
 * it.  If output_file is not NULL the update file is written to output_file,
 * if not it is written to file_name.  If redo_prebinding() is successful it
 * returns REDO_PREBINDING_SUCCESS otherwise it returns REDO_PREBINDING_FAILURE.
 * If the parameter allow_missing_architectures is zero and not all
 * architectures can be updated it is not successful and nothing is done and
 * this returns REDO_PREBINDING_FAILURE.  If the parameter
 * allow_missing_architectures is non-zero then only problems with missing
 * architectures for the architecure of the cputype specified by 
 * allow_missing_architectures will cause this call to fail.  Other
 * architectures that could not be prebound due to missing architectures in
 * depending libraries will not have their prebinding updated but will not
 * cause this call to fail.
 * If the slide_to_address parameter is non-zero and the binary is a
 * dynamic library it is relocated to have that has its prefered address.  If
 * only_if_needed is non-zero the prebinding is checked first and only done if
 * needed.  The checking includes checking the prefered address against the
 * slide_to_address value if it is non-zero.  If only_if_needed is non-zero
 * and the prebinding does not have to be redone REDO_PREBINDING_NOT_NEEDED is
 * returned, if the binary is not prebound REDO_PREBINDING_NOT_PREBOUND is
 * returned and if the new load commands do not fit in the binary and it needs
 * to be rebuilt REDO_PREBINDING_NEEDS_REBUILDING is returned.
 * If zero_out_prebind_checksum is non-zero then the cksum field of the
 * LC_PREBIND_CKSUM load command (if any) is set to zero on output (this should
 * always be set by B&I tools and never set by the update_prebinding(1)
 * command).
 * If throttle is non-NULL it points to a value of the maximum bytes per second
 * to use for writting the output.  If the value is ULONG_MAX then the actual
 * bytes per second is returned indirectly through *throttle.
 */
extern 
enum redo_prebinding_retval
redo_prebinding(
const char *file_name,
const char *executable_path,
const char *root_dir,
const char *output_file,
const char *program_name,
char **error_message,
uint32_t slide_to_address,
int only_if_needed,
int zero_out_prebind_checksum,
cpu_type_t allow_missing_architectures,
uint32_t *throttle);


/* return values for needs_redo_prebinding() */
enum needs_redo_prebinding_retval {
    PREBINDING_UPTODATE,  /* a binary who's prebinding is up todate */
    PREBINDING_OUTOFDATE, /* a binary who's prebinding is out of date */
    NOT_PREBOUND,	  /* a binary, but not built prebound */
    NOT_PREBINDABLE,	  /* not a binary or statically linked,
			     prebinding does not apply */
    PREBINDING_UNKNOWN	  /* a binary who's prebinding can't be determined
			     because it is malformed, a library it depends
			     on is missing, etc. */
};

/*
 * needs_redo_prebinding() takes a file_name and determines if it is a binary
 * and if its prebinding is uptodate.  It returns one of the return values
 * above depending on the state of the binary and libraries. If the parameter
 * allow_missing_architectures is zero then the value returned is based on the
 * first architecture for fat files.  If the parameter
 * allow_missing_architectures is non-zero then the value returned is based on
 * the cputype specified by allow_missing_architectures.  If that architecture
 * is not present then PREBINDING_UPTODATE is returned.  If the parameter
 * expected_address is not zero and the binary is a dynamic library then the
 * library is checked to see if it is at the expected_address if not the
 * prebinding is assumed to be out of date and PREBINDING_OUTOFDATE is returned.
 */
extern
enum needs_redo_prebinding_retval
needs_redo_prebinding(
const char *file_name,
const char *executable_path,
const char *root_dir,
const char *program_name,
char **error_message,
uint32_t expected_address,
cpu_type_t allow_missing_architectures);


/*
 * unprebind() takes a file_name of a binary and resets or removes prebinding
 * information from it.  If inbuf is non-NULL, the memory pointed to by inbuf is
 * used as the input file contents.  Otherwise, the contents are loaded from 
 * the file at path file_name.  Even if inbuf is non-NULL, a file_name 
 * parameter should be specified for error reporting.  Similarly, if outbuf is 
 * non-NULL, upon return, outbuf will point to a buffer containing the 
 * unprebound binary and outlen will point to the length of the output buffer.  
 * This buffer is vm_allocate'd and therefore should be vm_deallocate'd when it 
 * is no longer needed.  If outbuf is NULL, and output_file is not NULL the 
 * update file is written to output_file, if outbuf is NULL and output_file is 
 * NULL, it is written to file_name.  
 * If unprebind() is successful it returns REDO_PREBINDING_SUCCESS otherwise it
 * returns REDO_PREBINDING_FAILURE If the binary is already unprebound (i.e. it
 * has the MH_PREBINDABLE flag set) then REDO_PREBINDING_NOT_NEEDED is returned.
 * If the binary is not prebound and not prebindable, 
 * REDO_PREBINDING_NOT_PREBOUND is returned.  If zero_checksum is non-zero then
 * the cksum field the LC_PREBIND_CKSUM load command (if any) is set to zero on
 * output, otherwise it is left alone.
 * Unprebinding slides dynamic libraries to address zero, resets prebound 
 * symbols to address zero and type undefined, resets symbol pointers, removes 
 * LC_PREBOUND_DYLIB commands, resets library timestamps, resets two-level hints
 * and updates relocation entries if necessary.  Unprebound binaries have
 * the MH_PREBINDABLE flag set, but not MH_PREBOUND.  It will also set the the
 * MH_ALLMODSBOUND flag if all two-level libraries were used and all modules
 * were found to be bound in the LC_PREBOUND_DYLIB commands.
 * As unprebinding is intended to produce a canonical Mach-O
 * binary, bundles and non-prebound executables and dylibs are acceptable
 * as input.  For these files, the  unprebind operation will zero library 
 * time stamps and version numbers and zero entries in the two-level hints
 * table.  These files will not gain the MH_PREBINDABLE flag.
 * All resulting binaries successfully processed by unprebind() will have
 * the MH_CANONICAL flag.
 */
extern
enum redo_prebinding_retval
unprebind(
const char *file_name,
const char *output_file,
const char *program_name,
char **error_message,
int zero_checksum,
void *inbuf,
uint32_t inlen,
void **outbuf,
uint32_t *outlen);

enum object_file_type_retval {
    OFT_OTHER,
    OFT_EXECUTABLE,
    OFT_DYLIB,
    OFT_BUNDLE,
    OFT_ARCHIVE,
    OFT_INCONSISTENT,
    OFT_FILE_ERROR
};

/*
 * object_file_type() takes a file_name and determines what type of object
 * file it is.  If it is a fat file and the architectures are not of the same
 * type then OFT_INCONSISTENT is returned.  If the file_name can't be opened,
 * read or malformed then OFT_FILE_ERROR is returned.
 */
extern
enum object_file_type_retval
object_file_type(
const char *file_name,
const char *program_name,
char **error_message);

struct prebind_cksum_arch {
    cpu_type_t cputype;		/* cpu specifier */
    cpu_subtype_t cpusubtype;	/* machine specifier */
    uint32_t has_cksum;		/* 1 if the arch as an LC_PREBIND_CKSUM */
    uint32_t cksum;		/* value of the cksum in LC_PREBIND_CKSUM */
};

/*
 * get_prebind_cksums() takes a file_name that is a Mach-O file or fat file
 * containing Mach-O files and returns a malloc(3)'ed array of
 * prebind_cksum_arch structs indirectly through the cksums parameter.  The
 * number of prebind_cksum_arch structs is returned indirectly through the
 * ncksums parameter.  If successful it returns zero else it returns non-zero.
 */
extern
int
get_prebind_cksums(
const char *file_name,
struct prebind_cksum_arch **cksums,
uint32_t *ncksums,
const char *program_name,
char **error_message);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_REDO_PREBINDING_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/reloc.h                      0100644 0001750 0001750 00000024412 12612724206 024507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$NetBSD: exec.h,v 1.6 1994/10/27 04:16:05 cgd Exp $	*/

/*
 * Copyright (c) 1993 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHO_RELOC_H_
#define _MACHO_RELOC_H_
#include <stdint.h>

/*
 * Format of a relocation entry of a Mach-O file.  Modified from the 4.3BSD
 * format.  The modifications from the original format were changing the value
 * of the r_symbolnum field for "local" (r_extern == 0) relocation entries.
 * This modification is required to support symbols in an arbitrary number of
 * sections not just the three sections (text, data and bss) in a 4.3BSD file.
 * Also the last 4 bits have had the r_type tag added to them.
 */
struct relocation_info {
   int32_t	r_address;	/* offset in the section to what is being
				   relocated */
   uint32_t     r_symbolnum:24,	/* symbol index if r_extern == 1 or section
				   ordinal if r_extern == 0 */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_length:2,	/* 0=byte, 1=word, 2=long, 3=quad */
		r_extern:1,	/* does not include value of sym referenced */
		r_type:4;	/* if not 0, machine specific relocation type */
};
#define	R_ABS	0		/* absolute relocation type for Mach-O files */

/*
 * The r_address is not really the address as it's name indicates but an offset.
 * In 4.3BSD a.out objects this offset is from the start of the "segment" for
 * which relocation entry is for (text or data).  For Mach-O object files it is
 * also an offset but from the start of the "section" for which the relocation
 * entry is for.  See comments in <mach-o/loader.h> about the r_address feild
 * in images for used with the dynamic linker.
 * 
 * In 4.3BSD a.out objects if r_extern is zero then r_symbolnum is an ordinal
 * for the segment the symbol being relocated is in.  These ordinals are the
 * symbol types N_TEXT, N_DATA, N_BSS or N_ABS.  In Mach-O object files these
 * ordinals refer to the sections in the object file in the order their section
 * structures appear in the headers of the object file they are in.  The first
 * section has the ordinal 1, the second 2, and so on.  This means that the
 * same ordinal in two different object files could refer to two different
 * sections.  And further could have still different ordinals when combined
 * by the link-editor.  The value R_ABS is used for relocation entries for
 * absolute symbols which need no further relocation.
 */

/*
 * For RISC machines some of the references are split across two instructions
 * and the instruction does not contain the complete value of the reference.
 * In these cases a second, or paired relocation entry, follows each of these
 * relocation entries, using a PAIR r_type, which contains the other part of the
 * reference not contained in the instruction.  This other part is stored in the
 * pair's r_address field.  The exact number of bits of the other part of the
 * reference store in the r_address field is dependent on the particular
 * relocation type for the particular architecture.
 */

/*
 * To make scattered loading by the link editor work correctly "local"
 * relocation entries can't be used when the item to be relocated is the value
 * of a symbol plus an offset (where the resulting expresion is outside the
 * block the link editor is moving, a blocks are divided at symbol addresses).
 * In this case. where the item is a symbol value plus offset, the link editor
 * needs to know more than just the section the symbol was defined.  What is
 * needed is the actual value of the symbol without the offset so it can do the
 * relocation correctly based on where the value of the symbol got relocated to
 * not the value of the expression (with the offset added to the symbol value).
 * So for the NeXT 2.0 release no "local" relocation entries are ever used when
 * there is a non-zero offset added to a symbol.  The "external" and "local"
 * relocation entries remain unchanged.
 *
 * The implemention is quite messy given the compatibility with the existing
 * relocation entry format.  The ASSUMPTION is that a section will never be
 * bigger than 2**24 - 1 (0x00ffffff or 16,777,215) bytes.  This assumption
 * allows the r_address (which is really an offset) to fit in 24 bits and high
 * bit of the r_address field in the relocation_info structure to indicate
 * it is really a scattered_relocation_info structure.  Since these are only
 * used in places where "local" relocation entries are used and not where
 * "external" relocation entries are used the r_extern field has been removed.
 *
 * For scattered loading to work on a RISC machine where some of the references
 * are split across two instructions the link editor needs to be assured that
 * each reference has a unique 32 bit reference (that more than one reference is
 * NOT sharing the same high 16 bits for example) so it move each referenced
 * item independent of each other.  Some compilers guarantees this but the
 * compilers don't so scattered loading can be done on those that do guarantee
 * this.
 */
#if defined(__BIG_ENDIAN__) || defined(__LITTLE_ENDIAN__)
/*
 * The reason for the ifdef's of __BIG_ENDIAN__ and __LITTLE_ENDIAN__ are that
 * when stattered relocation entries were added the mistake of using a mask
 * against a structure that is made up of bit fields was used.  To make this
 * design work this structure must be laid out in memory the same way so the
 * mask can be applied can check the same bit each time (r_scattered).
 */
#endif /* defined(__BIG_ENDIAN__) || defined(__LITTLE_ENDIAN__) */
#define R_SCATTERED 0x80000000	/* mask to be applied to the r_address field 
				   of a relocation_info structure to tell that
				   is is really a scattered_relocation_info
				   stucture */
struct scattered_relocation_info {
#ifdef __BIG_ENDIAN__
   uint32_t	r_scattered:1,	/* 1=scattered, 0=non-scattered (see above) */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_length:2,	/* 0=byte, 1=word, 2=long, 3=quad */
		r_type:4,	/* if not 0, machine specific relocation type */
   		r_address:24;	/* offset in the section to what is being
				   relocated */
   int32_t	r_value;	/* the value the item to be relocated is
				   refering to (without any offset added) */
#endif /* __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
   uint32_t
   		r_address:24,	/* offset in the section to what is being
				   relocated */
		r_type:4,	/* if not 0, machine specific relocation type */
		r_length:2,	/* 0=byte, 1=word, 2=long, 3=quad */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_scattered:1;	/* 1=scattered, 0=non-scattered (see above) */
   int32_t	r_value;	/* the value the item to be relocated is
				   refering to (without any offset added) */
#endif /* __LITTLE_ENDIAN__ */
};

/*
 * Relocation types used in a generic implementation.  Relocation entries for
 * normal things use the generic relocation as discribed above and their r_type
 * is GENERIC_RELOC_VANILLA (a value of zero).
 *
 * Another type of generic relocation, GENERIC_RELOC_SECTDIFF, is to support
 * the difference of two symbols defined in different sections.  That is the
 * expression "symbol1 - symbol2 + constant" is a relocatable expression when
 * both symbols are defined in some section.  For this type of relocation the
 * both relocations entries are scattered relocation entries.  The value of
 * symbol1 is stored in the first relocation entry's r_value field and the
 * value of symbol2 is stored in the pair's r_value field.
 *
 * A special case for a prebound lazy pointer is needed to beable to set the
 * value of the lazy pointer back to its non-prebound state.  This is done
 * using the GENERIC_RELOC_PB_LA_PTR r_type.  This is a scattered relocation
 * entry where the r_value feild is the value of the lazy pointer not prebound.
 */
enum reloc_type_generic
{
    GENERIC_RELOC_VANILLA,	/* generic relocation as discribed above */
    GENERIC_RELOC_PAIR,		/* Only follows a GENERIC_RELOC_SECTDIFF */
    GENERIC_RELOC_SECTDIFF,
    GENERIC_RELOC_PB_LA_PTR,	/* prebound lazy pointer */
    GENERIC_RELOC_LOCAL_SECTDIFF,
    GENERIC_RELOC_TLV		/* thread local variables */
};

#endif /* _MACHO_RELOC_H_ */
                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/rld.h                        0100644 0001750 0001750 00000004133 12612724206 024162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * This is the interface to the rld package as described in rld(3).
 */

#ifndef _MACHO_RLD_H_
#define _MACHO_RLD_H_

#include <streams/streams.h>
#include <mach-o/loader.h>

extern long rld_load(
    NXStream *stream,
    struct mach_header **header_addr,
    const char * const *object_filenames,
    const char *output_filename);

extern long rld_load_from_memory(
    NXStream *stream,
    struct mach_header **header_addr,
    const char *object_name,
    char *object_addr,
    long object_size,
    const char *output_filename);

extern long rld_unload(
    NXStream *stream);

extern long rld_lookup(
    NXStream *stream,
    const char *symbol_name,
    unsigned long *value);

extern long rld_forget_symbol(
    NXStream *stream,
    const char *symbol_name);

extern long rld_unload_all(
    NXStream *stream,
    long deallocate_sets);

extern long rld_load_basefile(
    NXStream *stream,
    const char *base_filename);

extern void rld_address_func(
    unsigned long (*func)(unsigned long size, unsigned long headers_size));

extern long rld_write_symfile(
    NXStream *stream,
    const char *output_filename);
#endif /* _MACHO_RLD_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/rld_state.h                  0100644 0001750 0001750 00000007725 12612724206 025374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * To allow the debugger to debug programs that used rld on themselves without
 * having the having the programs create a debug file information is maintained
 * in the rld package for the debugger.  This information is two static data
 * items and a static routine.  The information that is maintained is the state
 * of the loaded sets are currently loaded into the program.  The number of
 * object files and their names that make up each set and the resulting address
 * they were loaded at is maintained for each set.  The static data symbol
 * rld_loaded_state points to an array of rld_loaded_state structures that
 * contains the above information.  The static data symbol rld_nloaded_states
 * contains the count of these structures.  When the loaded state is changed
 * the static routine rld_loaded_state_changed() is called.
 *
 * This is the only information in the rld package the debugger is allowed to
 * use.  The debugger sets a break point on the routine rld_loaded_state_changed
 * when it is triped on then it can inspect the rld_loaded_state.  Then using
 * the rld package and the program it is debugging as a base file then it can
 * create the symbols for the loaded sets by doing rld_loads for each set.
 * The debugger uses an undocumented feature of rld_load (intended only for it's
 * use) which is to used the interger value of 1 (RLD_DEBUG_OUTPUT_FILENAME)
 * for the output_filename which causes the symbols to be created and left in
 * memory and not written to a file.
 *
 * When the debugger attaches to a running process there is a window of time
 * where the process could be doing an rld operation and the state in not
 * correct.  The window is shorted to it's minimal time by changing the value
 * of rld_nloaded_states so that that number of states can be safely accessed.
 * There are still small windows where problems can occur.
 */

struct rld_loaded_state {
    char **object_filenames;	/* pointer to an array of file names loaded */
    unsigned long		/*  in this set */
	nobject_filenames;	/* number of file names loaded in this set */
    struct mach_header		/* The address the set was link edited at */
	*header_addr;
};

/* 
 * static unsigned long rld_nloaded_states = 0;
 * static struct rld_loaded_state *rld_loaded_state = NULL;
 *
 * static void rld_loaded_state_changed(void);
 */
#define RLD_NLOADED_STATES	"rld_nloaded_states"
#define RLD_LOADED_STATE	"rld_loaded_state"
#define RLD_LOADED_STATE_CHANGED "rld_loaded_state_changed"

#define RLD_DEBUG_OUTPUT_FILENAME ((char *)1)

/*
 * moninitrld() can be defined in the librld.o library module if it is used or
 * defined as a common in gcrt0.o if the librld.o library module is not used.
 * The library module is passed monaddition() to call when a rld_load() is done
 * and returns a pointer to the routine to get the rld loaded state so it can
 * be written in to the gmon.out file.
 */
extern void (*moninitrld(
    void (* monaddition)(char *lowpc, char *highpc)))
	    (struct rld_loaded_state **rld_loaded_state,
	     unsigned long *rld_nloaded_states);
                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/sarld.h                      0100644 0001750 0001750 00000007626 12612724206 024520  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_SARLD_H_
#define _MACH_O_SARLD_H_

#include <mach-o/nlist.h>
/*
 * sa_rld() loads the specified object in memory against the specified
 * base file in memory.  The output is placed in memory starting at
 * the value of the parameter workmem_addr and the size of the memory
 * used for the output returned indirectly through workmem_size.
 * Initially *workmem_size is the size of the working memory.
 */
typedef int sa_rld_t(
char		   *basefile_name,  /* base file name */
struct mach_header *basefile_addr,  /* mach header of the base file */

char               *object_name,    /* name of the object to load */
char               *object_addr,    /* addr of the object in memory to load */
unsigned long       object_size,    /* size of the object in memory to load */

char               *workmem_addr,   /* address of working memory */
unsigned long      *workmem_size,   /* size of working memory (in/out) */

char               *error_buf_addr, /* address of error message buffer */
unsigned long       error_buf_size, /* size of error message buffer */

char               *malloc_addr,    /* address to use for initializing malloc */
unsigned long       malloc_len);    /* length to use for same */

/*
 * sa_rld_with_symtab() is the same as sa_rld() except it passed in a pointer
 * to the symbol table, its size and a pointer to the string table and its
 * size.  Rather getting the the symbol table off of the mach header and the
 * link edit segment.
 */
typedef int sa_rld_with_symtab_t(
char		   *basefile_name,  /* base file name */
struct mach_header *basefile_addr,  /* mach header of the base file */

char               *object_name,    /* name of the object to load */
char               *object_addr,    /* addr of the object in memory to load */
unsigned long       object_size,    /* size of the object in memory to load */

char               *workmem_addr,   /* address of working memory */
unsigned long      *workmem_size,   /* size of working memory (in/out) */

char               *error_buf_addr, /* address of error message buffer */
unsigned long       error_buf_size, /* size of error message buffer */

char               *malloc_addr,    /* address to use for initializing malloc */
unsigned long       malloc_len,     /* length to use for same */

struct nlist       *symtab,         /* pointer to the symbol table */
unsigned long      nsyms,           /* number of symbols */

char               *strtab,         /* pointer to the string table */
unsigned long      strsize);        /* sizeof the string table */

#ifdef SA_RLD
extern sa_rld_t sa_rld;
extern sa_rld_with_symtab_t sa_rld_with_symtab;

/*
 * These two variables are internal to sarld and not part of the external sarld
 * API.  These are set in sa_rld() and used in layout_segments() as the place
 * to put the output in memory.
 */
__private_extern__ char         *sa_rld_output_addr;
__private_extern__ unsigned long sa_rld_output_size;
#endif /* SA_RLD */


#endif /* _MACH_O_SARLD_H_ */
                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/sparc/                       0040755 0001750 0001750 00000000000 12612724206 024342  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/sparc/reloc.h                0100644 0001750 0001750 00000004361 12612724206 025620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*    reloc.h   -  assemble for Sparc    */
/*    Defines machine specific relocation entries */

#ifndef SPARC_RELOC_INCLUDED
#define SPARC_RELOC_INCLUDED

/*
 * Relocation types used in the sparc implementation.  Relocation entries for
 * things other than instructions use the same generic relocation as discribed
 * in <mach-o/reloc.h> and their r_type is SPARC_RELOC_VANILLA.  The rest of the
 * relocation types are for instructions.  Since they are for instructions the
 * r_address field indicates the 32 bit instruction that the relocation is to
 * be preformed on.  The field r_pcrel is set only for the SPARC_RELOC_WDISP22
 * and SPARC_RELOC_WDISP30.  And r_length is set to long for all
 * non-RELOC_VANILLA r_types.
 */
enum reloc_type_sparc
{
	SPARC_RELOC_VANILLA,	/* vanilla relocation */
	SPARC_RELOC_PAIR,	/* the second relocation entry of a pair */
	SPARC_RELOC_HI22,	/* 22 high bits (sethi) (has pair) */
	SPARC_RELOC_LO10,	/* 10 low bits (has pair) */
	SPARC_RELOC_WDISP22,	/* 22 bit PC relative displacement */
	SPARC_RELOC_WDISP30,	/* 30 bit PC relative displacement */
	SPARC_RELOC_SECTDIFF,	/* a PAIR follows with subtract symbol value */
	SPARC_RELOC_HI22_SECTDIFF,
	SPARC_RELOC_LO10_SECTDIFF,
	SPARC_RELOC_PB_LA_PTR	/* prebound lazy pointer */
};
#endif    /* SPARC_RELOC_INCLUDED */
                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/sparc/swap.h                 0100644 0001750 0001750 00000002402 12612724206 025460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#import <architecture/byte_order.h>
#import <mach/sparc/thread_status.h>

void swap_sparc_thread_state_regs(
    struct sparc_thread_state_regs *cpu,
    enum NXByteOrder target_byte_sex);

void swap_sparc_thread_state_fpu(
    struct sparc_thread_state_fpu *fpu,
    enum NXByteOrder target_byte_sex);
                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/stab.h                       0100644 0001750 0001750 00000014261 12612724206 024335  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACHO_STAB_H_
#define _MACHO_STAB_H_
/*	$NetBSD: stab.h,v 1.4 1994/10/26 00:56:25 cgd Exp $	*/

/*-
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stab.h	5.2 (Berkeley) 4/4/91
 */

/*
 * This file gives definitions supplementing <nlist.h> for permanent symbol
 * table entries of Mach-O files.  Modified from the BSD definitions.  The
 * modifications from the original definitions were changing what the values of
 * what was the n_other field (an unused field) which is now the n_sect field.
 * These modifications are required to support symbols in an arbitrary number of
 * sections not just the three sections (text, data and bss) in a BSD file.
 * The values of the defined constants have NOT been changed.
 *
 * These must have one of the N_STAB bits on.  The n_value fields are subject
 * to relocation according to the value of their n_sect field.  So for types
 * that refer to things in sections the n_sect field must be filled in with the
 * proper section ordinal.  For types that are not to have their n_value field 
 * relocatated the n_sect field must be NO_SECT.
 */

/*
 * Symbolic debugger symbols.  The comments give the conventional use for
 * 
 * 	.stabs "n_name", n_type, n_sect, n_desc, n_value
 *
 * where n_type is the defined constant and not listed in the comment.  Other
 * fields not listed are zero. n_sect is the section ordinal the entry is
 * refering to.
 */
#define	N_GSYM	0x20	/* global symbol: name,,NO_SECT,type,0 */
#define	N_FNAME	0x22	/* procedure name (f77 kludge): name,,NO_SECT,0,0 */
#define	N_FUN	0x24	/* procedure: name,,n_sect,linenumber,address */
#define	N_STSYM	0x26	/* static symbol: name,,n_sect,type,address */
#define	N_LCSYM	0x28	/* .lcomm symbol: name,,n_sect,type,address */
#define N_BNSYM 0x2e	/* begin nsect sym: 0,,n_sect,0,address */
#define N_AST	0x32	/* AST file path: name,,NO_SECT,0,0 */
#define N_OPT	0x3c	/* emitted with gcc2_compiled and in gcc source */
#define	N_RSYM	0x40	/* register sym: name,,NO_SECT,type,register */
#define	N_SLINE	0x44	/* src line: 0,,n_sect,linenumber,address */
#define N_ENSYM 0x4e	/* end nsect sym: 0,,n_sect,0,address */
#define	N_SSYM	0x60	/* structure elt: name,,NO_SECT,type,struct_offset */
#define	N_SO	0x64	/* source file name: name,,n_sect,0,address */
#define	N_OSO	0x66	/* object file name: name,,0,0,st_mtime */
#define	N_LSYM	0x80	/* local sym: name,,NO_SECT,type,offset */
#define N_BINCL	0x82	/* include file beginning: name,,NO_SECT,0,sum */
#define	N_SOL	0x84	/* #included file name: name,,n_sect,0,address */
#define	N_PARAMS  0x86	/* compiler parameters: name,,NO_SECT,0,0 */
#define	N_VERSION 0x88	/* compiler version: name,,NO_SECT,0,0 */
#define	N_OLEVEL  0x8A	/* compiler -O level: name,,NO_SECT,0,0 */
#define	N_PSYM	0xa0	/* parameter: name,,NO_SECT,type,offset */
#define N_EINCL	0xa2	/* include file end: name,,NO_SECT,0,0 */
#define	N_ENTRY	0xa4	/* alternate entry: name,,n_sect,linenumber,address */
#define	N_LBRAC	0xc0	/* left bracket: 0,,NO_SECT,nesting level,address */
#define N_EXCL	0xc2	/* deleted include file: name,,NO_SECT,0,sum */
#define	N_RBRAC	0xe0	/* right bracket: 0,,NO_SECT,nesting level,address */
#define	N_BCOMM	0xe2	/* begin common: name,,NO_SECT,0,0 */
#define	N_ECOMM	0xe4	/* end common: name,,n_sect,0,0 */
#define	N_ECOML	0xe8	/* end common (local name): 0,,n_sect,0,address */
#define	N_LENG	0xfe	/* second stab entry with length information */

/*
 * for the berkeley pascal compiler, pc(1):
 */
#define	N_PC	0x30	/* global pascal symbol: name,,NO_SECT,subtype,line */

#endif /* _MACHO_STAB_H_ */
                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/swap.h                       0100644 0001750 0001750 00000015604 12612724206 024360  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_SWAP_H_
#define _MACH_O_SWAP_H_

#include <stdint.h>
#include <architecture/byte_order.h>
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/ranlib.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

extern void swap_fat_header(
    struct fat_header *fat_header,
    enum NXByteOrder target_byte_order);

extern void swap_fat_arch(
    struct fat_arch *fat_archs,
    uint32_t nfat_arch,
    enum NXByteOrder target_byte_order);

extern void swap_mach_header(
    struct mach_header *mh,
    enum NXByteOrder target_byte_order);

extern void swap_mach_header_64(
    struct mach_header_64 *mh,
    enum NXByteOrder target_byte_order);

extern void swap_load_command(
    struct load_command *lc,
    enum NXByteOrder target_byte_order);

extern void swap_segment_command(
    struct segment_command *sg,
    enum NXByteOrder target_byte_order);

extern void swap_segment_command_64(
    struct segment_command_64 *sg,
    enum NXByteOrder target_byte_order);

extern void swap_section(
    struct section *s,
    uint32_t nsects,
    enum NXByteOrder target_byte_order);

extern void swap_section_64(
    struct section_64 *s,
    uint32_t nsects,
    enum NXByteOrder target_byte_order);

extern void swap_symtab_command(
    struct symtab_command *st,
    enum NXByteOrder target_byte_order);

extern void swap_dysymtab_command(
    struct dysymtab_command *dyst,
    enum NXByteOrder target_byte_sex);

extern void swap_symseg_command(
    struct symseg_command *ss,
    enum NXByteOrder target_byte_order);

extern void swap_fvmlib_command(
    struct fvmlib_command *fl,
    enum NXByteOrder target_byte_order);

extern void swap_dylib_command(
    struct dylib_command *dl,
    enum NXByteOrder target_byte_sex);

extern void swap_sub_framework_command(
    struct sub_framework_command *sub,
    enum NXByteOrder target_byte_sex);

extern void swap_sub_umbrella_command(
    struct sub_umbrella_command *usub,
    enum NXByteOrder target_byte_sex);

extern void swap_sub_library_command(
    struct sub_library_command *lsub,
    enum NXByteOrder target_byte_sex);

extern void swap_sub_client_command(
    struct sub_client_command *csub,
    enum NXByteOrder target_byte_sex);

extern void swap_prebound_dylib_command(
    struct prebound_dylib_command *pbdylib,
    enum NXByteOrder target_byte_sex);

extern void swap_dylinker_command(
    struct dylinker_command *dyld,
    enum NXByteOrder target_byte_sex);

extern void swap_fvmfile_command(
    struct fvmfile_command *ff,
    enum NXByteOrder target_byte_order);

extern void swap_thread_command(
    struct thread_command *ut,
    enum NXByteOrder target_byte_order);

extern void swap_ident_command(
    struct ident_command *ident,
    enum NXByteOrder target_byte_order);

extern void swap_routines_command(
    struct routines_command *r_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_routines_command_64(
    struct routines_command_64 *r_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_twolevel_hints_command(
    struct twolevel_hints_command *hints_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_prebind_cksum_command(
    struct prebind_cksum_command *cksum_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_uuid_command(
    struct uuid_command *uuid_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_linkedit_data_command(
    struct linkedit_data_command *ld,
    enum NXByteOrder target_byte_sex);

extern void swap_version_min_command(
    struct version_min_command *ver_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_rpath_command(
    struct rpath_command *rpath_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_encryption_command(
    struct encryption_info_command *ec,
    enum NXByteOrder target_byte_sex);

extern void swap_encryption_command_64(
    struct encryption_info_command_64 *ec,
    enum NXByteOrder target_byte_sex);

extern void swap_linker_option_command(
    struct linker_option_command *lo,
    enum NXByteOrder target_byte_sex);

extern void swap_dyld_info_command(
    struct dyld_info_command *ed,
    enum NXByteOrder target_byte_sex);

extern void swap_entry_point_command(
    struct entry_point_command *ep,
    enum NXByteOrder target_byte_sex);

extern void swap_source_version_command(
    struct source_version_command *sv,
    enum NXByteOrder target_byte_sex);

extern void swap_prebind_cksum_command(
    struct prebind_cksum_command *cksum_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_uuid_command(
    struct uuid_command *uuid_cmd,
    enum NXByteOrder target_byte_sex);

extern void swap_twolevel_hint(
    struct twolevel_hint *hints,
    uint32_t nhints,
    enum NXByteOrder target_byte_sex);

extern void swap_nlist(
    struct nlist *symbols,
    uint32_t nsymbols,
    enum NXByteOrder target_byte_order);

extern void swap_nlist_64(
    struct nlist_64 *symbols,
    uint32_t nsymbols,
    enum NXByteOrder target_byte_order);

extern void swap_ranlib(
    struct ranlib *ranlibs,
    uint32_t nranlibs,
    enum NXByteOrder target_byte_order);

extern void swap_relocation_info(
    struct relocation_info *relocs,
    uint32_t nrelocs,
    enum NXByteOrder target_byte_order);

extern void swap_indirect_symbols(
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    enum NXByteOrder target_byte_sex);

extern void swap_dylib_reference(
    struct dylib_reference *refs,  
    uint32_t nrefs,
    enum NXByteOrder target_byte_sex);

extern void swap_dylib_module(  
    struct dylib_module *mods,
    uint32_t nmods, 
    enum NXByteOrder target_byte_sex);

extern void swap_dylib_module_64(  
    struct dylib_module_64 *mods,
    uint32_t nmods, 
    enum NXByteOrder target_byte_sex);

extern void swap_dylib_table_of_contents(
    struct dylib_table_of_contents *tocs,
    uint32_t ntocs,
    enum NXByteOrder target_byte_sex);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_SWAP_H_ */
                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/x86_64/                      0040755 0001750 0001750 00000000000 12612724206 024170  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/mach-o/x86_64/reloc.h               0100644 0001750 0001750 00000020225 12612724206 025443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Relocations for x86_64 are a bit different than for other architectures in
 * Mach-O: Scattered relocations are not used.  Almost all relocations produced
 * by the compiler are external relocations.  An external relocation has the
 * r_extern bit set to 1 and the r_symbolnum field contains the symbol table
 * index of the target label.
 * 
 * When the assembler is generating relocations, if the target label is a local
 * label (begins with 'L'), then the previous non-local label in the same
 * section is used as the target of the external relocation.  An addend is used
 * with the distance from that non-local label to the target label.  Only when
 * there is no previous non-local label in the section is an internal
 * relocation used.
 * 
 * The addend (i.e. the 4 in _foo+4) is encoded in the instruction (Mach-O does
 * not have RELA relocations).  For PC-relative relocations, the addend is
 * stored directly in the instruction.  This is different from other Mach-O
 * architectures, which encode the addend minus the current section offset.
 * 
 * The relocation types are:
 * 
 * 	X86_64_RELOC_UNSIGNED	// for absolute addresses
 * 	X86_64_RELOC_SIGNED		// for signed 32-bit displacement
 * 	X86_64_RELOC_BRANCH		// a CALL/JMP instruction with 32-bit displacement
 * 	X86_64_RELOC_GOT_LOAD	// a MOVQ load of a GOT entry
 * 	X86_64_RELOC_GOT		// other GOT references
 * 	X86_64_RELOC_SUBTRACTOR	// must be followed by a X86_64_RELOC_UNSIGNED
 * 
 * The following are sample assembly instructions, followed by the relocation
 * and section content they generate in an object file:
 * 
 * 	call _foo
 * 		r_type=X86_64_RELOC_BRANCH, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		E8 00 00 00 00
 * 
 * 	call _foo+4
 * 		r_type=X86_64_RELOC_BRANCH, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		E8 04 00 00 00 
 * 
 * 	movq _foo@GOTPCREL(%rip), %rax
 * 		r_type=X86_64_RELOC_GOT_LOAD, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		48 8B 05 00 00 00 00
 * 	
 * 	pushq _foo@GOTPCREL(%rip)
 * 		r_type=X86_64_RELOC_GOT, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		FF 35 00 00 00 00
 * 	
 * 	movl _foo(%rip), %eax
 * 		r_type=X86_64_RELOC_SIGNED, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		8B 05 00 00 00 00
 * 
 * 	movl _foo+4(%rip), %eax
 * 		r_type=X86_64_RELOC_SIGNED, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		8B 05 04 00 00 00
 * 
 * 	movb  $0x12, _foo(%rip)
 * 		r_type=X86_64_RELOC_SIGNED, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		C6 05 FF FF FF FF 12
 * 
 * 	movl  $0x12345678, _foo(%rip)
 * 		r_type=X86_64_RELOC_SIGNED, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_foo
 * 		C7 05 FC FF FF FF 78 56 34 12
 * 
 * 	.quad _foo
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		00 00 00 00 00 00 00 00
 * 
 * 	.quad _foo+4
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		04 00 00 00 00 00 00 00
 * 
 * 	.quad _foo - _bar
 * 		r_type=X86_64_RELOC_SUBTRACTOR, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_bar
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		00 00 00 00 00 00 00 00
 * 
 * 	.quad _foo - _bar + 4
 * 		r_type=X86_64_RELOC_SUBTRACTOR, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_bar
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		04 00 00 00 00 00 00 00
 * 	
 * 	.long _foo - _bar
 * 		r_type=X86_64_RELOC_SUBTRACTOR, r_length=2, r_extern=1, r_pcrel=0, r_symbolnum=_bar
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=2, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		00 00 00 00
 * 
 * 	lea L1(%rip), %rax
 * 		r_type=X86_64_RELOC_SIGNED, r_length=2, r_extern=1, r_pcrel=1, r_symbolnum=_prev
 * 		48 8d 05 12 00 00 00
 * 		// assumes _prev is the first non-local label 0x12 bytes before L1
 * 
 * 	lea L0(%rip), %rax
 * 		r_type=X86_64_RELOC_SIGNED, r_length=2, r_extern=0, r_pcrel=1, r_symbolnum=3
 * 		48 8d 05 56 00 00 00
 *		// assumes L0 is in third section and there is no previous non-local label.
 *		// The rip-relative-offset of 0x00000056 is L0-address_of_next_instruction.
 *		// address_of_next_instruction is the address of the relocation + 4.
 *
 *     add     $6,L0(%rip)
 *             r_type=X86_64_RELOC_SIGNED_1, r_length=2, r_extern=0, r_pcrel=1, r_symbolnum=3
 *		83 05 18 00 00 00 06
 *		// assumes L0 is in third section and there is no previous non-local label.
 *		// The rip-relative-offset of 0x00000018 is L0-address_of_next_instruction.
 *		// address_of_next_instruction is the address of the relocation + 4 + 1.
 *		// The +1 comes from SIGNED_1.  This is used because the relocation is not
 *		// at the end of the instruction.
 *
 * 	.quad L1
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_prev
 * 		12 00 00 00 00 00 00 00
 * 		// assumes _prev is the first non-local label 0x12 bytes before L1
 * 
 * 	.quad L0
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=0, r_pcrel=0, r_symbolnum=3
 * 		56 00 00 00 00 00 00 00
 * 		// assumes L0 is in third section, has an address of 0x00000056 in .o
 * 		// file, and there is no previous non-local label
 * 
 * 	.quad _foo - .
 * 		r_type=X86_64_RELOC_SUBTRACTOR, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_prev
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		EE FF FF FF FF FF FF FF
 * 		// assumes _prev is the first non-local label 0x12 bytes before this
 * 		// .quad
 * 
 * 	.quad _foo - L1
 * 		r_type=X86_64_RELOC_SUBTRACTOR, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_prev
 * 		r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_extern=1, r_pcrel=0, r_symbolnum=_foo
 * 		EE FF FF FF FF FF FF FF
 * 		// assumes _prev is the first non-local label 0x12 bytes before L1
 * 
 * 	.quad L1 - _prev
 * 		// No relocations.  This is an assembly time constant.
 * 		12 00 00 00 00 00 00 00
 * 		// assumes _prev is the first non-local label 0x12 bytes before L1
 *
 *
 *
 * In final linked images, there are only two valid relocation kinds:
 *
 *     r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_pcrel=0, r_extern=1, r_symbolnum=sym_index
 *	This tells dyld to add the address of a symbol to a pointer sized (8-byte)
 *  piece of data (i.e on disk the 8-byte piece of data contains the addend). The 
 *  r_symbolnum contains the index into the symbol table of the target symbol.
 *
 *     r_type=X86_64_RELOC_UNSIGNED, r_length=3, r_pcrel=0, r_extern=0, r_symbolnum=0
 * This tells dyld to adjust the pointer sized (8-byte) piece of data by the amount
 * the containing image was loaded from its base address (e.g. slide).
 *
 */ 
enum reloc_type_x86_64
{
	X86_64_RELOC_UNSIGNED,		// for absolute addresses
	X86_64_RELOC_SIGNED,		// for signed 32-bit displacement
	X86_64_RELOC_BRANCH,		// a CALL/JMP instruction with 32-bit displacement
	X86_64_RELOC_GOT_LOAD,		// a MOVQ load of a GOT entry
	X86_64_RELOC_GOT,			// other GOT references
	X86_64_RELOC_SUBTRACTOR,	// must be followed by a X86_64_RELOC_UNSIGNED
	X86_64_RELOC_SIGNED_1,		// for signed 32-bit displacement with a -1 addend
	X86_64_RELOC_SIGNED_2,		// for signed 32-bit displacement with a -2 addend
	X86_64_RELOC_SIGNED_4,		// for signed 32-bit displacement with a -4 addend
	X86_64_RELOC_TLV,		// for thread local variables
};
                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/opcode/                             0040755 0001750 0001750 00000000000 12612724206 023337  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/opcode/arm.h                        0100644 0001750 0001750 00000022610 12612724206 024265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* ARM assembler/disassembler support.
   Copyright 2004 Free Software Foundation, Inc.

   This file is part of GDB and GAS.

   GDB and GAS are free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 1, or (at
   your option) any later version.

   GDB and GAS are distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GDB or GAS; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* The following bitmasks control CPU extensions:  */
#define ARM_EXT_V1	 0x00000001	/* All processors (core set).  */
#define ARM_EXT_V2	 0x00000002	/* Multiply instructions.  */
#define ARM_EXT_V2S	 0x00000004	/* SWP instructions.       */
#define ARM_EXT_V3	 0x00000008	/* MSR MRS.                */
#define ARM_EXT_V3M	 0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_V4	 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_V4T	 0x00000040	/* Thumb.                  */
#define ARM_EXT_V5	 0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5T	 0x00000100	/* Improved interworking.  */
#define ARM_EXT_V5ExP	 0x00000200	/* DSP core set.           */
#define ARM_EXT_V5E	 0x00000400	/* DSP Double transfers.   */
#define ARM_EXT_V5J	 0x00000800	/* Jazelle extension.	   */
#define ARM_EXT_V6       0x00001000     /* ARM V6.                 */
#define ARM_EXT_V6K      0x00002000     /* ARM V6K.                */
#define ARM_EXT_V6Z      0x00004000     /* ARM V6Z.                */
#define ARM_EXT_V6T2	 0x00008000	/* Thumb-2.                */
#define ARM_EXT_DIV	 0x00010000	/* Integer division.       */
/* The 'M' in Arm V7M stands for Microcontroller.
   On earlier architecture variants it stands for Multiply.  */
#define ARM_EXT_V5E_NOTM 0x00020000	/* Arm V5E but not Arm V7M. */
#define ARM_EXT_V6_NOTM	 0x00040000	/* Arm V6 but not Arm V7M. */
#define ARM_EXT_V7	 0x00080000	/* Arm V7.                 */
#define ARM_EXT_V7A	 0x00100000	/* Arm V7A.                */
#define ARM_EXT_V7R	 0x00200000	/* Arm V7R.                */
#define ARM_EXT_V7M	 0x00400000	/* Arm V7M.                */

/* Co-processor space extensions.  */
#define ARM_CEXT_XSCALE   0x00000001	/* Allow MIA etc.          */
#define ARM_CEXT_MAVERICK 0x00000002	/* Use Cirrus/DSP coprocessor.  */
#define ARM_CEXT_IWMMXT   0x00000004    /* Intel Wireless MMX technology coprocessor.   */
#define ARM_CEXT_IWMMXT2  0x00000008    /* Intel Wireless MMX technology coprocessor version 2.   */

#define FPU_ENDIAN_PURE	 0x80000000	/* Pure-endian doubles.	      */
#define FPU_ENDIAN_BIG	 0		/* Double words-big-endian.   */
#define FPU_FPA_EXT_V1	 0x40000000	/* Base FPA instruction set.  */
#define FPU_FPA_EXT_V2	 0x20000000	/* LFM/SFM.		      */
#define FPU_MAVERICK	 0x10000000	/* Cirrus Maverick.	      */
#define FPU_VFP_EXT_V1xD 0x08000000	/* Base VFP instruction set.  */
#define FPU_VFP_EXT_V1	 0x04000000	/* Double-precision insns.    */
#define FPU_VFP_EXT_V2	 0x02000000	/* ARM10E VFPr1.	      */
#define FPU_VFP_EXT_V3	 0x01000000	/* VFPv3 insns.	              */
#define FPU_NEON_EXT_V1	 0x00800000	/* Neon (SIMD) insns.	      */

/* Architectures are the sum of the base and extensions.  The ARM ARM (rev E)
   defines the following: ARMv3, ARMv3M, ARMv4xM, ARMv4, ARMv4TxM, ARMv4T,
   ARMv5xM, ARMv5, ARMv5TxM, ARMv5T, ARMv5TExP, ARMv5TE.  To these we add
   three more to cover cores prior to ARM6.  Finally, there are cores which
   implement further extensions in the co-processor space.  */
#define ARM_AEXT_V1			  ARM_EXT_V1
#define ARM_AEXT_V2	(ARM_AEXT_V1	| ARM_EXT_V2)
#define ARM_AEXT_V2S	(ARM_AEXT_V2	| ARM_EXT_V2S)
#define ARM_AEXT_V3	(ARM_AEXT_V2S	| ARM_EXT_V3)
#define ARM_AEXT_V3M	(ARM_AEXT_V3	| ARM_EXT_V3M)
#define ARM_AEXT_V4xM	(ARM_AEXT_V3	| ARM_EXT_V4)
#define ARM_AEXT_V4	(ARM_AEXT_V3M	| ARM_EXT_V4)
#define ARM_AEXT_V4TxM	(ARM_AEXT_V4xM	| ARM_EXT_V4T)
#define ARM_AEXT_V4T	(ARM_AEXT_V4	| ARM_EXT_V4T)
#define ARM_AEXT_V5xM	(ARM_AEXT_V4xM	| ARM_EXT_V5)
#define ARM_AEXT_V5	(ARM_AEXT_V4	| ARM_EXT_V5)
#define ARM_AEXT_V5TxM	(ARM_AEXT_V5xM	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_AEXT_V5T	(ARM_AEXT_V5	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_AEXT_V5TExP	(ARM_AEXT_V5T	| ARM_EXT_V5ExP)
#define ARM_AEXT_V5TE	(ARM_AEXT_V5TExP | ARM_EXT_V5E)
#define ARM_AEXT_V5TEJ	(ARM_AEXT_V5TE	| ARM_EXT_V5J)
#define ARM_AEXT_V6     (ARM_AEXT_V5TEJ | ARM_EXT_V6)
#define ARM_AEXT_V6K    (ARM_AEXT_V6    | ARM_EXT_V6K)
#define ARM_AEXT_V6Z    (ARM_AEXT_V6    | ARM_EXT_V6Z)
#define ARM_AEXT_V6ZK   (ARM_AEXT_V6    | ARM_EXT_V6K | ARM_EXT_V6Z)
#define ARM_AEXT_V6T2   (ARM_AEXT_V6    | ARM_EXT_V6T2 | ARM_EXT_V6_NOTM)
#define ARM_AEXT_V6KT2  (ARM_AEXT_V6T2 | ARM_EXT_V6K)
#define ARM_AEXT_V6ZT2  (ARM_AEXT_V6T2 | ARM_EXT_V6Z)
#define ARM_AEXT_V6ZKT2 (ARM_AEXT_V6T2 | ARM_EXT_V6K | ARM_EXT_V6Z)
#define ARM_AEXT_V7_ARM	(ARM_AEXT_V6ZKT2 | ARM_EXT_V7)
#define ARM_AEXT_V7A	(ARM_AEXT_V7_ARM | ARM_EXT_V7A)
#define ARM_AEXT_V7R	(ARM_AEXT_V7_ARM | ARM_EXT_V7R | ARM_EXT_DIV)
#define ARM_AEXT_NOTM \
  (ARM_AEXT_V4 | ARM_EXT_V5ExP | ARM_EXT_V5J | ARM_EXT_V6_NOTM)
#define ARM_AEXT_V7M \
  ((ARM_AEXT_V7_ARM | ARM_EXT_V7M | ARM_EXT_DIV) & ~(ARM_AEXT_NOTM))
#define ARM_AEXT_V7 (ARM_AEXT_V7A & ARM_AEXT_V7R & ARM_AEXT_V7M)

/* Processors with specific extensions in the co-processor space.  */
#define ARM_ARCH_XSCALE	ARM_FEATURE (ARM_AEXT_V5TE, ARM_CEXT_XSCALE)
#define ARM_ARCH_IWMMXT	\
 ARM_FEATURE (ARM_AEXT_V5TE, ARM_CEXT_XSCALE | ARM_CEXT_IWMMXT)
#define ARM_ARCH_IWMMXT2	\
 ARM_FEATURE (ARM_AEXT_V5TE, ARM_CEXT_XSCALE | ARM_CEXT_IWMMXT | ARM_CEXT_IWMMXT2)

#define FPU_VFP_V1xD	(FPU_VFP_EXT_V1xD | FPU_ENDIAN_PURE)
#define FPU_VFP_V1	(FPU_VFP_V1xD | FPU_VFP_EXT_V1)
#define FPU_VFP_V2	(FPU_VFP_V1 | FPU_VFP_EXT_V2)
#define FPU_VFP_V3	(FPU_VFP_V2 | FPU_VFP_EXT_V3)
#define FPU_VFP_HARD	(FPU_VFP_EXT_V1xD | FPU_VFP_EXT_V1 | FPU_VFP_EXT_V2 \
                         | FPU_VFP_EXT_V3 | FPU_NEON_EXT_V1)
#define FPU_FPA		(FPU_FPA_EXT_V1 | FPU_FPA_EXT_V2)

/* Deprecated */
#define FPU_ARCH_VFP	ARM_FEATURE (0, FPU_ENDIAN_PURE)

#define FPU_ARCH_FPE	ARM_FEATURE (0, FPU_FPA_EXT_V1)
#define FPU_ARCH_FPA	ARM_FEATURE (0, FPU_FPA)

#define FPU_ARCH_VFP_V1xD ARM_FEATURE (0, FPU_VFP_V1xD)
#define FPU_ARCH_VFP_V1	  ARM_FEATURE (0, FPU_VFP_V1)
#define FPU_ARCH_VFP_V2	  ARM_FEATURE (0, FPU_VFP_V2)
#define FPU_ARCH_VFP_V3	  ARM_FEATURE (0, FPU_VFP_V3)
#define FPU_ARCH_NEON_V1  ARM_FEATURE (0, FPU_NEON_EXT_V1)
#define FPU_ARCH_VFP_V3_PLUS_NEON_V1 \
  ARM_FEATURE (0, FPU_VFP_V3 | FPU_NEON_EXT_V1)
#define FPU_ARCH_VFP_HARD ARM_FEATURE (0, FPU_VFP_HARD)

#define FPU_ARCH_ENDIAN_PURE ARM_FEATURE (0, FPU_ENDIAN_PURE)

#define FPU_ARCH_MAVERICK ARM_FEATURE (0, FPU_MAVERICK)

#define ARM_ARCH_V1	ARM_FEATURE (ARM_AEXT_V1, 0)
#define ARM_ARCH_V2	ARM_FEATURE (ARM_AEXT_V2, 0)
#define ARM_ARCH_V2S	ARM_FEATURE (ARM_AEXT_V2S, 0)
#define ARM_ARCH_V3	ARM_FEATURE (ARM_AEXT_V3, 0)
#define ARM_ARCH_V3M	ARM_FEATURE (ARM_AEXT_V3M, 0)
#define ARM_ARCH_V4xM	ARM_FEATURE (ARM_AEXT_V4xM, 0)
#define ARM_ARCH_V4	ARM_FEATURE (ARM_AEXT_V4, 0)
#define ARM_ARCH_V4TxM	ARM_FEATURE (ARM_AEXT_V4TxM, 0)
#define ARM_ARCH_V4T	ARM_FEATURE (ARM_AEXT_V4T, 0)
#define ARM_ARCH_V5xM	ARM_FEATURE (ARM_AEXT_V5xM, 0)
#define ARM_ARCH_V5	ARM_FEATURE (ARM_AEXT_V5, 0)
#define ARM_ARCH_V5TxM	ARM_FEATURE (ARM_AEXT_V5TxM, 0)
#define ARM_ARCH_V5T	ARM_FEATURE (ARM_AEXT_V5T, 0)
#define ARM_ARCH_V5TExP	ARM_FEATURE (ARM_AEXT_V5TExP, 0)
#define ARM_ARCH_V5TE	ARM_FEATURE (ARM_AEXT_V5TE, 0)
#define ARM_ARCH_V5TEJ	ARM_FEATURE (ARM_AEXT_V5TEJ, 0)
#define ARM_ARCH_V6	ARM_FEATURE (ARM_AEXT_V6, 0)
#define ARM_ARCH_V6K	ARM_FEATURE (ARM_AEXT_V6K, 0)
#define ARM_ARCH_V6Z	ARM_FEATURE (ARM_AEXT_V6Z, 0)
#define ARM_ARCH_V6ZK	ARM_FEATURE (ARM_AEXT_V6ZK, 0)
#define ARM_ARCH_V6T2	ARM_FEATURE (ARM_AEXT_V6T2, 0)
#define ARM_ARCH_V6KT2	ARM_FEATURE (ARM_AEXT_V6KT2, 0)
#define ARM_ARCH_V6ZT2	ARM_FEATURE (ARM_AEXT_V6ZT2, 0)
#define ARM_ARCH_V6ZKT2	ARM_FEATURE (ARM_AEXT_V6ZKT2, 0)
#define ARM_ARCH_V7	ARM_FEATURE (ARM_AEXT_V7, 0)
#define ARM_ARCH_V7A	ARM_FEATURE (ARM_AEXT_V7A, 0)
#define ARM_ARCH_V7R	ARM_FEATURE (ARM_AEXT_V7R, 0)
#define ARM_ARCH_V7M	ARM_FEATURE (ARM_AEXT_V7M, 0)

/* Some useful combinations:  */
#define ARM_ARCH_NONE	ARM_FEATURE (0, 0)
#define FPU_NONE	ARM_FEATURE (0, 0)
#define ARM_ANY		ARM_FEATURE (-1, 0)	/* Any basic core.  */
#define FPU_ANY_HARD	ARM_FEATURE (0, FPU_FPA | FPU_VFP_HARD | FPU_MAVERICK)
#define ARM_ARCH_THUMB2 ARM_FEATURE (ARM_EXT_V6T2 | ARM_EXT_V7 | ARM_EXT_V7A | ARM_EXT_V7R | ARM_EXT_V7M | ARM_EXT_DIV, 0)

/* There are too many feature bits to fit in a single word, so use a
   structure.  For simplicity we put all core features in one word and
   everything else in the other.  */
typedef struct
{
  uint32_t core;
  uint32_t coproc;
} arm_feature_set;

#define ARM_CPU_HAS_FEATURE(CPU,FEAT) \
  (((CPU).core & (FEAT).core) != 0 || ((CPU).coproc & (FEAT).coproc) != 0)

#define ARM_MERGE_FEATURE_SETS(TARG,F1,F2)	\
  do {						\
    (TARG).core = (F1).core | (F2).core;	\
    (TARG).coproc = (F1).coproc | (F2).coproc;	\
  } while (0)

#define ARM_CLEAR_FEATURE(TARG,F1,F2)		\
  do {						\
    (TARG).core = (F1).core &~ (F2).core;	\
    (TARG).coproc = (F1).coproc &~ (F2).coproc;	\
  } while (0)

#define ARM_FEATURE(core, coproc) {(core), (coproc)}
                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/standalone/                         0040755 0001750 0001750 00000000000 12612724206 024216  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/standalone/libsa.h                  0100644 0001750 0001750 00000007250 12612724206 025462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* Exported API for standalone library */
#if !(defined(KLD) && defined(__STATIC__))
#import <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#import <mach-o/loader.h>
#import <stdarg.h>
#import <stddef.h>

#ifndef bcopy
#ifdef __OPENSTEP__
extern char *bcopy(char *src, char *dst, int n);
#endif
#endif

extern void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
#ifndef bzero
#ifdef __OPENSTEP__
extern int bzero(char *b, int length);
#endif
#endif
extern void *memset(void *s, int c, size_t n);

/*
 * These are defined internally by GCC
 *
 * extern char *memcpy(void *dst, const void *src, int len);
 * extern size_t strlen(const char *s);
 */

extern int errno;
extern struct segment_command *
  getsegbynamefromheader(struct mach_header *mhp, char *segname);
extern int ptol(char *str);

/* setjmp/longjmp:
 * #include <setjmp.h>
 *
 * extern int setjmp(jmp_buf env);
 * extern void longjmp( jmp_buf env, int val);
 */

extern int slvprintf(char *buffer, int len, const char *fmt, va_list arg);
extern int sprintf(char *s, const char *format, ...);

extern char *strcat(char *s1, const char *s2);
extern int strcmp(const char *s1, const char *s2);
extern char *strcpy(char *s1, const char *s2);
char *strerror(int errnum);
extern int strncmp(const char *s1, const char *s2, size_t n);
extern char *strncpy(char *s1, const char *s2, size_t n);
extern long strtol(
    const char *nptr,
    char **endptr,
    register int base
);
extern unsigned long strtoul(
    const char *nptr,
    char **endptr,
    register int base
);

#if !(defined(KLD) && defined(__STATIC__))
/* Mach */
#ifdef __MACH30__
extern mach_port_t task_self_;
#else
extern port_t task_self_;
#endif
extern kern_return_t vm_allocate(
    mach_port_t target_task,
    vm_address_t *address,
    vm_size_t size,
    boolean_t anywhere
);
extern kern_return_t vm_deallocate(
    mach_port_t target_task,
    vm_address_t address,
    vm_size_t size
);
extern kern_return_t host_info(
    mach_port_t host,
    int flavor,
    host_info_t host_info,
    unsigned int *host_info_count
);
extern vm_size_t vm_page_size;
extern mach_port_t host_self(void);
extern int getpagesize(void);
extern char *mach_error_string(int errnum);

/* Malloc/Zalloc */
extern int malloc_init(char *start, int size, int nodes);
extern char * zalloc(int size);
extern int zfree(char *start);
extern int zinit(char *start, int size, int nodes);
#define ZALLOC_NODES	64	/* default number of nodes */
#endif /* !(defined(KLD) && defined(__STATIC__)) */
extern void *malloc(size_t size);
extern void free(void *start);
extern void *realloc(void *ptr, size_t size);
                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/                              0040755 0001750 0001750 00000000000 12612724206 023215  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/SymLoc.h                      0100644 0001750 0001750 00000003064 12612724206 024574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include "bool.h"

extern const char * symLocForDylib(
    const char *installName,
    const char *releaseName,
    enum bool *found_project,
    enum bool disablewarnings,
    enum bool no_error_if_missing);

extern const char * dstLocForDylib(
    const char *installName,
    const char *releaseName,
    enum bool *found_project,
    enum bool disablewarnings,
    enum bool no_error_if_missing);

const char * LocForDylib(
    const char *installName,
    const char *releaseName,
    const char *dirname,
    enum bool *found_project,
    enum bool disablewarnings,
    enum bool no_error_if_missing);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/allocate.h                    0100644 0001750 0001750 00000002525 12612724206 025153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/* defined in allocate.c */

__private_extern__ void *allocate(
    size_t size);

__private_extern__ void *reallocate(
    void *,
    size_t size);

__private_extern__ char *savestr(
    const char *s);

__private_extern__ char *makestr(
    const char *args, ...);
                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/arch.h                        0100644 0001750 0001750 00000013065 12612724206 024305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _STUFF_ARCH_H_
#define _STUFF_ARCH_H_

#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif
/*
 * This file contains the current known set of flags and constants for the
 * known architectures.
 */
#include <mach/machine.h>
#include <stuff/bytesex.h>

/*
 * The structure describing an architecture flag with the string of the flag
 * name, and the cputype and cpusubtype.
 */
struct arch_flag {
    char *name;
    cpu_type_t cputype;
    cpu_subtype_t cpusubtype;
};

/*
 * get_arch_from_flag() is passed a name of an architecture flag and returns
 * zero if that flag is not known and non-zero if the flag is known.
 * If the pointer to the arch_flag is not NULL it is filled in with the
 * arch_flag struct that matches the name.
 */
__private_extern__ int get_arch_from_flag(
    char *name,
    struct arch_flag *arch_flag);

/*
 * get_arch_from_host() gets the architecture from the host this is running on
 * and returns zero if the architecture is not known and zero if the
 * architecture is known.  If the parameters family_arch_flag and
 * specific_arch_flag are not NULL they get fill in with the family
 * architecture and specific architecure for the host.  If the architecture
 * is unknown and the parameters are not NULL then all fields are set to zero.
 */
__private_extern__ int get_arch_from_host(
    struct arch_flag *family_arch_flag,
    struct arch_flag *specific_arch_flag);

/*
 * get_arch_flags() returns a pointer to an array of all currently know
 * architecture flags (terminated with an entry with all zeros).
 */
__private_extern__ const struct arch_flag *get_arch_flags(
    void);

/*
 * arch_usage() is called when an unknown architecture flag is encountered.
 * It prints the currently know architecture flags on stderr.
 */
__private_extern__ void arch_usage(
    void);

/*
 * set_arch_flag_name() sets the name field of the specified arch_flag to
 * match it's cputype and cpusubtype.  The string is allocated via malloc by
 * the routines in "allocate.h" and errors are handled by the routines in
 * "error.h".
 */
__private_extern__ void set_arch_flag_name(
    struct arch_flag *p);

/*
 * get_arch_name_from_types() returns the name of the architecture for the
 * specified cputype and cpusubtype if known.  If unknown it returns a pointer
 * to the string "unknown".
 */
__private_extern__ const char *get_arch_name_from_types(
    cpu_type_t cputype,
    cpu_subtype_t cpusubtype);

/*
 * get_arch_family_from_cputype() returns the family architecture for the
 * specified cputype if known.  If unknown it returns NULL.
 */
__private_extern__ const struct arch_flag *get_arch_family_from_cputype(
    cpu_type_t cputype);

/*
 * get_byte_sex_from_flag() returns the byte sex of the architecture for the
 * specified cputype and cpusubtype if known.  If unknown it returns
 * UNKNOWN_BYTE_SEX.  If the bytesex can be determined directly as in the case
 * of reading a magic number from a file that should be done and this routine
 * should not be used as it could be out of date.
 */
__private_extern__ enum byte_sex get_byte_sex_from_flag(
    const struct arch_flag *flag);

/*
 * get_stack_direction_from_flag() returns the direction the stack grows as
 * either positive (+1) or negative (-1) of the architecture for the
 * specified cputype and cpusubtype if known.  If unknown it returns 0.
 */
__private_extern__ int get_stack_direction_from_flag(
    const struct arch_flag *flag);

/*
 * get_stack_addr_from_flag() returns the default starting address of the user
 * stack.
 */
__private_extern__ uint64_t get_stack_addr_from_flag(
    const struct arch_flag *flag);

/*
 * get_stack_size_from_flag() returns the default size of the userstack.
 */
__private_extern__ uint32_t get_stack_size_from_flag(
    const struct arch_flag *flag);

/*
 * get_segalign_from_flag() returns the default segment alignment (page size).
 */
__private_extern__ uint32_t get_segalign_from_flag(
    const struct arch_flag *flag);

/*
 * get_segprot_from_flag() returns the default segment protection.
 */
__private_extern__ vm_prot_t get_segprot_from_flag(
    const struct arch_flag *flag);

/*
 * get_shared_region_size_from_flag() returns the size of the read only shared
 * region.
 */
__private_extern__ uint32_t get_shared_region_size_from_flag(
    const struct arch_flag *flag);

/*
 * force_cpusubtype_ALL_for_cputype() takes a cputype and returns TRUE if for
 * that cputype the cpusubtype should always be forced to the ALL cpusubtype,
 * otherwise it returns FALSE.
 */
__private_extern__ enum bool force_cpusubtype_ALL_for_cputype(
    cpu_type_t cputype);
#endif /* _STUFF_ARCH_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/best_arch.h                   0100644 0001750 0001750 00000006403 12612724206 025320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#include <mach/machine.h>
#include <stuff/bool.h>

/*
 * cpusubtype_findbestarch() is passed a cputype and cpusubtype and a set of
 * fat_arch structs and selects the best one that matches (if any) and returns
 * a pointer to that fat_arch struct (or NULL).  The fat_arch structs must be
 * in the host byte sex and correct such that the fat_archs really points to
 * enough memory for nfat_arch structs.  It is possible that this routine could
 * fail if new cputypes or cpusubtypes are added and an old version of this
 * routine is used.  But if there is an exact match between the cputype and
 * cpusubtype and one of the fat_arch structs this routine will always succeed.
 */
__private_extern__ struct fat_arch * cpusubtype_findbestarch(
    cpu_type_t cputype,
    cpu_subtype_t cpusubtype,
    struct fat_arch *fat_archs,
    uint32_t nfat_archs);

/*
 * cpusubtype_combine() returns the resulting cpusubtype when combining two
 * differnet cpusubtypes for the specified cputype.  If the two cpusubtypes
 * can't be combined (the specific subtypes are mutually exclusive) -1 is
 * returned indicating it is an error to combine them.  This can also fail and
 * return -1 if new cputypes or cpusubtypes are added and an old version of
 * this routine is used.  But if the cpusubtypes are the same they can always
 * be combined and this routine will return the cpusubtype pass in.
 */
__private_extern__ cpu_subtype_t cpusubtype_combine(
    cpu_type_t cputype,
    cpu_subtype_t cpusubtype1,
    cpu_subtype_t cpusubtype2);

/*
 * cpusubtype_execute() returns TRUE if the exec_cpusubtype can be used for
 * execution on the host_cpusubtype for the specified cputype.  If the
 * exec_cpusubtype can't be run on the host_cpusubtype FALSE is returned
 * indicating it is an error to combine them.  This can also return FALSE and
 * if new cputypes or cpusubtypes are added and an old version of this routine
 * is used.  But if the cpusubtypes are the same they can always be executed
 * and this routine will return TRUE.
 */
__private_extern__ enum bool cpusubtype_execute(
    cpu_type_t host_cputype,
    cpu_subtype_t host_cpusubtype, /* can NOT be the ALL type */
    cpu_subtype_t exec_cpusubtype);/* can be the ALL type */
                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/bool.h                        0100644 0001750 0001750 00000003475 12612724206 024327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* bool.h */
#ifndef ENUM_DYLD_BOOL
#define ENUM_DYLD_BOOL

#define _STDBOOL_H /* for gcc header */
#define __STDBOOL_H /* for clang header */
#undef bool


#define DYLD_BOOL bool

#undef FALSE
#undef TRUE
enum bool {
    FALSE,
    TRUE
};

#endif /* ENUM_DYLD_BOOL */
                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/breakout.h                    0100644 0001750 0001750 00000027300 12612724206 025201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#import "stuff/ofile.h"

/*
 * This is used to build the table of contents of an archive.  Each toc_entry
 * Contains a pointer to a symbol name that is defined by a member of the
 * archive.  The member that defines this symbol is referenced by its index in
 * the archive plus one.  This is done so the negative value if the index can
 * be used for marking then later to generate the ran_off field with the byte
 * offset.
 */
struct toc_entry {
    char *symbol_name;
    int32_t member_index;
};

/*
 * The input files are broken out in to their object files and then placed in
 * these structures.  These structures are then used to edit the object files'
 * symbol table.  And then finally used to reassemble the object file for
 * output.
 */
struct arch {
    char *file_name;		/* name of file this arch came from */
    enum ofile_type type;	/* The type of file for this architecture */
				/*  can be OFILE_ARCHIVE, OFILE_Mach_O, */
    				/*  OFILE_LLVM_BITCODE or OFILE_UNKNOWN. */
    struct fat_arch *fat_arch;	/* If this came from fat file this is valid */
			        /*  and not NULL (needed for the align value */
				/*  and to output a fat file if only one arch)*/
    char *fat_arch_name;	/* If this came from fat file this is valid */
				/*  and is tthe name of this architecture */
				/*  (used for error messages). */

    /* if this is an archive: the members of this archive */
    struct member *members;	/* the members of the library for this arch */
    uint32_t       nmembers;	/* the number of the above members */
    /*
     * The output table of contents (toc) for this arch in the library (this
     * must be recreated, or at least the time of the toc member set, when
     * the output is modified because modifiy time is shared by all libraries
     * in the file).
     */
    uint32_t       toc_size;	/* total size of the toc including ar_hdr */
    struct ar_hdr  toc_ar_hdr;	/* the archive header for this member */
    enum bool      toc_long_name;/* use the long name in the output */
    char	  *toc_name;	 /* name of toc member */
    uint32_t       toc_name_size;/* size of name of toc member */
    uint32_t       ntocs;	/* number of table of contents entries */
    struct toc_entry
		  *toc_entries; /* the table of contents entries */
    struct ranlib *toc_ranlibs;	/* the ranlib structs */
    char	  *toc_strings;	/* strings of symbol names for toc entries */
    uint32_t       toc_strsize;	/* number of bytes for the strings above */
    uint32_t	  library_size;	/* current working size and final output size */
				/*  for this arch when it's a library (used */
				/*  for creating the toc entries). */

    /* if this is an object file: the object file */
    struct object *object;	/* the object file */

#ifdef LTO_SUPPORT
    /* if this member is an llvm bit code file: the lto module */
    void *lto;                  /* lto module */
#endif /* LTO_SUPPORT */

    /* if this is an unknown file: the addr and size of the file */
    char *unknown_addr;
    uint32_t unknown_size;

    /* don't update LC_ID_DYLIB timestamp */
    enum bool dont_update_LC_ID_DYLIB_timestamp;
};

struct member {
    enum ofile_type type;	/* the type of this member can be OFILE_Mach_O*/
				/*  OFILE_LLVM_BITCODE or OFILE_UNKNOWN */
    struct ar_hdr *ar_hdr;	/* the archive header for this member */
    uint32_t offset;		/* current working offset and final offset */
				/*  use in creating the table of contents */

    /* the name of the member in the output */
    char         *member_name;	    /* the member name */
    uint32_t      member_name_size; /* the size of the member name */
    enum bool     member_long_name; /* use the extended format #1 for the
				       member name in the output */

    /* if this member is an object file: the object file */
    struct object *object;	/* the object file */

#ifdef LTO_SUPPORT
    /* if this member is an llvm bit code file: the lto module */
    void *lto;                  /* lto module */
#endif /* LTO_SUPPORT */

    /* if this member is an unknown file: the addr and size of the member */
    char *unknown_addr;
    uint32_t unknown_size;

    /*
     * If this member was created from a file then input_file_name is set else
     * it is NULL and input_ar_hdr is set (these are recorded to allow
     * warn_member() messages to be printed)
     */
    char *input_file_name;
    struct ar_hdr *input_ar_hdr;
};

struct object {
    char *object_addr;		    /* the address of the object file */
    uint32_t object_size;	    /* the size of the object file on input */
    enum byte_sex object_byte_sex;  /* the byte sex of the object file */
    struct mach_header *mh;	    /* the mach_header of 32-bit object file */
    struct mach_header_64 *mh64;    /* the mach_header of 64-bit object file */
    /* these copied from the mach header above */
    cpu_type_t mh_cputype;	    /* cpu specifier */
    cpu_subtype_t mh_cpusubtype;    /* machine specifier */
    uint32_t mh_filetype;	    /* type of file */
    struct load_command		    /* the start of the load commands */
	*load_commands;
    struct symtab_command *st;	    /* the symbol table command */
    struct dysymtab_command *dyst;  /* the dynamic symbol table command */
    struct twolevel_hints_command   /* the two-level namespace hints command */
	*hints_cmd;
    struct prebind_cksum_command *cs;/* the prebind check sum command */
    struct segment_command
	*seg_bitcode;	    	    /* the 32-bit bitcode segment command */
    struct segment_command_64
	*seg_bitcode64;    	    /* the 64-bit bitcode segment command */
    struct segment_command
	*seg_linkedit;	    	    /* the 32-bit link edit segment command */
    struct segment_command_64
	*seg_linkedit64;    	    /* the 64-bit link edit segment command */
    struct linkedit_data_command
	*code_sig_cmd;	    	    /* the code signature load command, if any*/
    struct linkedit_data_command
	*split_info_cmd;    	    /* the split info load command, if any*/
    struct linkedit_data_command
	*func_starts_info_cmd; 	    /* the func starts load command, if any*/
    struct linkedit_data_command
	*data_in_code_cmd;	    /* the data in code load command, if any */
    struct linkedit_data_command
	*code_sign_drs_cmd;	    /* the code signing DRs command, if any */
    struct linkedit_data_command
	*link_opt_hint_cmd;	    /* the linker optimization hint command,
				       if any */
    struct section **sections;	    /* array of 32-bit section structs */
    struct section_64 **sections64; /* array of 64-bit section structs */
    struct dyld_info_command
	*dyld_info;		    /* the LC_DYLD_INFO command,if any */

    /*
     * This is only used for redo_prebinding and is calculated by breakout()
     * if the calculate_input_prebind_cksum parameter is TRUE and there is an
     * LC_PREBIND_CKSUM load command that has a zero value for the cksum field
     * (if so this will be value of the cksum field on output).
     */
    uint32_t calculated_input_prebind_cksum;

    /*
     * New content to be added to the output file just after where the input
     * sym info was.
     */
    char *output_new_content;
    uint32_t output_new_content_size;

    uint32_t input_sym_info_size;
    uint32_t output_sym_info_size;

    /*
     * For 64-bit Mach-O files they may have an odd number of indirect symbol
     * table entries so the next offset MAYBE or MAY NOT be rounded to a
     * multiple of 8. input_indirectsym_pad contains the amount of padding in
     * that was in the input.
     */
    uint32_t input_indirectsym_pad;

    char *output_dyld_info;
    uint32_t      output_dyld_info_size;
    struct nlist *output_symbols;
    struct nlist_64 *output_symbols64;
    uint32_t      output_nsymbols;
    char	 *output_strings;
    uint32_t      output_strings_size;
    char *output_code_sig_data;
    uint32_t      output_code_sig_data_size;
    char *output_split_info_data;
    uint32_t      output_split_info_data_size;
    char *output_func_start_info_data;
    uint32_t      output_func_start_info_data_size;
    char *output_data_in_code_info_data;
    uint32_t      output_data_in_code_info_data_size;
    char *output_code_sign_drs_info_data;
    uint32_t      output_code_sign_drs_info_data_size;
    char *output_link_opt_hint_info_data;
    uint32_t      output_link_opt_hint_info_data_size;

    uint32_t      output_ilocalsym;
    uint32_t      output_nlocalsym;
    uint32_t      output_iextdefsym;
    uint32_t      output_nextdefsym;
    uint32_t      output_iundefsym;
    uint32_t      output_nundefsym;

    struct twolevel_hint *output_hints;

    struct relocation_info *output_loc_relocs;
    struct relocation_info *output_ext_relocs;
    uint32_t *output_indirect_symtab;

    struct dylib_table_of_contents *output_tocs;
    uint32_t      output_ntoc;
    struct dylib_module *output_mods;
    struct dylib_module_64 *output_mods64;
    uint32_t      output_nmodtab;
    struct dylib_reference *output_refs;
    uint32_t      output_nextrefsyms;

    /*
     * For strip(1) to strip DWARF debug info it must run ld -r on the original
     * object contents and overwrite it with that output.  That output is mapped
     * by this ofile struct and is cleaned up when strip is done with the arch
     * that contains this object.
     */
    struct ofile *ld_r_ofile;
};

__private_extern__ struct ofile * breakout(
    char *filename,
    struct arch **archs,
    uint32_t *narchs,
    enum bool calculate_input_prebind_cksum);

__private_extern__ struct ofile * breakout_mem(
    void *membuf,
    uint32_t length,
    char *filename,
    struct arch **archs,
    uint32_t *narchs,
    enum bool calculate_input_prebind_cksum);

__private_extern__ void free_archs(
    struct arch *archs,
    uint32_t narchs);

__private_extern__ void writeout(
    struct arch *archs,
    uint32_t narchs,
    char *output,
    unsigned short mode,
    enum bool sort_toc,
    enum bool commons_in_toc,
    enum bool library_warnings,
    uint32_t *throttle);

__private_extern__ void writeout_to_mem(
    struct arch *archs,
    uint32_t narchs,
    char *filename,
    void **outputbuf,
    uint32_t *length,
    enum bool sort_toc,
    enum bool commons_in_toc,
    enum bool library_warning,
    enum bool *seen_archive);

__private_extern__ void checkout(
    struct arch *archs,
    uint32_t narchs);

void warning_arch(
    struct arch *arch,
    struct member *member,
    char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 3, 4)))
#endif
    ;

void error_arch(
    struct arch *arch,
    struct member *member,
    char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 3, 4)))
#endif
    ;

void fatal_arch(
    struct arch *arch,
    struct member *member,
    char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 3, 4)))
#endif
    ;
                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/bytesex.h                     0100644 0001750 0001750 00000034416 12612724206 025056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* bytesex.h */
#ifndef _STUFF_BYTESEX_H_
#define _STUFF_BYTESEX_H_

#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach/m68k/thread_status.h>
#undef MACHINE_THREAD_STATE	/* need to undef these to avoid warnings */
#undef MACHINE_THREAD_STATE_COUNT
#undef THREAD_STATE_NONE
#undef VALID_THREAD_STATE_FLAVOR
#include <mach/ppc/thread_status.h>
#undef MACHINE_THREAD_STATE	/* need to undef these to avoid warnings */
#undef MACHINE_THREAD_STATE_COUNT
#undef THREAD_STATE_NONE
#undef VALID_THREAD_STATE_FLAVOR
#include <mach/m88k/thread_status.h>
#include <mach/i860/thread_status.h>
#include <mach/i386/thread_status.h>
#include <mach/hppa/thread_status.h>
#include <mach/sparc/thread_status.h>
/* cctools-port: need to undef these to avoid warnings */
#undef MACHINE_THREAD_STATE
#undef MACHINE_THREAD_STATE_COUNT
#undef THREAD_STATE_NONE
#undef VALID_THREAD_STATE_FLAVOR
#include <mach/arm/thread_status.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/ranlib.h>
#include "../include/xar/xar.h" /* cctools-port:
				   force the use of the bundled xar header */
#include "stuff/bool.h"

enum byte_sex {
    UNKNOWN_BYTE_SEX,
    BIG_ENDIAN_BYTE_SEX,
    LITTLE_ENDIAN_BYTE_SEX
};

#define SWAP_SHORT(a) ( ((a & 0xff) << 8) | ((unsigned short)(a) >> 8) )

#define SWAP_INT(a)  ( ((a) << 24) | \
		      (((a) << 8) & 0x00ff0000) | \
		      (((a) >> 8) & 0x0000ff00) | \
	 ((unsigned int)(a) >> 24) )

#ifndef __LP64__
#define SWAP_LONG(a) ( ((a) << 24) | \
		      (((a) << 8) & 0x00ff0000) | \
		      (((a) >> 8) & 0x0000ff00) | \
	((unsigned long)(a) >> 24) )
#endif

__private_extern__ long long SWAP_LONG_LONG(
    long long ll);

__private_extern__ float SWAP_FLOAT(
    float f);

__private_extern__ double SWAP_DOUBLE(
    double d);

__private_extern__ enum byte_sex get_host_byte_sex(
    void);

__private_extern__ void swap_fat_header(
    struct fat_header *fat_header,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_fat_arch(
    struct fat_arch *fat_archs,
    uint32_t nfat_arch,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_mach_header(
    struct mach_header *mh,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_mach_header_64(
    struct mach_header_64 *mh,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_load_command(
    struct load_command *lc,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_segment_command(
    struct segment_command *sg,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_segment_command_64(
    struct segment_command_64 *sg,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_section(
    struct section *s,
    uint32_t nsects,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_section_64(
    struct section_64 *s,
    uint32_t nsects,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_symtab_command(
    struct symtab_command *st,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dysymtab_command(
    struct dysymtab_command *dyst,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_symseg_command(
    struct symseg_command *ss,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_fvmlib_command(
    struct fvmlib_command *fl,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dylib_command(
    struct dylib_command *dl,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_sub_framework_command(
    struct sub_framework_command *sub,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_sub_umbrella_command(
    struct sub_umbrella_command *usub,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_sub_library_command(
    struct sub_library_command *lsub,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_sub_client_command(
    struct sub_client_command *csub,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_prebound_dylib_command(
    struct prebound_dylib_command *pbdylib,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dylinker_command(
    struct dylinker_command *dyld,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_fvmfile_command(
    struct fvmfile_command *ff,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_thread_command(
    struct thread_command *ut,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m68k_thread_state_regs(
    struct m68k_thread_state_regs *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m68k_thread_state_68882(
    struct m68k_thread_state_68882 *fpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m68k_thread_state_user_reg(
    struct m68k_thread_state_user_reg *user_reg,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ppc_thread_state_t(
    ppc_thread_state_t *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ppc_thread_state64_t(
    ppc_thread_state64_t *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ppc_float_state_t(
    ppc_float_state_t *fpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ppc_exception_state_t(
    ppc_exception_state_t *state,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m88k_thread_state_grf_t(
    m88k_thread_state_grf_t *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m88k_thread_state_xrf_t(
    m88k_thread_state_xrf_t *fpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m88k_thread_state_user_t(
    m88k_thread_state_user_t *user,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_m88110_thread_state_impl_t(
    m88110_thread_state_impl_t *spu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_i860_thread_state_regs(
    struct i860_thread_state_regs *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_i386_thread_state(
    i386_thread_state_t *cpu,
    enum byte_sex target_byte_sex);

/* current i386 thread states */
#if i386_THREAD_STATE == 1
__private_extern__ void swap_i386_float_state(
    struct __darwin_i386_float_state *fpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_i386_exception_state(
    i386_exception_state_t *exc,
    enum byte_sex target_byte_sex);
#endif /* i386_THREAD_STATE == 1 */

/* i386 thread states on older releases */
#if i386_THREAD_STATE == -1
__private_extern__ void swap_i386_thread_fpstate(
    i386_thread_fpstate_t *fpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_i386_thread_exceptstate(
    i386_thread_exceptstate_t *exc,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_i386_thread_cthreadstate(
    i386_thread_cthreadstate_t *user,
    enum byte_sex target_byte_sex);
#endif /* i386_THREAD_STATE == -1 */

#ifdef x86_THREAD_STATE64
__private_extern__ void swap_x86_thread_state64(
    x86_thread_state64_t *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_x86_float_state64(
    x86_float_state64_t *fpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_x86_state_hdr(
    struct x86_state_hdr *hdr,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_x86_exception_state64(
    x86_exception_state64_t *exc,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_x86_debug_state32(
    x86_debug_state32_t *debug,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_x86_debug_state64(
    x86_debug_state64_t *debug,
    enum byte_sex target_byte_sex);
#endif /* x86_THREAD_STATE64 */

__private_extern__ void swap_hppa_integer_thread_state(
    struct hp_pa_integer_thread_state *regs,
    enum byte_sex target_byte_order);

__private_extern__ void swap_hppa_frame_thread_state(
  struct hp_pa_frame_thread_state *frame,
  enum byte_sex target_byte_order);

__private_extern__ void swap_hppa_fp_thread_state(
  struct hp_pa_fp_thread_state *fp,
  enum byte_sex target_byte_order);

__private_extern__ void swap_sparc_thread_state_regs(
  struct sparc_thread_state_regs *cpu,
  enum byte_sex target_byte_order);

__private_extern__ void swap_sparc_thread_state_fpu(
  struct sparc_thread_state_fpu *fpu,
  enum byte_sex target_byte_order);

__private_extern__ void swap_arm_thread_state_t(
    arm_thread_state_t *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_arm_thread_state64_t(
    arm_thread_state64_t *cpu,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ident_command(
    struct ident_command *id_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_routines_command(
    struct routines_command *r_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_routines_command_64(
    struct routines_command_64 *r_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_twolevel_hints_command(
    struct twolevel_hints_command *hints_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_prebind_cksum_command(
    struct prebind_cksum_command *cksum_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_uuid_command(
    struct uuid_command *uuid_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_linkedit_data_command(
    struct linkedit_data_command *ld,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_version_min_command(
    struct version_min_command *ver_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_rpath_command(
    struct rpath_command *rpath_cmd,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_encryption_command(
    struct encryption_info_command *ec,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_encryption_command_64(
    struct encryption_info_command_64 *ec,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_linker_option_command(
    struct linker_option_command *lo,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dyld_info_command(
    struct dyld_info_command *dc, 
    enum byte_sex target_byte_sex);

__private_extern__ void swap_entry_point_command(
    struct entry_point_command *ep,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_source_version_command(
    struct source_version_command *sv,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_nlist(
    struct nlist *symbols,
    uint32_t nsymbols,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_nlist_64(
    struct nlist_64 *symbols,
    uint32_t nsymbols,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ranlib(
    struct ranlib *ranlibs,
    uint32_t nranlibs,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_relocation_info(
    struct relocation_info *relocs,
    uint32_t nrelocs,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_indirect_symbols(
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dylib_reference(
    struct dylib_reference *refs,
    uint32_t nrefs,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dylib_module(
    struct dylib_module *mods,
    uint32_t nmods,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dylib_module_64(
    struct dylib_module_64 *mods,
    uint32_t nmods,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_dylib_table_of_contents(
    struct dylib_table_of_contents *tocs,
    uint32_t ntocs,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_twolevel_hint(
    struct twolevel_hint *hints,
    uint32_t nhints,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_data_in_code_entry(
    struct data_in_code_entry *dices,
    uint32_t ndices,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_xar_header(
    struct xar_header *xar,
    enum byte_sex target_byte_sex);

/*
 * swap_object_headers() swaps the object file headers from the host byte sex
 * into the non-host byte sex.  It returns TRUE if it can and did swap the
 * headers else returns FALSE and does not touch the headers and prints an error
 * using the error() routine.
 */
__private_extern__ enum bool swap_object_headers(
    void *mach_header, /* either a mach_header or a mach_header_64 */
    struct load_command *load_commands);

/*
 * get_toc_byte_sex() guesses the byte sex of the table of contents of the
 * library mapped in at the address, addr, of size, size based on the first
 * object file's bytesex.  If it can't figure it out, because the library has
 * no object file members or is malformed it will return UNKNOWN_BYTE_SEX.
 */
__private_extern__ enum byte_sex get_toc_byte_sex(
    char *addr,
    uint32_t size);

#endif /* _STUFF_BYTESEX_H_ */
                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/crc32.h                       0100644 0001750 0001750 00000002036 12612724206 024300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
__private_extern__ uint32_t crc32(
    const void *buf,
    uint32_t len);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/dylib_roots.h                 0100644 0001750 0001750 00000002622 12612724206 025716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
extern char * get_symfile_for_dylib(
    char *install_name,
    char *release_name,
    enum bool *found_project,
    enum bool disablewarnings,
    enum bool no_error_if_missing);

extern char * get_dstfile_for_dylib(
    char *install_name,
    char *release_name,
    enum bool *found_project,
    enum bool disablewarnings,
    enum bool no_error_if_missing);

extern char * find_dylib_in_root(
    char *install_name,
    const char *root);
                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/dylib_table.h                 0100644 0001750 0001750 00000003040 12612724206 025632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * The table of known dynamic library names and addresses they are linked at.
 * This is loaded from a -dylib_table option or from the default file:
 * ~rc/Data/DylibTable .
 */
struct dylib_table {
    uint32_t seg1addr;
    char *name;
};

extern struct dylib_table * parse_dylib_table(
    char *file_name,
    char *flag,
    char *argument);

extern struct dylib_table * parse_default_dylib_table(
    char **file_name);

extern struct dylib_table *search_dylib_table(
    struct dylib_table *dylib_table,
    char *name);

extern char * guess_dylib_install_name(
    char *name);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/errors.h                      0100644 0001750 0001750 00000006165 12612724206 024707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#import "mach/mach.h"

/* user defined (imported) */
extern char *progname __attribute__((visibility("hidden")));

/* defined in errors.c */
/* number of detected calls to error() */
extern uint32_t errors __attribute__((visibility("hidden")));

extern void warning(
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 1, 2)))
#endif
    __attribute__((visibility("hidden")));
extern void error(
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 1, 2)))
#endif
    __attribute__((visibility("hidden")));
extern void error_with_arch(
    const char *arch_name,
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 2, 3)))
#endif
    __attribute__((visibility("hidden")));
extern void system_error(
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 1, 2)))
#endif
    __attribute__((visibility("hidden")));
extern void fatal(
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 1, 2)))
#endif
    __attribute__((visibility("hidden")));
extern void system_fatal(
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 1, 2)))
#endif
    __attribute__((visibility("hidden")));
extern void my_mach_error(
    kern_return_t r,
    char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 2, 3)))
#endif
    __attribute__((visibility("hidden")));
extern void mach_fatal(
    kern_return_t r,
    char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 2, 3)))
#endif
    __attribute__((visibility("hidden")));
                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/execute.h                     0100644 0001750 0001750 00000003213 12612724206 025024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * execute() does an execvp using the argv passed to it.  If the parameter
 * verbose is non-zero the command is printed to stderr.  A non-zero return
 * value indicates success zero indicates failure.
 */
__private_extern__ int execute(
    char **argv,
    int verbose);

__private_extern__ void add_execute_list(
    char *str);

__private_extern__ void add_execute_list_with_prefix(
    char *str);

__private_extern__ char * cmd_with_prefix(
    char *str);

__private_extern__ void reset_execute_list(
    void);

__private_extern__ int execute_list(
    int verbose);
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/guess_short_name.h            0100644 0001750 0001750 00000002140 12612724206 026725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include "stuff/bool.h"

__private_extern__ char * guess_short_name(
    char *name,
    enum bool *is_framework,
    char **return_suffix);
                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/hash_string.h                 0100644 0001750 0001750 00000002201 12612724206 025667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

__private_extern__ int32_t hash_string(
    char *key);
                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/hppa.h                        0100644 0001750 0001750 00000004147 12612724206 024321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

__private_extern__ void calc_hppa_HILO(
    uint32_t base,
    uint32_t offset,
    uint32_t *left21,
    uint32_t *right14);

__private_extern__ uint32_t assemble_17(
    uint32_t x,
    uint32_t y,
    uint32_t z);

__private_extern__ uint32_t assemble_21(
    uint32_t x);

__private_extern__ uint32_t assemble_12(
    uint32_t x,
    uint32_t y);

__private_extern__ uint32_t assemble_3(
    uint32_t x);

__private_extern__ uint32_t sign_ext(
    uint32_t x,
    uint32_t len);

__private_extern__ uint32_t low_sign_ext(
    uint32_t x,
    uint32_t len);

__private_extern__ uint32_t dis_assemble_21(
    uint32_t as21);

__private_extern__ uint32_t low_sign_unext(
    uint32_t x,
    uint32_t len);

__private_extern__ void dis_assemble_17(
    uint32_t as17,
    uint32_t *x,
    uint32_t *y,
    uint32_t *z);

__private_extern__ uint32_t sign_unext(
    uint32_t x,
    uint32_t len);

__private_extern__ uint32_t dis_assemble_3(
    uint32_t x);

__private_extern__ void dis_assemble_12(
    uint32_t as12,
    uint32_t *x,
    uint32_t *y);
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/llvm.h                        0100644 0001750 0001750 00000001403 12612724206 024333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _STUFF_LLVM_H_
#define _STUFF_LLVM_H_

#include "llvm-c/Disassembler.h"

__private_extern__ LLVMDisasmContextRef llvm_create_disasm(
    const char *TripleName,
    const char *CPU,
    void *DisInfo,
    int TagType,
    LLVMOpInfoCallback GetOpInfo,
    LLVMSymbolLookupCallback SymbolLookUp);

__private_extern__ void llvm_disasm_dispose(
    LLVMDisasmContextRef DC);

__private_extern__ size_t llvm_disasm_instruction(
    LLVMDisasmContextRef DC,
    uint8_t *Bytes,
    uint64_t BytesSize,
    uint64_t Pc,
    char *OutString,
    size_t OutStringSize);

__private_extern__ int llvm_disasm_set_options(
    LLVMDisasmContextRef DC,
    uint64_t Options);

__private_extern__ const char *llvm_disasm_version_string(
    void);

#endif /* _STUFF_LLVM_H_ */
                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/lto.h                         0100644 0001750 0001750 00000001312 12612724206 024156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _STUFF_LTO_H_
#define _STUFF_LTO_H_

#include "stuff/arch.h"

#ifdef LTO_SUPPORT

__private_extern__ int is_llvm_bitcode_from_memory(
    char *addr,
    uint32_t size,
    struct arch_flag *arch_flag,
    void **mod); /* maybe NULL */

__private_extern__ uint32_t lto_get_nsyms(
    void *mod);

__private_extern__ int lto_toc_symbol(
    void *mod,
    uint32_t symbol_index,
    int commons_in_toc);

__private_extern__ void lto_get_nlist_64(
    struct nlist_64 *nl,
    void *mod,
    uint32_t symbol_index);

__private_extern__ char * lto_symbol_name(
    void *mod,
    uint32_t symbol_index);

__private_extern__ void lto_free(
    void *mod);

#endif /* LTO_SUPPORT */

#endif /* _STUFF_LTO_H_ */
                                                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/macosx_deployment_target.h    0100644 0001750 0001750 00000002511 12612724206 030462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <mach/mach.h>

struct macosx_deployment_target {
    uint32_t major;	/* major version */
    uint32_t minor;	/* minor version (if any or zero) */
    char *name;			/* name for printing */
};

__private_extern__ void get_macosx_deployment_target(
    struct macosx_deployment_target *value);

__private_extern__ void put_macosx_deployment_target(
    char *target);
                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/ofile.h                       0100644 0001750 0001750 00000021205 12612724206 024461  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* ofile.h */
#ifndef _STUFF_OFILE_H_
#define _STUFF_OFILE_H_

#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#import <ar.h>
#ifndef AR_EFMT1
#define	AR_EFMT1	"#1/"		/* extended format #1 */
#endif
#import <mach-o/loader.h>
#ifdef OFI
#import <mach-o/dyld.h>
#endif
#import "stuff/bytesex.h"
#import "stuff/bool.h"
#import "stuff/arch.h"

enum ofile_type {
    OFILE_UNKNOWN,
    OFILE_FAT,
    OFILE_ARCHIVE,
    OFILE_Mach_O
#ifdef LTO_SUPPORT
    ,
    OFILE_LLVM_BITCODE
#endif /* LTO_SUPPORT */
};

/*
 * The structure used by ofile_*() routines for object files.
 */
struct ofile {
    char *file_name;		    /* pointer to name malloc'ed by ofile_map */
    char *file_addr;		    /* pointer to vm_allocate'ed memory       */
    uint64_t file_size;	    	    /* size of vm_allocate'ed memory	      */
    uint64_t file_mtime;	    /* stat(2)'s mtime                        */
    enum ofile_type file_type;	    /* type of the file			      */

    struct fat_header *fat_header;  /* If a fat file these are filled in and */
    struct fat_arch *fat_archs;     /*  if needed converted to host byte sex */

    /* If this is a fat file then these are valid and filled in */
    uint32_t narch;	    	    /* the current architecture */
    enum ofile_type arch_type;	    /* the type of file for this arch. */
    struct arch_flag arch_flag;     /* the arch_flag for this arch, the name */
				    /*  field is pointing at space malloc'ed */
				    /*  by ofile_map. */

    /* If this structure is currently referencing a thin archive and it has a
       table of contents then these are valid and filled in */
    char *toc_addr;		    /* pointer to the toc contents */
    uint32_t toc_size;		    /* total size of the toc */
    struct ar_hdr *toc_ar_hdr;	    /* the archive header for the toc */
    char *toc_name;		    /* name of toc member */
    uint32_t toc_name_size;	    /* size of name of toc member */
    struct ranlib *toc_ranlibs;     /* ranlib structs */
    uint32_t       toc_nranlibs;    /* number of ranlib structs */
    char          *toc_strings;     /* strings of symbol names (for above) */
    uint32_t       toc_strsize;     /* number of bytes for the strings above */
    enum bool	   toc_bad;	    /* the toc needs to be rebuilt */

    /* If this structure is currently referencing an archive member or an object
       file that is an archive member these are valid and filled in. */
    uint32_t member_offset;         /* logical offset to the member starting */
    char *member_addr;      	    /* pointer to the member contents */
    uint32_t member_size;           /* actual size of the member (not rounded)*/
    struct ar_hdr *member_ar_hdr;   /* pointer to the ar_hdr for this member */
    char *member_name;		    /* name of this member */
    uint32_t member_name_size;      /* size of the member name */
    enum ofile_type member_type;    /* the type of file for this member */
    cpu_type_t archive_cputype;	    /* if the archive contains objects then */
    cpu_subtype_t		    /*  these two fields reflect the objects */
	archive_cpusubtype;	    /*  at are in the archive. */

    /* If this structure is currently referencing a dynamic library module 
       these are valid and filled in. */
    struct dylib_module *modtab;    /* the 32-bit module table */
    struct dylib_module_64 *modtab64;/* the 64-bit module table */
    uint32_t nmodtab;	    	    /* the number of module table entries */
    struct dylib_module		    /* pointer to the 32-bit dylib_module for */
	*dylib_module;		    /*  this module. */
    struct dylib_module_64	    /* pointer to the 64-bit dylib_module for */
	*dylib_module64;	    /*  this module. */
    char *dylib_module_name;	    /* the name of the module */

    /* If this structure is currently referencing an object file these are
       valid and filled in.  The mach_header and load commands have been 
       converted to the host byte sex if needed */
    enum bool headers_swapped;	    /* true if the headers have already been
				       swapped to host byte sex */
    char *object_addr;		    /* the address of the object file */
    uint32_t object_size;	    /* the size of the object file */
    enum byte_sex object_byte_sex;  /* the byte sex of the object file */
    struct mach_header *mh;	    /* the mach_header of 32-bit object file */
    struct mach_header_64 *mh64;    /* the mach_header of 64-bit object file */
    struct load_command		    /* the start of the load commands */
	*load_commands;
    /* these copied from the mach header above */
    cpu_type_t mh_cputype;	    /* cpu specifier */
    cpu_subtype_t mh_cpusubtype;    /* machine specifier */
    uint32_t mh_filetype;	    /* type of file */

    /* If this structure is currently referencing an llvm bitcode file these are
       valid and filled in. */
    void *lto;			    /* really the opaque struct LTOModule * */
    /* these are translated from the lto's target_triple */
    cpu_type_t lto_cputype;	    /* cpu specifier */
    cpu_subtype_t lto_cpusubtype;   /* machine specifier */
};

__private_extern__ void ofile_process(
    char *name,
    struct arch_flag *arch_flags,
    uint32_t narch_flags,
    enum bool all_archs,
    enum bool process_non_objects,
    enum bool dylib_flat,
    enum bool use_member_syntax,
    void (*processor)(struct ofile *ofile, char *arch_name, void *cookie),
    void *cookie);
#ifdef OFI
__private_extern__ NSObjectFileImageReturnCode ofile_map(
#else
__private_extern__ enum bool ofile_map(
#endif
    const char *file_name,
    const struct arch_flag *arch_flag,	/* can be NULL */
    const char *object_name,		/* can be NULL */
    struct ofile *ofile,
    enum bool archives_with_fat_objects);
#ifdef OFI
__private_extern__ NSObjectFileImageReturnCode ofile_map_from_memory(
#else
__private_extern__ enum bool ofile_map_from_memory(
#endif
    char *addr,
    uint64_t size,
    const char *file_name,
    uint64_t mtime,
    const struct arch_flag *arch_flag,	/* can be NULL */
    const char *object_name,		/* can be NULL */
    struct ofile *ofile,
    enum bool archives_with_fat_objects);
__private_extern__ void ofile_unmap(
    struct ofile *ofile);
__private_extern__ enum bool ofile_first_arch(
    struct ofile *ofile);
__private_extern__ enum bool ofile_next_arch(
    struct ofile *ofile);
__private_extern__ enum bool ofile_first_member(
    struct ofile *ofile);
__private_extern__ enum bool ofile_next_member(
    struct ofile *ofile);
__private_extern__ enum bool ofile_specific_member(
    const char *object_name,
    struct ofile *ofile);
__private_extern__ enum bool ofile_first_module(
    struct ofile *ofile);
__private_extern__ enum bool ofile_next_module(
    struct ofile *ofile);
__private_extern__ enum bool ofile_specific_module(
    const char *module_name,
    struct ofile *ofile);
__private_extern__ void ofile_print(
    struct ofile *ofile);
__private_extern__ uint32_t size_ar_name(
    const struct ar_hdr *ar_hdr);
__private_extern__ int32_t ofile_get_word(
    uint64_t addr,
    uint32_t *word,
    void *get_word_data /* struct ofile *ofile */);
__private_extern__ void archive_error(
    struct ofile *ofile,
    const char *format, ...)
#ifndef __MWERKS__
    __attribute__ ((format (printf, 2, 3)))
#endif
    ;
__private_extern__ void archive_member_error(
    struct ofile *ofile,
    const char *format, ...)
#ifndef __MWERKS__
    __attribute__ ((format (printf, 2, 3)))
#endif
    ;
__private_extern__ void Mach_O_error(
    struct ofile *ofile,
    const char *format, ...)
#ifndef __MWERKS__
    __attribute__ ((format (printf, 2, 3)))
#endif
    ;

#ifdef LTO_SUPPORT
__private_extern__ int is_llvm_bitcode(
    struct ofile *ofile,
    char *addr,
    size_t size);
#endif /* LTO_SUPPORT */

#endif /* _STUFF_OFILE_H_ */
                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/openstep_mach.h               0100644 0001750 0001750 00000004044 12612724206 026212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifdef __OPENSTEP__
/*
 * This file is used to allow cctools to be compiled for Openstep now that
 * the code has been changed to use Mach 3.0 names (which work for MacOS X and
 * Rhapsody but not for Openstep).
 */
#define mach_task_self task_self
#define mach_task_self_ task_self_
#define mach_host_self host_self
#define mach_thread_self thread_self
#define mach_port_allocate port_allocate
#define mach_port_deallocate port_deallocate
#define mach_port_names port_names
#endif /* __OPENSTEP__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/print.h                       0100644 0001750 0001750 00000002447 12612724206 024526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#import <stdarg.h>

__private_extern__ void print(
    const char *format, ...)
#ifdef __GNUC__
    __attribute__ ((format (printf, 1, 2)))
#endif
    ;
__private_extern__ void vprint(
    const char *format, va_list ap);
                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/reloc.h                       0100644 0001750 0001750 00000002573 12612724206 024476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#import <mach/machine.h>
#import "stuff/bool.h"

__private_extern__ uint32_t reloc_pair_r_type(
    cpu_type_t cputype);
__private_extern__ enum bool reloc_has_pair(
    cpu_type_t cputype,
    uint32_t r_type);
__private_extern__ enum bool reloc_is_sectdiff(
    cpu_type_t cputype,
    uint32_t r_type);
                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/rnd.h                         0100644 0001750 0001750 00000003451 12612724206 024151  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <stdint.h>

#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * rnd() rounds v to a multiple of r.
 */
__private_extern__ uint64_t rnd(
    uint64_t v,
    uint64_t r);
                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/seg_addr_table.h              0100644 0001750 0001750 00000004613 12612724206 026306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include "stuff/bool.h"

/*
 * These are the tokens for the "install name" for the next addresses to use
 * when updating the table.  And also the token for fixed regions.
 */
#define NEXT_FLAT_ADDRESS_TO_ASSIGN  "<<< Next flat address to assign >>>"
#define NEXT_SPLIT_ADDRESS_TO_ASSIGN "<<< Next split address to assign >>>"
#define NEXT_DEBUG_ADDRESS_TO_ASSIGN "<<< Next debug address to assign >>>"
#define FIXED_ADDRESS_AND_SIZE "<<< Fixed address and size not to assign >>>"

/*
 * The table of dynamic library install names and their addresses they are
 * linked at.  This is used with the -seg_addr_table option from the static
 * link editor, ld(1), and the seg_addr_table(1) program.
 */
struct seg_addr_table {
    char *install_name;
    enum bool split;
    uint32_t seg1addr;
    uint32_t segs_read_only_addr;
    uint32_t segs_read_write_addr;
    uint32_t line;
};

extern struct seg_addr_table *parse_default_seg_addr_table(
    char **seg_addr_table_name,
    uint32_t *table_size);

extern struct seg_addr_table * parse_seg_addr_table(
    char *file_name,
    char *flag,
    char *argument,
    uint32_t *table_size);

extern struct seg_addr_table * search_seg_addr_table(
    struct seg_addr_table *seg_addr_table,
    char *install_name);

extern void process_seg_addr_table(
    char *file_name,
    FILE *out_fp,
    char *comment_prefix,
    void (*processor)(struct seg_addr_table *entry, FILE *out_fp, void *cookie),
    void *cookie);
                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/symbol.h                      0100644 0001750 0001750 00000000307 12612724206 024670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _STUFF_SYMBOL_H_
#define _STUFF_SYMBOL_H_

#include <stdint.h>

struct symbol {
    char *name;
    char *indr_name;
    uint64_t n_value;
    int is_thumb;
};

#endif /* _STUFF_SYMBOL_H_ */
                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/symbol_list.h                 0100644 0001750 0001750 00000003004 12612724206 025720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <mach-o/nlist.h>
#include <stuff/bool.h>

/*
 * Data structures to perform selective stripping of symbol table entries.
 */
struct symbol_list {
    char *name;		/* name of the global symbol */
    void  *sym;		/* pointer to the nlist structure for this symbol */
    enum bool seen;	/* set if the symbol is seen in the input file */
};

__private_extern__ void setup_symbol_list(
    char *file,
    struct symbol_list **list,
    uint32_t *size);

__private_extern__ int symbol_list_bsearch(
    const char *name,
    const struct symbol_list *sym);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/unix_standard_mode.h          0100644 0001750 0001750 00000002054 12612724206 027233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include "stuff/bool.h"

__private_extern__ enum bool get_unix_standard_mode(
    void);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/version_number.h              0100644 0001750 0001750 00000002076 12612724206 026425  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
__private_extern__ enum bool get_version_number(
    char *flag,
    char *argument,
    uint32_t *value);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/stuff/vm_flush_cache.h              0100644 0001750 0001750 00000002334 12612724206 026333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#import <mach/mach.h>
__private_extern__ kern_return_t vm_flush_cache(
    mach_port_t target_task,
    vm_address_t address,
    vm_size_t size);
                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/sys/                                0040755 0001750 0001750 00000000000 12612724206 022704  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/sys/cdefs.h                         0100644 0001750 0001750 00000000627 12612724206 024143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Workaround for a GLIBC bug.
 * https://sourceware.org/bugzilla/show_bug.cgi?id=14952
 */

#include_next <sys/cdefs.h>

#ifdef __GLIBC__

#ifndef __extern_inline
# define __extern_inline \
  extern __inline __attribute__ ((__gnu_inline__))
#endif

#ifndef __extern_always_inline
# define __extern_always_inline \
  extern __always_inline __attribute__ ((__gnu_inline__))
#endif

#endif /* __GLIBC__ */
                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/sys/gmon.h                          0100644 0001750 0001750 00000017216 12612724206 024021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*-
 * Copyright (c) 1982, 1986, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * The NEXTSTEP Software License Agreement specifies the terms
 * and conditions for redistribution.
 *
 *	@(#)gmon.h	8.2 (Berkeley) 1/4/94
 */

#ifndef _SYS_GMON_H_
#define _SYS_GMON_H_
#include <stdint.h>

/*
 * Structure prepended to gmon.out profiling data file.
 */
struct gmonhdr {
	uint32_t lpc;		/* base pc address of sample buffer */
	uint32_t hpc;		/* max pc address of sampled buffer */
	uint32_t ncnt;		/* size of sample buffer (plus this header) */
	int32_t version;	/* version number */
	int32_t profrate;	/* profiling clock rate */
	int32_t spare[3];	/* reserved */
};
#define GMONVERSION	0x00051879

struct gmonhdr_64 {
	uint64_t lpc;		/* base pc address of sample buffer */
	uint64_t hpc;		/* max pc address of sampled buffer */
	uint32_t ncnt;		/* size of sample buffer (plus this header) */
	int32_t version;	/* version number */
	int32_t profrate;	/* profiling clock rate */
	int32_t spare[3];	/* reserved */
};

typedef struct
#ifndef __LP64__
        gmonhdr
#else
        gmonhdr_64
#endif
gmonhdr_t;

/*
 * histogram counters are unsigned shorts (according to the kernel).
 */
#define	HISTCOUNTER	unsigned short

/*
 * fraction of text space to allocate for histogram counters here, 1/2
 */
#define	HISTFRACTION	2

/*
 * Fraction of text space to allocate for from hash buckets.
 * The value of HASHFRACTION is based on the minimum number of bytes
 * of separation between two subroutine call points in the object code.
 * Given MIN_SUBR_SEPARATION bytes of separation the value of
 * HASHFRACTION is calculated as:
 *
 *	HASHFRACTION = MIN_SUBR_SEPARATION / (2 * sizeof(short) - 1);
 *
 * For example, on the VAX, the shortest two call sequence is:
 *
 *	calls	$0,(r0)
 *	calls	$0,(r0)
 *
 * which is separated by only three bytes, thus HASHFRACTION is 
 * calculated as:
 *
 *	HASHFRACTION = 3 / (2 * 2 - 1) = 1
 *
 * Note that the division above rounds down, thus if MIN_SUBR_FRACTION
 * is less than three, this algorithm will not work!
 *
 * In practice, however, call instructions are rarely at a minimal 
 * distance.  Hence, we will define HASHFRACTION to be 2 across all
 * architectures.  This saves a reasonable amount of space for 
 * profiling data structures without (in practice) sacrificing
 * any granularity.
 */
#define	HASHFRACTION	2

/*
 * percent of text space to allocate for tostructs with a minimum.
 */
#define ARCDENSITY	2
#define MINARCS		50
#define MAXARCS		((1 << (8 * sizeof(HISTCOUNTER))) - 2)

struct tostruct {
	uint32_t	selfpc;
	int32_t		count;
	uint16_t	link;
	uint16_t	order;
};

struct tostruct_64 {
	uint64_t	selfpc;
	int32_t		count;
	uint16_t	link;
	uint16_t	order;
};

typedef struct
#ifndef __LP64__
        tostruct
#else
        tostruct_64
#endif
tostruct_t;

/*
 * a raw arc, with pointers to the calling site and 
 * the called site and a count.
 */
struct rawarc {
	uint32_t	raw_frompc;
	uint32_t	raw_selfpc;
	int32_t		raw_count;
};

struct rawarc_64 {
	uint64_t	raw_frompc;
	uint64_t	raw_selfpc;
	int32_t		raw_count;
};

typedef struct
#ifndef __LP64__
        rawarc
#else
        rawarc_64
#endif
rawarc_t;

/*
 * general rounding functions.
 */
#define ROUNDDOWN(x,y)	(((x)/(y))*(y))
#define ROUNDUP(x,y)	((((x)+(y)-1)/(y))*(y))

/*
 * The profiling data structures are housed in this structure.
 */
struct gmonparam {
	int		state;
	u_short		*kcount;
	u_long		kcountsize;
	u_short		*froms;
	u_long		fromssize;
	tostruct_t	*tos;
	u_long		tossize;
	long		tolimit;
	u_long		lowpc;
	u_long		highpc;
	u_long		textsize;
	u_long		hashfraction;
};
extern struct gmonparam _gmonparam;

/*
 * Possible states of profiling.
 */
#define	GMON_PROF_ON	0
#define	GMON_PROF_BUSY	1
#define	GMON_PROF_ERROR	2
#define	GMON_PROF_OFF	3

/*
 * Sysctl definitions for extracting profiling information from the kernel.
 */
#define	GPROF_STATE	0	/* int: profiling enabling variable */
#define	GPROF_COUNT	1	/* struct: profile tick count buffer */
#define	GPROF_FROMS	2	/* struct: from location hash bucket */
#define	GPROF_TOS	3	/* struct: destination/count structure */
#define	GPROF_GMONPARAM	4	/* struct: profiling parameters (see above) */

/*
 * In order to support more information than in the original mon.out and
 * gmon.out files there is an alternate gmon.out file format.  The alternate
 * gmon.out file format starts with a magic number then separates the
 * information with gmon_data_t's.
 */
#define GMON_MAGIC 0xbeefbabe
#define GMON_MAGIC_64 0xbeefbabf
typedef struct gmon_data {
    uint32_t type; /* constant for type of data following this struct */
    uint32_t size; /* size in bytes of the data following this struct */
} gmon_data_t;

/*
 * The GMONTYPE_SAMPLES gmon_data.type is for the histogram counters described
 * above and has a gmonhdr_t followed by the counters.
 */
#define GMONTYPE_SAMPLES	1
/*
 * The GMONTYPE_RAWARCS gmon_data.type is for the raw arcs described above.
 */
#define GMONTYPE_RAWARCS	2
/*
 * The GMONTYPE_ARCS_ORDERS gmon_data.type is for the raw arcs with a call
 * order field.  The order is the order is a sequence number for the order each
 * call site was executed.  Raw_order values start at 1 not zero.  Other than
 * the raw_order field this is the same information as in the rawarc_t.
 */
#define GMONTYPE_ARCS_ORDERS	3
struct rawarc_order {
    uint32_t	raw_frompc;
    uint32_t	raw_selfpc;
    uint32_t	raw_count;
    uint32_t	raw_order;

}; struct rawarc_order_64 {
    uint64_t	raw_frompc;
    uint64_t	raw_selfpc;
    uint32_t	raw_count;
    uint32_t	raw_order;
};

typedef struct
#ifndef __LP64__
        rawarc_order
#else
        rawarc_order_64
#endif
rawarc_order_t;

/*
 * The GMONTYPE_DYLD_STATE gmon_data.type is for the dynamic link editor state
 * of the program.
 * The informations starts with an uint32_t with the count of states:
 *      image_count
 * Then each state follows in the file.  The state is made up of 
 *      vmaddr_slide (the amount dyld slid this image from it's vmaddress)
 *      name (the file name dyld loaded this image from)
 * The vmaddr_slide is a 32-bit value for 32-bit programs and 64-bit value for
 * 64-bit programs.
 */
#define GMONTYPE_DYLD_STATE     4

/*
 * The GMONTYPE_DYLD2_STATE gmon_data.type is for the dynamic link editor state
 * of the program.
 * The informations starts with an uint32_t with the count of states:
 *      image_count
 * Then each state follows in the file.  The state is made up of 
 *      image_header (the address where dyld loaded this image)
 *      name (the file name dyld loaded this image from)
 * The image_header is a 32-bit value for 32-bit programs and 64-bit value for
 * 64-bit programs.
 */
#define GMONTYPE_DYLD2_STATE     5

#endif /* !_SYS_GMON_H_ */
                                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/xar/                                0040755 0001750 0001750 00000000000 12612724206 022660  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/xar/xar.h                           0100644 0001750 0001750 00000023547 12612724206 023633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2005 Rob Braun
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of Rob Braun nor the names of his contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * 03-Apr-2005
 * DRI: Rob Braun <bbraun@opendarwin.org>
 */
/*
 * Portions Copyright 2006, Apple Computer, Inc.
 * Christopher Ryan <ryanc@apple.com>
 */
 
#ifndef _XAR_H_
#define _XAR_H_

#define XAR_VERSION "1.7dev"

#include <sys/types.h>
#include <stdint.h>
#include <sys/stat.h>

#pragma pack(4)

struct xar_header {
	uint32_t magic;
	uint16_t size;
	uint16_t version;
	uint64_t toc_length_compressed;
	uint64_t toc_length_uncompressed;
	uint32_t cksum_alg;
};
#pragma pack()
typedef struct xar_header xar_header_t;

#define XAR_HEADER_MAGIC 0x78617221
#define XAR_EA_FORK "ea"

#define XAR_CKSUM_NONE   0
#define XAR_CKSUM_SHA1   1
#define XAR_CKSUM_MD5    2
#define XAR_CKSUM_SHA256 3
#define XAR_CKSUM_SHA512 4

typedef void *xar_errctx_t;
typedef const struct __xar_file_t *xar_file_t;
typedef const struct __xar_iter_t *xar_iter_t;
typedef const struct __xar_t *xar_t;
typedef const struct __xar_subdoc_t *xar_subdoc_t;
typedef const struct __xar_signature_t *xar_signature_t;

typedef struct {
        char *next_out;
        unsigned int avail_out;

        unsigned long long total_in;
        unsigned long long total_out;

        void *state;
} xar_stream;

typedef int32_t (*err_handler)(int32_t severit, int32_t instance, xar_errctx_t ctx, void *usrctx);
/* the signed_data must be allocated durring the callback and will be released by the xar lib after the callback */
typedef int32_t (*xar_signer_callback)(xar_signature_t sig, void *context, uint8_t *data, uint32_t length, uint8_t **signed_data, uint32_t *signed_len);

#define READ 0
#define WRITE 1

/* xar stream return codes */
#define XAR_STREAM_OK   0
#define XAR_STREAM_END  1
#define XAR_STREAM_ERR -1

/* Valid xar options & values */
#define XAR_OPT_OWNERSHIP    "ownership"  /* setting owner/group behavior */
#define XAR_OPT_VAL_SYMBOLIC "symbolic"   /* set owner/group based on names */
#define XAR_OPT_VAL_NUMERIC  "numeric"    /* set owner/group based on uid/gid */

#define XAR_OPT_TOCCKSUM   "toc-cksum"      /* set the toc checksum algorithm */
#define XAR_OPT_FILECKSUM  "file-chksum"	/* set the file checksum algorithm */
#define XAR_OPT_VAL_NONE   "none"
#define XAR_OPT_VAL_SHA1   "sha1"
#define XAR_OPT_VAL_SHA256 "sha256"
#define XAR_OPT_VAL_SHA512 "sha512"
#define XAR_OPT_VAL_MD5    "md5"

#define XAR_OPT_COMPRESSION    "compression" /* set the file compression type */
#define XAR_OPT_COMPRESSIONARG "compression-arg" /* set the compression opts */
#define XAR_OPT_VAL_GZIP       "gzip"
#define XAR_OPT_VAL_BZIP       "bzip2"
#define XAR_OPT_VAL_LZMA       "lzma"

#define XAR_OPT_RSIZE          "rsize"       /* Read io buffer size */

#define XAR_OPT_COALESCE         "coalesce"         /* Coalesce identical heap blocks */
#define XAR_OPT_LINKSAME         "linksame"         /* Hardlink identical files */

#define XAR_OPT_PROPINCLUDE    "prop-include" /* File property to include */
#define XAR_OPT_PROPEXCLUDE    "prop-exclude" /* File property to exclude */

#define XAR_OPT_SAVESUID       "savesuid"     /* Preserve setuid/setgid bits */
#define XAR_OPT_VAL_TRUE       "true"
#define XAR_OPT_VAL_FALSE      "false"

/* xar signing algorithms */
#define XAR_SIG_SHA1RSA		1


/* xar error handler macros */
#define XAR_SEVERITY_DEBUG    1
#define XAR_SEVERITY_INFO     2
#define XAR_SEVERITY_NORMAL   3
#define XAR_SEVERITY_WARNING  4
#define XAR_SEVERITY_NONFATAL 5
#define XAR_SEVERITY_FATAL    6

#define XAR_ERR_ARCHIVE_CREATION   1
#define XAR_ERR_ARCHIVE_EXTRACTION 2

xar_t xar_open(const char *file, int32_t flags);
int xar_close(xar_t x);
xar_file_t xar_add(xar_t x, const char *path);

xar_file_t xar_add_frombuffer(xar_t x, xar_file_t parent, const char *name, char *buffer, size_t length);
xar_file_t xar_add_folder(xar_t x, xar_file_t f, const char *name, struct stat *info);
xar_file_t xar_add_frompath(xar_t x, xar_file_t parent, const char *name, const char *realpath);

xar_file_t xar_add_from_archive(xar_t x, xar_file_t parent, const char *name, xar_t sourcearchive, xar_file_t sourcefile);

int32_t xar_extract(xar_t x, xar_file_t f);
int32_t xar_extract_tofile(xar_t x, xar_file_t f, const char *path);
int32_t xar_extract_tobuffer(xar_t x, xar_file_t f, char **buffer);
int32_t xar_extract_tobuffersz(xar_t x, xar_file_t f, char **buffer, size_t *size);
int32_t xar_extract_tostream_init(xar_t x, xar_file_t f, xar_stream *stream);
int32_t xar_extract_tostream(xar_stream *stream);
int32_t xar_extract_tostream_end(xar_stream *stream);

int32_t xar_verify(xar_t x, xar_file_t f);


const char *xar_opt_get(xar_t x, const char *option);
int32_t xar_opt_set(xar_t x, const char *option, const char *value);
int32_t xar_opt_unset(xar_t x, const char *option);

int32_t xar_prop_set(xar_file_t f, const char *key, const char *value);
int32_t xar_prop_create(xar_file_t f, const char *key, const char *value);
int32_t xar_prop_get(xar_file_t f, const char *key, const char **value);

xar_iter_t xar_iter_new(void);
void xar_iter_free(xar_iter_t i);

const char *xar_prop_first(xar_file_t f, xar_iter_t i);
const char *xar_prop_next(xar_iter_t i);

void xar_prop_unset(xar_file_t f, const char *key);
xar_file_t xar_file_first(xar_t x, xar_iter_t i);
xar_file_t xar_file_next(xar_iter_t i);

const char *xar_attr_get(xar_file_t f, const char *prop, const char *key);
int32_t xar_attr_set(xar_file_t f, const char *prop, const char *key, const char *value);
const char *xar_attr_first(xar_file_t f, const char *prop, xar_iter_t i);
const char *xar_attr_next(xar_iter_t i);

xar_subdoc_t xar_subdoc_new(xar_t x, const char *name);
int32_t xar_subdoc_prop_set(xar_subdoc_t s, const char *key, const char *value);
int32_t xar_subdoc_prop_get(xar_subdoc_t s, const char *key, const char **value);
int32_t xar_subdoc_attr_set(xar_subdoc_t s, const char *prop, const char *key, const char *value);
const char *xar_subdoc_attr_get(xar_subdoc_t s, const char *prop, const char *key);
xar_subdoc_t xar_subdoc_first(xar_t x);
xar_subdoc_t xar_subdoc_next(xar_subdoc_t s);
const char *xar_subdoc_name(xar_subdoc_t s);
int32_t xar_subdoc_copyout(xar_subdoc_t s, unsigned char **, unsigned int *);
int32_t xar_subdoc_copyin(xar_subdoc_t s, const unsigned char *, unsigned int);
void xar_subdoc_remove(xar_subdoc_t s);

/* signature api for adding various signature types */
xar_signature_t xar_signature_new(xar_t x,const char *type, int32_t length, xar_signer_callback callback, void *callback_context);
/* extended signatures are ignored by previous versions of xar */
xar_signature_t xar_signature_new_extended(xar_t x,const char *type, int32_t length, xar_signer_callback callback, void *callback_context);

const char *xar_signature_type(xar_signature_t s);

xar_signature_t xar_signature_first(xar_t x);
xar_signature_t xar_signature_next(xar_signature_t s);

int32_t xar_signature_add_x509certificate(xar_signature_t sig, const uint8_t *cert_data, uint32_t cert_len );

int32_t xar_signature_get_x509certificate_count(xar_signature_t sig);
int32_t xar_signature_get_x509certificate_data(xar_signature_t sig, int32_t index, const uint8_t **cert_data, uint32_t *cert_len);

uint8_t xar_signature_copy_signed_data(xar_signature_t sig, uint8_t **data, uint32_t *length, uint8_t **signed_data, uint32_t *signed_length, off_t *signed_offset);

/* Helper functions - caller must free returned memory */
char *xar_get_size(xar_t x, xar_file_t f);
char *xar_get_type(xar_t x, xar_file_t f);
char *xar_get_mode(xar_t x, xar_file_t f);
char *xar_get_owner(xar_t x, xar_file_t f);
char *xar_get_group(xar_t x, xar_file_t f);
char *xar_get_mtime(xar_t x, xar_file_t f);

/* For helping calling apps harden against hacked archives that attempt to escape their extraction roots. */
int xar_path_issane(char* path);

/* These are for xar modules and should never be needed from a calling app */
void xar_register_errhandler(xar_t x, err_handler callback, void *usrctx);
xar_t xar_err_get_archive(xar_errctx_t ctx);
xar_file_t xar_err_get_file(xar_errctx_t ctx);
const char *xar_err_get_string(xar_errctx_t ctx);
int xar_err_get_errno(xar_errctx_t ctx);
void xar_err_set_file(xar_t x, xar_file_t f);
void xar_err_set_formatted_string(xar_t x, const char *format, ...);
void xar_err_set_string(xar_t x, const char *str);
void xar_err_set_errno(xar_t x, int e);
void xar_err_new(xar_t x);
int32_t xar_err_callback(xar_t x, int32_t sev, int32_t err);

void xar_serialize(xar_t x, const char *file);
char *xar_get_path(xar_file_t f);
off_t	xar_get_heap_offset(xar_t x);
uint64_t xar_ntoh64(uint64_t num);

#endif /* _XAR_H_ */
                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh                                  0100755 0001750 0001750 00000034523 12612724217 022455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh
# install - install a program, script, or datafile

scriptversion=2013-12-25.23; # UTC

# This originates from X11R5 (mit/util/scripts/install.sh), which was
# later released in X11R6 (xc/config/util/install.sh) with the
# following copyright and license.
#
# Copyright (C) 1994 X Consortium
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of the X Consortium shall not
# be used in advertising or otherwise to promote the sale, use or other deal-
# ings in this Software without prior written authorization from the X Consor-
# tium.
#
#
# FSF changes to this file are in the public domain.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# 'make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.

tab='	'
nl='
'
IFS=" $tab$nl"

# Set DOITPROG to "echo" to test this script.

doit=${DOITPROG-}
doit_exec=${doit:-exec}

# Put in absolute file names if you don't have them in your path;
# or use environment vars.

chgrpprog=${CHGRPPROG-chgrp}
chmodprog=${CHMODPROG-chmod}
chownprog=${CHOWNPROG-chown}
cmpprog=${CMPPROG-cmp}
cpprog=${CPPROG-cp}
mkdirprog=${MKDIRPROG-mkdir}
mvprog=${MVPROG-mv}
rmprog=${RMPROG-rm}
stripprog=${STRIPPROG-strip}

posix_mkdir=

# Desired mode of installed file.
mode=0755

chgrpcmd=
chmodcmd=$chmodprog
chowncmd=
mvcmd=$mvprog
rmcmd="$rmprog -f"
stripcmd=

src=
dst=
dir_arg=
dst_arg=

copy_on_change=false
is_target_a_directory=possibly

usage="\
Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
   or: $0 [OPTION]... SRCFILES... DIRECTORY
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...

In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.

Options:
     --help     display this help and exit.
     --version  display version info and exit.

  -c            (ignored)
  -C            install only if different (preserve the last data modification time)
  -d            create directories instead of installing files.
  -g GROUP      $chgrpprog installed files to GROUP.
  -m MODE       $chmodprog installed files to MODE.
  -o USER       $chownprog installed files to USER.
  -s            $stripprog installed files.
  -t DIRECTORY  install into DIRECTORY.
  -T            report an error if DSTFILE is a directory.

Environment variables override the default commands:
  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
  RMPROG STRIPPROG
"

while test $# -ne 0; do
  case $1 in
    -c) ;;

    -C) copy_on_change=true;;

    -d) dir_arg=true;;

    -g) chgrpcmd="$chgrpprog $2"
        shift;;

    --help) echo "$usage"; exit $?;;

    -m) mode=$2
        case $mode in
          *' '* | *"$tab"* | *"$nl"* | *'*'* | *'?'* | *'['*)
            echo "$0: invalid mode: $mode" >&2
            exit 1;;
        esac
        shift;;

    -o) chowncmd="$chownprog $2"
        shift;;

    -s) stripcmd=$stripprog;;

    -t)
        is_target_a_directory=always
        dst_arg=$2
        # Protect names problematic for 'test' and other utilities.
        case $dst_arg in
          -* | [=\(\)!]) dst_arg=./$dst_arg;;
        esac
        shift;;

    -T) is_target_a_directory=never;;

    --version) echo "$0 $scriptversion"; exit $?;;

    --) shift
        break;;

    -*) echo "$0: invalid option: $1" >&2
        exit 1;;

    *)  break;;
  esac
  shift
done

# We allow the use of options -d and -T together, by making -d
# take the precedence; this is for compatibility with GNU install.

if test -n "$dir_arg"; then
  if test -n "$dst_arg"; then
    echo "$0: target directory not allowed when installing a directory." >&2
    exit 1
  fi
fi

if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
  # When -d is used, all remaining arguments are directories to create.
  # When -t is used, the destination is already specified.
  # Otherwise, the last argument is the destination.  Remove it from $@.
  for arg
  do
    if test -n "$dst_arg"; then
      # $@ is not empty: it contains at least $arg.
      set fnord "$@" "$dst_arg"
      shift # fnord
    fi
    shift # arg
    dst_arg=$arg
    # Protect names problematic for 'test' and other utilities.
    case $dst_arg in
      -* | [=\(\)!]) dst_arg=./$dst_arg;;
    esac
  done
fi

if test $# -eq 0; then
  if test -z "$dir_arg"; then
    echo "$0: no input file specified." >&2
    exit 1
  fi
  # It's OK to call 'install-sh -d' without argument.
  # This can happen when creating conditional directories.
  exit 0
fi

if test -z "$dir_arg"; then
  if test $# -gt 1 || test "$is_target_a_directory" = always; then
    if test ! -d "$dst_arg"; then
      echo "$0: $dst_arg: Is not a directory." >&2
      exit 1
    fi
  fi
fi

if test -z "$dir_arg"; then
  do_exit='(exit $ret); exit $ret'
  trap "ret=129; $do_exit" 1
  trap "ret=130; $do_exit" 2
  trap "ret=141; $do_exit" 13
  trap "ret=143; $do_exit" 15

  # Set umask so as not to create temps with too-generous modes.
  # However, 'strip' requires both read and write access to temps.
  case $mode in
    # Optimize common cases.
    *644) cp_umask=133;;
    *755) cp_umask=22;;

    *[0-7])
      if test -z "$stripcmd"; then
        u_plus_rw=
      else
        u_plus_rw='% 200'
      fi
      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
    *)
      if test -z "$stripcmd"; then
        u_plus_rw=
      else
        u_plus_rw=,u+rw
      fi
      cp_umask=$mode$u_plus_rw;;
  esac
fi

for src
do
  # Protect names problematic for 'test' and other utilities.
  case $src in
    -* | [=\(\)!]) src=./$src;;
  esac

  if test -n "$dir_arg"; then
    dst=$src
    dstdir=$dst
    test -d "$dstdir"
    dstdir_status=$?
  else

    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
    # might cause directories to be created, which would be especially bad
    # if $src (and thus $dsttmp) contains '*'.
    if test ! -f "$src" && test ! -d "$src"; then
      echo "$0: $src does not exist." >&2
      exit 1
    fi

    if test -z "$dst_arg"; then
      echo "$0: no destination specified." >&2
      exit 1
    fi
    dst=$dst_arg

    # If destination is a directory, append the input filename; won't work
    # if double slashes aren't ignored.
    if test -d "$dst"; then
      if test "$is_target_a_directory" = never; then
        echo "$0: $dst_arg: Is a directory" >&2
        exit 1
      fi
      dstdir=$dst
      dst=$dstdir/`basename "$src"`
      dstdir_status=0
    else
      dstdir=`dirname "$dst"`
      test -d "$dstdir"
      dstdir_status=$?
    fi
  fi

  obsolete_mkdir_used=false

  if test $dstdir_status != 0; then
    case $posix_mkdir in
      '')
        # Create intermediate dirs using mode 755 as modified by the umask.
        # This is like FreeBSD 'install' as of 1997-10-28.
        umask=`umask`
        case $stripcmd.$umask in
          # Optimize common cases.
          *[2367][2367]) mkdir_umask=$umask;;
          .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

          *[0-7])
            mkdir_umask=`expr $umask + 22 \
              - $umask % 100 % 40 + $umask % 20 \
              - $umask % 10 % 4 + $umask % 2
            `;;
          *) mkdir_umask=$umask,go-w;;
        esac

        # With -d, create the new directory with the user-specified mode.
        # Otherwise, rely on $mkdir_umask.
        if test -n "$dir_arg"; then
          mkdir_mode=-m$mode
        else
          mkdir_mode=
        fi

        posix_mkdir=false
        case $umask in
          *[123567][0-7][0-7])
            # POSIX mkdir -p sets u+wx bits regardless of umask, which
            # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
            ;;
          *)
            tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
            trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

            if (umask $mkdir_umask &&
                exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
            then
              if test -z "$dir_arg" || {
                   # Check for POSIX incompatibilities with -m.
                   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
                   # other-writable bit of parent directory when it shouldn't.
                   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
                   ls_ld_tmpdir=`ls -ld "$tmpdir"`
                   case $ls_ld_tmpdir in
                     d????-?r-*) different_mode=700;;
                     d????-?--*) different_mode=755;;
                     *) false;;
                   esac &&
                   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
                     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
                     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
                   }
                 }
              then posix_mkdir=:
              fi
              rmdir "$tmpdir/d" "$tmpdir"
            else
              # Remove any dirs left behind by ancient mkdir implementations.
              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
            fi
            trap '' 0;;
        esac;;
    esac

    if
      $posix_mkdir && (
        umask $mkdir_umask &&
        $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
      )
    then :
    else

      # The umask is ridiculous, or mkdir does not conform to POSIX,
      # or it failed possibly due to a race condition.  Create the
      # directory the slow way, step by step, checking for races as we go.

      case $dstdir in
        /*) prefix='/';;
        [-=\(\)!]*) prefix='./';;
        *)  prefix='';;
      esac

      oIFS=$IFS
      IFS=/
      set -f
      set fnord $dstdir
      shift
      set +f
      IFS=$oIFS

      prefixes=

      for d
      do
        test X"$d" = X && continue

        prefix=$prefix$d
        if test -d "$prefix"; then
          prefixes=
        else
          if $posix_mkdir; then
            (umask=$mkdir_umask &&
             $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
            # Don't fail if two instances are running concurrently.
            test -d "$prefix" || exit 1
          else
            case $prefix in
              *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
              *) qprefix=$prefix;;
            esac
            prefixes="$prefixes '$qprefix'"
          fi
        fi
        prefix=$prefix/
      done

      if test -n "$prefixes"; then
        # Don't fail if two instances are running concurrently.
        (umask $mkdir_umask &&
         eval "\$doit_exec \$mkdirprog $prefixes") ||
          test -d "$dstdir" || exit 1
        obsolete_mkdir_used=true
      fi
    fi
  fi

  if test -n "$dir_arg"; then
    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
  else

    # Make a couple of temp file names in the proper directory.
    dsttmp=$dstdir/_inst.$$_
    rmtmp=$dstdir/_rm.$$_

    # Trap to clean up those temp files at exit.
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0

    # Copy the file name to the temp name.
    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&

    # and set any options; do chmod last to preserve setuid bits.
    #
    # If any of these fail, we abort the whole thing.  If we want to
    # ignore errors from any of these, just make sure not to ignore
    # errors from the above "$doit $cpprog $src $dsttmp" command.
    #
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&

    # If -C, don't bother to copy if it wouldn't change the file.
    if $copy_on_change &&
       old=`LC_ALL=C ls -dlL "$dst"     2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"  2>/dev/null` &&
       set -f &&
       set X $old && old=:$2:$4:$5:$6 &&
       set X $new && new=:$2:$4:$5:$6 &&
       set +f &&
       test "$old" = "$new" &&
       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
    then
      rm -f "$dsttmp"
    else
      # Rename the file to the real destination.
      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||

      # The rename failed, perhaps because mv can't rename something else
      # to itself, or perhaps because mv is so ancient that it does not
      # support -f.
      {
        # Now remove or move aside any old file at destination location.
        # We try this two ways since rm can't unlink itself on some
        # systems and the destination file might be busy for other
        # reasons.  In this case, the final cleanup might fail but the new
        # file should still install successfully.
        {
          test ! -f "$dst" ||
          $doit $rmcmd -f "$dst" 2>/dev/null ||
          { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
            { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
          } ||
          { echo "$0: cannot unlink or rename $dst" >&2
            (exit 1); exit 1
          }
        } &&

        # Now rename the file to the real destination.
        $doit $mvcmd "$dsttmp" "$dst"
      }
    fi || exit 1

    trap '' 0
  fi
done

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:
                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/                                         0040755 0001750 0001750 00000000000 13101126656 021041  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/4byte_literals.c                         0100644 0001750 0001750 00000032265 12612724205 024140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with 4 byte literals sections.
 * A literal in this section must beable to me moved freely with respect to
 * other literals.  This means relocation must not reach outside the size of
 * the literal.  The size of this this type of section must be a multiple of
 * 4 bytes in all input files.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <mach-o/loader.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "4byte_literals.h"
#include "8byte_literals.h"
#include "pass2.h"

/*
 * literal4_merge() merges 4 byte literals from the specified section in the
 * current object file (cur_obj). When redo_live is FALSE it allocates a fine
 * relocation map and sets the fine_relocs field in the section_map to it (as
 * well as the count).  When redo_live is TRUE it re-merges only the live
 * cstrings based on the live bit in the previouly allocated fine_relocs.
 */
__private_extern__
void
literal4_merge(
struct literal4_data *data,
struct merged_section *ms,
struct section *s,
struct section_map *section_map,
enum bool redo_live)
{
    unsigned long nliteral4s, i;
    struct literal4 *literal4s;
    struct fine_reloc *fine_relocs;

	if(s->size == 0){
	    if(redo_live == FALSE){
		section_map->fine_relocs = NULL;
		section_map->nfine_relocs = 0;
	    }
	    return;
	}
	/*
	 * Calculate the number of literals so the size of the fine relocation
	 * structures can be allocated.
	 */
	if(s->size % 4 != 0){
	    error_with_cur_obj("4 byte literal section (%.16s,%.16s) size is "
			       "not a multiple of 4 bytes", ms->s.segname,
			       ms->s.sectname);
	    return;
	}
	nliteral4s = s->size / 4;
#ifdef DEBUG
	if(redo_live == FALSE){
	    data->nfiles++;
	    data->nliterals += nliteral4s;
	}
#endif /* DEBUG */

	/*
	 * We will be called the first time with redo_live == FALSE and will
	 * just merge the cstrings from the input file and create the
	 * fine_relocs.
	 */
	if(redo_live == FALSE){
	    fine_relocs = allocate(nliteral4s * sizeof(struct fine_reloc));
	    memset(fine_relocs, '\0', nliteral4s * sizeof(struct fine_reloc));

	    /*
	     * lookup and enter each 4 byte literal in the section and record
	     * the offsets in the input file and in the output file.
	     */
	    literal4s = (struct literal4 *)(cur_obj->obj_addr + s->offset);
	    for(i = 0; i < nliteral4s; i++){
		fine_relocs[i].input_offset = i * 4;
		fine_relocs[i].output_offset =
					lookup_literal4(literal4s[i], data, ms);
	    }
	    section_map->fine_relocs = fine_relocs;
	    section_map->nfine_relocs = nliteral4s;
	}
	else{
	    /*
	     * redo_live == TRUE and this is being called a second time after
	     * all the literals were previouly merged when -dead_strip is
	     * specified.  So now we walk the fine_relocs and only re-merge the
	     * live literals.
	     */
	    fine_relocs = section_map->fine_relocs;
	    nliteral4s = section_map->nfine_relocs;
	    literal4s = (struct literal4 *)(cur_obj->obj_addr + s->offset);
	    for(i = 0; i < nliteral4s; i++){
		if(fine_relocs[i].live == TRUE){
		    fine_relocs[i].output_offset =
			lookup_literal4(literal4s[i], data, ms);
		}
		else{
		    fine_relocs[i].output_offset = 0;
		}
	    }
	}
}

/*
 * literal4_order() enters 4 byte literals from the order_file from the merged
 * section structure.  Since this is called before any call to literal4_merge
 * and it enters the literals in the order of the file it causes the section
 * to be ordered.
 */
__private_extern__
void
literal4_order(
struct literal4_data *data,
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, line_number, output_offset, nliteral4_order_lines;
    struct literal4 literal4;
    struct literal4_order_line *literal4_order_lines;

	/*
	 * If -dead_strip is specified allocate the needed structures so that
	 * the order of the live literals can be recreated later by
	 * literal4_reset_live().  Allocate a literal4_order_line for each
	 * line as the maximum that will needed.
	 */
	literal4_order_lines = NULL;
	if(dead_strip == TRUE){
	    line_number = 1;
	    i = 0;
	    while(i < ms->order_size){
		while(i < ms->order_size && ms->order_addr[i] != '\n')
		    i++;
		if(i < ms->order_size && ms->order_addr[i] == '\n')
		    i++;
		line_number++;
	    }
	    data->literal4_load_order_data =
		allocate(sizeof(struct literal4_load_order_data));
	    literal4_order_lines = allocate(sizeof(struct literal4_order_line) *
					   (line_number - 1));
	    data->literal4_load_order_data->literal4_order_lines =
		literal4_order_lines;
	}

	line_number = 1;
	i = 0;
	nliteral4_order_lines = 0;
	while(i < ms->order_size){
	    if(get_hex_from_sectorder(ms, &i, &(literal4.long0), line_number) ==
	       TRUE){
		output_offset = lookup_literal4(literal4, data, ms);
		if(dead_strip == TRUE){
		    literal4_order_lines[nliteral4_order_lines].literal4 =
			literal4;
		    literal4_order_lines[nliteral4_order_lines].line_number =
			line_number;
		    literal4_order_lines[nliteral4_order_lines].output_offset =
			output_offset;
		    nliteral4_order_lines++;
		}
	    }
	    while(i < ms->order_size && ms->order_addr[i] != '\n')
		i++;
	    if(i < ms->order_size && ms->order_addr[i] == '\n')
		i++;
	    line_number++;
	}

	if(dead_strip == TRUE)
	    data->literal4_load_order_data->nliteral4_order_lines =
		nliteral4_order_lines;
#endif /* !defined(RLD) */
}

/*
 * literal4_reset_live() is called when -dead_strip is specified after all the
 * literals from the input objects are merged.  It clears out the literal4_data
 * so the live literals can be re-merged (by later calling literal4_merge() with
 * redo_live == TRUE.  In here we first merge in the live literals from the
 * order file if any. 
 */
__private_extern__
void
literal4_reset_live(
struct literal4_data *data,
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, nliteral4_order_lines, line_number;
    struct literal4_order_line *literal4_order_lines;
    enum bool live;

	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* clear out the previously merged data */
	literal4_free(data);

	/*
	 * If this merged section has an order file we need to re-merged only
	 * the live literal4s from that order file.
	 */
	if(ms->order_filename != NULL){
	    literal4_order_lines =
		data->literal4_load_order_data->literal4_order_lines;
	    nliteral4_order_lines =
		data->literal4_load_order_data->nliteral4_order_lines;
	    for(i = 0; i < nliteral4_order_lines; i++){
		/*
		 * Figure out if this literal4 order line's output_index is live
		 * and if so re-merge the literal4 literal.
		 */
		live = is_literal_output_offset_live(
			ms, literal4_order_lines[i].output_offset);
		line_number = literal4_order_lines[i].line_number;
		if(live){
		    (void)lookup_literal4(literal4_order_lines[i].literal4,
					  data, ms);
		}
		else{
		    if(sectorder_detail == TRUE)
			warning("specification of 4-byte literal in -sectorder "
				"file: %s on line %lu for section (%.16s,%.16s)"
				" not used (dead stripped)", ms->order_filename,
				line_number, ms->s.segname, ms->s.sectname);
		}
	    }

	    /* deallocate the various data structures no longer needed */
	    free(data->literal4_load_order_data->literal4_order_lines);
	    free(data->literal4_load_order_data);
	    data->literal4_load_order_data = NULL;
	}
#endif /* !defined(RLD) */
}

/*
 * lookup_literal4() looks up the 4 byte literal passed to it in the
 * literal4_data passed to it and returns the offset the 4 byte literal will
 * have in the output file.  It creates the blocks to store the literals and
 * attaches them to the literal4_data passed to it.  The total size of the
 * section is accumulated in ms->s.size which is the merged section for this
 * literal section.  The literal is aligned to the alignment in the merged
 * section (ms->s.align).
 */
__private_extern__
unsigned long
lookup_literal4(
struct literal4 literal4,
struct literal4_data *data,
struct merged_section *ms)
{
    struct literal4_block **p, *literal4_block;
    unsigned long align_multiplier, output_offset, i;

	align_multiplier = 1;
 	if((1 << ms->s.align) > 4)
	    align_multiplier = (1 << ms->s.align) / 4;

	output_offset = 0;
	for(p = &(data->literal4_blocks); *p ; p = &(literal4_block->next)){
	    literal4_block = *p;
	    for(i = 0; i < literal4_block->used; i++){
		if(literal4.long0 == literal4_block->literal4s[i].long0)
		    return(output_offset + i * 4 * align_multiplier);
	    }
	    if(literal4_block->used != LITERAL4_BLOCK_SIZE){
		literal4_block->literal4s[i].long0 = literal4.long0;
		literal4_block->used++;
		ms->s.size += 4 * align_multiplier;
		return(output_offset + i * 4 * align_multiplier);
	    }
	    output_offset += literal4_block->used * 4 * align_multiplier;
	}
	*p = allocate(sizeof(struct literal4_block));
	literal4_block = *p;
	literal4_block->used = 1;
	literal4_block->literal4s[0].long0 = literal4.long0;
	literal4_block->next = NULL;

	ms->s.size += 4 * align_multiplier;
	return(output_offset);
}

/*
 * literal4_output() copies the 4 byte literals for the data passed to it into
 * the output file's buffer.  The pointer to the merged section passed to it is
 * used to tell where in the output file this section goes.  Then this routine
 * calls literal4_free to free() up all space used by the data block except the
 * data block itself.
 */
__private_extern__
void
literal4_output(
struct literal4_data *data,
struct merged_section *ms)
{
    unsigned long align_multiplier, i, offset;
    struct literal4_block **p, *literal4_block;

	align_multiplier = 1;
 	if((1 << ms->s.align) > 4)
	    align_multiplier = (1 << ms->s.align) / 4;

	/*
	 * Copy the literals into the output file.
	 */
	offset = ms->s.offset;
	for(p = &(data->literal4_blocks); *p ;){
	    literal4_block = *p;
	    for(i = 0; i < literal4_block->used; i++){
		memcpy(output_addr + offset,
		       literal4_block->literal4s + i,
		       sizeof(struct literal4));
		offset += 4 * align_multiplier;
	    }
	    p = &(literal4_block->next);
	}
#ifndef RLD
	output_flush(ms->s.offset, offset - ms->s.offset);
#endif /* !defined(RLD) */
}

/*
 * literal4_free() free()'s up all space used by the data block except the
 * data block itself.
 */
__private_extern__
void
literal4_free(
struct literal4_data *data)
{
    struct literal4_block *literal4_block, *next_literal4_block;

	/*
	 * Free all data for this block.
	 */
	for(literal4_block = data->literal4_blocks; literal4_block ;){
	    next_literal4_block = literal4_block->next;
	    free(literal4_block);
	    literal4_block = next_literal4_block;
	}
	data->literal4_blocks = NULL;
}

#ifdef DEBUG
/*
 * print_literal4_data() prints a literal4_data.  Used for debugging.
 */
__private_extern__
void
print_literal4_data(
struct literal4_data *data,
char *indent)
{
    unsigned long i;
    struct literal4_block **p, *literal4_block;

	print("%s4 byte literal data at 0x%x\n", indent, (unsigned int)data);
	if(data == NULL)
	    return;
	print("%s   literal4_blocks 0x%x\n", indent,
	      (unsigned int)(data->literal4_blocks));
	for(p = &(data->literal4_blocks); *p ; p = &(literal4_block->next)){
	    literal4_block = *p;
	    print("%s\tused %lu\n", indent, literal4_block->used);
	    print("%s\tnext 0x%x\n", indent,
		  (unsigned int)(literal4_block->next));
	    print("%s\tliteral4s\n", indent);
	    for(i = 0; i < literal4_block->used; i++){
		print("%s\t    0x%08x\n", indent,
		      (unsigned int)(literal4_block->literal4s[i].long0));
	    }
	}
}

/*
 * literal4_data_stats() prints the literal4_data stats.  Used for tuning.
 */
__private_extern__
void
literal4_data_stats(
struct literal4_data *data,
struct merged_section *ms)
{
	if(data == NULL)
	    return;
	print("literal4 section (%.16s,%.16s) contains:\n",
	      ms->s.segname, ms->s.sectname);
	print("    %u merged literals \n", ms->s.size / 4);
	print("    from %lu files and %lu total literals from those "
	      "files\n", data->nfiles, data->nliterals);
	print("    average number of literals per file %g\n",
	      (double)((double)data->nliterals / (double)(data->nfiles)));
}
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/4byte_literals.h                         0100644 0001750 0001750 00000007440 12612724205 024142  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file 4byte_literals.c.
 *
 * The following include files need to be included before this file:
 * #include "ld.h"
 * #include "objects.h"
 */

/*
 * The literal_data which is set into a merged_section's literal_data field for
 * S_4BYTE_LITERALS sections.  The external functions declared at the end of
 * this file operate on this data and are used for the other fields of a
 * merged_section for literals (literal_merge and literal_write).
 */
struct literal4_data {
    struct literal4_block *literal4_blocks;	/* the literal4's */
    struct literal4_load_order_data	 /* the load order info needed to */
	*literal4_load_order_data;	 /*  re-merge when using -dead_strip */
#ifdef DEBUG
    unsigned long nfiles;	/* number of files with this section */
    unsigned long nliterals;	/* total number of literals in the input files*/
				/*  merged into this section  */
#endif /* DEBUG */
};

/* the number of entries in the hash table */
#define LITERAL4_BLOCK_SIZE 60

/* The structure to hold an 4 byte literal */
struct literal4 {
    unsigned long long0;
};

/* the blocks that store the liiterals; allocated as needed */
struct literal4_block {
    unsigned long used;			/* the number of literals used in */
    struct literal4			/*  this block */
	literal4s[LITERAL4_BLOCK_SIZE];	/* the literals */
    struct literal4_block *next;	/* the next block */
};

/* the load order info needed to re-merge when using -dead_strip */
struct literal4_load_order_data {
    unsigned long nliteral4_order_lines;
    struct literal4_order_line *literal4_order_lines;
};
/* the load order info for a single literal4 order line */
struct literal4_order_line {
    struct literal4 literal4;
    unsigned long line_number;
    unsigned long output_offset;
};

__private_extern__ void literal4_merge(
    struct literal4_data *data,
    struct merged_section *ms,
    struct section *s,
    struct section_map *section_map,
    enum bool redo_live);

__private_extern__ void literal4_order(
    struct literal4_data *data,
    struct merged_section *ms);

__private_extern__ void literal4_reset_live(
    struct literal4_data *data,
    struct merged_section *ms);

__private_extern__ unsigned long lookup_literal4(
    struct literal4 literal4,
    struct literal4_data *data,
    struct merged_section *ms);

__private_extern__ void literal4_output(
    struct literal4_data *data,
    struct merged_section *ms);

__private_extern__ void literal4_free(
    struct literal4_data *data);

#ifdef DEBUG
__private_extern__ void print_literal4_data(
    struct literal4_data *data,
    char *indent);

__private_extern__ void literal4_data_stats(
    struct literal4_data *data,
    struct merged_section *ms);
#endif /* DEBUG */
                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/8byte_literals.c                         0100644 0001750 0001750 00000040165 12612724205 024142  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with 8 byte literals sections.
 * A literal in this section must beable to me moved freely with respect to
 * other literals.  This means relocation must not reach outside the size of
 * the literal.  The size of this this type of section must be a multiple of
 * 8 bytes in all input files.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <mach-o/loader.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "8byte_literals.h"
#include "pass2.h"

/*
 * literal8_merge() merges 8 byte literals from the specified section in the
 * current object file (cur_obj). When redo_live is FALSE it allocates a fine
 * relocation map and sets the fine_relocs field in the section_map to it (as
 * well as the count).  When redo_live is TRUE it re-merges only the live
 * cstrings based on the live bit in the previouly allocated fine_relocs.
 */
__private_extern__
void
literal8_merge(
struct literal8_data *data,
struct merged_section *ms,
struct section *s,
struct section_map *section_map,
enum bool redo_live)
{
    unsigned long nliteral8s, i;
    struct literal8 *literal8s;
    struct fine_reloc *fine_relocs;

	if(s->size == 0){
	    if(redo_live == FALSE){
		section_map->fine_relocs = NULL;
		section_map->nfine_relocs = 0;
	    }
	    return;
	}
	/*
	 * Calcualte the number of literals so the size of the fine relocation
	 * structures can be allocated.
	 */
	if(s->size % 8 != 0){
	    error_with_cur_obj("8 byte literal section (%.16s,%.16s) size is "
			       "not a multiple of 8 bytes", ms->s.segname,
			       ms->s.sectname);
	    return;
	}
	nliteral8s = s->size / 8;
#ifdef DEBUG
	if(redo_live == FALSE){
	    data->nfiles++;
	    data->nliterals += nliteral8s;
	}
#endif /* DEBUG */

	/*
	 * We will be called the first time with redo_live == FALSE and will
	 * just merge the cstrings from the input file and create the
	 * fine_relocs.
	 */
	if(redo_live == FALSE){
	    fine_relocs = allocate(nliteral8s * sizeof(struct fine_reloc));
	    memset(fine_relocs, '\0', nliteral8s * sizeof(struct fine_reloc));

	    /*
	     * lookup and enter each 8 byte literal in the section and record
	     * the offsets in the input file and in the output file.
	     */
	    literal8s = (struct literal8 *)(cur_obj->obj_addr + s->offset);
	    for(i = 0; i < nliteral8s; i++){
		fine_relocs[i].input_offset = i * 8;
		fine_relocs[i].output_offset =
		    lookup_literal8(literal8s[i], data, ms);
	    }
	    section_map->fine_relocs = fine_relocs;
	    section_map->nfine_relocs = nliteral8s;
	}
	else{
	    /*
	     * redo_live == TRUE and this is being called a second time after
	     * all the literals were previouly merged when -dead_strip is
	     * specified.  So now we walk the fine_relocs and only re-merge the
	     * live literals.
	     */
	    fine_relocs = section_map->fine_relocs;
	    nliteral8s = section_map->nfine_relocs;
	    literal8s = (struct literal8 *)(cur_obj->obj_addr + s->offset);
	    for(i = 0; i < nliteral8s; i++){
		if(fine_relocs[i].live == TRUE){
		    fine_relocs[i].output_offset =
			lookup_literal8(literal8s[i], data, ms);
		}
		else{
		    fine_relocs[i].output_offset = 0;
		}
	    }
	}
}

/*
 * literal8_order() enters 8 byte literals from the order_file from the merged
 * section structure.  Since this is called before any call to literal8_merge
 * and it enters the literals in the order of the file it causes the section
 * to be ordered.
 */
__private_extern__
void
literal8_order(
struct literal8_data *data,
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, line_number, output_offset, nliteral8_order_lines;
    struct literal8 literal8;
    struct literal8_order_line *literal8_order_lines;

	/*
	 * If -dead_strip is specified allocate the needed structures so that
	 * the order of the live literals can be recreated later by
	 * literal8_reset_live().  Allocate a literal8_order_line for each
	 * line as the maximum that will needed.
	 */
	literal8_order_lines = NULL;
	if(dead_strip == TRUE){
	    line_number = 1;
	    i = 0;
	    while(i < ms->order_size){
		while(i < ms->order_size && ms->order_addr[i] != '\n')
		    i++;
		if(i < ms->order_size && ms->order_addr[i] == '\n')
		    i++;
		line_number++;
	    }
	    data->literal8_load_order_data =
		allocate(sizeof(struct literal8_load_order_data));
	    literal8_order_lines = allocate(sizeof(struct literal8_order_line) *
					   (line_number - 1));
	    data->literal8_load_order_data->literal8_order_lines =
		literal8_order_lines;
	}

	line_number = 1;
	i = 0;
	nliteral8_order_lines = 0;
	while(i < ms->order_size){
	    if(get_hex_from_sectorder(ms, &i, &(literal8.long0),
				      line_number) == TRUE){
		if(get_hex_from_sectorder(ms, &i, &(literal8.long1),
					  line_number) == TRUE){
		    output_offset = lookup_literal8(literal8, data, ms);
		    if(dead_strip == TRUE){
			literal8_order_lines[nliteral8_order_lines].
			    literal8 = literal8;
			literal8_order_lines[nliteral8_order_lines].
			    line_number = line_number;
			literal8_order_lines[nliteral8_order_lines].
			    output_offset = output_offset;
			nliteral8_order_lines++;
		    }
		}
		else
		    error("format error in -sectorder file: %s line %lu for "
			  "section (%.16s,%.16s) (missing second hex number)",
			  ms->order_filename, line_number, ms->s.segname,
			  ms->s.sectname);
	    }
	    while(i < ms->order_size && ms->order_addr[i] != '\n')
		i++;
	    if(i < ms->order_size && ms->order_addr[i] == '\n')
		i++;
	    line_number++;
	}

	if(dead_strip == TRUE)
	    data->literal8_load_order_data->nliteral8_order_lines =
		nliteral8_order_lines;
#endif /* !defined(RLD) */
}

/*
 * literal8_reset_live() is called when -dead_strip is specified after all the
 * literals from the input objects are merged.  It clears out the literal8_data
 * so the live literals can be re-merged (by later calling literal8_merge() with
 * redo_live == TRUE.  In here we first merge in the live literals from the
 * order file if any. 
 */
__private_extern__
void
literal8_reset_live(
struct literal8_data *data,
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, nliteral8_order_lines, line_number;
    struct literal8_order_line *literal8_order_lines;
    enum bool live;

	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* clear out the previously merged data */
	literal8_free(data);

	/*
	 * If this merged section has an order file we need to re-merged only
	 * the live literal8s from that order file.
	 */
	if(ms->order_filename != NULL){
	    literal8_order_lines =
		data->literal8_load_order_data->literal8_order_lines;
	    nliteral8_order_lines =
		data->literal8_load_order_data->nliteral8_order_lines;
	    for(i = 0; i < nliteral8_order_lines; i++){
		/*
		 * Figure out if this literal8 order line's output_index is live
		 * and if so re-merge the literal8 literal.
		 */
		live = is_literal_output_offset_live(
			ms, literal8_order_lines[i].output_offset);
		line_number = literal8_order_lines[i].line_number;
		if(live){
		    (void)lookup_literal8(literal8_order_lines[i].literal8,
					  data, ms);
		}
		else{
		    if(sectorder_detail == TRUE)
			warning("specification of 8-byte literal in -sectorder "
				"file: %s on line %lu for section (%.16s,%.16s)"
				" not used (dead stripped)", ms->order_filename,
				line_number, ms->s.segname, ms->s.sectname);
		}
	    }

	    /* deallocate the various data structures no longer needed */
	    free(data->literal8_load_order_data->literal8_order_lines);
	    free(data->literal8_load_order_data);
	    data->literal8_load_order_data = NULL;
	}
#endif /* !defined(RLD) */
}

/*
 * get_hex_from_sectorder() gets a hex number of the form 0x<hex digits> for a
 * 32 bit value from a sectorder file.  The sectorder file is for the merged
 * section passed to it (ms).  The index to start scaning from is in *index and
 * is set to the index after the hex number on return.  If a hex number is found
 * it is returned indirectly through *value and TRUE is returned (if a hex
 * number is not found FALSE is returned).  If an error is incountered then an
 * error message is printed stating the order file and the section it is for
 * and the line_number (passed in) it occured on.
 */
__private_extern__
enum bool
get_hex_from_sectorder(
struct merged_section *ms,
unsigned long *index,
unsigned long *value,
unsigned long line_number)
{
    unsigned long i, j;
    char hex[9];

	i = *index;
	/* trim leading white space */
	while(i < ms->order_size &&
	      (ms->order_addr[i] == ' ' ||
	       ms->order_addr[i] == '\t'))
	    i++;

	/*
	 * If after skipping leading white space we are at the end of the file
	 * then just return FALSE but print no error.
	 */
	if(i > ms->order_size){
	    *index = i;
	    return(FALSE);
	}

	/* look for a leading 0x */
	if(i > ms->order_size || ms->order_addr[i] != '0'){
	    error("format error in -sectorder file: %s line %lu for section "
		  "(%.16s,%.16s) (missing hex number, no leading 0x found)",
		  ms->order_filename,line_number,ms->s.segname,ms->s.sectname);
	    *index = i;
	    return(FALSE);
	}
	i++;
	if(i > ms->order_size || ms->order_addr[i] != 'x'){
	    error("format error in -sectorder file: %s line %lu for section "
		  "(%.16s,%.16s) (missing hex number, no leading 0x found)",
		  ms->order_filename,line_number,ms->s.segname,ms->s.sectname);
	    *index = i;
	    return(FALSE);
	}
	i++;

	/* pick-up all hex digits and save the first 8 */
	j = 0;
	while(i < ms->order_size &&
	      ((ms->order_addr[i] >= '0' && ms->order_addr[i] <= '9') ||
	       (ms->order_addr[i] >= 'a' && ms->order_addr[i] <= 'f') ||
	       (ms->order_addr[i] >= 'A' && ms->order_addr[i] <= 'F')) ){
	    if(j <= 8)
		hex[j++] = ms->order_addr[i++];
	    else
		i++;
	}
	if(j > 8){
	    error("format error in -sectorder file: %s line %lu for section "
		  "(%.16s,%.16s) (too many hex digits for 32 bit value)",
		  ms->order_filename,line_number,ms->s.segname,ms->s.sectname);
	    *index = i;
	    return(FALSE);
	}
	hex[j] = '\0';
	*value = strtoul(hex, NULL, 16);
	*index = i;
	return(TRUE);
}

/*
 * lookup_literal8() looks up the 8 byte literal passed to it in the
 * literal8_data passed to it and returns the offset the 8 byte literal will
 * have in the output file.  It creates the blocks to store the literals and
 * attaches them to the literal8_data passed to it.  The total size of the
 * section is accumulated in ms->s.size which is the merged section for this
 * literal section.  The literal is aligned to the alignment in the merged
 * section (ms->s.align).
 */
__private_extern__
unsigned long
lookup_literal8(
struct literal8 literal8,
struct literal8_data *data,
struct merged_section *ms)
{
    struct literal8_block **p, *literal8_block;
    unsigned long align_multiplier, output_offset, i;

	align_multiplier = 1;
 	if((1 << ms->s.align) > 8)
	    align_multiplier = (1 << ms->s.align) / 8;

	output_offset = 0;
	for(p = &(data->literal8_blocks); *p ; p = &(literal8_block->next)){
	    literal8_block = *p;
	    for(i = 0; i < literal8_block->used; i++){
		if(literal8.long0 == literal8_block->literal8s[i].long0 &&
		   literal8.long1 == literal8_block->literal8s[i].long1)
		    return(output_offset + i * 8 * align_multiplier);
	    }
	    if(literal8_block->used != LITERAL8_BLOCK_SIZE){
		literal8_block->literal8s[i].long0 = literal8.long0;
		literal8_block->literal8s[i].long1 = literal8.long1;
		literal8_block->used++;
		ms->s.size += 8 * align_multiplier;
		return(output_offset + i * 8 * align_multiplier);
	    }
	    output_offset += literal8_block->used * 8 * align_multiplier;
	}
	*p = allocate(sizeof(struct literal8_block));
	literal8_block = *p;
	literal8_block->used = 1;
	literal8_block->literal8s[0].long0 = literal8.long0;
	literal8_block->literal8s[0].long1 = literal8.long1;
	literal8_block->next = NULL;

	ms->s.size += 8 * align_multiplier;
	return(output_offset);
}

/*
 * literal8_output() copies the 8 byte literals for the data passed to it into
 * the output file's buffer.  The pointer to the merged section passed to it is
 * used to tell where in the output file this section goes.  Then this routine
 * calls literal8_free() to free up all space used by the data block except the
 * data block itself.
 */
__private_extern__
void
literal8_output(
struct literal8_data *data,
struct merged_section *ms)
{
    unsigned long align_multiplier, i, offset;
    struct literal8_block **p, *literal8_block;

	align_multiplier = 1;
 	if((1 << ms->s.align) > 8)
	    align_multiplier = (1 << ms->s.align) / 8;

	/*
	 * Copy the literals into the output file.
	 */
	offset = ms->s.offset;
	for(p = &(data->literal8_blocks); *p ;){
	    literal8_block = *p;
	    for(i = 0; i < literal8_block->used; i++){
		memcpy(output_addr + offset,
		       literal8_block->literal8s + i,
		       sizeof(struct literal8));
		offset += 8 * align_multiplier;
	    }
	    p = &(literal8_block->next);
	}
#ifndef RLD
	output_flush(ms->s.offset, offset - ms->s.offset);
#endif /* !defined(RLD) */
	literal8_free(data);
}

/*
 * literal8_free() free()'s up all space used by the data block except the
 * data block itself.
 */
__private_extern__
void
literal8_free(
struct literal8_data *data)
{
    struct literal8_block *literal8_block, *next_literal8_block;

	/*
	 * Free all data for this block.
	 */
	for(literal8_block = data->literal8_blocks; literal8_block ;){
	    next_literal8_block = literal8_block->next;
	    free(literal8_block);
	    literal8_block = next_literal8_block;
	}
	data->literal8_blocks = NULL;
}

#ifdef DEBUG
/*
 * print_literal8_data() prints a literal8_data.  Used for debugging.
 */
__private_extern__
void
print_literal8_data(
struct literal8_data *data,
char *indent)
{
    unsigned long i;
    struct literal8_block **p, *literal8_block;

	print("%s8 byte literal data at 0x%x\n", indent, (unsigned int)data);
	if(data == NULL)
	    return;
	print("%s   literal8_blocks 0x%x\n", indent,
	      (unsigned int)(data->literal8_blocks));
	for(p = &(data->literal8_blocks); *p ; p = &(literal8_block->next)){
	    literal8_block = *p;
	    print("%s\tused %lu\n", indent, literal8_block->used);
	    print("%s\tnext 0x%x\n", indent,
		  (unsigned int)(literal8_block->next));
	    print("%s\tliteral8s\n", indent);
	    for(i = 0; i < literal8_block->used; i++){
		print("%s\t    0x%08x 0x%08x\n", indent,
		      (unsigned int)(literal8_block->literal8s[i].long0),
		      (unsigned int)(literal8_block->literal8s[i].long1));
	    }
	}
}

/*
 * literal8_data_stats() prints the literal8_data stats.  Used for tuning.
 */
__private_extern__
void
literal8_data_stats(
struct literal8_data *data,
struct merged_section *ms)
{
	if(data == NULL)
	    return;
	print("literal8 section (%.16s,%.16s) contains:\n",
	      ms->s.segname, ms->s.sectname);
	print("    %u merged literals \n", ms->s.size / 8);
	print("    from %lu files and %lu total literals from those "
	      "files\n", data->nfiles, data->nliterals);
	print("    average number of literals per file %g\n",
	      (double)((double)data->nliterals / (double)(data->nfiles)));
}
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/8byte_literals.h                         0100644 0001750 0001750 00000007741 12612724205 024152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file 8byte_literals.c.
 *
 * The following include files need to be included before this file:
 * #include "ld.h"
 * #include "objects.h"
 */

/*
 * The literal_data which is set into a merged_section's literal_data field for
 * S_8BYTE_LITERALS sections.  The external functions declared at the end of
 * this file operate on this data and are used for the other fields of a
 * merged_section for literals (literal_merge and literal_write).
 */
struct literal8_data {
    struct literal8_block *literal8_blocks;	/* the literal8's */
    struct literal8_load_order_data	 /* the load order info needed to */
	*literal8_load_order_data;	 /*  re-merge when using -dead_strip */
#ifdef DEBUG
    unsigned long nfiles;	/* number of files with this section */
    unsigned long nliterals;	/* total number of literals in the input files*/
				/*  merged into this section  */
#endif /* DEBUG */
};

/* the number of entries in the hash table */
#define LITERAL8_BLOCK_SIZE 60

/* The structure to hold an 8 byte literal */
struct literal8 {
    unsigned long long0;
    unsigned long long1;
};

/* the blocks that store the literals; allocated as needed */
struct literal8_block {
    unsigned long used;			/* the number of literals used in */
    struct literal8			/*  this block */
	literal8s[LITERAL8_BLOCK_SIZE];	/* the literals */
    struct literal8_block *next;	/* the next block */
};

/* the load order info needed to re-merge when using -dead_strip */
struct literal8_load_order_data {
    unsigned long nliteral8_order_lines;
    struct literal8_order_line *literal8_order_lines;
};
/* the load order info for a single literal8 order line */
struct literal8_order_line {
    struct literal8 literal8;
    unsigned long line_number;
    unsigned long output_offset;
};

__private_extern__ void literal8_merge(
    struct literal8_data *data,
    struct merged_section *ms,
    struct section *s,
    struct section_map *section_map,
    enum bool redo_live);

__private_extern__ void literal8_order(
    struct literal8_data *data,
    struct merged_section *ms);

__private_extern__ void literal8_reset_live(
    struct literal8_data *data,
    struct merged_section *ms);

__private_extern__ enum bool get_hex_from_sectorder(
    struct merged_section *ms,
    unsigned long *index,
    unsigned long *value,
    unsigned long line_number);

__private_extern__ unsigned long lookup_literal8(
    struct literal8 literal8,
    struct literal8_data *data,
    struct merged_section *ms);

__private_extern__ void literal8_output(
    struct literal8_data *data,
    struct merged_section *ms);

__private_extern__ void literal8_free(
    struct literal8_data *data);

#ifdef DEBUG
__private_extern__ void print_literal8_data(
    struct literal8_data *data,
    char *indent);

__private_extern__ void literal8_data_stats(
    struct literal8_data *data,
    struct merged_section *ms);
#endif /* DEBUG */
                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/Makefile                                 0100644 0000000 0000000 00000110461 13101126656 022447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# ld/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.




am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
bin_PROGRAMS = ld_classic$(EXEEXT)
subdir = ld
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__installdirs = "$(DESTDIR)$(bindir)"
PROGRAMS = $(bin_PROGRAMS)
am_ld_classic_OBJECTS = ld_classic-ld.$(OBJEXT) \
	ld_classic-pass1.$(OBJEXT) ld_classic-objects.$(OBJEXT) \
	ld_classic-sections.$(OBJEXT) \
	ld_classic-cstring_literals.$(OBJEXT) \
	ld_classic-symbols.$(OBJEXT) ld_classic-fvmlibs.$(OBJEXT) \
	ld_classic-layout.$(OBJEXT) ld_classic-specs.$(OBJEXT) \
	ld_classic-pass2.$(OBJEXT) ld_classic-generic_reloc.$(OBJEXT) \
	ld_classic-rld.$(OBJEXT) ld_classic-sets.$(OBJEXT) \
	ld_classic-4byte_literals.$(OBJEXT) \
	ld_classic-8byte_literals.$(OBJEXT) \
	ld_classic-literal_pointers.$(OBJEXT) \
	ld_classic-dylibs.$(OBJEXT) \
	ld_classic-indirect_sections.$(OBJEXT) \
	ld_classic-mod_sections.$(OBJEXT) \
	ld_classic-i860_reloc.$(OBJEXT) ld_classic-ppc_reloc.$(OBJEXT) \
	ld_classic-m88k_reloc.$(OBJEXT) \
	ld_classic-hppa_reloc.$(OBJEXT) \
	ld_classic-sparc_reloc.$(OBJEXT) \
	ld_classic-coalesced_sections.$(OBJEXT) \
	ld_classic-uuid.$(OBJEXT) ld_classic-debugcompunit.$(OBJEXT) \
	ld_classic-debugline.$(OBJEXT) ld_classic-arm_reloc.$(OBJEXT)
ld_classic_OBJECTS = $(am_ld_classic_OBJECTS)
am__DEPENDENCIES_1 =
ld_classic_DEPENDENCIES = $(top_builddir)/libstuff/libstuff.la \
	$(am__DEPENDENCIES_1)
AM_V_lt = $(am__v_lt_$(V))
am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
am__v_lt_0 = --silent
am__v_lt_1 = 
ld_classic_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ld_classic_CFLAGS) \
	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_$(V))
am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_$(V))
am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(ld_classic_SOURCES)
DIST_SOURCES = $(ld_classic_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../
top_builddir = ..
top_srcdir = ..
ld_classic_LDADD = \
        $(top_builddir)/libstuff/libstuff.la   $(UUID_LIB)

ld_classic_CFLAGS = -D__DARWIN_UNIX03 -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff $(WARNINGS) $(LTO_DEF) $(ENDIAN_FLAG) -DDEBUG
ld_classic_SOURCES = \
	ld.c pass1.c objects.c sections.c cstring_literals.c symbols.c \
	fvmlibs.c layout.c specs.c pass2.c generic_reloc.c rld.c sets.c \
	4byte_literals.c 8byte_literals.c literal_pointers.c dylibs.c \
	indirect_sections.c mod_sections.c i860_reloc.c ppc_reloc.c \
	m88k_reloc.c hppa_reloc.c sparc_reloc.c coalesced_sections.c uuid.c \
	debugcompunit.c debugline.c arm_reloc.c

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-binPROGRAMS: $(bin_PROGRAMS)
	@$(NORMAL_INSTALL)
	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(bindir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
	fi; \
	for p in $$list; do echo "$$p $$p"; done | \
	sed 's/$(EXEEXT)$$//' | \
	while read p p1; do if test -f $$p \
	 || test -f $$p1 \
	  ; then echo "$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n;h' \
	    -e 's|.*|.|' \
	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
	sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
	    else { print "f", $$3 "/" $$4, $$1; } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	    test -z "$$files" || { \
	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
	    } \
	; done

uninstall-binPROGRAMS:
	@$(NORMAL_UNINSTALL)
	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
	files=`for p in $$list; do echo "$$p"; done | \
	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
	      -e 's/$$/$(EXEEXT)/' \
	`; \
	test -n "$$list" || exit 0; \
	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
	cd "$(DESTDIR)$(bindir)" && rm -f $$files

clean-binPROGRAMS:
	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
	echo " rm -f" $$list; \
	rm -f $$list || exit $$?; \
	test -n "$(EXEEXT)" || exit 0; \
	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
	echo " rm -f" $$list; \
	rm -f $$list

ld_classic$(EXEEXT): $(ld_classic_OBJECTS) $(ld_classic_DEPENDENCIES) $(EXTRA_ld_classic_DEPENDENCIES) 
	@rm -f ld_classic$(EXEEXT)
	$(AM_V_CCLD)$(ld_classic_LINK) $(ld_classic_OBJECTS) $(ld_classic_LDADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

ld_classic-ld.o: ld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ld.o `test -f 'ld.c' || echo '$(srcdir)/'`ld.c

ld_classic-ld.obj: ld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ld.obj `if test -f 'ld.c'; then $(CYGPATH_W) 'ld.c'; else $(CYGPATH_W) '$(srcdir)/ld.c'; fi`

ld_classic-pass1.o: pass1.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass1.o `test -f 'pass1.c' || echo '$(srcdir)/'`pass1.c

ld_classic-pass1.obj: pass1.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass1.obj `if test -f 'pass1.c'; then $(CYGPATH_W) 'pass1.c'; else $(CYGPATH_W) '$(srcdir)/pass1.c'; fi`

ld_classic-objects.o: objects.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-objects.o `test -f 'objects.c' || echo '$(srcdir)/'`objects.c

ld_classic-objects.obj: objects.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-objects.obj `if test -f 'objects.c'; then $(CYGPATH_W) 'objects.c'; else $(CYGPATH_W) '$(srcdir)/objects.c'; fi`

ld_classic-sections.o: sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sections.o `test -f 'sections.c' || echo '$(srcdir)/'`sections.c

ld_classic-sections.obj: sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sections.obj `if test -f 'sections.c'; then $(CYGPATH_W) 'sections.c'; else $(CYGPATH_W) '$(srcdir)/sections.c'; fi`

ld_classic-cstring_literals.o: cstring_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-cstring_literals.o `test -f 'cstring_literals.c' || echo '$(srcdir)/'`cstring_literals.c

ld_classic-cstring_literals.obj: cstring_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-cstring_literals.obj `if test -f 'cstring_literals.c'; then $(CYGPATH_W) 'cstring_literals.c'; else $(CYGPATH_W) '$(srcdir)/cstring_literals.c'; fi`

ld_classic-symbols.o: symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-symbols.o `test -f 'symbols.c' || echo '$(srcdir)/'`symbols.c

ld_classic-symbols.obj: symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-symbols.obj `if test -f 'symbols.c'; then $(CYGPATH_W) 'symbols.c'; else $(CYGPATH_W) '$(srcdir)/symbols.c'; fi`

ld_classic-fvmlibs.o: fvmlibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-fvmlibs.o `test -f 'fvmlibs.c' || echo '$(srcdir)/'`fvmlibs.c

ld_classic-fvmlibs.obj: fvmlibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-fvmlibs.obj `if test -f 'fvmlibs.c'; then $(CYGPATH_W) 'fvmlibs.c'; else $(CYGPATH_W) '$(srcdir)/fvmlibs.c'; fi`

ld_classic-layout.o: layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-layout.o `test -f 'layout.c' || echo '$(srcdir)/'`layout.c

ld_classic-layout.obj: layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-layout.obj `if test -f 'layout.c'; then $(CYGPATH_W) 'layout.c'; else $(CYGPATH_W) '$(srcdir)/layout.c'; fi`

ld_classic-specs.o: specs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-specs.o `test -f 'specs.c' || echo '$(srcdir)/'`specs.c

ld_classic-specs.obj: specs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-specs.obj `if test -f 'specs.c'; then $(CYGPATH_W) 'specs.c'; else $(CYGPATH_W) '$(srcdir)/specs.c'; fi`

ld_classic-pass2.o: pass2.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass2.o `test -f 'pass2.c' || echo '$(srcdir)/'`pass2.c

ld_classic-pass2.obj: pass2.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass2.obj `if test -f 'pass2.c'; then $(CYGPATH_W) 'pass2.c'; else $(CYGPATH_W) '$(srcdir)/pass2.c'; fi`

ld_classic-generic_reloc.o: generic_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-generic_reloc.o `test -f 'generic_reloc.c' || echo '$(srcdir)/'`generic_reloc.c

ld_classic-generic_reloc.obj: generic_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-generic_reloc.obj `if test -f 'generic_reloc.c'; then $(CYGPATH_W) 'generic_reloc.c'; else $(CYGPATH_W) '$(srcdir)/generic_reloc.c'; fi`

ld_classic-rld.o: rld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-rld.o `test -f 'rld.c' || echo '$(srcdir)/'`rld.c

ld_classic-rld.obj: rld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-rld.obj `if test -f 'rld.c'; then $(CYGPATH_W) 'rld.c'; else $(CYGPATH_W) '$(srcdir)/rld.c'; fi`

ld_classic-sets.o: sets.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sets.o `test -f 'sets.c' || echo '$(srcdir)/'`sets.c

ld_classic-sets.obj: sets.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sets.obj `if test -f 'sets.c'; then $(CYGPATH_W) 'sets.c'; else $(CYGPATH_W) '$(srcdir)/sets.c'; fi`

ld_classic-4byte_literals.o: 4byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-4byte_literals.o `test -f '4byte_literals.c' || echo '$(srcdir)/'`4byte_literals.c

ld_classic-4byte_literals.obj: 4byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-4byte_literals.obj `if test -f '4byte_literals.c'; then $(CYGPATH_W) '4byte_literals.c'; else $(CYGPATH_W) '$(srcdir)/4byte_literals.c'; fi`

ld_classic-8byte_literals.o: 8byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-8byte_literals.o `test -f '8byte_literals.c' || echo '$(srcdir)/'`8byte_literals.c

ld_classic-8byte_literals.obj: 8byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-8byte_literals.obj `if test -f '8byte_literals.c'; then $(CYGPATH_W) '8byte_literals.c'; else $(CYGPATH_W) '$(srcdir)/8byte_literals.c'; fi`

ld_classic-literal_pointers.o: literal_pointers.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-literal_pointers.o `test -f 'literal_pointers.c' || echo '$(srcdir)/'`literal_pointers.c

ld_classic-literal_pointers.obj: literal_pointers.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-literal_pointers.obj `if test -f 'literal_pointers.c'; then $(CYGPATH_W) 'literal_pointers.c'; else $(CYGPATH_W) '$(srcdir)/literal_pointers.c'; fi`

ld_classic-dylibs.o: dylibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-dylibs.o `test -f 'dylibs.c' || echo '$(srcdir)/'`dylibs.c

ld_classic-dylibs.obj: dylibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-dylibs.obj `if test -f 'dylibs.c'; then $(CYGPATH_W) 'dylibs.c'; else $(CYGPATH_W) '$(srcdir)/dylibs.c'; fi`

ld_classic-indirect_sections.o: indirect_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-indirect_sections.o `test -f 'indirect_sections.c' || echo '$(srcdir)/'`indirect_sections.c

ld_classic-indirect_sections.obj: indirect_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-indirect_sections.obj `if test -f 'indirect_sections.c'; then $(CYGPATH_W) 'indirect_sections.c'; else $(CYGPATH_W) '$(srcdir)/indirect_sections.c'; fi`

ld_classic-mod_sections.o: mod_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-mod_sections.o `test -f 'mod_sections.c' || echo '$(srcdir)/'`mod_sections.c

ld_classic-mod_sections.obj: mod_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-mod_sections.obj `if test -f 'mod_sections.c'; then $(CYGPATH_W) 'mod_sections.c'; else $(CYGPATH_W) '$(srcdir)/mod_sections.c'; fi`

ld_classic-i860_reloc.o: i860_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-i860_reloc.o `test -f 'i860_reloc.c' || echo '$(srcdir)/'`i860_reloc.c

ld_classic-i860_reloc.obj: i860_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-i860_reloc.obj `if test -f 'i860_reloc.c'; then $(CYGPATH_W) 'i860_reloc.c'; else $(CYGPATH_W) '$(srcdir)/i860_reloc.c'; fi`

ld_classic-ppc_reloc.o: ppc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ppc_reloc.o `test -f 'ppc_reloc.c' || echo '$(srcdir)/'`ppc_reloc.c

ld_classic-ppc_reloc.obj: ppc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ppc_reloc.obj `if test -f 'ppc_reloc.c'; then $(CYGPATH_W) 'ppc_reloc.c'; else $(CYGPATH_W) '$(srcdir)/ppc_reloc.c'; fi`

ld_classic-m88k_reloc.o: m88k_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-m88k_reloc.o `test -f 'm88k_reloc.c' || echo '$(srcdir)/'`m88k_reloc.c

ld_classic-m88k_reloc.obj: m88k_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-m88k_reloc.obj `if test -f 'm88k_reloc.c'; then $(CYGPATH_W) 'm88k_reloc.c'; else $(CYGPATH_W) '$(srcdir)/m88k_reloc.c'; fi`

ld_classic-hppa_reloc.o: hppa_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-hppa_reloc.o `test -f 'hppa_reloc.c' || echo '$(srcdir)/'`hppa_reloc.c

ld_classic-hppa_reloc.obj: hppa_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-hppa_reloc.obj `if test -f 'hppa_reloc.c'; then $(CYGPATH_W) 'hppa_reloc.c'; else $(CYGPATH_W) '$(srcdir)/hppa_reloc.c'; fi`

ld_classic-sparc_reloc.o: sparc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sparc_reloc.o `test -f 'sparc_reloc.c' || echo '$(srcdir)/'`sparc_reloc.c

ld_classic-sparc_reloc.obj: sparc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sparc_reloc.obj `if test -f 'sparc_reloc.c'; then $(CYGPATH_W) 'sparc_reloc.c'; else $(CYGPATH_W) '$(srcdir)/sparc_reloc.c'; fi`

ld_classic-coalesced_sections.o: coalesced_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-coalesced_sections.o `test -f 'coalesced_sections.c' || echo '$(srcdir)/'`coalesced_sections.c

ld_classic-coalesced_sections.obj: coalesced_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-coalesced_sections.obj `if test -f 'coalesced_sections.c'; then $(CYGPATH_W) 'coalesced_sections.c'; else $(CYGPATH_W) '$(srcdir)/coalesced_sections.c'; fi`

ld_classic-uuid.o: uuid.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-uuid.o `test -f 'uuid.c' || echo '$(srcdir)/'`uuid.c

ld_classic-uuid.obj: uuid.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-uuid.obj `if test -f 'uuid.c'; then $(CYGPATH_W) 'uuid.c'; else $(CYGPATH_W) '$(srcdir)/uuid.c'; fi`

ld_classic-debugcompunit.o: debugcompunit.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugcompunit.o `test -f 'debugcompunit.c' || echo '$(srcdir)/'`debugcompunit.c

ld_classic-debugcompunit.obj: debugcompunit.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugcompunit.obj `if test -f 'debugcompunit.c'; then $(CYGPATH_W) 'debugcompunit.c'; else $(CYGPATH_W) '$(srcdir)/debugcompunit.c'; fi`

ld_classic-debugline.o: debugline.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugline.o `test -f 'debugline.c' || echo '$(srcdir)/'`debugline.c

ld_classic-debugline.obj: debugline.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugline.obj `if test -f 'debugline.c'; then $(CYGPATH_W) 'debugline.c'; else $(CYGPATH_W) '$(srcdir)/debugline.c'; fi`

ld_classic-arm_reloc.o: arm_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-arm_reloc.o `test -f 'arm_reloc.c' || echo '$(srcdir)/'`arm_reloc.c

ld_classic-arm_reloc.obj: arm_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-arm_reloc.obj `if test -f 'arm_reloc.c'; then $(CYGPATH_W) 'arm_reloc.c'; else $(CYGPATH_W) '$(srcdir)/arm_reloc.c'; fi`

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(PROGRAMS)
installdirs:
	for dir in "$(DESTDIR)$(bindir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am: install-binPROGRAMS

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-binPROGRAMS

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
	clean-binPROGRAMS clean-generic clean-libtool cscopelist-am \
	ctags ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-binPROGRAMS \
	install-data install-data-am install-dvi install-dvi-am \
	install-exec install-exec-am install-html install-html-am \
	install-info install-info-am install-man install-pdf \
	install-pdf-am install-ps install-ps-am install-strip \
	installcheck installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-compile \
	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
	tags tags-am uninstall uninstall-am uninstall-binPROGRAMS

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/Makefile.am                              0100644 0001750 0001750 00000001240 12612724205 023067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        bin_PROGRAMS = ld_classic 
ld_classic_LDADD =  \
        $(top_builddir)/libstuff/libstuff.la   $(UUID_LIB)

ld_classic_CFLAGS = -D__DARWIN_UNIX03 -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff $(WARNINGS) $(LTO_DEF) $(ENDIAN_FLAG) -DDEBUG

ld_classic_SOURCES =  \
	ld.c pass1.c objects.c sections.c cstring_literals.c symbols.c \
	fvmlibs.c layout.c specs.c pass2.c generic_reloc.c rld.c sets.c \
	4byte_literals.c 8byte_literals.c literal_pointers.c dylibs.c \
	indirect_sections.c mod_sections.c i860_reloc.c ppc_reloc.c \
	m88k_reloc.c hppa_reloc.c sparc_reloc.c coalesced_sections.c uuid.c \
	debugcompunit.c debugline.c arm_reloc.c
                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/Makefile.in                              0100644 0001750 0001750 00000106061 12612724226 023112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
bin_PROGRAMS = ld_classic$(EXEEXT)
subdir = ld
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__installdirs = "$(DESTDIR)$(bindir)"
PROGRAMS = $(bin_PROGRAMS)
am_ld_classic_OBJECTS = ld_classic-ld.$(OBJEXT) \
	ld_classic-pass1.$(OBJEXT) ld_classic-objects.$(OBJEXT) \
	ld_classic-sections.$(OBJEXT) \
	ld_classic-cstring_literals.$(OBJEXT) \
	ld_classic-symbols.$(OBJEXT) ld_classic-fvmlibs.$(OBJEXT) \
	ld_classic-layout.$(OBJEXT) ld_classic-specs.$(OBJEXT) \
	ld_classic-pass2.$(OBJEXT) ld_classic-generic_reloc.$(OBJEXT) \
	ld_classic-rld.$(OBJEXT) ld_classic-sets.$(OBJEXT) \
	ld_classic-4byte_literals.$(OBJEXT) \
	ld_classic-8byte_literals.$(OBJEXT) \
	ld_classic-literal_pointers.$(OBJEXT) \
	ld_classic-dylibs.$(OBJEXT) \
	ld_classic-indirect_sections.$(OBJEXT) \
	ld_classic-mod_sections.$(OBJEXT) \
	ld_classic-i860_reloc.$(OBJEXT) ld_classic-ppc_reloc.$(OBJEXT) \
	ld_classic-m88k_reloc.$(OBJEXT) \
	ld_classic-hppa_reloc.$(OBJEXT) \
	ld_classic-sparc_reloc.$(OBJEXT) \
	ld_classic-coalesced_sections.$(OBJEXT) \
	ld_classic-uuid.$(OBJEXT) ld_classic-debugcompunit.$(OBJEXT) \
	ld_classic-debugline.$(OBJEXT) ld_classic-arm_reloc.$(OBJEXT)
ld_classic_OBJECTS = $(am_ld_classic_OBJECTS)
am__DEPENDENCIES_1 =
ld_classic_DEPENDENCIES = $(top_builddir)/libstuff/libstuff.la \
	$(am__DEPENDENCIES_1)
AM_V_lt = $(am__v_lt_@AM_V@)
am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
am__v_lt_0 = --silent
am__v_lt_1 = 
ld_classic_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ld_classic_CFLAGS) \
	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.@am__isrc@
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_@AM_V@)
am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_@AM_V@)
am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(ld_classic_SOURCES)
DIST_SOURCES = $(ld_classic_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
ld_classic_LDADD = \
        $(top_builddir)/libstuff/libstuff.la   $(UUID_LIB)

ld_classic_CFLAGS = -D__DARWIN_UNIX03 -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff $(WARNINGS) $(LTO_DEF) $(ENDIAN_FLAG) -DDEBUG
ld_classic_SOURCES = \
	ld.c pass1.c objects.c sections.c cstring_literals.c symbols.c \
	fvmlibs.c layout.c specs.c pass2.c generic_reloc.c rld.c sets.c \
	4byte_literals.c 8byte_literals.c literal_pointers.c dylibs.c \
	indirect_sections.c mod_sections.c i860_reloc.c ppc_reloc.c \
	m88k_reloc.c hppa_reloc.c sparc_reloc.c coalesced_sections.c uuid.c \
	debugcompunit.c debugline.c arm_reloc.c

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-binPROGRAMS: $(bin_PROGRAMS)
	@$(NORMAL_INSTALL)
	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(bindir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
	fi; \
	for p in $$list; do echo "$$p $$p"; done | \
	sed 's/$(EXEEXT)$$//' | \
	while read p p1; do if test -f $$p \
	 || test -f $$p1 \
	  ; then echo "$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n;h' \
	    -e 's|.*|.|' \
	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
	sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
	    else { print "f", $$3 "/" $$4, $$1; } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	    test -z "$$files" || { \
	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
	    } \
	; done

uninstall-binPROGRAMS:
	@$(NORMAL_UNINSTALL)
	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
	files=`for p in $$list; do echo "$$p"; done | \
	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
	      -e 's/$$/$(EXEEXT)/' \
	`; \
	test -n "$$list" || exit 0; \
	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
	cd "$(DESTDIR)$(bindir)" && rm -f $$files

clean-binPROGRAMS:
	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
	echo " rm -f" $$list; \
	rm -f $$list || exit $$?; \
	test -n "$(EXEEXT)" || exit 0; \
	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
	echo " rm -f" $$list; \
	rm -f $$list

ld_classic$(EXEEXT): $(ld_classic_OBJECTS) $(ld_classic_DEPENDENCIES) $(EXTRA_ld_classic_DEPENDENCIES) 
	@rm -f ld_classic$(EXEEXT)
	$(AM_V_CCLD)$(ld_classic_LINK) $(ld_classic_OBJECTS) $(ld_classic_LDADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

ld_classic-ld.o: ld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ld.o `test -f 'ld.c' || echo '$(srcdir)/'`ld.c

ld_classic-ld.obj: ld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ld.obj `if test -f 'ld.c'; then $(CYGPATH_W) 'ld.c'; else $(CYGPATH_W) '$(srcdir)/ld.c'; fi`

ld_classic-pass1.o: pass1.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass1.o `test -f 'pass1.c' || echo '$(srcdir)/'`pass1.c

ld_classic-pass1.obj: pass1.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass1.obj `if test -f 'pass1.c'; then $(CYGPATH_W) 'pass1.c'; else $(CYGPATH_W) '$(srcdir)/pass1.c'; fi`

ld_classic-objects.o: objects.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-objects.o `test -f 'objects.c' || echo '$(srcdir)/'`objects.c

ld_classic-objects.obj: objects.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-objects.obj `if test -f 'objects.c'; then $(CYGPATH_W) 'objects.c'; else $(CYGPATH_W) '$(srcdir)/objects.c'; fi`

ld_classic-sections.o: sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sections.o `test -f 'sections.c' || echo '$(srcdir)/'`sections.c

ld_classic-sections.obj: sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sections.obj `if test -f 'sections.c'; then $(CYGPATH_W) 'sections.c'; else $(CYGPATH_W) '$(srcdir)/sections.c'; fi`

ld_classic-cstring_literals.o: cstring_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-cstring_literals.o `test -f 'cstring_literals.c' || echo '$(srcdir)/'`cstring_literals.c

ld_classic-cstring_literals.obj: cstring_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-cstring_literals.obj `if test -f 'cstring_literals.c'; then $(CYGPATH_W) 'cstring_literals.c'; else $(CYGPATH_W) '$(srcdir)/cstring_literals.c'; fi`

ld_classic-symbols.o: symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-symbols.o `test -f 'symbols.c' || echo '$(srcdir)/'`symbols.c

ld_classic-symbols.obj: symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-symbols.obj `if test -f 'symbols.c'; then $(CYGPATH_W) 'symbols.c'; else $(CYGPATH_W) '$(srcdir)/symbols.c'; fi`

ld_classic-fvmlibs.o: fvmlibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-fvmlibs.o `test -f 'fvmlibs.c' || echo '$(srcdir)/'`fvmlibs.c

ld_classic-fvmlibs.obj: fvmlibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-fvmlibs.obj `if test -f 'fvmlibs.c'; then $(CYGPATH_W) 'fvmlibs.c'; else $(CYGPATH_W) '$(srcdir)/fvmlibs.c'; fi`

ld_classic-layout.o: layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-layout.o `test -f 'layout.c' || echo '$(srcdir)/'`layout.c

ld_classic-layout.obj: layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-layout.obj `if test -f 'layout.c'; then $(CYGPATH_W) 'layout.c'; else $(CYGPATH_W) '$(srcdir)/layout.c'; fi`

ld_classic-specs.o: specs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-specs.o `test -f 'specs.c' || echo '$(srcdir)/'`specs.c

ld_classic-specs.obj: specs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-specs.obj `if test -f 'specs.c'; then $(CYGPATH_W) 'specs.c'; else $(CYGPATH_W) '$(srcdir)/specs.c'; fi`

ld_classic-pass2.o: pass2.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass2.o `test -f 'pass2.c' || echo '$(srcdir)/'`pass2.c

ld_classic-pass2.obj: pass2.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-pass2.obj `if test -f 'pass2.c'; then $(CYGPATH_W) 'pass2.c'; else $(CYGPATH_W) '$(srcdir)/pass2.c'; fi`

ld_classic-generic_reloc.o: generic_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-generic_reloc.o `test -f 'generic_reloc.c' || echo '$(srcdir)/'`generic_reloc.c

ld_classic-generic_reloc.obj: generic_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-generic_reloc.obj `if test -f 'generic_reloc.c'; then $(CYGPATH_W) 'generic_reloc.c'; else $(CYGPATH_W) '$(srcdir)/generic_reloc.c'; fi`

ld_classic-rld.o: rld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-rld.o `test -f 'rld.c' || echo '$(srcdir)/'`rld.c

ld_classic-rld.obj: rld.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-rld.obj `if test -f 'rld.c'; then $(CYGPATH_W) 'rld.c'; else $(CYGPATH_W) '$(srcdir)/rld.c'; fi`

ld_classic-sets.o: sets.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sets.o `test -f 'sets.c' || echo '$(srcdir)/'`sets.c

ld_classic-sets.obj: sets.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sets.obj `if test -f 'sets.c'; then $(CYGPATH_W) 'sets.c'; else $(CYGPATH_W) '$(srcdir)/sets.c'; fi`

ld_classic-4byte_literals.o: 4byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-4byte_literals.o `test -f '4byte_literals.c' || echo '$(srcdir)/'`4byte_literals.c

ld_classic-4byte_literals.obj: 4byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-4byte_literals.obj `if test -f '4byte_literals.c'; then $(CYGPATH_W) '4byte_literals.c'; else $(CYGPATH_W) '$(srcdir)/4byte_literals.c'; fi`

ld_classic-8byte_literals.o: 8byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-8byte_literals.o `test -f '8byte_literals.c' || echo '$(srcdir)/'`8byte_literals.c

ld_classic-8byte_literals.obj: 8byte_literals.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-8byte_literals.obj `if test -f '8byte_literals.c'; then $(CYGPATH_W) '8byte_literals.c'; else $(CYGPATH_W) '$(srcdir)/8byte_literals.c'; fi`

ld_classic-literal_pointers.o: literal_pointers.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-literal_pointers.o `test -f 'literal_pointers.c' || echo '$(srcdir)/'`literal_pointers.c

ld_classic-literal_pointers.obj: literal_pointers.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-literal_pointers.obj `if test -f 'literal_pointers.c'; then $(CYGPATH_W) 'literal_pointers.c'; else $(CYGPATH_W) '$(srcdir)/literal_pointers.c'; fi`

ld_classic-dylibs.o: dylibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-dylibs.o `test -f 'dylibs.c' || echo '$(srcdir)/'`dylibs.c

ld_classic-dylibs.obj: dylibs.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-dylibs.obj `if test -f 'dylibs.c'; then $(CYGPATH_W) 'dylibs.c'; else $(CYGPATH_W) '$(srcdir)/dylibs.c'; fi`

ld_classic-indirect_sections.o: indirect_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-indirect_sections.o `test -f 'indirect_sections.c' || echo '$(srcdir)/'`indirect_sections.c

ld_classic-indirect_sections.obj: indirect_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-indirect_sections.obj `if test -f 'indirect_sections.c'; then $(CYGPATH_W) 'indirect_sections.c'; else $(CYGPATH_W) '$(srcdir)/indirect_sections.c'; fi`

ld_classic-mod_sections.o: mod_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-mod_sections.o `test -f 'mod_sections.c' || echo '$(srcdir)/'`mod_sections.c

ld_classic-mod_sections.obj: mod_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-mod_sections.obj `if test -f 'mod_sections.c'; then $(CYGPATH_W) 'mod_sections.c'; else $(CYGPATH_W) '$(srcdir)/mod_sections.c'; fi`

ld_classic-i860_reloc.o: i860_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-i860_reloc.o `test -f 'i860_reloc.c' || echo '$(srcdir)/'`i860_reloc.c

ld_classic-i860_reloc.obj: i860_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-i860_reloc.obj `if test -f 'i860_reloc.c'; then $(CYGPATH_W) 'i860_reloc.c'; else $(CYGPATH_W) '$(srcdir)/i860_reloc.c'; fi`

ld_classic-ppc_reloc.o: ppc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ppc_reloc.o `test -f 'ppc_reloc.c' || echo '$(srcdir)/'`ppc_reloc.c

ld_classic-ppc_reloc.obj: ppc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-ppc_reloc.obj `if test -f 'ppc_reloc.c'; then $(CYGPATH_W) 'ppc_reloc.c'; else $(CYGPATH_W) '$(srcdir)/ppc_reloc.c'; fi`

ld_classic-m88k_reloc.o: m88k_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-m88k_reloc.o `test -f 'm88k_reloc.c' || echo '$(srcdir)/'`m88k_reloc.c

ld_classic-m88k_reloc.obj: m88k_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-m88k_reloc.obj `if test -f 'm88k_reloc.c'; then $(CYGPATH_W) 'm88k_reloc.c'; else $(CYGPATH_W) '$(srcdir)/m88k_reloc.c'; fi`

ld_classic-hppa_reloc.o: hppa_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-hppa_reloc.o `test -f 'hppa_reloc.c' || echo '$(srcdir)/'`hppa_reloc.c

ld_classic-hppa_reloc.obj: hppa_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-hppa_reloc.obj `if test -f 'hppa_reloc.c'; then $(CYGPATH_W) 'hppa_reloc.c'; else $(CYGPATH_W) '$(srcdir)/hppa_reloc.c'; fi`

ld_classic-sparc_reloc.o: sparc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sparc_reloc.o `test -f 'sparc_reloc.c' || echo '$(srcdir)/'`sparc_reloc.c

ld_classic-sparc_reloc.obj: sparc_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-sparc_reloc.obj `if test -f 'sparc_reloc.c'; then $(CYGPATH_W) 'sparc_reloc.c'; else $(CYGPATH_W) '$(srcdir)/sparc_reloc.c'; fi`

ld_classic-coalesced_sections.o: coalesced_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-coalesced_sections.o `test -f 'coalesced_sections.c' || echo '$(srcdir)/'`coalesced_sections.c

ld_classic-coalesced_sections.obj: coalesced_sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-coalesced_sections.obj `if test -f 'coalesced_sections.c'; then $(CYGPATH_W) 'coalesced_sections.c'; else $(CYGPATH_W) '$(srcdir)/coalesced_sections.c'; fi`

ld_classic-uuid.o: uuid.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-uuid.o `test -f 'uuid.c' || echo '$(srcdir)/'`uuid.c

ld_classic-uuid.obj: uuid.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-uuid.obj `if test -f 'uuid.c'; then $(CYGPATH_W) 'uuid.c'; else $(CYGPATH_W) '$(srcdir)/uuid.c'; fi`

ld_classic-debugcompunit.o: debugcompunit.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugcompunit.o `test -f 'debugcompunit.c' || echo '$(srcdir)/'`debugcompunit.c

ld_classic-debugcompunit.obj: debugcompunit.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugcompunit.obj `if test -f 'debugcompunit.c'; then $(CYGPATH_W) 'debugcompunit.c'; else $(CYGPATH_W) '$(srcdir)/debugcompunit.c'; fi`

ld_classic-debugline.o: debugline.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugline.o `test -f 'debugline.c' || echo '$(srcdir)/'`debugline.c

ld_classic-debugline.obj: debugline.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-debugline.obj `if test -f 'debugline.c'; then $(CYGPATH_W) 'debugline.c'; else $(CYGPATH_W) '$(srcdir)/debugline.c'; fi`

ld_classic-arm_reloc.o: arm_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-arm_reloc.o `test -f 'arm_reloc.c' || echo '$(srcdir)/'`arm_reloc.c

ld_classic-arm_reloc.obj: arm_reloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ld_classic_CFLAGS) $(CFLAGS) -c -o ld_classic-arm_reloc.obj `if test -f 'arm_reloc.c'; then $(CYGPATH_W) 'arm_reloc.c'; else $(CYGPATH_W) '$(srcdir)/arm_reloc.c'; fi`

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(PROGRAMS)
installdirs:
	for dir in "$(DESTDIR)$(bindir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am: install-binPROGRAMS

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-binPROGRAMS

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
	clean-binPROGRAMS clean-generic clean-libtool cscopelist-am \
	ctags ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-binPROGRAMS \
	install-data install-data-am install-dvi install-dvi-am \
	install-exec install-exec-am install-html install-html-am \
	install-info install-info-am install-man install-pdf \
	install-pdf-am install-ps install-ps-am install-strip \
	installcheck installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-compile \
	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
	tags tags-am uninstall uninstall-am uninstall-binPROGRAMS

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/arm_reloc.c                              0100644 0001750 0001750 00000137535 12612724205 023163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to do relocation for the arm.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/arm/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "arm_reloc.h"
#include "indirect_sections.h"
#include "dylibs.h"

#define U_ABS(l) (((long)(l))<0 ? (unsigned long)(-(l)) : (l))

/*
 * arm_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 *
 * Or if refs is not NULL it is being called by to get the addresses or
 * merged_symbols from the item being referenced by the relocation entry(s) at
 * reloc_index. This is used by mark_fine_relocs_references_live() when
 * -dead_strip is specified to determined what is being referenced and is only
 * called when all sections have fine_relocs (that is why refs is only filled
 * in when nfine_relocs != 0). When refs is not NULL, only refs is filled in
 * and returned and the contents are not relocated.
 */
__private_extern__
void
arm_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map,
struct live_refs *refs,
unsigned long reloc_index)
{
    unsigned long i, j, symbolnum, value, input_pc, output_pc;
    unsigned long instruction, immediate, low_bit;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc, relocated_extern_thumb_symbol;
    enum bool relocated_extern_arm_symbol;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_arm r_type, pair_r_type;
    unsigned long other_half;
    unsigned long offset;
    unsigned long br14_disp_sign;

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler "warnings: ... may be used uninitialized in this
	 * function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	instruction = 0;
	other_half = 0;
	immediate = 0;
	offset = 0;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	pair_local_map = NULL;
#endif /* defined(DEBUG) || defined(RLD) */

	if(refs != NULL)
	    memset(refs, '\0', sizeof(struct live_refs));
	else
	    reloc_index = 0;
	for(i = reloc_index; i < section_map->s->nreloc; i++){
	    br14_disp_sign = 0;
	    force_extern_reloc = FALSE;
	    relocated_extern_thumb_symbol = FALSE;
	    relocated_extern_arm_symbol = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_arm)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a ARM_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * ARM_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A ARM_RELOC_PAIR
		 * only follows ARM_RELOC_{SECTDIFF,LOCAL_SECTDIFF} relocation
		 * types and it is an error to see one otherwise.
		 */
		if(r_type == ARM_RELOC_PAIR){
		    error_with_cur_obj("stray relocation ARM_RELOC_PAIR entry "
			"(%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_arm)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * ARM_RELOC_PAIR relocation types only follows ARM_RELOC_{SECTDIFF,
	     * LOCAL_SECTDIFF} relocation types and it is an error to see one
	     * otherwise.
	     */
	    if(r_type == ARM_RELOC_PAIR){
		error_with_cur_obj("stray relocation ARM_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section (Note
	     * that this is not the case for ARM_RELOC_PAIR entries but this
	     * can't be one with the above checks).
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.
	     */
	    pair_r_type = (enum reloc_type_arm)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == ARM_RELOC_SECTDIFF ||
	       r_type == ARM_RELOC_LOCAL_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is ARM_RELOC_SECTDIFF but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_arm)spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
			other_half = spair_reloc->r_address;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != ARM_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"ARM_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry (or scattered entry).
	     */
	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in arm_reloc() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in arm_reloc() symbol index %lu "
			    "in above file not in undefined map", symbolnum);
		    }
		}
		if(refs == NULL && 
		   ((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		    (get_output_section(merged_symbol->nlist.n_sect)->
		     flags & SECTION_TYPE) == S_COALESCED)){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;

		/*
		 * If we are being called only to get the references for this
		 * relocation entry fill it in and return.
		 */
		if(refs != NULL){
		    refs->ref1.ref_type = LIVE_REF_SYMBOL;
		    refs->ref1.merged_symbol = merged_symbol;
		    refs->ref2.ref_type = LIVE_REF_NONE;
		    return;
		}

		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * Pointers to thumb symbols must have their low bit set
		     * only after they have been relocated.  Also arm BL 
		     * instructions to thumb symbols must be conveted to BLX
		     * instructions. This external relocation entry will be
		     * relocated, so if it is for a thumb symbol then set
		     * relocated_extern_thumb_symbol so it can be used later.
		     */
		    if((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF))
			relocated_extern_thumb_symbol = TRUE;
		    else
			relocated_extern_arm_symbol = TRUE;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    input_pc = section_map->s->addr + r_address;
		    if(r_type == ARM_RELOC_VANILLA){
			switch(r_length){
			case 0: /* byte */
			    offset = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    offset = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    offset = get_long((long *)(contents + r_address));
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
			if(r_pcrel)
			    offset += input_pc;
		    }
		    else{
			instruction = get_long((long *)(contents + r_address));
			switch(r_type){
			case ARM_RELOC_BR24:
			    offset = instruction & 0x00ffffff;
			    /* sign extend if needed */
			    if((offset & 0x00800000) != 0)
				offset |= 0xff000000;
			    /* The value in the instruction is shifted by 2 */
			    offset = offset << 2;
			    /*
			     * Note the pc added will be +8 from the pc of the
			     * branch instruction.  And the assembler creating
			     * this instruction takes that into account when
			     * calculating the displacement in the instruction.
			     */
			    if(r_pcrel)
				offset += input_pc;
			    break;
			case ARM_THUMB_RELOC_BR22:
			    /*
			     * The code below assumes ARM is little endian
			     * such that "the first 16-bit thumb instruction"
			     * is the low 16 bits and "the second 16-bit thumb	
			     * instruction" is the high 16 bits of the 32-bits
			     * in the variable instruction.
			     */
			    /* the first instruction has the upper eleven bits 
			       of the two byte displacement */
			    offset = (instruction & 0x7FF) << 12;
			    /* sign extend if needed */
			    if((offset & 0x400000) != 0)
				offset |= 0xFF800000;
			    /* the second instruction has the lower eleven bits 
			        of the two byte displacement.  Add that times
				two to get the offset added to the symbol */
			    offset += 2*((instruction >> 16) & 0x7FF);
			    /*
			     * Note the pc added will be +4 from the pc of the
			     * branch instruction.  And the assembler creating
			     * this instruction takes that into account when
			     * calculating the displacement in the instruction.
			     */
			    if(r_pcrel)
				offset += input_pc;
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
		    }
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT)
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum == R_ABS){
		    /*
		     * If we are being called only to get the references for
		     * this relocation entry fill in it has none and return.
		     */
		    if(refs != NULL){
			refs->ref1.ref_type = LIVE_REF_NONE;
			refs->ref2.ref_type = LIVE_REF_NONE;
			return;
		    }
		}
		else{
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    pair_local_map = NULL;
		    if(r_type == ARM_RELOC_SECTDIFF ||
		       r_type == ARM_RELOC_LOCAL_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == ARM_RELOC_SECTDIFF ||
			   r_type == ARM_RELOC_LOCAL_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation the value is set (not adjusted
			 * with addition).  So the new value is directly
			 * calculated from the old value.
			 */
			if(r_pcrel){
			    input_pc = section_map->s->addr +
				       r_address;
			    if(section_map->nfine_relocs == 0)
				output_pc = section_map->output_section->s.addr
					    + section_map->offset +
					    r_address;
			    else
				output_pc = section_map->output_section->s.addr
					    + 
					fine_reloc_output_offset(section_map,
								 r_address);
			}
			else{
			    input_pc = 0;
			    output_pc = 0;
			}
			/*
			 * Get the value of the expresion of the item to be
			 * relocated.
			 */
			if(r_type == ARM_RELOC_VANILLA ||
			   r_type == ARM_RELOC_SECTDIFF ||
			   r_type == ARM_RELOC_LOCAL_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				value = get_byte((char *)(contents +
							  r_address));
				break;
			    case 1: /* word (2 byte) */
				value = get_short((short *)(contents +
							    r_address));
				break;
			    case 2: /* long (4 byte) */
				value = get_long((long *)(contents +
							  r_address));
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			else{
			    instruction = get_long((long *)(contents +
							    r_address));
			    switch(r_type){
			    case ARM_RELOC_BR24:
				value = instruction & 0x00ffffff;
				if((value & 0x00800000) != 0)
				    value |= 0xff000000;
				/* The value (displacement) is shifted by 2 */
				value = value << 2;
				/*
				 * For a BLX instruction, set bit[1] of the
				 * result to the H bit.
				 */
				if((instruction & 0xff000000) == 0xfb000000)
				    value |= 0x2;
				/* The pc added will be +8 from the pc */
				value += 8;
				break;
			    case ARM_THUMB_RELOC_BR22:
				/*
				 * The code below assumes ARM is little endian
				 * such that "the first 16-bit thumb
				 * instruction" is the low 16 bits and "the
				 * second 16-bit thumb instruction" is the high
				 * 16 bits of the 32-bits in the variable
				 * instruction.
				 */
				/* the first instruction has the upper eleven
				   bits of the two byte displacement */
				value = (instruction & 0x7FF) << 12;
				/* sign extend if needed */
				if((value & 0x400000) != 0)
				    value |= 0xFF800000;
				/* the second instruction has the lower eleven
				   bits of the two byte displacement.  Add that 
				   times two to get the target address */
				value += 2*((instruction >> 16) & 0x7FF);
				/* The pc added will be +4 from the pc */
				value += 4;
				/*
				 * For BLX, the resulting address is forced to
				 * be word-aligned by clearing bit[1].
				 */
				if(((instruction & 0x18000000) == 0x08000000) &&
				   ((input_pc + value) & 0x2))
				  value -= 2;
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			if(r_type == ARM_RELOC_SECTDIFF ||
			   r_type == ARM_RELOC_LOCAL_SECTDIFF){
			    /*
			     * For ARM_RELOC_SECTDIFF's the item to be
			     * relocated, in value, is the value of the
			     * expression:
			     *     r_value - pair_r_value + offset
			     * To set the value of the relocated expression,
			     * it is set from relocating the two r_value's and
			     * adding back in the offset.  So here get the
			     * offset from the value of the expression.
			     */
			    value += input_pc; /* adjust for pcrel */
			    offset = value - r_value + pair_r_value;

			    /*
			     * If we are being called only to get the references
			     * for this relocation entry fill it in and return.
			     */
			    if(refs != NULL){
				fine_reloc_output_ref(
				    local_map,
				    r_value - local_map->s->addr,
				    &(refs->ref1) );
				fine_reloc_output_ref(
				    local_map,
				    pair_r_value - local_map->s->addr,
				    &(refs->ref2) );
				return;
			    }

			    /*
			     * Now build up the value of the relocated
			     * expression one part at a time.  First set the
			     * new value to the relocated r_value.
			     */
		    	    if(local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    local_map, r_value - local_map->s->addr,
				    i,
				    r_type != ARM_RELOC_LOCAL_SECTDIFF);
				value = fine_reloc_output_address(local_map,
					    r_value - local_map->s->addr,
					    local_map->output_section->s.addr);
			    }
			    else{
				value = local_map->output_section->s.addr +
					local_map->offset +
					r_value - local_map->s->addr;
			    }
			    /* Second subtract the relocated pair_r_value. */
			    if(pair_local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    pair_local_map, pair_r_value -
				    pair_local_map->s->addr, i, TRUE);
				value -=
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
				        pair_local_map->output_section->s.addr);
			    }
			    else{
				value -=
				    pair_local_map->output_section->s.addr +
				    pair_local_map->offset +
				    pair_r_value - pair_local_map->s->addr;
			    }
			    /* Third add in the offset. */
			    value += offset;
			    value -= output_pc; /* adjust for pcrel */
			}
			else{
			    /*
			     * If the relocation entry is not a scattered
			     * relocation entry then the relocation is based on
			     * the value of value of the expresion of the item
			     * to be relocated.  If it is a scattered relocation
			     * entry then the relocation is based on the r_value
			     * in the relocation entry and the offset part of
			     * the expression at the item to be relocated is
			     * extracted so it can be added after the relocation
			     * is done.
			     */
			    value += input_pc;
			    if(r_scattered == 0){
				r_value = value;
				offset = 0;
			    }
			    else{
				offset = value - r_value;
			    }
			    /*
			     * Check to see if this reference is legal with
			     * respect to indirect sections.
			     */
			    legal_reference(section_map, r_address, local_map,
				    r_value - local_map->s->addr + offset, i,
				    FALSE);

			    /*
			     * If we are being called only to get the references
			     * for this relocation entry fill it in and return.
			     */
			    if(refs != NULL){
				fine_reloc_output_ref(
				    local_map,
				    r_value - local_map->s->addr,
				    &(refs->ref1) );
				refs->ref2.ref_type = LIVE_REF_NONE;
				return;
			    }

			    value = fine_reloc_output_address(local_map,
					r_value - local_map->s->addr,
					local_map->output_section->s.addr);
			    value -= output_pc;
			    value += offset;
			}
			if(r_type == ARM_RELOC_VANILLA ||
			   r_type == ARM_RELOC_LOCAL_SECTDIFF ||
			   r_type == ARM_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				if( (value & 0xffffff00) &&
				   ((value & 0xffffff80) != 0xffffff80))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 1 byte", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_byte((char *)(contents + r_address), value);
				break;
			    case 1: /* word (2 byte) */
				if( (value & 0xffff0000) &&
				   ((value & 0xffff8000) != 0xffff8000))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 2 bytes", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_short((short *)(contents + r_address),
					  value);
				break;
			    case 2: /* long (4 byte) */
				set_long((long *)(contents + r_address), value);
				break;
			    default:
				error_with_cur_obj("r_length field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			}
			else{
			    switch(r_type){
			    case ARM_RELOC_BR24:
				/* The pc added will be +8 from the pc */
				value -= 8;
				/*
				 * An ARM BLX targetting an ARM symbol or
				 * a local symbol needs to be converted to a
				 * BL.  This could happen if it was originally
				 * targetting a thumb stub which will be
				 * optimized away.
				 */
				if(((fine_reloc_arm(local_map,
					r_value - local_map->s->addr) == TRUE) ||
				    (fine_reloc_local(local_map,
					r_value - local_map->s->addr) == TRUE)) &&
				   ((instruction & 0xfe000000) == 0xfa000000))
				    instruction = 0xeb000000;
				/*
				 * For arm branch instructions if the target is 
				 * a thumb symbol it must be converted to a
				 * branch and exchange instruction (unless it
				 * already is one).
				 */
				if((fine_reloc_thumb(local_map,
					r_value - local_map->s->addr) == TRUE) ||
				   ((instruction & 0xfe000000) == 0xfa000000)){
				    /*
				     * Only unconditional BL can be converted
				     * to BLX
				     */
				    if(((instruction & 0xff000000) != 0xeb000000) &&
				       ((instruction & 0xfe000000) != 0xfa000000))
					error_with_cur_obj("relocation error "
					    "for relocation entry %lu in "
					    "section (%.16s,%.16s) (branch "
					    "cannot be converted to BLX)", i,
					    section_map->s->segname,
					    section_map->s->sectname);
				    /*
				     * The H bit of the BLX instruction (bit 24)
				     * contains bit 1 of the target address.
				     */
				    instruction = (0xfa000000 |
						   ((value & 0x2) << 23));
				    /*
				     * This code assumes the thumb symbol
				     * address is two byte aligned.  This next
				     * line clears the last two bits so the next
				     * test will not cause an error
				     */
				    value &= ~0x2;
				}
				if((value & 0x3) != 0)
				    error_with_cur_obj("relocation error "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement not a "
					"multiple of 4 bytes)", i,
					section_map->s->segname,
					section_map->s->sectname);
				if((value & 0xfe000000) != 0xfe000000 &&
				   (value & 0xfe000000) != 0x00000000)
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
				instruction = (instruction & 0xff000000) |
					      ((value >> 2) & 0x00ffffff);
				break;
			    case ARM_THUMB_RELOC_BR22:
				/* The pc added will be +4 from the pc */
				value -= 4;
				/*
				 * Here we have a BL instruction targetting an
				 * arm symbol -- convert it to a BLX
				 */
				if((fine_reloc_arm(local_map,
					r_value - local_map->s->addr) == TRUE) &&
				   ((instruction & 0xf800f800) == 0xf800f000))
				    instruction &= 0xefffffff;
				/*
				 * Here we have a BLX instruction targetting a
				 * thumb symbol or a local symbol (which we will
				 * boldly assume to be thumb in the absence of
				 * any evidence to the contrary)  -- convert it
				 * to a BL
				 */
				if(((fine_reloc_thumb(local_map,
					r_value - local_map->s->addr) == TRUE) ||
				    (fine_reloc_local(local_map,
					r_value - local_map->s->addr) == TRUE)) &&
				   ((instruction & 0xf800f800) == 0xe800f000))
				    instruction |= 0x10000000;
				/* immediate must be multiple of four bytes.
				 * This enforces the requirement that
				 * instruction[0] must be zero for a BLX.
				 */
				if((instruction & 0xf800f800) == 0xe800f000 &&
				   (value & 0x2) != 0)
				    value += 2;
				instruction = (instruction & 0xf800f800) |
					      (value & 0x7ff000) >> 12 |
					      (value & 0xffe) << 15;
				break;
			    default:
				error_with_cur_obj("r_type field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			    set_long((long *)(contents + r_address),
				     instruction);
			}

			goto update_reloc;
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr /* + r_address */
			     - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else
		    value += + section_map->s->addr + r_address
			     - (section_map->output_section->s.addr +
			        fine_reloc_output_offset(section_map,
							 r_address));
	    }
	    if(r_type == ARM_RELOC_VANILLA ||
	       r_type == ARM_RELOC_LOCAL_SECTDIFF ||
	       r_type == ARM_RELOC_SECTDIFF){
		/*
		 * Pointers to thumb symbols must have their low bit set, but
		 * only after they have been relocated.  Code above determined
		 * if this is and external relocation entry for a thumb symbol
		 * that is being relocated and if so set 
		 * relocated_extern_thumb_symbol.  So now if this is a VANILLA
		 * relocation entry for a pointer set the low bit from
		 * relocated_extern_thumb_symbol.
		 */
		if(r_type == ARM_RELOC_VANILLA)
		    low_bit = (relocated_extern_thumb_symbol == TRUE) ? 1 : 0;
		else
		    low_bit = 0;
		/*
		 * This is part of the cctools_aek-thumb-hack branch.  It seems
		 * like a reasonable error check but I don't see how it could
		 * ever get triggered by any code going though the assember.
		 */
		if(r_type == ARM_RELOC_VANILLA && 
		   relocated_extern_thumb_symbol == TRUE && r_pcrel)
		    error_with_cur_obj("relocation for entry %lu in section "
			"(%.16s,%.16s) is VANILLA PC-relative to a thumb "
			"symbol %s", i, section_map->s->segname,
			section_map->s->sectname,
			merged_symbol->nlist.n_un.n_name);
		switch(r_length){
		case 0: /* byte */
		    value += get_byte((char *)(contents + r_address));
		    if( (value & 0xffffff00) &&
		       ((value & 0xffffff80) != 0xffffff80))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 1 byte", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_byte((char *)(contents + r_address), value | low_bit);
		    break;
		case 1: /* word (2 byte) */
		    value += get_short((short *)(contents + r_address));
		    if( (value & 0xffff0000) &&
		       ((value & 0xffff8000) != 0xffff8000))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 2 bytes", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_short((short *)(contents + r_address), value | low_bit);
		    break;
		case 2: /* long (4 byte) */
		    value += get_long((long *)(contents + r_address));
		    set_long((long *)(contents + r_address), value | low_bit);
		    break;
		default:
		    error_with_cur_obj("r_length field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * Do arm specific relocation based on the r_type.
	     */
	    else{
		instruction = get_long((long *)(contents + r_address));
		switch(r_type){
		case ARM_RELOC_BR24:
		    immediate = instruction & 0x00ffffff;
		    if((immediate & 0x00800000) != 0)
			immediate |= 0xff000000;
		    /* The value in the instruction is shifted by 2 */
		    immediate = immediate << 2;
		    /* In a BLX, bit 1 of the immediate is at bit 24
		     * of the instruction.
		     */
		    if((instruction & 0xfe000000) == 0xfa000000)
			immediate |= (instruction & 0x01000000) >> 23;
		    immediate += value;
		    /*
		     * Here we have a BLX instruction that targets an
		     * arm symbol -- convert it to a BL instruction.
		     */
		    if((r_extern == TRUE) &&
		       (relocated_extern_arm_symbol == TRUE) &&
		       ((instruction & 0xfe000000) == 0xfa000000))
			instruction = 0xeb000000;
		    /*
		     * For arm branch instructions if the target is a thumb 
		     * symbol it must be converted to a branch and exchange
		     * instruction (unless it already is one).
		     */
		    else if(((r_extern == TRUE) &&
			     (relocated_extern_thumb_symbol == TRUE)) ||
			    ((instruction & 0xfe000000) == 0xfa000000)){
			/* only unconditional BL can be converted to BLX */
			if(((instruction & 0xff000000) != 0xeb000000) &&
			   ((instruction & 0xfe000000) != 0xfa000000))
			    error_with_cur_obj("relocation error for relocation"
				" entry %lu in section (%.16s,%.16s) (branch "
				"cannot be converted to BLX)", i,
				section_map->s->segname,
				section_map->s->sectname);
			/* the H bit of the BLX instruction (bit 24) contains 
			   bit 1 of the target address */
			instruction = (0xfa000000 | ((immediate & 0x2) << 23));
			/* this code assumes the thumb symbol address is two
			   byte aligned.  This next line clears the last two
			   bits so the next test will not cause an error */
			immediate &= ~0x2;
		    }
		    if((immediate & 0x3) != 0)
			error_with_cur_obj("relocation error for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "not a multiple of 4 bytes)", i,
			    section_map->s->segname, section_map->s->sectname);
		    if((immediate & 0xfe000000) != 0xfe000000 &&
		       (immediate & 0xfe000000) != 0x00000000)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    instruction = (instruction & 0xff000000) |
		    		  (immediate & 0x03ffffff) >> 2;
		    break;
		case ARM_THUMB_RELOC_BR22:
		    /*
		     * The code below assumes ARM is little endian such that
		     * "the first 16-bit thumb instruction" is the low 16 bits
		     * and "the second 16-bit thumb instruction" is the high 16 
		     * bits of the 32-bits in the variable instruction.
		     */
		    /* the first instruction has the upper eleven bits of the
		       two byte displacement */
		    immediate = (instruction & 0x7FF) << 12;
		    /* sign extend if needed */
		    if((immediate & 0x400000) != 0)
			immediate |= 0xFF800000;
		    /* the second instruction has the lower eleven bits of the
		       two byte displacement.  Add that times two to get the
		       target address */
		    immediate += 2*((instruction >> 16) & 0x7FF);
		    /*
		     * For BLX, the resulting address is forced to be word-
		     * aligned by clearing bit[1].
		     */
		    if((instruction & 0xf800f800) == 0xe800f000 &&
		       (r_address & 0x2))
			immediate -= 2;
		    immediate += value;
		    /*
		     * The target address for a thumb branch must be to a
		     * two-byte address.
		     */
		    if((immediate & 0x1) != 0)
			error_with_cur_obj("relocation error for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "not a multiple of 2 bytes)", i,
			    section_map->s->segname, section_map->s->sectname);
		    /*
		     * Here we have a BLX instruction that targets a
		     * thumb symbol -- convert it to a BL instruction.
		     */
		    if((r_extern == TRUE) &&
		       (relocated_extern_thumb_symbol == TRUE) &&
		       ((instruction & 0xf800f800) == 0xe800f000))
			instruction |= 0x10000000;
		    /*
		     * For thumb branch instructions if the target is not a
		     * thumb symbol (an arm symbol) it must be converted to a
		     * branch and exchange instruction (if it is not already
		     * one).
		     */
		    if(r_extern == TRUE &&
		       relocated_extern_arm_symbol == TRUE &&
		       (instruction & 0xf800f800) != 0xe800f000){
			/* Make sure we have a high+low BL */
			if((instruction & 0xf800f800) != 0xf800f000)
			    error_with_cur_obj("relocation error for relocation"
				" entry %lu in section (%.16s,%.16s) (unknown "
				"branch type)", i, section_map->s->segname, 
				section_map->s->sectname);
			/* Convert BL to BLX: clear top H bit of second insr */
			instruction &= 0xefffffff;
		    }
		    /* immediate must be multiple of four bytes.
		     * This enforces the requirement that
		     * instruction[0] must be zero for a BLX.
		     */
		    if((instruction & 0xf800f800) == 0xe800f000 &&
		       (immediate & 0x2) != 0)
			immediate += 2;
		    if((immediate & 0xffc00000) != 0xffc00000 &&
		       (immediate & 0xffc00000) != 0x00000000)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    instruction = (instruction & 0xf800f800) |
				  (immediate & 0x7ff000) >> 12 |
				  (immediate & 0xffe) << 15;
		    break;
		case ARM_THUMB_32BIT_BRANCH:
		    break;
		default:
		    error_with_cur_obj("r_type field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		set_long((long *)(contents + r_address), instruction);
	    }

	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
update_reloc:
	    ;
#ifndef RLD
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a ARM_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = ARM_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		            (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		            force_extern_reloc == FALSE &&
		            ((filetype != MH_DYLIB ||
			      multi_module_dylib == FALSE) ||
			     (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value and the output is not for
			     * dyld make it a scattered relocation entry else
			     * make it a local relocation entry.
			     */
			    if(offset == 0 || output_for_dyld){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = r_type;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a ARM_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = ARM_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    else if(reloc->r_symbolnum != R_ABS){
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		}
		else{
		    /*
		     * This is a scattered relocation entry.  If the output is
		     * for dyld convert it to a local relocation entry so as
		     * to not overflow the 24-bit r_address field in a scattered
		     * relocation entry.  The overflow would happen in
		     * reloc_output_for_dyld() in sections.c when it adjusts
		     * the r_address fields of the relocation entries.
		     */
		    if(output_for_dyld){
			reloc = (struct relocation_info *)sreloc;
			r_scattered = 0;
			reloc->r_address = r_address;
			reloc->r_pcrel = r_pcrel;
			reloc->r_extern = 0;
			reloc->r_length = r_length;
			reloc->r_type = r_type;
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		    else{
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(local_map->nfine_relocs == 0)
			    sreloc->r_value +=
					   - local_map->s->addr
					   + local_map->output_section->s.addr +
					   local_map->offset;
			else
			    sreloc->r_value =
					fine_reloc_output_address(local_map,
						r_value - local_map->s->addr,
					   local_map->output_section->s.addr);
		    }
		}
		/*
		 * If this section that the reloation is being done for has fine
		 * relocation then the offset in the r_address field has to be
		 * set to where it will end up in the output file.  Otherwise
		 * it simply has to have the offset to where this contents
		 * appears in the output file. 
		 */
		if(r_scattered == 0){
		    if(section_map->nfine_relocs == 0){
			reloc->r_address += section_map->offset;
		    }
		    else{
			reloc->r_address = fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		else{
		    if(section_map->nfine_relocs == 0){
			/* this can overflow the 24-bit sreloc->r_address */
			sreloc->r_address += section_map->offset;
		    }
		    else{
			sreloc->r_address =fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == ARM_RELOC_PAIR){
		    if(pair_reloc != NULL){
			/* I don't think arm has any pairs that are not
			   scattered relocs so this should never happen */
			pair_reloc->r_address = other_half;
		    }
		    else if(spair_reloc != NULL){
			if(r_type == ARM_RELOC_SECTDIFF ||
			   r_type == ARM_RELOC_LOCAL_SECTDIFF){
			    /*
			     * For ARM_RELOC_SECTDIFF relocation entries (which
			     * are always scattered types) the r_value field is
			     * relocated.
			     */
			    if(pair_local_map->nfine_relocs == 0)
				spair_reloc->r_value +=
				    - pair_local_map->s->addr
				    + (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			    else
				spair_reloc->r_value =
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
					pair_local_map->output_section->s.addr);
			}
		    }
		    else{
			fatal("internal error, in arm_reloc() pair_r_type "
			    "is ARM_RELOC_PAIR but pair_reloc and spair_reloc "
			    "are NULL");
		    }
		}
	    }
#endif /* !defined(RLD) */
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == ARM_RELOC_PAIR)
		i++;
	}
}
                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/arm_reloc.h                              0100644 0001750 0001750 00000002721 12612724205 023154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file arm_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void arm_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *section_map,
    struct live_refs *refs,
    unsigned long reloc_index);
                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/coalesced_sections.c                     0100644 0001750 0001750 00000065771 12612724205 025053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with indirect sections (both
 * lazy and non-lazy symbol pointer sections as well as symbol stub sections). 
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/stab.h>
#include <mach-o/reloc.h>
#include <mach-o/ppc/reloc.h>
#include <mach-o/hppa/reloc.h>
#include "stuff/arch.h"
#include "stuff/reloc.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "pass1.h"
#include "symbols.h"
#include "layout.h"
#include "coalesced_sections.h"
#include "dylibs.h"

/*
 * coalesced_section_merge() merges items from a coalesced section from the
 * specified section in the current object file (cur_obj).  When redo_live is
 * FALSE it allocates a fine relocation map and sets the fine_relocs field in
 * the section_map to it (as well as the count).
 *
 * When redo_live is FALSE after all the items for this section in this object
 * file have been merged two more things are done.  First the number of
 * relocation entries that will be in the output file is adjusted (incremented)
 * based on which items are used from this object's section.  Second the number
 * of local symbol table entries and the size of the string table is adjusted
 * (decremented) based on the which symbols are in the items from this object's
 * section that will be in the resulting object file.
 * 
 * When redo_live is TRUE it re-merges only the live items from a coalesced
 * section from the specified section in the current object file (cur_obj).
 */
__private_extern__
void
coalesced_section_merge(
void *data,
struct merged_section *ms,
struct section *s, 
struct section_map *section_map,
enum bool redo_live)
{
    unsigned long i, j, nsect, count;
    struct nlist *object_symbols;
    char *object_strings;
    enum bool start_section;
    struct load_order *load_orders;
    struct fine_reloc *fine_relocs;
    struct merged_symbol *merged_symbol;
    struct relocation_info *relocs, reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_pcrel, r_length, r_type, pair_r_type, r_extern,
		  r_symbolnum, r_scattered, pair, r_value;
    struct undefined_map *undefined_map;
#ifndef RLD
    enum bool pic;
#endif
    enum bool defined, force_extern_reloc;

	pair_r_type = 0;
	/*
	 * If the size of the section is zero there is nothing to merge.
	 */
	if(s->size == 0)
	    return;

	merged_symbol = NULL;

	/*
	 * Figure out the nsect in the object file we are about to merge.
	 * This is so we can count the symbols that match this nsect which
	 * are defined in this section.
	 */
	nsect = 0;
	for(i = 0; i < cur_obj->nsection_maps; i++){
	    if(&(cur_obj->section_maps[i]) == section_map){
		nsect = i + 1;
		break;
	    }
	}
	if(nsect == 0){
	    fatal("internal error: coalesced_section_merge() called "
		"with bad section_map for section (%.16s,%.16s)",
		s->segname, s->sectname);
	}

	/*
	 * Count the number of symbols in this section in this object file.
	 * Check to see if there is a symbol at the beginning of the section.
	 * and that all symbols defined in this section are global.
	 */
	count = 0;
	start_section = FALSE;
	if(cur_obj->symtab != NULL){
	    object_symbols = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
	    object_strings = (char *)(cur_obj->obj_addr +
				      cur_obj->symtab->stroff);
	}
	else{
	    object_symbols = NULL;
	    object_strings = NULL;
	}
	if(redo_live == TRUE)
	    goto set_load_orders;

	if(cur_obj->symtab != NULL){
	    for(i = 0; i < cur_obj->symtab->nsyms; i++){
		if((object_symbols[i].n_type & N_TYPE) == N_SECT &&
		    object_symbols[i].n_sect == nsect &&
		   (object_symbols[i].n_type & N_STAB) == 0){
		    count++;
/*
 * Allow private extern and local symbols.
 */
#ifdef notdef
		    if((object_symbols[i].n_type & (N_EXT|N_PEXT)) ==
		       (N_EXT|N_PEXT)){
			error_with_cur_obj("malformed object (symbol: %s in "
			    "S_COALESCE section (%.16s,%.16s) can't be a "
			    "private extern symbol)",
			    object_strings + object_symbols[i].n_un.n_strx,
			    s->segname, s->sectname);
			return;
		    }
		    if((object_symbols[i].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("malformed object (symbol: %s in "
			    "S_COALESCE section (%.16s,%.16s) not an external "
			    "symbol)",
			    object_strings + object_symbols[i].n_un.n_strx,
			    s->segname, s->sectname);
			return;
		    }
#endif
		    if(object_symbols[i].n_value == s->addr)
			start_section = TRUE;
		}
	    }
	}
	if(start_section == FALSE){
	    error_with_cur_obj("malformed object (section (%.16s,%.16s) no "
		"symbol at start of coalesced section)",s->segname,s->sectname);
	    return;
	}

set_load_orders:
	/*
	 * Allocate a load order map for the symbols in this section.
	 * We are not ordering the section but simpily needing to figure out
	 * the sizes and offsets of each symbol and a load order map is now
	 * this is normally done.
	 */
	if(redo_live == FALSE){
	    load_orders = allocate(sizeof(struct load_order) * count);
	    memset(load_orders, '\0', sizeof(struct load_order) * count);
	    section_map->load_orders = load_orders;
	    section_map->nload_orders = count;
	}
	else{
	    load_orders = section_map->load_orders;
	    count = section_map->nload_orders;
	    goto deal_with_contents;
	}

	/*
	 * Fill in symbol names and values the load order map for this section
	 * in this object file.
	 */
	j = 0;
	for(i = 0; i < cur_obj->symtab->nsyms; i++){
	    if((object_symbols[i].n_type & N_TYPE) == N_SECT &&
	        object_symbols[i].n_sect == nsect &&
	       (object_symbols[i].n_type & N_STAB) == 0){
		load_orders[j].name = object_strings +
			      object_symbols[i].n_un.n_strx;
		load_orders[j].value =
			      object_symbols[i].n_value;
		/*
		 * We fill in the 'global_coalesced_symbol' field with a
		 * boolean test of if the symbol is external or not.  See
		 * below where this is used.
		 */
		load_orders[j].global_coalesced_symbol =
			      (object_symbols[i].n_type & N_EXT) == N_EXT;
		j++;
	    }
	}

#ifdef DEBUG
	if(debug & (1 << 14))
	    print_load_order(load_orders, count, ms,
			     cur_obj, "names and values");
#endif /* DEBUG */

	/*
	 * Sort the load order map by symbol value so the
	 * size and input offset fields can be set.
	 */
	qsort(load_orders,
	      count,
	      sizeof(struct load_order),
	      (int (*)(const void *, const void *))qsort_load_order_values);
	/*
	 * Set the input offset and size fields.
	 */
	for(i = 0; i < count - 1; i++){
	    load_orders[i].input_offset =
			   load_orders[i].value -
			   s->addr;
	    load_orders[i].input_size =
			   load_orders[i + 1].value -
			   load_orders[i].value;
	}
	load_orders[i].input_offset =
			   load_orders[i].value -
			   s->addr;
	load_orders[i].input_size =
			   s->addr + s->size -
			   load_orders[i].value;
#ifdef DEBUG
	if(debug & (1 << 15))
	    print_load_order(load_orders, count, ms,
			     cur_obj, "sizes and offsets");
#endif /* DEBUG */

deal_with_contents:
	/*
	 * First deal with the contents of section for each symbol and determine
	 * based on the symbol if the contents will be used from this object or
	 * used from a previously merged object.  This information is encoded
	 * into the fine_reloc structures for each item.
	 */
	if(redo_live == FALSE){
	    fine_relocs = allocate(count * sizeof(struct fine_reloc));
	    memset(fine_relocs, '\0', count * sizeof(struct fine_reloc));
	    section_map->fine_relocs = fine_relocs;
	    section_map->nfine_relocs = count;
	}
	else{
            fine_relocs = section_map->fine_relocs;
            count = section_map->nfine_relocs;
	}
	for(i = 0; i < count; i++){
	    if(redo_live == FALSE)
		fine_relocs[i].input_offset = load_orders[i].input_offset;
	    /*
	     * We previously filled in the 'global_coalesced_symbol' field with 
	     * a boolean test of if the symbol is external or not.  See above
	     * where this is done.
	     */
	    if(load_orders[i].global_coalesced_symbol == TRUE){
		merged_symbol = lookup_symbol(load_orders[i].name);
		if(merged_symbol->name_len == 0)
		    fatal("internal error, coalesced_section_merge() failed in "
			  "looking up external symbol: %s",load_orders[i].name);
		/*
		 * If the merged symbol comes from this object then this
		 * object's contents will be used.  If not it won't.
		 */
		if(merged_symbol->definition_object == cur_obj){
		    if(redo_live == FALSE){
			fine_relocs[i].use_contents = TRUE;
			fine_relocs[i].indirect_defined = FALSE;
		    }
		    if(redo_live == FALSE || fine_relocs[i].live == TRUE){
			/* align size before using it to assign output offset */
			ms->s.size = align_to_input_mod(ms->s.size,
						fine_relocs[i].input_offset,
						ms->s.align);
			fine_relocs[i].output_offset = ms->s.size;
			ms->s.size += load_orders[i].input_size;
		    }
		}
		else{
		    if(redo_live == FALSE){
			fine_relocs[i].use_contents = FALSE;
			fine_relocs[i].indirect_defined = FALSE;
			fine_relocs[i].merged_symbol = merged_symbol;
		    }
		}
		/*
		 * We want to set local_symbol to TRUE if this symbol is a
		 * private extern symbol so that section difference relocation
		 * entries to it are not flagged as illegal references.
		 */
		if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT){
		    if(redo_live == FALSE)
			fine_relocs[i].local_symbol = TRUE;
		}
		else{
		    if(redo_live == FALSE)
			fine_relocs[i].local_symbol = FALSE;
		}
	    }
	    else{
		/*
		 * This is a local or private_extern symbol so keep its
		 * contents.
		 */
		if(redo_live == FALSE){
		    fine_relocs[i].use_contents = TRUE;
		    fine_relocs[i].local_symbol = TRUE;
		    fine_relocs[i].indirect_defined = FALSE;
		}
		if(redo_live == FALSE || fine_relocs[i].live == TRUE){
		    /* align size before using it to assign output offset */
		    ms->s.size = align_to_input_mod(ms->s.size,
					            fine_relocs[i].input_offset,
					            ms->s.align);
		    fine_relocs[i].output_offset = ms->s.size;
		    ms->s.size += load_orders[i].input_size;
		}
	    }
	}

#ifdef COALESCE_DEBUG
	/*
	 * For debugging print out the fine relocs we created for this section.
	 */
	printf("Fine relocs created for coalesced section (%.16s,%.16s) in ",
	       s->segname, s->sectname);
	print_obj_name(cur_obj);
	printf("\n");
	for(i = 0; i < count; i++){
	    printf("fine_relocs[%lu] load_orders[%lu].name = %s\n",
		   i, i, load_orders[i].name);
	    printf("\tuse_contents = %s\n", fine_relocs[i].use_contents == TRUE
		   ? "TRUE" : "FALSE");
	    printf("\tlocal_symbol = %s\n", fine_relocs[i].local_symbol == TRUE
		   ? "TRUE" : "FALSE");
	    printf("\tinput_offset = %d\n", fine_relocs[i].input_offset);
	    if(fine_relocs[i].use_contents == TRUE)
		printf("\toutput_offset = %ld\n", fine_relocs[i].output_offset);
	    else{
		merged_symbol = fine_relocs[i].merged_symbol;
		printf("\t%s from ", merged_symbol->nlist.n_un.n_name);
		print_obj_name(merged_symbol->definition_object);
		printf("\n");
	    }
	}
#endif

	/*
	 * Second deal with the relocation entries for the section in this
	 * object file.  Now that it has been determined for which items the 
	 * contents will be used from this object file.
	 */

	/*
	 * This loop loops through the relocation entries and using the
	 * use_contents field (via a call to fine_reloc_offset_in_output())		 * of the fine_relocs just created determines how many relocation
	 * entries will be in the output for this section of this object file.
	 */
	relocs = (struct relocation_info *)(cur_obj->obj_addr + s->reloff);
	for(i = 0; i < s->nreloc; i++){
	    reloc = relocs[i];
	    if(cur_obj->swapped &&
	       section_map->input_relocs_already_swapped == FALSE)
		swap_relocation_info(&reloc, 1, host_byte_sex);
	    /*
	     * Break out the fields of the relocation entry we need here.
	     */
	    if((reloc.r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(&reloc);
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_type = sreloc->r_type;
		r_extern = 0;
		r_value = sreloc->r_value;
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		r_scattered = 0;
		r_address = reloc.r_address;
		r_pcrel = reloc.r_pcrel;
		r_length = reloc.r_length;
		r_type = reloc.r_type;
		r_extern = reloc.r_extern;
		r_symbolnum = reloc.r_symbolnum;
	    }
	    /*
	     * Make sure that this is not a stray PAIR relocation entry.
	     */
	    if(r_type == reloc_pair_r_type(arch_flag.cputype)){
		error_with_cur_obj("malformed object (stray relocation PAIR "
		    "entry (%lu) in section (%.16s,%.16s))", i, s->segname,
		    s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section.
	     */
	    if(r_address >= s->size){
		error_with_cur_obj("malformed object (r_address (0x%x) field "
		    "of relocation entry %ld in section (%.16s,%.16s) out of "
		    "range)",(unsigned int)r_address, i,s->segname,s->sectname);
		continue;
	    }
	    /*
	     * If this relocation entry is suppose to have a PAIR make sure it
	     * does.
	     */
	    if(reloc_has_pair(arch_flag.cputype, r_type)){
		if(i + 1 < s->nreloc){
		    reloc = relocs[i + 1];
		    if(cur_obj->swapped &&
		       section_map->input_relocs_already_swapped == FALSE)
			swap_relocation_info(&reloc, 1, host_byte_sex);
		    if((reloc.r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
                                      &reloc;
                        pair_r_type = spair_reloc->r_type;
		    }
		    else{
                        pair_r_type = reloc.r_type;
		    }
		}
		if(i + 1 >= s->nreloc ||
		   pair_r_type != reloc_pair_r_type(arch_flag.cputype)){
		    error_with_cur_obj("malformed object (relocation entry "
			"(%lu) in section (%.16s,%.16s) missing following "
			"associated PAIR entry)", i, s->segname, s->sectname);
                    continue;
                }
	    }

	    /*
	     * Assumed the symbol for this relocation entry is defined (always
	     * true for local relocation entries).  Then reset the variable
	     * "defined" correctly if this is an external relocation entry based
	     * on if the symbol is defined, where it is defined and the output
	     * file type.
	     */
	    defined = TRUE;
	    force_extern_reloc = FALSE;
	    if(output_for_dyld && r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined symbol to be used in an external relocation entry
		 * or a global coalesced symbol.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, s->segname, s->sectname);
		    continue;
		}
		undefined_map = bsearch(&r_symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		       (merged_symbol->definition_object->section_maps[
			merged_symbol->nlist.n_sect - 1].s->flags &
			SECTION_TYPE) == S_COALESCED){
			if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			    keep_private_externs == FALSE) ||
			   dynamic == FALSE ||
			   (output_for_dyld && has_dynamic_linker_command))
			    force_extern_reloc = FALSE;
			else
			    force_extern_reloc = TRUE;
		    }
		}
		else{
		    if((object_symbols[r_symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((object_symbols[r_symbolnum].n_type & N_TYPE) ==
			N_SECT &&
		       (cur_obj->section_maps[object_symbols[r_symbolnum].
			n_sect-1].s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(object_strings +
				     object_symbols[r_symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in coalesced_section_merge()"
				  " failed to lookup coalesced symbol %s",
				  object_strings +
				  object_symbols[r_symbolnum].n_un.n_strx);
			}
			/*
			 * While the .o file's symbol is a coalesced symbol, it
			 * may have been weak and the merged symbol now being
			 * used is not a coalesced symbol. In that case we don't
			 * force an external relocation entry.
			 */
			if(((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
			    (merged_symbol->definition_object->section_maps[
			      merged_symbol->nlist.n_sect-1].
			      s->flags & SECTION_TYPE) != S_COALESCED) ||
			  ((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			    keep_private_externs == FALSE) ||
			    dynamic == FALSE ||
			   (output_for_dyld && has_dynamic_linker_command))
			    force_extern_reloc = FALSE;
			else
			    force_extern_reloc = TRUE;
		    }
		    else{
			if(object_symbols[r_symbolnum].n_type !=
			   (N_EXT | N_UNDF)){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", r_symbolnum, i,
				section_map->s->segname,
				section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in coalesced_section_merge() "
			    "symbol index %lu in above file not in undefined "
			    "map", r_symbolnum);
		    }
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * Is the merged symbol for this external relocation entry
		 * defined in the output file.
		 */
		if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		   merged_symbol->nlist.n_type == (N_EXT | N_PBUD) ||
		   (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		    merged_symbol->defined_in_dylib == TRUE))
		    defined = FALSE;
		else
		    defined = TRUE;
	    }
	    if(reloc_has_pair(arch_flag.cputype, r_type))
		pair = 1;
	    else
		pair = 0;

	    /*
	     * For output_for_dyld PPC_RELOC_JBSR and HPPA_RELOC_JBSR's are
	     * never put out.
	     */
	    if(output_for_dyld &&
	       ((arch_flag.cputype == CPU_TYPE_POWERPC &&
		 r_type == PPC_RELOC_JBSR) ||
	        (arch_flag.cputype == CPU_TYPE_HPPA &&
		 r_type == HPPA_RELOC_JBSR)) ){
		i += pair;
		continue;
	    }
#ifndef RLD
	    /*
	     * If saving relocation entries see if this relocation entry is for 
	     * an item that is going to be in the output file and if so count it
	     * as one of the output relocation entries.
	     */
	    if(output_for_dyld &&
	       fine_reloc_offset_in_output(section_map, r_address)){
		/*
		 * Mark this section as being relocated (staticly).
		 */
		if(dead_strip == FALSE || redo_live == TRUE)
		    ms->relocated = TRUE;
		if(r_extern == 0)
		    pic = (enum bool)
			  (reloc_is_sectdiff(arch_flag.cputype, r_type) ||
			   (r_pcrel == 1 && r_symbolnum != NO_SECT));
		else
		    pic = (enum bool)
			  (r_pcrel == 1 &&
			   (merged_symbol->nlist.n_type & N_TYPE) == N_SECT);
		/*
		 * The number of relocation entries in the output file is based
		 * on one of three different cases:
		 *  The output file is a multi module dynamic shared library
		 *  The output file has a dynamic linker load command
		 *  The output does not have a dynamic linker load command
		 */
		if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		    /*
		     * For a multi module dynamic shared library the modules are
		     * kept separate so external relocation entries on input
		     * will be external relocation entries on output.  For local
		     * relocation entries only non-position-independent local
		     * relocation entries are kept.  Modules of dylibs are not
		     * linked together and can only be slid keeping all sections
		     * relative to each other the same.
		     */
		    if(r_extern && (merged_symbol->nlist.n_type & N_PEXT) == 0)
			section_map->nextrel += 1 + pair;
		    else if(pic == FALSE)
			section_map->nlocrel += 1 + pair;
		}
		else if(has_dynamic_linker_command){
		    /*
		     * For an file with a dynamic linker load command only
		     * external relocation entries for undefined symbols are
		     * kept.  This output file is a fixed address and can't be
		     * moved.
		     */
		    if(r_extern && defined == FALSE)
			section_map->nextrel += 1 + pair;
		}
		else{
		    /*
		     * For an file without a dynamic linker load command
		     * external relocation entries for undefined symbols are
		     * kept and locals that are non-position-independent are
		     * kept.  This file can only be slid keeping all sections
		     * relative to each other the same.
		     */
		    if(r_extern && (merged_symbol->nlist.n_type & N_PEXT) == 0){
			if(defined == FALSE || force_extern_reloc == TRUE)
			    section_map->nextrel += 1 + pair;
			else if(pic == FALSE)
			    section_map->nlocrel += 1 + pair;
		    }
		    else if(pic == FALSE)
			section_map->nlocrel += 1 + pair;
		}
	    }
	    else if(save_reloc &&
	            fine_reloc_offset_in_output(section_map, r_address)){
		ms->s.nreloc += 1 + pair;
		nreloc += 1 + pair;
	    }
#endif /* !defined(RLD) */
	    i += pair;
	}
	/*
	 * If the the number of relocation entries is not zero mark this section
	 * as being relocated (staticly).
	 */
	if(ms->s.nreloc != 0){
	    if(dead_strip == FALSE || redo_live == TRUE)
		ms->relocated = TRUE;
	}

	/*
	 * Third deal with the symbol table entries for local symbols and N_STAB
	 * symbols in this section in this object file.  Now that it has been
	 * determined for which items the contents will be used from this
	 * object file.  
	 *
	 * When -dead_strip this can't be called when redo_live is FALSE as the
	 * live marking has not been done yet. And when TRUE will get called for
	 * all sections including coalesced sections as part of
	 * count_live_symbols() calling removed_dead_local_symbols_in_section().
	 */
	if(dead_strip == FALSE)
	    discard_local_symbols_for_section(nsect, object_symbols,
					      object_strings, s, section_map);

	/*
	 * The load_orders are free()'ed if -dead_strip is not specified.  Or
	 * if this the second time we are called, when redo_live == TRUE, we
	 * are done with the load_orders so they can be free()'ed at this point.
	 */
	if(dead_strip == FALSE || redo_live == TRUE){
	    free(load_orders);
	    section_map->load_orders = NULL;
	    section_map->nload_orders = 0;
	}
}

__private_extern__
void
coalesced_section_order(
void *data,
struct merged_section *ms)
{
#ifndef RLD
    kern_return_t r;
#ifdef __MWERKS__
    struct coalesced_section_data *dummy1;
    struct merged_section *dummy2;
        dummy1 = data;
        dummy2 = ms;
#endif

	warning("section ordering for coalesced sections not supported ("
		"-sectorder %s %s %s ignored)", ms->s.segname, ms->s.sectname,
		ms->order_filename);
	/*
	 * Deallocate the memory for the load order file now that it is
	 * nolonger needed.
	 */
	if((r = vm_deallocate(mach_task_self(), (vm_address_t)
	    ms->order_addr, ms->order_size)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
		       "file: %s for section (%.16s,%.16s)",
		       ms->order_filename, ms->s.segname,
		       ms->s.sectname);
	ms->order_addr = NULL;
#else /* RLD */
#ifdef __MWERKS__
    struct coalesced_section_data *dummy1;
    struct merged_section *dummy2;
        dummy1 = data;
        dummy2 = ms;
#endif
#endif /* RLD */
}

/*
 * coalesced_section_reset_live() is called when -dead_strip is specified after
 * the coalesced sections the input objects are merged. It resets the merged
 * section size and the count of relocation entries back to zero so the live
 * coalesced items can be re-merged (by later calling coalesced_section_merge()
 * with redo_live == TRUE.
 */
__private_extern__
void
coalesced_section_reset_live(
void *data,
struct merged_section *ms)
{
	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* reset the count of relocation entries for this merged section */
	if(output_for_dyld){
	    ms->nlocrel = 0;
	    ms->nextrel = 0;
	}
	else if(save_reloc){
	    nreloc -= ms->s.nreloc;
	    ms->s.nreloc = 0;
	}
}
       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/coalesced_sections.h                     0100644 0001750 0001750 00000002713 12612724205 025043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

__private_extern__ void coalesced_section_merge(
    void *data, 
    struct merged_section *ms,
    struct section *s, 
    struct section_map *section_map,
    enum bool redo_live);

__private_extern__ void coalesced_section_order(
    void *data, 
    struct merged_section *ms);

__private_extern__ void coalesced_section_reset_live(
    void *data,
    struct merged_section *ms);
                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/cstring_literals.c                       0100644 0001750 0001750 00000055372 12612724205 024566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with literal 'C' string sections.
 * A string in this section must beable to me moved freely with respect to other
 * strings or data.  This means relocation must not reach outside the string and
 * things like: "abc"[i+20] can't be in this type of section.  Also strings
 * like: "foo\0bar" can not be in this type of section.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <limits.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/mach.h>
#include <mach/kern_return.h>
#define CHAR_MAX 0xff
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "cstring_literals.h"
#include "pass2.h"
#include "hash_string.h"
#include "symbols.h"

/*
 * cstring_merge() merges cstring literals from the specified section in the
 * current object file (cur_obj).  When redo_live is FALSE it allocates a fine
 * relocation map and sets the fine_relocs field in the section_map to it (as
 * well as the count).  When redo_live is TRUE it re-merges only the live
 * cstrings based on the live bit in the previouly allocated fine_relocs.
 */
__private_extern__
void
cstring_merge(
struct cstring_data *data,
struct merged_section *ms,
struct section *s,
struct section_map *section_map,
enum bool redo_live)
{
    unsigned long ncstrings, i;
    char *cstrings, *p;
    struct fine_reloc *fine_relocs;
 
	if(s->size == 0){
	    if(redo_live == FALSE){
		section_map->fine_relocs = NULL;
		section_map->nfine_relocs = 0;
	    }
	    return;
	}
	/*
	 * Count the number of strings so the size of the fine relocation
	 * structures can be allocated.
	 */
	ncstrings = 0;
	cstrings = cur_obj->obj_addr + s->offset;
	if(*(cstrings + s->size - 1) != '\0'){
	    error_with_cur_obj("literal C string section (%.16s,%.16s) does "
			       "not end with a '\\0'", s->segname, s->sectname);
	    return;
	}
	for(p = cstrings; p < cstrings + s->size; p += strlen(p) + 1)
	    ncstrings++;
#ifdef DEBUG
	if(redo_live == FALSE){
	    data->nfiles++;
	    data->nbytes += s->size;
	    data->ninput_strings += ncstrings;
	}
#endif /* DEBUG */

	/*
	 * We will be called the first time with redo_live == FALSE and will
	 * just merge the cstrings from the input file and create the
	 * fine_relocs.
	 */
	if(redo_live == FALSE){
	    fine_relocs = allocate(ncstrings * sizeof(struct fine_reloc));
	    memset(fine_relocs, '\0', ncstrings * sizeof(struct fine_reloc));

	    /*
	     * lookup and enter each C string in the section and record the
	     * offsets in the input file and in the output file.
	     */
	    p = cstrings;
	    for(i = 0; i < ncstrings; i++){
		fine_relocs[i].input_offset = p - cstrings;
		fine_relocs[i].output_offset = lookup_cstring(p, data, ms);
		p += strlen(p) + 1;
	    }
	    section_map->fine_relocs = fine_relocs;
	    section_map->nfine_relocs = ncstrings;
	}
	else{
	    /*
	     * redo_live == TRUE and this is being called a second time after
	     * all the cstrings were previouly merged when -dead_strip is
	     * specified.  So now we walk the fine_relocs and only re-merge the
	     * live strings.
	     */
	    fine_relocs = section_map->fine_relocs;
	    ncstrings = section_map->nfine_relocs;
	    p = cstrings;
	    for(i = 0; i < ncstrings; i++){
		if(fine_relocs[i].live == TRUE){
		    fine_relocs[i].output_offset = lookup_cstring(p, data, ms);
		}
		else{
		    fine_relocs[i].output_offset = 0;
		}
		p += strlen(p) + 1;
	    }
	}
}

/*
 * cstring_order() enters cstring literals from the order_file from the merged
 * section structure.  Since this is called before any call to cstring_merge
 * and it enters the strings in the order of the file it causes the section
 * to be ordered.
 */
__private_extern__
void
cstring_order(
struct cstring_data *data,
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, line_number, line_length, max_line_length, output_offset;
    char *buffer;
    kern_return_t r;
    struct cstring_order_line *cstring_order_lines;
 
	/*
	 * Parse the load order file by changing '\n' to '\0'.  Also check for
	 * '\0 in the file and flag them as errors.  Also determine the maximum
	 * line length of the file for the needed buffer to allocate for
	 * character translation.
	 */
	line_number = 1;
	line_length = 1;
	max_line_length = 1;
	for(i = 0; i < ms->order_size; i++){
	    if(ms->order_addr[i] == '\0'){
		fatal("format error in -sectorder file: %s line %lu character "
		      "possition %lu for section (%.16s,%.16s) (illegal null "
		      "character \'\\0\' found)", ms->order_filename,
		      line_number, line_length, ms->s.segname, ms->s.sectname);
	    }
	    if(ms->order_addr[i] == '\n'){
		ms->order_addr[i] = '\0';
		if(line_length > max_line_length)
		    max_line_length = line_length;
		line_number++;
		line_length = 1;
	    }
	    else
		line_length++;
	}

	/*
	 * Allocate the buffer to translate the order file lines' escape
	 * characters into real characters.
	 */
	buffer = allocate(max_line_length + 1);

	/*
	 * If -dead_strip is specified allocate the needed structures so that
	 * the order of the live cstrings can be recreated later by
	 * cstring_reset_live().
	 */
	cstring_order_lines = NULL;
	if(dead_strip == TRUE){
	    data->cstring_load_order_data =
		allocate(sizeof(struct cstring_load_order_data));
	    cstring_order_lines = allocate(sizeof(struct cstring_order_line) *
					   (line_number - 1));
	    data->cstring_load_order_data->order_line_buffer =
		buffer;
	    data->cstring_load_order_data->cstring_order_lines =
		cstring_order_lines;
	    data->cstring_load_order_data->ncstring_order_lines =
		(line_number - 1);
	}

	/*
	 * Process each line in the order file by translating all escape
	 * characters and then entering the cstring using lookup_cstring().
	 * If -dead_strip is specified save away the starting character index
	 * of each order line and the output offset.
	 */
	line_number = 1;
	for(i = 0; i < ms->order_size; i++){
	    if(dead_strip == TRUE)
		cstring_order_lines[line_number - 1].character_index = i;

	    get_cstring_from_sectorder(ms, &i, buffer, line_number, 1);
	    output_offset = lookup_cstring(buffer, data, ms);

	    if(dead_strip == TRUE)
		cstring_order_lines[line_number - 1].output_offset =
		    output_offset;

	    line_number++;
	}

	/*
	 * If -dead_strip is not specified free up the memory for the line
	 * buffer and the load order file.  If -dead_strip is specified these
	 * will be free'ed up in cstring_reset_live().
	 */
	if(dead_strip == FALSE){

	    /* deallocate the line buffer */
	    free(buffer);

	    /*
	     * Deallocate the memory for the load order file now that it is
	     * nolonger needed (since the memory has been written on it is
	     * always deallocated so it won't get written to the swap file
	     * unnecessarily).
	     */
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)
		ms->order_addr, ms->order_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
			   "file: %s for section (%.16s,%.16s)",
			   ms->order_filename, ms->s.segname,
			   ms->s.sectname);
	    ms->order_addr = NULL;
	}
#endif /* !defined(RLD) */
}

/*
 * cstring_reset_live() is called when -dead_strip is specified after all the
 * literals from the input objects are merged.  It clears out the cstring_data
 * so the live cstrings can be re-merged (by later calling cstring_merge() with
 * redo_live == TRUE.  In here we first merge in the live cstrings from the
 * order file if any. 
 */
__private_extern__
void
cstring_reset_live(
struct cstring_data *data,
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, ncstring_order_lines, character_index, line_number;
    char *buffer;
    struct cstring_order_line *cstring_order_lines;
    enum bool live;
    kern_return_t r;

	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* clear out the previously merged data */
	cstring_free(data);

	/*
	 * If this merged section has an order file we need to re-merged only
	 * the live cstrings from that order file.
	 */
	if(ms->order_filename != NULL){
	    buffer = data->cstring_load_order_data->order_line_buffer;
	    cstring_order_lines =
		data->cstring_load_order_data->cstring_order_lines;
	    ncstring_order_lines =
		data->cstring_load_order_data->ncstring_order_lines;
	    for(i = 0; i < ncstring_order_lines; i++){
		/*
		 * Figure out if this cstring order line's output_index is live
		 * and if so re-merge the cstring literal.
		 */
		live = is_literal_output_offset_live(
			ms, cstring_order_lines[i].output_offset);
		line_number = i + 1;
		if(live){
		    character_index = cstring_order_lines[i].character_index;
		    get_cstring_from_sectorder(ms, &character_index, buffer,
					       line_number, 1);
		    (void)lookup_cstring(buffer, data, ms);
		}
		else{
		    if(sectorder_detail == TRUE)
			warning("specification of string in -sectorder file: "
				"%s on line %lu for section (%.16s,%.16s) not "
				"used (dead stripped)", ms->order_filename,
				line_number, ms->s.segname, ms->s.sectname);
		}
	    }

	    /* deallocate the various data structures no longer needed */
	    free(data->cstring_load_order_data->order_line_buffer);
	    free(data->cstring_load_order_data->cstring_order_lines);
	    free(data->cstring_load_order_data);
	    data->cstring_load_order_data = NULL;

	    /*
	     * Deallocate the memory for the load order file now that it is
	     * nolonger needed (since the memory has been written on it is
	     * allways deallocated so it won't get written to the swap file
	     * unnecessarily).
	     */
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)
		ms->order_addr, ms->order_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
			   "file: %s for section (%.16s,%.16s)",
			   ms->order_filename, ms->s.segname,
			   ms->s.sectname);
	    ms->order_addr = NULL;
	}
#endif /* !defined(RLD) */
}

/*
 * get_cstring_from_sectorder() parses a cstring from a order file for the
 * specified merged_section, ms, starting from the index, *index the order file
 * must have had its newlines changed to '\0's previouly.  It places the parsed
 * cstring in the specified buffer, buffer and advances the index over the
 * cstring it parsed.  line_number and char_pos are used for printing error
 * messages and refer the line_number and character possition the index is at.
 */
__private_extern__
void
get_cstring_from_sectorder(
struct merged_section *ms,
unsigned long *index,
char *buffer,
unsigned long line_number,
unsigned long char_pos)
{
#ifndef RLD
    unsigned long i, j, k, char_value;
    char octal[4], hex[9];

	j = 0;
	/*
	 * See that this is not the end of a line in the order file.
	 */
	for(i = *index; i < ms->order_size && ms->order_addr[i] != '\0'; i++){
	    /*
	     * See if this character the start of an escape sequence.
	     */
	    if(ms->order_addr[i] == '\\'){
		if(i + 1 >= ms->order_size || ms->order_addr[i + 1] == '\0')
		    fatal("format error in -sectorder file: %s line %lu "
			  "character possition %lu for section (%.16s,"
			  "%.16s) (\'\\\' at the end of the line)",
			  ms->order_filename, line_number, char_pos,
			  ms->s.segname, ms->s.sectname);
		/* move past the '\\' */
		i++;
		char_pos++;
		if(ms->order_addr[i] >= '0' && ms->order_addr[i] <= '7'){
		    /* 1, 2 or 3 octal digits */
		    k = 0;
		    octal[k++] = ms->order_addr[i];
		    char_pos++;
		    if(i+1 < ms->order_size &&
		       ms->order_addr[i+1] >= '0' &&
		       ms->order_addr[i+1] <= '7'){
			octal[k++] = ms->order_addr[++i];
			char_pos++;
		    }
		    if(i+1 < ms->order_size &&
		       ms->order_addr[i+1] >= '0' &&
		       ms->order_addr[i+1] <= '7'){
			octal[k++] = ms->order_addr[++i];
			char_pos++;
		    }
		    octal[k] = '\0';
		    char_value = strtol(octal, NULL, 8);
		    if(char_value > CHAR_MAX){
			error("format error in -sectorder file: %s line %lu "
			      "for section (%.16s,%.16s) (escape sequence"
			      " ending at character possition %lu out of "
			      "range for character)", ms->order_filename,
			      line_number, ms->s.segname, ms->s.sectname,
			      char_pos - 1);
		    }
		    buffer[j++] = (char)char_value;
		}
		else{
		    switch(ms->order_addr[i]){
		    case 'n':
			buffer[j++] = '\n';
			char_pos++;
			break;
		    case 't':
			buffer[j++] = '\t';
			char_pos++;
			break;
		    case 'v':
			buffer[j++] = '\v';
			char_pos++;
			break;
		    case 'b':
			buffer[j++] = '\b';
			char_pos++;
			break;
		    case 'r':
			buffer[j++] = '\r';
			char_pos++;
			break;
		    case 'f':
			buffer[j++] = '\f';
			char_pos++;
			break;
		    case 'a':
			buffer[j++] = '\a';
			char_pos++;
			break;
		    case '\\':
			buffer[j++] = '\\';
			char_pos++;
			break;
		    case '\?':
			buffer[j++] = '\?';
			char_pos++;
			break;
		    case '\'':
			buffer[j++] = '\'';
			char_pos++;
			break;
		    case '\"':
			buffer[j++] = '\"';
			char_pos++;
			break;
		    case 'x':
			/* hex digits */
			k = 0;
			while(i+1 < ms->order_size &&
			      ((ms->order_addr[i+1] >= '0' &&
				ms->order_addr[i+1] <= '9') ||
			       (ms->order_addr[i+1] >= 'a' &&
				ms->order_addr[i+1] <= 'f') ||
			       (ms->order_addr[i+1] >= 'A' &&
				ms->order_addr[i+1] <= 'F')) ){
			    if(k <= 8)
				hex[k++] = ms->order_addr[++i];
			    else
				++i;
			    char_pos++;
			}
			if(k > 8){
			    error("format error in -sectorder file: %s line"
				  " %lu for section (%.16s,%.16s) (hex "
				  "escape ending at character possition "
				  "%lu out of range)", ms->order_filename,
				  line_number, ms->s.segname,
				  ms->s.sectname, char_pos);
			    break;
			}
			hex[k] = '\0';
			char_value = strtol(hex, NULL, 16);
			if(char_value > CHAR_MAX){
			    error("format error in -sectorder file: %s line"
				  " %lu for section (%.16s,%.16s) (escape "
				  "sequence ending at character possition "
				  "%lu out of range for character)",
				  ms->order_filename, line_number,
				  ms->s.segname, ms->s.sectname, char_pos);
			}
			buffer[j++] = (char)char_value;
			char_pos++;
			break;
		    default:
			error("format error in -sectorder file: %s line %lu "
			      "for section (%.16s,%.16s) (unknown escape "
			      "sequence ending at character possition %lu)",
			      ms->order_filename, line_number,
			      ms->s.segname, ms->s.sectname, char_pos);
			buffer[j++] = ms->order_addr[i];
			char_pos++;
			break;
		    }
		}
	    }
	    /*
	     * This character is not the start of an escape sequence so take
	     * it as it is.
	     */
	    else{
		buffer[j] = ms->order_addr[i];
		char_pos++;
		j++;
	    }
	}
	buffer[j] = '\0';
	*index = i;
#endif /* !defined(RLD) */
}

/*
 * lookup_cstring() looks up the cstring passed to it in the cstring_data
 * passed to it and returns the offset the cstring will have in the output
 * file.  It creates the hash table as needed and the blocks to store the
 * strings and attaches them to the cstring_data passed to it.  The total
 * size of the section is accumulated in ms->s.size which is the merged
 * section for this literal section.  The string is aligned to the alignment
 * in the merged section (ms->s.align).
 */
__private_extern__
unsigned long
lookup_cstring(
char *cstring,
struct cstring_data *data,
struct merged_section *ms)
{
    unsigned long hashval, len, cstring_len;
    struct cstring_bucket *bp;
    struct cstring_block **p, *cstring_block;

	if(data->hashtable == NULL){
	    data->hashtable = allocate(sizeof(struct cstring_bucket *) *
				       CSTRING_HASHSIZE);
	    memset(data->hashtable, '\0', sizeof(struct cstring_bucket *) *
					  CSTRING_HASHSIZE);
	}
#if defined(DEBUG) && defined(PROBE_COUNT)
	    data->nprobes++;
#endif
	hashval = hash_string(cstring, NULL) % CSTRING_HASHSIZE;
	for(bp = data->hashtable[hashval]; bp; bp = bp->next){
	    if(strcmp(cstring, bp->cstring) == 0)
		return(bp->offset);
#if defined(DEBUG) && defined(PROBE_COUNT)
	    data->nprobes++;
#endif
	}

	cstring_len = strlen(cstring) + 1;
	len = rnd(cstring_len, 1 << ms->s.align);
	bp = allocate(sizeof(struct cstring_bucket));
	for(p = &(data->cstring_blocks); *p ; p = &(cstring_block->next)){
	    cstring_block = *p;
	    if(cstring_block->full)
		continue;
	    if(len > cstring_block->size - cstring_block->used){
		cstring_block->full = TRUE;
		continue;
	    }
	    strcpy(cstring_block->cstrings + cstring_block->used, cstring);
	    memset(cstring_block->cstrings + cstring_block->used + cstring_len,
		   '\0', len - cstring_len);
	    bp->cstring = cstring_block->cstrings + cstring_block->used;
	    cstring_block->used += len;
	    bp->offset = ms->s.size;
	    bp->next = data->hashtable[hashval];
	    data->hashtable[hashval] = bp;
	    ms->s.size += len;
#ifdef DEBUG
	    data->noutput_strings++;
#endif /* DEBUG */
	    return(bp->offset);
	}
	*p = allocate(sizeof(struct cstring_block));
	cstring_block = *p;
	cstring_block->size = (len > host_pagesize ? len : host_pagesize);
	cstring_block->used = len;
	cstring_block->full = (len == cstring_block->size ? TRUE : FALSE);
	cstring_block->next = NULL;
	cstring_block->cstrings = allocate(cstring_block->size);
	strcpy(cstring_block->cstrings, cstring);
	memset(cstring_block->cstrings + cstring_len, '\0', len - cstring_len);
	bp->cstring = cstring_block->cstrings;
	bp->offset = ms->s.size;
	bp->next = data->hashtable[hashval];
	data->hashtable[hashval] = bp;
	ms->s.size += len;
#ifdef DEBUG
	data->noutput_strings++;
#endif /* DEBUG */
	return(bp->offset);
}

/*
 * cstring_output() copies the cstrings for the data passed to it into the 
 * output file's buffer.  The pointer to the merged section passed to it is
 * used to tell where in the output file this section goes.  Then this routine
 * called cstring_free() to free() up all space used by this data block except
 * the data block itself.
 */
__private_extern__
void
cstring_output(
struct cstring_data *data,
struct merged_section *ms)
{
    unsigned long offset;
    struct cstring_block **p, *cstring_block;

	/*
	 * Copy the blocks into the output file.
	 */
	offset = ms->s.offset;
	for(p = &(data->cstring_blocks); *p ;){
	    cstring_block = *p;
	    memcpy(output_addr + offset,
		   cstring_block->cstrings,
		   cstring_block->used);
	    offset += cstring_block->used;
	    p = &(cstring_block->next);
	}
#ifndef RLD
	output_flush(ms->s.offset, offset - ms->s.offset);
#endif /* !defined(RLD) */
	cstring_free(data);
}

/*
 * cstring_free() free()'s up all space used by this cstring_data block except
 * the data block itself.
 */
__private_extern__
void
cstring_free(
struct cstring_data *data)
{
    unsigned long i;
    struct cstring_bucket *bp, *next_bp;
    struct cstring_block *cstring_block, *next_cstring_block;

	/*
	 * Free all data for this block.
	 */
	if(data->hashtable != NULL){
	    for(i = 0; i < CSTRING_HASHSIZE; i++){
		for(bp = data->hashtable[i]; bp; ){
		    next_bp = bp->next;
		    free(bp);
		    bp = next_bp;
		}
	    }
	    free(data->hashtable);
	    data->hashtable = NULL;
	}
	for(cstring_block = data->cstring_blocks; cstring_block ;){
	    next_cstring_block = cstring_block->next;
	    free(cstring_block->cstrings);
	    free(cstring_block);
	    cstring_block = next_cstring_block;
	}
	data->cstring_blocks = NULL;
}

#ifdef DEBUG
/*
 * print_cstring_data() prints a cstring_data.  Used for debugging.
 */
__private_extern__
void
print_cstring_data(
struct cstring_data *data,
char *indent)
{
    char *s;
    struct cstring_block **p, *cstring_block;
/*
    unsigned long i;
    struct cstring_bucket *bp;
*/

	print("%sC string data at 0x%x\n", indent, (unsigned int)data);
	if(data == NULL)
	    return;
	print("%s    hashtable 0x%x\n", indent,(unsigned int)(data->hashtable));
/*
	if(data->hashtable != NULL){
	    for(i = 0; i < CSTRING_HASHSIZE; i++){
		print("%s    %-3d [0x%x]\n", indent, i, data->hashtable[i]);
		for(bp = data->hashtable[i]; bp; bp = bp->next){
		    print("%s\tcstring %s\n", indent, bp->cstring);
		    print("%s\toffset  %lu\n", indent, bp->offset);
		    print("%s\tnext    0x%x\n", indent, bp->next);
		}
	    }
	}
*/
	print("%s   cstring_blocks 0x%x\n", indent,
	      (unsigned int)(data->cstring_blocks));
	for(p = &(data->cstring_blocks); *p ; p = &(cstring_block->next)){
	    cstring_block = *p;
	    print("%s\tsize %lu\n", indent, cstring_block->size);
	    print("%s\tused %lu\n", indent, cstring_block->used);
	    if(cstring_block->full)
		print("%s\tfull TRUE\n", indent);
	    else
		print("%s\tfull FALSE\n", indent);
	    print("%s\tnext 0x%x\n", indent,
		  (unsigned int)(cstring_block->next));
	    print("%s\tcstrings\n", indent);
	    for(s = cstring_block->cstrings;
	        s < cstring_block->cstrings + cstring_block->used;
	        s += strlen(s) + 1){
		print("%s\t    %s\n", indent, s);
	    }
	}
}

/*
 * cstring_data_stats() prints the cstring_data stats.  Used for tuning.
 */
__private_extern__
void
cstring_data_stats(
struct cstring_data *data,
struct merged_section *ms)
{
	if(data == NULL)
	    return;
	print("literal cstring section (%.16s,%.16s) contains:\n",
	      ms->s.segname, ms->s.sectname);
	print("    %u bytes of merged strings\n", ms->s.size);
	print("    from %lu files and %lu total bytes from those "
	      "files\n", data->nfiles, data->nbytes);
	print("    average number of bytes per file %g\n",
	      (double)((double)data->nbytes / (double)(data->nfiles)));
	print("    %lu merged strings\n", data->noutput_strings);
	print("    from %lu files and %lu total strings from those "
	      "files\n", data->nfiles, data->ninput_strings);
	print("    average number of strings per file %g\n",
	      (double)((double)data->ninput_strings / (double)(data->nfiles)));
	if(data->nprobes != 0){
	    print("    number of hash probes %lu\n", data->nprobes);
	    print("    average number of hash probes %g\n",
	    (double)((double)(data->nprobes) / (double)(data->ninput_strings)));
	}
}
#endif /* DEBUG */
                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/cstring_literals.h                       0100644 0001750 0001750 00000010724 12612724205 024563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file cstring_literals.c.
 *
 * The following include files need to be included before this file:
 * #include "ld.h"
 * #include "objects.h"
 */

/*
 * The literal_data which is set into a merged_section's literal_data field for
 * S_CSTRING_LITERALS sections.  The external functions declared at the end of
 * this file operate on this data and are used for the other fields of a
 * merged_section for literals (literal_merge and literal_write).
 */
struct cstring_data {
    struct cstring_bucket **hashtable;		/* the hash table */
    struct cstring_block *cstring_blocks;	/* the cstrings */
    struct cstring_load_order_data	 /* the load order info needed to */
	*cstring_load_order_data;	 /*  re-merge when using -dead_strip */
#ifdef DEBUG
    unsigned long nfiles;	/* number of files with this section */
    unsigned long nbytes;	/* total number of bytes in the input files*/
				/*  merged into this section  */
    unsigned long ninput_strings;/* number of strings in the input file */
    unsigned long noutput_strings;/* number of strings in the output file */
    unsigned long nprobes;	/* number of hash probes */
#endif /* DEBUG */
};

/* the number of entries in the hash table */
#define CSTRING_HASHSIZE 1022

/* the hash bucket entries in the hash table points to; allocated as needed */
struct cstring_bucket {
    char *cstring;		/* pointer to the string */
    unsigned long offset;	/* offset of this string in the output file */
    struct cstring_bucket *next;/* next in the hash chain */
};

/* the blocks that store the strings; allocated as needed */
struct cstring_block {
    unsigned long size;		/* the number of bytes in this block */
    unsigned long used;		/* the number of bytes used in this block */
    enum bool full;		/* no more strings are to come from this block*/
    char *cstrings;		/* the strings */
    struct cstring_block *next;	/* the next block */
};

/* the load order info needed to re-merge when using -dead_strip */
struct cstring_load_order_data {
    char *order_line_buffer;
    unsigned long ncstring_order_lines;
    struct cstring_order_line *cstring_order_lines;
};
/* the load order info for a single cstring order line */
struct cstring_order_line {
    unsigned character_index;
    unsigned long output_offset;
};

__private_extern__ void cstring_merge(
    struct cstring_data *data,
    struct merged_section *ms,
    struct section *s,
    struct section_map *section_map,
    enum bool redo_live);

__private_extern__ void cstring_order(
    struct cstring_data *data,
    struct merged_section *ms);

__private_extern__ void cstring_reset_live(
    struct cstring_data *data,
    struct merged_section *ms);

__private_extern__ void get_cstring_from_sectorder(
    struct merged_section *ms,
    unsigned long *index,
    char *buffer,
    unsigned long line_number,
    unsigned long char_pos);

__private_extern__ unsigned long lookup_cstring(
    char *cstring,
    struct cstring_data *data,
    struct merged_section *ms);

__private_extern__ void cstring_output(
    struct cstring_data *data,
    struct merged_section *ms);

__private_extern__ void cstring_free(
    struct cstring_data *data);

#ifdef DEBUG
__private_extern__ void print_cstring_data(
    struct cstring_data *data,
    char *indent);

__private_extern__ void cstring_data_stats(
    struct cstring_data *data,
    struct merged_section *ms);
#endif /* DEBUG */
                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/debugcompunit.c                          0100644 0001750 0001750 00000020033 12612724205 024045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef KLD
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "dwarf2.h"
#include "debugcompunit.h"

/* Read in a word of fixed size, which may be unaligned, in the
   appropriate endianness.  */
#define read_16(p) (little_endian		\
		    ? ((p)[1] << 8 | (p)[0])	\
		    : ((p)[0] << 8 | (p)[1]))
#define read_32(p) (little_endian					    \
		    ? ((p)[3] << 24 | (p)[2] << 16 | (p)[1] << 8 | (p)[0])  \
		    : ((p)[0] << 24 | (p)[1] << 16 | (p)[2] << 8 | (p)[3]))
#define read_64(p) (little_endian					    \
		    ? ((uint64_t) (p)[7] << 56 | (uint64_t) (p)[6] << 48    \
		       | (uint64_t) (p)[5] << 40 | (uint64_t) (p)[4] << 32  \
		       | (uint64_t) (p)[3] << 24 | (uint64_t) (p)[2] << 16u \
		       | (uint64_t) (p)[1] << 8 | (uint64_t) (p)[0])	    \
		    : ((uint64_t) (p)[0] << 56 | (uint64_t) (p)[1] << 48    \
		       | (uint64_t) (p)[2] << 40 | (uint64_t) (p)[3] << 32  \
		       | (uint64_t) (p)[4] << 24 | (uint64_t) (p)[5] << 16u \
		       | (uint64_t) (p)[6] << 8 | (uint64_t) (p)[7]))

/* Skip over a LEB128 value (signed or unsigned).  */
static void
skip_leb128 (const uint8_t ** offset, const uint8_t * end)
{
  while (*offset != end && **offset >= 0x80)
    (*offset)++;
  if (*offset != end)
    (*offset)++;
}

/* Read a ULEB128 into a 64-bit word.  Return (uint64_t)-1 on overflow
   or error.  On overflow, skip past the rest of the uleb128.  */
static uint64_t
read_uleb128 (const uint8_t ** offset, const uint8_t * end)
{
  uint64_t result = 0;
  int bit = 0;
  
  do  {
    uint64_t b;
    
    if (*offset == end)
      return (uint64_t) -1;
  
    b = **offset & 0x7f;
    
    if (bit >= 64 || b << bit >> bit != b)
      result = (uint64_t) -1;
    else
      result |= b << bit, bit += 7;
  } while (*(*offset)++ >= 0x80);
  return result;
}

/* Skip over a DWARF attribute of form FORM.  */
static bool
skip_form (const uint8_t ** offset, const uint8_t * end, uint64_t form,
	   uint8_t addr_size, bool dwarf64, bool little_endian)
{
  uint64_t sz;
  
  switch (form)
    {
    case DW_FORM_addr:
      sz = addr_size;
      break;
      
    case DW_FORM_block2:
      if (end - *offset < 2)
	return false;
      sz = 2 + read_16 (*offset);
      break;
      
    case DW_FORM_block4:
      if (end - *offset < 4)
	return false;
      sz = 2 + read_32 (*offset);
      break;
      
    case DW_FORM_data2:
    case DW_FORM_ref2:
      sz = 2;
      break;
      
    case DW_FORM_data4:
    case DW_FORM_ref4:
      sz = 4;
      break;
      
    case DW_FORM_data8:
    case DW_FORM_ref8:
      sz = 8;
      break;
      
    case DW_FORM_string:
      while (*offset != end && **offset)
	++*offset;
    case DW_FORM_data1:
    case DW_FORM_flag:
    case DW_FORM_ref1:
      sz = 1;
      break;
      
    case DW_FORM_block:
      sz = read_uleb128 (offset, end);
      break;
      
    case DW_FORM_block1:
      if (*offset == end)
	return false;
      sz = 1 + **offset;
      break;
      
    case DW_FORM_sdata:
    case DW_FORM_udata:
    case DW_FORM_ref_udata:
      skip_leb128 (offset, end);
      return true;
      
    case DW_FORM_strp:
    case DW_FORM_ref_addr:
      sz = dwarf64 ? 8 : 4;
      break;
      
    default:
      return false;
    }
  if (end - *offset < sz)
    return false;
  *offset += sz;
  return true;
}

/* Given pointers to the DEBUG_INFO and DEBUG_ABBREV sections, and
   their corresponding sizes, and whether the object file is
   LITTLE_ENDIAN or not, look at the compilation unit DIE and
   determine its NAME, compilation directory (in COMP_DIR) and its
   line number information offset (in STMT_LIST).  NAME and COMP_DIR
   may be NULL (especially COMP_DIR) if they are not in the .o file;
   STMT_LIST will be (uint64_t) -1.

   At present this assumes that there's only one compilation unit DIE.  */

int
read_comp_unit (const uint8_t * debug_info,
		size_t debug_info_size,
		const uint8_t * debug_abbrev,
		size_t debug_abbrev_size,
		int little_endian,
		const char ** name,
		const char ** comp_dir,
		uint64_t *stmt_list)
{
  const uint8_t * di = debug_info;
  const uint8_t * da;
  const uint8_t * end;
  const uint8_t * enda;
  uint64_t sz;
  uint16_t vers;
  uint64_t abbrev_base;
  uint64_t abbrev;
  uint8_t address_size;
  bool dwarf64;
  
  *name = NULL;
  *comp_dir = NULL;
  *stmt_list = (uint64_t) -1;

  if (debug_info_size < 12)
    /* Too small to be a real debug_info section.  */
    return false;
  sz = read_32 (di);
  di += 4;
  dwarf64 = sz == 0xffffffff;
  if (dwarf64)
    sz = read_64 (di), di += 8;
  else if (sz > 0xffffff00)
    /* Unknown dwarf format.  */
    return false;
  
  /* Verify claimed size.  */
  if (sz + (di - debug_info) > debug_info_size || sz <= (dwarf64 ? 23 : 11))
    return false;

  vers = read_16 (di);
  if (vers < 2 || vers > 3)
    /* DWARF version wrong for this code.
       Chances are we could continue anyway, but we don't know for sure.  */
    return false;
  di += 2;
  
  /* Find the debug_abbrev section.  */
  abbrev_base = dwarf64 ? read_64 (di) : read_32 (di);
  di += dwarf64 ? 8 : 4;
  
  if (abbrev_base > debug_abbrev_size)
    return false;
  da = debug_abbrev + abbrev_base;
  enda = debug_abbrev + debug_abbrev_size;

  address_size = *di++;

  /* Find the abbrev number we're looking for.  */
  end = di + sz;
  abbrev = read_uleb128 (&di, end);
  if (abbrev == (uint64_t) -1)
    return false;
  
  /* Skip through the debug_abbrev section looking for that abbrev.  */
  for (;;)
    {
      uint64_t this_abbrev = read_uleb128 (&da, enda);
      uint64_t attr;
      
      if (this_abbrev == abbrev)
	/* This is almost always taken.  */
	break;
      skip_leb128 (&da, enda); /* Skip the tag.  */
      if (da == enda)
	return false;
      da++;  /* Skip the DW_CHILDREN_* value.  */
      
      do {
	attr = read_uleb128 (&da, enda);
	skip_leb128 (&da, enda);
      } while (attr != 0 && attr != (uint64_t) -1);
      if (attr != 0)
	return false;
    }

  /* Check that the abbrev is one for a DW_TAG_compile_unit.  */
  if (read_uleb128 (&da, enda) != DW_TAG_compile_unit)
    return false;
  if (da == enda)
    return false;
  da++;  /* Skip the DW_CHILDREN_* value.  */

  /* Now, go through the DIE looking for DW_AT_name,
     DW_AT_comp_dir, and DW_AT_stmt_list.  */
  for (;;)
    {
      uint64_t attr = read_uleb128 (&da, enda);
      uint64_t form = read_uleb128 (&da, enda);

      if (attr == (uint64_t) -1)
	return false;
      else if (attr == 0)
	return true;

      if (form == DW_FORM_indirect)
	form = read_uleb128 (&di, end);
      
      if (attr == DW_AT_name && form == DW_FORM_string)
	*name = (const char *) di;
      else if (attr == DW_AT_comp_dir && form == DW_FORM_string)
	*comp_dir = (const char *) di;
      /* Really we should support DW_FORM_strp here, too, but
	 there's usually no reason for the producer to use that form
         for the DW_AT_name and DW_AT_comp_dir attributes.  */
      else if (attr == DW_AT_stmt_list && form == DW_FORM_data4)
	*stmt_list = read_32 (di);
      else if (attr == DW_AT_stmt_list && form == DW_FORM_data8)
	*stmt_list = read_64 (di);
      if (! skip_form (&di, end, form, address_size, dwarf64, little_endian))
	return false;
    }
}
#endif /* ! KLD */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/debugcompunit.h                          0100644 0001750 0001750 00000003370 12612724205 024057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdint.h>
#include <stddef.h>

/* Given pointers to the DEBUG_INFO and DEBUG_ABBREV sections, and
   their corresponding sizes, and whether the object file is
   LITTLE_ENDIAN or not, look at the compilation unit DIE and
   determine its NAME, compilation directory (in COMP_DIR) and its
   line number information offset (in STMT_LIST).  NAME and COMP_DIR
   may be NULL (especially COMP_DIR) if they are not in the .o file;
   STMT_LIST will be (uint64_t) -1.

   At present this assumes that there's only one compilation unit DIE.  */

int read_comp_unit (const uint8_t * debug_info,
		    size_t debug_info_size,
		    const uint8_t * debug_abbrev,
		    size_t debug_abbrev_size,
		    int little_endian,
		    const char ** name,
		    const char ** comp_dir,
		    uint64_t *stmt_list);
                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/debugline.c                              0100644 0001750 0001750 00000033377 12612724205 023155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2005-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef KLD
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "dwarf2.h"
#include "debugline.h"

struct line_reader_data 
{
  bool little_endian;
  
  /* From the line number information header.  */
  uint8_t minimum_instruction_length;
  int8_t line_base;
  uint8_t line_range;
  uint8_t opcode_base;
  const uint8_t * standard_opcode_lengths;
  size_t numdir;
  const uint8_t * * dirnames;
  size_t numfile_orig;
  size_t numfile;  /* As updated during execution of the table.  */
  const uint8_t * * filenames;

  /* Current position in the line table.  */
  const uint8_t * cpos;
  /* End of this part of the line table.  */
  const uint8_t * end;
  /* Start of the line table.  */
  const uint8_t * init;

  struct line_info cur;
};

/* Read in a word of fixed size, which may be unaligned, in the
   appropriate endianness.  */
#define read_16(p) (lnd->little_endian		\
		    ? ((p)[1] << 8 | (p)[0])	\
		    : ((p)[0] << 8 | (p)[1]))
#define read_32(p) (lnd->little_endian					    \
		    ? ((p)[3] << 24 | (p)[2] << 16 | (p)[1] << 8 | (p)[0])  \
		    : ((p)[0] << 24 | (p)[1] << 16 | (p)[2] << 8 | (p)[3]))
#define read_64(p) (lnd->little_endian					    \
		    ? ((uint64_t) (p)[7] << 56 | (uint64_t) (p)[6] << 48    \
		       | (uint64_t) (p)[5] << 40 | (uint64_t) (p)[4] << 32  \
		       | (uint64_t) (p)[3] << 24 | (uint64_t) (p)[2] << 16u \
		       | (uint64_t) (p)[1] << 8 | (uint64_t) (p)[0])	    \
		    : ((uint64_t) (p)[0] << 56 | (uint64_t) (p)[1] << 48    \
		       | (uint64_t) (p)[2] << 40 | (uint64_t) (p)[3] << 32  \
		       | (uint64_t) (p)[4] << 24 | (uint64_t) (p)[5] << 16u \
		       | (uint64_t) (p)[6] << 8 | (uint64_t) (p)[7]))

/* Skip over a LEB128 value (signed or unsigned).  */
static void
skip_leb128 (struct line_reader_data * leb)
{
  while (leb->cpos != leb->end && *leb->cpos >= 0x80)
    leb->cpos++;
  if (leb->cpos != leb->end)
    leb->cpos++;
}

/* Read a ULEB128 into a 64-bit word.  Return (uint64_t)-1 on overflow
   or error.  On overflow, skip past the rest of the uleb128.  */
static uint64_t
read_uleb128 (struct line_reader_data * leb)
{
  uint64_t result = 0;
  int bit = 0;
  
  do  {
    uint64_t b;
    
    if (leb->cpos == leb->end)
      return (uint64_t) -1;
  
    b = *leb->cpos & 0x7f;
    
    if (bit >= 64 || b << bit >> bit != b)
      result = (uint64_t) -1;
    else
      result |= b << bit, bit += 7;
  } while (*leb->cpos++ >= 0x80);
  return result;
}

/* Read a SLEB128 into a 64-bit word.  Return 0 on overflow or error
   (which is not very helpful).  On overflow, skip past the rest of
   the SLEB128.  For negative numbers, this actually overflows when
   under -2^62, but since this is used for line numbers that ought to
   be OK...  */
static int64_t
read_sleb128 (struct line_reader_data * leb)
{
  const uint8_t * start_pos = leb->cpos;
  uint64_t v = read_uleb128 (leb);
  uint64_t signbit;
  
  if (v >= 1ull << 63)
    return 0;
  if (leb->cpos - start_pos > 9)
    return v;

  signbit = 1ull << ((leb->cpos - start_pos) * 7 - 1);

  return v | -(v & signbit);
}

/* Free a line_reader_data structure.  */
void
line_free (struct line_reader_data * lnd)
{
  if (! lnd)
    return;
  if (lnd->dirnames)
    free (lnd->dirnames);
  if (lnd->filenames)
    free (lnd->filenames);
  free (lnd);
}

/* Return the pathname of the file in S, or NULL on error. 
   The result will have been allocated with malloc.  */

char *
line_file (struct line_reader_data *lnd, uint64_t n)
{
  const uint8_t * prev_pos = lnd->cpos;
  size_t filelen, dirlen;
  uint64_t dir;
  char * result;

  /* I'm not sure if this is actually an error.  */
  if (n == 0
      || n > lnd->numfile)
    return NULL;

  filelen = strlen ((const char *)lnd->filenames[n - 1]);
  lnd->cpos = lnd->filenames[n - 1] + filelen + 1;
  dir = read_uleb128 (lnd);
  lnd->cpos = prev_pos;
  if (dir == 0
      || lnd->filenames[n - 1][0] == '/')
    return strdup ((const char *)lnd->filenames[n - 1]);
  else if (dir > lnd->numdir)
    return NULL;

  dirlen = strlen ((const char *) lnd->dirnames[dir - 1]);
  result = malloc (dirlen + filelen + 2);
  memcpy (result, lnd->dirnames[dir - 1], dirlen);
  result[dirlen] = '/';
  memcpy (result + dirlen + 1, lnd->filenames[n - 1], filelen);
  result[dirlen + 1 + filelen] = '\0';
  return result;
}

/* Initialize a state S.  Return FALSE on error.  */

static void
init_state (struct line_info *s)
{
  s->file = 1;
  s->line = 1;
  s->col = 0;
  s->pc = 0;
  s->end_of_sequence = false;
}

/* Read a debug_line section.  */

struct line_reader_data *
line_open (const uint8_t * debug_line, size_t debug_line_size,
	   int little_endian)
{
  struct line_reader_data * lnd = NULL;
  bool dwarf_size_64;

  uint64_t lnd_length, header_length;
  const uint8_t * table_start;

  if (debug_line_size < 12)
    return NULL;
  
  lnd = malloc (sizeof (struct line_reader_data));
  if (! lnd)
    goto error;
  
  lnd->little_endian = little_endian;
  lnd->cpos = debug_line;

  lnd_length = read_32 (lnd->cpos);
  lnd->cpos += 4;
  if (lnd_length == 0xffffffff)
    {
      lnd_length = read_64 (lnd->cpos);
      lnd->cpos += 8;
      dwarf_size_64 = true;
    }
  else if (lnd_length > 0xfffffff0)
    /* Not a format we understand.  */
    goto error;
  else
    dwarf_size_64 = false;

  if (debug_line_size < lnd_length + (dwarf_size_64 ? 12 : 4)
      || lnd_length < (dwarf_size_64 ? 15 : 11))
    /* Too small.  */
    goto error;
  
  if (read_16 (lnd->cpos) != 2)
    /* Unknown line number format.  */
    goto error;
  lnd->cpos += 2;

  header_length = dwarf_size_64 ? read_64(lnd->cpos) : read_32(lnd->cpos);
  lnd->cpos += dwarf_size_64 ? 8 : 4;
  if (lnd_length < header_length + (lnd->cpos - debug_line)
      || header_length < 7)
    goto error;

  lnd->minimum_instruction_length = lnd->cpos[0];
  /* Ignore default_is_stmt.  */
  lnd->line_base = lnd->cpos[2];
  lnd->line_range = lnd->cpos[3];
  lnd->opcode_base = lnd->cpos[4];

  if (lnd->opcode_base == 0)
    /* Every valid line number program must use at least opcode 0
       for DW_LNE_end_sequence.  */
    goto error;

  lnd->standard_opcode_lengths = lnd->cpos + 5;
  if (header_length < 5 + (lnd->opcode_base - 1))
    /* Header not long enough.  */
    goto error;
  lnd->cpos += 5 + lnd->opcode_base - 1;
  lnd->end = debug_line + header_length + (dwarf_size_64 ? 22 : 10);
  
  /* Make table of offsets to directory names.  */
  table_start = lnd->cpos;
  lnd->numdir = 0;
  while (lnd->cpos != lnd->end && *lnd->cpos)
    {
      lnd->cpos = memchr (lnd->cpos, 0, lnd->end - lnd->cpos);
      if (! lnd->cpos)
	goto error;
      lnd->cpos++;
      lnd->numdir++;
    }
  if (lnd->cpos == lnd->end)
    goto error;
  lnd->dirnames = malloc (lnd->numdir * sizeof (const uint8_t *));
  if (! lnd->dirnames)
    goto error;
  lnd->numdir = 0;
  lnd->cpos = table_start;
  while (*lnd->cpos)
    {
      lnd->dirnames[lnd->numdir++] = lnd->cpos;
      lnd->cpos = memchr (lnd->cpos, 0, lnd->end - lnd->cpos) + 1;
    }
  lnd->cpos++;
  
  /* Make table of offsets to file entries.  */
  table_start = lnd->cpos;
  lnd->numfile = 0;
  while (lnd->cpos != lnd->end && *lnd->cpos)
    {
      lnd->cpos = memchr (lnd->cpos, 0, lnd->end - lnd->cpos);
      if (! lnd->cpos)
	goto error;
      lnd->cpos++;
      skip_leb128 (lnd);
      skip_leb128 (lnd);
      skip_leb128 (lnd);
      lnd->numfile++;
    }
  if (lnd->cpos == lnd->end)
    goto error;
  lnd->filenames = malloc (lnd->numfile * sizeof (const uint8_t *));
  if (! lnd->filenames)
    goto error;
  lnd->numfile = 0;
  lnd->cpos = table_start;
  while (*lnd->cpos)
    {
      lnd->filenames[lnd->numfile++] = lnd->cpos;
      lnd->cpos = memchr (lnd->cpos, 0, lnd->end - lnd->cpos) + 1;
      skip_leb128 (lnd);
      skip_leb128 (lnd);
      skip_leb128 (lnd);
    }
  lnd->cpos++;
  
  lnd->numfile_orig = lnd->numfile;
  lnd->cpos = lnd->init = lnd->end;
  lnd->end = debug_line + lnd_length + (dwarf_size_64 ? 12 : 4);

  init_state (&lnd->cur);

  return lnd;
  
 error:
  line_free (lnd);
  return NULL;
}

/* Reset back to the beginning.  */
void
line_reset (struct line_reader_data * lnd)
{
  lnd->cpos = lnd->init;
  lnd->numfile = lnd->numfile_orig;
  init_state (&lnd->cur);
}

/* Is there no more line data available?  */
int
line_at_eof (struct line_reader_data * lnd)
{
  return lnd->cpos == lnd->end;
}

static bool
next_state (struct line_reader_data *lnd)
{
  if (lnd->cur.end_of_sequence)
    init_state (&lnd->cur);

  for (;;)
    {
      uint8_t op;
      uint64_t tmp;
      
      if (lnd->cpos == lnd->end)
	return false;
      op = *lnd->cpos++;
      if (op >= lnd->opcode_base)
	{
	  op -= lnd->opcode_base;
	  
	  lnd->cur.line += op % lnd->line_range + lnd->line_base;
	  lnd->cur.pc += (op / lnd->line_range 
			  * lnd->minimum_instruction_length);
	  return true;
	}
      else switch (op)
	{
	case DW_LNS_extended_op:
	  {
	    uint64_t sz = read_uleb128 (lnd);
	    const uint8_t * op = lnd->cpos;
	    
	    if (lnd->end - op < sz || sz == 0)
	      return false;
	    lnd->cpos += sz;
	    switch (*op++)
	      {
	      case DW_LNE_end_sequence:
		lnd->cur.end_of_sequence = true;
		return true;
		
	      case DW_LNE_set_address:
		if (sz == 9)
		  lnd->cur.pc = read_64 (op);
		else if (sz == 5)
		  lnd->cur.pc = read_32 (op);
		else
		  return false;
		break;
		
	      case DW_LNE_define_file:
		{
		  const uint8_t * * filenames;
		  filenames = realloc 
		    (lnd->filenames, 
		     (lnd->numfile + 1) * sizeof (const uint8_t *));
		  if (! filenames)
		    return false;
		  /* Check for zero-termination.  */
		  if (! memchr (op, 0, lnd->cpos - op))
		    return false;
		  filenames[lnd->numfile++] = op;
		  lnd->filenames = filenames;

		  /* There's other data here, like file sizes and modification
		     times, but we don't need to read it so skip it.  */
		}
		break;
		
	      default:
		/* Don't understand it, so skip it.  */
		break;
	      }
	    break;
	  }
	  
	case DW_LNS_copy:
	  return true;
	case DW_LNS_advance_pc:
	  tmp = read_uleb128 (lnd);
	  if (tmp == (uint64_t) -1)
	    return false;
	  lnd->cur.pc += tmp * lnd->minimum_instruction_length;
	  break;
	case DW_LNS_advance_line:
	  lnd->cur.line += read_sleb128 (lnd);
	  break;
	case DW_LNS_set_file:
	  lnd->cur.file = read_uleb128 (lnd);
	  break;
	case DW_LNS_set_column:
	  lnd->cur.col = read_uleb128 (lnd);
	  break;
	case DW_LNS_const_add_pc:
	  lnd->cur.pc += ((255 - lnd->opcode_base) / lnd->line_range
			  * lnd->minimum_instruction_length);
	  break;
	case DW_LNS_fixed_advance_pc:
	  if (lnd->end - lnd->cpos < 2)
	    return false;
	  lnd->cur.pc += read_16 (lnd->cpos);
	  lnd->cpos += 2;
	  break;
	default:
	  {
	    /* Don't know what it is, so skip it.  */
	    int i;
	    for (i = 0; i < lnd->standard_opcode_lengths[op - 1]; i++)
	      skip_leb128 (lnd);
	    break;
	  }
	}
    }
}


/* Set RESULT to the next 'interesting' line state, as indicated
   by STOP, or return FALSE on error.  The final (end-of-sequence)
   line state is always considered interesting.  */
int
line_next (struct line_reader_data * lnd,
	   struct line_info * result,
	   enum line_stop_constants stop)
{
  for (;;)
    {
      struct line_info prev = lnd->cur;

      if (! next_state (lnd))
	return false;

      if (lnd->cur.end_of_sequence)
	break;
      if (stop == line_stop_always)
	break;
      if ((stop & line_stop_pc) && lnd->cur.pc != prev.pc)
	break;
      if ((stop & line_stop_pos_mask) && lnd->cur.file != prev.file)
	break;
      if ((stop & line_stop_pos_mask) >= line_stop_line
	  && lnd->cur.line != prev.line)
	break;
      if ((stop & line_stop_pos_mask) >= line_stop_col
	  && lnd->cur.col != prev.col)
	break;
    }
  *result = lnd->cur;
  return true;
}

/* Find the region (START->pc through END->pc) in the debug_line
   information which contains PC.  This routine starts searching at
   the current position (which is returned as END), and will go all
   the way around the debug_line information.  It will return false if
   an error occurs or if there is no matching region; these may be
   distinguished by looking at START->end_of_sequence, which will be
   false on error and true if there was no matching region.
   You could write this routine using line_next, but this version
   will be slightly more efficient, and of course more convenient.  */

int
line_find_addr (struct line_reader_data * lnd,
		struct line_info * start,
		struct line_info * end,
		uint64_t pc)
{
  const uint8_t * startpos;
  struct line_info prev;

  if (lnd->cur.end_of_sequence && lnd->cpos == lnd->end)
    line_reset (lnd);

  startpos = lnd->cpos;

  do {
    prev = lnd->cur;
    if (! next_state (lnd))
      {
	start->end_of_sequence = false;
	return false;
      }
    if (lnd->cur.end_of_sequence && lnd->cpos == lnd->end)
      line_reset (lnd);
    if (lnd->cpos == startpos)
      {
	start->end_of_sequence = true;
	return false;
      }
  } while (lnd->cur.pc <= pc || prev.pc > pc || prev.end_of_sequence);
  *start = prev;
  *end = lnd->cur;
  return true;
}
#endif /* ! KLD */

                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/debugline.h                              0100644 0001750 0001750 00000010200 12612724205 023136  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdint.h>
#include <stddef.h>

/* Information about a line.
   DIRECTORY is to be ignored if FILENAME is absolute.  
   PC will be relative to the file the debug_line section is in.  */
struct line_info
{
  uint64_t file;
  int64_t line;
  uint64_t col;
  uint64_t pc;
  int end_of_sequence;
};

/* Opaque status structure for the line readers.  */
struct line_reader_data;

/* Create a line_reader_data, given address and size of the debug_line section.
   SIZE may be (size_t)-1 if unknown, although this suppresses checking
   for an incorrectly large size in the debug_line section.
   LITTLE_ENDIAN is set if the debug_line section is for a little-endian
   machine.
   Returns NULL on error.  */
struct line_reader_data * line_open (const uint8_t * debug_line,
				     size_t debug_line_size,
				     int little_endian);

/* The STOP parameter to line_next is one of line_stop_{file,line,col},
   perhaps ORed with line_stop_pc; or line_stop_atend, or line_stop_always.  */
enum line_stop_constants {
  line_stop_atend = 0, /* Stop only at the end of a sequence.  */
  line_stop_file = 1,  /* Stop if DIRECTORY or FILENAME change.  */
  line_stop_line = 2,  /* Stop if LINE, DIRECTORY, or FILENAME change.  */
  line_stop_col = 3,   /* Stop if COL, LINE, DIRECTORY, or FILENAME change.  */
  line_stop_pos_mask = 3,
  line_stop_pc = 4,    /* Stop if PC changes.  */
  line_stop_always = 8 /* Stop always.  */
};

/* Either return FALSE on an error, in which case the line_reader_data
   may be invalid and should be passed immediately to line_free; or
   fill RESULT with the first 'interesting' line, as determined by STOP.
   The last line data in a sequence is always considered 'interesting'.  */
int line_next (struct line_reader_data * lnd,
		struct line_info * result,
		enum line_stop_constants stop);

/* Find the region (START->pc through END->pc) in the debug_line
   information which contains PC.  This routine starts searching at
   the current position (which is returned as END), and will go all
   the way around the debug_line information.  It will return false if
   an error occurs or if there is no matching region; these may be
   distinguished by looking at START->end_of_sequence, which will be
   false on error and true if there was no matching region.
   You could write this routine using line_next, but this version
   will be slightly more efficient, and of course more convenient.  */

int line_find_addr (struct line_reader_data * lnd,
		     struct line_info * start,
		     struct line_info * end,
		     uint64_t pc);

/* Return TRUE if there is more line data to be fetched.
   If line_next has not been called or it has been called but did not
   set END_OF_SEQUENCE, you can assume there is more line data,
   but it's safe to call this routine anyway.  */
int line_at_eof (struct line_reader_data * lnd);

/* Return the pathname of the file in S, or NULL on error. 
   The result will have been allocated with malloc.  */
char * line_file (struct line_reader_data *lnd, uint64_t file);

/* Reset the line_reader_data: go back to the beginning.  */
void line_reset (struct line_reader_data * lnd);

/* Free a line_reader_data structure.  */
void line_free (struct line_reader_data * lnd);
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/dwarf2.h                                 0100644 0001750 0001750 00000004176 12612724205 022404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* These constants were taken from version 3 of the DWARF standard,
   which is Copyright (c) 2005 Free Standards Group, and
   Copyright (c) 1992, 1993 UNIX International, Inc.  */

/* This is not a complete list.  */
enum {
  DW_TAG_compile_unit = 17,
  DW_TAG_partial_unit = 60
};

/* This is not a complete list.  */
enum {
  DW_AT_sibling = 1,
  DW_AT_name = 3,
  DW_AT_stmt_list = 16,
  DW_AT_comp_dir = 27
};

enum {
  DW_FORM_addr = 1,
  DW_FORM_block2 = 3,
  DW_FORM_block4,
  DW_FORM_data2,
  DW_FORM_data4,
  DW_FORM_data8,
  DW_FORM_string,
  DW_FORM_block,
  DW_FORM_block1,
  DW_FORM_data1,
  DW_FORM_flag,
  DW_FORM_sdata,
  DW_FORM_strp,
  DW_FORM_udata,
  DW_FORM_ref_addr,
  DW_FORM_ref1,
  DW_FORM_ref2,
  DW_FORM_ref4,
  DW_FORM_ref8,
  DW_FORM_ref_udata,
  DW_FORM_indirect /* 22 */
};

enum {
  DW_LNS_extended_op = 0,
  DW_LNS_copy,
  DW_LNS_advance_pc,
  DW_LNS_advance_line,
  DW_LNS_set_file,
  DW_LNS_set_column,
  DW_LNS_negate_stmt,
  DW_LNS_set_basic_block,
  DW_LNS_const_add_pc,
  DW_LNS_fixed_advance_pc,
  DW_LNS_set_prologue_end,
  DW_LNS_set_epilogue_begin,
  DW_LNS_set_isa
};

enum {
  DW_LNE_end_sequence = 1,
  DW_LNE_set_address,
  DW_LNE_define_file
};
                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/dylibs.c                                 0100644 0001750 0001750 00000035317 12612724205 022501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#include <time.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"
#include "stuff/guess_short_name.h"

#include "dylibs.h"
#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "pass1.h"
#include "sections.h"

__private_extern__ enum bool has_dynamic_linker_command = FALSE;

#ifndef RLD

/* the pointer to the head of the dynamicly linked shared library commands */
__private_extern__ struct merged_dylib *merged_dylibs = NULL;

/* the pointer to the merged the dynamic linker command if any */
__private_extern__ struct merged_dylinker *merged_dylinker = NULL;

/* the pointer to the merged sub_framework command if any */
__private_extern__ struct merged_sub_frameworks *merged_sub_framework = NULL;

/* the pointer to the head of the dynamicly linked shared library segments */
__private_extern__ struct merged_segment *dylib_segments = NULL;

/* the pointer to the merged sub_umbrella commands if any */
__private_extern__ struct merged_sub_umbrella *merged_sub_umbrellas = NULL;

/* the pointer to the merged sub_library commands if any */
__private_extern__ struct merged_sub_library *merged_sub_librarys = NULL;

/* the pointer to the merged sub_client commands if any */
__private_extern__ struct merged_sub_client *merged_sub_clients = NULL;

static struct merged_dylib *lookup_merged_dylib(
    struct dylib_command *dl);

/*
 * create_dylib_id_command() creates the LC_ID_DYLIB load command from the
 * command line argument values.  It is called from layout() when the output
 * filetype is MH_DYLIB.
 */
__private_extern__
void
create_dylib_id_command(
void)
{
    char *name;
    unsigned long cmdsize;
    struct dylib_command *dl;
    struct merged_dylib *mdl;

	if(dylib_install_name != NULL)
	    name = dylib_install_name;
	else
	    name = outputfile;

	cmdsize = sizeof(struct dylib_command) +
		  rnd(strlen(name) + 1, sizeof(long));
	dl = allocate(cmdsize);
	memset(dl, '\0', cmdsize);
	dl->cmd = LC_ID_DYLIB;
	dl->cmdsize = cmdsize;
	dl->dylib.name.offset = sizeof(struct dylib_command);
	dl->dylib.timestamp = time(0);
	dl->dylib.current_version = dylib_current_version;
	dl->dylib.compatibility_version = dylib_compatibility_version;
	strcpy((char *)dl + sizeof(struct dylib_command), name);

	mdl = allocate(sizeof(struct merged_dylib));
	memset(mdl, '\0', sizeof(struct merged_dylib));
	mdl->dylib_name = name;
	mdl->dl = dl;
	mdl->output_id = TRUE;
	mdl->next = merged_dylibs;
	merged_dylibs = mdl;
}

/*
 * merge_dylibs() merges in the dylib commands from the current object.
 */
__private_extern__
void
merge_dylibs(
enum bool force_weak)
{
    unsigned long i;
    struct mach_header *mh;
    struct load_command *lc;
    struct dylib_command *dl;
    struct dylinker_command *dyld;
    char *dyld_name;
    struct merged_dylib *mdl;
    struct dynamic_library *p;

	/*
	 * Process all the load commands for the dynamic shared libraries.
	 */
	mh = (struct mach_header *)cur_obj->obj_addr;
	lc = (struct load_command *)((char *)cur_obj->obj_addr +
				     sizeof(struct mach_header));
	for(i = 0; i < mh->ncmds; i++){
	    if(lc->cmd == LC_ID_DYLIB ||
	       lc->cmd == LC_LOAD_DYLIB ||
	       lc->cmd == LC_LOAD_WEAK_DYLIB ||
	       lc->cmd == LC_REEXPORT_DYLIB){
		/*
		 * Do not record dynamic libraries dependencies in the output
		 * file.  Only record the library itself.
		 */
		if((lc->cmd != LC_LOAD_DYLIB &&
		    lc->cmd != LC_LOAD_WEAK_DYLIB &&
		    lc->cmd != LC_REEXPORT_DYLIB) ||
		   (mh->filetype != MH_DYLIB &&
		    mh->filetype != MH_DYLIB_STUB) ){
		    dl = (struct dylib_command *)lc;
		    mdl = lookup_merged_dylib(dl);
		    if(filetype == MH_DYLIB && dylib_install_name != NULL &&
		       strcmp(mdl->dylib_name, dylib_install_name) == 0)
			error_with_cur_obj("can't be linked because it has the "
			   "same install_name (%s) as the output", 
			   dylib_install_name);
		    p = add_dynamic_lib(DYLIB, dl, cur_obj);
		    p->force_weak_dylib = force_weak;
		    mdl->dynamic_library = p;
		}
	    }
	    else if(lc->cmd == LC_LOAD_DYLINKER || lc->cmd == LC_ID_DYLINKER){
		dyld = (struct dylinker_command *)lc;
		dyld_name = (char *)dyld + dyld->name.offset;
		if(merged_dylinker == NULL){
		    merged_dylinker = allocate(sizeof(struct merged_dylinker));
		    memset(merged_dylinker, '\0',
			   sizeof(struct merged_dylinker));
		    merged_dylinker->dylinker_name = dyld_name;
		    merged_dylinker->definition_object = cur_obj;
		    merged_dylinker->dyld = dyld;
		    has_dynamic_linker_command = TRUE;
		    if(save_reloc == FALSE)
			output_for_dyld = TRUE;
		}
		else if(strcmp(dyld_name, merged_dylinker->dylinker_name) != 0){
		    error("multiple dynamic linkers loaded (only one allowed)");
		    print_obj_name(merged_dylinker->definition_object);
		    print("loads dynamic linker %s\n",
			  merged_dylinker->dylinker_name);
		    print_obj_name(cur_obj);
		    print("loads dynamic linker %s\n", dyld_name);
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
}

/*
 * lookup_merged_dylib() adds a LC_LOAD_DYLIB command to it to the merged list
 * of dynamic shared libraries for the load command passed to it.  It ignores
 * the command if it see the same library twice.
 */
static
struct merged_dylib *
lookup_merged_dylib(
struct dylib_command *dl)
{
    char *dylib_name;
    struct merged_dylib **p, *mdl;

	dylib_name = (char *)dl + dl->dylib.name.offset;
	p = &merged_dylibs;
	while(*p){
	    mdl = *p;
	    if(strcmp(mdl->dylib_name, dylib_name) == 0){
		if(mdl->dl->cmd == LC_ID_DYLIB){
		    /*
		     * If the new one is also a LC_ID_DYLIB use the one with the
		     * highest compatiblity number.  Else if the new one is just
		     * an LC_LOAD_DYLIB ignore it and use the merged one that is
		     * a LC_ID_DYLIB.
		     */
		    if(dl->cmd == LC_ID_DYLIB){
		       if(dl->dylib.compatibility_version >
			  mdl->dl->dylib.compatibility_version){
			    if(strcmp(mdl->definition_object->file_name,
				      cur_obj->file_name) != 0)
				warning("multiple references to dynamic shared "
				    "library: %s (from %s and %s, using %s "
				    "which has higher compatibility_version)",
				    dylib_name,
				    mdl->definition_object->file_name,
				    cur_obj->file_name, cur_obj->file_name);
			    mdl->dylib_name = dylib_name;
			    mdl->dl = dl;
			    mdl->definition_object = cur_obj;
			}
		    }
		}
		else{
		    if(dl->cmd == LC_ID_DYLIB){
			mdl->dylib_name = dylib_name;
			mdl->dl = dl;
			mdl->definition_object = cur_obj;
		    }
		}
		return(mdl);
	    }
	    p = &(mdl->next);
	}
	*p = allocate(sizeof(struct merged_dylib));
	memset(*p, '\0', sizeof(struct merged_dylib));
	mdl = *p;
	mdl->dylib_name = dylib_name;
	mdl->dl = dl;
	mdl->definition_object = cur_obj;
	mdl->output_id = FALSE;
	return(mdl);
}

/*
 * create_dylinker_id_command() creates the LC_ID_DYLINKER load command from the
 * command line argument values.  It is called from layout() when the output
 * filetype is MH_DYLINKER.
 */
__private_extern__
void
create_dylinker_id_command(
void)
{
    char *name;
    unsigned long cmdsize;
    struct dylinker_command *dyld;
    struct merged_dylinker *mdyld;

	if(dylinker_install_name != NULL)
	    name = dylinker_install_name;
	else
	    name = outputfile;

	cmdsize = sizeof(struct dylinker_command) +
		  rnd(strlen(name) + 1, sizeof(long));
	dyld = allocate(cmdsize);
	memset(dyld, '\0', cmdsize);
	dyld->cmd = LC_ID_DYLINKER;
	dyld->cmdsize = cmdsize;
	dyld->name.offset = sizeof(struct dylinker_command);
	strcpy((char *)dyld + sizeof(struct dylinker_command), name);

	mdyld = allocate(sizeof(struct merged_dylinker));
	memset(mdyld, '\0', sizeof(struct merged_dylinker));
	mdyld->dylinker_name = name;
	mdyld->dyld = dyld;
	merged_dylinker = mdyld;
}

/*
 * create_sub_framework_command() creates a LC_SUB_FRAMEWORK load command from
 * the command line argument values.  It is called from layout() when the output
 * filetype is MH_DYLIB and -sub_framework was specified.
 */
__private_extern__
void
create_sub_framework_command(
void)
{
    char *name;
    unsigned long cmdsize;
    struct sub_framework_command *sub;
    struct merged_sub_frameworks *msub;

	name = umbrella_framework_name;

	cmdsize = sizeof(struct sub_framework_command) +
		  rnd(strlen(name) + 1, sizeof(long));
	sub = allocate(cmdsize);
	memset(sub, '\0', cmdsize);
	sub->cmd = LC_SUB_FRAMEWORK;
	sub->cmdsize = cmdsize;
	sub->umbrella.offset = sizeof(struct sub_framework_command);
	strcpy((char *)sub + sizeof(struct sub_framework_command), name);

	msub = allocate(sizeof(struct merged_sub_frameworks));
	memset(msub, '\0', sizeof(struct merged_sub_frameworks));
	msub->unbrell_name = name;
	msub->sub = sub;
	merged_sub_framework = msub;
}

/*
 * create_sub_umbrella_commands() creates the LC_SUB_UMBRELLA load commands from
 * the command line options.  It is called from layout() when the output 
 * filetype is MH_DYLIB and one or more -sub_umbrella flags were specified.
 * It returns the total size of the load commands it creates.
 */
__private_extern__
unsigned long
create_sub_umbrella_commands(
void)
{
    unsigned long i;
    char *name, *umbrella_framework_name, *has_suffix;
    unsigned long cmdsize, sizeofcmds;
    struct sub_umbrella_command *sub;
    enum bool found, is_framework;
    struct merged_dylib **p, *mdl;

	sizeofcmds = 0;
	merged_sub_umbrellas = allocate(sizeof(struct merged_sub_umbrella) *
				        nsub_umbrellas);
	for(i = 0; i < nsub_umbrellas ; i++){
	    name = sub_umbrellas[i];

	    found = FALSE;
	    p = &merged_dylibs;
	    while(*p){
		mdl = *p;
		umbrella_framework_name = guess_short_name(mdl->dylib_name,
			&is_framework, &has_suffix);
		if(umbrella_framework_name != NULL &&
		   is_framework == TRUE &&
		   strcmp(umbrella_framework_name, name) == 0){
		    found = TRUE;
		    break;
		}
		p = &(mdl->next);
	    }
	    if(found == FALSE)
		error("-sub_umbrella %s specified but no framework by that "
		      "name is linked in", name);

	    cmdsize = sizeof(struct sub_umbrella_command) +
		      rnd(strlen(name) + 1, sizeof(long));
	    sub = allocate(cmdsize);
	    memset(sub, '\0', cmdsize);
	    sub->cmd = LC_SUB_UMBRELLA;
	    sub->cmdsize = cmdsize;
	    sub->sub_umbrella.offset = sizeof(struct sub_umbrella_command);
	    strcpy((char *)sub + sizeof(struct sub_umbrella_command), name);

	    sizeofcmds += cmdsize;
	    merged_sub_umbrellas[i].sub = sub;
	}
	return(sizeofcmds);
}

/*
 * create_sub_library_commands() creates the LC_SUB_LIBRARY load commands from
 * the command line options.  It is called from layout() when the output 
 * filetype is MH_DYLIB and one or more -sub_library flags were specified.
 * It returns the total size of the load commands it creates.
 */
__private_extern__
unsigned long
create_sub_library_commands(
void)
{
    unsigned long i;
    char *name, *library_name, *has_suffix;
    unsigned long cmdsize, sizeofcmds;
    struct sub_library_command *sub;
    enum bool found, is_framework;
    struct merged_dylib **p, *mdl;

	sizeofcmds = 0;
	merged_sub_librarys = allocate(sizeof(struct merged_sub_library) *
				        nsub_librarys);
	for(i = 0; i < nsub_librarys ; i++){
	    name = sub_librarys[i];

	    found = FALSE;
	    p = &merged_dylibs;
	    while(*p){
		mdl = *p;
		library_name = guess_short_name(mdl->dylib_name,
			&is_framework, &has_suffix);
		if(library_name != NULL &&
		   is_framework == FALSE &&
		   strcmp(library_name, name) == 0){
		    found = TRUE;
		    break;
		}
		p = &(mdl->next);
	    }
	    if(found == FALSE)
		error("-sub_library %s specified but no library by that "
		      "name is linked in", name);

	    cmdsize = sizeof(struct sub_library_command) +
		      rnd(strlen(name) + 1, sizeof(long));
	    sub = allocate(cmdsize);
	    memset(sub, '\0', cmdsize);
	    sub->cmd = LC_SUB_LIBRARY;
	    sub->cmdsize = cmdsize;
	    sub->sub_library.offset = sizeof(struct sub_library_command);
	    strcpy((char *)sub + sizeof(struct sub_library_command), name);

	    sizeofcmds += cmdsize;
	    merged_sub_librarys[i].sub = sub;
	}
	return(sizeofcmds);
}

/*
 * create_sub_client_commands() creates the LC_SUB_CLIENT load commands from
 * the command line options.  It is called from layout() when the output 
 * filetype is MH_DYLIB and one or more -allowable_client flags were specified.
 * It returns the total size of the load commands it creates.
 */
__private_extern__
unsigned long
create_sub_client_commands(
void)
{
    unsigned long i;
    char *name;
    unsigned long cmdsize, sizeofcmds;
    struct sub_client_command *sub;

	sizeofcmds = 0;
	merged_sub_clients = allocate(sizeof(struct merged_sub_client) *
				      nallowable_clients);
	for(i = 0; i < nallowable_clients ; i++){
	    name = allowable_clients[i];
	    cmdsize = sizeof(struct sub_client_command) +
		      rnd(strlen(name) + 1, sizeof(long));
	    sub = allocate(cmdsize);
	    memset(sub, '\0', cmdsize);
	    sub->cmd = LC_SUB_CLIENT;
	    sub->cmdsize = cmdsize;
	    sub->client.offset = sizeof(struct sub_client_command);
	    strcpy((char *)sub + sizeof(struct sub_client_command), name);

	    sizeofcmds += cmdsize;
	    merged_sub_clients[i].sub = sub;
	}
	return(sizeofcmds);
}

/*
 * add_dylib_segment() adds the specified segment to the list of
 * dylib_segments as comming from the specified dylib_name.
 */
__private_extern__
void
add_dylib_segment(
struct segment_command *sg,
char *dylib_name,
enum bool split_dylib)
{
    struct merged_segment **p, *msg;

	p = &dylib_segments;
	while(*p){
	    msg = *p;
	    p = &(msg->next);
	}
	*p = allocate(sizeof(struct merged_segment));
	msg = *p;
	memset(msg, '\0', sizeof(struct merged_segment));
	msg->sg = *sg;
	msg->filename = dylib_name;
	msg->split_dylib = split_dylib;
}
#endif /* !defined(RLD) */
                                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/dylibs.h                                 0100644 0001750 0001750 00000010253 12612724205 022476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file dylibs.c.
 */

__private_extern__ enum bool has_dynamic_linker_command;

#ifndef RLD

struct merged_dylib {
    char *dylib_name;		/* The name of this dynamic shared library. */
    struct dylib_command *dl;	/* The load command for this dynamicly linked */
				/*  shared library. */
    struct object_file		/* Pointer to the object file the load */
	*definition_object;	/*  command was found in */
    enum bool output_id;	/* This is the output file's LC_ID_DYLIB */
				/*  command others get turned into */
				/*  LD_LOAD_DYLIB commands */
    struct dynamic_library	/* The dynamic_library struct for this */
	*dynamic_library;	/*  dynamic library shared library */
    struct merged_dylib *next;	/* The next in the list, NULL otherwise */
};
/* the pointer to the head of the dynamicly linked shared library commands */
__private_extern__ struct merged_dylib *merged_dylibs;

/* the pointer to the head of the dynamicly linked shared library segments */
__private_extern__ struct merged_segment *dylib_segments;

__private_extern__ void create_dylib_id_command(
    void);
__private_extern__ void merge_dylibs(
    enum bool force_weak);
__private_extern__ void add_dylib_segment(
    struct segment_command *sg,
    char *dylib_name,
    enum bool split_dylib);

struct merged_dylinker {
    char *dylinker_name;	/* The name of dynamic linker */
    struct dylinker_command
	*dyld;			/* The load command for the dynamicly linker */
    struct object_file		/* Pointer to the object file the load */
	*definition_object;	/*  command was found in */
};
/* the pointer to the merged the dynamic linker command if any */
__private_extern__ struct merged_dylinker *merged_dylinker;

__private_extern__ void create_dylinker_id_command(
    void);

struct merged_sub_frameworks {
    char *unbrell_name;		/* The name of the unbrella framework */
    struct sub_framework_command
	*sub;			/* The load command for the output file */
};
/* the pointer to the merged sub_framework command if any */
__private_extern__ struct merged_sub_frameworks *merged_sub_framework;

__private_extern__ void create_sub_framework_command(
    void);

struct merged_sub_umbrella {
    struct sub_umbrella_command
	*sub;			/* The load command for the output file */
};
/* the pointer to the merged sub_umbrella commands if any */
__private_extern__ struct merged_sub_umbrella *merged_sub_umbrellas;

__private_extern__ unsigned long create_sub_umbrella_commands(
    void);

struct merged_sub_library {
    struct sub_library_command
	*sub;			/* The load command for the output file */
};
/* the pointer to the merged sub_library commands if any */
__private_extern__ struct merged_sub_library *merged_sub_librarys;

__private_extern__ unsigned long create_sub_library_commands(
    void);

struct merged_sub_client {
    struct sub_client_command
	*sub;			/* The load command for the output file */
};
/* the pointer to the merged sub_client commands if any */
__private_extern__ struct merged_sub_client *merged_sub_clients;

__private_extern__ unsigned long create_sub_client_commands(
    void);

#endif /* !defined(RLD) */
                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/fvmlibs.c                                0100644 0001750 0001750 00000023326 12612724205 022652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
#ifndef RLD
/*
 * This file contains the routines to manage the fixed VM shared libraries
 * that the output file uses.
 */
#include <stdio.h>
#include <stdarg.h>
#include <strings.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <ar.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "fvmlibs.h"

/* the pointer to the head of the load fixed VM shared library commamds */
__private_extern__ struct merged_fvmlib *merged_fvmlibs = NULL;

/* the pointer to the head of the fixed VM shared library segments */
__private_extern__ struct merged_segment *fvmlib_segments = NULL;

static struct merged_fvmlib *lookup_merged_fvmlib(struct fvmlib_command *fl);
static void add_fvmlib_segment(struct segment_command *sg, char *fvmlib_name);

/*
 * merge_fvmlibs() handles the things relelated to fixed VM libraries.  It does
 * two things.  First any object file that has a LC_LOADFVMLIB command in it
 * indicated that library must be loaded in the final output.  So this routine
 * collects all the load fixed VM library load commands into a list.  Second
 * for the link editor to do overlap checking of the segments in a fixed VM
 * library with all the segments in the output file the program mkshlib(l)
 * builds an object file with segments marked with SG_FVMLIB and one
 * LC_LOADFVMLIB command for the library those segments are in.  So this routine
 * also collects a list of these segments so the overlap checking can be done.
 */
__private_extern__
void
merge_fvmlibs(void)
{
    unsigned long i, nload_fvmlibs, nid_fvmlibs, nfvmlib_segments;
    struct mach_header *mh;
    struct load_command *lc;
    struct segment_command *sg;
    struct fvmlib_command *fl;
    struct merged_fvmlib *mfl;

#ifdef DEBUG
	/* The compiler "warnings: `fl' and `mfl' may be used uninitialized */
	/* in this function" can safely be ignored */
	fl = NULL;;
	mfl = NULL;;
#endif /* DEBUG */

	/*
	 * First process all the load commands for the fixed VM libraries
	 * loaded.  This needs to be done first so that the fvmlib segments
	 * can be associated with the library they are for.
	 */
	nload_fvmlibs = 0;
	nid_fvmlibs = 0;
	nfvmlib_segments = 0;
	mh = (struct mach_header *)cur_obj->obj_addr;
	lc = (struct load_command *)((char *)cur_obj->obj_addr +
				     sizeof(struct mach_header));
	for(i = 0; i < mh->ncmds; i++){
	    if(lc->cmd == LC_LOADFVMLIB){
		fl = (struct fvmlib_command *)lc;
		mfl = lookup_merged_fvmlib(fl);
		nload_fvmlibs++;
	    }
	    if(lc->cmd == LC_IDFVMLIB){
		fl = (struct fvmlib_command *)lc;
		mfl = lookup_merged_fvmlib(fl);
		nid_fvmlibs++;
	    }
	    else if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		if(sg->flags == SG_FVMLIB)
		    nfvmlib_segments++;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}

	/*
	 * If the output file type is MH_FVMLIB then there should be one
	 * LC_IDFVMLIB command seen in all the input files (that check is done
	 * layout_segments() in layout.c.  No LC_LOADFVMLIB commands should be
	 * seen in the input files for the MH_FVMLIB output format and this is
	 * checked in check_cur_obj() in pass1.c.
	 */
	if(filetype == MH_FVMLIB){
	    if(nid_fvmlibs > 1){
		error_with_cur_obj("contains more than one LC_IDFVMLIB load "
				   "command");
		return;
	    }
	}
	/*
	 * For output file types that are not MH_FVMLIB then.  There must be
	 * exactly one LC_LOADFVMLIB command seen in the object file which is
	 * the fixed VM library associated with these segments (if it has any
	 * of these segments).  There should not be any LC_IDFVMLIB commands
	 * seen in the input files if the output format is not MH_FVMLIB and
	 * this is checked in check_cur_obj() in pass1.c.
	 */
	else{
	    if(nfvmlib_segments == 0)
		return;
	    if(nload_fvmlibs == 0){
		error_with_cur_obj("contains SG_FVMLIB segments but no "
				   "LC_LOADFVMLIB load command");
		return;
	    }
	    if(nload_fvmlibs > 1){
		error_with_cur_obj("contains SG_FVMLIB segments and more than "
				   "one LC_LOADFVMLIB load command");
		return;
	    }
	    if(mfl->multiple)
		return;

	    lc = (struct load_command *)((char *)cur_obj->obj_addr +
					 sizeof(struct mach_header));
	    for(i = 0; i < mh->ncmds; i++){
		if(lc->cmd == LC_SEGMENT){
		    sg = (struct segment_command *)lc;
		    if(sg->flags == SG_FVMLIB)
			add_fvmlib_segment(sg,
					   (char *)fl + fl->fvmlib.name.offset);
		}
		lc = (struct load_command *)((char *)lc + lc->cmdsize);
	    }
	}
}

/*
 * lookup_merged_fvmlib() adds the LC_LOADFVMLIB structure passed to it to the
 * merged list of fixed VM libraries.  It warns if it see the same library
 * twice.
 */
static
struct merged_fvmlib *
lookup_merged_fvmlib(
struct fvmlib_command *fl)
{
    char *fvmlib_name;
    struct merged_fvmlib **p, *mfl;

	fvmlib_name = (char *)fl + fl->fvmlib.name.offset;
	p = &merged_fvmlibs;
	while(*p){
	    mfl = *p;
	    if(strcmp(mfl->fvmlib_name, fvmlib_name) == 0){
		if(mfl->multiple == FALSE){
		    if(mfl->fl->cmd == LC_IDFVMLIB)
			error("multiple object files identify fixed VM library "
			      "%s", fvmlib_name);
		    else
			warning("multiple object files load fixed VM library "
				"%s", fvmlib_name);
		    print_obj_name(mfl->definition_object);
		    print("%s fixed VM library %s\n",
			  mfl->fl->cmd == LC_LOADFVMLIB ? "loads" :"identifies",
			  fvmlib_name);
		    mfl->multiple = TRUE;
		}
		print_obj_name(cur_obj);
		print("%s fixed VM library %s\n",
		      mfl->fl->cmd == LC_LOADFVMLIB ? "loads" : "identifies",
		      fvmlib_name);
		return(mfl);
	    }
	    p = &(mfl->next);
	}
	*p = allocate(sizeof(struct merged_fvmlib));
	memset(*p, '\0', sizeof(struct merged_fvmlib));
	mfl = *p;
	mfl->fl = fl;
	mfl->fvmlib_name = fvmlib_name;
	mfl->definition_object = cur_obj;
	mfl->multiple = FALSE;
	return(mfl);
}

/*
 * add_fvmlib_segment() adds the specified segment to the list of
 * fvmlib_segments as comming from the specified fvmlib_name.
 */
static
void
add_fvmlib_segment(
struct segment_command *sg,
char *fvmlib_name)
{
    struct merged_segment **p, *msg;

	p = &fvmlib_segments;
	while(*p){
	    msg = *p;
	    p = &(msg->next);
	}
	*p = allocate(sizeof(struct merged_segment));
	msg = *p;
	memset(msg, '\0', sizeof(struct merged_segment));
	msg->sg = *sg;
	msg->filename = fvmlib_name;
}

#ifdef DEBUG
/*
 * print_load_fvmlibs_list() prints the fvmlib segments table.  For debugging.
 */
__private_extern__
void
print_load_fvmlibs_list(void)
{
    struct merged_fvmlib **p, *mfl;

	print("Load fvmlibs list\n");
	p = &merged_fvmlibs;
	while(*p){
	    mfl = *p;
	    if(mfl->fl->cmd == LC_LOADFVMLIB)
		print("    LC_LOADFVMLIB\n");
	    else
		print("    LC_IDFVMLIB\n");
	    print("\tcmdsize %u\n", mfl->fl->cmdsize);
	    if(mfl->fl->fvmlib.name.offset < mfl->fl->cmdsize)
		print("\tname %s (offset %u)\n",
		       (char *)(mfl->fl) + mfl->fl->fvmlib.name.offset,
		       mfl->fl->fvmlib.name.offset);
	    else
		print("\tname ?(bad offset %u)\n",mfl->fl->fvmlib.name.offset);
	    print("\tminor version %u\n", mfl->fl->fvmlib.minor_version);
	    print("\theader addr 0x%08x\n",
		  (unsigned int)(mfl->fl->fvmlib.header_addr));
	    print("    fvmlib_name %s\n", mfl->fvmlib_name);
	    print("    definition_object ");
	    print_obj_name(mfl->definition_object);
	    print("\n");
	    print("    multiple %s\n", mfl->multiple == TRUE ? "TRUE" :
		   "FALSE");
	    p = &(mfl->next);
	}
}

/*
 * print_fvmlib_segments() prints the fvmlib segments table.  For debugging.
 */
__private_extern__
void
print_fvmlib_segments(void)
{
    struct merged_segment **p, *msg;
    unsigned long flags;

	print("FVMLIB segments\n");
	p = &fvmlib_segments;
	while(*p){
	    msg = *p;
	    print("    filename %s\n", msg->filename);
	    print("\t      cmd LC_SEGMENT\n");
	    print("\t  cmdsize %u\n", msg->sg.cmdsize);
	    print("\t  segname %.16s\n", msg->sg.segname);
	    print("\t   vmaddr 0x%08x\n", (unsigned int)(msg->sg.vmaddr));
	    print("\t   vmsize 0x%08x\n", (unsigned int)(msg->sg.vmsize));
	    print("\t  fileoff %u\n", msg->sg.fileoff);
	    print("\t filesize %u\n", msg->sg.filesize);
	    print("\t  maxprot 0x%08x\n", (unsigned int)(msg->sg.maxprot));
	    print("\t initprot 0x%08x\n", (unsigned int)(msg->sg.initprot));
	    print("\t   nsects %u\n", msg->sg.nsects);
	    print("\t    flags");
	    if(msg->sg.flags == 0)
		print(" (none)\n");
	    else{
		flags = msg->sg.flags;
		if(flags & SG_HIGHVM){
		    print(" HIGHVM");
		    flags &= ~SG_HIGHVM;
		}
		if(flags & SG_FVMLIB){
		    print(" FVMLIB");
		    flags &= ~SG_FVMLIB;
		}
		if(flags & SG_NORELOC){
		    print(" NORELOC");
		    flags &= ~SG_NORELOC;
		}
		if(flags)
		    print(" 0x%x (unknown flags)\n", (unsigned int)flags);
		else
		    print("\n");
	    }
	    p = &(msg->next);
	}
}
#endif /* DEBUG */
#endif /* !defined(RLD) */
                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/fvmlibs.h                                0100644 0001750 0001750 00000004410 12612724205 022650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#ifndef RLD
/*
 * Global types, variables and routines declared in the file fvmlibs.c.
 *
 * The following include file need to be included before this file:
 * #include <sys/loader.h> 
 * #include "ld.h"
 */

struct merged_fvmlib {
    char *fvmlib_name;		/* The name of this fixed VM shared library. */
    struct fvmlib_command *fl;	/* The LC_LOADFVMLIB load command for this */
				/*  fixed VM shared library. */
    struct object_file		/* Pointer to the object file the load */
	*definition_object;	/*  command was found in */
    enum bool multiple;		/* Flag to indicate if this was already */
				/*  loaded from more than one object */
    struct merged_fvmlib *next;	/* The next in the list, NULL otherwise */
};

/* the pointer to the head of the load fixed VM shared library commamds */
__private_extern__ struct merged_fvmlib *merged_fvmlibs;

/* the pointer to the head of the fixed VM shared library segments */
__private_extern__ struct merged_segment *fvmlib_segments;

__private_extern__ void merge_fvmlibs(
    void);

#ifdef DEBUG
__private_extern__ void print_load_fvmlibs_list(
    void);
__private_extern__ void print_fvmlib_segments(
    void);
#endif /* DEBUG */
#endif /* !defined(RLD) */
                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/generic_reloc.c                          0100644 0001750 0001750 00000106730 12612724205 024011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to do generic relocation.  Which can be used
 * for such machines that have simple 1, 2, and 4 byte relocation lengths.
 */
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "indirect_sections.h"
#include "dylibs.h"

/*
 * generic_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 *
 * Or if refs is not NULL it is being called by to get the addresses or
 * merged_symbols from the item being referenced by the relocation entry(s) at
 * reloc_index. This is used by mark_fine_relocs_references_live() when
 * -dead_strip is specified to determined what is being referenced and is only
 * called when all sections have fine_relocs (that is why refs is only filled
 * in when nfine_relocs != 0). When refs is not NULL, only refs is filled in
 * and returned and the contents are not relocated.
 */
__private_extern__
void
generic_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map,
long pcrel_at_end_of_disp,
struct live_refs *refs,
unsigned long reloc_index)
{
    unsigned long i, j, symbolnum, value, input_pc, output_pc;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_generic r_type, pair_r_type;
    unsigned long offset;

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler "warnings: `merged_symbol', `local_map' and `offset'
	 * may be used uninitialized in this function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	offset = 0;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	pair_local_map = 0;
#endif /* DEBUG */

	if(refs != NULL)
	    memset(refs, '\0', sizeof(struct live_refs));
	else
	    reloc_index = 0;
	for(i = reloc_index; i < section_map->s->nreloc; i++){
	    force_extern_reloc = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_generic)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a GENERIC_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * GENERIC_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A GENERIC_RELOC_PAIR
		 * only follows a GENERIC_RELOC_SECTDIFF or
		 * GENERIC_RELOC_LOCAL_SECTDIFF relocation type and it
		 * is an error to see one otherwise.
		 */
		if(r_type == GENERIC_RELOC_PAIR){
		    error_with_cur_obj("stray relocation GENERIC_RELOC_PAIR "
			"entry (%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_generic)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * GENERIC_RELOC_PAIR relocation types only follow a 
	     * GENERIC_RELOC_SECTDIFF or GENERIC_RELOC_LOCAL_SECTDIFF
	     * relocation type and it is an error to
	     * see one otherwise.
	     */
	    if(r_type == GENERIC_RELOC_PAIR){
		error_with_cur_obj("stray relocation GENERIC_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section.
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.  Currently only the relocation
	     * types GENERIC_RELOC_SECTDIFF and GENERIC_RELOC_LOCAL_SECTDIFF
	     * can have a pair and itself and it's
	     * pair must be scattered relocation types.
	     */
	    pair_r_type = (enum reloc_type_generic)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == GENERIC_RELOC_SECTDIFF ||
	       r_type == GENERIC_RELOC_LOCAL_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is section difference but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_generic)
				       spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != GENERIC_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"GENERIC_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    else if(r_type != GENERIC_RELOC_VANILLA){
		error_with_cur_obj("r_type field of relocation entry %lu in "
		    "section (%.16s,%.16s) invalid", i, section_map->s->segname,
		    section_map->s->sectname);
		continue;
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry (or scattered entry).
	     */
	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * external relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in generic_reloc() failed "
				  "to lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in generic_reloc() symbol index "
			      "%lu in above file not in undefined map",
			      symbolnum);
		    }
		}
		if(refs == NULL &&
		   ((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		    (get_output_section(merged_symbol->nlist.n_sect)->
		     flags & SECTION_TYPE) == S_COALESCED)){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;

		/*
		 * If we are being called only to get the references for this
		 * relocation entry fill it in and return.
		 */
		if(refs != NULL){
		    refs->ref1.ref_type = LIVE_REF_SYMBOL;
		    refs->ref1.merged_symbol = merged_symbol;
		    refs->ref2.ref_type = LIVE_REF_NONE;
		    return;
		}

		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    switch(r_length){
		    case 0: /* byte */
			offset = get_byte((char *)(contents + r_address));
			break;
		    case 1: /* word (2 byte) */
			offset = get_short((short *)(contents + r_address));
			break;
		    case 2: /* long (4 byte) */
			offset = get_long((long *)(contents + r_address));
			break;
		    default:
			/* the error check is catched below */
			break;
		    }
		    /*
		     * If the offset is pc-relative then adjust it.
		     */
		    if(r_pcrel){
			input_pc = section_map->s->addr + r_address;
			if(pcrel_at_end_of_disp){
			    switch(r_length){
			    case 0: /* byte */
				input_pc += sizeof(char);
				break;
			    case 1: /* word (2 byte) */
				input_pc += sizeof(short);
				break;
			    case 2: /* long (4 byte) */
				input_pc += sizeof(long);
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			offset += input_pc;
		    }
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT)
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum == R_ABS){
		    /*
		     * If we are being called only to get the references for
		     * this relocation entry fill in it has none and return.
		     */
		    if(refs != NULL){
			refs->ref1.ref_type = LIVE_REF_NONE;
			refs->ref2.ref_type = LIVE_REF_NONE;
			return;
		    }
		}
		else{
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    if(local_map->s->flags & S_ATTR_DEBUG){
			error_with_cur_obj("illegal reference to debug section,"
			    " from non-debug section (%.16s,%.16s) via "
			    "relocation entry (%lu) to section (%.16s,%.16s)",
			    section_map->s->segname, section_map->s->sectname,
			    i, local_map->s->segname, local_map->s->sectname);
			return;
		    }
		    pair_local_map = NULL;
		    if(r_type == GENERIC_RELOC_SECTDIFF ||
		       r_type == GENERIC_RELOC_LOCAL_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
			if(pair_local_map->s->flags & S_ATTR_DEBUG){
			    error_with_cur_obj("illegal reference to debug "
				"section, from non-debug section (%.16s,%.16s) "
				"via relocation entry (%lu) to section (%.16s,"
				"%.16s)", section_map->s->segname,
				section_map->s->sectname, i,
				pair_local_map->s->segname,
				pair_local_map->s->sectname);
			    return;
			}
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == GENERIC_RELOC_SECTDIFF ||
			   r_type == GENERIC_RELOC_LOCAL_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation the value is set (not adjusted
			 * with addition).  So the new value is directly
			 * calculated from the old value.
			 */
			if(r_pcrel){
			    input_pc = section_map->s->addr +
				       r_address;
			    if(section_map->nfine_relocs == 0)
				output_pc = section_map->output_section->s.addr
					    + section_map->offset +
					    r_address;
			    else
				output_pc = section_map->output_section->s.addr
					    + 
					fine_reloc_output_offset(section_map,
								 r_address);
			    if(pcrel_at_end_of_disp){
				switch(r_length){
				case 0: /* byte */
				    input_pc += sizeof(char);
				    output_pc += sizeof(char);
				    break;
				case 1: /* word (2 byte) */
				    input_pc += sizeof(short);
				    output_pc += sizeof(short);
				    break;
				case 2: /* long (4 byte) */
				    input_pc += sizeof(long);
				    output_pc += sizeof(long);
				    break;
				default:
				    /* the error check is catched below */
				    break;
				}
			    }
			}
			else{
			    input_pc = 0;
			    output_pc = 0;
			}
			/*
			 * Get the value of the expresion of the item to be
			 * relocated (errors of r_length are checked later).
			 */
			switch(r_length){
			case 0: /* byte */
			    value = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    value = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    value = get_long((long *)(contents + r_address));
			    break;
			}
			if(r_type == GENERIC_RELOC_SECTDIFF ||
			   r_type == GENERIC_RELOC_LOCAL_SECTDIFF){
			    /*
			     * For GENERIC_RELOC_SECTDIFF's the item to be
			     * relocated, in value, is the value of the
			     * expression:
			     *     r_value - pair_r_value + offset
			     * To set the value of the relocated expression,
			     * it is set from relocating the two r_value's and
			     * adding back in the offset.  So here get the
			     * offset from the value of the expression.
			     */
			    value += input_pc; /* adjust for pcrel */
			    offset = value - r_value + pair_r_value;

			    /*
			     * If we are being called only to get the references
			     * for this relocation entry fill it in and return.
			     */
			    if(refs != NULL){
				fine_reloc_output_ref(
				    local_map,
				    r_value - local_map->s->addr,
				    &(refs->ref1) );
				fine_reloc_output_ref(
				    local_map,
				    pair_r_value - local_map->s->addr,
				    &(refs->ref2) );
				return;
			    }

			    /*
			     * Now build up the value of the relocated
			     * expression one part at a time.  First set the
			     * new value to the relocated r_value.
			     */
		    	    if(local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    local_map, r_value - local_map->s->addr +
				    offset, i,
				    r_type != GENERIC_RELOC_LOCAL_SECTDIFF);
				value = fine_reloc_output_address(local_map,
					    r_value - local_map->s->addr,
					    local_map->output_section->s.addr);
			    }
			    else{
				value = local_map->output_section->s.addr +
					local_map->offset +
					r_value - local_map->s->addr;
			    }
			    /* Second subtract the relocated pair_r_value. */
			    if(pair_local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    pair_local_map, pair_r_value -
				    pair_local_map->s->addr, i, TRUE);
				value -=
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
				        pair_local_map->output_section->s.addr);
			    }
			    else{
				value -=
				    pair_local_map->output_section->s.addr +
				    pair_local_map->offset +
				    pair_r_value - pair_local_map->s->addr;
			    }
			    /* Third add in the offset. */
			    value += offset;
			    value -= output_pc; /* adjust for pcrel */
			}
			else{
			    /*
			     * If the relocation entry is not a scattered
			     * relocation entry then the relocation is based on
			     * the value of value of the expresion of the item
			     * to be relocated.  If it is a scattered relocation
			     * entry then the relocation is based on the r_value
			     * in the relocation entry and the offset part of
			     * the expression at the item to be relocated is
			     * extracted so it can be added after the relocation
			     * is done.
			     */
			    value += input_pc;
			    if(r_scattered == 0){
				r_value = value;
				offset = 0;
			    }
			    else{
				offset = value - r_value;
			    }
			    /*
			     * Check to see if this reference is legal with
			     * respect to indirect sections.
			     */
			    legal_reference(section_map, r_address, local_map,
				    r_value - local_map->s->addr + offset, i,
				    FALSE);

			    /*
			     * If we are being called only to get the references
			     * for this relocation entry fill it in and return.
			     */
			    if(refs != NULL){
				fine_reloc_output_ref(
				    local_map,
				    r_value - local_map->s->addr,
				    &(refs->ref1) );
				refs->ref2.ref_type = LIVE_REF_NONE;
				return;
			    }

			    value = fine_reloc_output_address(local_map,
					r_value - local_map->s->addr,
					local_map->output_section->s.addr);
			    value -= output_pc;
			    value += offset;
			}
			switch(r_length){
			case 0: /* byte */
			    if( (value & 0xffffff00) &&
			       ((value & 0xffffff80) != 0xffffff80))
				error_with_cur_obj("relocation for entry %lu in"
				    " section (%.16s,%.16s) does not fit in 1 "
				    "byte", i, section_map->s->segname,
				    section_map->s->sectname);
			    set_byte((char *)(contents + r_address), value);
			    break;
			case 1: /* word (2 byte) */
			    if( (value & 0xffff0000) &&
			       ((value & 0xffff8000) != 0xffff8000))
				error_with_cur_obj("relocation for entry %lu in"
				    " section (%.16s,%.16s) does not fit in 2 "
				    "bytes", i, section_map->s->segname,
				    section_map->s->sectname);
			    set_short((short *)(contents + r_address), value);
			    break;
			case 2: /* long (4 byte) */
			    set_long((long *)(contents + r_address), value);
			    break;
			default:
			    error_with_cur_obj("r_length field of relocation "
				"entry %lu in section (%.16s,%.16s) invalid",
				i, section_map->s->segname,
				section_map->s->sectname);
			    return;
			}
			goto update_reloc;
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr /* + r_address */
			     - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else
		    value += + section_map->s->addr + r_address
			     - (section_map->output_section->s.addr +
			        fine_reloc_output_offset(section_map,
							 r_address));
	    }
	    switch(r_length){
	    case 0: /* byte */
		value += get_byte((char *)(contents + r_address));
		if( (value & 0xffffff00) &&
		   ((value & 0xffffff80) != 0xffffff80))
		    error_with_cur_obj("relocation for entry %lu in section "
			"(%.16s,%.16s) does not fit in 1 byte", i,
			section_map->s->segname, section_map->s->sectname);
		set_byte((char *)(contents + r_address), value);
		break;
	    case 1: /* word (2 byte) */
		value += get_short((short *)(contents + r_address));
		if( (value & 0xffff0000) &&
		   ((value & 0xffff8000) != 0xffff8000))
		    error_with_cur_obj("relocation for entry %lu in section "
			"(%.16s,%.16s) does not fit in 2 bytes", i,
			section_map->s->segname, section_map->s->sectname);
		set_short((short *)(contents + r_address), value);
		break;
	    case 2: /* long (4 byte) */
		value += get_long((long *)(contents + r_address));
		set_long((long *)(contents + r_address), value);
		break;
	    default:
		error_with_cur_obj("r_length field of relocation entry %lu in "
		    "section (%.16s,%.16s) invalid", i,
		    section_map->s->segname, section_map->s->sectname);
		return;
	    }
	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
update_reloc:
	    ;
#ifndef RLD
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a GENERIC_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			if((r_address & 0x00ffffff) != r_address)
			    error_with_cur_obj("Can't create valid output "
				"file (r_address field of relocation "
				"entry %lu in section (%.16s,%.16s) would "
				"overflow)", i, section_map->s->segname,
				section_map->s->sectname);
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = GENERIC_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		            (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		            force_extern_reloc == FALSE &&
		            ((filetype != MH_DYLIB ||
			      multi_module_dylib == FALSE) ||
			     (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value and the output is not for
			     * dyld make it a scattered relocation entry else
			     * make it a local relocation entry.
			     */
			    if(offset == 0 || output_for_dyld){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				if((r_address & 0x00ffffff) != r_address)
				    error_with_cur_obj("Can't create valid "
					"output file (r_address field of "
					"relocation entry %lu in section "
					"(%.16s,%.16s) would overflow)", i,
					section_map->s->segname,
					section_map->s->sectname);
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = 0;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a GENERIC_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			if((r_address & 0x00ffffff) != r_address)
			    error_with_cur_obj("Can't create valid output "
				"file (r_address field of relocation "
				"entry %lu in section (%.16s,%.16s) would "
				"overflow)", i, section_map->s->segname,
				section_map->s->sectname);
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = GENERIC_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    else if(reloc->r_symbolnum != R_ABS){
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		}
		else{
		    /*
		     * This is a scattered relocation entry.  If the output is
		     * for dyld convert it to a local relocation entry so as
		     * to not overflow the 24-bit r_address field in a scattered
		     * relocation entry.  The overflow would happen in
		     * reloc_output_for_dyld() in sections.c when it adjusts
		     * the r_address fields of the relocation entries.
		     */
		    if(output_for_dyld){
			reloc = (struct relocation_info *)sreloc;
			r_scattered = 0;
			reloc->r_address = r_address;
			reloc->r_pcrel = r_pcrel;
			reloc->r_extern = 0;
			reloc->r_length = r_length;
			reloc->r_type = r_type;
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		    else{
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(local_map->nfine_relocs == 0)
			    sreloc->r_value +=
					   - local_map->s->addr
					   + local_map->output_section->s.addr +
					   local_map->offset;
			else
			    sreloc->r_value =
					fine_reloc_output_address(local_map,
						r_value - local_map->s->addr,
					   local_map->output_section->s.addr);
		    }
		}
		/*
		 * If this section that the reloation is being done for has fine
		 * relocation then the offset in the r_address field has to be
		 * set to where it will end up in the output file.  Otherwise
		 * it simply has to have the offset to where this contents
		 * appears in the output file. 
		 */
		if(r_scattered == 0){
		    if(section_map->nfine_relocs == 0){
			reloc->r_address += section_map->offset;
		    }
		    else{
			reloc->r_address = fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		else{
		    if(section_map->nfine_relocs == 0){
			if(((sreloc->r_address + section_map->offset) &
			    0x00ffffff) !=
			    sreloc->r_address + section_map->offset)
			    error_with_cur_obj("Can't create valid output "
				"file (r_address field of relocation "
				"entry %lu in section (%.16s,%.16s) would "
				"overflow)", i, section_map->s->segname,
				section_map->s->sectname);
			sreloc->r_address += section_map->offset;
		    }
		    else{
			r_address = fine_reloc_output_offset(section_map,
							     r_address);
			if((r_address & 0x00ffffff) != r_address)
			    error_with_cur_obj("Can't create valid output "
				"file (r_address field of relocation "
				"entry %lu in section (%.16s,%.16s) would "
				"overflow)", i, section_map->s->segname,
				section_map->s->sectname);
			sreloc->r_address = r_address;
		    }
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == GENERIC_RELOC_PAIR){
		    if(spair_reloc != NULL){
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(pair_local_map->nfine_relocs == 0)
			    spair_reloc->r_value +=
				- pair_local_map->s->addr
				+ (pair_local_map->output_section->s.addr +
				   pair_local_map->offset);
			else
			    spair_reloc->r_value =
				fine_reloc_output_address(pair_local_map,
				    pair_r_value - pair_local_map->s->addr,
				    pair_local_map->output_section->s.addr);
		    }
		    else{
			fatal("internal error, in generic_reloc() pair_r_type "
			    "is GENERIC_RELOC_PAIR but spair_reloc is NULL");
		    }
		}
	    }
#endif /* !defined(RLD) */
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == GENERIC_RELOC_PAIR)
		i++;
	}
}

__private_extern__
int
undef_bsearch(
const unsigned long *index,
const struct undefined_map *undefined_map)
{
	return(*index - undefined_map->index);
}
                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/generic_reloc.h                          0100644 0001750 0001750 00000004730 12612724205 024013  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file generic_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void generic_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *map,
    long pcrel_at_end_of_disp,
    struct live_refs *refs,
    unsigned long reloc_index);

__private_extern__ int undef_bsearch(
    const unsigned long *index,
    const struct undefined_map *undefined_map);

/*
 * These routines are used to get/set values that might not be aligned correctly
 * which are being relocated.
 */
static
inline
long
get_long(
void *addr)
{
    long l;

	memcpy(&l, addr, sizeof(long));
	if(cur_obj->swapped)
	    return(SWAP_LONG(l));
	else
	    return(l);
}

static
inline
short
get_short(
void *addr)
{
    short s;

	memcpy(&s, addr, sizeof(short));
	if(cur_obj->swapped)
	    return(SWAP_SHORT(s));
	else
	    return(s);
}

static
inline
char
get_byte(
char *addr)
{
	return(*addr);
}

static
inline
void
set_long(
void *addr,
long value)
{
	if(cur_obj->swapped)
	    value = SWAP_LONG(value);
	memcpy(addr, &value, sizeof(long));
}

static
inline
void
set_short(
void *addr,
short value)
{
    if(cur_obj->swapped)
	value = SWAP_SHORT(value);
    memcpy(addr, &value, sizeof(short));
}

static
inline
void
set_byte(
char *addr,
char value)
{
	*addr = value;
}
                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/hash_string.h                            0100644 0001750 0001750 00000002527 12612724205 023526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * hash_string() compute a hash code for the specified null terminated string.
 * The caller can then mod it with the size of the hash table.
 */
static
inline
unsigned long
hash_string(
char *key,
unsigned long *len)
{
    char *cp;
    long k;

	cp = key;
	k = 0;
	while(*cp)
	    k = (((k << 1) + (k >> 14)) ^ (*cp++)) & 0x3fff;
	if(len != NULL)
	    *len = cp - key;
	return(k);
}
                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/hppa_reloc.c                             0100644 0001750 0001750 00000125006 12612724205 023322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to do relocation for hp pa-risc.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/hppa/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"
#include "stuff/hppa.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "hppa_reloc.h"
#include "indirect_sections.h"
#include "dylibs.h"

#define U_ABS(l) (((long)(l))<0 ? (unsigned long)(-(l)) : (l))

/*
 * hppa_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 */
__private_extern__
void
hppa_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map)
{
    unsigned long i, j, symbolnum, value, input_pc, output_pc;
    unsigned long instruction, immediate;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_hppa r_type, pair_r_type;
    unsigned long other_half;
    unsigned long offset;
    uint32_t hi21, lo14;
    uint32_t w, w1, w2;

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler "warnings: ... may be used uninitialized in this
	 * function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	instruction = 0;
	other_half = 0;
	immediate = 0;
	offset = 0;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	pair_local_map = NULL;
#endif /* defined(DEBUG) || defined(RLD) */

	for(i = 0; i < section_map->s->nreloc; i++){
	    force_extern_reloc = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_hppa)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a HPPA_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * HPPA_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A HPPA_RELOC_PAIR
		 * follow HPPA_RELOC_{HI21,LO14,BR17,JBSR,SECTDIFF,
		 * HI21_SECTDIFF,LO14_SECTDIFF} relocation types and it is
		 * an error to see one otherwise.
		 */
		if(r_type == HPPA_RELOC_PAIR){
		    error_with_cur_obj("stray relocation HPPA_RELOC_PAIR entry "
			"(%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_hppa)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * HPPA_RELOC_PAIR relocation types only follows HPPA_RELOC_
	     * {HI21,LO14,BR17,JBSR,SECTDIFF,HI21_SECTDIFF,LO14_SECTDIFF}
	     * relocation types and it is an error to
	     * see one otherwise.
	     */
	    if(r_type == HPPA_RELOC_PAIR){
		error_with_cur_obj("stray relocation HPPA_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section (Note
	     * that this is not the case for HPPA_RELOC_PAIR entries but this
	     * can't be one with the above checks).
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.
	     */
	    pair_r_type = (enum reloc_type_hppa)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == HPPA_RELOC_HI21 || r_type == HPPA_RELOC_LO14 ||
	       r_type == HPPA_RELOC_BR17 || r_type == HPPA_RELOC_JBSR) {
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc  = NULL;
			pair_r_type = (enum reloc_type_hppa)spair_reloc->r_type;
			other_half  = spair_reloc->r_address;
		    }
		    else{
			pair_r_type = (enum reloc_type_hppa)pair_reloc->r_type;
			other_half  = pair_reloc->r_address;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != HPPA_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"HPPA_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
	    }
	    else if(r_type == HPPA_RELOC_SECTDIFF ||
		    r_type == HPPA_RELOC_HI21_SECTDIFF ||
		    r_type == HPPA_RELOC_LO14_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is HPPA_RELOC_SECTDIFF but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_hppa)spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
			other_half  = spair_reloc->r_address;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != HPPA_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"HPPA_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry (or scattered entry).
	     */
	    input_pc = section_map->s->addr + r_address;
	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in hppa_reloc() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in hppa_reloc() symbol index %lu"
			    " in above file not in undefined map", symbolnum);
		    }
		}
		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		   (get_output_section(merged_symbol->nlist.n_sect)->
		    flags & SECTION_TYPE) == S_COALESCED){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    if(r_type == HPPA_RELOC_VANILLA){
			switch(r_length){
			case 0: /* byte */
			    offset = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    offset = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    offset = get_long((long *)(contents + r_address));
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
			if(r_pcrel)
			    offset += input_pc;
		    }
		    else{
			instruction = get_long((long *)(contents + r_address));
			switch(r_type){
			case HPPA_RELOC_HI21:
			    offset = (assemble_21(instruction & 0x1fffff) << 11)
			             + sign_ext(other_half, 14);
			    break;
			case HPPA_RELOC_LO14:
			    offset = instruction & 0x3fff;
			    offset = low_sign_ext(offset, 14) + 
			             (other_half << 11);
			    break;
			case HPPA_RELOC_BR17:
			case HPPA_RELOC_BL17:
			    /* assemble low part */
			    offset = assemble_17(
			           (instruction & 0x1f0000) >> 16,
			           (instruction & 0x1ffc) >> 2,
				    instruction & 1);
			    /* sign extend it  */
			    offset = sign_ext(offset, 17);
			    /* its a word displacement */
			    offset <<= 2;
			    if(r_type == HPPA_RELOC_BR17)
				offset += other_half << 11;
			    else
				offset += 8;
			    break;
			case HPPA_RELOC_JBSR:
			    offset = sign_ext(other_half, 24);
			    if((merged_symbol->nlist.n_type & N_TYPE) ==
				N_SECT){
				other_half = value - output_sections[
					merged_symbol->nlist.n_sect]->s.addr +
					offset;
			       other_half = sign_unext(other_half, 24);
			    }
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
		    }
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT)
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum != R_ABS){
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    if(local_map->s->flags & S_ATTR_DEBUG){
			error_with_cur_obj("illegal reference to debug section,"
			    " from non-debug section (%.16s,%.16s) via "
			    "relocation entry (%lu) to section (%.16s,%.16s)",
			    section_map->s->segname, section_map->s->sectname,
			    i, local_map->s->segname, local_map->s->sectname);
			return;
		    }
		    pair_local_map = NULL;
		    if(r_type == HPPA_RELOC_SECTDIFF ||
		       r_type == HPPA_RELOC_HI21_SECTDIFF ||
		       r_type == HPPA_RELOC_LO14_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
			if(pair_local_map->s->flags & S_ATTR_DEBUG){
			    error_with_cur_obj("illegal reference to debug "
				"section, from non-debug section (%.16s,%.16s) "
				"via relocation entry (%lu) to section (%.16s,"
				"%.16s)", section_map->s->segname,
				section_map->s->sectname, i,
				pair_local_map->s->segname,
				pair_local_map->s->sectname);
			    return;
			}
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == HPPA_RELOC_SECTDIFF ||
			   r_type == HPPA_RELOC_HI21_SECTDIFF ||
			   r_type == HPPA_RELOC_LO14_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation the value is set (not adjusted
			 * with addition).  So the new value is directly
			 * calculated from the old value.
			 */
			if(r_pcrel) {
			    if(section_map->nfine_relocs == 0)
				output_pc = section_map->output_section->s.addr
					    + section_map->offset +
					    r_address;
			    else
				output_pc = section_map->output_section->s.addr
					    + 
					fine_reloc_output_offset(section_map,
								 r_address);
			}
			else{
			    input_pc = 0;
			    output_pc = 0;
			}
			/*
			 * Get the value of the expresion of the item to be
			 * relocated.
			 */
			if(r_type == HPPA_RELOC_VANILLA ||
			   r_type == HPPA_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				value = get_byte((char *)(contents +
							  r_address));
				break;
			    case 1: /* word (2 byte) */
				value = get_short((short *)(contents +
							    r_address));
				break;
			    case 2: /* long (4 byte) */
				value = get_long((long *)(contents +
							  r_address));
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			else{
			    instruction = get_long((long *)(contents +
							    r_address));
			    switch(r_type){
			    case HPPA_RELOC_HI21:
			    case HPPA_RELOC_HI21_SECTDIFF:
				value = (assemble_21(instruction & 0x1fffff) 
				         << 11) + sign_ext(other_half, 14);
				break;
			    case HPPA_RELOC_LO14:
			    case HPPA_RELOC_LO14_SECTDIFF:
				value = instruction & 0x3fff;
				value = low_sign_ext(value, 14) + 
				        (other_half << 11);
				break;
			    case HPPA_RELOC_BR17:
			    case HPPA_RELOC_BL17:
				value = assemble_17(
				          (instruction & 0x1f0000) >> 16,
				          (instruction & 0x1ffc) >> 2,
				          instruction & 1);
			        value = sign_ext(value, 17) << 2;
			        if(r_type == HPPA_RELOC_BR17)
				    value += (other_half << 11);
				else
				    value += 8;
				break;
			     case HPPA_RELOC_JBSR:
			        value = local_map->s->addr +
					sign_ext(other_half, 24);
				if(r_scattered == 0)
				    other_half = fine_reloc_output_offset(
							local_map, other_half);
				else{
				    other_half = fine_reloc_output_offset(
						 local_map,
						 r_value - local_map->s->addr) +
						 sign_ext(other_half, 24) -
						 (r_value - local_map->s->addr);
				    other_half = sign_unext(other_half, 24);
				}
			        break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			if(r_type == HPPA_RELOC_SECTDIFF ||
			   r_type == HPPA_RELOC_HI21_SECTDIFF ||
			   r_type == HPPA_RELOC_LO14_SECTDIFF){
			    /*
			     * For HPPA_RELOC_SECTDIFF's the item to be
			     * relocated, in value, is the value of the
			     * expression:
			     *     r_value - pair_r_value + offset
			     * To set the value of the relocated expression,
			     * it is set from relocating the two r_value's and
			     * adding back in the offset.  So here get the
			     * offset from the value of the expression.
			     */
			    value += input_pc; /* adjust for pcrel */
			    offset = value - r_value + pair_r_value;

			    /*
			     * Now build up the value of the relocated
			     * expression one part at a time.  First set the
			     * new value to the relocated r_value.
			     */
		    	    if(local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    local_map, r_value - local_map->s->addr +
				    offset, i, TRUE);
				value = fine_reloc_output_address(local_map,
					    r_value - local_map->s->addr,
					    local_map->output_section->s.addr);
			    }
			    else{
				value = local_map->output_section->s.addr +
					local_map->offset +
					r_value - local_map->s->addr;
			    }
			    /* Second subtract the relocated pair_r_value. */
			    if(pair_local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    pair_local_map, pair_r_value -
				    pair_local_map->s->addr, i, TRUE);
				value -=
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
				        pair_local_map->output_section->s.addr);
			    }
			    else{
				value -=
				    pair_local_map->output_section->s.addr +
				    pair_local_map->offset +
				    pair_r_value - pair_local_map->s->addr;
			    }
			    /* Third add in the offset. */
			    value += offset;
			    value -= output_pc; /* adjust for pcrel */
			}
			else{
			    /*
			     * If the relocation entry is not a scattered
			     * relocation entry then the relocation is based on
			     * the value of value of the expresion of the item
			     * to be relocated.  If it is a scattered relocation
			     * entry then the relocation is based on the r_value
			     * in the relocation entry and the offset part of
			     * the expression at the item to be relocated is
			     * extracted so it can be added after the relocation
			     * is done.
			     */
			    value += input_pc;
			    if(r_scattered == 0){
				r_value = value;
				offset = 0;
			    }
			    else{
				offset = value - r_value;
			    }
			    /*
			     * Check to see if this reference is legal with
			     * respect to indirect sections.
			     */
			    legal_reference(section_map, r_address, local_map,
				    r_value - local_map->s->addr + offset, i,
				    FALSE);
			    value = fine_reloc_output_address(local_map,
					r_value - local_map->s->addr,
					local_map->output_section->s.addr);
			    value -= output_pc;
			    value += offset;
			}
			if(r_type == HPPA_RELOC_VANILLA ||
			   r_type == HPPA_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				if( (value & 0xffffff00) &&
				   ((value & 0xffffff80) != 0xffffff80))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 1 byte", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_byte((char *)(contents + r_address), value);
				break;
			    case 1: /* word (2 byte) */
				if( (value & 0xffff0000) &&
				   ((value & 0xffff8000) != 0xffff8000))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 2 bytes", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_short((short *)(contents + r_address),
					  value);
				break;
			    case 2: /* long (4 byte) */
				set_long((long *)(contents + r_address), value);
				break;
			    default:
				error_with_cur_obj("r_length field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			}
			else{
			    calc_hppa_HILO(value - offset, offset, &hi21,&lo14);
			    
			    switch(r_type){
			    case HPPA_RELOC_HI21:
			    case HPPA_RELOC_HI21_SECTDIFF:
				other_half = lo14 & 0x3fff;
				instruction = (instruction & 0xffe00000) |
					      dis_assemble_21(hi21 >> 11);
				break;
			    case HPPA_RELOC_LO14:
			    case HPPA_RELOC_LO14_SECTDIFF:
				other_half = hi21 >> 11;
				lo14 = low_sign_unext(lo14, 14);
				instruction = (instruction & 0xffffc000) |
					      (lo14 & 0x3fff);
				break;
			    case HPPA_RELOC_BR17:
				other_half = hi21 >> 11;
				if((lo14 & 3) != 0)
				    error_with_cur_obj("relocation entry %lu in"
					" section (%.16s,%.16s) (branch offset "
					"not a multiple of 4)", i,
					section_map->s->segname,
					section_map->s->sectname);
				lo14 >>= 2;
				dis_assemble_17(lo14, &w1, &w2, &w);
				instruction = (instruction & 0xffe0e002) |
					      (w1 << 16) | (w2 << 2) | w;
				break;
			    case HPPA_RELOC_BL17:
				value -= 8;
				if((value & 3) != 0)
				    error_with_cur_obj("relocation entry %lu in"
					" section (%.16s,%.16s) (branch offset "
					"not a multiple of 4)", i,
					section_map->s->segname,
					section_map->s->sectname);
				if(U_ABS(value) > 0x3ffff) 
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
			        value >>= 2;
				dis_assemble_17(value, &w1, &w2, &w);
				instruction = (instruction & 0xffe0e002) |
					      (w1 << 16) | (w2 << 2) | w;
				break;
			    case HPPA_RELOC_JBSR:
				if(section_map->nfine_relocs == 0)
				    value -= section_map->output_section->s.addr
					     + section_map->offset + r_address +
					     8;
				else
				    value -= section_map->output_section->s.addr
					     + fine_reloc_output_offset(
						    section_map, r_address) +
					     8;
				if(save_reloc == 0 &&
				   ((filetype != MH_DYLIB ||
			             multi_module_dylib == FALSE) ||
				    (r_extern == 1 &&
				    (merged_symbol->nlist.n_type & N_PEXT) ==
								N_PEXT)) &&
				   (output_for_dyld == FALSE || r_extern == 0 ||
				    (merged_symbol->nlist.n_type & N_TYPE) !=
								N_UNDF) &&
				   (U_ABS(value) <= 0x3ffff)){
				    value = value >> 2;
				    dis_assemble_17(value, &w1, &w2, &w);
				    instruction = (instruction & 0xffe0e002) |
						  (w1 << 16) | (w2 << 2) | w;
				}
				break;
			    default:
				error_with_cur_obj("r_type field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			    set_long((long *)(contents + r_address),
				     instruction);
			}

			goto update_reloc;
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr /* + r_address */
			     - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else
		    value += + section_map->s->addr + r_address
			     - (section_map->output_section->s.addr +
			        fine_reloc_output_offset(section_map,
							 r_address));
	    }
	    if(r_type == HPPA_RELOC_VANILLA ||
	       r_type == HPPA_RELOC_SECTDIFF){
		switch(r_length){
		case 0: /* byte */
		    value += get_byte((char *)(contents + r_address));
		    if( (value & 0xffffff00) &&
		       ((value & 0xffffff80) != 0xffffff80))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 1 byte", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_byte((char *)(contents + r_address), value);
		    break;
		case 1: /* word (2 byte) */
		    value += get_short((short *)(contents + r_address));
		    if( (value & 0xffff0000) &&
		       ((value & 0xffff8000) != 0xffff8000))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 2 bytes", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_short((short *)(contents + r_address), value);
		    break;
		case 2: /* long (4 byte) */
		    value += get_long((long *)(contents + r_address));
		    set_long((long *)(contents + r_address), value);
		    break;
		default:
		    error_with_cur_obj("r_length field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * Do hppa specific relocation based on the r_type.
	     */
	    else{
		instruction = get_long((long *)(contents + r_address));
		switch(r_type){
		case HPPA_RELOC_HI21_SECTDIFF:
		    immediate = sign_ext(other_half, 14) + 
		               (assemble_21(instruction & 0x1fffff) << 11);
		    calc_hppa_HILO(value + r_value - pair_r_value,
				   immediate - r_value + pair_r_value,
				   &hi21, &lo14);
		    instruction = (instruction & 0xffe00000) |
				  dis_assemble_21(hi21 >> 11);
		    other_half = lo14 & 0x3fff;
		    break;

		case HPPA_RELOC_HI21:
		    immediate = sign_ext(other_half, 14) + 
		               (assemble_21(instruction & 0x1fffff) << 11);
		    if(r_extern)
			calc_hppa_HILO(value, immediate, &hi21, &lo14);
		    else if(r_scattered)
			calc_hppa_HILO(value + r_value, immediate - r_value,
				       &hi21, &lo14);
		    else
			calc_hppa_HILO(value + immediate, 0, &hi21, &lo14);
		    instruction = (instruction & 0xffe00000) |
				  dis_assemble_21(hi21 >> 11);
		    other_half = lo14 & 0x3fff;
		    break;
		case HPPA_RELOC_LO14:
		    immediate = low_sign_ext(instruction & 0x3fff, 14);
		    immediate += (other_half << 11);
		    if(r_extern)
			calc_hppa_HILO(value, immediate, &hi21, &lo14);
		    else if(r_scattered)
			calc_hppa_HILO(value + r_value, immediate - r_value,
				       &hi21, &lo14);
		    else
			calc_hppa_HILO(value + immediate, 0, &hi21, &lo14);
		    lo14 = low_sign_unext(lo14, 14);
		    instruction = (instruction & 0xffffc000) |
				  (lo14 & 0x3fff);
		    other_half = hi21 >> 11;
		    break;
		case HPPA_RELOC_LO14_SECTDIFF:
		    immediate = low_sign_ext(instruction & 0x3fff, 14);
		    immediate += (other_half << 11);
		    calc_hppa_HILO(value + r_value - pair_r_value,
				   immediate - r_value + pair_r_value,
				   &hi21, &lo14);
		    lo14 = low_sign_unext(lo14, 14);
		    instruction = (instruction & 0xffffc000) |
				  (lo14 & 0x3fff);
		    other_half = hi21 >> 11;
		    break;
		case HPPA_RELOC_BR17:
		    immediate = assemble_17((instruction & 0x1f0000) >> 16,
			                    (instruction & 0x1ffc) >> 2,
				             instruction & 1);
		    immediate = (sign_ext(immediate, 17) << 2) +
				(other_half << 11);
		    if(r_extern)
			calc_hppa_HILO(value, immediate, &hi21, &lo14);
		    else if(r_scattered)
			calc_hppa_HILO(value + r_value, immediate - r_value,
				       &hi21, &lo14);
		    else
			calc_hppa_HILO(value + immediate, 0, &hi21, &lo14);
		    lo14 >>= 2;
		    other_half = hi21 >> 11;
		    dis_assemble_17(lo14, &w1, &w2, &w);
		    instruction = (instruction & 0xffe0e002) |
				  (w1 << 16) | (w2 << 2) | w;
		    break;
		case HPPA_RELOC_BL17:
		    immediate = assemble_17((instruction & 0x1f0000) >> 16,
			                    (instruction & 0x1ffc) >> 2,
				             instruction & 1);
		    if((immediate & 0x10000) != 0)
			immediate |= 0xfffe0000;
		    immediate <<= 2;
		    immediate += value;
		    if(U_ABS(immediate) > 0x3ffff)
			error_with_cur_obj("relocation overflow "
				"for relocation entry %lu in section "
				"(%.16s,%.16s) (displacement too large)"
				, i, section_map->s->segname,
				section_map->s->sectname);
		    immediate >>= 2;
		    dis_assemble_17(immediate, &w1, &w2, &w);
		    instruction = (instruction & 0xffe0e002) |
				  (w1 << 16) | (w2 << 2) | w;
		    break;
		case HPPA_RELOC_JBSR:
		    if(r_extern)
			value += offset;
		    else{
			value += local_map->s->addr + sign_ext(other_half, 24);
			other_half = local_map->offset +
				     sign_ext(other_half, 24);
		    }
		    if(section_map->nfine_relocs == 0)
			value += - (section_map->output_section->s.addr +
				    section_map->offset + r_address +
				    8);
		    else
			value += - (section_map->output_section->s.addr +
				    fine_reloc_output_offset(section_map,
							     r_address) +
				    8);
		    if(save_reloc == 0 &&
		       ((filetype != MH_DYLIB || multi_module_dylib == FALSE) ||
			(r_extern == 1 &&
			(merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)) &&
		       (output_for_dyld == FALSE || r_extern == 0 ||
			(merged_symbol->nlist.n_type & N_TYPE) != N_UNDF) &&
		       (U_ABS(value) <= 0x3ffff)){
			value = value >> 2;
			dis_assemble_17(value, &w1, &w2, &w);
			instruction = (instruction & 0xffe0e002) |
				      (w1 << 16) | (w2 << 2) | w;
		    }
		    break;
		default:
		    error_with_cur_obj("r_type field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		set_long((long *)(contents + r_address), instruction);
	    }

	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
update_reloc:
	    ;
#ifndef RLD
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a HPPA_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = HPPA_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		            (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		            force_extern_reloc == FALSE &&
		            ((filetype != MH_DYLIB ||
			      multi_module_dylib == FALSE) ||
			     (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value and the output is not for
			     * dyld make it a scattered relocation entry else
			     * make it a local relocation entry.
			     */
			    if(offset == 0 || output_for_dyld){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = r_type;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a HPPA_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = HPPA_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    else if(reloc->r_symbolnum != R_ABS){
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		}
		else{
		    /*
		     * This is a scattered relocation entry.  If the output is
		     * for dyld convert it to a local relocation entry so as
		     * to not overflow the 24-bit r_address field in a scattered
		     * relocation entry.  The overflow would happen in
		     * reloc_output_for_dyld() in sections.c when it adjusts
		     * the r_address fields of the relocation entries.
		     */
		    if(output_for_dyld){
			reloc = (struct relocation_info *)sreloc;
			r_scattered = 0;
			reloc->r_address = r_address;
			reloc->r_pcrel = r_pcrel;
			reloc->r_extern = 0;
			reloc->r_length = r_length;
			reloc->r_type = r_type;
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		    else{
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(local_map->nfine_relocs == 0)
			    sreloc->r_value +=
					   - local_map->s->addr
					   + local_map->output_section->s.addr +
					   local_map->offset;
			else
			    sreloc->r_value =
					fine_reloc_output_address(local_map,
						r_value - local_map->s->addr,
					   local_map->output_section->s.addr);
		    }
		}
		/*
		 * If this section that the reloation is being done for has fine
		 * relocation then the offset in the r_address field has to be
		 * set to where it will end up in the output file.  Otherwise
		 * it simply has to have the offset to where this contents
		 * appears in the output file. 
		 */
		if(r_scattered == 0){
		    if(section_map->nfine_relocs == 0){
			reloc->r_address += section_map->offset;
		    }
		    else{
			reloc->r_address = fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		else{
		    if(section_map->nfine_relocs == 0){
			sreloc->r_address += section_map->offset;
		    }
		    else{
			sreloc->r_address =fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == HPPA_RELOC_PAIR){
		    if(pair_reloc != NULL)
			pair_reloc->r_address = other_half;
		    else if(spair_reloc != NULL){
			if(r_type == HPPA_RELOC_SECTDIFF ||
			   r_type == HPPA_RELOC_HI21_SECTDIFF ||
			   r_type == HPPA_RELOC_LO14_SECTDIFF){
			    /*
			     * For HPPA_RELOC_SECTDIFF relocation entries (which
			     * are always scattered types) the r_value field is
			     * relocated.
			     */
			    if(pair_local_map->nfine_relocs == 0)
				spair_reloc->r_value +=
				    - pair_local_map->s->addr
				    + (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			    else
				spair_reloc->r_value =
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
					pair_local_map->output_section->s.addr);
			    if(r_type == HPPA_RELOC_HI21_SECTDIFF ||
			       r_type == HPPA_RELOC_LO14_SECTDIFF)
				spair_reloc->r_address = other_half;
			}
			else{
			    spair_reloc->r_address = other_half;
			}
		    }
		    else{
			fatal("internal error, in hppa_reloc() pair_r_type "
			    "is HPPA_RELOC_PAIR but pair_reloc and spair_reloc "
			    "are NULL");
		    }
		}
	    }
#endif /* !defined(RLD) */
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == HPPA_RELOC_PAIR)
		i++;
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/hppa_reloc.h                             0100644 0001750 0001750 00000002612 12612724205 023324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file hppa_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void hppa_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *map);
                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/i860_reloc.c                             0100644 0001750 0001750 00000074073 12612724205 023067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef RLD
/*
 * This file contains the routines to do relocation for the i860.  Since this is
 * a RISC machine that has items to be relocated that are not always 32 bits
 * wide and that two different references to the same symbol may share the same
 * high 16 bits scattered relocation can't be performed.  It is treated as an
 * error in the object file to see a scattered relocation entry.  And it is an
 * interal error if any section has fine relocations (this may be relaxed at
 * some time in the future if all the cases can be delt with).
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/i860/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "i860_reloc.h"
#include "dylibs.h"

/*
 * i860_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 */
__private_extern__
void
i860_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map)
{
    unsigned long i, j, symbolnum, value;
    unsigned long instruction, immediate;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_i860 r_type, pair_r_type;
    unsigned short other_half;
    unsigned long offset;

#ifdef DEBUG
	/*
	 * The compiler "warnings: `merged_symbol', `local_map' and `immediate'
	 * may be used uninitialized in this function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	immediate = 0;
	pair_local_map = NULL;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	other_half = 0;
	offset = 0;
#endif /* DEBUG */

	for(i = 0; i < section_map->s->nreloc; i++){
	    force_extern_reloc = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_i860)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a I860_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * I860_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A I860_RELOC_PAIR
		 * only follows I860_RELOC_HIGH, I860_RELOC_HIGHADJ and
		 * I860_RELOC_SECTDIFF relocation types and it is an error
		 * to see one otherwise.
		 */
		if(r_type == I860_RELOC_PAIR){
		    error_with_cur_obj("stray relocation I860_RELOC_PAIR entry "
			"(%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_i860)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * I860_RELOC_PAIR relocation types only follow I860_RELOC_HIGH,
	     * I860_RELOC_HIGHADJ and I860_RELOC_SECTDIFF relocation types and
	     * it is an error to see one otherwise.
	     */
	    if(r_type == I860_RELOC_PAIR){
		error_with_cur_obj("stray relocation I860_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section (Note
	     * that this is not the case for I860_RELOC_PAIR entries but this
	     * can't be one with the above check).
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.
	     */
	    pair_r_type = (enum reloc_type_i860)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == I860_RELOC_HIGH || r_type == I860_RELOC_HIGHADJ){
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc  = NULL;
			pair_r_type = (enum reloc_type_i860)spair_reloc->r_type;
			other_half  = spair_reloc->r_address & 0xffff;
		    }
		    else{
			pair_r_type = (enum reloc_type_i860)pair_reloc->r_type;
			other_half  = pair_reloc->r_address & 0xffff;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != I860_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"I860_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
	    }
	    else if(r_type == I860_RELOC_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is I860_RELOC_SECTDIFF but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_i860)spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != I860_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"I860_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry.
	     */
	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in i860_reloc() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in i860_reloc() symbol index %lu"
			    " in above file not in undefined map", symbolnum);
		    }
		}
		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		   (get_output_section(merged_symbol->nlist.n_sect)->
		    flags & SECTION_TYPE) == S_COALESCED){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    if(r_type == I860_RELOC_VANILLA){
			switch(r_length){
			case 0: /* byte */
			    offset = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    offset = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    offset = get_long((long *)(contents + r_address));
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
			if(r_pcrel)
			    offset += section_map->s->addr + r_address;
		    }
		    else{
			instruction = get_long((long *)(contents + r_address));
			switch(r_type){
			case I860_RELOC_HIGH:
			    offset = ((instruction & 0xffff) << 16) |
				     other_half;
			    break;
			case I860_RELOC_HIGHADJ:
			    if(other_half & 0x8000)
				offset = ((instruction & 0xffff) << 16) +
					 (other_half | 0xffff0000);
			    else
				offset = ((instruction & 0xffff) << 16) +
					 other_half;
			    break;
			case I860_RELOC_LOW0:
			    offset = instruction & 0xffff;
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_LOW1:
			    offset = instruction & 0xfffe;
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_LOW2:
			    offset = instruction & 0xfffc;
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_LOW3:
			    offset = instruction & 0xfff8;
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_LOW4:
			    offset = instruction &0xfff0;
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_SPLIT0:
			    offset = ((instruction >> 5) & 0xf800) |
				     (instruction & 0x7ff);
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    /*
			     * This is used both for a 16 bit immediate or a
			     * branch instruction.  If it is a branch
			     * instruction then r_pcrel is set and the
			     * immediate is a 32 bit word displacement
			     * otherwise it is a byte displacement and r_pcrel
			     * is not set.
			     */
			    if(r_pcrel)
				offset <<= 2; /* long to byte address */
			    break;
			case I860_RELOC_SPLIT1:
			    offset = ((instruction >> 5) & 0xf800) |
				     (instruction & 0x7fe);
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_SPLIT2:
			    offset = ((instruction >> 5) & 0xf800) |
				     (instruction & 0x7fc);
			    /* sign extend if needed */
			    if((offset & 0x8000) != 0)
				offset |= 0xffff0000;
			    break;
			case I860_RELOC_BRADDR:
			    offset = instruction & 0x03ffffff;
			    if((offset & 0x02000000) != 0)
				offset |= 0xfc000000;
			    /*
			     * The immediate is always a 32 bit word
			     * displacement.
			     */
			    offset <<= 2;
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
		    }
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT)
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum != R_ABS){
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    if(local_map->s->flags & S_ATTR_DEBUG){
			error_with_cur_obj("illegal reference to debug section,"
			    " from non-debug section (%.16s,%.16s) via "
			    "relocation entry (%lu) to section (%.16s,%.16s)",
			    section_map->s->segname, section_map->s->sectname,
			    i, local_map->s->segname, local_map->s->sectname);
			return;
		    }
		    pair_local_map = NULL;
		    if(r_type == I860_RELOC_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
			if(pair_local_map->s->flags & S_ATTR_DEBUG){
			    error_with_cur_obj("illegal reference to debug "
				"section, from non-debug section (%.16s,%.16s) "
				"via relocation entry (%lu) to section (%.16s,"
				"%.16s)", section_map->s->segname,
				section_map->s->sectname, i,
				pair_local_map->s->segname,
				pair_local_map->s->sectname);
			    return;
			}
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == I860_RELOC_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation it is an interal error for the
			 * i860 cputype.
			 */
			fatal("internal error, in i860_reloc() section (%.16s,"
			      "%.16s) has fine relocs", local_map->s->segname,
			      local_map->s->sectname);
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr /* + r_address */
			     - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else{
		    /*
		     * For items to be relocated that refer to a section
		     * with fine relocation it is an interal error for the
		     * i860 cputype.
		     */
		    fatal("internal error, in i860_reloc() section (%.16s,"
			  "%.16s) has fine relocs", local_map->s->segname,
			  local_map->s->sectname);
		}
	    }

	    /*
	     * Do "vanilla" and "sectdiff" relocation just like in
	     * generic_reloc() first.
	     */
	    if(r_type == I860_RELOC_VANILLA ||
	       r_type == I860_RELOC_SECTDIFF){
		switch(r_length){
		case 0: /* byte */
		    value += get_byte((char *)(contents + r_address));
		    if( (value & 0xffffff00) &&
		       ((value & 0xffffff80) != 0xffffff80))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 1 byte", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_byte((char *)(contents + r_address), value);
		    break;
		case 1: /* word (2 byte) */
		    value += get_short((short *)(contents + r_address));
		    if( (value & 0xffff0000) &&
		       ((value & 0xffff8000) != 0xffff8000))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 2 bytes", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_short((short *)(contents + r_address), value);
		    break;
		case 2: /* long (4 byte) */
		    value += get_long((long *)(contents + r_address));
		    set_long((long *)(contents + r_address), value);
		    break;
		default:
		    error_with_cur_obj("r_length field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * Do i860 specific relocation based on the r_type.
	     */
	    else{
		instruction = get_long((long *)(contents + r_address));
		switch(r_type){
		case I860_RELOC_HIGH:
		    immediate = ((instruction & 0xffff) << 16) | other_half;
		    immediate += value;
		    instruction = (instruction & 0xffff0000) |
				  ((immediate >> 16) & 0xffff);
		    other_half = immediate & 0xffff;
		    break;
		case I860_RELOC_HIGHADJ:
		    if(other_half & 0x8000)
			immediate = ((instruction & 0xffff) << 16) +
				    (other_half | 0xffff0000);
		    else
			immediate = ((instruction & 0xffff) << 16) + other_half;
		    immediate += value;
		    if(immediate & 0x8000)
			instruction = (instruction & 0xffff0000) |
				      (((immediate >> 16) + 1) & 0xffff);
		    else
			instruction = (instruction & 0xffff0000) |
				      ((immediate >> 16) & 0xffff);
		    other_half = immediate & 0xffff;
		    break;
		case I860_RELOC_LOW0:
		    immediate = instruction & 0xffff;
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffff0000) |
				  (immediate & 0xffff);
		    break;
		case I860_RELOC_LOW1:
		    immediate = instruction & 0xfffe;
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffff0001) |
				  (immediate & 0xfffe);
		    break;
		case I860_RELOC_LOW2:
		    immediate = instruction & 0xfffc;
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffff0003) |
				  (immediate & 0xfffc);
		    break;
		case I860_RELOC_LOW3:
		    immediate = instruction & 0xfff8;
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffff0007) |
				  (immediate & 0xfff8);
		    break;
		case I860_RELOC_LOW4:
		    immediate = instruction &0xfff0;
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffff000f) |
				  (immediate & 0xfff0);
		    break;
		case I860_RELOC_SPLIT0:
		    immediate = ((instruction >> 5) & 0xf800) |
				(instruction & 0x7ff);
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    /*
		     * This is used both for a 16 bit immediate or a branch
		     * instruction.  If it is a branch instruction then r_pcrel
		     * is set and the immediate is a 32 bit word displacement
		     * otherwise it is a byte displacement and r_pcrel is not
		     * set.
		     */
		    if(r_pcrel)
			immediate <<= 2;	/* long to byte address */
		    immediate += value;
		    if(r_pcrel)
			immediate >>= 2;	/* Back to long address */
		    instruction = (instruction & 0xffe0f800) |
				  ((immediate & 0xf800) << 5) |
				  (immediate & 0x7ff);
		    break;
		case I860_RELOC_SPLIT1:
		    immediate = ((instruction >> 5) & 0xf800) |
				(instruction & 0x7fe);
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffe0f801) |
				  ((immediate & 0xf800) << 5) |
				  (immediate & 0x7fe);
		    break;
		case I860_RELOC_SPLIT2:
		    immediate = ((instruction >> 5) & 0xf800) |
				(instruction & 0x7fc);
		    if((immediate & 0x8000) != 0)
			immediate |= 0xffff0000;
		    immediate += value;
		    instruction = (instruction & 0xffe0f803) |
				  ((immediate & 0xf800) << 5) |
				  (immediate & 0x7FC);
		    break;
		case I860_RELOC_BRADDR:
		    immediate = instruction & 0x03ffffff;
		    if((immediate & 0x02000000) != 0)
			immediate |= 0xfc000000;
		    /*
		     * The immediate is always a 32 bit word displacement.
		     */
		    immediate <<= 2;
		    immediate += value;
		    immediate >>= 2;
		    instruction = (instruction & 0xfc000000) |
		    		  (immediate & 0x03ffffff);
		    break;
		case I860_RELOC_PAIR:
		default:
		    error_with_cur_obj("r_type field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		set_long((long *)(contents + r_address), instruction);
	    }

	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
			(merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
			force_extern_reloc == FALSE &&
			((filetype != MH_DYLIB ||
			  multi_module_dylib == FALSE) ||
			 (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value make it a scattered
			     * relocation entry else make it a local relocation
			     * entry.
			     */
			    if(offset == 0){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = r_type;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    if(reloc->r_symbolnum != R_ABS)
			reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
		}
		else{
		    /*
		     * For scattered relocation entries the r_value field is
		     * relocated.
		     */
		    sreloc->r_value += - local_map->s->addr
				       + (local_map->output_section->s.addr +
				          local_map->offset);
		}
		/*
		 * The offset in the r_address field has to be updated to where
		 * this contents appears in the output file. 
		 */
		if(r_scattered == 0){
		    reloc->r_address += section_map->offset;
		}
		else{
		    sreloc->r_address += section_map->offset;
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == I860_RELOC_PAIR){
		    if(pair_reloc != NULL)
			pair_reloc->r_address = other_half;
		    else if(spair_reloc != NULL){
			if(r_type == I860_RELOC_SECTDIFF){
			    /*
			     * For I860_RELOC_SECTDIFF relocation entries (which
			     * are always scattered types) the r_value field is
			     * relocated.
			     */
			    spair_reloc->r_value +=
				- pair_local_map->s->addr
				+ (pair_local_map->output_section->s.addr +
				   pair_local_map->offset);
			}
			else{
			    spair_reloc->r_address = other_half;
			}
		    }
		    else{
			fatal("internal error, in i860_reloc() pair_r_type "
			    "is I860_RELOC_PAIR but pair_reloc and spair_reloc "
			    "are NULL");
		    }
		}
	    }
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == I860_RELOC_PAIR)
		i++;
	}
}
#endif /* !defined(RLD) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/i860_reloc.h                             0100644 0001750 0001750 00000002612 12612724205 023062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file i860_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void i860_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *map);
                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/indirect_sections.c                      0100644 0001750 0001750 00000155321 12612724205 024721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with indirect sections (both
 * lazy and non-lazy symbol pointer sections as well as symbol stub sections). 
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include "stuff/arch.h"
#include "stuff/reloc.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "pass1.h"
#include "symbols.h"
#include "layout.h"
#include "indirect_sections.h"
#include "dylibs.h"

/*
 * The number of indirect symbol table entries in the output file.
 */
__private_extern__ unsigned long nindirectsyms = 0;

/*
 * If we are still attempting to prebind when indirect_section_merge() is
 * called save_lazy_symbol_pointer_relocs will get set in layout.c.
 * Between the time indirect_section_merge() gets called and the time
 * reloc_output_for_dyld() gets called prebinding may be disabled because of
 * various problems.  But the count of relocs can't change after layout so
 * we'll put them out anyway.
 */
__private_extern__ enum bool save_lazy_symbol_pointer_relocs = FALSE;

#ifndef SA_RLD

static unsigned long lookup_indirect_item(
    struct merged_symbol *merged_symbol,
    struct object_file *obj,
    unsigned long index,
    struct indirect_section_data *data, 
    unsigned long stride,
    enum bool *new);

/*
 * indirect_section_merge() merges items from symbol pointers and symbol stub
 * sections from the specified section in the current object file (cur_obj).
 * When redo_live is FALSE it allocates a fine relocation map and sets the
 * fine_relocs field in the section_map to it (as well as the count).
 *
 * When redo_live is FALSE after all the items for this section in this object
 * file have been merged two more things are done.  First the number of
 * relocation entries that will be in the output file is adjusted (incremented)
 * based on which items are used from this object's section.  Second the number
 * of local symbol table entries and the size of the string table is adjusted
 * (decremented) based on the which symbols are in the items from this object's
 * section that will be in the resulting object file.
 *
 * When redo_live is TRUE it re-merges only the live items from symbol pointers
 * and symbol stub sections from the specified section in the current object
 * file (cur_obj).
 */
__private_extern__
void
indirect_section_merge(
struct indirect_section_data *data, 
struct merged_section *ms,
struct section *s, 
struct section_map *section_map,
enum bool redo_live)
{
    unsigned long i, j, stride, section_type, nitems, index;
    struct fine_reloc *fine_relocs;
    struct nlist *nlists;
    unsigned long *indirect_symtab;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol, *indr_symbol;
    enum bool new;

    struct relocation_info *relocs, reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_pcrel, r_length, r_type, pair_r_type, r_extern,
		  r_symbolnum, r_scattered, r_value, pair;
#ifndef RLD
    enum bool pic;
#endif
    enum bool defined, force_extern_reloc;
    unsigned long nsect;
    char *strings;

	/* to shut up compiler warning messages "may be used uninitialized" */
	merged_symbol = NULL;

	if(s->size == 0)
	    return;

	stride = 0;
	pair_r_type = 0;
	section_type = s->flags & SECTION_TYPE;
	if(section_type == S_LAZY_SYMBOL_POINTERS ||
	   section_type == S_NON_LAZY_SYMBOL_POINTERS){
	    stride = 4;
	}
	else if(section_type == S_SYMBOL_STUBS)
	    stride = s->reserved2;
	else
	    fatal("internal error, in indirect_section_merge() section type "
		  "(%lu) is not correct for an indirect section", section_type);
	nitems = s->size / stride;

	if(s->size % stride != 0){
	    error_with_cur_obj("malformed object (section (%.16s,%.16s) size "
		"is not a multiple of %lu bytes)", s->segname, s->sectname,
		stride);
	    return;
	}
	if(cur_obj->dysymtab == NULL){
	    error_with_cur_obj("malformed object (file has indirect section "
		"(%.16s,%.16s) but no dysymtab_command)", s->segname,
		s->sectname);
	    return;
	}
	if(s->reserved1 > cur_obj->dysymtab->nindirectsyms){
	    error_with_cur_obj("malformed object (index into indirect symbol "
		"table (reserved1 field) for indirect section (%.16s,%.16s) "
		"past the end of the table)", s->segname, s->sectname);
	    return;
	}
	if(s->reserved1 + nitems > cur_obj->dysymtab->nindirectsyms){
	    error_with_cur_obj("malformed object (indirect symbol table entries"
		"for section (%.16s,%.16s) extends past the end of the table)",
		s->segname, s->sectname);
	    return;
	}
	if(s->size == 0){
	    if(redo_live == FALSE){
		section_map->fine_relocs = NULL;
		section_map->nfine_relocs = 0;
	    }
	    return;
	}
#ifdef DEBUG
	if(redo_live == FALSE){
	    data->nfiles++;
	    data->nitems += nitems;
	}
#endif /* DEBUG */

	/*
	 * First deal with the contents of the indirect section and determine
	 * based on the indirect symbol for each item in the section if the
	 * contents 1) will in the output and used from this object, 2) used
	 * from a previous merged object or 3) the value of the indirect symbol
	 * will be used instead of the contents of this item.  This information
	 * is encoded into the fine_reloc structures for each item.
	 */
	/* setup pointers to the symbol, indirect symbol and string tables */
	nlists = (struct nlist *)(cur_obj->obj_addr +
				  cur_obj->symtab->symoff);
	indirect_symtab = (unsigned long *)(cur_obj->obj_addr +
					    cur_obj->dysymtab->indirectsymoff);
	strings = cur_obj->obj_addr + cur_obj->symtab->stroff;
	if(redo_live == FALSE){
	    fine_relocs = allocate(nitems * sizeof(struct fine_reloc));
	    memset(fine_relocs, '\0', nitems * sizeof(struct fine_reloc));
	}
	else{
	    fine_relocs = section_map->fine_relocs;
	    nitems = section_map->nfine_relocs;
	}
	for(i = 0; i < nitems; i++){
	    /* get the indirect symbol table entry for this item */
	    index = indirect_symtab[s->reserved1 + i];
	    /*
	     * With strip(1), nmedit(l) or and "ld(1) -r with private externs
	     * index could be INDIRECT_SYMBOL_LOCAL or INDIRECT_SYMBOL_ABS.
	     */
	    if(index == INDIRECT_SYMBOL_LOCAL ||
	       index == INDIRECT_SYMBOL_ABS){
		if(redo_live == FALSE){
		    fine_relocs[i].local_symbol = TRUE;
		    fine_relocs[i].indirect_defined = FALSE;
		    fine_relocs[i].use_contents = TRUE;
		    fine_relocs[i].input_offset = i * stride;
		    fine_relocs[i].merged_symbol = NULL;
		    if(index == INDIRECT_SYMBOL_LOCAL)
			fine_relocs[i].indirect_symbol_local = TRUE;
		}
		if(redo_live == FALSE || fine_relocs[i].live == TRUE){
		    fine_relocs[i].output_offset = lookup_indirect_item(
				NULL, cur_obj, index, data, stride, &new);
		}
		else if(redo_live == TRUE && fine_relocs[i].live == FALSE){
		    fine_relocs[i].use_contents = FALSE;
		}
		goto account_for_size;
	    }

	    /*
	     * Since the indirect symbol table entry should be for an undefined
	     * symbol use the current object's undefined symbol map to get the
	     * merged symbol.
	     */
	    undefined_map = bsearch(&index, cur_obj->undefined_maps,
		cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
	    if(undefined_map != NULL){
		merged_symbol = undefined_map->merged_symbol;
		/*
		 * If the indirect symbol table entry is for a private extern
		 * it is an error.
		 */
		if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
		   (merged_symbol->nlist.n_type & N_EXT) != N_EXT &&
		   section_type == S_NON_LAZY_SYMBOL_POINTERS &&
		   output_for_dyld == FALSE)
		    fatal("indirect symbol:%s can not be a private extern",
			  strings + nlists[index].n_un.n_strx);
	    }
	    else if((nlists[index].n_type & N_EXT) == N_EXT){
		/*
		 * The indirect symbol table entry was not for an undefined but
		 * it is an external symbol so get the merged_symbol for this
		 * external symbol by looking it up by name.
		 */
		merged_symbol = lookup_symbol(strings +
						nlists[index].n_un.n_strx);
		if(merged_symbol->name_len == 0)
		    fatal("interal error, indirect_section_merge() failed in "
			  "looking up external symbol");
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * If the indirect symbol table entry is for a private extern
		 * it is an error.
		 */
		if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
		   (merged_symbol->nlist.n_type & N_EXT) != N_EXT &&
		   section_type == S_NON_LAZY_SYMBOL_POINTERS &&
		   output_for_dyld == FALSE)
		    fatal("indirect symbol:%s can not be a private extern",
			  strings + nlists[index].n_un.n_strx);
	    }
	    else if((nlists[index].n_type & N_PEXT) == N_PEXT &&
		    (nlists[index].n_type & N_EXT) != N_EXT &&
		    section_type == S_NON_LAZY_SYMBOL_POINTERS &&
		    output_for_dyld == FALSE)
		/*
		 * If the indirect symbol table entry is for a private extern
		 * it is an error.
		 */
		fatal("indirect symbol:%s can not be a private extern",
		      strings + nlists[index].n_un.n_strx);
	    else if((nlists[index].n_type & N_STAB) == 0){
		/*
		 * The indirect symbol table entry was not even an external
		 * symbol but it is a local defined symbol.  So the symbol table
		 * index will be use in place of the merged_symbol.  This is
		 * allowed on input only for stub sections and won't be created
		 * on output.
		 */
		merged_symbol = NULL;
	    }
	    else{
		/*
		 * The indirect symbol table entry was a stab, this is an error.
		 */
		error_with_cur_obj("malformed object (bad indirect symbol "
		    "table entry (%ld) (symbol at index %lu is a stab)",
		    s->reserved1 + i, index);
		return;
	    }
	    /*
	     * Now set the values in the fine relocation entry for this item
	     * based on the type of section and the merged symbol for this
	     * item's indirect symbol and if the output file is a dynamic
	     * shared library file.
	     */
	    if(redo_live == FALSE)
		fine_relocs[i].input_offset = i * stride;
	    if(merged_symbol == NULL){
		/*
		 * Indirect table entries which refer to local defined symbols
		 * are allowed only in symbol stub and lazy pointer sections so
		 * they can always be removed and never created on output.
		 */
		if(section_type == S_NON_LAZY_SYMBOL_POINTERS){
		    if((nlists[index].n_type & N_PEXT) == 0){
			error_with_cur_obj("malformed object (bad indirect "
			    "symbol table entry (%ld) (symbol at index %lu is "
			    "not external)", s->reserved1 + i, index);
			return;
		    }
		    /*
		     * A non-lazy symbol pointer for a private extern that no
		     * longer is external.
		     */
		    if(redo_live == FALSE){
			fine_relocs[i].local_symbol = TRUE;
			fine_relocs[i].indirect_defined = TRUE;
			fine_relocs[i].use_contents = TRUE;
			fine_relocs[i].merged_symbol = NULL;
		    }
		    if(redo_live == FALSE || fine_relocs[i].live == TRUE){
			fine_relocs[i].output_offset = lookup_indirect_item(
				    NULL, cur_obj, index, data, stride, &new);
		    }
		    else if(redo_live == TRUE && fine_relocs[i].live == FALSE){
			fine_relocs[i].use_contents = FALSE;
		    }
		}
		else{
		    if(redo_live == FALSE){
			fine_relocs[i].local_symbol = TRUE;
			fine_relocs[i].indirect_defined = TRUE;
			fine_relocs[i].use_contents = FALSE;
			fine_relocs[i].output_offset = index;
			fine_relocs[i].merged_symbol = NULL;
		    }
		}
	    }
	    else{
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR &&
		   merged_symbol->defined_in_dylib == FALSE){
		    /*
		     * If this N_INDR symbol was in a chain has symbols both
		     * from dylib and not from dylibs get then there was a
		     * recorded a pair for the merged symbol and the first in
		     * the chain defined in a dylib for the indr_symbol to be
		     * used.  If not then merged_symbol->nlist.n_value can be
		     * used.
		     */
		    indr_symbol = NULL;
		    for(j = 0; j < nindr_symbol_pairs; j++){
			if(indr_symbol_pairs[j].merged_symbol == merged_symbol)
			    indr_symbol = indr_symbol_pairs[j].indr_symbol;
		    }
		    if(indr_symbol == NULL)
			indr_symbol = (struct merged_symbol *)
				(merged_symbol->nlist.n_value);
		    merged_symbol = indr_symbol;
		}

		if(redo_live == FALSE)
		    fine_relocs[i].local_symbol = FALSE;

		if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		   merged_symbol->nlist.n_type == (N_EXT | N_PBUD) ||
		   (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		    merged_symbol->defined_in_dylib == TRUE)){
		    if(redo_live == FALSE){
			fine_relocs[i].indirect_defined = FALSE;
		    }
		}
		else if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
			(merged_symbol->definition_object->section_maps[
			 merged_symbol->nlist.n_sect - 1].
			 s->flags & SECTION_TYPE) == S_COALESCED &&
			filetype != MH_DYLINKER){
		    if((output_for_dyld &&
		       (has_dynamic_linker_command || filetype == MH_BUNDLE) &&
		       (((merged_symbol->nlist.n_desc & N_WEAK_DEF) !=
			 N_WEAK_DEF) ||
		       ((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ) ) ||
		       (filetype == MH_DYLIB && multi_module_dylib == FALSE &&
			(merged_symbol->nlist.n_type & N_PEXT) == N_PEXT) ){
			if(redo_live == FALSE)
			    fine_relocs[i].indirect_defined = TRUE;
		    }
		    else{
			if(redo_live == FALSE)
			    fine_relocs[i].indirect_defined = FALSE;
		    }
		}
		else{
		    if(redo_live == FALSE)
			fine_relocs[i].indirect_defined = TRUE;
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_ABS)
		    section_map->absolute_indirect_defineds = TRUE;

		if((filetype == MH_DYLIB && multi_module_dylib == TRUE) ||
		   section_type == S_NON_LAZY_SYMBOL_POINTERS ||
		   fine_relocs[i].indirect_defined == FALSE){
		    if(redo_live == FALSE || fine_relocs[i].live == TRUE){
			fine_relocs[i].output_offset = lookup_indirect_item(
				    merged_symbol, NULL, 0, data, stride, &new);
		    }
		    else if(redo_live == TRUE && fine_relocs[i].live == FALSE){
			new = FALSE;
		    }
		    fine_relocs[i].use_contents = new;
		    if(redo_live == FALSE)
			fine_relocs[i].merged_symbol = merged_symbol;
		}
		else{
		    if(redo_live == FALSE){
			fine_relocs[i].use_contents = FALSE;
			fine_relocs[i].merged_symbol = merged_symbol;
		    }
		}
	    }

account_for_size:
	    /*
	     * If this item's contents will be used in the output file account
	     * for it's size in the merged section and it's entry in the
	     * indirect symbol table.
	     */
	    if(fine_relocs[i].use_contents){
		/*
		 * When -dead_strip is specified this will be called a second
		 * time and redo_live will be TRUE.  If so only account for this
		 * item if it is live.
		 */
		if(redo_live == FALSE || fine_relocs[i].live == TRUE){
		    ms->s.size += stride;
		    nindirectsyms++;
		}
	    }
	}
	if(redo_live == FALSE){
	    section_map->fine_relocs = fine_relocs;
	    section_map->nfine_relocs = nitems;
	}

	/*
	 * Second deal with the relocation entries for the section in this
	 * object file.  Now that it has been determined for which items the 
	 * contents will be used from this object file.
	 */
	/*
 	 * A lazy symbol pointer section must have one relocation entry for each
	 * pointer.  A non-lazy symbol pointer section can't have any relocation
	 * entries (this was checked in check_cur_obj() before getting here).
	 * And a symbol stub section may have many relocation entries.
	 */
	if(section_type == S_LAZY_SYMBOL_POINTERS && s->nreloc != nitems){
	    error_with_cur_obj("malformed object (lazy symbol pointer section "
		"(%.16s,%.16s) does not have is exactly one relocation entry "
		"for each pointer)", s->segname, s->sectname);
	    return;
	}
	/*
	 * This loop loops through the relocation entries and using the
	 * use_contents field (via a call to fine_reloc_offset_in_output())
	 * of the fine_relocs just created determines how many relocation
	 * entries will be in the output for this section of this object file.
	 */
	relocs = (struct relocation_info *)(cur_obj->obj_addr + s->reloff);
	for(i = 0; i < s->nreloc; i++){
	    reloc = relocs[i];
	    if(cur_obj->swapped &&
	       section_map->input_relocs_already_swapped == FALSE)
		swap_relocation_info(&reloc, 1, host_byte_sex);
	    /*
	     * Break out the fields of the relocation entry we need here.
	     */
	    if((reloc.r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(&reloc);
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = sreloc->r_type;
		r_extern = 0;

		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		r_scattered = 0;
		r_address = reloc.r_address;
		r_pcrel = reloc.r_pcrel;
		r_length = reloc.r_length;
		r_type = reloc.r_type;
		r_extern = reloc.r_extern;
		r_symbolnum = reloc.r_symbolnum;
	    }
	    /*
	     * Make sure that this is not a stray PAIR relocation entry.
	     */
	    if(r_type == reloc_pair_r_type(arch_flag.cputype)){
		error_with_cur_obj("malformed object (stray relocation PAIR "
		    "entry (%lu) in section (%.16s,%.16s))", i, s->segname,
		    s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section.
	     */
	    if(r_address >= s->size){
		error_with_cur_obj("malformed object (r_address (0x%x) field "
		    "of relocation entry %ld in section (%.16s,%.16s) out of "
		    "range)",(unsigned int)r_address, i,s->segname,s->sectname);
		continue;
	    }
	    /*
	     * If this relocation entry is suppose to have a PAIR make sure it
	     * does.
	     */
	    if(reloc_has_pair(arch_flag.cputype, r_type)){
		if(i + 1 < s->nreloc){
		    reloc = relocs[i + 1];
		    if(cur_obj->swapped &&
		       section_map->input_relocs_already_swapped == FALSE)
			swap_relocation_info(&reloc, 1, host_byte_sex);
		    if((reloc.r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
                                      &reloc;
                        pair_r_type = spair_reloc->r_type;
		    }
		    else{
                        pair_r_type = reloc.r_type;
		    }
		}
		if(i + 1 >= s->nreloc ||
		   pair_r_type != reloc_pair_r_type(arch_flag.cputype)){
		    error_with_cur_obj("malformed object (relocation entry "
			"(%lu) in section (%.16s,%.16s) missing following "
			"associated PAIR entry)", i, s->segname, s->sectname);
                    continue;
                }
	    }
	    /*
	     * For a lazy symbol pointer section all relocation entries must be
	     * for one of the pointers or an external relocation entry and
	     * therefore the offset must be a multiple of 4 (the size of a
	     * pointer), have an r_length field of 2 (long) and a r_pcrel field
	     * of 0 (FALSE).
	     */
	    if(section_type == S_LAZY_SYMBOL_POINTERS){
		if(r_address % 4 != 0){
		    error_with_cur_obj("malformed object, illegal reference "
			"(r_address (0x%x) field of relocation entry %lu in "
			"lazy symbol pointer section (%.16s,%.16s) is not a "
			"multiple of 4)", (unsigned int)r_address, i,
			s->segname, s->sectname);
		    continue;
		}
		if(r_length != 2){
		    error_with_cur_obj("malformed object, illegal reference "
			"(r_length (0x%x) field of relocation entry %lu in "
			"lazy symbol pointer section (%.16s,%.16s) is not 2 "
			"(long))", (unsigned int)r_length, i, s->segname,
			s->sectname);
		    continue;
		}
		if(r_pcrel != 0){
		    error_with_cur_obj("malformed object, illegal reference "
			"(r_pcrel (0x%x) field of relocation entry %lu in lazy "
			"symbol pointer section (%.16s,%.16s) is not 0 "
			"(FALSE))", (unsigned int)r_pcrel, i, s->segname,
			s->sectname);
		    continue;
		}
		if(r_type != 0){
		    error_with_cur_obj("malformed object, illegal reference "
			"(r_type (0x%x) field of relocation entry %lu in lazy "
			"symbol pointer section (%.16s,%.16s) is not 0 "
			"(VANILLA))", (unsigned int)r_type, i, s->segname,
			s->sectname);
		    continue;
		}
		if(r_scattered != 0){
		    error_with_cur_obj("malformed object, illegal reference "
			"(relocation entry %lu in lazy symbol pointer section "
			"(%.16s,%.16s) is a scattered type)", i, s->segname,
			s->sectname);
		    continue;
		}
		if(r_extern == 0 && r_symbolnum == R_ABS){
	    	    error_with_cur_obj("malformed object, illegal reference "
			"(reference from a lazy symbol pointer section (%.16s,"
			"%.16s) relocation entry (%lu) which is not to a "
			"symbol stub section)", s->segname, s->sectname, i);
		    continue;
		}
	    }
	    /*
	     * Assumed the symbol for this relocation entry is defined (always
	     * true for local relocation entries).  Then reset the variable
	     * "defined" correctly if this is an external relocation entry based
	     * on if the symbol is defined, where it is defined and the output
	     * file type.
	     */
	    defined = TRUE;
	    force_extern_reloc = FALSE;
	    if(output_for_dyld && r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, s->segname, s->sectname);
		    continue;
		}
		undefined_map = bsearch(&r_symbolnum,
		    cur_obj->undefined_maps, cur_obj->nundefineds,
		    sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    if((nlists[r_symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of "
			    "external relocation entry %lu in section "
			    "(%.16s,%.16s) refers to a non-external symbol",
			     r_symbolnum, i, s->segname, s->sectname);
			continue;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references
		     * to the same symbol.
		     */
		    if((nlists[r_symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[r_symbolnum].
			n_sect-1].s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					   nlists[r_symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in indirect_section_merge() "
				  "failed to lookup coalesced symbol %s",
				  strings + nlists[r_symbolnum].n_un.n_strx);
			}
			if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			    keep_private_externs == FALSE) ||
			   dynamic == FALSE ||
			   (output_for_dyld && has_dynamic_linker_command))
			    force_extern_reloc = FALSE;
			else
			    force_extern_reloc = TRUE;
		    }
		    else{
			if(nlists[r_symbolnum].n_type != (N_EXT | N_UNDF)){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", r_symbolnum, i,
				section_map->s->segname,
				section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in indirect_section_merge()"
			    " symbol index %lu in above file not in "
			    "undefined map", r_symbolnum);
		    }
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * For multi module dynamic shared library format files the
		 * merged sections that could have had external relocation
		 * entries must be resolved to private extern symbols.  This is
		 * because for multi module MH_DYLIB files all modules share the
		 * merged sections and the entire section gets relocated when
		 * the library is mapped in. So the above restriction assures
		 * the merged section will get relocated properly and can be
		 * shared amoung library modules.
		 */
		if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		    /*
		     * If the symbol is undefined or not a private extern it is
		     * an error for in this section for a MH_DYLIB file.
		     */
		    if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		       merged_symbol->nlist.n_type == (N_EXT | N_PBUD) ||
		       (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
			merged_symbol->defined_in_dylib == TRUE)){
			if(merged_symbol->error_flagged_for_dylib == 0){
			    error_with_cur_obj("illegal undefined reference "
				"for multi module MH_DYLIB output file to "
				"symbol: %s from section (%.16s,%.16s) "
				"relocation entry: %lu",
				merged_symbol->nlist.n_un.n_name, s->segname,
				s->sectname, i);
			    merged_symbol->error_flagged_for_dylib = 1;
			}
		    }
		    else if((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT){
			if(merged_symbol->error_flagged_for_dylib == 0){
			    error_with_cur_obj("illegal external reference for "
				"multi module MH_DYLIB output file to symbol: "
				"%s (not a private extern symbol) from section "
				"(%.16s,%.16s) relocation entry: %lu",
				merged_symbol->nlist.n_un.n_name,
				s->segname, s->sectname, i);
			    merged_symbol->error_flagged_for_dylib = 1;
			}
		    }
		}
		else{
		    if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		       merged_symbol->nlist.n_type == (N_EXT | N_PBUD) ||
		       (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		        merged_symbol->defined_in_dylib == TRUE))
			defined = FALSE;
		    else
			defined = TRUE;
		}
	    }
	    if(reloc_has_pair(arch_flag.cputype, r_type))
		pair = 1;
	    else
		pair = 0;
#ifndef RLD
	    /*
	     * If saving relocation entries see if this relocation entry is for 
	     * an item that is going to be in the output file and if so count it
	     * as one of the output relocation entries.
	     */
	    if(output_for_dyld &&
	       fine_reloc_offset_in_output(section_map, r_address)){
		/*
		 * Mark this section as being relocated (staticly).
		 */
		if(dead_strip == FALSE || redo_live == TRUE)
		    ms->relocated = TRUE;
		if(r_extern == 0)
		    pic = (enum bool)
			  (reloc_is_sectdiff(arch_flag.cputype, r_type) ||
			   (r_pcrel == 1 && r_symbolnum != NO_SECT));
		else
		    pic = (enum bool)
			  (r_pcrel == 1 &&
			   (merged_symbol->nlist.n_type & N_TYPE) == N_SECT);
		/*
		 * The number of relocation entries in the output file is based
		 * on one of three different cases:
		 *  The output file is a multi module dynamic shared library
		 *  The output file has a dynamic linker load command
		 *  The output does not have a dynamic linker load command
		 */
		if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		    /*
		     * For multi module dynamic shared library files there are
		     * no external relocation entries that will be left as
		     * external as checked above.  Only non-position-independent
		     * local relocation entries are kept.  Modules of multi
		     * module dylibs are not linked together and can only be
		     * slid keeping all sections relative to each other the
		     * same.
		     */
		    if(pic == FALSE)
			ms->nlocrel += 1 + pair;
		}
		else if(has_dynamic_linker_command){
		    /*
		     * For an file with a dynamic linker load command only
		     * external relocation entries for undefined symbols are
		     * kept.  This output file is a fixed address and can't be
		     * moved.
		     */
		    if(r_extern){
			if(defined == FALSE)
			    ms->nextrel += 1 + pair;
			/*
			 * As of the PowerPC port, relocation entries for
			 * lazy symbol pointers can be external so when the
			 * the symbol is defined if we are doing prebinding and
			 * this is for a lazy symbol pointer then this will
			 * turn into a local relocation entry and we save it
			 * so we can undo the prebinding if needed.
			 */
			else if(save_lazy_symbol_pointer_relocs == TRUE &&
				section_type == S_LAZY_SYMBOL_POINTERS)
			    ms->nlocrel += 1 + pair;
		    }
		    /*
		     * Even though the file can't be moved we may be trying to
		     * prebind.  If we are prebinging we need the local
		     * relocation entries for lazy symbol pointers to be saved
		     * so dyld will have the info to undo this if it fails.
		     */
		    else if(save_lazy_symbol_pointer_relocs == TRUE &&
			    section_type == S_LAZY_SYMBOL_POINTERS){
			ms->nlocrel += 1 + pair;
		    }
		}
		else{
		    /*
		     * For an file without a dynamic linker load command
		     * external relocation entries for undefined symbols are
		     * kept and locals that are non-position-independent are
		     * kept.  This file can only be slid keeping all sections
		     * relative to each other the same.
		     */
		    if(r_extern){
			if(defined == FALSE || force_extern_reloc == TRUE)
			    ms->nextrel += 1 + pair;
			else if(pic == FALSE)
			    ms->nlocrel += 1 + pair;
		    }
		    else if(pic == FALSE)
			ms->nlocrel += 1 + pair;
		}
	    }
	    else if(save_reloc &&
	            fine_reloc_offset_in_output(section_map, r_address)){
		ms->s.nreloc += 1 + pair;
		nreloc += 1 + pair;
	    }
#endif /* !defined(RLD) */
	    i += pair;
	}
	/*
	 * If the the number of relocation entries is not zero mark this section
	 * as being relocated (staticly).
	 */
	if(ms->s.nreloc != 0){
	    if(dead_strip == FALSE || redo_live == TRUE)
		ms->relocated = TRUE;
	}

	/*
	 * Third deal with the symbol table entries for local symbols and N_STAB
	 * symbols in this section in this object file.  Now that it has been
	 * determined for which items the contents will be used from this
	 * object file.  If when -dead_strip is specified we have to wait to
	 * do this until we are called a second time when redo_live is TRUE and
	 * all the fine_relocs have had their live field set.
	 */
	if(dead_strip == FALSE || redo_live == TRUE){
	    /* determine the section number this has in this object */
	    for(nsect = 0; nsect < cur_obj->nsection_maps; nsect++)
		if(s == cur_obj->section_maps[nsect].s)
		    break;
	    nsect++; /* section numbers start at 1 (not zero) */
	    /* set up a pointer to the string table */
	    strings = (char *)(cur_obj->obj_addr + cur_obj->symtab->stroff);
	    discard_local_symbols_for_section(nsect, nlists, strings, s,
					      section_map);
	}
}

static
unsigned long
lookup_indirect_item(
struct merged_symbol *merged_symbol,
struct object_file *obj,
unsigned long index,
struct indirect_section_data *data, 
unsigned long stride,
enum bool *new)
{
    unsigned long hashval, output_offset;
    struct indirect_item_block **p, *indirect_item_block;
    struct indirect_item *indirect_item;
    struct indirect_item_bucket *bp;

	if(data->hashtable == NULL){
	    data->hashtable = allocate(sizeof(struct indirect_item_bucket *) *
						  INDIRECT_SECTION_HASHSIZE);
	    memset(data->hashtable, '\0',
		   sizeof(struct indirect_item_bucket *) *
						  INDIRECT_SECTION_HASHSIZE);
	}
#if defined(DEBUG) && defined(PROBE_COUNT)
	data->nprobes++;
#endif
	hashval = ((unsigned long)merged_symbol) % INDIRECT_SECTION_HASHSIZE;
	for(bp = data->hashtable[hashval]; bp; bp = bp->next){
#if defined(DEBUG) && defined(PROBE_COUNT)
	    data->nprobes++;
#endif
	    if(bp->indirect_item->merged_symbol == merged_symbol &&
	       merged_symbol != NULL){
		*new = FALSE;
		return(bp->output_offset);
	    }
	}

	bp = allocate(sizeof(struct indirect_item_bucket));
	output_offset = 0;
	for(p = &(data->indirect_item_blocks);
	    *p ;
	    p = &(indirect_item_block->next)){

	    indirect_item_block = *p;
	    if(indirect_item_block->used != INDIRECT_SECTION_BLOCK_SIZE){
		indirect_item = indirect_item_block->indirect_items +
				  indirect_item_block->used;
		indirect_item->merged_symbol = merged_symbol;
		indirect_item->obj = obj;
		indirect_item->index = index;

		bp->indirect_item = indirect_item;
		bp->output_offset = output_offset +
				    indirect_item_block->used * stride;
		bp->next = data->hashtable[hashval];
		data->hashtable[hashval] = bp;

		indirect_item_block->used++;
		*new = TRUE;
		return(bp->output_offset);
	    }
	    output_offset += indirect_item_block->used * stride;
	}
	*p = allocate(sizeof(struct indirect_item_block));
	indirect_item_block = *p;
	indirect_item = indirect_item_block->indirect_items;
	indirect_item->merged_symbol = merged_symbol;
	indirect_item->obj = obj;
	indirect_item->index = index;
	indirect_item_block->used = 1;
	indirect_item_block->next = NULL;

	bp->indirect_item = indirect_item;
	bp->output_offset = output_offset;
	bp->next = data->hashtable[hashval];
	data->hashtable[hashval] = bp;

	*new = TRUE;
	return(bp->output_offset);
}

/*
 * indirect_section_order() enters indirect symbols from the order_file from the
 * merged section structure.  Since this is called before any call to
 * indirect_section_merge() and it enters the indirect symbols in the order of
 * the file it causes the section to be ordered.
 */
__private_extern__
void
indirect_section_order(
struct indirect_section_data *data, 
struct merged_section *ms)
{
#ifndef RLD
    kern_return_t r;
#ifdef __MWERKS__
    struct indirect_section_data *dummy1;
    struct merged_section *dummy2;
        dummy1 = data;
        dummy2 = ms;
#endif

	warning("section ordering for indirect sections not supported ("
		"-sectorder %s %s %s ignored)", ms->s.segname, ms->s.sectname,
		ms->order_filename);
	/*
	 * Deallocate the memory for the load order file now that it is
	 * nolonger needed.
	 */
	if((r = vm_deallocate(mach_task_self(), (vm_address_t)
	    ms->order_addr, ms->order_size)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
		       "file: %s for section (%.16s,%.16s)",
		       ms->order_filename, ms->s.segname,
		       ms->s.sectname);
	ms->order_addr = NULL;
#else /* RLD */
#ifdef __MWERKS__
    struct indirect_section_data *dummy1;
    struct merged_section *dummy2;
        dummy1 = data;
        dummy2 = ms;
#endif
#endif /* RLD */
}

/*
 * indirect_section_reset_live() is called when -dead_strip is specified after
 * the indirect sections the input objects are merged. It clears out
 * the indirect_section_data so the live indirect items can be re-merged (by
 * later calling indirect_section_merge() with redo_live == TRUE.
 */
__private_extern__
void
indirect_section_reset_live(
struct indirect_section_data *data, 
struct merged_section *ms)
{
	/*
	 * reset the total number of indirect symbol table entries in the
	 * output file.  Really needs to happen only once.  But placing it
	 * here it will get reset once for each merged section.
	 */
	nindirectsyms = 0;

	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* reset the count of relocation entries for this merged section */
	if(output_for_dyld){
	    ms->nlocrel = 0;
	    ms->nextrel = 0;
	}
	else if(save_reloc){
	    nreloc -= ms->s.nreloc;
	    ms->s.nreloc = 0;
	}

	/* clear out the previously merged data */
	indirect_section_free(data);
}

#ifndef RLD
/*
 * indirect_live_ref() is called by walk_references() as part of the live
 * marking pass when -dead_strip is specified to get the ref when a
 * indirect section is referenced.  The reference is specified by fine_reloc,
 * map and obj.  This routine sets the ref struct passed to it for the
 * reference if there is one and returns TRUE else it returns FALSE.
 */
__private_extern__
enum bool
indirect_live_ref(
struct fine_reloc *fine_reloc,
struct section_map *map,
struct object_file *obj,
struct ref *r)
{
    unsigned long index, value, r_symbolnum;
    struct nlist *nlists;
    char *contents;

	if((map->s->flags & SECTION_TYPE) != S_SYMBOL_STUBS &&
	   (map->s->flags & SECTION_TYPE) != S_LAZY_SYMBOL_POINTERS &&
	   (map->s->flags & SECTION_TYPE) != S_NON_LAZY_SYMBOL_POINTERS)
	    fatal("internal error: indirect_live_ref() called with map not for "
		  "indirect section");

	if(fine_reloc->local_symbol == TRUE){
	    /*
	     * Indirect table entries which refer to local defined symbols are
	     * allowed only in symbol stub and lazy pointer sections so they can
	     * always be removed and never created on output.  When this happens
	     * the fine_reloc has use_contents set to FALSE and the symbol index
	     * of the local symbol stored in output_offset.
	     */
	    if(fine_reloc->use_contents == FALSE){
		if((map->s->flags & SECTION_TYPE) ==
		   S_NON_LAZY_SYMBOL_POINTERS){
		    fatal("internal error: indirect_live_ref() called "
			  "with fine_reloc for non-lazy pointer with "
			  "local_symbol == TRUE and use_contents == "
			  "FALSE");
		}
		index = fine_reloc->output_offset;
		nlists = (struct nlist *)(obj->obj_addr +
					  obj->symtab->symoff);
		r_symbolnum = r_symbolnum_from_r_value(nlists[index].n_value,
						       obj);
	        r->map = &(obj->section_maps[r_symbolnum - 1]);
	        r->fine_reloc = fine_reloc_for_input_offset(r->map,
				      nlists[index].n_value - r->map->s->addr);
		r->obj = obj;
		r->merged_symbol = NULL;
		return(TRUE);
	    }
	    else{
		/*
		 * Both local_symbol is TRUE and use_contents is TRUE.  This
		 * happens for INDIRECT_SYMBOL_LOCAL and INDIRECT_SYMBOL_ABS.
		 * In this case we need to get the reference from the indirect
		 * symbol table entry (the section contents).  The contents of
		 * the non-lazy pointer has the address of the item being
		 * referenced.  If it is INDIRECT_SYMBOL_LOCAL then it will be
		 * in this object.  If it is INDIRECT_SYMBOL_ABS we will not
		 * return a reference.  If we have a INDIRECT_SYMBOL_ABS then
		 * we will return the ref_type set to LIVE_REF_NONE.
		 */
		if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		   (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS)
		    fatal("internal error: indirect_live_ref() called "
			  "with fine_reloc for stub or lazy pointer "
			  "with local_symbol == TRUE and use_contents "
			  "== TRUE");
		if(fine_reloc->indirect_symbol_local == TRUE){
		    contents = obj->obj_addr + map->s->offset;
		    memcpy(&value, contents + fine_reloc->input_offset, 4);
		    if(obj->swapped)
			value = SWAP_LONG(value);
		    r_symbolnum = r_symbolnum_from_r_value(value, obj);
		    r->map = &(obj->section_maps[r_symbolnum - 1]);
		    r->fine_reloc = fine_reloc_for_input_offset(r->map,
					value - r->map->s->addr);
		    r->obj = obj;
		    r->merged_symbol = NULL;
		    return(TRUE);
		}
		else{
		    /*
		     * Note: that fine_relocs for indirect symbol which are
		     * INDIRECT_SYMBOL_LOCAL and INDIRECT_SYMBOL_ABS have
		     * local_symbol set to TRUE.
		     */
		    return(FALSE);
		}
	    }
	}
	else{
	    /*
	     * External symbols just set the ref's merged_symbol field.
	     */
	    r->merged_symbol = fine_reloc->merged_symbol;
	    r->fine_reloc = NULL;
	    r->map = NULL;
	    r->obj = NULL;
	    return(TRUE);
	}
}
#endif /* !defined(RLD) */

/*
 * indirect_section_free() free()'s up all space used by the data block except 
 * the data block itself.
 */
__private_extern__
void
indirect_section_free(
struct indirect_section_data *data)
{
    unsigned long i;
    struct indirect_item_bucket *bp, *next_bp;
    struct indirect_item_block *indirect_item_block,
			       *next_indirect_item_block;

	/*
	 * Free all data for this block.
	 */
	if(data->hashtable != NULL){
	    for(i = 0; i < INDIRECT_SECTION_HASHSIZE; i++){
		for(bp = data->hashtable[i]; bp; ){
		    next_bp = bp->next;
		    free(bp);
		    bp = next_bp;
		}
	    }
	    free(data->hashtable);
	    data->hashtable = NULL;
	}
	for(indirect_item_block = data->indirect_item_blocks;
	    indirect_item_block;
	    indirect_item_block = next_indirect_item_block){

	    next_indirect_item_block = indirect_item_block->next;
	    free(indirect_item_block);
	}
	data->indirect_item_blocks = NULL;
}
#endif /* !defined(SA_RLD) */

/*
 * legal_reference() determines if the specified reference is legal with respect
 * to the correct usage of symbol stub sections and lazy symbol pointer sections
 * (as parts of these section can be removed by the link editor and we must make
 * sure that these things are correctly being referenced so removing them will
 * produce a correct object file).  The specified reference comes from a
 * relocation entry and is specified as section maps and offsets FROM the place
 * of reference to the item being refered TO and the relocation entry index
 * causing the reference.  It returns TRUE if the reference is legal if not it
 * prints the appropate error message and returns FALSE.
 */
__private_extern__
enum bool
legal_reference(
struct section_map *from_map,
unsigned long from_offset,
struct section_map *to_map,
unsigned long to_offset,
unsigned long from_reloc_index,
enum bool sectdiff_reloc)
{
#ifndef SA_RLD
    unsigned long to_section_type, from_section_type;
    unsigned long *indirect_symtab;
    struct fine_reloc *to_fine_reloc, *from_fine_reloc;
    struct merged_symbol *merged_symbol;
    unsigned long stride;

	from_section_type = from_map->s->flags & SECTION_TYPE;
	/*
	 * If we are not using the block where this reference is coming from
	 * then we don't care if this is an illegal reference or not.
	 */
	if(from_section_type == S_COALESCED){
	    from_fine_reloc =
		fine_reloc_for_input_offset(from_map, from_offset);
	    if(from_fine_reloc->use_contents == FALSE)
		return(TRUE);
	}

	to_section_type = to_map->s->flags & SECTION_TYPE;
	/*
	 * If this is a coalesced section then the reference may not be to this
	 * coalesced section if the referenced block's contents is not used,
	 * because the block could have been for a weak definition symbol.
	 */
	if(to_section_type == S_COALESCED){
	    to_fine_reloc = fine_reloc_for_input_offset(to_map, to_offset);
	    /*
	     * If this reference is to a local symbol then it is ok to reference
	     * this coalesced symbol directly from anywhere.
	     */
	    if(to_fine_reloc->local_symbol == TRUE)
		return(TRUE);
	    if(to_fine_reloc->use_contents == FALSE){
		merged_symbol = to_fine_reloc->merged_symbol;
		if(merged_symbol->defined_in_dylib == TRUE){
		    if(sectdiff_reloc == TRUE && dynamic == TRUE){
			error_with_cur_obj("illegal reference for -dynamic "
			    "code (section difference reference from section "
			    "(%.16s,%.16s) relocation entry (%lu) "
			    "to symbol: %s defined in dylib: %s)",
			    from_map->s->segname, from_map->s->sectname,
			    from_reloc_index, merged_symbol->nlist.n_un.n_name,
			    merged_symbol->definition_object->file_name);
			return(FALSE);
		    }
		    to_section_type = S_REGULAR;
		}
		else if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT){
		    if(merged_symbols_relocated == FALSE)
			to_section_type = merged_symbol->definition_object->
			    section_maps[merged_symbol->nlist.n_sect - 1].s->
			    flags & SECTION_TYPE;
		    else
			to_section_type =
			    pass2_nsect_merged_symbol_section_type(
				merged_symbol);
		}
		else{
		    if(sectdiff_reloc == TRUE && dynamic == TRUE){
			if((merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
			    error_with_cur_obj("illegal reference for -dynamic "
				"code (section difference reference from "
				"section (%.16s,%.16s) relocation entry (%lu) "
				"to absolute symbol: %s)",
				from_map->s->segname, from_map->s->sectname,
				from_reloc_index,
				merged_symbol->nlist.n_un.n_name);
			    return(FALSE);
			}
		    }
		    to_section_type = S_REGULAR;
		}
	    }
	}

	/*
	 * To allow the dynamic linker to use the same coalesced symbol through
	 * out the program all references to coalesced symbols must be
	 * relocatable to the same coalesced symbol.  Most references are done
	 * indirectly through symbol stubs and non-lazy pointers, static
	 * initialization of data references are done directly.  The only type
	 * direct reference that can't be relocated by the dynamic linker is
	 * a reference through a section difference relocation entry because
	 * it is pic and does not make it the output_for_dyld files.  This is
	 * bad code generation except for the case the reference is TO the
	 * same block the reference is from or to a block with a local symbol.
	 * The first is usually the picbase of a routine in a coalesced section
	 * and the second allows for unwind tables to reference private extern
	 * coalesced symbols.
	 */
	if(dynamic == TRUE && to_section_type == S_COALESCED &&
	   sectdiff_reloc == TRUE && (from_map != to_map ||
	   fine_reloc_for_input_offset(from_map, from_offset) != 
	   fine_reloc_for_input_offset(to_map, to_offset)) &&
	   fine_reloc_for_input_offset(to_map, to_offset)->local_symbol ==
		FALSE){
	    error_with_cur_obj("malformed object, illegal reference for "
		"-dynamic code (reference to a coalesced section (%.16s,"
		"%.16s) from section (%.16s,%.16s) relocation entry (%lu))",
		to_map->s->segname, to_map->s->sectname, from_map->s->segname,
		from_map->s->sectname, from_reloc_index);
	    return(FALSE);
	}

	/*
	 * If the reference is not to or from a symbol stub section or a
	 * lazy symbol pointer section it is legal as far as used of these
	 * sections goes.
	 */
	if(to_section_type != S_SYMBOL_STUBS &&
	   to_section_type != S_LAZY_SYMBOL_POINTERS &&
	   from_section_type != S_SYMBOL_STUBS &&
	   from_section_type != S_LAZY_SYMBOL_POINTERS)
	    return(TRUE);

	/*
	 * See if this reference is to a symbol stub section.
	 */
	if(to_section_type == S_SYMBOL_STUBS){
	    /*
	     * For references to a symbol stub section that are made from any
	     * thing but a lazy pointer section the reference must be made to
	     * the start of a symbol stub in that section.
	     */
	    if(from_section_type != S_LAZY_SYMBOL_POINTERS){
		if((to_offset % to_map->s->reserved2) != 0){
		    /*
		     * A reference to a symbol stub section may be made from the
		     * same symbol stub section from the same stub which is what
		     * happens for a pic style symbol stub.
		     */
		    if(from_section_type == S_SYMBOL_STUBS &&
		       from_map == to_map &&
		       from_offset / from_map->s->reserved2 ==
		       to_offset / to_map->s->reserved2)
			return(TRUE);
		    error_with_cur_obj("malformed object, illegal reference "
			"(reference to a symbol stub not at the start of the "
			"stub from section (%.16s,%.16s) relocation entry "
			"(%lu))", from_map->s->segname, from_map->s->sectname,
			from_reloc_index);
		    return(FALSE);
		}
		else
		    return(TRUE);
	    }
	    else{
		/*
		 * This reference is to a symbol stub section from a lazy
		 * pointer section.  The stub being referenced and the pointer
		 * must both have the same indirect symbol.  By same in this
		 * case we check for the same indirect symbol table entry
		 * (that is the same index into the symbol table).
		 */
		indirect_symtab = (unsigned long *)(cur_obj->obj_addr +
					    cur_obj->dysymtab->indirectsymoff);
		stride = 4;
		if(indirect_symtab[from_map->s->reserved1 + from_offset /
							stride] !=
		   indirect_symtab[to_map->s->reserved1 + to_offset /
							to_map->s->reserved2]){
		    error_with_cur_obj("malformed object, illegal reference "
			"(reference to symbol stub in section (%.16s,%.16s) "
			"at address 0x%x from lazy pointer section "
			"(%.16s,%.16s) relocation entry (%lu) with non-"
			"matching indirect symbols)", to_map->s->segname,
			to_map->s->sectname,
			(unsigned int)(to_map->s->addr + to_offset),
			from_map->s->segname, from_map->s->sectname,
			from_reloc_index);
		    return(FALSE);
		}
		else
		    return(TRUE);
	    }
	}

	/*
	 * See if this reference is to a lazy symbol pointer section.
	 */
	if(to_section_type == S_LAZY_SYMBOL_POINTERS){
	    /*
	     * Legal references to lazy pointer sections can only be made from a
	     * symbol stub section.
	     */
	    if(from_section_type != S_SYMBOL_STUBS){
		error_with_cur_obj("malformed object, illegal reference "
		    "(reference to a lazy symbol pointer section from section "
		    "(%.16s,%.16s) relocation entry (%lu) which is not a "
		    "symbol stub section)", from_map->s->segname,
		    from_map->s->sectname, from_reloc_index);
		return(FALSE);
	    }
	    else{
		/*
		 * This reference is to a lazy pointer section from a symbol
		 * stub section.  The pointer being referenced and the stub
		 * must both have the same indirect symbol.  By same in this
		 * case we check for the same indirect symbol table entry
		 * (that is the same index into the symbol table).
		 */
		indirect_symtab = (unsigned long *)(cur_obj->obj_addr +
					    cur_obj->dysymtab->indirectsymoff);
		stride = (arch_flag.cputype == CPU_TYPE_POWERPC64 ? 8 : 4);
		if(indirect_symtab[from_map->s->reserved1 + from_offset /
				   from_map->s->reserved2] !=
		   indirect_symtab[to_map->s->reserved1 + to_offset / stride]){
		    error_with_cur_obj("malformed object, illegal reference "
			"(reference to lazy symbol pointer section "
			"(%.16s,%.16s) at address 0x%x from symbol stub "
			"section (%.16s,%.16s) relocation entry (%lu) with "
			"non-matching indirect symbols)",
			to_map->s->segname, to_map->s->sectname,
			(unsigned int)(to_map->s->addr + to_offset),
			from_map->s->segname, from_map->s->sectname,
			from_reloc_index);
		    return(FALSE);
		}
		else
		    return(TRUE);
	    }
	}

	/*
	 * See if this reference is from a symbol stub section.
	 */
	if(from_section_type == S_SYMBOL_STUBS){
	    /*
	     * At this point we know this reference from a symbol stub section
	     * is not to lazy symbol pointer section.  The only thing else this
	     * section should be referencing is the stub binding helper routine.
	     */
	    return(TRUE);
	}
#endif /* !defined(SA_RLD) */
	return(TRUE);
}

#ifndef SA_RLD
/*
 * output_indirect_symbols() copies the indirect symbol table into the output
 * file.
 */
__private_extern__
void
output_indirect_symbols(
void)
{
    unsigned long i, nindirect_symbols;
    uint32_t *indirect_symbols;
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;
    struct indirect_section_data *data;
    struct indirect_item_block **q, *indirect_item_block;
    struct indirect_item *indirect_item;

	if(nindirectsyms == 0)
	    return;
	if(strip_level == STRIP_ALL)
	    fatal("can't use -s with input files containing indirect symbols "
		  "(output file must contain at least global symbols, for "
		  "maximum stripping use -x)");
	indirect_symbols = (uint32_t *)(output_addr +
			output_dysymtab_info.dysymtab_command.indirectsymoff);
	nindirect_symbols = 0;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		   (ms->s.flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
		   (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS){
		    data = (struct indirect_section_data *)ms->literal_data;
		    ms->s.reserved1 = nindirect_symbols;
		    for(q = &(data->indirect_item_blocks);
			*q ;
			q = &(indirect_item_block->next)){

			indirect_item_block = *q;
			for(i = 0; i < indirect_item_block->used; i++){
			    indirect_item = indirect_item_block->
					    indirect_items + i;
			    if(indirect_item->merged_symbol != NULL){
				/*
				 * If this is a non-lazy symbol pointer section
				 * and the symbol is a private extern then
				 * change the indirect symbol to
				 * INDIRECT_SYMBOL_LOCAL or
				 * INDIRECT_SYMBOL_ABS.
				 */
				if((ms->s.flags & SECTION_TYPE) ==
				   S_NON_LAZY_SYMBOL_POINTERS &&
				   (indirect_item->merged_symbol->
					nlist.n_type & N_PEXT) == N_PEXT &&
				    keep_private_externs == FALSE){
				    if((indirect_item->merged_symbol->
					nlist.n_type & N_TYPE) == N_ABS)
					indirect_symbols[nindirect_symbols++] =
						INDIRECT_SYMBOL_ABS;
				    else
					indirect_symbols[nindirect_symbols++] =
						INDIRECT_SYMBOL_LOCAL;
				}
				else{
				    indirect_symbols[nindirect_symbols++] =
					merged_symbol_output_index(
					    indirect_item->merged_symbol);
				}
			    }
			    else{
				if(indirect_item->index ==
				       INDIRECT_SYMBOL_LOCAL ||
				   indirect_item->index ==
				       INDIRECT_SYMBOL_ABS){
				    indirect_symbols[nindirect_symbols++] =
					indirect_item->index;
				}
				else{
				    indirect_symbols[nindirect_symbols++] =
					local_symbol_output_index(
					    indirect_item->obj,
					    indirect_item->index);
				}
			    }
			}
		    }
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
	if(nindirect_symbols != nindirectsyms)
	    fatal("internal error, nindirect_symbols != nindirectsyms in "
		   "output_indirect_symbols()");
	if(host_byte_sex != target_byte_sex)
	    swap_indirect_symbols(indirect_symbols, nindirect_symbols,
		target_byte_sex);
#ifndef RLD
	output_flush(output_dysymtab_info.dysymtab_command.indirectsymoff,
		     nindirect_symbols * sizeof(uint32_t));
#endif /* !defined(RLD) */
}
#endif /* !defined(SA_RLD) */
                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/indirect_sections.h                      0100644 0001750 0001750 00000010632 12612724205 024721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * The number of indirect symbol table entries in the output file.
 */
__private_extern__ unsigned long nindirectsyms;

/*
 * If we are still attempting to prebind when indirect_section_merge() is
 * called save_lazy_symbol_pointer_relocs will get set in layout.c.
 * Between the time indirect_section_merge() gets called and the time
 * reloc_output_for_dyld() gets called prebinding may be disabled because of
 * various problems.  But the count of relocs can't change after layout so
 * we'll put them out anyway.
 */
__private_extern__ enum bool save_lazy_symbol_pointer_relocs;

/*
 * The literal_data which is set into a merged_section's literal_data field for
 * indirect sections.  The external functions declared at the end of this file
 * operate on this data and are used for the other fields of a merged_section
 * for literals (literal_merge, literal_write, and literal_free).
 */
struct indirect_section_data {
    struct indirect_item_bucket **hashtable;	/* the hash table */
    struct indirect_item_block			/* the items */
	*indirect_item_blocks;
#ifdef DEBUG
    unsigned long nfiles;	/* number of files with this section */
    unsigned long nitems;	/* total number of items in the input files */
				/*  merged into this section */
    unsigned long nprobes;	/* number of hash probes */
#endif /* DEBUG */
};

/* the number of entries in the hash table */
#define INDIRECT_SECTION_HASHSIZE 1000

/* the hash bucket entries in the hash table points to; allocated as needed */
struct indirect_item_bucket {
    struct indirect_item *indirect_item; /* pointer to the item */
    unsigned long output_offset; /* offset to this pointer in the output file */
    struct indirect_item_bucket *next;   /* next in the hash chain */
};

/*
 * The structure to hold a item's merge symbol pointer that is the indirect
 * symbol for this item.
 */
struct indirect_item {
    struct merged_symbol *merged_symbol;
    struct object_file *obj;
    unsigned long index;
};

/* the number of entries each item block*/
#define INDIRECT_SECTION_BLOCK_SIZE 1000
/* the blocks that store the item's symbol; allocated as needed */
struct indirect_item_block {
    unsigned long used;			/* the number of items used in */
    struct indirect_item		/*  this block */
	indirect_items
	[INDIRECT_SECTION_BLOCK_SIZE];	/* the item's symbol */
    struct indirect_item_block *next;	/* the next block */
};

__private_extern__ void indirect_section_merge(
    struct indirect_section_data *data, 
    struct merged_section *ms,
    struct section *s, 
    struct section_map *section_map,
    enum bool redo_live);

__private_extern__ void indirect_section_order(
    struct indirect_section_data *data, 
    struct merged_section *ms);

__private_extern__ void indirect_section_reset_live(
    struct indirect_section_data *data, 
    struct merged_section *ms);

__private_extern__ enum bool indirect_live_ref(
    struct fine_reloc *fine_reloc,
    struct section_map *map,
    struct object_file *obj,
    struct ref *ref);

__private_extern__ void indirect_section_free(
    struct indirect_section_data *data);

__private_extern__ enum bool legal_reference(
    struct section_map *from_map,
    unsigned long from_offset,
    struct section_map *to_map,
    unsigned long to_offset,
    unsigned long from_reloc_index,
    enum bool sectdiff_reloc);

__private_extern__ void output_indirect_symbols(
    void);
                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/layout.c                                 0100644 0001750 0001750 00000240547 12612724205 022533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#define __srr0 srr0
#define __r1 r1
#define __eip eip
#define __esp esp
#define __es es
#define __ds ds
#define __ss ss
#define __cs cs

#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that drives the layout phase of the
 * link-editor.  In this phase the output file's addresses and offset are
 * set up.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else
#include <mach/mach.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <sys/param.h>
#include "stuff/openstep_mach.h"
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#import <mach/m68k/thread_status.h>
#undef MACHINE_THREAD_STATE	/* need to undef these to avoid warnings */
#undef MACHINE_THREAD_STATE_COUNT
#undef THREAD_STATE_NONE
#undef VALID_THREAD_STATE_FLAVOR
#import <mach/ppc/thread_status.h>
#undef MACHINE_THREAD_STATE	/* need to undef these to avoid warnings */
#undef MACHINE_THREAD_STATE_COUNT
#undef THREAD_STATE_NONE
#undef VALID_THREAD_STATE_FLAVOR
#import <mach/m88k/thread_status.h>
#import <mach/i860/thread_status.h>
#import <mach/i386/thread_status.h>
#import <mach/hppa/thread_status.h>
#import <mach/sparc/thread_status.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#if defined(RLD) && !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
#include <mach-o/rld.h>
#include <streams/streams.h>
#endif /* defined(RLD) && !defined(SA_RLD) &&
	  !(defined(KLD) && defined(__STATIC__)) */

#include "stuff/arch.h"
#include "stuff/macosx_deployment_target.h"

#include "ld.h"
#include "specs.h"
#include "fvmlibs.h"
#include "dylibs.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "layout.h"
#include "pass2.h"
#include "sets.h"
#include "mach-o/sarld.h"
#include "indirect_sections.h"
#include "uuid.h"

#ifdef RLD
__private_extern__ long RLD_DEBUG_OUTPUT_FILENAME_flag;
#endif

/* The output file's mach header */
__private_extern__ struct mach_header output_mach_header = { 0 };

/*
 * The output file's symbol table load command and the offsets used in the
 * second pass to output the symbol table and string table.
 */
__private_extern__ struct symtab_info output_symtab_info = { {0} };

/*
 * The output file's dynamic symbol table load command.
 */
__private_extern__ struct dysymtab_info output_dysymtab_info = { {0} };

/*
 * The output file's two level hints load command.
 */
__private_extern__ struct hints_info output_hints_info = { { 0 } };

/*
 * The output file's prebind_cksum load command.
 */
__private_extern__ struct cksum_info output_cksum_info = { { 0 } };

/*
 * The output file's UUID load command.
 */
__private_extern__ struct uuid_info output_uuid_info = { 0 };

/*
 * The output file's thread load command and the machine specific information
 * for it.
 */
__private_extern__ struct thread_info output_thread_info = { {0} };

/*
 * The output file's routines load command and the specific information for it.
 */
__private_extern__ struct routines_info output_routines_info = { {0} };

/*
 * The thread states that are currently known by this link editor.
 * (for the specific cputypes)
 */
/* cputype == CPU_TYPE_MC680x0, all cpusubtype's */
static struct m68k_thread_state_regs mc680x0 = { {0} };
/* cputype == CPU_TYPE_POWERPC, all cpusubtype's */
static ppc_thread_state_t powerpc = { 0 };
/* cputype == CPU_TYPE_MC88000, all cpusubtype's */
static m88k_thread_state_grf_t mc88000 = { 0 };
/* cputype == CPU_TYPE_I860, all cpusubtype's */
static struct i860_thread_state_regs i860 = { {0} };
/* cputype == CPU_TYPE_I386, all cpusubtype's */
static i386_thread_state_t intel386 = { 0 };
/* cputype == CPU_TYPE_HPPA, all cpusubtypes */
static struct hp_pa_frame_thread_state hppa_frame_state = { 0 };
static struct hp_pa_integer_thread_state hppa_integer_state = { 0 };
/* cputype == CPU_TYPE_SPARC, all subtypes */
static struct sparc_thread_state_regs sparc_state = { {0} };
/* cputype == CPU_TYPE_ARM, all subtypes */
static arm_thread_state_t arm_state = { {0} };

static void layout_segments(void);
static unsigned long next_vmaddr(
    unsigned long vmaddr,
    unsigned long vmsize);
static int qsort_vmaddr(
    const struct merged_segment **msg1,
    const struct merged_segment **msg2);
#ifndef RLD
static enum bool check_reserved_segment(char *segname,
					char *reserved_error_string);
static void check_overlap(struct merged_segment *msg1,
			  struct merged_segment *msg2,
			  enum bool prebind_check,
    			  struct merged_segment *outputs_linkedit_segment);
static void check_for_overlapping_segments(
    struct merged_segment *outputs_linkedit_segment);
static void check_for_lazy_pointer_relocs_too_far(void);
static void print_load_map(void);
static void print_load_map_for_objects(struct merged_section *ms);
#endif /* !defined(RLD) */

/*
 * layout() is called from main() and lays out the output file.
 */
__private_extern__
void
layout(void)
{
#ifdef RLD
	memset(&output_mach_header, '\0', sizeof(struct mach_header));
	memset(&output_symtab_info, '\0', sizeof(struct symtab_info));
	memset(&output_dysymtab_info, '\0', sizeof(struct dysymtab_info));
	memset(&output_hints_info, '\0', sizeof(struct hints_info));
	memset(&output_cksum_info, '\0', sizeof(struct cksum_info));
#ifndef KLD
	memset(&output_uuid_info, '\0', sizeof(struct uuid_info));
#endif
	memset(&output_thread_info, '\0', sizeof(struct thread_info));
	memset(&mc680x0, '\0', sizeof(struct m68k_thread_state_regs));
	memset(&powerpc,     '\0', sizeof(ppc_thread_state_t));
	memset(&mc88000, '\0', sizeof(m88k_thread_state_grf_t));
	memset(&intel386,'\0', sizeof(i386_thread_state_t));
	intel386.es = USER_DATA_SELECTOR;
	intel386.ds = USER_DATA_SELECTOR;
	intel386.ss = USER_DATA_SELECTOR;
	intel386.cs = USER_CODE_SELECTOR;
	memset(&hppa_frame_state, '\0',
		sizeof(struct hp_pa_frame_thread_state));
	memset(&hppa_integer_state, '\0',
		sizeof(struct hp_pa_integer_thread_state));
	memset(&sparc_state, '\0', sizeof(struct sparc_thread_state_regs));
#endif /* RLD */
	/*
	 * First finish creating all sections that will be in the final output
	 * file.  This involves defining common symbols which can create a
	 * (__DATA,__common) section and creating sections from files (via
	 * -sectcreate options).
	 */
	define_common_symbols();
	/*
	 * Process the command line specifications for the sections including
	 * creating sections from files.
	 */
#ifndef RLD
	process_section_specs();
#endif /* !defined(RLD) */

	/*
	 * So literal pointer sections can use indirect symbols these need to
	 * be resolved before the literal pointer section is merged.
	 */
	reduce_indr_symbols();
	if(errors)
	    return;

#ifndef RLD
	/*
	 * Setup the link editor defined symbols if the output file type could
	 * be output for dyld. This is needed because the symbol needs to be
	 * defined and set to a private extern so that file can be laid out
	 * even though we don't know it's address at this point.
	 */
	if(filetype == MH_EXECUTE ||
	   filetype == MH_BUNDLE ||
	   filetype == MH_DYLIB ||
	   filetype == MH_DYLINKER){
	    setup_link_editor_symbols();
	    if(undefined_flag == UNDEFINED_DEFINE_A_WAY)
		define_undefined_symbols_a_way();
	}
	if(filetype == MH_PRELOAD)
	    define_link_editor_preload_symbols(TRUE);
#endif /* !defined(RLD) */

	/*
	 * Now that the alignment of all the sections has been determined (from
	 * the command line and the object files themselves) the literal
	 * sections can be merged with the correct alignment and their sizes
	 * in the output file can be determined.
	 */
	save_lazy_symbol_pointer_relocs = prebinding;
	merge_literal_sections(FALSE);
	if(errors)
	    return;
#ifdef DEBUG
	if(debug & (1 << 21))
	    print_merged_section_stats();
#endif /* DEBUG */

	/*
	 * Segments with only debug sections do not appear in the output.
	 * So before dead code stripping and laying out the segments and
	 * sections for the output remove them from the merged segment and
	 * merged sections list.
	 */
	remove_debug_segments();

#ifndef RLD
	/*
	 * Layout any sections that have -sectorder options specified for them.
	 */
	layout_ordered_sections();

	/*
	 * If -dead_strip is specified mark the fine_relocs that are live and
	 * update all the merged counts, and resize everything to only contain
	 * live items.
	 */
	if(dead_strip == TRUE){
	    /*
	     * Mark the fine_relocs and symbols that are live.
	     */
	    live_marking();

	    /*
	     * If live_marking() encountered a relocation error just return now.
	     */
	    if(errors)
		return;

	    /*
	     * Now with all the live fine_relocs and live merged symbols marked
	     * merged tables, calculated sizes and counts for everything that is
	     * live.
	     */
	    count_live_symbols();

	    /*
	     * Now resize all sections using the live block sizes and adjust
	     * the number of relocation entries so the counts includes entries
	     * only for live blocks.
	     */
	    resize_live_sections();

	    /*
	     * Now re-merge all the literal sections so that only live literals
	     * end up in the output.
	     */
	    merge_literal_sections(TRUE);
	}
#endif /* RLD */

	/*
	 * Report undefined symbols and account for the merged symbols that will
	 * not be in the output file.
	 */
	process_undefineds();
	if(errors)
	    return;

#ifndef RLD
	/*
	 * Check to make sure symbols are not overridden in dependent dylibs
	 * when prebinding.
	 */
	prebinding_check_for_dylib_override_symbols();

	/*
	 * If the users wants to see warnings about unused multiply defined
	 * symbols when -twolevel_namespace is in effect then check for them
	 * and print out a warning.
	 */
	if(nowarnings == FALSE &&
	   twolevel_namespace == TRUE &&
	   multiply_defined_unused_flag != MULTIPLY_DEFINED_SUPPRESS)
	    twolevel_namespace_check_for_unused_dylib_symbols();
#endif /* RLD */

	/*
	 * Assign the symbol table indexes for the symbol table entries.
	 */
	assign_output_symbol_indexes();

#ifndef RLD
	/*
	 * Layout the dynamic shared library tables if the output is a MH_DYLIB
	 * file.
	 */
	if(filetype == MH_DYLIB)
	    layout_dylib_tables();

	/*
	 * If the output is intended for the dynamic link editor or -dead_strip
	 * is specified relayout the relocation entries for only the ones that
	 * will be in the output file.
	 */
	if(output_for_dyld == TRUE || dead_strip == TRUE)
	    relayout_relocs();

	/*
	 * If the segment alignment is not set, set it based on the target
	 * architecture.
	 */
	if(segalign_specified == FALSE)
#endif /* !defined(RLD) */
	    segalign = get_segalign_from_flag(&arch_flag);

	/*
	 * Set the segment addresses, protections and offsets into the file.
	 */
	layout_segments();

#ifndef RLD
	/*
	 * For symbol from dylibs reset the prebound symbols if not prebinding.
	 */
	reset_prebound_undefines();

	if(load_map)
	    print_load_map();
#endif /* !defined(RLD) */

#ifdef DEBUG
	if(debug & (1 << 7)){
	    print_mach_header();
	    print_merged_sections("after layout");
	    print_symtab_info();
	    print_thread_info();
	}
	if(debug & (1 << 8))
	    print_symbol_list("after layout", FALSE);
	if(debug & (1 << 20))
	    print_object_list();
#endif /* DEBUG */
}

#if defined(RLD) && !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
/*
 * layout_rld_symfile() is called from rld_write_symfile() and lays out the
 * output file.  This contains only a mach_header, a symtab load command the
 * symbol and string table for the current set of merged symbols.
 */
__private_extern__
void
layout_rld_symfile(void)
{
    unsigned long offset;
    kern_return_t r;

	memset(&output_mach_header, '\0', sizeof(struct mach_header));
	memset(&output_symtab_info, '\0', sizeof(struct symtab_info));

	/*
	 * Create the symbol table load command.
	 */
	output_symtab_info.symtab_command.cmd = LC_SYMTAB;
	output_symtab_info.symtab_command.cmdsize =
						sizeof(struct symtab_command);
	output_symtab_info.symtab_command.nsyms = nmerged_symbols;
	output_symtab_info.symtab_command.strsize =
	    rnd(merged_string_size + STRING_SIZE_OFFSET,
		  sizeof(unsigned long));
	output_symtab_info.output_strpad =
	    output_symtab_info.symtab_command.strsize -
	    (merged_string_size + STRING_SIZE_OFFSET);
	output_symtab_info.output_merged_strsize = STRING_SIZE_OFFSET;
	output_symtab_info.output_local_strsize = STRING_SIZE_OFFSET +
						      merged_string_size;
	/*
	 * Fill in the mach_header for the output file.
	 */
	output_mach_header.magic = MH_MAGIC;
	output_mach_header.cputype = arch_flag.cputype;
	output_mach_header.cpusubtype = arch_flag.cpusubtype;
	output_mach_header.filetype = filetype;
	output_mach_header.ncmds = 1;
	output_mach_header.sizeofcmds =
	 			output_symtab_info.symtab_command.cmdsize;
	output_mach_header.flags = 0;

	/*
	 * Lay everything out setting the offsets.
	 */
	offset = sizeof(struct mach_header) + output_mach_header.sizeofcmds;
	output_symtab_info.symtab_command.symoff = offset;
	offset += output_symtab_info.symtab_command.nsyms *
		  sizeof(struct nlist);
	output_symtab_info.symtab_command.stroff = offset;
	offset += output_symtab_info.symtab_command.strsize;

	/*
	 * Allocate the buffer for the output file.
	 */
	output_size = offset;
	if((r = vm_allocate(mach_task_self(), (vm_address_t *)&output_addr,
		