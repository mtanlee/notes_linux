to 'add_include_dir()' add
        to the list passed to 'set_include_dirs()'.  This does not affect
        any list of standard include directories that the compiler may
        search by default.
        """
        self.include_dirs = dirs[:]

    def add_library(self, libname):
        """Add 'libname' to the list of libraries that will be included in
        all links driven by this compiler object.  Note that 'libname'
        should *not* be the name of a file containing a library, but the
        name of the library itself: the actual filename will be inferred by
        the linker, the compiler, or the compiler class (depending on the
        platform).

        The linker will be instructed to link against libraries in the
        order they were supplied to 'add_library()' and/or
        'set_libraries()'.  It is perfectly valid to duplicate library
        names; the linker will be instructed to link against libraries as
        many times as they are mentioned.
        """
        self.libraries.append (libname)

    def set_libraries(self, libnames):
        """Set the list of libraries to be included in all links driven by
        this compiler object to 'libnames' (a list of strings).  This does
        not affect any standard system libraries that the linker may
        include by default.
        """
        self.libraries = libnames[:]


    def add_library_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        libraries specified to 'add_library()' and 'set_libraries()'.  The
        linker will be instructed to search for libraries in the order they
        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
        """
        self.library_dirs.append(dir)

    def set_library_dirs(self, dirs):
        """Set the list of library search directories to 'dirs' (a list of
        strings).  This does not affect any standard library search path
        that the linker may search by default.
        """
        self.library_dirs = dirs[:]

    def add_runtime_library_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        shared libraries at runtime.
        """
        self.runtime_library_dirs.append(dir)

    def set_runtime_library_dirs(self, dirs):
        """Set the list of directories to search for shared libraries at
        runtime to 'dirs' (a list of strings).  This does not affect any
        standard search path that the runtime linker may search by
        default.
        """
        self.runtime_library_dirs = dirs[:]

    def add_link_object(self, object):
        """Add 'object' to the list of object files (or analogues, such as
        explicitly named library files or the output of "resource
        compilers") to be included in every link driven by this compiler
        object.
        """
        self.objects.append(object)

    def set_link_objects(self, objects):
        """Set the list of object files (or analogues) to be included in
        every link to 'objects'.  This does not affect any standard object
        files that the linker may include by default (such as system
        libraries).
        """
        self.objects = objects[:]


    # -- Private utility methods --------------------------------------
    # (here for the convenience of subclasses)

    # Helper method to prep compiler in subclass compile() methods

    def _setup_compile(self, outdir, macros, incdirs, sources, depends,
                       extra):
        """Process arguments and decide which source files to compile."""
        if outdir is None:
            outdir = self.output_dir
        elif not isinstance(outdir, str):
            raise TypeError, "'output_dir' must be a string or None"

        if macros is None:
            macros = self.macros
        elif isinstance(macros, list):
            macros = macros + (self.macros or [])
        else:
            raise TypeError, "'macros' (if supplied) must be a list of tuples"

        if incdirs is None:
            incdirs = self.include_dirs
        elif isinstance(incdirs, (list, tuple)):
            incdirs = list(incdirs) + (self.include_dirs or [])
        else:
            raise TypeError, \
                  "'include_dirs' (if supplied) must be a list of strings"

        if extra is None:
            extra = []

        # Get the list of expected output (object) files
        objects = self.object_filenames(sources,
                                        strip_dir=0,
                                        output_dir=outdir)
        assert len(objects) == len(sources)

        pp_opts = gen_preprocess_options(macros, incdirs)

        build = {}
        for i in range(len(sources)):
            src = sources[i]
            obj = objects[i]
            ext = os.path.splitext(src)[1]
            self.mkpath(os.path.dirname(obj))
            build[obj] = (src, ext)

        return macros, objects, extra, pp_opts, build

    def _get_cc_args(self, pp_opts, debug, before):
        # works for unixccompiler, emxccompiler, cygwinccompiler
        cc_args = pp_opts + ['-c']
        if debug:
            cc_args[:0] = ['-g']
        if before:
            cc_args[:0] = before
        return cc_args

    def _fix_compile_args(self, output_dir, macros, include_dirs):
        """Typecheck and fix-up some of the arguments to the 'compile()'
        method, and return fixed-up values.  Specifically: if 'output_dir'
        is None, replaces it with 'self.output_dir'; ensures that 'macros'
        is a list, and augments it with 'self.macros'; ensures that
        'include_dirs' is a list, and augments it with 'self.include_dirs'.
        Guarantees that the returned values are of the correct type,
        i.e. for 'output_dir' either string or None, and for 'macros' and
        'include_dirs' either list or None.
        """
        if output_dir is None:
            output_dir = self.output_dir
        elif not isinstance(output_dir, str):
            raise TypeError, "'output_dir' must be a string or None"

        if macros is None:
            macros = self.macros
        elif isinstance(macros, list):
            macros = macros + (self.macros or [])
        else:
            raise TypeError, "'macros' (if supplied) must be a list of tuples"

        if include_dirs is None:
            include_dirs = self.include_dirs
        elif isinstance(include_dirs, (list, tuple)):
            include_dirs = list (include_dirs) + (self.include_dirs or [])
        else:
            raise TypeError, \
                  "'include_dirs' (if supplied) must be a list of strings"

        return output_dir, macros, include_dirs

    def _fix_object_args(self, objects, output_dir):
        """Typecheck and fix up some arguments supplied to various methods.
        Specifically: ensure that 'objects' is a list; if output_dir is
        None, replace with self.output_dir.  Return fixed versions of
        'objects' and 'output_dir'.
        """
        if not isinstance(objects, (list, tuple)):
            raise TypeError, \
                  "'objects' must be a list or tuple of strings"
        objects = list (objects)

        if output_dir is None:
            output_dir = self.output_dir
        elif not isinstance(output_dir, str):
            raise TypeError, "'output_dir' must be a string or None"

        return (objects, output_dir)

    def _fix_lib_args(self, libraries, library_dirs, runtime_library_dirs):
        """Typecheck and fix up some of the arguments supplied to the
        'link_*' methods.  Specifically: ensure that all arguments are
        lists, and augment them with their permanent versions
        (eg. 'self.libraries' augments 'libraries').  Return a tuple with
        fixed versions of all arguments.
        """
        if libraries is None:
            libraries = self.libraries
        elif isinstance(libraries, (list, tuple)):
            libraries = list (libraries) + (self.libraries or [])
        else:
            raise TypeError, \
                  "'libraries' (if supplied) must be a list of strings"

        if library_dirs is None:
            library_dirs = self.library_dirs
        elif isinstance(library_dirs, (list, tuple)):
            library_dirs = list (library_dirs) + (self.library_dirs or [])
        else:
            raise TypeError, \
                  "'library_dirs' (if supplied) must be a list of strings"

        if runtime_library_dirs is None:
            runtime_library_dirs = self.runtime_library_dirs
        elif isinstance(runtime_library_dirs, (list, tuple)):
            runtime_library_dirs = (list (runtime_library_dirs) +
                                    (self.runtime_library_dirs or []))
        else:
            raise TypeError, \
                  "'runtime_library_dirs' (if supplied) " + \
                  "must be a list of strings"

        return (libraries, library_dirs, runtime_library_dirs)

    def _need_link(self, objects, output_file):
        """Return true if we need to relink the files listed in 'objects'
        to recreate 'output_file'.
        """
        if self.force:
            return 1
        else:
            if self.dry_run:
                newer = newer_group (objects, output_file, missing='newer')
            else:
                newer = newer_group (objects, output_file)
            return newer

    def detect_language(self, sources):
        """Detect the language of a given file, or list of files. Uses
        language_map, and language_order to do the job.
        """
        if not isinstance(sources, list):
            sources = [sources]
        lang = None
        index = len(self.language_order)
        for source in sources:
            base, ext = os.path.splitext(source)
            extlang = self.language_map.get(ext)
            try:
                extindex = self.language_order.index(extlang)
                if extindex < index:
                    lang = extlang
                    index = extindex
            except ValueError:
                pass
        return lang

    # -- Worker methods ------------------------------------------------
    # (must be implemented by subclasses)

    def preprocess(self, source, output_file=None, macros=None,
                   include_dirs=None, extra_preargs=None, extra_postargs=None):
        """Preprocess a single C/C++ source file, named in 'source'.
        Output will be written to file named 'output_file', or stdout if
        'output_file' not supplied.  'macros' is a list of macro
        definitions as for 'compile()', which will augment the macros set
        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
        list of directory names that will be added to the default list.

        Raises PreprocessError on failure.
        """
        pass

    def compile(self, sources, output_dir=None, macros=None,
                include_dirs=None, debug=0, extra_preargs=None,
                extra_postargs=None, depends=None):
        """Compile one or more source files.

        'sources' must be a list of filenames, most likely C/C++
        files, but in reality anything that can be handled by a
        particular compiler and compiler class (eg. MSVCCompiler can
        handle resource files in 'sources').  Return a list of object
        filenames, one per source filename in 'sources'.  Depending on
        the implementation, not all source files will necessarily be
        compiled, but all corresponding object filenames will be
        returned.

        If 'output_dir' is given, object files will be put under it, while
        retaining their original path component.  That is, "foo/bar.c"
        normally compiles to "foo/bar.o" (for a Unix implementation); if
        'output_dir' is "build", then it would compile to
        "build/foo/bar.o".

        'macros', if given, must be a list of macro definitions.  A macro
        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
        The former defines a macro; if the value is None, the macro is
        defined without an explicit value.  The 1-tuple case undefines a
        macro.  Later definitions/redefinitions/ undefinitions take
        precedence.

        'include_dirs', if given, must be a list of strings, the
        directories to add to the default include file search path for this
        compilation only.

        'debug' is a boolean; if true, the compiler will be instructed to
        output debug symbols in (or alongside) the object file(s).

        'extra_preargs' and 'extra_postargs' are implementation- dependent.
        On platforms that have the notion of a command-line (e.g. Unix,
        DOS/Windows), they are most likely lists of strings: extra
        command-line arguments to prepand/append to the compiler command
        line.  On other platforms, consult the implementation class
        documentation.  In any event, they are intended as an escape hatch
        for those occasions when the abstract compiler framework doesn't
        cut the mustard.

        'depends', if given, is a list of filenames that all targets
        depend on.  If a source file is older than any file in
        depends, then the source file will be recompiled.  This
        supports dependency tracking, but only at a coarse
        granularity.

        Raises CompileError on failure.
        """
        # A concrete compiler class can either override this method
        # entirely or implement _compile().

        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)
        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)

        # Return *all* object filenames, not just the ones we just built.
        return objects

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        """Compile 'src' to product 'obj'."""

        # A concrete compiler class that does not override compile()
        # should implement _compile().
        pass

    def create_static_lib(self, objects, output_libname, output_dir=None,
                          debug=0, target_lang=None):
        """Link a bunch of stuff together to create a static library file.
        The "bunch of stuff" consists of the list of object files supplied
        as 'objects', the extra object files supplied to
        'add_link_object()' and/or 'set_link_objects()', the libraries
        supplied to 'add_library()' and/or 'set_libraries()', and the
        libraries supplied as 'libraries' (if any).

        'output_libname' should be a library name, not a filename; the
        filename will be inferred from the library name.  'output_dir' is
        the directory where the library file will be put.

        'debug' is a boolean; if true, debugging information will be
        included in the library (note that on most platforms, it is the
        compile step where this matters: the 'debug' flag is included here
        just for consistency).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LibError on failure.
        """
        pass

    # values for target_desc parameter in link()
    SHARED_OBJECT = "shared_object"
    SHARED_LIBRARY = "shared_library"
    EXECUTABLE = "executable"

    def link(self, target_desc, objects, output_filename, output_dir=None,
             libraries=None, library_dirs=None, runtime_library_dirs=None,
             export_symbols=None, debug=0, extra_preargs=None,
             extra_postargs=None, build_temp=None, target_lang=None):
        """Link a bunch of stuff together to create an executable or
        shared library file.

        The "bunch of stuff" consists of the list of object files supplied
        as 'objects'.  'output_filename' should be a filename.  If
        'output_dir' is supplied, 'output_filename' is relative to it
        (i.e. 'output_filename' can provide directory components if
        needed).

        'libraries' is a list of libraries to link against.  These are
        library names, not filenames, since they're translated into
        filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
        on Unix and "foo.lib" on DOS/Windows).  However, they can include a
        directory component, which means the linker will look in that
        specific directory rather than searching all the normal locations.

        'library_dirs', if supplied, should be a list of directories to
        search for libraries that were specified as bare library names
        (ie. no directory component).  These are on top of the system
        default and those supplied to 'add_library_dir()' and/or
        'set_library_dirs()'.  'runtime_library_dirs' is a list of
        directories that will be embedded into the shared library and used
        to search for other shared libraries that *it* depends on at
        run-time.  (This may only be relevant on Unix.)

        'export_symbols' is a list of symbols that the shared library will
        export.  (This appears to be relevant only on Windows.)

        'debug' is as for 'compile()' and 'create_static_lib()', with the
        slight distinction that it actually matters on most platforms (as
        opposed to 'create_static_lib()', which includes a 'debug' flag
        mostly for form's sake).

        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
        of course that they supply command-line arguments for the
        particular linker being used).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LinkError on failure.
        """
        raise NotImplementedError


    # Old 'link_*()' methods, rewritten to use the new 'link()' method.

    def link_shared_lib(self, objects, output_libname, output_dir=None,
                        libraries=None, library_dirs=None,
                        runtime_library_dirs=None, export_symbols=None,
                        debug=0, extra_preargs=None, extra_postargs=None,
                        build_temp=None, target_lang=None):
        self.link(CCompiler.SHARED_LIBRARY, objects,
                  self.library_filename(output_libname, lib_type='shared'),
                  output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)


    def link_shared_object(self, objects, output_filename, output_dir=None,
                           libraries=None, library_dirs=None,
                           runtime_library_dirs=None, export_symbols=None,
                           debug=0, extra_preargs=None, extra_postargs=None,
                           build_temp=None, target_lang=None):
        self.link(CCompiler.SHARED_OBJECT, objects,
                  output_filename, output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)

    def link_executable(self, objects, output_progname, output_dir=None,
                        libraries=None, library_dirs=None,
                        runtime_library_dirs=None, debug=0, extra_preargs=None,
                        extra_postargs=None, target_lang=None):
        self.link(CCompiler.EXECUTABLE, objects,
                  self.executable_filename(output_progname), output_dir,
                  libraries, library_dirs, runtime_library_dirs, None,
                  debug, extra_preargs, extra_postargs, None, target_lang)


    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function; there is
    # no appropriate default implementation so subclasses should
    # implement all of these.

    def library_dir_option(self, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched for libraries.
        """
        raise NotImplementedError

    def runtime_library_dir_option(self, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched for runtime libraries.
        """
        raise NotImplementedError

    def library_option(self, lib):
        """Return the compiler option to add 'dir' to the list of libraries
        linked into the shared library or executable.
        """
        raise NotImplementedError

    def has_function(self, funcname, includes=None, include_dirs=None,
                     libraries=None, library_dirs=None):
        """Return a boolean indicating whether funcname is supported on
        the current platform.  The optional arguments can be used to
        augment the compilation environment.
        """

        # this can't be included at module scope because it tries to
        # import math which might not be available at that point - maybe
        # the necessary logic should just be inlined?
        import tempfile
        if includes is None:
            includes = []
        if include_dirs is None:
            include_dirs = []
        if libraries is None:
            libraries = []
        if library_dirs is None:
            library_dirs = []
        fd, fname = tempfile.mkstemp(".c", funcname, text=True)
        f = os.fdopen(fd, "w")
        try:
            for incl in includes:
                f.write("""#include "%s"\n""" % incl)
            f.write("""\
main (int argc, char **argv) {
    %s();
}
""" % funcname)
        finally:
            f.close()
        try:
            objects = self.compile([fname], include_dirs=include_dirs)
        except CompileError:
            return False

        try:
            self.link_executable(objects, "a.out",
                                 libraries=libraries,
                                 library_dirs=library_dirs)
        except (LinkError, TypeError):
            return False
        return True

    def find_library_file (self, dirs, lib, debug=0):
        """Search the specified list of directories for a static or shared
        library file 'lib' and return the full path to that file.  If
        'debug' true, look for a debugging version (if that makes sense on
        the current platform).  Return None if 'lib' wasn't found in any of
        the specified directories.
        """
        raise NotImplementedError

    # -- Filename generation methods -----------------------------------

    # The default implementation of the filename generating methods are
    # prejudiced towards the Unix/DOS/Windows view of the world:
    #   * object files are named by replacing the source file extension
    #     (eg. .c/.cpp -> .o/.obj)
    #   * library files (shared or static) are named by plugging the
    #     library name and extension into a format string, eg.
    #     "lib%s.%s" % (lib_name, ".a") for Unix static libraries
    #   * executables are named by appending an extension (possibly
    #     empty) to the program name: eg. progname + ".exe" for
    #     Windows
    #
    # To reduce redundant code, these methods expect to find
    # several attributes in the current object (presumably defined
    # as class attributes):
    #   * src_extensions -
    #     list of C/C++ source file extensions, eg. ['.c', '.cpp']
    #   * obj_extension -
    #     object file extension, eg. '.o' or '.obj'
    #   * static_lib_extension -
    #     extension for static library files, eg. '.a' or '.lib'
    #   * shared_lib_extension -
    #     extension for shared library/object files, eg. '.so', '.dll'
    #   * static_lib_format -
    #     format string for generating static library filenames,
    #     eg. 'lib%s.%s' or '%s.%s'
    #   * shared_lib_format
    #     format string for generating shared library filenames
    #     (probably same as static_lib_format, since the extension
    #     is one of the intended parameters to the format string)
    #   * exe_extension -
    #     extension for executable files, eg. '' or '.exe'

    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
        if output_dir is None:
            output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            base, ext = os.path.splitext(src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            if ext not in self.src_extensions:
                raise UnknownFileError, \
                      "unknown file type '%s' (from '%s')" % (ext, src_name)
            if strip_dir:
                base = os.path.basename(base)
            obj_names.append(os.path.join(output_dir,
                                          base + self.obj_extension))
        return obj_names

    def shared_object_filename(self, basename, strip_dir=0, output_dir=''):
        assert output_dir is not None
        if strip_dir:
            basename = os.path.basename (basename)
        return os.path.join(output_dir, basename + self.shared_lib_extension)

    def executable_filename(self, basename, strip_dir=0, output_dir=''):
        assert output_dir is not None
        if strip_dir:
            basename = os.path.basename (basename)
        return os.path.join(output_dir, basename + (self.exe_extension or ''))

    def library_filename(self, libname, lib_type='static',     # or 'shared'
                         strip_dir=0, output_dir=''):
        assert output_dir is not None
        if lib_type not in ("static", "shared", "dylib"):
            raise ValueError, "'lib_type' must be \"static\", \"shared\" or \"dylib\""
        fmt = getattr(self, lib_type + "_lib_format")
        ext = getattr(self, lib_type + "_lib_extension")

        dir, base = os.path.split (libname)
        filename = fmt % (base, ext)
        if strip_dir:
            dir = ''

        return os.path.join(output_dir, dir, filename)


    # -- Utility methods -----------------------------------------------

    def announce(self, msg, level=1):
        log.debug(msg)

    def debug_print(self, msg):
        from distutils.debug import DEBUG
        if DEBUG:
            print msg

    def warn(self, msg):
        sys.stderr.write("warning: %s\n" % msg)

    def execute(self, func, args, msg=None, level=1):
        execute(func, args, msg, self.dry_run)

    def spawn(self, cmd):
        spawn(cmd, dry_run=self.dry_run)

    def move_file(self, src, dst):
        return move_file(src, dst, dry_run=self.dry_run)

    def mkpath(self, name, mode=0777):
        mkpath(name, mode, dry_run=self.dry_run)


# class CCompiler


# Map a sys.platform/os.name ('posix', 'nt') to the default compiler
# type for that platform. Keys are interpreted as re match
# patterns. Order is important; platform mappings are preferred over
# OS names.
_default_compilers = (

    # Platform string mappings

    # on a cygwin built python we can use gcc like an ordinary UNIXish
    # compiler
    ('cygwin.*', 'unix'),
    ('os2emx', 'emx'),

    # OS name mappings
    ('posix', 'unix'),
    ('nt', 'msvc'),

    )

def get_default_compiler(osname=None, platform=None):
    """ Determine the default compiler to use for the given platform.

        osname should be one of the standard Python OS names (i.e. the
        ones returned by os.name) and platform the common value
        returned by sys.platform for the platform in question.

        The default values are os.name and sys.platform in case the
        parameters are not given.

    """
    if osname is None:
        osname = os.name
    if platform is None:
        platform = sys.platform
    for pattern, compiler in _default_compilers:
        if re.match(pattern, platform) is not None or \
           re.match(pattern, osname) is not None:
            return compiler
    # Default to Unix compiler
    return 'unix'

# Map compiler types to (module_name, class_name) pairs -- ie. where to
# find the code that implements an interface to this compiler.  (The module
# is assumed to be in the 'distutils' package.)
compiler_class = { 'unix':    ('unixccompiler', 'UnixCCompiler',
                               "standard UNIX-style compiler"),
                   'msvc':    ('msvccompiler', 'MSVCCompiler',
                               "Microsoft Visual C++"),
                   'cygwin':  ('cygwinccompiler', 'CygwinCCompiler',
                               "Cygwin port of GNU C Compiler for Win32"),
                   'mingw32': ('cygwinccompiler', 'Mingw32CCompiler',
                               "Mingw32 port of GNU C Compiler for Win32"),
                   'bcpp':    ('bcppcompiler', 'BCPPCompiler',
                               "Borland C++ Compiler"),
                   'emx':     ('emxccompiler', 'EMXCCompiler',
                               "EMX port of GNU C Compiler for OS/2"),
                 }

def show_compilers():
    """Print list of available compilers (used by the "--help-compiler"
    options to "build", "build_ext", "build_clib").
    """
    # XXX this "knows" that the compiler option it's describing is
    # "--compiler", which just happens to be the case for the three
    # commands that use it.
    from distutils.fancy_getopt import FancyGetopt
    compilers = []
    for compiler in compiler_class.keys():
        compilers.append(("compiler="+compiler, None,
                          compiler_class[compiler][2]))
    compilers.sort()
    pretty_printer = FancyGetopt(compilers)
    pretty_printer.print_help("List of available compilers:")


def new_compiler(plat=None, compiler=None, verbose=0, dry_run=0, force=0):
    """Generate an instance of some CCompiler subclass for the supplied
    platform/compiler combination.  'plat' defaults to 'os.name'
    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler
    for that platform.  Currently only 'posix' and 'nt' are supported, and
    the default compilers are "traditional Unix interface" (UnixCCompiler
    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly
    possible to ask for a Unix compiler object under Windows, and a
    Microsoft compiler object under Unix -- if you supply a value for
    'compiler', 'plat' is ignored.
    """
    if plat is None:
        plat = os.name

    try:
        if compiler is None:
            compiler = get_default_compiler(plat)

        (module_name, class_name, long_description) = compiler_class[compiler]
    except KeyError:
        msg = "don't know how to compile C/C++ code on platform '%s'" % plat
        if compiler is not None:
            msg = msg + " with '%s' compiler" % compiler
        raise DistutilsPlatformError, msg

    try:
        module_name = "distutils." + module_name
        __import__ (module_name)
        module = sys.modules[module_name]
        klass = vars(module)[class_name]
    except ImportError:
        raise DistutilsModuleError, \
              "can't compile C/C++ code: unable to load module '%s'" % \
              module_name
    except KeyError:
        raise DistutilsModuleError, \
              ("can't compile C/C++ code: unable to find class '%s' " +
               "in module '%s'") % (class_name, module_name)

    # XXX The None is necessary to preserve backwards compatibility
    # with classes that expect verbose to be the first positional
    # argument.
    return klass(None, dry_run, force)


def gen_preprocess_options(macros, include_dirs):
    """Generate C pre-processor options (-D, -U, -I) as used by at least
    two types of compilers: the typical Unix compiler and Visual C++.
    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)
    means undefine (-U) macro 'name', and (name,value) means define (-D)
    macro 'name' to 'value'.  'include_dirs' is just a list of directory
    names to be added to the header file search path (-I).  Returns a list
    of command-line options suitable for either Unix compilers or Visual
    C++.
    """
    # XXX it would be nice (mainly aesthetic, and so we don't generate
    # stupid-looking command lines) to go over 'macros' and eliminate
    # redundant definitions/undefinitions (ie. ensure that only the
    # latest mention of a particular macro winds up on the command
    # line).  I don't think it's essential, though, since most (all?)
    # Unix C compilers only pay attention to the latest -D or -U
    # mention of a macro on their command line.  Similar situation for
    # 'include_dirs'.  I'm punting on both for now.  Anyways, weeding out
    # redundancies like this should probably be the province of
    # CCompiler, since the data structures used are inherited from it
    # and therefore common to all CCompiler classes.

    pp_opts = []
    for macro in macros:

        if not (isinstance(macro, tuple) and
                1 <= len (macro) <= 2):
            raise TypeError, \
                  ("bad macro definition '%s': " +
                   "each element of 'macros' list must be a 1- or 2-tuple") % \
                  macro

        if len (macro) == 1:        # undefine this macro
            pp_opts.append ("-U%s" % macro[0])
        elif len (macro) == 2:
            if macro[1] is None:    # define with no explicit value
                pp_opts.append ("-D%s" % macro[0])
            else:
                # XXX *don't* need to be clever about quoting the
                # macro value here, because we're going to avoid the
                # shell at all costs when we spawn the command!
                pp_opts.append ("-D%s=%s" % macro)

    for dir in include_dirs:
        pp_opts.append ("-I%s" % dir)

    return pp_opts


def gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries):
    """Generate linker options for searching library directories and
    linking with specific libraries.

    'libraries' and 'library_dirs' are, respectively, lists of library names
    (not filenames!) and search directories.  Returns a list of command-line
    options suitable for use with some compiler (depending on the two format
    strings passed in).
    """
    lib_opts = []

    for dir in library_dirs:
        lib_opts.append(compiler.library_dir_option(dir))

    for dir in runtime_library_dirs:
        opt = compiler.runtime_library_dir_option(dir)
        if isinstance(opt, list):
            lib_opts.extend(opt)
        else:
            lib_opts.append(opt)

    # XXX it's important that we *not* remove redundant library mentions!
    # sometimes you really do have to say "-lfoo -lbar -lfoo" in order to
    # resolve all symbols.  I just hope we never have to say "-lfoo obj.o
    # -lbar" to get things to work -- that's certainly a possibility, but a
    # pretty nasty way to arrange your C code.

    for lib in libraries:
        lib_dir, lib_name = os.path.split(lib)
        if lib_dir != '':
            lib_file = compiler.find_library_file([lib_dir], lib_name)
            if lib_file is not None:
                lib_opts.append(lib_file)
            else:
                compiler.warn("no library file corresponding to "
                              "'%s' found (skipping)" % lib)
        else:
            lib_opts.append(compiler.library_option(lib))

    return lib_opts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python2.7/distutils/ccompiler.pyc                                                           0100644 0000000 0000000 00000107552 13077704274 017137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s∑  d  Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z m Z m	 Z	 m
 Z
 d d l m Z d d l m Z d d l m Z d d l m Z d d	 l m Z m Z d d
 l m Z d d l m Z d f  d Ñ  É  YZ d d f d d f d d f d d f f Z e e d Ñ Z i d d d f d 6d d d f d 6d d d f d 6d d  d! f d" 6d# d$ d% f d& 6d' d( d) f d 6Z d* Ñ  Z e e d+ d+ d+ d, Ñ Z  d- Ñ  Z! d. Ñ  Z" d S(/   sà   distutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
for the Distutils compiler abstraction model.s   $Id$iˇˇˇˇN(   t   CompileErrort	   LinkErrort   UnknownFileErrort   DistutilsPlatformErrort   DistutilsModuleError(   t   spawn(   t	   move_file(   t   mkpath(   t   newer_group(   t   split_quotedt   execute(   t   log(   t   customize_compilert	   CCompilerc           B   s  e  Z d  Z dA Z dA Z dA Z dA Z dA Z dA Z	 dA Z
 dA Z i d d 6d d 6d d 6d d 6d d 6Z d d d g Z d	 d	 d	 d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z dA d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d  Ñ  Z$ d! Ñ  Z% dA dA dA dA dA d" Ñ Z& dA dA dA d	 dA dA dA d# Ñ Z' d$ Ñ  Z( dA d	 dA d% Ñ Z) d& Z* d' Z+ d( Z, dA dA dA dA dA d	 dA dA dA dA d) Ñ
 Z- dA dA dA dA dA d	 dA dA dA dA d* Ñ
 Z. dA dA dA dA dA d	 dA dA dA dA d+ Ñ
 Z/ dA dA dA dA d	 dA dA dA d, Ñ Z0 d- Ñ  Z1 d. Ñ  Z2 d/ Ñ  Z3 dA dA dA dA d0 Ñ Z4 d	 d1 Ñ Z5 d	 d2 d3 Ñ Z6 d	 d2 d4 Ñ Z7 d	 d2 d5 Ñ Z8 d6 d	 d2 d7 Ñ Z9 d8 d9 Ñ Z: d: Ñ  Z; d; Ñ  Z< dA d8 d< Ñ Z= d= Ñ  Z> d> Ñ  Z? d? d@ Ñ Z@ RS(B   sü  Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The basic idea behind a compiler abstraction class is that each
    instance can be used for all the compile/link steps in building a
    single project.  Thus, attributes common to all of those compile and
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow for
    variability in how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link basis.
    t   cs   .cs   c++s   .ccs   .cpps   .cxxt   objcs   .mi    c         C   sè   | |  _  | |  _ | |  _ d  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _	 g  |  _
 x. |  j j É  D] } |  j | |  j | É qj Wd  S(   N(   t   dry_runt   forcet   verboset   Nonet
   output_dirt   macrost   include_dirst	   librariest   library_dirst   runtime_library_dirst   objectst   executablest   keyst   set_executable(   t   selfR   R   R   t   key(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   __init__]   s    										c         K   sZ   xS | j  É  D]E } | |  j k r> t d | |  j j f Ç n  |  j | | | É q Wd S(   sã  Define the executables (and options for them) that will be run
        to perform the various stages of compilation.  The exact set of
        executables that may be specified here depends on the compiler
        class (via the 'executables' class attribute), but most will have:
          compiler      the C/C++ compiler
          linker_so     linker used to create shared objects and libraries
          linker_exe    linker used to create binary executables
          archiver      static library creator

        On platforms with a command-line (Unix, DOS/Windows), each of these
        is a string that will be split into executable name and (optional)
        list of arguments.  (Splitting the string is done similarly to how
        Unix shells operate: words are delimited by spaces, but quotes and
        backslashes can override this.  See
        'distutils.util.split_quoted()'.)
        s$   unknown executable '%s' for class %sN(   R   R   t
   ValueErrort	   __class__t   __name__R   (   R   t   argsR   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   set_executablesÅ   s    c         C   s<   t  | t É r( t |  | t | É É n t |  | | É d  S(   N(   t
   isinstancet   strt   setattrR	   (   R   R   t   value(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyR   ¢   s    c         C   s<   d } x/ |  j  D]$ } | d | k r* | S| d } q Wd  S(   Ni    i   (   R   R   (   R   t   namet   it   defn(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _find_macro®   s    c         C   sñ   xè | D]á } t  | t É os t | É d k sc t | É d k os t  | d t É sc | d d k os t  | d t É s t d | d d Ç q q Wd S(   s◊   Ensures that every element of 'definitions' is a valid macro
        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do
        nothing if all definitions are OK, raise TypeError otherwise.
        i   i   i    s   invalid macro definition '%s': s.   must be tuple (string,), (string, string), or s   (string, None)N(   R&   t   tuplet   lenR'   R   t	   TypeError(   R   t   definitionsR,   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _check_macro_definitions∞   s    #c         C   sH   |  j  | É } | d k	 r( |  j | =n  | | f } |  j j | É d S(   s_  Define a preprocessor macro for all compilations driven by this
        compiler object.  The optional parameter 'value' should be a
        string; if it is not supplied, then the macro will be defined
        without an explicit value and the exact outcome depends on the
        compiler used (XXX true? does ANSI say anything about this?)
        N(   R-   R   R   t   append(   R   R*   R)   R+   R,   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   define_macro√   s
    	c         C   sE   |  j  | É } | d k	 r( |  j | =n  | f } |  j j | É d S(   s≥  Undefine a preprocessor macro for all compilations driven by
        this compiler object.  If the same macro is defined by
        'define_macro()' and undefined by 'undefine_macro()' the last call
        takes precedence (including multiple redefinitions or
        undefinitions).  If the macro is redefined/undefined on a
        per-compilation basis (ie. in the call to 'compile()'), then that
        takes precedence.
        N(   R-   R   R   R3   (   R   R*   R+   t   undefn(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   undefine_macro”   s
    	c         C   s   |  j  j | É d S(   sÛ   Add 'dir' to the list of directories that will be searched for
        header files.  The compiler is instructed to search directories in
        the order in which they are supplied by successive calls to
        'add_include_dir()'.
        N(   R   R3   (   R   t   dir(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   add_include_dirÂ   s    c         C   s   | |  _  d S(   sy  Set the list of directories that will be searched to 'dirs' (a
        list of strings).  Overrides any preceding calls to
        'add_include_dir()'; subsequence calls to 'add_include_dir()' add
        to the list passed to 'set_include_dirs()'.  This does not affect
        any list of standard include directories that the compiler may
        search by default.
        N(   R   (   R   t   dirs(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   set_include_dirsÌ   s    c         C   s   |  j  j | É d S(   sø  Add 'libname' to the list of libraries that will be included in
        all links driven by this compiler object.  Note that 'libname'
        should *not* be the name of a file containing a library, but the
        name of the library itself: the actual filename will be inferred by
        the linker, the compiler, or the compiler class (depending on the
        platform).

        The linker will be instructed to link against libraries in the
        order they were supplied to 'add_library()' and/or
        'set_libraries()'.  It is perfectly valid to duplicate library
        names; the linker will be instructed to link against libraries as
        many times as they are mentioned.
        N(   R   R3   (   R   t   libname(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   add_library˜   s    c         C   s   | |  _  d S(   sÙ   Set the list of libraries to be included in all links driven by
        this compiler object to 'libnames' (a list of strings).  This does
        not affect any standard system libraries that the linker may
        include by default.
        N(   R   (   R   t   libnames(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   set_libraries  s    c         C   s   |  j  j | É d S(   s'  Add 'dir' to the list of directories that will be searched for
        libraries specified to 'add_library()' and 'set_libraries()'.  The
        linker will be instructed to search for libraries in the order they
        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
        N(   R   R3   (   R   R7   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   add_library_dir  s    c         C   s   | |  _  d S(   s¿   Set the list of library search directories to 'dirs' (a list of
        strings).  This does not affect any standard library search path
        that the linker may search by default.
        N(   R   (   R   R9   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   set_library_dirs  s    c         C   s   |  j  j | É d S(   sl   Add 'dir' to the list of directories that will be searched for
        shared libraries at runtime.
        N(   R   R3   (   R   R7   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   add_runtime_library_dir  s    c         C   s   | |  _  d S(   s„   Set the list of directories to search for shared libraries at
        runtime to 'dirs' (a list of strings).  This does not affect any
        standard search path that the runtime linker may search by
        default.
        N(   R   (   R   R9   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   set_runtime_library_dirs%  s    c         C   s   |  j  j | É d S(   s„   Add 'object' to the list of object files (or analogues, such as
        explicitly named library files or the output of "resource
        compilers") to be included in every link driven by this compiler
        object.
        N(   R   R3   (   R   t   object(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   add_link_object-  s    c         C   s   | |  _  d S(   sÍ   Set the list of object files (or analogues) to be included in
        every link to 'objects'.  This does not affect any standard object
        files that the linker may include by default (such as system
        libraries).
        N(   R   (   R   R   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   set_link_objects5  s    c         C   s±  | d k r |  j } n t | t É s3 t d Ç n  | d k rK |  j } n. t | t É rp | |  j pi g  } n	 t d Ç | d k rë |  j } n: t | t t f É r¬ t | É |  j pª g  } n	 t d Ç | d k r‡ g  } n  |  j	 | d d d | É} t
 | É t
 | É k st Ç t | | É } i  }	 xm t t
 | É É D]Y }
 | |
 } | |
 } t j j | É d } |  j t j j | É É | | f |	 | <qAW| | | | |	 f S(	   s;   Process arguments and decide which source files to compile.s%   'output_dir' must be a string or Nones/   'macros' (if supplied) must be a list of tupless6   'include_dirs' (if supplied) must be a list of stringst	   strip_diri    R   i   N(   R   R   R&   R'   R0   R   t   listR   R.   t   object_filenamesR/   t   AssertionErrort   gen_preprocess_optionst   ranget   ost   patht   splitextR   t   dirname(   R   t   outdirR   t   incdirst   sourcest   dependst   extraR   t   pp_optst   buildR+   t   srct   objt   ext(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _setup_compileC  s<    			

c         C   s:   | d g } | r# d g | d *n  | r6 | | d *n  | S(   Ns   -cs   -gi    (    (   R   RU   t   debugt   beforet   cc_args(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _get_cc_argso  s    c         C   sÿ   | d k r |  j } n t | t É s3 t d Ç n  | d k rK |  j } n. t | t É rp | |  j pi g  } n	 t d Ç | d k rë |  j } n: t | t t f É r¬ t | É |  j pª g  } n	 t d Ç | | | f S(   s'  Typecheck and fix-up some of the arguments to the 'compile()'
        method, and return fixed-up values.  Specifically: if 'output_dir'
        is None, replaces it with 'self.output_dir'; ensures that 'macros'
        is a list, and augments it with 'self.macros'; ensures that
        'include_dirs' is a list, and augments it with 'self.include_dirs'.
        Guarantees that the returned values are of the correct type,
        i.e. for 'output_dir' either string or None, and for 'macros' and
        'include_dirs' either list or None.
        s%   'output_dir' must be a string or Nones/   'macros' (if supplied) must be a list of tupless6   'include_dirs' (if supplied) must be a list of stringsN(	   R   R   R&   R'   R0   R   RG   R   R.   (   R   R   R   R   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _fix_compile_argsx  s     
	c         C   sj   t  | t t f É s! t d Ç n  t | É } | d k rE |  j } n t  | t É s` t d Ç n  | | f S(   s˚   Typecheck and fix up some arguments supplied to various methods.
        Specifically: ensure that 'objects' is a list; if output_dir is
        None, replace with self.output_dir.  Return fixed versions of
        'objects' and 'output_dir'.
        s,   'objects' must be a list or tuple of stringss%   'output_dir' must be a string or NoneN(   R&   RG   R.   R0   R   R   R'   (   R   R   R   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _fix_object_argsò  s    	c         C   s  | d k r |  j } n: t | t t f É rI t | É |  j pB g  } n	 t d Ç | d k rj |  j } n: t | t t f É rõ t | É |  j pî g  } n	 t d Ç | d k rº |  j } n> t | t t f É rÌ t | É |  j pÊ g  } n t d d Ç | | | f S(   s;  Typecheck and fix up some of the arguments supplied to the
        'link_*' methods.  Specifically: ensure that all arguments are
        lists, and augment them with their permanent versions
        (eg. 'self.libraries' augments 'libraries').  Return a tuple with
        fixed versions of all arguments.
        s3   'libraries' (if supplied) must be a list of stringss6   'library_dirs' (if supplied) must be a list of stringss%   'runtime_library_dirs' (if supplied) s   must be a list of stringsN(   R   R   R&   RG   R.   R0   R   R   (   R   R   R   R   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   _fix_lib_args™  s*    	c         C   sE   |  j  r d S|  j r. t | | d d É} n t | | É } | Sd S(   sj   Return true if we need to relink the files listed in 'objects'
        to recreate 'output_file'.
        i   t   missingt   newerN(   R   R   R   (   R   R   t   output_fileRc   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt
   _need_linkÕ  s    		c   	      C   s¥   t  | t É s | g } n  d } t |  j É } x} | D]u } t j j | É \ } } |  j j	 | É } y1 |  j j
 | É } | | k  ró | } | } n  Wq7 t k
 r´ q7 Xq7 W| S(   s|   Detect the language of a given file, or list of files. Uses
        language_map, and language_order to do the job.
        N(   R&   RG   R   R/   t   language_orderRL   RM   RN   t   language_mapt   gett   indexR!   (	   R   RR   t   langRi   t   sourcet   baseRY   t   extlangt   extindex(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   detect_language⁄  s    c         C   s   d S(   s’  Preprocess a single C/C++ source file, named in 'source'.
        Output will be written to file named 'output_file', or stdout if
        'output_file' not supplied.  'macros' is a list of macro
        definitions as for 'compile()', which will augment the macros set
        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
        list of directory names that will be added to the default list.

        Raises PreprocessError on failure.
        N(    (   R   Rk   Rd   R   R   t   extra_preargst   extra_postargs(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt
   preprocessÒ  s    c	         C   sû   |  j  | | | | | | É \ } }	 } }
 } |  j |
 | | É } xU |	 D]M } y | | \ } } Wn t k
 ry qI n X|  j | | | | | |
 É qI W|	 S(   sK	  Compile one or more source files.

        'sources' must be a list of filenames, most likely C/C++
        files, but in reality anything that can be handled by a
        particular compiler and compiler class (eg. MSVCCompiler can
        handle resource files in 'sources').  Return a list of object
        filenames, one per source filename in 'sources'.  Depending on
        the implementation, not all source files will necessarily be
        compiled, but all corresponding object filenames will be
        returned.

        If 'output_dir' is given, object files will be put under it, while
        retaining their original path component.  That is, "foo/bar.c"
        normally compiles to "foo/bar.o" (for a Unix implementation); if
        'output_dir' is "build", then it would compile to
        "build/foo/bar.o".

        'macros', if given, must be a list of macro definitions.  A macro
        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
        The former defines a macro; if the value is None, the macro is
        defined without an explicit value.  The 1-tuple case undefines a
        macro.  Later definitions/redefinitions/ undefinitions take
        precedence.

        'include_dirs', if given, must be a list of strings, the
        directories to add to the default include file search path for this
        compilation only.

        'debug' is a boolean; if true, the compiler will be instructed to
        output debug symbols in (or alongside) the object file(s).

        'extra_preargs' and 'extra_postargs' are implementation- dependent.
        On platforms that have the notion of a command-line (e.g. Unix,
        DOS/Windows), they are most likely lists of strings: extra
        command-line arguments to prepand/append to the compiler command
        line.  On other platforms, consult the implementation class
        documentation.  In any event, they are intended as an escape hatch
        for those occasions when the abstract compiler framework doesn't
        cut the mustard.

        'depends', if given, is a list of filenames that all targets
        depend on.  If a source file is older than any file in
        depends, then the source file will be recompiled.  This
        supports dependency tracking, but only at a coarse
        granularity.

        Raises CompileError on failure.
        (   RZ   R^   t   KeyErrort   _compile(   R   RR   R   R   R   R[   Rp   Rq   RS   R   RU   RV   R]   RX   RW   RY   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   compile˛  s    7 c         C   s   d S(   s   Compile 'src' to product 'obj'.N(    (   R   RX   RW   RY   R]   Rq   RU   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyRt   C  s    c         C   s   d S(   s&  Link a bunch of stuff together to create a static library file.
        The "bunch of stuff" consists of the list of object files supplied
        as 'objects', the extra object files supplied to
        'add_link_object()' and/or 'set_link_objects()', the libraries
        supplied to 'add_library()' and/or 'set_libraries()', and the
        libraries supplied as 'libraries' (if any).

        'output_libname' should be a library name, not a filename; the
        filename will be inferred from the library name.  'output_dir' is
        the directory where the library file will be put.

        'debug' is a boolean; if true, debugging information will be
        included in the library (note that on most platforms, it is the
        compile step where this matters: the 'debug' flag is included here
        just for consistency).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LibError on failure.
        N(    (   R   R   t   output_libnameR   R[   t   target_lang(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   create_static_libJ  s    t   shared_objectt   shared_libraryt
   executablec         C   s
   t  Ç d S(   su  Link a bunch of stuff together to create an executable or
        shared library file.

        The "bunch of stuff" consists of the list of object files supplied
        as 'objects'.  'output_filename' should be a filename.  If
        'output_dir' is supplied, 'output_filename' is relative to it
        (i.e. 'output_filename' can provide directory components if
        needed).

        'libraries' is a list of libraries to link against.  These are
        library names, not filenames, since they're translated into
        filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
        on Unix and "foo.lib" on DOS/Windows).  However, they can include a
        directory component, which means the linker will look in that
        specific directory rather than searching all the normal locations.

        'library_dirs', if supplied, should be a list of directories to
        search for libraries that were specified as bare library names
        (ie. no directory component).  These are on top of the system
        default and those supplied to 'add_library_dir()' and/or
        'set_library_dirs()'.  'runtime_library_dirs' is a list of
        directories that will be embedded into the shared library and used
        to search for other shared libraries that *it* depends on at
        run-time.  (This may only be relevant on Unix.)

        'export_symbols' is a list of symbols that the shared library will
        export.  (This appears to be relevant only on Windows.)

        'debug' is as for 'compile()' and 'create_static_lib()', with the
        slight distinction that it actually matters on most platforms (as
        opposed to 'create_static_lib()', which includes a 'debug' flag
        mostly for form's sake).

        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
        of course that they supply command-line arguments for the
        particular linker being used).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LinkError on failure.
        N(   t   NotImplementedError(   R   t   target_descR   t   output_filenameR   R   R   R   t   export_symbolsR[   Rp   Rq   t
   build_tempRw   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   linki  s    /c         C   sG   |  j  t j | |  j | d d É| | | | | | |	 |
 | | É d  S(   Nt   lib_typet   shared(   RÅ   R   t   SHARED_LIBRARYt   library_filename(   R   R   Rv   R   R   R   R   R   R[   Rp   Rq   RÄ   Rw   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   link_shared_libù  s    	c         C   s8   |  j  t j | | | | | | | | |	 |
 | | É d  S(   N(   RÅ   R   t   SHARED_OBJECT(   R   R   R~   R   R   R   R   R   R[   Rp   Rq   RÄ   Rw   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   link_shared_object™  s
    	c         C   sA   |  j  t j | |  j | É | | | | d  | | |	 d  |
 É d  S(   N(   RÅ   R   t
   EXECUTABLEt   executable_filenameR   (   R   R   t   output_prognameR   R   R   R   R[   Rp   Rq   Rw   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   link_executableµ  s    c         C   s
   t  Ç d S(   sk   Return the compiler option to add 'dir' to the list of
        directories searched for libraries.
        N(   R|   (   R   R7   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   library_dir_optionƒ  s    c         C   s
   t  Ç d S(   ss   Return the compiler option to add 'dir' to the list of
        directories searched for runtime libraries.
        N(   R|   (   R   R7   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   runtime_library_dir_option   s    c         C   s
   t  Ç d S(   s   Return the compiler option to add 'dir' to the list of libraries
        linked into the shared library or executable.
        N(   R|   (   R   t   lib(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   library_option–  s    c         C   sE  d d l  } | d k r! g  } n  | d k r6 g  } n  | d k rK g  } n  | d k r` g  } n  | j d | d t É\ } } t j | d É }	 z7 x | D] }
 |	 j d |
 É qö W|	 j d | É Wd |	 j É  Xy |  j | g d | É} Wn t	 k
 rt
 SXy  |  j | d	 d
 | d | ÉWn t t f k
 r@t
 SXt S(   s∑   Return a boolean indicating whether funcname is supported on
        the current platform.  The optional arguments can be used to
        augment the compilation environment.
        iˇˇˇˇNs   .ct   textt   ws   #include "%s"
s+   main (int argc, char **argv) {
    %s();
}
R   s   a.outR   R   (   t   tempfileR   t   mkstempt   TrueRL   t   fdopent   writet   closeRu   R    t   FalseRå   R   R0   (   R   t   funcnamet   includesR   R   R   Rì   t   fdt   fnamet   ft   inclR   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   has_function÷  s8    
				c         C   s
   t  Ç d S(   sH  Search the specified list of directories for a static or shared
        library file 'lib' and return the full path to that file.  If
        'debug' true, look for a debugging version (if that makes sense on
        the current platform).  Return None if 'lib' wasn't found in any of
        the specified directories.
        N(   R|   (   R   R9   Rè   R[   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   find_library_file  s    t    c         C   s◊   | d  k r d } n  g  } xµ | D]≠ } t j j | É \ } } t j j | É d } | t j j | É } | |  j k rë t d | | f Ç n  | r¨ t j j | É } n  | j	 t j j
 | | |  j É É q" W| S(   NR¢   i   s"   unknown file type '%s' (from '%s')(   R   RL   RM   RN   t
   splitdrivet   isabst   src_extensionsR   t   basenameR3   t   joint   obj_extension(   R   t   source_filenamesRF   R   t	   obj_namest   src_nameRl   RY   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyRH   -  s    	c         C   sG   | d  k	 s t Ç | r- t j j | É } n  t j j | | |  j É S(   N(   R   RI   RL   RM   R¶   Rß   t   shared_lib_extension(   R   R¶   RF   R   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   shared_object_filename>  s    c         C   sM   | d  k	 s t Ç | r- t j j | É } n  t j j | | |  j pH d É S(   NR¢   (   R   RI   RL   RM   R¶   Rß   t   exe_extension(   R   R¶   RF   R   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyRä   D  s    t   staticc   
      C   sù   | d  k	 s t Ç | d k r* t d Ç n  t |  | d É } t |  | d É } t j j | É \ } } | | | f }	 | rá d } n  t j j | | |	 É S(	   NRØ   RÉ   t   dylibs0   'lib_type' must be "static", "shared" or "dylib"t   _lib_formatt   _lib_extensionR¢   (   RØ   s   sharedR∞   (   R   RI   R!   t   getattrRL   RM   t   splitRß   (
   R   R;   RÇ   RF   R   t   fmtRY   R7   Rl   t   filename(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyRÖ   J  s    	i   c         C   s   t  j | É d  S(   N(   R   R[   (   R   t   msgt   level(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   announce\  s    c         C   s"   d d l  m } | r | GHn  d  S(   Niˇˇˇˇ(   t   DEBUG(   t   distutils.debugR∫   (   R   R∑   R∫   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   debug_print_  s    c         C   s   t  j j d | É d  S(   Ns   warning: %s
(   t   syst   stderrRó   (   R   R∑   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   warnd  s    c         C   s   t  | | | |  j É d  S(   N(   R
   R   (   R   t   funcR$   R∑   R∏   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyR
   g  s    c         C   s   t  | d |  j Éd  S(   NR   (   R   R   (   R   t   cmd(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyR   j  s    c         C   s   t  | | d |  j ÉS(   NR   (   R   R   (   R   RW   t   dst(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyR   m  s    iˇ  c         C   s   t  | | d |  j Éd  S(   NR   (   R   R   (   R   R*   t   mode(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyR   p  s    N(A   R#   t
   __module__t   __doc__R   t   compiler_typeR•   R®   t   static_lib_extensionR¨   t   static_lib_formatt   shared_lib_formatRÆ   Rg   Rf   R    R%   R   R-   R2   R4   R6   R8   R:   R<   R>   R?   R@   RA   RB   RD   RE   RZ   R^   R_   R`   Ra   Re   Ro   Rr   Ru   Rt   Rx   Rá   RÑ   Râ   RÅ   RÜ   Rà   Rå   Rç   Ré   Rê   R†   R°   RH   R≠   Rä   RÖ   Rπ   Rº   Rø   R
   R   R   R   (    (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyR      s¨   


$	!						
										,			 		#			C			1							++				s   cygwin.*t   unixt   os2emxt   emxt   posixt   ntt   msvcc         C   s   |  d k r t j }  n  | d k r0 t j } n  xH t D]@ \ } } t j | | É d k	 ss t j | |  É d k	 r7 | Sq7 Wd S(   sr   Determine the default compiler to use for the given platform.

        osname should be one of the standard Python OS names (i.e. the
        ones returned by os.name) and platform the common value
        returned by sys.platform for the platform in question.

        The default values are os.name and sys.platform in case the
        parameters are not given.

    R    N(   R   RL   R*   RΩ   t   platformt   _default_compilerst   ret   match(   t   osnameR–   t   patternt   compiler(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   get_default_compilerä  s    t   unixccompilert   UnixCCompilers   standard UNIX-style compilert   msvccompilert   MSVCCompilers   Microsoft Visual C++t   cygwinccompilert   CygwinCCompilers'   Cygwin port of GNU C Compiler for Win32t   cygwint   Mingw32CCompilers(   Mingw32 port of GNU C Compiler for Win32t   mingw32t   bcppcompilert   BCPPCompilers   Borland C++ Compilert   bcppt   emxccompilert   EMXCCompilers#   EMX port of GNU C Compiler for OS/2c          C   sv   d d l  m }  g  } x6 t j É  D]( } | j d | d t | d f É q# W| j É  |  | É } | j d É d S(   sy   Print list of available compilers (used by the "--help-compiler"
    options to "build", "build_ext", "build_clib").
    iˇˇˇˇ(   t   FancyGetopts	   compiler=i   s   List of available compilers:N(   t   distutils.fancy_getoptRÊ   t   compiler_classR   R3   R   t   sortt
   print_help(   RÊ   t	   compilersR÷   t   pretty_printer(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   show_compilers±  s    
i    c         C   s  |  d k r t j }  n  y2 | d k r6 t |  É } n  t | \ } } } WnA t k
 rç d |  } | d k	 rÅ | d | } n  t | Ç n Xy5 d | } t | É t j	 | }	 t
 |	 É | }
 WnE t k
 r„ t d | Ç n( t k
 r
t d d | | f Ç n X|
 d | | É S(   s[  Generate an instance of some CCompiler subclass for the supplied
    platform/compiler combination.  'plat' defaults to 'os.name'
    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler
    for that platform.  Currently only 'posix' and 'nt' are supported, and
    the default compilers are "traditional Unix interface" (UnixCCompiler
    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly
    possible to ask for a Unix compiler object under Windows, and a
    Microsoft compiler object under Unix -- if you supply a value for
    'compiler', 'plat' is ignored.
    s5   don't know how to compile C/C++ code on platform '%s's    with '%s' compilers
   distutils.s4   can't compile C/C++ code: unable to load module '%s's4   can't compile C/C++ code: unable to find class '%s' s   in module '%s'N(   R   RL   R*   R◊   RË   Rs   R   t
   __import__RΩ   t   modulest   varst   ImportErrorR   (   t   platR÷   R   R   R   t   module_namet
   class_namet   long_descriptionR∑   t   modulet   klass(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   new_compiler¬  s2    



c         C   s˙   g  } xÀ |  D]√ } t  | t É oA d t | É k o? d k n sX t d d | Ç n  t | É d k rÇ | j d | d É q t | É d k r | d d
 k rº | j d | d É q– | j d | É q q Wx | D] } | j d	 | É q€ W| S(   s  Generate C pre-processor options (-D, -U, -I) as used by at least
    two types of compilers: the typical Unix compiler and Visual C++.
    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)
    means undefine (-U) macro 'name', and (name,value) means define (-D)
    macro 'name' to 'value'.  'include_dirs' is just a list of directory
    names to be added to the header file search path (-I).  Returns a list
    of command-line options suitable for either Unix compilers or Visual
    C++.
    i   i   s   bad macro definition '%s': s5   each element of 'macros' list must be a 1- or 2-tuples   -U%si    s   -D%ss   -D%s=%ss   -I%sN(   R&   R.   R/   R0   R3   R   (   R   R   RU   t   macroR7   (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyRJ   Ô  s"    "
c         C   s  g  } x$ | D] } | j  |  j | É É q WxI | D]A } |  j | É } t | t É rh | j | É q4 | j  | É q4 Wxç | D]Ö } t j j | É \ } }	 | d k rÔ |  j	 | g |	 É }
 |
 d k	 r€ | j  |
 É q|  j d | É qÄ | j  |  j | É É qÄ W| S(   sg  Generate linker options for searching library directories and
    linking with specific libraries.

    'libraries' and 'library_dirs' are, respectively, lists of library names
    (not filenames!) and search directories.  Returns a list of command-line
    options suitable for use with some compiler (depending on the two format
    strings passed in).
    R¢   s6   no library file corresponding to '%s' found (skipping)N(   R3   Rç   Ré   R&   RG   t   extendRL   RM   R¥   R°   R   Rø   Rê   (   R÷   R   R   R   t   lib_optsR7   t   optRè   t   lib_dirt   lib_namet   lib_file(    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   gen_lib_options   s$    		(#   R≈   t   __revision__RΩ   RL   R“   t   distutils.errorsR    R   R   R   R   t   distutils.spawnR   t   distutils.file_utilR   t   distutils.dir_utilR   t   distutils.dep_utilR   t   distutils.utilR	   R
   t	   distutilsR   t   distutils.sysconfigR   R   R—   R   R◊   RË   RÌ   R¯   RJ   R   (    (    (    s)   /usr/lib/python2.7/distutils/ccompiler.pyt   <module>   sJ   (ˇ ˇ ˇ m				




	-	1                                                                                                                                                      usr/lib/python2.7/distutils/cmd.py                                                                  0100644 0000000 0000000 00000045506 12734733743 015564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.cmd

Provides the Command class, the base class for the command classes
in the distutils.command package.
"""

__revision__ = "$Id$"

import sys, os, re
from distutils.errors import DistutilsOptionError
from distutils import util, dir_util, file_util, archive_util, dep_util
from distutils import log

class Command:
    """Abstract base class for defining command classes, the "worker bees"
    of the Distutils.  A useful analogy for command classes is to think of
    them as subroutines with local variables called "options".  The options
    are "declared" in 'initialize_options()' and "defined" (given their
    final values, aka "finalized") in 'finalize_options()', both of which
    must be defined by every command class.  The distinction between the
    two is necessary because option values might come from the outside
    world (command line, config file, ...), and any options dependent on
    other options must be computed *after* these outside influences have
    been processed -- hence 'finalize_options()'.  The "body" of the
    subroutine, where it does all its work based on the values of its
    options, is the 'run()' method, which must also be implemented by every
    command class.
    """

    # 'sub_commands' formalizes the notion of a "family" of commands,
    # eg. "install" as the parent with sub-commands "install_lib",
    # "install_headers", etc.  The parent of a family of commands
    # defines 'sub_commands' as a class attribute; it's a list of
    #    (command_name : string, predicate : unbound_method | string | None)
    # tuples, where 'predicate' is a method of the parent command that
    # determines whether the corresponding command is applicable in the
    # current situation.  (Eg. we "install_headers" is only applicable if
    # we have any C header files to install.)  If 'predicate' is None,
    # that command is always applicable.
    #
    # 'sub_commands' is usually defined at the *end* of a class, because
    # predicates can be unbound methods, so they must already have been
    # defined.  The canonical example is the "install" command.
    sub_commands = []


    # -- Creation/initialization methods -------------------------------

    def __init__(self, dist):
        """Create and initialize a new Command object.  Most importantly,
        invokes the 'initialize_options()' method, which is the real
        initializer and depends on the actual command being
        instantiated.
        """
        # late import because of mutual dependence between these classes
        from distutils.dist import Distribution

        if not isinstance(dist, Distribution):
            raise TypeError, "dist must be a Distribution instance"
        if self.__class__ is Command:
            raise RuntimeError, "Command is an abstract class"

        self.distribution = dist
        self.initialize_options()

        # Per-command versions of the global flags, so that the user can
        # customize Distutils' behaviour command-by-command and let some
        # commands fall back on the Distribution's behaviour.  None means
        # "not defined, check self.distribution's copy", while 0 or 1 mean
        # false and true (duh).  Note that this means figuring out the real
        # value of each flag is a touch complicated -- hence "self._dry_run"
        # will be handled by __getattr__, below.
        # XXX This needs to be fixed.
        self._dry_run = None

        # verbose is largely ignored, but needs to be set for
        # backwards compatibility (I think)?
        self.verbose = dist.verbose

        # Some commands define a 'self.force' option to ignore file
        # timestamps, but methods defined *here* assume that
        # 'self.force' exists for all commands.  So define it here
        # just to be safe.
        self.force = None

        # The 'help' flag is just used for command-line parsing, so
        # none of that complicated bureaucracy is needed.
        self.help = 0

        # 'finalized' records whether or not 'finalize_options()' has been
        # called.  'finalize_options()' itself should not pay attention to
        # this flag: it is the business of 'ensure_finalized()', which
        # always calls 'finalize_options()', to respect/update it.
        self.finalized = 0

    # XXX A more explicit way to customize dry_run would be better.
    def __getattr__(self, attr):
        if attr == 'dry_run':
            myval = getattr(self, "_" + attr)
            if myval is None:
                return getattr(self.distribution, attr)
            else:
                return myval
        else:
            raise AttributeError, attr

    def ensure_finalized(self):
        if not self.finalized:
            self.finalize_options()
        self.finalized = 1

    # Subclasses must define:
    #   initialize_options()
    #     provide default values for all options; may be customized by
    #     setup script, by options from config file(s), or by command-line
    #     options
    #   finalize_options()
    #     decide on the final values for all options; this is called
    #     after all possible intervention from the outside world
    #     (command-line, option file, etc.) has been processed
    #   run()
    #     run the command: do whatever it is we're here to do,
    #     controlled by the command's various option values

    def initialize_options(self):
        """Set default values for all the options that this command
        supports.  Note that these defaults may be overridden by other
        commands, by the setup script, by config files, or by the
        command-line.  Thus, this is not the place to code dependencies
        between options; generally, 'initialize_options()' implementations
        are just a bunch of "self.foo = None" assignments.

        This method must be implemented by all command classes.
        """
        raise RuntimeError, \
              "abstract method -- subclass %s must override" % self.__class__

    def finalize_options(self):
        """Set final values for all the options that this command supports.
        This is always called as late as possible, ie.  after any option
        assignments from the command-line or from other commands have been
        done.  Thus, this is the place to code option dependencies: if
        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
        long as 'foo' still has the same value it was assigned in
        'initialize_options()'.

        This method must be implemented by all command classes.
        """
        raise RuntimeError, \
              "abstract method -- subclass %s must override" % self.__class__


    def dump_options(self, header=None, indent=""):
        from distutils.fancy_getopt import longopt_xlate
        if header is None:
            header = "command options for '%s':" % self.get_command_name()
        self.announce(indent + header, level=log.INFO)
        indent = indent + "  "
        for (option, _, _) in self.user_options:
            option = option.translate(longopt_xlate)
            if option[-1] == "=":
                option = option[:-1]
            value = getattr(self, option)
            self.announce(indent + "%s = %s" % (option, value),
                          level=log.INFO)

    def run(self):
        """A command's raison d'etre: carry out the action it exists to
        perform, controlled by the options initialized in
        'initialize_options()', customized by other commands, the setup
        script, the command-line, and config files, and finalized in
        'finalize_options()'.  All terminal output and filesystem
        interaction should be done by 'run()'.

        This method must be implemented by all command classes.
        """
        raise RuntimeError, \
              "abstract method -- subclass %s must override" % self.__class__

    def announce(self, msg, level=1):
        """If the current verbosity level is of greater than or equal to
        'level' print 'msg' to stdout.
        """
        log.log(level, msg)

    def debug_print(self, msg):
        """Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        """
        from distutils.debug import DEBUG
        if DEBUG:
            print msg
            sys.stdout.flush()


    # -- Option validation methods -------------------------------------
    # (these are very handy in writing the 'finalize_options()' method)
    #
    # NB. the general philosophy here is to ensure that a particular option
    # value meets certain type and value constraints.  If not, we try to
    # force it into conformance (eg. if we expect a list but have a string,
    # split the string on comma and/or whitespace).  If we can't force the
    # option into conformance, raise DistutilsOptionError.  Thus, command
    # classes need do nothing more than (eg.)
    #   self.ensure_string_list('foo')
    # and they can be guaranteed that thereafter, self.foo will be
    # a list of strings.

    def _ensure_stringlike(self, option, what, default=None):
        val = getattr(self, option)
        if val is None:
            setattr(self, option, default)
            return default
        elif not isinstance(val, str):
            raise DistutilsOptionError, \
                  "'%s' must be a %s (got `%s`)" % (option, what, val)
        return val

    def ensure_string(self, option, default=None):
        """Ensure that 'option' is a string; if not defined, set it to
        'default'.
        """
        self._ensure_stringlike(option, "string", default)

    def ensure_string_list(self, option):
        """Ensure that 'option' is a list of strings.  If 'option' is
        currently a string, we split it either on /,\s*/ or /\s+/, so
        "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
        ["foo", "bar", "baz"].
        """
        val = getattr(self, option)
        if val is None:
            return
        elif isinstance(val, str):
            setattr(self, option, re.split(r',\s*|\s+', val))
        else:
            if isinstance(val, list):
                # checks if all elements are str
                ok = 1
                for element in val:
                    if not isinstance(element, str):
                        ok = 0
                        break
            else:
                ok = 0

            if not ok:
                raise DistutilsOptionError, \
                    "'%s' must be a list of strings (got %r)" % \
                        (option, val)


    def _ensure_tested_string(self, option, tester,
                              what, error_fmt, default=None):
        val = self._ensure_stringlike(option, what, default)
        if val is not None and not tester(val):
            raise DistutilsOptionError, \
                  ("error in '%s' option: " + error_fmt) % (option, val)

    def ensure_filename(self, option):
        """Ensure that 'option' is the name of an existing file."""
        self._ensure_tested_string(option, os.path.isfile,
                                   "filename",
                                   "'%s' does not exist or is not a file")

    def ensure_dirname(self, option):
        self._ensure_tested_string(option, os.path.isdir,
                                   "directory name",
                                   "'%s' does not exist or is not a directory")


    # -- Convenience methods for commands ------------------------------

    def get_command_name(self):
        if hasattr(self, 'command_name'):
            return self.command_name
        else:
            return self.__class__.__name__

    def set_undefined_options(self, src_cmd, *option_pairs):
        """Set the values of any "undefined" options from corresponding
        option values in some other command object.  "Undefined" here means
        "is None", which is the convention used to indicate that an option
        has not been changed between 'initialize_options()' and
        'finalize_options()'.  Usually called from 'finalize_options()' for
        options that depend on some other command rather than another
        option of the same command.  'src_cmd' is the other command from
        which option values will be taken (a command object will be created
        for it if necessary); the remaining arguments are
        '(src_option,dst_option)' tuples which mean "take the value of
        'src_option' in the 'src_cmd' command object, and copy it to
        'dst_option' in the current command object".
        """

        # Option_pairs: list of (src_option, dst_option) tuples

        src_cmd_obj = self.distribution.get_command_obj(src_cmd)
        src_cmd_obj.ensure_finalized()
        for (src_option, dst_option) in option_pairs:
            if getattr(self, dst_option) is None:
                setattr(self, dst_option,
                        getattr(src_cmd_obj, src_option))


    def get_finalized_command(self, command, create=1):
        """Wrapper around Distribution's 'get_command_obj()' method: find
        (create if necessary and 'create' is true) the command object for
        'command', call its 'ensure_finalized()' method, and return the
        finalized command object.
        """
        cmd_obj = self.distribution.get_command_obj(command, create)
        cmd_obj.ensure_finalized()
        return cmd_obj

    # XXX rename to 'get_reinitialized_command()'? (should do the
    # same in dist.py, if so)
    def reinitialize_command(self, command, reinit_subcommands=0):
        return self.distribution.reinitialize_command(
            command, reinit_subcommands)

    def run_command(self, command):
        """Run some other command: uses the 'run_command()' method of
        Distribution, which creates and finalizes the command object if
        necessary and then invokes its 'run()' method.
        """
        self.distribution.run_command(command)

    def get_sub_commands(self):
        """Determine the sub-commands that are relevant in the current
        distribution (ie., that need to be run).  This is based on the
        'sub_commands' class attribute: each tuple in that list may include
        a method that we call to determine if the subcommand needs to be
        run for the current distribution.  Return a list of command names.
        """
        commands = []
        for (cmd_name, method) in self.sub_commands:
            if method is None or method(self):
                commands.append(cmd_name)
        return commands


    # -- External world manipulation -----------------------------------

    def warn(self, msg):
        log.warn("warning: %s: %s\n" %
                (self.get_command_name(), msg))

    def execute(self, func, args, msg=None, level=1):
        util.execute(func, args, msg, dry_run=self.dry_run)

    def mkpath(self, name, mode=0777):
        dir_util.mkpath(name, mode, dry_run=self.dry_run)

    def copy_file(self, infile, outfile,
                   preserve_mode=1, preserve_times=1, link=None, level=1):
        """Copy a file respecting verbose, dry-run and force flags.  (The
        former two default to whatever is in the Distribution object, and
        the latter defaults to false for commands that don't define it.)"""

        return file_util.copy_file(
            infile, outfile,
            preserve_mode, preserve_times,
            not self.force,
            link,
            dry_run=self.dry_run)

    def copy_tree(self, infile, outfile,
                   preserve_mode=1, preserve_times=1, preserve_symlinks=0,
                   level=1):
        """Copy an entire directory tree respecting verbose, dry-run,
        and force flags.
        """
        return dir_util.copy_tree(
            infile, outfile,
            preserve_mode,preserve_times,preserve_symlinks,
            not self.force,
            dry_run=self.dry_run)

    def move_file (self, src, dst, level=1):
        """Move a file respecting dry-run flag."""
        return file_util.move_file(src, dst, dry_run = self.dry_run)

    def spawn (self, cmd, search_path=1, level=1):
        """Spawn an external command respecting dry-run flag."""
        from distutils.spawn import spawn
        spawn(cmd, search_path, dry_run= self.dry_run)

    def make_archive(self, base_name, format, root_dir=None, base_dir=None,
                     owner=None, group=None):
        return archive_util.make_archive(base_name, format, root_dir,
                                         base_dir, dry_run=self.dry_run,
                                         owner=owner, group=group)

    def make_file(self, infiles, outfile, func, args,
                  exec_msg=None, skip_msg=None, level=1):
        """Special case of 'execute()' for operations that process one or
        more input files and generate one output file.  Works just like
        'execute()', except the operation is skipped and a different
        message printed if 'outfile' already exists and is newer than all
        files listed in 'infiles'.  If the command defined 'self.force',
        and it is true, then the command is unconditionally run -- does no
        timestamp checks.
        """
        if skip_msg is None:
            skip_msg = "skipping %s (inputs unchanged)" % outfile

        # Allow 'infiles' to be a single string
        if isinstance(infiles, str):
            infiles = (infiles,)
        elif not isinstance(infiles, (list, tuple)):
            raise TypeError, \
                  "'infiles' must be a string, or a list or tuple of strings"

        if exec_msg is None:
            exec_msg = "generating %s from %s" % \
                       (outfile, ', '.join(infiles))

        # If 'outfile' must be regenerated (either because it doesn't
        # exist, is out-of-date, or the 'force' flag is true) then
        # perform the action that presumably regenerates it
        if self.force or dep_util.newer_group(infiles, outfile):
            self.execute(func, args, exec_msg, level)

        # Otherwise, print the "skip" message
        else:
            log.debug(skip_msg)

# XXX 'install_misc' class not currently used -- it was the base class for
# both 'install_scripts' and 'install_data', but they outgrew it.  It might
# still be useful for 'install_headers', though, so I'm keeping it around
# for the time being.

class install_misc(Command):
    """Common base class for installing some files in a subdirectory.
    Currently used by install_data and install_scripts.
    """

    user_options = [('install-dir=', 'd', "directory to install the files to")]

    def initialize_options (self):
        self.install_dir = None
        self.outfiles = []

    def _install_dir_from(self, dirname):
        self.set_undefined_options('install', (dirname, 'install_dir'))

    def _copy_files(self, filelist):
        self.outfiles = []
        if not filelist:
            return
        self.mkpath(self.install_dir)
        for f in filelist:
            self.copy_file(f, self.install_dir)
            self.outfiles.append(os.path.join(self.install_dir, f))

    def get_outputs(self):
        return self.outfiles
                                                                                                                                                                                          usr/lib/python2.7/distutils/cmd.pyc                                                                 0100644 0000000 0000000 00000040532 13077704274 015717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s•   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z m	 Z	 m
 Z
 m Z m Z d d l m Z d f  d Ñ  É  YZ d	 e f d
 Ñ  É  YZ d S(   st   distutils.cmd

Provides the Command class, the base class for the command classes
in the distutils.command package.
s   $Id$iˇˇˇˇN(   t   DistutilsOptionError(   t   utilt   dir_utilt	   file_utilt   archive_utilt   dep_util(   t   logt   Commandc           B   sy  e  Z d  Z g  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d# d d Ñ Z
 d Ñ  Z d	 d
 Ñ Z d Ñ  Z d# d Ñ Z d# d Ñ Z d Ñ  Z d# d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d# d	 d Ñ Z d d Ñ Z d	 d	 d# d	 d Ñ Z d	 d	 d d	 d Ñ Z d	 d Ñ Z d	 d	 d  Ñ Z  d# d# d# d# d! Ñ Z! d# d# d	 d" Ñ Z" RS($   s}  Abstract base class for defining command classes, the "worker bees"
    of the Distutils.  A useful analogy for command classes is to think of
    them as subroutines with local variables called "options".  The options
    are "declared" in 'initialize_options()' and "defined" (given their
    final values, aka "finalized") in 'finalize_options()', both of which
    must be defined by every command class.  The distinction between the
    two is necessary because option values might come from the outside
    world (command line, config file, ...), and any options dependent on
    other options must be computed *after* these outside influences have
    been processed -- hence 'finalize_options()'.  The "body" of the
    subroutine, where it does all its work based on the values of its
    options, is the 'run()' method, which must also be implemented by every
    command class.
    c         C   sç   d d l  m } t | | É s+ t d Ç n  |  j t k rF t d Ç n  | |  _ |  j É  d |  _
 | j |  _ d |  _ d |  _ d |  _ d S(   sﬁ   Create and initialize a new Command object.  Most importantly,
        invokes the 'initialize_options()' method, which is the real
        initializer and depends on the actual command being
        instantiated.
        iˇˇˇˇ(   t   Distributions$   dist must be a Distribution instances   Command is an abstract classi    N(   t   distutils.distR   t
   isinstancet	   TypeErrort	   __class__R   t   RuntimeErrort   distributiont   initialize_optionst   Nonet   _dry_runt   verboset   forcet   helpt	   finalized(   t   selft   distR   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   __init__1   s    	

			c         C   sO   | d k rB t  |  d | É } | d  k r; t  |  j | É S| Sn	 t | Ç d  S(   Nt   dry_runt   _(   t   getattrR   R   t   AttributeError(   R   t   attrt   myval(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   __getattr__a   s    c         C   s#   |  j  s |  j É  n  d |  _  d  S(   Ni   (   R   t   finalize_options(   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   ensure_finalizedk   s    	c         C   s   t  d |  j Ç d S(   sŸ  Set default values for all the options that this command
        supports.  Note that these defaults may be overridden by other
        commands, by the setup script, by config files, or by the
        command-line.  Thus, this is not the place to code dependencies
        between options; generally, 'initialize_options()' implementations
        are just a bunch of "self.foo = None" assignments.

        This method must be implemented by all command classes.
        s,   abstract method -- subclass %s must overrideN(   R   R   (   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyR   }   s    
c         C   s   t  d |  j Ç d S(   s  Set final values for all the options that this command supports.
        This is always called as late as possible, ie.  after any option
        assignments from the command-line or from other commands have been
        done.  Thus, this is the place to code option dependencies: if
        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
        long as 'foo' still has the same value it was assigned in
        'initialize_options()'.

        This method must be implemented by all command classes.
        s,   abstract method -- subclass %s must overrideN(   R   R   (   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyR    ä   s    t    c         C   s”   d d l  m } | d  k r/ d |  j É  } n  |  j | | d t j É| d } xy |  j D]n \ } } } | j | É } | d d k rò | d  } n  t	 |  | É } |  j | d | | f d t j Éq] Wd  S(   Niˇˇˇˇ(   t   longopt_xlates   command options for '%s':t   levels     t   =s   %s = %s(
   t   distutils.fancy_getoptR#   R   t   get_command_namet   announceR   t   INFOt   user_optionst	   translateR   (   R   t   headert   indentR#   t   optionR   t   value(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   dump_optionsô   s    
c         C   s   t  d |  j Ç d S(   sæ  A command's raison d'etre: carry out the action it exists to
        perform, controlled by the options initialized in
        'initialize_options()', customized by other commands, the setup
        script, the command-line, and config files, and finalized in
        'finalize_options()'.  All terminal output and filesystem
        interaction should be done by 'run()'.

        This method must be implemented by all command classes.
        s,   abstract method -- subclass %s must overrideN(   R   R   (   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   runß   s    
i   c         C   s   t  j  | | É d S(   sm   If the current verbosity level is of greater than or equal to
        'level' print 'msg' to stdout.
        N(   R   (   R   t   msgR$   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyR(   ¥   s    c         C   s/   d d l  m } | r+ | GHt j j É  n  d S(   s~   Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        iˇˇˇˇ(   t   DEBUGN(   t   distutils.debugR3   t   syst   stdoutt   flush(   R   R2   R3   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   debug_print∫   s    c         C   s[   t  |  | É } | d  k r/ t |  | | É | St | t É sW t d | | | f Ç n  | S(   Ns   '%s' must be a %s (got `%s`)(   R   R   t   setattrR
   t   strR    (   R   R.   t   whatt   defaultt   val(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   _ensure_stringlike—   s    c         C   s   |  j  | d | É d S(   sW   Ensure that 'option' is a string; if not defined, set it to
        'default'.
        t   stringN(   R>   (   R   R.   R<   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   ensure_string€   s    c         C   sµ   t  |  | É } | d k r d St | t É rM t |  | t j d | É É nd t | t É rè d } x0 | D] } t | t É si d } Pqi qi Wn d } | s± t d | | f Ç n  d S(   sÓ   Ensure that 'option' is a list of strings.  If 'option' is
        currently a string, we split it either on /,\s*/ or /\s+/, so
        "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
        ["foo", "bar", "baz"].
        Ns   ,\s*|\s+i   i    s'   '%s' must be a list of strings (got %r)(	   R   R   R
   R:   R9   t   ret   splitt   listR    (   R   R.   R=   t   okt   element(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   ensure_string_list·   s     c         C   sL   |  j  | | | É } | d  k	 rH | | É rH t d | | | f Ç n  d  S(   Ns   error in '%s' option: (   R>   R   R    (   R   R.   t   testerR;   t	   error_fmtR<   R=   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   _ensure_tested_string˝   s    c         C   s    |  j  | t j j d d É d S(   s5   Ensure that 'option' is the name of an existing file.t   filenames$   '%s' does not exist or is not a fileN(   RI   t   ost   patht   isfile(   R   R.   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   ensure_filename  s    c         C   s    |  j  | t j j d d É d  S(   Ns   directory names)   '%s' does not exist or is not a directory(   RI   RK   RL   t   isdir(   R   R.   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   ensure_dirname
  s    c         C   s$   t  |  d É r |  j S|  j j Sd  S(   Nt   command_name(   t   hasattrRQ   R   t   __name__(   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyR'     s    c         G   sh   |  j  j | É } | j É  xE | D]= \ } } t |  | É d k r# t |  | t | | É É q# q# Wd S(   s>  Set the values of any "undefined" options from corresponding
        option values in some other command object.  "Undefined" here means
        "is None", which is the convention used to indicate that an option
        has not been changed between 'initialize_options()' and
        'finalize_options()'.  Usually called from 'finalize_options()' for
        options that depend on some other command rather than another
        option of the same command.  'src_cmd' is the other command from
        which option values will be taken (a command object will be created
        for it if necessary); the remaining arguments are
        '(src_option,dst_option)' tuples which mean "take the value of
        'src_option' in the 'src_cmd' command object, and copy it to
        'dst_option' in the current command object".
        N(   R   t   get_command_objR!   R   R   R9   (   R   t   src_cmdt   option_pairst   src_cmd_objt
   src_optiont
   dst_option(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   set_undefined_options  s    
	c         C   s#   |  j  j | | É } | j É  | S(   s˚   Wrapper around Distribution's 'get_command_obj()' method: find
        (create if necessary and 'create' is true) the command object for
        'command', call its 'ensure_finalized()' method, and return the
        finalized command object.
        (   R   RT   R!   (   R   t   commandt   createt   cmd_obj(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   get_finalized_command1  s    
i    c         C   s   |  j  j | | É S(   N(   R   t   reinitialize_command(   R   R[   t   reinit_subcommands(    (    s#   /usr/lib/python2.7/distutils/cmd.pyR_   =  s    	c         C   s   |  j  j | É d S(   s¬   Run some other command: uses the 'run_command()' method of
        Distribution, which creates and finalizes the command object if
        necessary and then invokes its 'run()' method.
        N(   R   t   run_command(   R   R[   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRa   A  s    c         C   sL   g  } x? |  j  D]4 \ } } | d k s4 | |  É r | j | É q q W| S(   sk  Determine the sub-commands that are relevant in the current
        distribution (ie., that need to be run).  This is based on the
        'sub_commands' class attribute: each tuple in that list may include
        a method that we call to determine if the subcommand needs to be
        run for the current distribution.  Return a list of command names.
        N(   t   sub_commandsR   t   append(   R   t   commandst   cmd_namet   method(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   get_sub_commandsH  s
    c         C   s!   t  j d |  j É  | f É d  S(   Ns   warning: %s: %s
(   R   t   warnR'   (   R   R2   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRh   X  s    	c         C   s    t  j | | | d |  j Éd  S(   NR   (   R   t   executeR   (   R   t   funct   argsR2   R$   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRi   \  s    iˇ  c         C   s   t  j | | d |  j Éd  S(   NR   (   R   t   mkpathR   (   R   t   namet   mode(    (    s#   /usr/lib/python2.7/distutils/cmd.pyRl   _  s    c      	   C   s)   t  j | | | | |  j | d |  j ÉS(   s—   Copy a file respecting verbose, dry-run and force flags.  (The
        former two default to whatever is in the Distribution object, and
        the latter defaults to false for commands that don't define it.)R   (   R   t	   copy_fileR   R   (   R   t   infilet   outfilet   preserve_modet   preserve_timest   linkR$   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRo   b  s    c      	   C   s)   t  j | | | | | |  j d |  j ÉS(   s\   Copy an entire directory tree respecting verbose, dry-run,
        and force flags.
        R   (   R   t	   copy_treeR   R   (   R   Rp   Rq   Rr   Rs   t   preserve_symlinksR$   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRu   o  s
    	
c         C   s   t  j | | d |  j ÉS(   s$   Move a file respecting dry-run flag.R   (   R   t	   move_fileR   (   R   t   srct   dstR$   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRw   {  s    c         C   s*   d d l  m } | | | d |  j Éd S(   s2   Spawn an external command respecting dry-run flag.iˇˇˇˇ(   t   spawnR   N(   t   distutils.spawnRz   R   (   R   t   cmdt   search_pathR$   Rz   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRz     s    c         C   s+   t  j | | | | d |  j d | d | ÉS(   NR   t   ownert   group(   R   t   make_archiveR   (   R   t	   base_namet   formatt   root_dirt   base_dirR~   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRÄ   Ñ  s    c         C   s¬   | d k r d | } n  t | t É r4 | f } n! t | t t f É sU t d Ç n  | d k r} d | d j | É f } n  |  j sò t j	 | | É r± |  j
 | | | | É n t j | É d S(   sÃ  Special case of 'execute()' for operations that process one or
        more input files and generate one output file.  Works just like
        'execute()', except the operation is skipped and a different
        message printed if 'outfile' already exists and is newer than all
        files listed in 'infiles'.  If the command defined 'self.force',
        and it is true, then the command is unconditionally run -- does no
        timestamp checks.
        s   skipping %s (inputs unchanged)s9   'infiles' must be a string, or a list or tuple of stringss   generating %s from %ss   , N(   R   R
   R:   RC   t   tupleR   t   joinR   R   t   newer_groupRi   R   t   debug(   R   t   infilesRq   Rj   Rk   t   exec_msgt   skip_msgR$   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt	   make_fileä  s    
	N(#   RS   t
   __module__t   __doc__Rb   R   R   R!   R   R    R   R0   R1   R(   R8   R>   R@   RF   RI   RN   RP   R'   RZ   R^   R_   Ra   Rg   Rh   Ri   Rl   Ro   Ru   Rw   Rz   RÄ   Rå   (    (    (    s#   /usr/lib/python2.7/distutils/cmd.pyR      sD   	0	
					
									
t   install_miscc           B   s;   e  Z d  Z d g Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(	   s{   Common base class for installing some files in a subdirectory.
    Currently used by install_data and install_scripts.
    s   install-dir=t   ds!   directory to install the files toc         C   s   d  |  _ g  |  _ d  S(   N(   R   t   install_dirt   outfiles(   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyR   ∏  s    	c         C   s   |  j  d | d f É d  S(   Nt   installRë   (   RZ   (   R   t   dirname(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   _install_dir_fromº  s    c         C   sm   g  |  _  | s d  S|  j |  j É xC | D]; } |  j | |  j É |  j  j t j j |  j | É É q* Wd  S(   N(   Rí   Rl   Rë   Ro   Rc   RK   RL   RÜ   (   R   t   filelistt   f(    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   _copy_filesø  s    	c         C   s   |  j  S(   N(   Rí   (   R   (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   get_outputs»  s    (   s   install-dir=Rê   s!   directory to install the files to(   RS   Rç   Ré   R*   R   Rï   Rò   Rô   (    (    (    s#   /usr/lib/python2.7/distutils/cmd.pyRè   ±  s   					(   Ré   t   __revision__R5   RK   RA   t   distutils.errorsR    t	   distutilsR   R   R   R   R   R   R   Rè   (    (    (    s#   /usr/lib/python2.7/distutils/cmd.pyt   <module>   s   $(ˇ §                                                                                                                                                                      usr/lib/python2.7/distutils/command/                                                                0040755 0000000 0000000 00000000000 13077704274 016054  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python2.7/distutils/command/__init__.py                                                     0100644 0000000 0000000 00000001466 12734733743 020173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command

Package containing implementation of all the standard Distutils
commands."""

__revision__ = "$Id$"

__all__ = ['build',
           'build_py',
           'build_ext',
           'build_clib',
           'build_scripts',
           'clean',
           'install',
           'install_lib',
           'install_headers',
           'install_scripts',
           'install_data',
           'sdist',
           'register',
           'bdist',
           'bdist_dumb',
           'bdist_rpm',
           'bdist_wininst',
           'upload',
           'check',
           # These two are reserved for future use:
           #'bdist_sdux',
           #'bdist_pkgtool',
           # Note:
           # bdist_packager is not included because it only provides
           # an abstract base class
          ]
                                                                                                                                                                                                          usr/lib/python2.7/distutils/command/__init__.pyc                                                    0100644 0000000 0000000 00000001227 13077704274 020327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sO   d  Z  d Z d d d d d d d d	 d
 d d d d d d d d d d g Z d S(   s\   distutils.command

Package containing implementation of all the standard Distutils
commands.s   $Id$t   buildt   build_pyt	   build_extt
   build_clibt   build_scriptst   cleant   installt   install_libt   install_headerst   install_scriptst   install_datat   sdistt   registert   bdistt
   bdist_dumbt	   bdist_rpmt   bdist_wininstt   uploadt   checkN(   t   __doc__t   __revision__t   __all__(    (    (    s0   /usr/lib/python2.7/distutils/command/__init__.pyt   <module>   s(                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/distutils/command/bdist.py                                                        0100644 0000000 0000000 00000012734 12734733743 017541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution)."""

__revision__ = "$Id$"

import os

from distutils.util import get_platform
from distutils.core import Command
from distutils.errors import DistutilsPlatformError, DistutilsOptionError


def show_formats():
    """Print list of available formats (arguments to "--format" option).
    """
    from distutils.fancy_getopt import FancyGetopt
    formats = []
    for format in bdist.format_commands:
        formats.append(("formats=" + format, None,
                        bdist.format_command[format][1]))
    pretty_printer = FancyGetopt(formats)
    pretty_printer.print_help("List of available distribution formats:")


class bdist(Command):

    description = "create a built (binary) distribution"

    user_options = [('bdist-base=', 'b',
                     "temporary directory for creating built distributions"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('formats=', None,
                     "formats for distribution (comma-separated list)"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in "
                     "[default: dist]"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user]"),
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group]"),
                   ]

    boolean_options = ['skip-build']

    help_options = [
        ('help-formats', None,
         "lists available distribution formats", show_formats),
        ]

    # The following commands do not take a format option from bdist
    no_format_option = ('bdist_rpm',)

    # This won't do in reality: will need to distinguish RPM-ish Linux,
    # Debian-ish Linux, Solaris, FreeBSD, ..., Windows, Mac OS.
    default_format = {'posix': 'gztar',
                      'nt': 'zip',
                      'os2': 'zip'}

    # Establish the preferred order (for the --help-formats option).
    format_commands = ['rpm', 'gztar', 'bztar', 'ztar', 'tar',
                       'wininst', 'zip', 'msi']

    # And the real information.
    format_command = {'rpm':   ('bdist_rpm',  "RPM distribution"),
                      'gztar': ('bdist_dumb', "gzip'ed tar file"),
                      'bztar': ('bdist_dumb', "bzip2'ed tar file"),
                      'ztar':  ('bdist_dumb', "compressed tar file"),
                      'tar':   ('bdist_dumb', "tar file"),
                      'wininst': ('bdist_wininst',
                                  "Windows executable installer"),
                      'zip':   ('bdist_dumb', "ZIP file"),
                      'msi':   ('bdist_msi',  "Microsoft Installer")
                      }


    def initialize_options(self):
        self.bdist_base = None
        self.plat_name = None
        self.formats = None
        self.dist_dir = None
        self.skip_build = 0
        self.group = None
        self.owner = None

    def finalize_options(self):
        # have to finalize 'plat_name' before 'bdist_base'
        if self.plat_name is None:
            if self.skip_build:
                self.plat_name = get_platform()
            else:
                self.plat_name = self.get_finalized_command('build').plat_name

        # 'bdist_base' -- parent of per-built-distribution-format
        # temporary directories (eg. we'll probably have
        # "build/bdist.<plat>/dumb", "build/bdist.<plat>/rpm", etc.)
        if self.bdist_base is None:
            build_base = self.get_finalized_command('build').build_base
            self.bdist_base = os.path.join(build_base,
                                           'bdist.' + self.plat_name)

        self.ensure_string_list('formats')
        if self.formats is None:
            try:
                self.formats = [self.default_format[os.name]]
            except KeyError:
                raise DistutilsPlatformError, \
                      "don't know how to create built distributions " + \
                      "on platform %s" % os.name

        if self.dist_dir is None:
            self.dist_dir = "dist"

    def run(self):
        # Figure out which sub-commands we need to run.
        commands = []
        for format in self.formats:
            try:
                commands.append(self.format_command[format][0])
            except KeyError:
                raise DistutilsOptionError, "invalid format '%s'" % format

        # Reinitialize and run each command.
        for i in range(len(self.formats)):
            cmd_name = commands[i]
            sub_cmd = self.reinitialize_command(cmd_name)
            if cmd_name not in self.no_format_option:
                sub_cmd.format = self.formats[i]

            # passing the owner and group names for tar archiving
            if cmd_name == 'bdist_dumb':
                sub_cmd.owner = self.owner
                sub_cmd.group = self.group

            # If we're going to need to run this command again, tell it to
            # keep its temporary files around so subsequent runs go faster.
            if cmd_name in commands[i+1:]:
                sub_cmd.keep_temp = 1
            self.run_command(cmd_name)
                                    usr/lib/python2.7/distutils/command/bdist.pyc                                                       0100644 0000000 0000000 00000012127 13077704274 017676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sq   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z m	 Z	 d Ñ  Z
 d e f d	 Ñ  É  YZ d S(
   si   distutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution).s   $Id$iˇˇˇˇN(   t   get_platform(   t   Command(   t   DistutilsPlatformErrort   DistutilsOptionErrorc          C   sl   d d l  m }  g  } x6 t j D]+ } | j d | d t j | d f É q  W|  | É } | j d É d S(   sF   Print list of available formats (arguments to "--format" option).
    iˇˇˇˇ(   t   FancyGetopts   formats=i   s'   List of available distribution formats:N(   t   distutils.fancy_getoptR   t   bdistt   format_commandst   appendt   Nonet   format_commandt
   print_help(   R   t   formatst   formatt   pretty_printer(    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   show_formats   s    R   c        	   B   sÔ   e  Z d  Z d0 d d d e É  f d2 d3 d4 d5 d6 g Z d g Z d d1 d e f g Z d7 Z	 i d d 6d d 6d d 6Z
 d d d d d d  d d! g Z i d8 d 6d9 d 6d: d 6d; d 6d< d 6d= d  6d> d 6d? d! 6Z d- Ñ  Z d. Ñ  Z d/ Ñ  Z RS(@   s$   create a built (binary) distributions   bdist-base=t   bs4   temporary directory for creating built distributionss
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s   formats=s/   formats for distribution (comma-separated list)s	   dist-dir=t   ds=   directory to put final built distributions in [default: dist]s
   skip-builds2   skip rebuilding everything (for testing/debugging)s   owner=t   us@   Owner name used when creating a tar file [default: current user]s   group=t   gsA   Group name used when creating a tar file [default: current group]s   help-formatss$   lists available distribution formatst	   bdist_rpmt   gztart   posixt   zipt   ntt   os2t   rpmt   bztart   ztart   tart   wininstt   msis   RPM distributiont
   bdist_dumbs   gzip'ed tar files   bzip2'ed tar files   compressed tar files   tar filet   bdist_wininsts   Windows executable installers   ZIP filet	   bdist_msis   Microsoft Installerc         C   sC   d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  S(   Ni    (   R	   t
   bdist_baset	   plat_nameR   t   dist_dirt
   skip_buildt   groupt   owner(   t   self(    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   initialize_optionsT   s    						c         C   s  |  j  d  k r? |  j r' t É  |  _  q? |  j d É j  |  _  n  |  j d  k rÇ |  j d É j } t j j	 | d |  j  É |  _ n  |  j
 d É |  j d  k r„ y |  j t j g |  _ Wq„ t k
 rﬂ t d d t j Ç q„ Xn  |  j d  k r˛ d |  _ n  d  S(   Nt   builds   bdist.R   s-   don't know how to create built distributions s   on platform %st   dist(   R%   R	   R'   R    t   get_finalized_commandR$   t
   build_baset   ost   patht   joint   ensure_string_listR   t   default_formatt   namet   KeyErrorR   R&   (   R*   R/   (    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   finalize_options]   s$    	c         C   s
  g  } xN |  j  D]C } y | j |  j | d É Wq t k
 rR t d | Ç q Xq Wx¨ t t |  j  É É D]ï } | | } |  j | É } | |  j k rÆ |  j  | | _	 n  | d k r’ |  j
 | _
 |  j | _ n  | | | d k rı d | _ n  |  j | É qm Wd  S(   Ni    s   invalid format '%s'R!   i   (   R   R   R
   R6   R   t   ranget   lent   reinitialize_commandt   no_format_optionR   R)   R(   t	   keep_tempt   run_command(   R*   t   commandsR   t   it   cmd_namet   sub_cmd(    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   runy   s"    
(   s   bdist-base=R   s4   temporary directory for creating built distributionsN(   s   formats=Ns/   formats for distribution (comma-separated list)(   s	   dist-dir=R   s=   directory to put final built distributions in [default: dist](   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   owner=R   s@   Owner name used when creating a tar file [default: current user](   s   group=R   sA   Group name used when creating a tar file [default: current group](   R   (   R   s   RPM distribution(   s
   bdist_dumbs   gzip'ed tar file(   s
   bdist_dumbs   bzip2'ed tar file(   s
   bdist_dumbs   compressed tar file(   s
   bdist_dumbs   tar file(   R"   s   Windows executable installer(   s
   bdist_dumbs   ZIP file(   R#   s   Microsoft Installer(   t   __name__t
   __module__t   descriptionR    R	   t   user_optionst   boolean_optionsR   t   help_optionsR;   R4   R   R
   R+   R7   RB   (    (    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyR      sJ    
     		


 
			(   t   __doc__t   __revision__R0   t   distutils.utilR    t   distutils.coreR   t   distutils.errorsR   R   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python2.7/distutils/command/bdist_dumb.py                                                   0100644 0000000 0000000 00000012113 12734733743 020537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix)."""

__revision__ = "$Id$"

import os

from sysconfig import get_python_version

from distutils.util import get_platform
from distutils.core import Command
from distutils.dir_util import remove_tree, ensure_relative
from distutils.errors import DistutilsPlatformError
from distutils import log

class bdist_dumb (Command):

    description = 'create a "dumb" built distribution'

    user_options = [('bdist-dir=', 'd',
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('format=', 'f',
                     "archive format to create (tar, ztar, gztar, zip)"),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('relative', None,
                     "build the archive using relative paths"
                     "(default: false)"),
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user]"),
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group]"),
                   ]

    boolean_options = ['keep-temp', 'skip-build', 'relative']

    default_format = { 'posix': 'gztar',
                       'nt': 'zip',
                       'os2': 'zip' }


    def initialize_options (self):
        self.bdist_dir = None
        self.plat_name = None
        self.format = None
        self.keep_temp = 0
        self.dist_dir = None
        self.skip_build = None
        self.relative = 0
        self.owner = None
        self.group = None

    def finalize_options(self):
        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'dumb')

        if self.format is None:
            try:
                self.format = self.default_format[os.name]
            except KeyError:
                raise DistutilsPlatformError, \
                      ("don't know how to create dumb built distributions " +
                       "on platform %s") % os.name

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                   ('skip_build', 'skip_build'))

    def run(self):
        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.root = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0

        log.info("installing to %s" % self.bdist_dir)
        self.run_command('install')

        # And make an archive relative to the root of the
        # pseudo-installation tree.
        archive_basename = "%s.%s" % (self.distribution.get_fullname(),
                                      self.plat_name)

        # OS/2 objects to any ":" characters in a filename (such as when
        # a timestamp is used in a version) so change them to hyphens.
        if os.name == "os2":
            archive_basename = archive_basename.replace(":", "-")

        pseudoinstall_root = os.path.join(self.dist_dir, archive_basename)
        if not self.relative:
            archive_root = self.bdist_dir
        else:
            if (self.distribution.has_ext_modules() and
                (install.install_base != install.install_platbase)):
                raise DistutilsPlatformError, \
                      ("can't make a dumb built distribution where "
                       "base and platbase are different (%s, %s)"
                       % (repr(install.install_base),
                          repr(install.install_platbase)))
            else:
                archive_root = os.path.join(self.bdist_dir,
                                   ensure_relative(install.install_base))

        # Make the archive
        filename = self.make_archive(pseudoinstall_root,
                                     self.format, root_dir=archive_root,
                                     owner=self.owner, group=self.group)
        if self.distribution.has_ext_modules():
            pyversion = get_python_version()
        else:
            pyversion = 'any'
        self.distribution.dist_files.append(('bdist_dumb', pyversion,
                                             filename))

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)
                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/distutils/command/bdist_dumb.pyc                                                  0100644 0000000 0000000 00000011651 13077704274 020706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sò   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 m Z d d l m Z d d	 l m Z d
 e f d Ñ  É  YZ d S(   s∑   distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix).s   $Id$iˇˇˇˇN(   t   get_python_version(   t   get_platform(   t   Command(   t   remove_treet   ensure_relative(   t   DistutilsPlatformError(   t   logt
   bdist_dumbc           B   së   e  Z d  Z d" d d d e É  f d# d
 d d d f d$ d& d' d( d) g	 Z d
 d d g Z i d d 6d d 6d d 6Z d Ñ  Z d  Ñ  Z	 d! Ñ  Z
 RS(*   s"   create a "dumb" built distributions
   bdist-dir=t   ds1   temporary directory for creating the distributions
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s   format=t   fs0   archive format to create (tar, ztar, gztar, zip)s	   keep-tempt   ks/   keep the pseudo-installation tree around after s!   creating the distribution archives	   dist-dir=s-   directory to put final built distributions ins
   skip-builds2   skip rebuilding everything (for testing/debugging)t   relatives6   build the archive using relative paths(default: false)s   owner=t   us@   Owner name used when creating a tar file [default: current user]s   group=t   gsA   Group name used when creating a tar file [default: current group]t   gztart   posixt   zipt   ntt   os2c         C   sU   d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _	 d  S(   Ni    (
   t   Nonet	   bdist_dirt	   plat_namet   formatt	   keep_tempt   dist_dirt
   skip_buildR   t   ownert   group(   t   self(    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   initialize_options7   s    								c         C   sß   |  j  d  k r< |  j d É j } t j j | d É |  _  n  |  j d  k rç y |  j t j	 |  _ Wqç t
 k
 râ t d d t j	 Ç qç Xn  |  j d d d	 d
 É d  S(   Nt   bdistt   dumbs2   don't know how to create dumb built distributions s   on platform %sR   R   R   (   s   dist_dirs   dist_dir(   s	   plat_names	   plat_name(   s
   skip_builds
   skip_build(   R   R   t   get_finalized_commandt
   bdist_baset   ost   patht   joinR   t   default_formatt   namet   KeyErrorR   t   set_undefined_options(   R   R"   (    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   finalize_optionsB   s    	c      	   C   s◊  |  j  s |  j d É n  |  j d d d É} |  j | _ |  j  | _  d | _ t j d |  j É |  j d É d |  j j	 É  |  j
 f } t j d k r∞ | j d	 d
 É } n  t j j |  j | É } |  j s› |  j } nj |  j j É  r&| j | j k r&t d t | j É t | j É f Ç n! t j j |  j t | j É É } |  j | |  j d | d |  j d |  j É} |  j j É  rèt É  } n d } |  j j j d | | f É |  j s”t  |  j d |  j! Én  d  S(   Nt   buildt   installt   reinit_subcommandsi   i    s   installing to %ss   %s.%sR   t   :t   -sS   can't make a dumb built distribution where base and platbase are different (%s, %s)t   root_dirR   R   t   anyR   t   dry_run("   R   t   run_commandt   reinitialize_commandR   t   roott   warn_dirR   t   infot   distributiont   get_fullnameR   R#   R'   t   replaceR$   R%   R   R   t   has_ext_modulest   install_baset   install_platbaseR   t   reprR   t   make_archiveR   R   R   R    t
   dist_filest   appendR   R   R2   (   R   R,   t   archive_basenamet   pseudoinstall_roott   archive_roott   filenamet	   pyversion(    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   runT   sB    				
	(   s
   bdist-dir=R   s1   temporary directory for creating the distribution(   s   format=R
   s0   archive format to create (tar, ztar, gztar, zip)(   s	   dist-dir=R   s-   directory to put final built distributions inN(   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   relativeNs6   build the archive using relative paths(default: false)(   s   owner=R   s@   Owner name used when creating a tar file [default: current user](   s   group=R   sA   Group name used when creating a tar file [default: current group](   t   __name__t
   __module__t   descriptionR   R   t   user_optionst   boolean_optionsR&   R   R*   RG   (    (    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyR      s8    
      	

		(   t   __doc__t   __revision__R#   t	   sysconfigR    t   distutils.utilR   t   distutils.coreR   t   distutils.dir_utilR   R   t   distutils.errorsR   t	   distutilsR   R   (    (    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   <module>   s                                                                                          usr/lib/python2.7/distutils/command/bdist_msi.py                                                    0100644 0000000 0000000 00000104567 12734733743 020417  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: iso-8859-1 -*-
# Copyright (C) 2005, 2006 Martin von Lˆwis
# Licensed to PSF under a Contributor Agreement.
# The bdist_wininst command proper
# based on bdist_wininst
"""
Implements the bdist_msi command.
"""
import sys, os
from sysconfig import get_python_version

from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils.version import StrictVersion
from distutils.errors import DistutilsOptionError
from distutils import log
from distutils.util import get_platform

import msilib
from msilib import schema, sequence, text
from msilib import Directory, Feature, Dialog, add_data

class PyDialog(Dialog):
    """Dialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left."""
    def __init__(self, *args, **kw):
        """Dialog(database, name, x, y, w, h, attributes, title, first,
        default, cancel, bitmap=true)"""
        Dialog.__init__(self, *args)
        ruler = self.h - 36
        #if kw.get("bitmap", True):
        #    self.bitmap("Bitmap", 0, 0, bmwidth, ruler, "PythonWin")
        self.line("BottomLine", 0, ruler, self.w, 0)

    def title(self, title):
        "Set the title text of the dialog at the top."
        # name, x, y, w, h, flags=Visible|Enabled|Transparent|NoPrefix,
        # text, in VerdanaBold10
        self.text("Title", 15, 10, 320, 60, 0x30003,
                  r"{\VerdanaBold10}%s" % title)

    def back(self, title, next, name = "Back", active = 1):
        """Add a back button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 180, self.h-27 , 56, 17, flags, title, next)

    def cancel(self, title, next, name = "Cancel", active = 1):
        """Add a cancel button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 304, self.h-27, 56, 17, flags, title, next)

    def next(self, title, next, name = "Next", active = 1):
        """Add a Next button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 236, self.h-27, 56, 17, flags, title, next)

    def xbutton(self, name, title, next, xpos):
        """Add a button with a given title, the tab-next button,
        its name in the Control table, giving its x position; the
        y-position is aligned with the other buttons.

        Return the button, so that events can be associated"""
        return self.pushbutton(name, int(self.w*xpos - 28), self.h-27, 56, 17, 3, title, next)

class bdist_msi (Command):

    description = "create a Microsoft Installer (.msi) binary distribution"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    all_versions = ['2.0', '2.1', '2.2', '2.3', '2.4',
                    '2.5', '2.6', '2.7', '2.8', '2.9',
                    '3.0', '3.1', '3.2', '3.3', '3.4',
                    '3.5', '3.6', '3.7', '3.8', '3.9']
    other_version = 'X'

    def initialize_options (self):
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.no_target_compile = 0
        self.no_target_optimize = 0
        self.target_version = None
        self.dist_dir = None
        self.skip_build = None
        self.install_script = None
        self.pre_install_script = None
        self.versions = None

    def finalize_options (self):
        self.set_undefined_options('bdist', ('skip_build', 'skip_build'))

        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'msi')

        short_version = get_python_version()
        if (not self.target_version) and self.distribution.has_ext_modules():
            self.target_version = short_version

        if self.target_version:
            self.versions = [self.target_version]
            if not self.skip_build and self.distribution.has_ext_modules()\
               and self.target_version != short_version:
                raise DistutilsOptionError, \
                      "target version can only be %s, or the '--skip-build'" \
                      " option must be specified" % (short_version,)
        else:
            self.versions = list(self.all_versions)

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                   )

        if self.pre_install_script:
            raise DistutilsOptionError, "the pre-install-script feature is not yet implemented"

        if self.install_script:
            for script in self.distribution.scripts:
                if self.install_script == os.path.basename(script):
                    break
            else:
                raise DistutilsOptionError, \
                      "install_script '%s' not found in scripts" % \
                      self.install_script
        self.install_script_key = None
    # finalize_options()


    def run (self):
        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.prefix = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0

        install_lib = self.reinitialize_command('install_lib')
        # we do not want to include pyc or pyo files
        install_lib.compile = 0
        install_lib.optimize = 0

        if self.distribution.has_ext_modules():
            # If we are building an installer for a Python version other
            # than the one we are currently running, then we need to ensure
            # our build_lib reflects the other Python version rather than ours.
            # Note that for target_version!=sys.version, we must have skipped the
            # build step, so there is no issue with enforcing the build of this
            # version.
            target_version = self.target_version
            if not target_version:
                assert self.skip_build, "Should have already checked this"
                target_version = sys.version[0:3]
            plat_specifier = ".%s-%s" % (self.plat_name, target_version)
            build = self.get_finalized_command('build')
            build.build_lib = os.path.join(build.build_base,
                                           'lib' + plat_specifier)

        log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()

        # avoid warning of 'install_lib' about installing
        # into a directory not in sys.path
        sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

        install.run()

        del sys.path[0]

        self.mkpath(self.dist_dir)
        fullname = self.distribution.get_fullname()
        installer_name = self.get_installer_filename(fullname)
        installer_name = os.path.abspath(installer_name)
        if os.path.exists(installer_name): os.unlink(installer_name)

        metadata = self.distribution.metadata
        author = metadata.author
        if not author:
            author = metadata.maintainer
        if not author:
            author = "UNKNOWN"
        version = metadata.get_version()
        # ProductVersion must be strictly numeric
        # XXX need to deal with prerelease versions
        sversion = "%d.%d.%d" % StrictVersion(version).version
        # Prefix ProductName with Python x.y, so that
        # it sorts together with the other Python packages
        # in Add-Remove-Programs (APR)
        fullname = self.distribution.get_fullname()
        if self.target_version:
            product_name = "Python %s %s" % (self.target_version, fullname)
        else:
            product_name = "Python %s" % (fullname)
        self.db = msilib.init_database(installer_name, schema,
                product_name, msilib.gen_uuid(),
                sversion, author)
        msilib.add_tables(self.db, sequence)
        props = [('DistVersion', version)]
        email = metadata.author_email or metadata.maintainer_email
        if email:
            props.append(("ARPCONTACT", email))
        if metadata.url:
            props.append(("ARPURLINFOABOUT", metadata.url))
        if props:
            add_data(self.db, 'Property', props)

        self.add_find_python()
        self.add_files()
        self.add_scripts()
        self.add_ui()
        self.db.Commit()

        if hasattr(self.distribution, 'dist_files'):
            tup = 'bdist_msi', self.target_version or 'any', fullname
            self.distribution.dist_files.append(tup)

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)

    def add_files(self):
        db = self.db
        cab = msilib.CAB("distfiles")
        rootdir = os.path.abspath(self.bdist_dir)

        root = Directory(db, cab, None, rootdir, "TARGETDIR", "SourceDir")
        f = Feature(db, "Python", "Python", "Everything",
                    0, 1, directory="TARGETDIR")

        items = [(f, root, '')]
        for version in self.versions + [self.other_version]:
            target = "TARGETDIR" + version
            name = default = "Python" + version
            desc = "Everything"
            if version is self.other_version:
                title = "Python from another location"
                level = 2
            else:
                title = "Python %s from registry" % version
                level = 1
            f = Feature(db, name, title, desc, 1, level, directory=target)
            dir = Directory(db, cab, root, rootdir, target, default)
            items.append((f, dir, version))
        db.Commit()

        seen = {}
        for feature, dir, version in items:
            todo = [dir]
            while todo:
                dir = todo.pop()
                for file in os.listdir(dir.absolute):
                    afile = os.path.join(dir.absolute, file)
                    if os.path.isdir(afile):
                        short = "%s|%s" % (dir.make_short(file), file)
                        default = file + version
                        newdir = Directory(db, cab, dir, file, default, short)
                        todo.append(newdir)
                    else:
                        if not dir.component:
                            dir.start_component(dir.logical, feature, 0)
                        if afile not in seen:
                            key = seen[afile] = dir.add_file(file)
                            if file==self.install_script:
                                if self.install_script_key:
                                    raise DistutilsOptionError(
                                          "Multiple files with name %s" % file)
                                self.install_script_key = '[#%s]' % key
                        else:
                            key = seen[afile]
                            add_data(self.db, "DuplicateFile",
                                [(key + version, dir.component, key, None, dir.logical)])
            db.Commit()
        cab.commit(db)

    def add_find_python(self):
        """Adds code to the installer to compute the location of Python.

        Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
        registry for each version of Python.

        Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
        else from PYTHON.MACHINE.X.Y.

        Properties PYTHONX.Y will be set to TARGETDIRX.Y\\python.exe"""

        start = 402
        for ver in self.versions:
            install_path = r"SOFTWARE\Python\PythonCore\%s\InstallPath" % ver
            machine_reg = "python.machine." + ver
            user_reg = "python.user." + ver
            machine_prop = "PYTHON.MACHINE." + ver
            user_prop = "PYTHON.USER." + ver
            machine_action = "PythonFromMachine" + ver
            user_action = "PythonFromUser" + ver
            exe_action = "PythonExe" + ver
            target_dir_prop = "TARGETDIR" + ver
            exe_prop = "PYTHON" + ver
            if msilib.Win64:
                # type: msidbLocatorTypeRawValue + msidbLocatorType64bit
                Type = 2+16
            else:
                Type = 2
            add_data(self.db, "RegLocator",
                    [(machine_reg, 2, install_path, None, Type),
                     (user_reg, 1, install_path, None, Type)])
            add_data(self.db, "AppSearch",
                    [(machine_prop, machine_reg),
                     (user_prop, user_reg)])
            add_data(self.db, "CustomAction",
                    [(machine_action, 51+256, target_dir_prop, "[" + machine_prop + "]"),
                     (user_action, 51+256, target_dir_prop, "[" + user_prop + "]"),
                     (exe_action, 51+256, exe_prop, "[" + target_dir_prop + "]\\python.exe"),
                    ])
            add_data(self.db, "InstallExecuteSequence",
                    [(machine_action, machine_prop, start),
                     (user_action, user_prop, start + 1),
                     (exe_action, None, start + 2),
                    ])
            add_data(self.db, "InstallUISequence",
                    [(machine_action, machine_prop, start),
                     (user_action, user_prop, start + 1),
                     (exe_action, None, start + 2),
                    ])
            add_data(self.db, "Condition",
                    [("Python" + ver, 0, "NOT TARGETDIR" + ver)])
            start += 4
            assert start < 500

    def add_scripts(self):
        if self.install_script:
            start = 6800
            for ver in self.versions + [self.other_version]:
                install_action = "install_script." + ver
                exe_prop = "PYTHON" + ver
                add_data(self.db, "CustomAction",
                        [(install_action, 50, exe_prop, self.install_script_key)])
                add_data(self.db, "InstallExecuteSequence",
                        [(install_action, "&Python%s=3" % ver, start)])
                start += 1
        # XXX pre-install scripts are currently refused in finalize_options()
        #     but if this feature is completed, it will also need to add
        #     entries for each version as the above code does
        if self.pre_install_script:
            scriptfn = os.path.join(self.bdist_dir, "preinstall.bat")
            f = open(scriptfn, "w")
            # The batch file will be executed with [PYTHON], so that %1
            # is the path to the Python interpreter; %0 will be the path
            # of the batch file.
            # rem ="""
            # %1 %0
            # exit
            # """
            # <actual script>
            f.write('rem ="""\n%1 %0\nexit\n"""\n')
            f.write(open(self.pre_install_script).read())
            f.close()
            add_data(self.db, "Binary",
                [("PreInstall", msilib.Binary(scriptfn))
                ])
            add_data(self.db, "CustomAction",
                [("PreInstall", 2, "PreInstall", None)
                ])
            add_data(self.db, "InstallExecuteSequence",
                    [("PreInstall", "NOT Installed", 450)])


    def add_ui(self):
        db = self.db
        x = y = 50
        w = 370
        h = 300
        title = "[ProductName] Setup"

        # see "Dialog Style Bits"
        modal = 3      # visible | modal
        modeless = 1   # visible

        # UI customization properties
        add_data(db, "Property",
                 # See "DefaultUIFont Property"
                 [("DefaultUIFont", "DlgFont8"),
                  # See "ErrorDialog Style Bit"
                  ("ErrorDialog", "ErrorDlg"),
                  ("Progress1", "Install"),   # modified in maintenance type dlg
                  ("Progress2", "installs"),
                  ("MaintenanceForm_Action", "Repair"),
                  # possible values: ALL, JUSTME
                  ("WhichUsers", "ALL")
                 ])

        # Fonts, see "TextStyle Table"
        add_data(db, "TextStyle",
                 [("DlgFont8", "Tahoma", 9, None, 0),
                  ("DlgFontBold8", "Tahoma", 8, None, 1), #bold
                  ("VerdanaBold10", "Verdana", 10, None, 1),
                  ("VerdanaRed9", "Verdana", 9, 255, 0),
                 ])

        # UI Sequences, see "InstallUISequence Table", "Using a Sequence Table"
        # Numbers indicate sequence; see sequence.py for how these action integrate
        add_data(db, "InstallUISequence",
                 [("PrepareDlg", "Not Privileged or Windows9x or Installed", 140),
                  ("WhichUsersDlg", "Privileged and not Windows9x and not Installed", 141),
                  # In the user interface, assume all-users installation if privileged.
                  ("SelectFeaturesDlg", "Not Installed", 1230),
                  # XXX no support for resume installations yet
                  #("ResumeDlg", "Installed AND (RESUME OR Preselected)", 1240),
                  ("MaintenanceTypeDlg", "Installed AND NOT RESUME AND NOT Preselected", 1250),
                  ("ProgressDlg", None, 1280)])

        add_data(db, 'ActionText', text.ActionText)
        add_data(db, 'UIText', text.UIText)
        #####################################################################
        # Standard dialogs: FatalError, UserExit, ExitDialog
        fatal=PyDialog(db, "FatalError", x, y, w, h, modal, title,
                     "Finish", "Finish", "Finish")
        fatal.title("[ProductName] Installer ended prematurely")
        fatal.back("< Back", "Finish", active = 0)
        fatal.cancel("Cancel", "Back", active = 0)
        fatal.text("Description1", 15, 70, 320, 80, 0x30003,
                   "[ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.")
        fatal.text("Description2", 15, 155, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c=fatal.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Exit")

        user_exit=PyDialog(db, "UserExit", x, y, w, h, modal, title,
                     "Finish", "Finish", "Finish")
        user_exit.title("[ProductName] Installer was interrupted")
        user_exit.back("< Back", "Finish", active = 0)
        user_exit.cancel("Cancel", "Back", active = 0)
        user_exit.text("Description1", 15, 70, 320, 80, 0x30003,
                   "[ProductName] setup was interrupted.  Your system has not been modified.  "
                   "To install this program at a later time, please run the installation again.")
        user_exit.text("Description2", 15, 155, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c = user_exit.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Exit")

        exit_dialog = PyDialog(db, "ExitDialog", x, y, w, h, modal, title,
                             "Finish", "Finish", "Finish")
        exit_dialog.title("Completing the [ProductName] Installer")
        exit_dialog.back("< Back", "Finish", active = 0)
        exit_dialog.cancel("Cancel", "Back", active = 0)
        exit_dialog.text("Description", 15, 235, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c = exit_dialog.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Return")

        #####################################################################
        # Required dialog: FilesInUse, ErrorDlg
        inuse = PyDialog(db, "FilesInUse",
                         x, y, w, h,
                         19,                # KeepModeless|Modal|Visible
                         title,
                         "Retry", "Retry", "Retry", bitmap=False)
        inuse.text("Title", 15, 6, 200, 15, 0x30003,
                   r"{\DlgFontBold8}Files in Use")
        inuse.text("Description", 20, 23, 280, 20, 0x30003,
               "Some files that need to be updated are currently in use.")
        inuse.text("Text", 20, 55, 330, 50, 3,
                   "The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.")
        inuse.control("List", "ListBox", 20, 107, 330, 130, 7, "FileInUseProcess",
                      None, None, None)
        c=inuse.back("Exit", "Ignore", name="Exit")
        c.event("EndDialog", "Exit")
        c=inuse.next("Ignore", "Retry", name="Ignore")
        c.event("EndDialog", "Ignore")
        c=inuse.cancel("Retry", "Exit", name="Retry")
        c.event("EndDialog","Retry")

        # See "Error Dialog". See "ICE20" for the required names of the controls.
        error = Dialog(db, "ErrorDlg",
                       50, 10, 330, 101,
                       65543,       # Error|Minimize|Modal|Visible
                       title,
                       "ErrorText", None, None)
        error.text("ErrorText", 50,9,280,48,3, "")
        #error.control("ErrorIcon", "Icon", 15, 9, 24, 24, 5242881, None, "py.ico", None, None)
        error.pushbutton("N",120,72,81,21,3,"No",None).event("EndDialog","ErrorNo")
        error.pushbutton("Y",240,72,81,21,3,"Yes",None).event("EndDialog","ErrorYes")
        error.pushbutton("A",0,72,81,21,3,"Abort",None).event("EndDialog","ErrorAbort")
        error.pushbutton("C",42,72,81,21,3,"Cancel",None).event("EndDialog","ErrorCancel")
        error.pushbutton("I",81,72,81,21,3,"Ignore",None).event("EndDialog","ErrorIgnore")
        error.pushbutton("O",159,72,81,21,3,"Ok",None).event("EndDialog","ErrorOk")
        error.pushbutton("R",198,72,81,21,3,"Retry",None).event("EndDialog","ErrorRetry")

        #####################################################################
        # Global "Query Cancel" dialog
        cancel = Dialog(db, "CancelDlg", 50, 10, 260, 85, 3, title,
                        "No", "No", "No")
        cancel.text("Text", 48, 15, 194, 30, 3,
                    "Are you sure you want to cancel [ProductName] installation?")
        #cancel.control("Icon", "Icon", 15, 15, 24, 24, 5242881, None,
        #               "py.ico", None, None)
        c=cancel.pushbutton("Yes", 72, 57, 56, 17, 3, "Yes", "No")
        c.event("EndDialog", "Exit")

        c=cancel.pushbutton("No", 132, 57, 56, 17, 3, "No", "Yes")
        c.event("EndDialog", "Return")

        #####################################################################
        # Global "Wait for costing" dialog
        costing = Dialog(db, "WaitForCostingDlg", 50, 10, 260, 85, modal, title,
                         "Return", "Return", "Return")
        costing.text("Text", 48, 15, 194, 30, 3,
                     "Please wait while the installer finishes determining your disk space requirements.")
        c = costing.pushbutton("Return", 102, 57, 56, 17, 3, "Return", None)
        c.event("EndDialog", "Exit")

        #####################################################################
        # Preparation dialog: no user input except cancellation
        prep = PyDialog(db, "PrepareDlg", x, y, w, h, modeless, title,
                        "Cancel", "Cancel", "Cancel")
        prep.text("Description", 15, 70, 320, 40, 0x30003,
                  "Please wait while the Installer prepares to guide you through the installation.")
        prep.title("Welcome to the [ProductName] Installer")
        c=prep.text("ActionText", 15, 110, 320, 20, 0x30003, "Pondering...")
        c.mapping("ActionText", "Text")
        c=prep.text("ActionData", 15, 135, 320, 30, 0x30003, None)
        c.mapping("ActionData", "Text")
        prep.back("Back", None, active=0)
        prep.next("Next", None, active=0)
        c=prep.cancel("Cancel", None)
        c.event("SpawnDialog", "CancelDlg")

        #####################################################################
        # Feature (Python directory) selection
        seldlg = PyDialog(db, "SelectFeaturesDlg", x, y, w, h, modal, title,
                        "Next", "Next", "Cancel")
        seldlg.title("Select Python Installations")

        seldlg.text("Hint", 15, 30, 300, 20, 3,
                    "Select the Python locations where %s should be installed."
                    % self.distribution.get_fullname())

        seldlg.back("< Back", None, active=0)
        c = seldlg.next("Next >", "Cancel")
        order = 1
        c.event("[TARGETDIR]", "[SourceDir]", ordering=order)
        for version in self.versions + [self.other_version]:
            order += 1
            c.event("[TARGETDIR]", "[TARGETDIR%s]" % version,
                    "FEATURE_SELECTED AND &Python%s=3" % version,
                    ordering=order)
        c.event("SpawnWaitDialog", "WaitForCostingDlg", ordering=order + 1)
        c.event("EndDialog", "Return", ordering=order + 2)
        c = seldlg.cancel("Cancel", "Features")
        c.event("SpawnDialog", "CancelDlg")

        c = seldlg.control("Features", "SelectionTree", 15, 60, 300, 120, 3,
                           "FEATURE", None, "PathEdit", None)
        c.event("[FEATURE_SELECTED]", "1")
        ver = self.other_version
        install_other_cond = "FEATURE_SELECTED AND &Python%s=3" % ver
        dont_install_other_cond = "FEATURE_SELECTED AND &Python%s<>3" % ver

        c = seldlg.text("Other", 15, 200, 300, 15, 3,
                        "Provide an alternate Python location")
        c.condition("Enable", install_other_cond)
        c.condition("Show", install_other_cond)
        c.condition("Disable", dont_install_other_cond)
        c.condition("Hide", dont_install_other_cond)

        c = seldlg.control("PathEdit", "PathEdit", 15, 215, 300, 16, 1,
                           "TARGETDIR" + ver, None, "Next", None)
        c.condition("Enable", install_other_cond)
        c.condition("Show", install_other_cond)
        c.condition("Disable", dont_install_other_cond)
        c.condition("Hide", dont_install_other_cond)

        #####################################################################
        # Disk cost
        cost = PyDialog(db, "DiskCostDlg", x, y, w, h, modal, title,
                        "OK", "OK", "OK", bitmap=False)
        cost.text("Title", 15, 6, 200, 15, 0x30003,
                  "{\DlgFontBold8}Disk Space Requirements")
        cost.text("Description", 20, 20, 280, 20, 0x30003,
                  "The disk space required for the installation of the selected features.")
        cost.text("Text", 20, 53, 330, 60, 3,
                  "The highlighted volumes (if any) do not have enough disk space "
              "available for the currently selected features.  You can either "
              "remove some files from the highlighted volumes, or choose to "
              "install less features onto local drive(s), or select different "
              "destination drive(s).")
        cost.control("VolumeList", "VolumeCostList", 20, 100, 330, 150, 393223,
                     None, "{120}{70}{70}{70}{70}", None, None)
        cost.xbutton("OK", "Ok", None, 0.5).event("EndDialog", "Return")

        #####################################################################
        # WhichUsers Dialog. Only available on NT, and for privileged users.
        # This must be run before FindRelatedProducts, because that will
        # take into account whether the previous installation was per-user
        # or per-machine. We currently don't support going back to this
        # dialog after "Next" was selected; to support this, we would need to
        # find how to reset the ALLUSERS property, and how to re-run
        # FindRelatedProducts.
        # On Windows9x, the ALLUSERS property is ignored on the command line
        # and in the Property table, but installer fails according to the documentation
        # if a dialog attempts to set ALLUSERS.
        whichusers = PyDialog(db, "WhichUsersDlg", x, y, w, h, modal, title,
                            "AdminInstall", "Next", "Cancel")
        whichusers.title("Select whether to install [ProductName] for all users of this computer.")
        # A radio group with two options: allusers, justme
        g = whichusers.radiogroup("AdminInstall", 15, 60, 260, 50, 3,
                                  "WhichUsers", "", "Next")
        g.add("ALL", 0, 5, 150, 20, "Install for all users")
        g.add("JUSTME", 0, 25, 150, 20, "Install just for me")

        whichusers.back("Back", None, active=0)

        c = whichusers.next("Next >", "Cancel")
        c.event("[ALLUSERS]", "1", 'WhichUsers="ALL"', 1)
        c.event("EndDialog", "Return", ordering = 2)

        c = whichusers.cancel("Cancel", "AdminInstall")
        c.event("SpawnDialog", "CancelDlg")

        #####################################################################
        # Installation Progress dialog (modeless)
        progress = PyDialog(db, "ProgressDlg", x, y, w, h, modeless, title,
                            "Cancel", "Cancel", "Cancel", bitmap=False)
        progress.text("Title", 20, 15, 200, 15, 0x30003,
                      "{\DlgFontBold8}[Progress1] [ProductName]")
        progress.text("Text", 35, 65, 300, 30, 3,
                      "Please wait while the Installer [Progress2] [ProductName]. "
                      "This may take several minutes.")
        progress.text("StatusLabel", 35, 100, 35, 20, 3, "Status:")

        c=progress.text("ActionText", 70, 100, w-70, 20, 3, "Pondering...")
        c.mapping("ActionText", "Text")

        #c=progress.text("ActionData", 35, 140, 300, 20, 3, None)
        #c.mapping("ActionData", "Text")

        c=progress.control("ProgressBar", "ProgressBar", 35, 120, 300, 10, 65537,
                           None, "Progress done", None, None)
        c.mapping("SetProgress", "Progress")

        progress.back("< Back", "Next", active=False)
        progress.next("Next >", "Cancel", active=False)
        progress.cancel("Cancel", "Back").event("SpawnDialog", "CancelDlg")

        ###################################################################
        # Maintenance type: repair/uninstall
        maint = PyDialog(db, "MaintenanceTypeDlg", x, y, w, h, modal, title,
                         "Next", "Next", "Cancel")
        maint.title("Welcome to the [ProductName] Setup Wizard")
        maint.text("BodyText", 15, 63, 330, 42, 3,
                   "Select whether you want to repair or remove [ProductName].")
        g=maint.radiogroup("RepairRadioGroup", 15, 108, 330, 60, 3,
                            "MaintenanceForm_Action", "", "Next")
        #g.add("Change", 0, 0, 200, 17, "&Change [ProductName]")
        g.add("Repair", 0, 18, 200, 17, "&Repair [ProductName]")
        g.add("Remove", 0, 36, 200, 17, "Re&move [ProductName]")

        maint.back("< Back", None, active=False)
        c=maint.next("Finish", "Cancel")
        # Change installation: Change progress dialog to "Change", then ask
        # for feature selection
        #c.event("[Progress1]", "Change", 'MaintenanceForm_Action="Change"', 1)
        #c.event("[Progress2]", "changes", 'MaintenanceForm_Action="Change"', 2)

        # Reinstall: Change progress dialog to "Repair", then invoke reinstall
        # Also set list of reinstalled features to "ALL"
        c.event("[REINSTALL]", "ALL", 'MaintenanceForm_Action="Repair"', 5)
        c.event("[Progress1]", "Repairing", 'MaintenanceForm_Action="Repair"', 6)
        c.event("[Progress2]", "repairs", 'MaintenanceForm_Action="Repair"', 7)
        c.event("Reinstall", "ALL", 'MaintenanceForm_Action="Repair"', 8)

        # Uninstall: Change progress to "Remove", then invoke uninstall
        # Also set list of removed features to "ALL"
        c.event("[REMOVE]", "ALL", 'MaintenanceForm_Action="Remove"', 11)
        c.event("[Progress1]", "Removing", 'MaintenanceForm_Action="Remove"', 12)
        c.event("[Progress2]", "removes", 'MaintenanceForm_Action="Remove"', 13)
        c.event("Remove", "ALL", 'MaintenanceForm_Action="Remove"', 14)

        # Close dialog when maintenance action scheduled
        c.event("EndDialog", "Return", 'MaintenanceForm_Action<>"Change"', 20)
        #c.event("NewDialog", "SelectFeaturesDlg", 'MaintenanceForm_Action="Change"', 21)

        maint.cancel("Cancel", "RepairRadioGroup").event("SpawnDialog", "CancelDlg")

    def get_installer_filename(self, fullname):
        # Factored out to allow overriding in subclasses
        if self.target_version:
            base_name = "%s.%s-py%s.msi" % (fullname, self.plat_name,
                                            self.target_version)
        else:
            base_name = "%s.%s.msi" % (fullname, self.plat_name)
        installer_name = os.path.join(self.dist_dir, base_name)
        return installer_name
                                                                                                                                         usr/lib/python2.7/distutils/command/bdist_msi.pyc                                                   0100644 0000000 0000000 00000056653 13077704274 020562  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s  d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z d d	 l m Z d d l Z d d
 l m Z m Z m Z d d l m Z m Z m Z m Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   s#   
Implements the bdist_msi command.
iˇˇˇˇN(   t   get_python_version(   t   Command(   t   remove_tree(   t   StrictVersion(   t   DistutilsOptionError(   t   log(   t   get_platform(   t   schemat   sequencet   text(   t	   Directoryt   Featuret   Dialogt   add_datat   PyDialogc           B   sV   e  Z d  Z d Ñ  Z d Ñ  Z d d d Ñ Z d d d Ñ Z d d d	 Ñ Z d
 Ñ  Z RS(   sô   Dialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left.c         O   s=   t  j |  | å |  j d } |  j d d | |  j d É d S(   sb   Dialog(database, name, x, y, w, h, attributes, title, first,
        default, cancel, bitmap=true)i$   t
   BottomLinei    N(   R   t   __init__t   ht   linet   w(   t   selft   argst   kwt   ruler(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR      s    c      	   C   s'   |  j  d d d d d d d | É d S(	   s,   Set the title text of the dialog at the top.t   Titlei   i
   i@  i<   i  s   {\VerdanaBold10}%sN(   R	   (   R   t   title(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR   $   s    t   Backi   c      	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S(   sª   Add a back button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedi   i   i¥   i   i8   i   (   t
   pushbuttonR   (   R   R   t   nextt   namet   activet   flags(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   back+   s    	t   Cancelc      	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S(   sΩ   Add a cancel button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedi   i   i0  i   i8   i   (   R   R   (   R   R   R   R   R   R   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   cancel6   s    	t   Nextc      	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S(   sª   Add a Next button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedi   i   iÏ   i   i8   i   (   R   R   (   R   R   R   R   R   R   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR   A   s    	c      	   C   s:   |  j  | t |  j | d É |  j d d d d | | É S(   sÍ   Add a button with a given title, the tab-next button,
        its name in the Control table, giving its x position; the
        y-position is aligned with the other buttons.

        Return the button, so that events can be associatedi   i   i8   i   i   (   R   t   intR   R   (   R   R   R   R   t   xpos(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   xbuttonL   s    (	   t   __name__t
   __module__t   __doc__R   R   R    R"   R   R&   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR      s   			t	   bdist_msic           B   s=  e  Z d  Z d e d f d d d e É  f d d d d	 f d
 e d d f d d d f d d d f d d d f d e d f d e d f d e d f g
 Z d d d d g Z d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ g Z d0 Z d1 Ñ  Z	 d2 Ñ  Z
 d3 Ñ  Z d4 Ñ  Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z RS(9   s7   create a Microsoft Installer (.msi) binary distributions
   bdist-dir=s1   temporary directory for creating the distributions
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s	   keep-tempt   ks/   keep the pseudo-installation tree around after s!   creating the distribution archives   target-version=s!   require a specific python versions    on the target systems   no-target-compilet   cs/   do not compile .py to .pyc on the target systems   no-target-optimizet   os:   do not compile .py to .pyo (optimized)on the target systems	   dist-dir=t   ds-   directory to put final built distributions ins
   skip-builds2   skip rebuilding everything (for testing/debugging)s   install-script=sT   basename of installation script to be run afterinstallation or before deinstallations   pre-install-script=s{   Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distributions   2.0s   2.1s   2.2s   2.3s   2.4s   2.5s   2.6s   2.7s   2.8s   2.9s   3.0s   3.1s   3.2s   3.3s   3.4s   3.5s   3.6s   3.7s   3.8s   3.9t   Xc         C   sg   d  |  _ d  |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  S(   Ni    (   t   Nonet	   bdist_dirt	   plat_namet	   keep_tempt   no_target_compilet   no_target_optimizet   target_versiont   dist_dirt
   skip_buildt   install_scriptt   pre_install_scriptt   versions(   R   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   initialize_options~   s    										c         C   si  |  j  d d	 É |  j d  k rL |  j d É j } t j j | d É |  _ n  t É  } |  j	 rz |  j
 j É  rz | |  _	 n  |  j	 r– |  j	 g |  _ |  j r‚ |  j
 j É  r‚ |  j	 | k r‚ t d | f Ç q‚ n t |  j É |  _ |  j  d d
 d É |  j r
t d Ç n  |  j r\xF |  j
 j D]% } |  j t j j | É k r Pq q Wt d |  j Ç n  d  |  _ d  S(   Nt   bdistR9   t   msisM   target version can only be %s, or the '--skip-build' option must be specifiedR8   R3   s5   the pre-install-script feature is not yet implementeds(   install_script '%s' not found in scripts(   s
   skip_builds
   skip_build(   s   dist_dirs   dist_dir(   s	   plat_names	   plat_name(   t   set_undefined_optionsR2   R1   t   get_finalized_commandt
   bdist_baset   ost   patht   joinR    R7   t   distributiont   has_ext_modulesR<   R9   R   t   listt   all_versionsR;   R:   t   scriptst   basenamet   install_script_key(   R   RB   t   short_versiont   script(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   finalize_optionsã   s8    					c         C   sè  |  j  s |  j d É n  |  j d d d É} |  j | _ |  j  | _  d | _ |  j d É } d | _ d | _ |  j j	 É  r˙ |  j
 } | s∂ |  j  s£ t d É Ç t j d d !} n  d	 |  j | f } |  j d É } t j j | j d
 | É | _ n  t j d |  j É | j É  t j j d t j j |  j d É É | j É  t j d =|  j |  j É |  j j É  } |  j | É } t j j | É } t j j | É r≤t j  | É n  |  j j! } | j" }	 |	 sŸ| j# }	 n  |	 sËd }	 n  | j$ É  }
 d t% |
 É j } |  j j É  } |  j
 r5d |  j
 | f } n
 d | } t& j' | t( | t& j) É  | |	 É |  _* t& j+ |  j* t, É d |
 f g } | j- pó| j. } | r∂| j/ d | f É n  | j0 rÿ| j/ d | j0 f É n  | rÙt1 |  j* d | É n  |  j2 É  |  j3 É  |  j4 É  |  j5 É  |  j* j6 É  t7 |  j d É rid |  j
 pJd | f } |  j j8 j/ | É n  |  j9 sãt: |  j d |  j; Én  d  S(   Nt   buildt   installt   reinit_subcommandsi   i    t   install_libs    Should have already checked thisi   s   .%s-%st   libs   installing to %st   PURELIBt   UNKNOWNs   %d.%d.%ds   Python %s %ss	   Python %st   DistVersiont
   ARPCONTACTt   ARPURLINFOABOUTt   Propertyt
   dist_filesR*   t   anyt   dry_run(<   R9   t   run_commandt   reinitialize_commandR2   t   prefixt   warn_dirt   compilet   optimizeRF   RG   R7   t   AssertionErrort   syst   versionR3   RA   RC   RD   RE   t
   build_baset	   build_libR   t   infot   ensure_finalizedt   insertt   runt   mkpathR8   t   get_fullnamet   get_installer_filenamet   abspatht   existst   unlinkt   metadatat   authort
   maintainert   get_versionR   t   msilibt   init_databaseR   t   gen_uuidt   dbt
   add_tablesR   t   author_emailt   maintainer_emailt   appendt   urlR   t   add_find_pythont	   add_filest   add_scriptst   add_uit   Committ   hasattrR[   R4   R   R]   (   R   RQ   RS   R7   t   plat_specifierRP   t   fullnamet   installer_nameRs   Rt   Rf   t   sversiont   product_namet   propst   emailt   tup(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRl   ¥   s~    					
%

 			
	



	c      
   C   sÔ  |  j  } t j d É } t j j |  j É } t | | d  | d d É } t	 | d d d d d d d É} | | d	 f g } xπ |  j
 |  j g D]§ } d | } d | }	 }
 d } | |  j k r— d
 } d } n d | } d } t	 | |	 | | d | d | É} t | | | | | |
 É } | j | | | f É qè W| j É  i  } xî| D]å\ } } } | g } xg| rœ| j É  } xNt j | j É D]:} t j j | j | É } t j j | É rd | j | É | f } | | }
 t | | | | |
 | É } | j | É qé| j s.| j | j | d É n  | | k rè| j | É } | | <| |  j k r»|  j r|t d | É Ç n  d | |  _ q»qé| | } t |  j  d | | | j | d  | j f g É qéWqiW| j É  qNW| j | É d  S(   Nt	   distfilest	   TARGETDIRt	   SourceDirt   Pythont
   Everythingi    i   t	   directoryt    s   Python from another locationi   s   Python %s from registrys   %s|%ss   Multiple files with name %ss   [#%s]t   DuplicateFile(   Rz   Rw   t   CABRC   RD   Rp   R2   R
   R1   R   R<   t   other_versionR~   RÑ   t   popt   listdirt   absoluteRE   t   isdirt
   make_shortt	   componentt   start_componentt   logicalt   add_fileR:   RL   R   R   t   commit(   R   Rz   t   cabt   rootdirt   roott   ft   itemsRf   t   targetR   t   defaultt   descR   t   levelt   dirt   seent   featuret   todot   filet   afilet   shortt   newdirt   key(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÅ     s\    	
	
!
		
		
+c         C   s  d } x|  j  D]˜} d | } d | } d | } d | } d | } d | } d | }	 d	 | }
 d
 | } d | } t j rå d  } n d } t |  j d | d | d | f | d | d | f g É t |  j d | | f | | f g É t |  j d | d! | d | d f |	 d" | d | d f |
 d# | d | d f g É t |  j d | | | f |	 | | d f |
 d | d f g É t |  j d | | | f |	 | | d f |
 d | d f g É t |  j d d | d d | f g É | d 7} | d k  s t Ç q Wd S($   ss  Adds code to the installer to compute the location of Python.

        Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
        registry for each version of Python.

        Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
        else from PYTHON.MACHINE.X.Y.

        Properties PYTHONX.Y will be set to TARGETDIRX.Y\python.exeií  s)   SOFTWARE\Python\PythonCore\%s\InstallPaths   python.machine.s   python.user.s   PYTHON.MACHINE.s   PYTHON.USER.t   PythonFromMachinet   PythonFromUsert	   PythonExeRè   t   PYTHONi   i   t
   RegLocatori   t	   AppSearcht   CustomActioni3   i   t   [t   ]s   ]\python.exet   InstallExecuteSequencet   InstallUISequencet	   ConditionRë   i    s   NOT TARGETDIRi   iÙ  Ni   i3  i3  i3  (   R<   Rw   t   Win64R   Rz   R1   Rd   (   R   t   startt   vert   install_patht   machine_regt   user_regt   machine_propt	   user_propt   machine_actiont   user_actiont
   exe_actiont   target_dir_propt   exe_propt   Type(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÄ   E  sJ    









			
c         C   sQ  |  j  rñ d } xÑ |  j |  j g D]l } d | } d | } t |  j d | d | |  j f g É t |  j d | d | | f g É | d 7} q# Wn  |  j rMt j j	 |  j
 d	 É } t | d
 É } | j d É | j t |  j É j É  É | j É  t |  j d d t j | É f g É t |  j d d g É t |  j d d g É n  d  S(   Niê  s   install_script.R∑   R∫   i2   RΩ   s   &Python%s=3i   s   preinstall.batR   s   rem ="""
%1 %0
exit
"""
t   Binaryt
   PreInstalli   s   NOT Installedi¬  (   Rœ   i   Rœ   N(   Rœ   s   NOT Installedi¬  (   R:   R<   Ró   R   Rz   RL   R;   RC   RD   RE   R2   t   opent   writet   readt   closeRw   RŒ   R1   (   R   R¡   R¬   t   install_actionRÃ   t   scriptfnR•   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÇ   {  s,    	

		

c         C   sA  |  j  } d } } d } d } d } d } d } t | d d dÒ dÚ dÛ dÙ dı g É t | d dˆ d˜ d¯ d˘ g É t | d d˙ d˚ d¸ d˝ d˛ g É t | d. t j É t | d/ t j É t | d0 | | | | | | d1 d1 d1 É }	 |	 j d2 É |	 j d3 d1 d4 d É|	 j	 d5 d6 d4 d É|	 j d7 d8 d9 d: d; d< d= É |	 j d> d8 d? d: d@ d< dA É |	 j
 d1 d5 dB d1 É}
 |
 j dC dD É t | dE | | | | | | d1 d1 d1 É } | j dF É | j d3 d1 d4 d É| j	 d5 d6 d4 d É| j d7 d8 d9 d: d; d< dG É | j d> d8 d? d: d@ d< dA É | j
 d1 d5 dB d1 É}
 |
 j dC dD É t | dH | | | | | | d1 d1 d1 É } | j dI É | j d3 d1 d4 d É| j	 d5 d6 d4 d É| j dJ d8 dK d: d@ d< dA É | j
 d1 d5 dB d1 É}
 |
 j dC dL É t | dM | | | | dN | dO dO dO dP t É} | j dQ d8 dR dS d8 d< dT É | j dJ d@ dU dV d@ d< dW É | j dX d@ dY dZ d d d[ É | j d\ d] d@ d^ dZ d_ d` da d  d  d  É | j dD db dB dD É}
 |
 j dC dD É | j
 db dO dB db É}
 |
 j dC db É | j	 dO dD dB dO É}
 |
 j dC dO É t | d d d dZ dc dd | de d  d  É } | j de d d dV df d dg É | j dh di dj dk dl d dm d  É j dC dn É | j do dp dj dk dl d dq d  É j dC dr É | j ds d dj dk dl d dt d  É j dC du É | j dv dw dj dk dl d d5 d  É j dC dx É | j dy dk dj dk dl d db d  É j dC dz É | j d{ d| dj dk dl d d} d  É j dC d~ É | j d dÄ dj dk dl d dO d  É j dC dÅ É t | dÇ d d dÉ dÑ d | dm dm dm É } | j dX df d8 dÖ dÜ d dá É | j dq dj dà dâ dä d dq dm É }
 |
 j dC dD É | j dm dã dà dâ dä d dm dq É }
 |
 j dC dL É t | då d d dÉ dÑ | | dL dL dL É } | j dX df d8 dÖ dÜ d dç É | j dL dé dà dâ dä d dL d  É }
 |
 j dC dD É t | d  | | | | | | d5 d5 d5 É } | j dJ d8 d9 d: dè d< dê É | j dë É | j d. d8 dí d: d@ d< dì É }
 |
 j d. dX É | j dî d8 dï d: dÜ d< d  É }
 |
 j dî dX É | j d6 d  d4 d É| j
 dñ d  d4 d É| j	 d5 d  É }
 |
 j dó dÇ É t | d& | | | | | | dñ dñ d5 É } | j dò É | j dô d8 dÜ d d@ d dö |  j j É  É | j d3 d  d4 d É| j
 dõ d5 É }
 d } |
 j dú dù dû | ÉxF |  j |  j g D]1 } | d 7} |
 j dú dü | d† | dû | ÉqöW|
 j d° då dû | d É|
 j dC dL dû | d¢ É| j	 d5 d£ É }
 |
 j dó dÇ É | j d£ d§ d8 d• d di d d¶ d  dß d  É }
 |
 j d® d© É |  j } d† | } d™ | } | j d´ d8 dS d d8 d d¨ É }
 |
 j d≠ | É |
 j dÆ | É |
 j dØ | É |
 j d∞ | É | j dß dß d8 d± d d≤ d d≥ | d  dñ d  É }
 |
 j d≠ | É |
 j dÆ | É |
 j dØ | É |
 j d∞ | É t | d¥ | | | | | | dµ dµ dµ dP t É} | j dQ d8 dR dS d8 d< d∂ É | j dJ d@ d@ dV d@ d< d∑ É | j dX d@ d∏ dZ d• d dπ É | j d∫ dª d@ dº dZ dΩ dæ d  dø d  d  É | j dµ d} d  d¿ É j dC dL É t | d# | | | | | | d¡ dñ d5 É } | j d¬ É | j d¡ d8 d• dÉ d d d dg dñ É	 } | j d d d√ dΩ d@ dƒ É | j d≈ d d∆ dΩ d@ d« É | j d6 d  d4 d É| j
 dõ d5 É }
 |
 j d» d© d… d É |
 j dC dL dû d¢ É| j	 d5 d¡ É }
 |
 j dó dÇ É t | d, | | | | | | d5 d5 d5 dP t É} | j dQ d@ d8 dS d8 d< d  É | j dX dÀ dÃ d dÜ d dÕ É | j dŒ dÀ dº dÀ d@ d dœ É | j d. d9 dº | d9 d@ d dì É }
 |
 j d. dX É | j d– d– dÀ di d d d— d  d“ d  d  É }
 |
 j d” d‘ É | j d3 dñ d4 t É| j
 dõ d5 d4 t É| j	 d5 d6 É j dó dÇ É t | d) | | | | | | dñ dñ d5 É } | j d’ É | j d÷ d8 d◊ dZ dw d dÿ É | j dŸ d8 d⁄ dZ d• d d dg dñ É	 } | j d d d€ dS dä d‹ É | j d› d dﬁ dS dä dﬂ É | j d3 d  d4 t É| j
 d1 d5 É }
 |
 j d‡ d d· d√ É |
 j d‚ d„ d· dR É |
 j d‰ dÂ d· d` É |
 j dÊ d d· d É |
 j dÁ d dË dÈ É |
 j d‚ dÍ dË dÎ É |
 j d‰ dÏ dË dÌ É |
 j d› d dË dÓ É |
 j dC dL dÔ d@ É | j	 d5 dŸ É j dó dÇ É d  S(ˇ   Ni2   ir  i,  s   [ProductName] Setupi   i   RZ   t   DefaultUIFontt   DlgFont8t   ErrorDialogt   ErrorDlgt	   Progress1t   Installt	   Progress2t   installst   MaintenanceForm_Actiont   Repairt
   WhichUserst   ALLt	   TextStylet   Tahomai	   i    t   DlgFontBold8i   t   VerdanaBold10t   Verdanai
   t   VerdanaRed9iˇ   Ræ   t
   PrepareDlgs(   Not Privileged or Windows9x or Installediå   t   WhichUsersDlgs.   Privileged and not Windows9x and not Installediç   t   SelectFeaturesDlgs   Not InstallediŒ  t   MaintenanceTypeDlgs,   Installed AND NOT RESUME AND NOT Preselectedi‚  t   ProgressDlgi   t
   ActionTextt   UITextt
   FatalErrort   Finishs)   [ProductName] Installer ended prematurelys   < BackR   R!   R   t   Description1i   iF   i@  iP   i  s´   [ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.t   Description2iõ   i   s.   Click the Finish button to exit the Installer.R   t	   EndDialogt   Exitt   UserExits'   [ProductName] Installer was interruptedsï   [ProductName] setup was interrupted.  Your system has not been modified.  To install this program at a later time, please run the installation again.t
   ExitDialogs&   Completing the [ProductName] Installert   DescriptioniÎ   t   Returnt
   FilesInUsei   t   Retryt   bitmapR   i   i»   s   {\DlgFontBold8}Files in Usei   i  s8   Some files that need to be updated are currently in use.t   Texti7   iJ  s≤   The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.t   Listt   ListBoxik   iÇ   i   t   FileInUseProcesst   Ignoreie   i  t	   ErrorTexti0   Rî   t   Nix   iH   iQ   i   t   Not   ErrorNot   Yi   t   Yest   ErrorYest   At   Abortt
   ErrorAbortt   Ci*   t   ErrorCancelt   It   ErrorIgnoret   Oiü   t   Okt   ErrorOkt   Ri∆   t
   ErrorRetryt	   CancelDlgi  iU   i¬   i   s;   Are you sure you want to cancel [ProductName] installation?i9   i8   i   iÑ   t   WaitForCostingDlgsR   Please wait while the installer finishes determining your disk space requirements.if   i(   sO   Please wait while the Installer prepares to guide you through the installation.s&   Welcome to the [ProductName] Installerin   s   Pondering...t
   ActionDataiá   R#   t   SpawnDialogs   Select Python Installationst   Hints9   Select the Python locations where %s should be installed.s   Next >s   [TARGETDIR]s   [SourceDir]t   orderings   [TARGETDIR%s]s    FEATURE_SELECTED AND &Python%s=3t   SpawnWaitDialogi   t   Featurest   SelectionTreei<   t   FEATUREt   PathEdits   [FEATURE_SELECTED]t   1s!   FEATURE_SELECTED AND &Python%s<>3t   Others$   Provide an alternate Python locationt   Enablet   Showt   Disablet   Hidei◊   i   Rè   t   DiskCostDlgt   OKs&   {\DlgFontBold8}Disk Space RequirementssF   The disk space required for the installation of the selected features.i5   s  The highlighted volumes (if any) do not have enough disk space available for the currently selected features.  You can either remove some files from the highlighted volumes, or choose to install less features onto local drive(s), or select different destination drive(s).t
   VolumeListt   VolumeCostListid   iñ   i  s   {120}{70}{70}{70}{70}g      ‡?t   AdminInstallsG   Select whether to install [ProductName] for all users of this computer.i   s   Install for all userst   JUSTMEi   s   Install just for mes
   [ALLUSERS]s   WhichUsers="ALL"s(   {\DlgFontBold8}[Progress1] [ProductName]i#   iA   sY   Please wait while the Installer [Progress2] [ProductName]. This may take several minutes.t   StatusLabels   Status:t   ProgressBari  s   Progress donet   SetProgresst   Progresss)   Welcome to the [ProductName] Setup Wizardt   BodyTexti?   s:   Select whether you want to repair or remove [ProductName].t   RepairRadioGroupil   i   s   &Repair [ProductName]t   Removei$   s   Re&move [ProductName]s   [REINSTALL]s   MaintenanceForm_Action="Repair"s   [Progress1]t	   Repairings   [Progress2]t   repairst	   Reinstalls   [REMOVE]s   MaintenanceForm_Action="Remove"i   t   Removingi   t   removesi   i   s    MaintenanceForm_Action<>"Change"(   R÷   R◊   (   Rÿ   RŸ   (   R⁄   R€   (   R‹   R›   (   Rﬁ   Rﬂ   (   R‡   R·   (   R◊   R„   i	   Ni    (   R‰   R„   i   Ni   (   RÂ   RÊ   i
   Ni   (   RÁ   RÊ   i	   iˇ   i    (   RË   s(   Not Privileged or Windows9x or Installediå   (   RÈ   s.   Privileged and not Windows9x and not Installediç   (   RÍ   s   Not InstallediŒ  (   RÎ   s,   Installed AND NOT RESUME AND NOT Preselectedi‚  (   RÏ   Ni   (   Rz   R   R1   R	   RÌ   RÓ   R   R   R    R"   R   t   eventt   Falset   controlR   R   t   mappingRF   Rn   R<   Ró   t	   conditionR&   t
   radiogroupt   add(   R   Rz   t   xt   yR   R   R   t   modalt   modelesst   fatalR-   t	   user_exitt   exit_dialogt   inuset   errorR"   t   costingt   prept   seldlgt   orderRf   R¬   t   install_other_condt   dont_install_other_condt   costt
   whichuserst   gt   progresst   maint(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÉ   °  s¨   	
	
	
	
		.......$$$!!

	

	"%c         C   sT   |  j  r% d | |  j |  j  f } n d | |  j f } t j j |  j | É } | S(   Ns   %s.%s-py%s.msis	   %s.%s.msi(   R7   R3   RC   RD   RE   R8   (   R   Rá   t	   base_nameRà   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRo   ﬁ  s    	(   R'   R(   t   descriptionR1   R   t   user_optionst   boolean_optionsRI   Ró   R=   RO   Rl   RÅ   RÄ   RÇ   RÉ   Ro   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR*   T   sP   
				)	[	6	6	&	ˇ >(   R)   Re   RC   t	   sysconfigR    t   distutils.coreR   t   distutils.dir_utilR   t   distutils.versionR   t   distutils.errorsR   t	   distutilsR   t   distutils.utilR   Rw   R   R   R	   R
   R   R   R   R   R*   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   <module>   s   "=                                                                                     usr/lib/python2.7/distutils/command/bdist_rpm.py                                                    0100644 0000000 0000000 00000051070 12734733743 020413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions)."""

__revision__ = "$Id$"

import sys
import os
import string

from distutils.core import Command
from distutils.debug import DEBUG
from distutils.file_util import write_file
from distutils.sysconfig import get_python_version
from distutils.errors import (DistutilsOptionError, DistutilsPlatformError,
                              DistutilsFileError, DistutilsExecError)
from distutils import log

class bdist_rpm (Command):

    description = "create an RPM distribution"

    user_options = [
        ('bdist-base=', None,
         "base directory for creating built distributions"),
        ('rpm-base=', None,
         "base directory for creating RPMs (defaults to \"rpm\" under "
         "--bdist-base; must be specified for RPM 2)"),
        ('dist-dir=', 'd',
         "directory to put final RPM files in "
         "(and .spec files if --spec-only)"),
        ('python=', None,
         "path to Python interpreter to hard-code in the .spec file "
         "(default: \"python\")"),
        ('fix-python', None,
         "hard-code the exact path to the current Python interpreter in "
         "the .spec file"),
        ('spec-only', None,
         "only regenerate spec file"),
        ('source-only', None,
         "only generate source RPM"),
        ('binary-only', None,
         "only generate binary RPM"),
        ('use-bzip2', None,
         "use bzip2 instead of gzip to create source distribution"),

        # More meta-data: too RPM-specific to put in the setup script,
        # but needs to go in the .spec file -- so we make these options
        # to "bdist_rpm".  The idea is that packagers would put this
        # info in setup.cfg, although they are of course free to
        # supply it on the command line.
        ('distribution-name=', None,
         "name of the (Linux) distribution to which this "
         "RPM applies (*not* the name of the module distribution!)"),
        ('group=', None,
         "package classification [default: \"Development/Libraries\"]"),
        ('release=', None,
         "RPM release number"),
        ('serial=', None,
         "RPM serial number"),
        ('vendor=', None,
         "RPM \"vendor\" (eg. \"Joe Blow <joe@example.com>\") "
         "[default: maintainer or author from setup script]"),
        ('packager=', None,
         "RPM packager (eg. \"Jane Doe <jane@example.net>\")"
         "[default: vendor]"),
        ('doc-files=', None,
         "list of documentation files (space or comma-separated)"),
        ('changelog=', None,
         "RPM changelog"),
        ('icon=', None,
         "name of icon file"),
        ('provides=', None,
         "capabilities provided by this package"),
        ('requires=', None,
         "capabilities required by this package"),
        ('conflicts=', None,
         "capabilities which conflict with this package"),
        ('build-requires=', None,
         "capabilities required to build this package"),
        ('obsoletes=', None,
         "capabilities made obsolete by this package"),
        ('no-autoreq', None,
         "do not automatically calculate dependencies"),

        # Actions to take when building RPM
        ('keep-temp', 'k',
         "don't clean up RPM build directory"),
        ('no-keep-temp', None,
         "clean up RPM build directory [default]"),
        ('use-rpm-opt-flags', None,
         "compile with RPM_OPT_FLAGS when building from source RPM"),
        ('no-rpm-opt-flags', None,
         "do not pass any RPM CFLAGS to compiler"),
        ('rpm3-mode', None,
         "RPM 3 compatibility mode (default)"),
        ('rpm2-mode', None,
         "RPM 2 compatibility mode"),

        # Add the hooks necessary for specifying custom scripts
        ('prep-script=', None,
         "Specify a script for the PREP phase of RPM building"),
        ('build-script=', None,
         "Specify a script for the BUILD phase of RPM building"),

        ('pre-install=', None,
         "Specify a script for the pre-INSTALL phase of RPM building"),
        ('install-script=', None,
         "Specify a script for the INSTALL phase of RPM building"),
        ('post-install=', None,
         "Specify a script for the post-INSTALL phase of RPM building"),

        ('pre-uninstall=', None,
         "Specify a script for the pre-UNINSTALL phase of RPM building"),
        ('post-uninstall=', None,
         "Specify a script for the post-UNINSTALL phase of RPM building"),

        ('clean-script=', None,
         "Specify a script for the CLEAN phase of RPM building"),

        ('verify-script=', None,
         "Specify a script for the VERIFY phase of the RPM build"),

        # Allow a packager to explicitly force an architecture
        ('force-arch=', None,
         "Force an architecture onto the RPM build process"),

        ('quiet', 'q',
         "Run the INSTALL phase of RPM building in quiet mode"),
        ]

    boolean_options = ['keep-temp', 'use-rpm-opt-flags', 'rpm3-mode',
                       'no-autoreq', 'quiet']

    negative_opt = {'no-keep-temp': 'keep-temp',
                    'no-rpm-opt-flags': 'use-rpm-opt-flags',
                    'rpm2-mode': 'rpm3-mode'}


    def initialize_options (self):
        self.bdist_base = None
        self.rpm_base = None
        self.dist_dir = None
        self.python = None
        self.fix_python = None
        self.spec_only = None
        self.binary_only = None
        self.source_only = None
        self.use_bzip2 = None

        self.distribution_name = None
        self.group = None
        self.release = None
        self.serial = None
        self.vendor = None
        self.packager = None
        self.doc_files = None
        self.changelog = None
        self.icon = None

        self.prep_script = None
        self.build_script = None
        self.install_script = None
        self.clean_script = None
        self.verify_script = None
        self.pre_install = None
        self.post_install = None
        self.pre_uninstall = None
        self.post_uninstall = None
        self.prep = None
        self.provides = None
        self.requires = None
        self.conflicts = None
        self.build_requires = None
        self.obsoletes = None

        self.keep_temp = 0
        self.use_rpm_opt_flags = 1
        self.rpm3_mode = 1
        self.no_autoreq = 0

        self.force_arch = None
        self.quiet = 0

    # initialize_options()


    def finalize_options (self):
        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))
        if self.rpm_base is None:
            if not self.rpm3_mode:
                raise DistutilsOptionError, \
                      "you must specify --rpm-base in RPM 2 mode"
            self.rpm_base = os.path.join(self.bdist_base, "rpm")

        if self.python is None:
            if self.fix_python:
                self.python = sys.executable
            else:
                self.python = "python"
        elif self.fix_python:
            raise DistutilsOptionError, \
                  "--python and --fix-python are mutually exclusive options"

        if os.name != 'posix':
            raise DistutilsPlatformError, \
                  ("don't know how to create RPM "
                   "distributions on platform %s" % os.name)
        if self.binary_only and self.source_only:
            raise DistutilsOptionError, \
                  "cannot supply both '--source-only' and '--binary-only'"

        # don't pass CFLAGS to pure python distributions
        if not self.distribution.has_ext_modules():
            self.use_rpm_opt_flags = 0

        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))
        self.finalize_package_data()

    # finalize_options()

    def finalize_package_data (self):
        self.ensure_string('group', "Development/Libraries")
        self.ensure_string('vendor',
                           "%s <%s>" % (self.distribution.get_contact(),
                                        self.distribution.get_contact_email()))
        self.ensure_string('packager')
        self.ensure_string_list('doc_files')
        if isinstance(self.doc_files, list):
            for readme in ('README', 'README.txt'):
                if os.path.exists(readme) and readme not in self.doc_files:
                    self.doc_files.append(readme)

        self.ensure_string('release', "1")
        self.ensure_string('serial')   # should it be an int?

        self.ensure_string('distribution_name')

        self.ensure_string('changelog')
          # Format changelog correctly
        self.changelog = self._format_changelog(self.changelog)

        self.ensure_filename('icon')

        self.ensure_filename('prep_script')
        self.ensure_filename('build_script')
        self.ensure_filename('install_script')
        self.ensure_filename('clean_script')
        self.ensure_filename('verify_script')
        self.ensure_filename('pre_install')
        self.ensure_filename('post_install')
        self.ensure_filename('pre_uninstall')
        self.ensure_filename('post_uninstall')

        # XXX don't forget we punted on summaries and descriptions -- they
        # should be handled here eventually!

        # Now *this* is some meta-data that belongs in the setup script...
        self.ensure_string_list('provides')
        self.ensure_string_list('requires')
        self.ensure_string_list('conflicts')
        self.ensure_string_list('build_requires')
        self.ensure_string_list('obsoletes')

        self.ensure_string('force_arch')
    # finalize_package_data ()


    def run (self):

        if DEBUG:
            print "before _get_package_data():"
            print "vendor =", self.vendor
            print "packager =", self.packager
            print "doc_files =", self.doc_files
            print "changelog =", self.changelog

        # make directories
        if self.spec_only:
            spec_dir = self.dist_dir
            self.mkpath(spec_dir)
        else:
            rpm_dir = {}
            for d in ('SOURCES', 'SPECS', 'BUILD', 'RPMS', 'SRPMS'):
                rpm_dir[d] = os.path.join(self.rpm_base, d)
                self.mkpath(rpm_dir[d])
            spec_dir = rpm_dir['SPECS']

        # Spec file goes into 'dist_dir' if '--spec-only specified',
        # build/rpm.<plat> otherwise.
        spec_path = os.path.join(spec_dir,
                                 "%s.spec" % self.distribution.get_name())
        self.execute(write_file,
                     (spec_path,
                      self._make_spec_file()),
                     "writing '%s'" % spec_path)

        if self.spec_only: # stop if requested
            return

        # Make a source distribution and copy to SOURCES directory with
        # optional icon.
        saved_dist_files = self.distribution.dist_files[:]
        sdist = self.reinitialize_command('sdist')
        if self.use_bzip2:
            sdist.formats = ['bztar']
        else:
            sdist.formats = ['gztar']
        self.run_command('sdist')
        self.distribution.dist_files = saved_dist_files

        source = sdist.get_archive_files()[0]
        source_dir = rpm_dir['SOURCES']
        self.copy_file(source, source_dir)

        if self.icon:
            if os.path.exists(self.icon):
                self.copy_file(self.icon, source_dir)
            else:
                raise DistutilsFileError, \
                      "icon file '%s' does not exist" % self.icon


        # build package
        log.info("building RPMs")
        rpm_cmd = ['rpm']
        if os.path.exists('/usr/bin/rpmbuild') or \
           os.path.exists('/bin/rpmbuild'):
            rpm_cmd = ['rpmbuild']

        if self.source_only: # what kind of RPMs?
            rpm_cmd.append('-bs')
        elif self.binary_only:
            rpm_cmd.append('-bb')
        else:
            rpm_cmd.append('-ba')
        if self.rpm3_mode:
            rpm_cmd.extend(['--define',
                             '_topdir %s' % os.path.abspath(self.rpm_base)])
        if not self.keep_temp:
            rpm_cmd.append('--clean')

        if self.quiet:
            rpm_cmd.append('--quiet')

        rpm_cmd.append(spec_path)
        # Determine the binary rpm names that should be built out of this spec
        # file
        # Note that some of these may not be really built (if the file
        # list is empty)
        nvr_string = "%{name}-%{version}-%{release}"
        src_rpm = nvr_string + ".src.rpm"
        non_src_rpm = "%{arch}/" + nvr_string + ".%{arch}.rpm"
        q_cmd = r"rpm -q --qf '%s %s\n' --specfile '%s'" % (
            src_rpm, non_src_rpm, spec_path)

        out = os.popen(q_cmd)
        try:
            binary_rpms = []
            source_rpm = None
            while 1:
                line = out.readline()
                if not line:
                    break
                l = string.split(string.strip(line))
                assert(len(l) == 2)
                binary_rpms.append(l[1])
                # The source rpm is named after the first entry in the spec file
                if source_rpm is None:
                    source_rpm = l[0]

            status = out.close()
            if status:
                raise DistutilsExecError("Failed to execute: %s" % repr(q_cmd))

        finally:
            out.close()

        self.spawn(rpm_cmd)

        if not self.dry_run:
            if self.distribution.has_ext_modules():
                pyversion = get_python_version()
            else:
                pyversion = 'any'

            if not self.binary_only:
                srpm = os.path.join(rpm_dir['SRPMS'], source_rpm)
                assert(os.path.exists(srpm))
                self.move_file(srpm, self.dist_dir)
                filename = os.path.join(self.dist_dir, source_rpm)
                self.distribution.dist_files.append(
                    ('bdist_rpm', pyversion, filename))

            if not self.source_only:
                for rpm in binary_rpms:
                    rpm = os.path.join(rpm_dir['RPMS'], rpm)
                    if os.path.exists(rpm):
                        self.move_file(rpm, self.dist_dir)
                        filename = os.path.join(self.dist_dir,
                                                os.path.basename(rpm))
                        self.distribution.dist_files.append(
                            ('bdist_rpm', pyversion, filename))
    # run()

    def _dist_path(self, path):
        return os.path.join(self.dist_dir, os.path.basename(path))

    def _make_spec_file(self):
        """Generate the text of an RPM spec file and return it as a
        list of strings (one per line).
        """
        # definitions and headers
        spec_file = [
            '%define name ' + self.distribution.get_name(),
            '%define version ' + self.distribution.get_version().replace('-','_'),
            '%define unmangled_version ' + self.distribution.get_version(),
            '%define release ' + self.release.replace('-','_'),
            '',
            'Summary: ' + self.distribution.get_description(),
            ]

        # put locale summaries into spec file
        # XXX not supported for now (hard to put a dictionary
        # in a config file -- arg!)
        #for locale in self.summaries.keys():
        #    spec_file.append('Summary(%s): %s' % (locale,
        #                                          self.summaries[locale]))

        spec_file.extend([
            'Name: %{name}',
            'Version: %{version}',
            'Release: %{release}',])

        # XXX yuck! this filename is available from the "sdist" command,
        # but only after it has run: and we create the spec file before
        # running "sdist", in case of --spec-only.
        if self.use_bzip2:
            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.bz2')
        else:
            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.gz')

        spec_file.extend([
            'License: ' + self.distribution.get_license(),
            'Group: ' + self.group,
            'BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot',
            'Prefix: %{_prefix}', ])

        if not self.force_arch:
            # noarch if no extension modules
            if not self.distribution.has_ext_modules():
                spec_file.append('BuildArch: noarch')
        else:
            spec_file.append( 'BuildArch: %s' % self.force_arch )

        for field in ('Vendor',
                      'Packager',
                      'Provides',
                      'Requires',
                      'Conflicts',
                      'Obsoletes',
                      ):
            val = getattr(self, string.lower(field))
            if isinstance(val, list):
                spec_file.append('%s: %s' % (field, string.join(val)))
            elif val is not None:
                spec_file.append('%s: %s' % (field, val))


        if self.distribution.get_url() != 'UNKNOWN':
            spec_file.append('Url: ' + self.distribution.get_url())

        if self.distribution_name:
            spec_file.append('Distribution: ' + self.distribution_name)

        if self.build_requires:
            spec_file.append('BuildRequires: ' +
                             string.join(self.build_requires))

        if self.icon:
            spec_file.append('Icon: ' + os.path.basename(self.icon))

        if self.no_autoreq:
            spec_file.append('AutoReq: 0')

        spec_file.extend([
            '',
            '%description',
            self.distribution.get_long_description()
            ])

        # put locale descriptions into spec file
        # XXX again, suppressed because config file syntax doesn't
        # easily support this ;-(
        #for locale in self.descriptions.keys():
        #    spec_file.extend([
        #        '',
        #        '%description -l ' + locale,
        #        self.descriptions[locale],
        #        ])

        # rpm scripts
        # figure out default build script
        def_setup_call = "%s %s" % (self.python,os.path.basename(sys.argv[0]))
        def_build = "%s build" % def_setup_call
        if self.use_rpm_opt_flags:
            def_build = 'env CFLAGS="$RPM_OPT_FLAGS" ' + def_build

        # insert contents of files

        # XXX this is kind of misleading: user-supplied options are files
        # that we open and interpolate into the spec file, but the defaults
        # are just text that we drop in as-is.  Hmmm.

        install_cmd = ('%s install -O1 --root=$RPM_BUILD_ROOT '
                       '--record=INSTALLED_FILES') % def_setup_call

        script_options = [
            ('prep', 'prep_script', "%setup -n %{name}-%{unmangled_version}"),
            ('build', 'build_script', def_build),
            ('install', 'install_script', install_cmd),
            ('clean', 'clean_script', "rm -rf $RPM_BUILD_ROOT"),
            ('verifyscript', 'verify_script', None),
            ('pre', 'pre_install', None),
            ('post', 'post_install', None),
            ('preun', 'pre_uninstall', None),
            ('postun', 'post_uninstall', None),
        ]

        for (rpm_opt, attr, default) in script_options:
            # Insert contents of file referred to, if no file is referred to
            # use 'default' as contents of script
            val = getattr(self, attr)
            if val or default:
                spec_file.extend([
                    '',
                    '%' + rpm_opt,])
                if val:
                    spec_file.extend(string.split(open(val, 'r').read(), '\n'))
                else:
                    spec_file.append(default)


        # files section
        spec_file.extend([
            '',
            '%files -f INSTALLED_FILES',
            '%defattr(-,root,root)',
            ])

        if self.doc_files:
            spec_file.append('%doc ' + string.join(self.doc_files))

        if self.changelog:
            spec_file.extend([
                '',
                '%changelog',])
            spec_file.extend(self.changelog)

        return spec_file

    # _make_spec_file ()

    def _format_changelog(self, changelog):
        """Format the changelog correctly and convert it to a list of strings
        """
        if not changelog:
            return changelog
        new_changelog = []
        for line in string.split(string.strip(changelog), '\n'):
            line = string.strip(line)
            if line[0] == '*':
                new_changelog.extend(['', line])
            elif line[0] == '-':
                new_changelog.append(line)
            else:
                new_changelog.append('  ' + line)

        # strip trailing newline inserted by first changelog entry
        if not new_changelog[0]:
            del new_changelog[0]

        return new_changelog

    # _format_changelog()

# class bdist_rpm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/distutils/command/bdist_rpm.pyc                                                   0100644 0000000 0000000 00000042466 13077704274 020565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sº   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z m Z m Z m Z d d	 l m Z d
 e f d Ñ  É  YZ d S(   sw   distutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions).s   $Id$iˇˇˇˇN(   t   Command(   t   DEBUG(   t
   write_file(   t   get_python_version(   t   DistutilsOptionErrort   DistutilsPlatformErrort   DistutilsFileErrort   DistutilsExecError(   t   logt	   bdist_rpmc        +   B   s˛   e  Z d  Z d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d dÄ dÅ dÇ dÉ dÑ dÖ dÜ g) Z d2 d7 d; d0 dS g Z i d2 d5 6d7 d9 6d; d= 6Z dV Ñ  Z dW Ñ  Z dX Ñ  Z	 dY Ñ  Z
 dZ Ñ  Z d[ Ñ  Z d\ Ñ  Z RS(á   s   create an RPM distributions   bdist-base=s/   base directory for creating built distributionss	   rpm-base=sd   base directory for creating RPMs (defaults to "rpm" under --bdist-base; must be specified for RPM 2)s	   dist-dir=t   dsD   directory to put final RPM files in (and .spec files if --spec-only)s   python=sM   path to Python interpreter to hard-code in the .spec file (default: "python")s
   fix-pythonsL   hard-code the exact path to the current Python interpreter in the .spec files	   spec-onlys   only regenerate spec files   source-onlys   only generate source RPMs   binary-onlys   only generate binary RPMs	   use-bzip2s7   use bzip2 instead of gzip to create source distributions   distribution-name=sg   name of the (Linux) distribution to which this RPM applies (*not* the name of the module distribution!)s   group=s9   package classification [default: "Development/Libraries"]s   release=s   RPM release numbers   serial=s   RPM serial numbers   vendor=sa   RPM "vendor" (eg. "Joe Blow <joe@example.com>") [default: maintainer or author from setup script]s	   packager=sA   RPM packager (eg. "Jane Doe <jane@example.net>")[default: vendor]s
   doc-files=s6   list of documentation files (space or comma-separated)s
   changelog=s   RPM changelogs   icon=s   name of icon files	   provides=s%   capabilities provided by this packages	   requires=s%   capabilities required by this packages
   conflicts=s-   capabilities which conflict with this packages   build-requires=s+   capabilities required to build this packages
   obsoletes=s*   capabilities made obsolete by this packages
   no-autoreqs+   do not automatically calculate dependenciess	   keep-tempt   ks"   don't clean up RPM build directorys   no-keep-temps&   clean up RPM build directory [default]s   use-rpm-opt-flagss8   compile with RPM_OPT_FLAGS when building from source RPMs   no-rpm-opt-flagss&   do not pass any RPM CFLAGS to compilers	   rpm3-modes"   RPM 3 compatibility mode (default)s	   rpm2-modes   RPM 2 compatibility modes   prep-script=s3   Specify a script for the PREP phase of RPM buildings   build-script=s4   Specify a script for the BUILD phase of RPM buildings   pre-install=s:   Specify a script for the pre-INSTALL phase of RPM buildings   install-script=s6   Specify a script for the INSTALL phase of RPM buildings   post-install=s;   Specify a script for the post-INSTALL phase of RPM buildings   pre-uninstall=s<   Specify a script for the pre-UNINSTALL phase of RPM buildings   post-uninstall=s=   Specify a script for the post-UNINSTALL phase of RPM buildings   clean-script=s4   Specify a script for the CLEAN phase of RPM buildings   verify-script=s6   Specify a script for the VERIFY phase of the RPM builds   force-arch=s0   Force an architecture onto the RPM build processt   quiett   qs3   Run the INSTALL phase of RPM building in quiet modec         C   sc  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _  d  |  _! d |  _" d |  _# d |  _$ d |  _% d  |  _& d |  _' d  S(   Ni    i   ((   t   Nonet
   bdist_baset   rpm_baset   dist_dirt   pythont
   fix_pythont	   spec_onlyt   binary_onlyt   source_onlyt	   use_bzip2t   distribution_namet   groupt   releaset   serialt   vendort   packagert	   doc_filest	   changelogt   icont   prep_scriptt   build_scriptt   install_scriptt   clean_scriptt   verify_scriptt   pre_installt   post_installt   pre_uninstallt   post_uninstallt   prept   providest   requirest	   conflictst   build_requirest	   obsoletest	   keep_tempt   use_rpm_opt_flagst	   rpm3_modet
   no_autoreqt
   force_archR   (   t   self(    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   initialize_optionsç   sN    																																						c         C   s  |  j  d d É |  j d  k rR |  j s4 t d Ç n  t j j |  j d É |  _ n  |  j	 d  k rÖ |  j
 ry t j |  _	 qö d |  _	 n |  j
 rö t d Ç n  t j d k rº t d t j Ç n  |  j r⁄ |  j r⁄ t d	 Ç n  |  j j É  sı d
 |  _ n  |  j  d d É |  j É  d  S(   Nt   bdistR   s)   you must specify --rpm-base in RPM 2 modet   rpmR   s8   --python and --fix-python are mutually exclusive optionst   posixs9   don't know how to create RPM distributions on platform %ss6   cannot supply both '--source-only' and '--binary-only'i    R   (   s
   bdist_bases
   bdist_base(   s   dist_dirs   dist_dir(   t   set_undefined_optionsR   R   R2   R   t   ost   patht   joinR   R   R   t   syst
   executablet   nameR   R   R   t   distributiont   has_ext_modulesR1   t   finalize_package_data(   R5   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   finalize_optionsΩ   s0    						c         C   s–  |  j  d d É |  j  d d |  j j É  |  j j É  f É |  j  d É |  j d É t |  j t É r∞ xE d D]: } t j	 j
 | É ro | |  j k ro |  j j | É qo qo Wn  |  j  d	 d
 É |  j  d É |  j  d É |  j  d É |  j |  j É |  _ |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j  d É d  S(   NR   s   Development/LibrariesR   s   %s <%s>R   R   t   READMEs
   README.txtR   t   1R   R   R   R    R!   R"   R#   R$   R%   R&   R'   R(   R)   R+   R,   R-   R.   R/   R4   (   RE   s
   README.txt(   t   ensure_stringRA   t   get_contactt   get_contact_emailt   ensure_string_listt
   isinstanceR   t   listR;   R<   t   existst   appendt   _format_changelogR   t   ensure_filename(   R5   t   readme(    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyRC   ﬂ   s>    	!c         C   s  t  r> d GHd G|  j GHd G|  j GHd G|  j GHd G|  j GHn  |  j r` |  j } |  j | É nN i  } x; d( D]3 } t j	 j
 |  j | É | | <|  j | | É qm W| d } t j	 j
 | d |  j j É  É } |  j t | |  j É  f d | É |  j r d  S|  j j } |  j d É } |  j r4d g | _ n d g | _ |  j d É | |  j _ | j É  d } | d } |  j | | É |  j r t j	 j |  j É r∑|  j |  j | É q t d |  j Ç n  t j d É d g }	 t j	 j d É st j	 j d É rd g }	 n  |  j r)|	 j d É n& |  j rB|	 j d É n |	 j d É |  j  rÅ|	 j! d d t j	 j" |  j É g É n  |  j# sö|	 j d É n  |  j$ r≥|	 j d É n  |	 j | É d }
 |
 d } d  |
 d! } d" | | | f } t j% | É } z± g  } d  } xs | j' É  } | s(Pn  t( j) t( j* | É É } t+ | É d# k sXt, Ç | j | d$ É | d  k r| d } qq| j- É  } | r∞t. d% t/ | É É Ç n  Wd  | j- É  X|  j0 |	 É |  j1 s|  j j2 É  rt3 É  } n d& } |  j szt j	 j
 | d
 | É } t j	 j | É s0t, Ç |  j4 | |  j É t j	 j
 |  j | É } |  j j j d' | | f É n  |  j sxí | D]á } t j	 j
 | d	 | É } t j	 j | É rä|  j4 | |  j É t j	 j
 |  j t j	 j5 | É É } |  j j j d' | | f É qäqäWqn  d  S()   Ns   before _get_package_data():s   vendor =s
   packager =s   doc_files =s   changelog =t   SOURCESt   SPECSt   BUILDt   RPMSt   SRPMSs   %s.specs   writing '%s't   sdistt   bztart   gztari    s   icon file '%s' does not exists   building RPMsR8   s   /usr/bin/rpmbuilds   /bin/rpmbuildt   rpmbuilds   -bss   -bbs   -bas   --defines
   _topdir %ss   --cleans   --quiets   %{name}-%{version}-%{release}s   .src.rpms   %{arch}/s   .%{arch}.rpms%   rpm -q --qf '%s %s\n' --specfile '%s'i   i   s   Failed to execute: %st   anyR	   (   RR   RS   RT   RU   RV   (6   R   R   R   R   R   R   R   t   mkpathR;   R<   R=   R   RA   t   get_namet   executeR   t   _make_spec_filet
   dist_filest   reinitialize_commandR   t   formatst   run_commandt   get_archive_filest	   copy_fileR    RM   R   R   t   infoR   RN   R   R2   t   extendt   abspathR0   R   t   popenR   t   readlinet   stringt   splitt   stript   lent   AssertionErrort   closeR   t   reprt   spawnt   dry_runRB   R   t	   move_filet   basename(   R5   t   spec_dirt   rpm_dirR
   t	   spec_patht   saved_dist_filesRW   t   sourcet
   source_dirt   rpm_cmdt
   nvr_stringt   src_rpmt   non_src_rpmt   q_cmdt   outt   binary_rpmst
   source_rpmt   linet   lt   statust	   pyversiont   srpmt   filenameR8   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   run  sƒ    		
			
						 		
			c         C   s"   t  j j |  j t  j j | É É S(   N(   R;   R<   R=   R   Ru   (   R5   R<   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt
   _dist_pathó  s    c         C   sı  d |  j  j É  d |  j  j É  j d d É d |  j  j É  d |  j j d d É d d |  j  j É  g } | j d	 d
 d g É |  j rö | j d É n | j d É | j d |  j  j	 É  d |  j
 d d g É |  j sˇ |  j  j É  s| j d É qn | j d |  j É x~ dB D]v } t |  t j | É É } t | t É rj| j d | t j | É f É q| dC k	 r| j d | | f É qqW|  j  j É  d k r∆| j d |  j  j É  É n  |  j rÊ| j d |  j É n  |  j r| j d t j |  j É É n  |  j r;| j d t j j |  j É É n  |  j rT| j d  É n  | j d d! |  j  j É  g É d" |  j t j j t j d# É f } d$ | } |  j  rπd% | } n  d& | } dD d* d+ | f d, d- | f dE dF dG dH dI dJ g	 } xä | D]Ç \ } }	 }
 t |  |	 É } | s'|
 r˝| j d d; | g É | ro| j t j! t" | d< É j# É  d= É É q| j |
 É q˝q˝W| j d d> d? g É |  j$ r¬| j d@ t j |  j$ É É n  |  j% rÒ| j d dA g É | j |  j% É n  | S(K   si   Generate the text of an RPM spec file and return it as a
        list of strings (one per line).
        s   %define name s   %define version t   -t   _s   %define unmangled_version s   %define release t    s	   Summary: s   Name: %{name}s   Version: %{version}s   Release: %{release}s-   Source0: %{name}-%{unmangled_version}.tar.bz2s,   Source0: %{name}-%{unmangled_version}.tar.gzs	   License: s   Group: s>   BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroots   Prefix: %{_prefix}s   BuildArch: noarchs   BuildArch: %st   Vendort   Packagert   Providest   Requirest	   Conflictst	   Obsoletess   %s: %st   UNKNOWNs   Url: s   Distribution: s   BuildRequires: s   Icon: s
   AutoReq: 0s   %descriptions   %s %si    s   %s builds   env CFLAGS="$RPM_OPT_FLAGS" s>   %s install -O1 --root=$RPM_BUILD_ROOT --record=INSTALLED_FILESR*   R!   s&   %setup -n %{name}-%{unmangled_version}t   buildR"   t   installR#   t   cleanR$   s   rm -rf $RPM_BUILD_ROOTt   verifyscriptR%   t   preR&   t   postR'   t   preunR(   t   postunR)   t   %t   rs   
s   %files -f INSTALLED_FILESs   %defattr(-,root,root)s   %doc s
   %changelog(   Rè   Rê   Rë   Rí   Rì   Rî   N(   s   preps   prep_scripts&   %setup -n %{name}-%{unmangled_version}(   Rò   s   clean_scripts   rm -rf $RPM_BUILD_ROOT(   Rô   s   verify_scriptN(   Rö   s   pre_installN(   Rõ   s   post_installN(   Rú   s   pre_uninstallN(   Rù   s   post_uninstallN(&   RA   R]   t   get_versiont   replaceR   t   get_descriptionRg   R   RN   t   get_licenseR   R4   RB   t   getattrRk   t   lowerRK   RL   R=   R   t   get_urlR   R.   R    R;   R<   Ru   R3   t   get_long_descriptionR   R>   t   argvR1   Rl   t   opent   readR   R   (   R5   t	   spec_filet   fieldt   valt   def_setup_callt	   def_buildt   install_cmdt   script_optionst   rpm_optt   attrt   default(    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyR_   ö  s®    

	

	    
#				#	&
		+
	 	
c         C   s¥   | s
 | Sg  } xâ t  j t  j | É d É D]l } t  j | É } | d d k rg | j d | g É q, | d d k rá | j | É q, | j d | É q, W| d s∞ | d =n  | S(   sK   Format the changelog correctly and convert it to a list of strings
        s   
i    t   *Ré   Rå   s     (   Rk   Rl   Rm   Rg   RN   (   R5   R   t   new_changelogRÑ   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyRO   5  s    "

N(   s   bdist-base=Ns/   base directory for creating built distributions(   s	   rpm-base=Nsd   base directory for creating RPMs (defaults to "rpm" under --bdist-base; must be specified for RPM 2)(   s	   dist-dir=R
   sD   directory to put final RPM files in (and .spec files if --spec-only)(   s   python=NsM   path to Python interpreter to hard-code in the .spec file (default: "python")(   s
   fix-pythonNsL   hard-code the exact path to the current Python interpreter in the .spec file(   s	   spec-onlyNs   only regenerate spec file(   s   source-onlyNs   only generate source RPM(   s   binary-onlyNs   only generate binary RPM(   s	   use-bzip2Ns7   use bzip2 instead of gzip to create source distribution(   s   distribution-name=Nsg   name of the (Linux) distribution to which this RPM applies (*not* the name of the module distribution!)(   s   group=Ns9   package classification [default: "Development/Libraries"](   s   release=Ns   RPM release number(   s   serial=Ns   RPM serial number(   s   vendor=Nsa   RPM "vendor" (eg. "Joe Blow <joe@example.com>") [default: maintainer or author from setup script](   s	   packager=NsA   RPM packager (eg. "Jane Doe <jane@example.net>")[default: vendor](   s
   doc-files=Ns6   list of documentation files (space or comma-separated)(   s
   changelog=Ns   RPM changelog(   s   icon=Ns   name of icon file(   s	   provides=Ns%   capabilities provided by this package(   s	   requires=Ns%   capabilities required by this package(   s
   conflicts=Ns-   capabilities which conflict with this package(   s   build-requires=Ns+   capabilities required to build this package(   s
   obsoletes=Ns*   capabilities made obsolete by this package(   s
   no-autoreqNs+   do not automatically calculate dependencies(   s	   keep-tempR   s"   don't clean up RPM build directory(   s   no-keep-tempNs&   clean up RPM build directory [default](   s   use-rpm-opt-flagsNs8   compile with RPM_OPT_FLAGS when building from source RPM(   s   no-rpm-opt-flagsNs&   do not pass any RPM CFLAGS to compiler(   s	   rpm3-modeNs"   RPM 3 compatibility mode (default)(   s	   rpm2-modeNs   RPM 2 compatibility mode(   s   prep-script=Ns3   Specify a script for the PREP phase of RPM building(   s   build-script=Ns4   Specify a script for the BUILD phase of RPM building(   s   pre-install=Ns:   Specify a script for the pre-INSTALL phase of RPM building(   s   install-script=Ns6   Specify a script for the INSTALL phase of RPM building(   s   post-install=Ns;   Specify a script for the post-INSTALL phase of RPM building(   s   pre-uninstall=Ns<   Specify a script for the pre-UNINSTALL phase of RPM building(   s   post-uninstall=Ns=   Specify a script for the post-UNINSTALL phase of RPM building(   s   clean-script=Ns4   Specify a script for the CLEAN phase of RPM building(   s   verify-script=Ns6   Specify a script for the VERIFY phase of the RPM build(   s   force-arch=Ns0   Force an architecture onto the RPM build process(   s   quietR   s3   Run the INSTALL phase of RPM building in quiet mode(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionst   negative_optR6   RD   RC   Rä   Rã   R_   RO   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyR	      sæ                                            		

	0	"	/	â		õ(   t   __doc__t   __revision__R>   R;   Rk   t   distutils.coreR    t   distutils.debugR   t   distutils.file_utilR   t   distutils.sysconfigR   t   distutils.errorsR   R   R   R   t	   distutilsR   R	   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   <module>   s   "                                                                                                                                                                                                          usr/lib/python2.7/distutils/command/bdist_wininst.py                                                0100644 0000000 0000000 00000035533 12734733743 021316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program."""

__revision__ = "$Id$"

import sys
import os
import string

from sysconfig import get_python_version

from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils.errors import DistutilsOptionError, DistutilsPlatformError
from distutils.errors import DistutilsFileError
from distutils import log
from distutils.util import get_platform

class bdist_wininst (Command):

    description = "create an executable installer for MS Windows"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('bitmap=', 'b',
                     "bitmap to use for the installer instead of python-powered logo"),
                    ('title=', 't',
                     "title to display on the installer background instead of default"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                    ('user-access-control=', None,
                     "specify Vista's UAC handling - 'none'/default=no "
                     "handling, 'auto'=use UAC if target Python installed for "
                     "all users, 'force'=always use UAC"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    def initialize_options (self):
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.no_target_compile = 0
        self.no_target_optimize = 0
        self.target_version = None
        self.dist_dir = None
        self.bitmap = None
        self.title = None
        self.skip_build = None
        self.install_script = None
        self.pre_install_script = None
        self.user_access_control = None

    # initialize_options()


    def finalize_options (self):
        self.set_undefined_options('bdist', ('skip_build', 'skip_build'))

        if self.bdist_dir is None:
            if self.skip_build and self.plat_name:
                # If build is skipped and plat_name is overridden, bdist will
                # not see the correct 'plat_name' - so set that up manually.
                bdist = self.distribution.get_command_obj('bdist')
                bdist.plat_name = self.plat_name
                # next the command will be initialized using that name
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'wininst')

        if not self.target_version:
            self.target_version = ""

        if not self.skip_build and self.distribution.has_ext_modules():
            short_version = get_python_version()
            if self.target_version and self.target_version != short_version:
                raise DistutilsOptionError, \
                      "target version can only be %s, or the '--skip-build'" \
                      " option must be specified" % (short_version,)
            self.target_version = short_version

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                  )

        if self.install_script:
            for script in self.distribution.scripts:
                if self.install_script == os.path.basename(script):
                    break
            else:
                raise DistutilsOptionError, \
                      "install_script '%s' not found in scripts" % \
                      self.install_script
    # finalize_options()


    def run (self):
        if (sys.platform != "win32" and
            (self.distribution.has_ext_modules() or
             self.distribution.has_c_libraries())):
            raise DistutilsPlatformError \
                  ("distribution contains extensions and/or C libraries; "
                   "must be compiled on a Windows 32 platform")

        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.root = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0
        install.plat_name = self.plat_name

        install_lib = self.reinitialize_command('install_lib')
        # we do not want to include pyc or pyo files
        install_lib.compile = 0
        install_lib.optimize = 0

        if self.distribution.has_ext_modules():
            # If we are building an installer for a Python version other
            # than the one we are currently running, then we need to ensure
            # our build_lib reflects the other Python version rather than ours.
            # Note that for target_version!=sys.version, we must have skipped the
            # build step, so there is no issue with enforcing the build of this
            # version.
            target_version = self.target_version
            if not target_version:
                assert self.skip_build, "Should have already checked this"
                target_version = sys.version[0:3]
            plat_specifier = ".%s-%s" % (self.plat_name, target_version)
            build = self.get_finalized_command('build')
            build.build_lib = os.path.join(build.build_base,
                                           'lib' + plat_specifier)

        # Use a custom scheme for the zip-file, because we have to decide
        # at installation time which scheme to use.
        for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):
            value = string.upper(key)
            if key == 'headers':
                value = value + '/Include/$dist_name'
            setattr(install,
                    'install_' + key,
                    value)

        log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()

        # avoid warning of 'install_lib' about installing
        # into a directory not in sys.path
        sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

        install.run()

        del sys.path[0]

        # And make an archive relative to the root of the
        # pseudo-installation tree.
        from tempfile import mktemp
        archive_basename = mktemp()
        fullname = self.distribution.get_fullname()
        arcname = self.make_archive(archive_basename, "zip",
                                    root_dir=self.bdist_dir)
        # create an exe containing the zip-file
        self.create_exe(arcname, fullname, self.bitmap)
        if self.distribution.has_ext_modules():
            pyversion = get_python_version()
        else:
            pyversion = 'any'
        self.distribution.dist_files.append(('bdist_wininst', pyversion,
                                             self.get_installer_filename(fullname)))
        # remove the zip-file again
        log.debug("removing temporary file '%s'", arcname)
        os.remove(arcname)

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)

    # run()

    def get_inidata (self):
        # Return data describing the installation.

        lines = []
        metadata = self.distribution.metadata

        # Write the [metadata] section.
        lines.append("[metadata]")

        # 'info' will be displayed in the installer's dialog box,
        # describing the items to be installed.
        info = (metadata.long_description or '') + '\n'

        # Escape newline characters
        def escape(s):
            return string.replace(s, "\n", "\\n")

        for name in ["author", "author_email", "description", "maintainer",
                     "maintainer_email", "name", "url", "version"]:
            data = getattr(metadata, name, "")
            if data:
                info = info + ("\n    %s: %s" % \
                               (string.capitalize(name), escape(data)))
                lines.append("%s=%s" % (name, escape(data)))

        # The [setup] section contains entries controlling
        # the installer runtime.
        lines.append("\n[Setup]")
        if self.install_script:
            lines.append("install_script=%s" % self.install_script)
        lines.append("info=%s" % escape(info))
        lines.append("target_compile=%d" % (not self.no_target_compile))
        lines.append("target_optimize=%d" % (not self.no_target_optimize))
        if self.target_version:
            lines.append("target_version=%s" % self.target_version)
        if self.user_access_control:
            lines.append("user_access_control=%s" % self.user_access_control)

        title = self.title or self.distribution.get_fullname()
        lines.append("title=%s" % escape(title))
        import time
        import distutils
        build_info = "Built %s with distutils-%s" % \
                     (time.ctime(time.time()), distutils.__version__)
        lines.append("build_info=%s" % build_info)
        return string.join(lines, "\n")

    # get_inidata()

    def create_exe (self, arcname, fullname, bitmap=None):
        import struct

        self.mkpath(self.dist_dir)

        cfgdata = self.get_inidata()

        installer_name = self.get_installer_filename(fullname)
        self.announce("creating %s" % installer_name)

        if bitmap:
            bitmapdata = open(bitmap, "rb").read()
            bitmaplen = len(bitmapdata)
        else:
            bitmaplen = 0

        file = open(installer_name, "wb")
        file.write(self.get_exe_bytes())
        if bitmap:
            file.write(bitmapdata)

        # Convert cfgdata from unicode to ascii, mbcs encoded
        try:
            unicode
        except NameError:
            pass
        else:
            if isinstance(cfgdata, unicode):
                cfgdata = cfgdata.encode("mbcs")

        # Append the pre-install script
        cfgdata = cfgdata + "\0"
        if self.pre_install_script:
            script_data = open(self.pre_install_script, "r").read()
            cfgdata = cfgdata + script_data + "\n\0"
        else:
            # empty pre-install script
            cfgdata = cfgdata + "\0"
        file.write(cfgdata)

        # The 'magic number' 0x1234567B is used to make sure that the
        # binary layout of 'cfgdata' is what the wininst.exe binary
        # expects.  If the layout changes, increment that number, make
        # the corresponding changes to the wininst.exe sources, and
        # recompile them.
        header = struct.pack("<iii",
                             0x1234567B,       # tag
                             len(cfgdata),     # length
                             bitmaplen,        # number of bytes in bitmap
                             )
        file.write(header)
        file.write(open(arcname, "rb").read())

    # create_exe()

    def get_installer_filename(self, fullname):
        # Factored out to allow overriding in subclasses
        if self.target_version:
            # if we create an installer for a specific python version,
            # it's better to include this in the name
            installer_name = os.path.join(self.dist_dir,
                                          "%s.%s-py%s.exe" %
                                           (fullname, self.plat_name, self.target_version))
        else:
            installer_name = os.path.join(self.dist_dir,
                                          "%s.%s.exe" % (fullname, self.plat_name))
        return installer_name
    # get_installer_filename()

    def get_exe_bytes (self):
        from distutils.msvccompiler import get_build_version
        # If a target-version other than the current version has been
        # specified, then using the MSVC version from *this* build is no good.
        # Without actually finding and executing the target version and parsing
        # its sys.version, we just hard-code our knowledge of old versions.
        # NOTE: Possible alternative is to allow "--target-version" to
        # specify a Python executable rather than a simple version string.
        # We can then execute this program to obtain any info we need, such
        # as the real sys.version string for the build.
        cur_version = get_python_version()
        if self.target_version and self.target_version != cur_version:
            # If the target version is *later* than us, then we assume they
            # use what we use
            # string compares seem wrong, but are what sysconfig.py itself uses
            if self.target_version > cur_version:
                bv = get_build_version()
            else:
                if self.target_version < "2.4":
                    bv = 6.0
                else:
                    bv = 7.1
        else:
            # for current version - use authoritative check.
            bv = get_build_version()

        # wininst-x.y.exe is in the same directory as this file
        directory = os.path.dirname(__file__)
        # we must use a wininst-x.y.exe built with the same C compiler
        # used for python.  XXX What about mingw, borland, and so on?

        # if plat_name starts with "win" but is not "win32"
        # we want to strip "win" and leave the rest (e.g. -amd64)
        # for all other cases, we don't want any suffix
        if self.plat_name != 'win32' and self.plat_name[:3] == 'win':
            sfix = self.plat_name[3:]
        else:
            sfix = ''

        filename = os.path.join(directory, "wininst-%.1f%s.exe" % (bv, sfix))
        try:
            f = open(filename, "rb")
        except IOError, msg:
            raise DistutilsFileError, str(msg) + ', %s not included in the Debian packages.' % filename
        try:
            return f.read()
        finally:
            f.close()
# class bdist_wininst
                                                                                                                                                                     usr/lib/python2.7/distutils/command/bdist_wininst.pyc                                               0100644 0000000 0000000 00000025307 13077704274 021455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s¿   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z m Z d d l m Z d d	 l m Z d d
 l m Z d e f d Ñ  É  YZ d S(   sz   distutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program.s   $Id$iˇˇˇˇN(   t   get_python_version(   t   Command(   t   remove_tree(   t   DistutilsOptionErrort   DistutilsPlatformError(   t   DistutilsFileError(   t   log(   t   get_platformt   bdist_wininstc           B   sπ   e  Z d  Z d, d d d e É  f d d d d	 f d
 d+ d d f d- d. d/ d0 d1 d2 d3 d4 d5 g Z d d d d g Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z	 d' Ñ  Z
 d+ d( Ñ Z d) Ñ  Z d* Ñ  Z RS(6   s-   create an executable installer for MS Windowss
   bdist-dir=s1   temporary directory for creating the distributions
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s	   keep-tempt   ks/   keep the pseudo-installation tree around after s!   creating the distribution archives   target-version=s!   require a specific python versions    on the target systems   no-target-compilet   cs/   do not compile .py to .pyc on the target systems   no-target-optimizet   os:   do not compile .py to .pyo (optimized)on the target systems	   dist-dir=t   ds-   directory to put final built distributions ins   bitmap=t   bs>   bitmap to use for the installer instead of python-powered logos   title=t   ts?   title to display on the installer background instead of defaults
   skip-builds2   skip rebuilding everything (for testing/debugging)s   install-script=sT   basename of installation script to be run afterinstallation or before deinstallations   pre-install-script=s{   Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distributions   user-access-control=sä   specify Vista's UAC handling - 'none'/default=no handling, 'auto'=use UAC if target Python installed for all users, 'force'=always use UACc         C   sy   d  |  _ d  |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet	   bdist_dirt	   plat_namet	   keep_tempt   no_target_compilet   no_target_optimizet   target_versiont   dist_dirt   bitmapt   titlet
   skip_buildt   install_scriptt   pre_install_scriptt   user_access_control(   t   self(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   initialize_optionsA   s    												c         C   sV  |  j  d d	 É |  j d  k r |  j rR |  j rR |  j j d É } |  j | _ n  |  j d É j } t	 j
 j | d É |  _ n  |  j sî d |  _ n  |  j rÌ |  j j É  rÌ t É  } |  j r· |  j | k r· t d | f Ç n  | |  _ n  |  j  d d
 d É |  j rRxF |  j j D]% } |  j t	 j
 j | É k rPqqWt d |  j Ç n  d  S(   Nt   bdistR   t   wininstt    sM   target version can only be %s, or the '--skip-build' option must be specifiedR   R   s(   install_script '%s' not found in scripts(   s
   skip_builds
   skip_build(   s   dist_dirs   dist_dir(   s	   plat_names	   plat_name(   t   set_undefined_optionsR   R   R   R   t   distributiont   get_command_objt   get_finalized_commandt
   bdist_baset   ost   patht   joinR   t   has_ext_modulesR    R   R   t   scriptst   basename(   R   R    R'   t   short_versiont   script(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   finalize_optionsS   s4    				c         C   s«  t  j d k r< |  j j É  s- |  j j É  r< t d É Ç n  |  j sU |  j d É n  |  j d d d É} |  j	 | _
 |  j | _ d | _ |  j | _ |  j d É } d | _ d | _ |  j j É  rB|  j } | s˛ |  j sÎ t d	 É Ç t  j d d
 !} n  d |  j | f } |  j d É } t j j | j d | É | _ n  xJ d D]B } t j | É } | d k rw| d } n  t | d | | É qIWt j d |  j	 É | j É  t  j j d t j j |  j	 d É É | j É  t  j d =d d l  m! } | É  }	 |  j j" É  }
 |  j# |	 d d |  j	 É} |  j$ | |
 |  j% É |  j j É  rYt& É  } n d } |  j j' j( d | |  j) |
 É f É t j* d | É t j+ | É |  j, s√t- |  j	 d |  j. Én  d  S(   Nt   win32s^   distribution contains extensions and/or C libraries; must be compiled on a Windows 32 platformt   buildt   installt   reinit_subcommandsi   i    t   install_libs    Should have already checked thisi   s   .%s-%st   libt   purelibt   platlibt   headersR,   t   datas   /Include/$dist_namet   install_s   installing to %st   PURELIBiˇˇˇˇ(   t   mktempt   zipt   root_dirt   anyR   s   removing temporary file '%s't   dry_run(   R7   R8   R9   s   scriptss   data(/   t   syst   platformR$   R+   t   has_c_librariesR   R   t   run_commandt   reinitialize_commandR   t   roott   warn_dirR   t   compilet   optimizeR   t   AssertionErrort   versionR&   R(   R)   R*   t
   build_baset	   build_libt   stringt   uppert   setattrR   t   infot   ensure_finalizedt   insertt   runt   tempfileR=   t   get_fullnamet   make_archivet
   create_exeR   R    t
   dist_filest   appendt   get_installer_filenamet   debugt   removeR   R   RA   (   R   R3   R5   R   t   plat_specifierR2   t   keyt   valueR=   t   archive_basenamet   fullnamet   arcnamet	   pyversion(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyRU   {   sf    					
%

		c         C   s˜  g  } |  j  j } | j d É | j p+ d d } d Ñ  } xÅ d d d d d	 d
 d d g D]a } t | | d É } | rZ | d t j | É | | É f } | j d | | | É f É qZ qZ W| j d É |  j rÏ | j d |  j É n  | j d | | É É | j d |  j É | j d |  j	 É |  j
 rM| j d |  j
 É n  |  j rm| j d |  j É n  |  j pÇ|  j  j É  } | j d | | É É d d  l } d d  l }	 d | j | j É  É |	 j f }
 | j d |
 É t j | d É S(   Ns
   [metadata]R"   s   
c         S   s   t  j |  d d É S(   Ns   
s   \n(   RO   t   replace(   t   s(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   escape‹   s    t   authort   author_emailt   descriptiont
   maintainert   maintainer_emailt   namet   urlRL   s   
    %s: %ss   %s=%ss   
[Setup]s   install_script=%ss   info=%ss   target_compile=%ds   target_optimize=%ds   target_version=%ss   user_access_control=%ss   title=%siˇˇˇˇs   Built %s with distutils-%ss   build_info=%s(   R$   t   metadataR[   t   long_descriptiont   getattrRO   t
   capitalizeR   R   R   R   R   R   RW   t   timet	   distutilst   ctimet   __version__R*   (   R   t   linesRp   RR   Rh   Rn   R:   R   Rt   Ru   t
   build_info(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   get_inidataŒ   s<    	$			c         C   sã  d d  l  } |  j |  j É |  j É  } |  j | É } |  j d | É | rr t | d É j É  } t | É } n d } t | d É }	 |	 j	 |  j
 É  É | r∞ |	 j	 | É n  y t Wn t k
 rÀ n" Xt | t É rÌ | j d É } n  | d } |  j r)t |  j d É j É  }
 | |
 d	 } n
 | d } |	 j	 | É | j d
 d t | É | É } |	 j	 | É |	 j	 t | d É j É  É d  S(   Niˇˇˇˇs   creating %st   rbi    t   wbt   mbcst    t   rs   
 s   <iiii{V4(   t   structt   mkpathR   Rz   R\   t   announcet   opent   readt   lent   writet   get_exe_bytest   unicodet	   NameErrort
   isinstancet   encodeR   t   pack(   R   Rd   Rc   R   RÄ   t   cfgdatat   installer_namet
   bitmapdatat	   bitmaplent   filet   script_datat   header(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyRY   ˇ   s>    
	
			c         C   s`   |  j  r7 t j j |  j d | |  j |  j  f É } n% t j j |  j d | |  j f É } | S(   Ns   %s.%s-py%s.exes	   %s.%s.exe(   R   R(   R)   R*   R   R   (   R   Rc   Ré   (    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyR\   6  s    	c   	      C   s?  d d l  m } t É  } |  j rm |  j | k rm |  j | k rL | É  } qv |  j d k  rd d } qv d } n	 | É  } t j j t É } |  j d k r∫ |  j d  d k r∫ |  j d } n d	 } t j j	 | d
 | | f É } y t
 | d É } Wn* t k
 r} t t | É d | Ç n Xz | j É  SWd  | j É  Xd  S(   Niˇˇˇˇ(   t   get_build_versions   2.4g      @gffffff@R1   i   t   winR"   s   wininst-%.1f%s.exeR{   s)   , %s not included in the Debian packages.(   t   distutils.msvccompilerRî   R    R   R(   R)   t   dirnamet   __file__R   R*   RÉ   t   IOErrorR   t   strRÑ   t   close(	   R   Rî   t   cur_versiont   bvt	   directoryt   sfixt   filenamet   ft   msg(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyRá   D  s*    					"N(   s
   bdist-dir=Ns1   temporary directory for creating the distribution(   s   no-target-compileR   s/   do not compile .py to .pyc on the target system(   s   no-target-optimizeR   s:   do not compile .py to .pyo (optimized)on the target system(   s	   dist-dir=R   s-   directory to put final built distributions in(   s   bitmap=R   s>   bitmap to use for the installer instead of python-powered logo(   s   title=R   s?   title to display on the installer background instead of default(   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   install-script=NsT   basename of installation script to be run afterinstallation or before deinstallation(   s   pre-install-script=Ns{   Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distribution(   s   user-access-control=Nsä   specify Vista's UAC handling - 'none'/default=no handling, 'auto'=use UAC if target Python installed for all users, 'force'=always use UAC(   t   __name__t
   __module__Rk   R   R   t   user_optionst   boolean_optionsR   R0   RU   Rz   RY   R\   Rá   (    (    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyR      sN    
         					(	S	17	(   t   __doc__t   __revision__RB   R(   RO   t	   sysconfigR    t   distutils.coreR   t   distutils.dir_utilR   t   distutils.errorsR   R   R   Ru   R   t   distutils.utilR   R   (    (    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   <module>   s                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/distutils/command/build.py                                                        0100644 0000000 0000000 00000012574 12734733743 017535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.build

Implements the Distutils 'build' command."""

__revision__ = "$Id$"

import sys, os

from distutils.util import get_platform
from distutils.core import Command
from distutils.errors import DistutilsOptionError

def show_compilers():
    from distutils.ccompiler import show_compilers
    show_compilers()

class build(Command):

    description = "build everything needed to install"

    user_options = [
        ('build-base=', 'b',
         "base directory for build library"),
        ('build-purelib=', None,
         "build directory for platform-neutral distributions"),
        ('build-platlib=', None,
         "build directory for platform-specific distributions"),
        ('build-lib=', None,
         "build directory for all distribution (defaults to either " +
         "build-purelib or build-platlib"),
        ('build-scripts=', None,
         "build directory for scripts"),
        ('build-temp=', 't',
         "temporary build directory"),
        ('plat-name=', 'p',
         "platform name to build for, if supported "
         "(default: %s)" % get_platform()),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('debug', 'g',
         "compile extensions and libraries with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('executable=', 'e',
         "specify final destination interpreter path (build.py)"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options(self):
        self.build_base = 'build'
        # these are decided only after 'build_base' has its final value
        # (unless overridden by the user or client)
        self.build_purelib = None
        self.build_platlib = None
        self.build_lib = None
        self.build_temp = None
        self.build_scripts = None
        self.compiler = None
        self.plat_name = None
        self.debug = None
        self.force = 0
        self.executable = None

    def finalize_options(self):
        if self.plat_name is None:
            self.plat_name = get_platform()
        else:
            # plat-name only supported for windows (other platforms are
            # supported via ./configure flags, if at all).  Avoid misleading
            # other platforms.
            if os.name != 'nt':
                raise DistutilsOptionError(
                            "--plat-name only supported on Windows (try "
                            "using './configure --help' on your platform)")

        plat_specifier = ".%s-%s" % (self.plat_name, sys.version[0:3])

        # Make it so Python 2.x and Python 2.x with --with-pydebug don't
        # share the same build directories. Doing so confuses the build
        # process for C modules
        if hasattr(sys, 'gettotalrefcount'):
            plat_specifier += '-pydebug'

        # 'build_purelib' and 'build_platlib' just default to 'lib' and
        # 'lib.<plat>' under the base build directory.  We only use one of
        # them for a given distribution, though --
        if self.build_purelib is None:
            self.build_purelib = os.path.join(self.build_base,
                                              'lib' + plat_specifier)
        if self.build_platlib is None:
            self.build_platlib = os.path.join(self.build_base,
                                              'lib' + plat_specifier)

        # 'build_lib' is the actual directory that we will use for this
        # particular module distribution -- if user didn't supply it, pick
        # one of 'build_purelib' or 'build_platlib'.
        if self.build_lib is None:
            if self.distribution.ext_modules:
                self.build_lib = self.build_platlib
            else:
                self.build_lib = self.build_purelib

        # 'build_temp' -- temporary directory for compiler turds,
        # "build/temp.<plat>"
        if self.build_temp is None:
            self.build_temp = os.path.join(self.build_base,
                                           'temp' + plat_specifier)
        if self.build_scripts is None:
            self.build_scripts = os.path.join(self.build_base,
                                              'scripts-' + sys.version[0:3])

        if self.executable is None:
            self.executable = os.path.normpath(sys.executable)

    def run(self):
        # Run all relevant sub-commands.  This will be some subset of:
        #  - build_py      - pure Python modules
        #  - build_clib    - standalone C libraries
        #  - build_ext     - Python extensions
        #  - build_scripts - (Python) scripts
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

    # -- Predicates for the sub-command list ---------------------------

    def has_pure_modules (self):
        return self.distribution.has_pure_modules()

    def has_c_libraries (self):
        return self.distribution.has_c_libraries()

    def has_ext_modules (self):
        return self.distribution.has_ext_modules()

    def has_scripts (self):
        return self.distribution.has_scripts()

    sub_commands = [('build_py',      has_pure_modules),
                    ('build_clib',    has_c_libraries),
                    ('build_ext',     has_ext_modules),
                    ('build_scripts', has_scripts),
                   ]
                                                                                                                                    usr/lib/python2.7/distutils/command/build.pyc                                                       0100644 0000000 0000000 00000012015 13077704274 017664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sw   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d Ñ  Z
 d e f d	 Ñ  É  YZ d S(
   sB   distutils.command.build

Implements the Distutils 'build' command.s   $Id$iˇˇˇˇN(   t   get_platform(   t   Command(   t   DistutilsOptionErrorc          C   s   d d l  m }  |  É  d  S(   Niˇˇˇˇ(   t   show_compilers(   t   distutils.ccompilerR   (   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR      s    t   buildc           B   s‹   e  Z d  Z d, d. d/ d d- d	 d
 f d0 d1 d d d e É  f d2 d3 d4 d5 g Z d d g Z d d- d  e f g Z d! Ñ  Z	 d" Ñ  Z
 d# Ñ  Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z d' Ñ  Z d( e f d) e f d* e f d+ e f g Z RS(6   s"   build everything needed to installs   build-base=t   bs    base directory for build librarys   build-purelib=s2   build directory for platform-neutral distributionss   build-platlib=s3   build directory for platform-specific distributionss
   build-lib=s9   build directory for all distribution (defaults to either s   build-purelib or build-platlibs   build-scripts=s   build directory for scriptss   build-temp=t   ts   temporary build directorys
   plat-name=t   ps6   platform name to build for, if supported (default: %s)s	   compiler=t   cs   specify the compiler typet   debugt   gs;   compile extensions and libraries with debugging informationt   forcet   fs2   forcibly build everything (ignore file timestamps)s   executable=t   es5   specify final destination interpreter path (build.py)s   help-compilers   list available compilersc         C   sg   d |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d |  _
 d  |  _ d  S(   NR   i    (   t
   build_baset   Nonet   build_purelibt   build_platlibt	   build_libt
   build_tempt   build_scriptst   compilert	   plat_nameR
   R   t
   executable(   t   self(    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   initialize_options7   s    										c         C   s™  |  j  d  k r t É  |  _  n t j d k r< t d É Ç n  d |  j  t j d d !f } t t d É ru | d 7} n  |  j	 d  k r¶ t j
 j |  j d | É |  _	 n  |  j d  k r◊ t j
 j |  j d | É |  _ n  |  j d  k r|  j j r|  j |  _ q|  j	 |  _ n  |  j d  k rAt j
 j |  j d	 | É |  _ n  |  j d  k r|t j
 j |  j d
 t j d d !É |  _ n  |  j d  k r¶t j
 j t j É |  _ n  d  S(   Nt   ntsW   --plat-name only supported on Windows (try using './configure --help' on your platform)s   .%s-%si    i   t   gettotalrefcounts   -pydebugt   libt   temps   scripts-(   R   R   R    t   ost   nameR   t   syst   versiont   hasattrR   t   patht   joinR   R   R   t   distributiont   ext_modulesR   R   R   t   normpath(   R   t   plat_specifier(    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   finalize_optionsF   s4    c         C   s(   x! |  j  É  D] } |  j | É q Wd  S(   N(   t   get_sub_commandst   run_command(   R   t   cmd_name(    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   runy   s    c         C   s   |  j  j É  S(   N(   R&   t   has_pure_modules(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR/   Ñ   s    c         C   s   |  j  j É  S(   N(   R&   t   has_c_libraries(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR0   á   s    c         C   s   |  j  j É  S(   N(   R&   t   has_ext_modules(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR1   ä   s    c         C   s   |  j  j É  S(   N(   R&   t   has_scripts(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR2   ç   s    t   build_pyt
   build_clibt	   build_extR   (   s   build-base=R   s    base directory for build libraryN(   s   build-purelib=Ns2   build directory for platform-neutral distributions(   s   build-platlib=Ns3   build directory for platform-specific distributions(   s   build-scripts=Ns   build directory for scripts(   s   build-temp=R   s   temporary build directory(   s	   compiler=R	   s   specify the compiler type(   s   debugR   s;   compile extensions and libraries with debugging information(   s   forceR   s2   forcibly build everything (ignore file timestamps)(   s   executable=R   s5   specify final destination interpreter path (build.py)(   t   __name__t
   __module__t   descriptionR   R    t   user_optionst   boolean_optionsR   t   help_optionsR   R*   R.   R/   R0   R1   R2   t   sub_commands(    (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR      sN        
    			3								(   t   __doc__t   __revision__R!   R   t   distutils.utilR    t   distutils.coreR   t   distutils.errorsR   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/distutils/command/build_clib.py                                                   0100644 0000000 0000000 00000017703 12734733743 020525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module."""

__revision__ = "$Id$"


# XXX this module has *lots* of code ripped-off quite transparently from
# build_ext.py -- not surprisingly really, as the work required to build
# a static library from a collection of C source files is not really all
# that different from what's required to build a shared object file from
# a collection of C source files.  Nevertheless, I haven't done the
# necessary refactoring to account for the overlap in code between the
# two modules, mainly because a number of subtle details changed in the
# cut 'n paste.  Sigh.

import os
from distutils.core import Command
from distutils.errors import DistutilsSetupError
from distutils.sysconfig import customize_compiler
from distutils import log

def show_compilers():
    from distutils.ccompiler import show_compilers
    show_compilers()


class build_clib(Command):

    description = "build C/C++ libraries used by Python extensions"

    user_options = [
        ('build-clib=', 'b',
         "directory to build C/C++ libraries to"),
        ('build-temp=', 't',
         "directory to put temporary build by-products"),
        ('debug', 'g',
         "compile with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options(self):
        self.build_clib = None
        self.build_temp = None

        # List of libraries to build
        self.libraries = None

        # Compilation options for all libraries
        self.include_dirs = None
        self.define = None
        self.undef = None
        self.debug = None
        self.force = 0
        self.compiler = None


    def finalize_options(self):
        # This might be confusing: both build-clib and build-temp default
        # to build-temp as defined by the "build" command.  This is because
        # I think that C libraries are really just temporary build
        # by-products, at least from the point of view of building Python
        # extensions -- but I want to keep my options open.
        self.set_undefined_options('build',
                                   ('build_temp', 'build_clib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'))

        self.libraries = self.distribution.libraries
        if self.libraries:
            self.check_library_list(self.libraries)

        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        # XXX same as for build_ext -- what about 'self.define' and
        # 'self.undef' ?

    def run(self):
        if not self.libraries:
            return

        # Yech -- this is cut 'n pasted from build_ext.py!
        from distutils.ccompiler import new_compiler
        self.compiler = new_compiler(compiler=self.compiler,
                                     dry_run=self.dry_run,
                                     force=self.force)
        customize_compiler(self.compiler)

        if self.include_dirs is not None:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for (name,value) in self.define:
                self.compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                self.compiler.undefine_macro(macro)

        self.build_libraries(self.libraries)


    def check_library_list(self, libraries):
        """Ensure that the list of libraries is valid.

        `library` is presumably provided as a command option 'libraries'.
        This method checks that it is a list of 2-tuples, where the tuples
        are (library_name, build_info_dict).

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        """
        if not isinstance(libraries, list):
            raise DistutilsSetupError, \
                  "'libraries' option must be a list of tuples"

        for lib in libraries:
            if not isinstance(lib, tuple) and len(lib) != 2:
                raise DistutilsSetupError, \
                      "each element of 'libraries' must a 2-tuple"

            name, build_info = lib

            if not isinstance(name, str):
                raise DistutilsSetupError, \
                      "first element of each tuple in 'libraries' " + \
                      "must be a string (the library name)"
            if '/' in name or (os.sep != '/' and os.sep in name):
                raise DistutilsSetupError, \
                      ("bad library name '%s': " +
                       "may not contain directory separators") % \
                      lib[0]

            if not isinstance(build_info, dict):
                raise DistutilsSetupError, \
                      "second element of each tuple in 'libraries' " + \
                      "must be a dictionary (build info)"

    def get_library_names(self):
        # Assume the library list is valid -- 'check_library_list()' is
        # called from 'finalize_options()', so it should be!
        if not self.libraries:
            return None

        lib_names = []
        for (lib_name, build_info) in self.libraries:
            lib_names.append(lib_name)
        return lib_names


    def get_source_files(self):
        self.check_library_list(self.libraries)
        filenames = []
        for (lib_name, build_info) in self.libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError, \
                      ("in 'libraries' option (library '%s'), "
                       "'sources' must be present and must be "
                       "a list of source filenames") % lib_name

            filenames.extend(sources)
        return filenames

    def build_libraries(self, libraries):
        for (lib_name, build_info) in libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError, \
                      ("in 'libraries' option (library '%s'), " +
                       "'sources' must be present and must be " +
                       "a list of source filenames") % lib_name
            sources = list(sources)

            log.info("building '%s' library", lib_name)

            # First, compile the source code to object files in the library
            # directory.  (This should probably change to putting object
            # files in a temporary build directory.)
            macros = build_info.get('macros')
            include_dirs = build_info.get('include_dirs')
            objects = self.compiler.compile(sources,
                                            output_dir=self.build_temp,
                                            macros=macros,
                                            include_dirs=include_dirs,
                                            debug=self.debug)

            # Now "link" the object files together into a static library.
            # (On Unix at least, this isn't really linking -- it just
            # builds an archive.  Whatever.)
            self.compiler.create_static_lib(objects, lib_name,
                                            output_dir=self.build_clib,
                                            debug=self.debug)
                                                             usr/lib/python2.7/distutils/command/build_clib.pyc                                                  0100644 0000000 0000000 00000014415 13077704274 020663  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s{   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d Ñ  Z d	 e f d
 Ñ  É  YZ d S(   s¥   distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module.s   $Id$iˇˇˇˇN(   t   Command(   t   DistutilsSetupError(   t   customize_compiler(   t   logc          C   s   d d l  m }  |  É  d  S(   Niˇˇˇˇ(   t   show_compilers(   t   distutils.ccompilerR   (   R   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR      s    t
   build_clibc           B   sÉ   e  Z d  Z d d d d d g Z d d
 g Z d d d e f g Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s/   build C/C++ libraries used by Python extensionss   build-clib=t   bs%   directory to build C/C++ libraries tos   build-temp=t   ts,   directory to put temporary build by-productst   debugt   gs"   compile with debugging informationt   forcet   fs2   forcibly build everything (ignore file timestamps)s	   compiler=t   cs   specify the compiler types   help-compilers   list available compilersc         C   sU   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _	 d  S(   Ni    (
   t   NoneR   t
   build_tempt	   librariest   include_dirst   definet   undefR	   R   t   compiler(   t   self(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   initialize_options6   s    								c         C   sü   |  j  d d d d	 d
 d É |  j j |  _ |  j rG |  j |  j É n  |  j d  k rn |  j j pe g  |  _ n  t |  j t É rõ |  j j t	 j
 É |  _ n  d  S(   Nt   buildR   R   R   R	   R   (   s
   build_temps
   build_clib(   s
   build_temps
   build_temp(   s   compilers   compiler(   s   debugs   debug(   s   forces   force(   t   set_undefined_optionst   distributionR   t   check_library_listR   R   t
   isinstancet   strt   splitt   ost   pathsep(   R   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   finalize_optionsF   s    		c         C   sˇ   |  j  s d  Sd d l m } | d |  j d |  j d |  j É |  _ t |  j É |  j d  k	 rv |  j j	 |  j É n  |  j
 d  k	 rµ x- |  j
 D] \ } } |  j j | | É qè Wn  |  j d  k	 rÎ x$ |  j D] } |  j j | É qŒ Wn  |  j |  j  É d  S(   Niˇˇˇˇ(   t   new_compilerR   t   dry_runR   (   R   R   R!   R   R"   R   R   R   R   t   set_include_dirsR   t   define_macroR   t   undefine_macrot   build_libraries(   R   R!   t   namet   valuet   macro(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   run_   s     		c         C   sÍ   t  | t É s t d Ç n  x» | D]¿ } t  | t É rV t | É d k rV t d Ç n  | \ } } t  | t É sÅ t d d Ç n  d | k s´ t j d k r√ t j | k r√ t d d | d	 Ç n  t  | t É s" t d
 d Ç q" q" Wd S(   s`  Ensure that the list of libraries is valid.

        `library` is presumably provided as a command option 'libraries'.
        This method checks that it is a list of 2-tuples, where the tuples
        are (library_name, build_info_dict).

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        s+   'libraries' option must be a list of tuplesi   s*   each element of 'libraries' must a 2-tuples+   first element of each tuple in 'libraries' s#   must be a string (the library name)t   /s   bad library name '%s': s$   may not contain directory separatorsi    s,   second element of each tuple in 'libraries' s!   must be a dictionary (build info)N(	   R   t   listR   t   tuplet   lenR   R   t   sept   dict(   R   R   t   libR'   t
   build_info(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR   w   s*    
	"	
*c         C   s>   |  j  s d  Sg  } x$ |  j  D] \ } } | j | É q W| S(   N(   R   R   t   append(   R   t	   lib_namest   lib_nameR2   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   get_library_namesõ   s    	c         C   sÇ   |  j  |  j É g  } xe |  j D]Z \ } } | j d É } | d  k s] t | t t f É rm t d | Ç n  | j | É q  W| S(   Nt   sourcessf   in 'libraries' option (library '%s'), 'sources' must be present and must be a list of source filenames(	   R   R   t   getR   R   R,   R-   R   t   extend(   R   t	   filenamesR5   R2   R7   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   get_source_filesß   s    "
c         C   sÛ   xÏ | D]‰ \ } } | j  d É } | d  k sD t | t t f É r\ t d d d | Ç n  t | É } t j d | É | j  d É } | j  d É } |  j j	 | d |  j
 d | d | d	 |  j É} |  j j | | d |  j d	 |  j Éq Wd  S(
   NR7   s&   in 'libraries' option (library '%s'), s&   'sources' must be present and must be s   a list of source filenamess   building '%s' libraryt   macrosR   t
   output_dirR	   (   R8   R   R   R,   R-   R   R   t   infoR   t   compileR   R	   t   create_static_libR   (   R   R   R5   R2   R7   R<   R   t   objects(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR&   µ   s$    "		(   s   build-clib=R   s%   directory to build C/C++ libraries to(   s   build-temp=R   s,   directory to put temporary build by-products(   s   debugR
   s"   compile with debugging information(   s   forceR   s2   forcibly build everything (ignore file timestamps)(   s	   compiler=R   s   specify the compiler typeN(   t   __name__t
   __module__t   descriptiont   user_optionst   boolean_optionsR   R   t   help_optionsR   R    R*   R   R6   R;   R&   (    (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR      s*        					$		(   t   __doc__t   __revision__R   t   distutils.coreR    t   distutils.errorsR   t   distutils.sysconfigR   t	   distutilsR   R   R   (    (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   <module>   s   	                                                                                                                                                                                                                                                   usr/lib/python2.7/distutils/command/build_ext.py                                                    0100644 0000000 0000000 00000076546 12734733743 020426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import sys, os, string, re
from types import *
from site import USER_BASE, USER_SITE
from distutils.core import Command
from distutils.errors import *
from distutils.sysconfig import customize_compiler, get_python_version
from distutils.dep_util import newer_group
from distutils.extension import Extension
from distutils.util import get_platform
from distutils import log

if os.name == 'nt':
    from distutils.msvccompiler import get_build_version
    MSVC_VERSION = int(get_build_version())

# An extension name is just a dot-separated list of Python NAMEs (ie.
# the same as a fully-qualified module name).
extension_name_re = re.compile \
    (r'^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$')


def show_compilers ():
    from distutils.ccompiler import show_compilers
    show_compilers()


class build_ext (Command):

    description = "build C/C++ extensions (compile/link to build directory)"

    # XXX thoughts on how to deal with complex command-line options like
    # these, i.e. how to make it so fancy_getopt can suck them off the
    # command line and make it look like setup.py defined the appropriate
    # lists of tuples of what-have-you.
    #   - each command needs a callback to process its command-line options
    #   - Command.__init__() needs access to its share of the whole
    #     command line (must ultimately come from
    #     Distribution.parse_command_line())
    #   - it then calls the current command class' option-parsing
    #     callback to deal with weird options like -D, which have to
    #     parse the option text and churn out some custom data
    #     structure
    #   - that data structure (in this case, a list of 2-tuples)
    #     will then be present in the command object by the time
    #     we get to finalize_options() (i.e. the constructor
    #     takes care of both command-line and client options
    #     in between initialize_options() and finalize_options())

    sep_by = " (separated by '%s')" % os.pathsep
    user_options = [
        ('build-lib=', 'b',
         "directory for compiled extension modules"),
        ('build-temp=', 't',
         "directory for temporary files (build by-products)"),
        ('plat-name=', 'p',
         "platform name to cross-compile for, if supported "
         "(default: %s)" % get_platform()),
        ('inplace', 'i',
         "ignore build-lib and put compiled extensions into the source " +
         "directory alongside your pure Python modules"),
        ('include-dirs=', 'I',
         "list of directories to search for header files" + sep_by),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries" + sep_by),
        ('rpath=', 'R',
         "directories to search for shared C libraries at runtime"),
        ('link-objects=', 'O',
         "extra explicit link objects to include in the link"),
        ('debug', 'g',
         "compile/link with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('swig-cpp', None,
         "make SWIG create C++ files (default is C)"),
        ('swig-opts=', None,
         "list of SWIG command line options"),
        ('swig=', None,
         "path to the SWIG executable"),
        ('user', None,
         "add user include, library and rpath"),
        ]

    boolean_options = ['inplace', 'debug', 'force', 'swig-cpp', 'user']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options (self):
        self.extensions = None
        self.build_lib = None
        self.plat_name = None
        self.build_temp = None
        self.inplace = 0
        self.package = None

        self.include_dirs = None
        self.define = None
        self.undef = None
        self.libraries = None
        self.library_dirs = None
        self.rpath = None
        self.link_objects = None
        self.debug = None
        self.force = None
        self.compiler = None
        self.swig = None
        self.swig_cpp = None
        self.swig_opts = None
        self.user = None

    def finalize_options(self):
        from distutils import sysconfig

        self.set_undefined_options('build',
                                   ('build_lib', 'build_lib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'),
                                   ('plat_name', 'plat_name'),
                                   )

        if self.package is None:
            self.package = self.distribution.ext_package

        self.extensions = self.distribution.ext_modules

        # Make sure Python's include directories (for Python.h, pyconfig.h,
        # etc.) are in the include search path.
        py_include = sysconfig.get_python_inc()
        plat_py_include = sysconfig.get_python_inc(plat_specific=1)
        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        # Put the Python "system" include dir at the end, so that
        # any local include dirs take precedence.
        self.include_dirs.append(py_include)
        if plat_py_include != py_include:
            self.include_dirs.append(plat_py_include)

        self.ensure_string_list('libraries')

        # Life is easier if we're not forever checking for None, so
        # simplify these options to empty lists if unset
        if self.libraries is None:
            self.libraries = []
        if self.library_dirs is None:
            self.library_dirs = []
        elif type(self.library_dirs) is StringType:
            self.library_dirs = string.split(self.library_dirs, os.pathsep)

        if self.rpath is None:
            self.rpath = []
        elif type(self.rpath) is StringType:
            self.rpath = string.split(self.rpath, os.pathsep)

        # for extensions under windows use different directories
        # for Release and Debug builds.
        # also Python's library directory must be appended to library_dirs
        if os.name == 'nt':
            # the 'libs' directory is for binary installs - we assume that
            # must be the *native* platform.  But we don't really support
            # cross-compiling via a binary install anyway, so we let it go.
            self.library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))
            if self.debug:
                self.build_temp = os.path.join(self.build_temp, "Debug")
            else:
                self.build_temp = os.path.join(self.build_temp, "Release")

            # Append the source distribution include and library directories,
            # this allows distutils on windows to work in the source tree
            self.include_dirs.append(os.path.join(sys.exec_prefix, 'PC'))
            if MSVC_VERSION == 9:
                # Use the .lib files for the correct architecture
                if self.plat_name == 'win32':
                    suffix = ''
                else:
                    # win-amd64 or win-ia64
                    suffix = self.plat_name[4:]
                new_lib = os.path.join(sys.exec_prefix, 'PCbuild')
                if suffix:
                    new_lib = os.path.join(new_lib, suffix)
                self.library_dirs.append(new_lib)

            elif MSVC_VERSION == 8:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VS8.0'))
            elif MSVC_VERSION == 7:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VS7.1'))
            else:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VC6'))

        # OS/2 (EMX) doesn't support Debug vs Release builds, but has the
        # import libraries in its "Config" subdirectory
        if os.name == 'os2':
            self.library_dirs.append(os.path.join(sys.exec_prefix, 'Config'))

        # for extensions under Cygwin and AtheOS Python's library directory must be
        # appended to library_dirs
        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos':
            if sys.executable.startswith(os.path.join(sys.exec_prefix, "bin")):
                # building third party extensions
                self.library_dirs.append(os.path.join(sys.prefix, "lib",
                                                      "python" + get_python_version(),
                                                      "config"))
            else:
                # building python standard extensions
                self.library_dirs.append('.')

        # For building extensions with a shared Python library,
        # Python's library directory must be appended to library_dirs
        # See Issues: #1600860, #4366
        if False and (sysconfig.get_config_var('Py_ENABLE_SHARED')):
            if not sysconfig.python_build:
                # building third party extensions
                self.library_dirs.append(sysconfig.get_config_var('LIBDIR'))
            else:
                # building python standard extensions
                self.library_dirs.append('.')

        # The argument parsing will result in self.define being a string, but
        # it has to be a list of 2-tuples.  All the preprocessor symbols
        # specified by the 'define' option will be set to '1'.  Multiple
        # symbols can be separated with commas.

        if self.define:
            defines = self.define.split(',')
            self.define = map(lambda symbol: (symbol, '1'), defines)

        # The option for macros to undefine is also a string from the
        # option parsing, but has to be a list.  Multiple symbols can also
        # be separated with commas here.
        if self.undef:
            self.undef = self.undef.split(',')

        if self.swig_opts is None:
            self.swig_opts = []
        else:
            self.swig_opts = self.swig_opts.split(' ')

        # Finally add the user include and library directories if requested
        if self.user:
            user_include = os.path.join(USER_BASE, "include")
            user_lib = os.path.join(USER_BASE, "lib")
            if os.path.isdir(user_include):
                self.include_dirs.append(user_include)
            if os.path.isdir(user_lib):
                self.library_dirs.append(user_lib)
                self.rpath.append(user_lib)

    def run(self):
        from distutils.ccompiler import new_compiler

        # 'self.extensions', as supplied by setup.py, is a list of
        # Extension instances.  See the documentation for Extension (in
        # distutils.extension) for details.
        #
        # For backwards compatibility with Distutils 0.8.2 and earlier, we
        # also allow the 'extensions' list to be a list of tuples:
        #    (ext_name, build_info)
        # where build_info is a dictionary containing everything that
        # Extension instances do except the name, with a few things being
        # differently named.  We convert these 2-tuples to Extension
        # instances as needed.

        if not self.extensions:
            return

        # If we were asked to build any C/C++ libraries, make sure that the
        # directory where we put them is in the library search path for
        # linking extensions.
        if self.distribution.has_c_libraries():
            build_clib = self.get_finalized_command('build_clib')
            self.libraries.extend(build_clib.get_library_names() or [])
            self.library_dirs.append(build_clib.build_clib)

        # Setup the CCompiler object that we'll use to do all the
        # compiling and linking
        self.compiler = new_compiler(compiler=self.compiler,
                                     verbose=self.verbose,
                                     dry_run=self.dry_run,
                                     force=self.force)
        customize_compiler(self.compiler)
        # If we are cross-compiling, init the compiler now (if we are not
        # cross-compiling, init would not hurt, but people may rely on
        # late initialization of compiler even if they shouldn't...)
        if os.name == 'nt' and self.plat_name != get_platform():
            self.compiler.initialize(self.plat_name)

        # And make sure that any compile/link-related options (which might
        # come from the command-line or from the setup script) are set in
        # that CCompiler object -- that way, they automatically apply to
        # all compiling and linking done here.
        if self.include_dirs is not None:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for (name, value) in self.define:
                self.compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                self.compiler.undefine_macro(macro)
        if self.libraries is not None:
            self.compiler.set_libraries(self.libraries)
        if self.library_dirs is not None:
            self.compiler.set_library_dirs(self.library_dirs)
        if self.rpath is not None:
            self.compiler.set_runtime_library_dirs(self.rpath)
        if self.link_objects is not None:
            self.compiler.set_link_objects(self.link_objects)

        # Now actually compile and link everything.
        self.build_extensions()

    def check_extensions_list(self, extensions):
        """Ensure that the list of extensions (presumably provided as a
        command option 'extensions') is valid, i.e. it is a list of
        Extension objects.  We also support the old-style list of 2-tuples,
        where the tuples are (ext_name, build_info), which are converted to
        Extension instances here.

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        """
        if not isinstance(extensions, list):
            raise DistutilsSetupError, \
                  "'ext_modules' option must be a list of Extension instances"

        for i, ext in enumerate(extensions):
            if isinstance(ext, Extension):
                continue                # OK! (assume type-checking done
                                        # by Extension constructor)

            if not isinstance(ext, tuple) or len(ext) != 2:
                raise DistutilsSetupError, \
                      ("each element of 'ext_modules' option must be an "
                       "Extension instance or 2-tuple")

            ext_name, build_info = ext

            log.warn(("old-style (ext_name, build_info) tuple found in "
                      "ext_modules for extension '%s'"
                      "-- please convert to Extension instance" % ext_name))

            if not (isinstance(ext_name, str) and
                    extension_name_re.match(ext_name)):
                raise DistutilsSetupError, \
                      ("first element of each tuple in 'ext_modules' "
                       "must be the extension name (a string)")

            if not isinstance(build_info, dict):
                raise DistutilsSetupError, \
                      ("second element of each tuple in 'ext_modules' "
                       "must be a dictionary (build info)")

            # OK, the (ext_name, build_info) dict is type-safe: convert it
            # to an Extension instance.
            ext = Extension(ext_name, build_info['sources'])

            # Easy stuff: one-to-one mapping from dict elements to
            # instance attributes.
            for key in ('include_dirs', 'library_dirs', 'libraries',
                        'extra_objects', 'extra_compile_args',
                        'extra_link_args'):
                val = build_info.get(key)
                if val is not None:
                    setattr(ext, key, val)

            # Medium-easy stuff: same syntax/semantics, different names.
            ext.runtime_library_dirs = build_info.get('rpath')
            if 'def_file' in build_info:
                log.warn("'def_file' element of build info dict "
                         "no longer supported")

            # Non-trivial stuff: 'macros' split into 'define_macros'
            # and 'undef_macros'.
            macros = build_info.get('macros')
            if macros:
                ext.define_macros = []
                ext.undef_macros = []
                for macro in macros:
                    if not (isinstance(macro, tuple) and len(macro) in (1, 2)):
                        raise DistutilsSetupError, \
                              ("'macros' element of build info dict "
                               "must be 1- or 2-tuple")
                    if len(macro) == 1:
                        ext.undef_macros.append(macro[0])
                    elif len(macro) == 2:
                        ext.define_macros.append(macro)

            extensions[i] = ext

    def get_source_files(self):
        self.check_extensions_list(self.extensions)
        filenames = []

        # Wouldn't it be neat if we knew the names of header files too...
        for ext in self.extensions:
            filenames.extend(ext.sources)

        return filenames

    def get_outputs(self):
        # Sanity check the 'extensions' list -- can't assume this is being
        # done in the same run as a 'build_extensions()' call (in fact, we
        # can probably assume that it *isn't*!).
        self.check_extensions_list(self.extensions)

        # And build the list of output (built) filenames.  Note that this
        # ignores the 'inplace' flag, and assumes everything goes in the
        # "build" tree.
        outputs = []
        for ext in self.extensions:
            outputs.append(self.get_ext_fullpath(ext.name))
        return outputs

    def build_extensions(self):
        # First, sanity-check the 'extensions' list
        self.check_extensions_list(self.extensions)

        for ext in self.extensions:
            self.build_extension(ext)

    def build_extension(self, ext):
        sources = ext.sources
        if sources is None or type(sources) not in (ListType, TupleType):
            raise DistutilsSetupError, \
                  ("in 'ext_modules' option (extension '%s'), " +
                   "'sources' must be present and must be " +
                   "a list of source filenames") % ext.name
        sources = list(sources)

        ext_path = self.get_ext_fullpath(ext.name)
        depends = sources + ext.depends
        if not (self.force or newer_group(depends, ext_path, 'newer')):
            log.debug("skipping '%s' extension (up-to-date)", ext.name)
            return
        else:
            log.info("building '%s' extension", ext.name)

        # First, scan the sources for SWIG definition files (.i), run
        # SWIG on 'em to create .c files, and modify the sources list
        # accordingly.
        sources = self.swig_sources(sources, ext)

        # Next, compile the source code to object files.

        # XXX not honouring 'define_macros' or 'undef_macros' -- the
        # CCompiler API needs to change to accommodate this, and I
        # want to do one thing at a time!

        # Two possible sources for extra compiler arguments:
        #   - 'extra_compile_args' in Extension object
        #   - CFLAGS environment variable (not particularly
        #     elegant, but people seem to expect it and I
        #     guess it's useful)
        # The environment variable should take precedence, and
        # any sensible compiler will give precedence to later
        # command line args.  Hence we combine them in order:
        extra_args = ext.extra_compile_args or []

        macros = ext.define_macros[:]
        for undef in ext.undef_macros:
            macros.append((undef,))

        objects = self.compiler.compile(sources,
                                         output_dir=self.build_temp,
                                         macros=macros,
                                         include_dirs=ext.include_dirs,
                                         debug=self.debug,
                                         extra_postargs=extra_args,
                                         depends=ext.depends)

        # XXX -- this is a Vile HACK!
        #
        # The setup.py script for Python on Unix needs to be able to
        # get this list so it can perform all the clean up needed to
        # avoid keeping object files around when cleaning out a failed
        # build of an extension module.  Since Distutils does not
        # track dependencies, we have to get rid of intermediates to
        # ensure all the intermediates will be properly re-built.
        #
        self._built_objects = objects[:]

        # Now link the object files together into a "shared object" --
        # of course, first we have to figure out all the other things
        # that go into the mix.
        if ext.extra_objects:
            objects.extend(ext.extra_objects)
        extra_args = ext.extra_link_args or []

        # Detect target language, if not provided
        language = ext.language or self.compiler.detect_language(sources)

        self.compiler.link_shared_object(
            objects, ext_path,
            libraries=self.get_libraries(ext),
            library_dirs=ext.library_dirs,
            runtime_library_dirs=ext.runtime_library_dirs,
            extra_postargs=extra_args,
            export_symbols=self.get_export_symbols(ext),
            debug=self.debug,
            build_temp=self.build_temp,
            target_lang=language)


    def swig_sources (self, sources, extension):

        """Walk the list of source files in 'sources', looking for SWIG
        interface (.i) files.  Run SWIG on all that are found, and
        return a modified 'sources' list with SWIG source files replaced
        by the generated C (or C++) files.
        """

        new_sources = []
        swig_sources = []
        swig_targets = {}

        # XXX this drops generated C/C++ files into the source tree, which
        # is fine for developers who want to distribute the generated
        # source -- but there should be an option to put SWIG output in
        # the temp dir.

        if self.swig_cpp:
            log.warn("--swig-cpp is deprecated - use --swig-opts=-c++")

        if self.swig_cpp or ('-c++' in self.swig_opts) or \
           ('-c++' in extension.swig_opts):
            target_ext = '.cpp'
        else:
            target_ext = '.c'

        for source in sources:
            (base, ext) = os.path.splitext(source)
            if ext == ".i":             # SWIG interface file
                new_sources.append(base + '_wrap' + target_ext)
                swig_sources.append(source)
                swig_targets[source] = new_sources[-1]
            else:
                new_sources.append(source)

        if not swig_sources:
            return new_sources

        swig = self.swig or self.find_swig()
        swig_cmd = [swig, "-python"]
        swig_cmd.extend(self.swig_opts)
        if self.swig_cpp:
            swig_cmd.append("-c++")

        # Do not override commandline arguments
        if not self.swig_opts:
            for o in extension.swig_opts:
                swig_cmd.append(o)

        for source in swig_sources:
            target = swig_targets[source]
            log.info("swigging %s to %s", source, target)
            self.spawn(swig_cmd + ["-o", target, source])

        return new_sources

    # swig_sources ()

    def find_swig (self):
        """Return the name of the SWIG executable.  On Unix, this is
        just "swig" -- it should be in the PATH.  Tries a bit harder on
        Windows.
        """

        if os.name == "posix":
            return "swig"
        elif os.name == "nt":

            # Look for SWIG in its standard installation directory on
            # Windows (or so I presume!).  If we find it there, great;
            # if not, act like Unix and assume it's in the PATH.
            for vers in ("1.3", "1.2", "1.1"):
                fn = os.path.join("c:\\swig%s" % vers, "swig.exe")
                if os.path.isfile(fn):
                    return fn
            else:
                return "swig.exe"

        elif os.name == "os2":
            # assume swig available in the PATH.
            return "swig.exe"

        else:
            raise DistutilsPlatformError, \
                  ("I don't know how to find (much less run) SWIG "
                   "on platform '%s'") % os.name

    # find_swig ()

    # -- Name generators -----------------------------------------------
    # (extension names, filenames, whatever)
    def get_ext_fullpath(self, ext_name):
        """Returns the path of the filename for a given extension.

        The file is located in `build_lib` or directly in the package
        (inplace option).
        """
        # makes sure the extension name is only using dots
        all_dots = string.maketrans('/'+os.sep, '..')
        ext_name = ext_name.translate(all_dots)

        fullname = self.get_ext_fullname(ext_name)
        modpath = fullname.split('.')
        filename = self.get_ext_filename(ext_name)
        filename = os.path.split(filename)[-1]

        if not self.inplace:
            # no further work needed
            # returning :
            #   build_dir/package/path/filename
            filename = os.path.join(*modpath[:-1]+[filename])
            return os.path.join(self.build_lib, filename)

        # the inplace option requires to find the package directory
        # using the build_py command for that
        package = '.'.join(modpath[0:-1])
        build_py = self.get_finalized_command('build_py')
        package_dir = os.path.abspath(build_py.get_package_dir(package))

        # returning
        #   package_dir/filename
        return os.path.join(package_dir, filename)

    def get_ext_fullname(self, ext_name):
        """Returns the fullname of a given extension name.

        Adds the `package.` prefix"""
        if self.package is None:
            return ext_name
        else:
            return self.package + '.' + ext_name

    def get_ext_filename(self, ext_name):
        r"""Convert the name of an extension (eg. "foo.bar") into the name
        of the file from which it will be loaded (eg. "foo/bar.so", or
        "foo\bar.pyd").
        """
        from distutils.sysconfig import get_config_var
        ext_path = string.split(ext_name, '.')
        # OS/2 has an 8 character module (extension) limit :-(
        if os.name == "os2":
            ext_path[len(ext_path) - 1] = ext_path[len(ext_path) - 1][:8]
        # extensions in debug_mode are named 'module_d.pyd' under windows
        so_ext = get_config_var('SO')
        if os.name == 'nt' and self.debug:
            return os.path.join(*ext_path) + '_d' + so_ext
        return os.path.join(*ext_path) + so_ext

    def get_export_symbols (self, ext):
        """Return the list of symbols that a shared extension has to
        export.  This either uses 'ext.export_symbols' or, if it's not
        provided, "init" + module_name.  Only relevant on Windows, where
        the .pyd file (DLL) must export the module "init" function.
        """
        initfunc_name = "init" + ext.name.split('.')[-1]
        if initfunc_name not in ext.export_symbols:
            ext.export_symbols.append(initfunc_name)
        return ext.export_symbols

    def get_libraries (self, ext):
        """Return the list of libraries to link against when building a
        shared extension.  On most platforms, this is just 'ext.libraries';
        on Windows and OS/2, we add the Python library (eg. python20.dll).
        """
        # The python library is always needed on Windows.  For MSVC, this
        # is redundant, since the library is mentioned in a pragma in
        # pyconfig.h that MSVC groks.  The other Windows compilers all seem
        # to need it mentioned explicitly, though, so that's what we do.
        # Append '_d' to the python import library on debug builds.
        if sys.platform == "win32":
            from distutils.msvccompiler import MSVCCompiler
            if not isinstance(self.compiler, MSVCCompiler):
                template = "python%d%d"
                if self.debug:
                    template = template + '_d'
                pythonlib = (template %
                       (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
                # don't extend ext.libraries, it may be shared with other
                # extensions, it is a reference to the original list
                return ext.libraries + [pythonlib]
            else:
                return ext.libraries
        elif sys.platform == "os2emx":
            # EMX/GCC requires the python library explicitly, and I
            # believe VACPP does as well (though not confirmed) - AIM Apr01
            template = "python%d%d"
            # debug versions of the main DLL aren't supported, at least
            # not at this time - AIM Apr01
            #if self.debug:
            #    template = template + '_d'
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        elif sys.platform[:6] == "cygwin":
            template = "python%d.%d"
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        elif sys.platform[:6] == "atheos":
            from distutils import sysconfig

            template = "python%d.%d"
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # Get SHLIBS from Makefile
            extra = []
            for lib in sysconfig.get_config_var('SHLIBS').split():
                if lib.startswith('-l'):
                    extra.append(lib[2:])
                else:
                    extra.append(lib)
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib, "m"] + extra

        elif sys.platform == 'darwin':
            # Don't use the default code below
            return ext.libraries
        elif sys.platform[:3] == 'aix':
            # Don't use the default code below
            return ext.libraries
        else:
            from distutils import sysconfig
            if False and sysconfig.get_config_var('Py_ENABLE_SHARED'):
                template = "python%d.%d"
                pythonlib = (template %
                             (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
                return ext.libraries + [pythonlib]
            else:
                return ext.libraries

# class build_ext
                                                                                                                                                          usr/lib/python2.7/distutils/command/build_ext.pyc                                                   0100644 0000000 0000000 00000045632 13077704274 020557  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s/  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l Td d l m Z m	 Z	 d d l
 m Z d d l Td d l m Z m Z d d l m Z d d	 l m Z d d
 l m Z d d l m Z e j d k r˝ d d l m Z e e É  É Z n  e j d É Z d Ñ  Z d e f d Ñ  É  YZ  d S(   s∂   distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP).s   $Id$iˇˇˇˇN(   t   *(   t	   USER_BASEt	   USER_SITE(   t   Command(   t   customize_compilert   get_python_version(   t   newer_group(   t	   Extension(   t   get_platform(   t   logt   nt(   t   get_build_versions3   ^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$c          C   s   d d l  m }  |  É  d  S(   Niˇˇˇˇ(   t   show_compilers(   t   distutils.ccompilerR   (   R   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR       s    t	   build_extc           B   s?  e  Z d  Z d e j Z dF dG d d	 d
 e É  f d d d d f d d d e f dH dI dJ d d d e f dK dL dM dN dO dQ dR dS dT g Z d d$ d' d- d3 g Z	 d5 dP d6 e
 f g Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z d< Ñ  Z d= Ñ  Z d> Ñ  Z d? Ñ  Z d@ Ñ  Z dA Ñ  Z dB Ñ  Z dC Ñ  Z dD Ñ  Z dE Ñ  Z RS(U   s8   build C/C++ extensions (compile/link to build directory)s    (separated by '%s')s
   build-lib=t   bs(   directory for compiled extension moduless   build-temp=t   ts1   directory for temporary files (build by-products)s
   plat-name=t   ps>   platform name to cross-compile for, if supported (default: %s)t   inplacet   is=   ignore build-lib and put compiled extensions into the source s,   directory alongside your pure Python moduless   include-dirs=t   Is.   list of directories to search for header filess   define=t   Ds   C preprocessor macros to defines   undef=t   Us!   C preprocessor macros to undefines
   libraries=t   ls!   external C libraries to link withs   library-dirs=t   Ls.   directories to search for external C librariess   rpath=t   Rs7   directories to search for shared C libraries at runtimes   link-objects=t   Os2   extra explicit link objects to include in the linkt   debugt   gs'   compile/link with debugging informationt   forcet   fs2   forcibly build everything (ignore file timestamps)s	   compiler=t   cs   specify the compiler types   swig-cpps)   make SWIG create C++ files (default is C)s
   swig-opts=s!   list of SWIG command line optionss   swig=s   path to the SWIG executablet   users#   add user include, library and rpaths   help-compilers   list available compilersc         C   s∏   d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet
   extensionst	   build_libt	   plat_namet
   build_tempR   t   packaget   include_dirst   definet   undeft	   librariest   library_dirst   rpatht   link_objectsR   R   t   compilert   swigt   swig_cppt	   swig_optsR    (   t   self(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   initialize_optionsl   s(    																			c   	   	   C   sã  d d l  m } |  j d d, d- d. d/ d0 d1 É |  j d  k rP |  j j |  _ n  |  j j |  _ | j	 É  } | j	 d
 d É } |  j
 d  k r§ |  j j
 põ g  |  _
 n  t |  j
 t É r— |  j
 j t j É |  _
 n  |  j
 j | É | | k r |  j
 j | É n  |  j d É |  j d  k r(g  |  _ n  |  j d  k rCg  |  _ n3 t |  j É t k rvt j |  j t j É |  _ n  |  j d  k rëg  |  _ n3 t |  j É t k rƒt j |  j t j É |  _ n  t j d k rc|  j j t j j t j d É É |  j rt j j |  j d É |  _ n t j j |  j d É |  _ |  j
 j t j j t j d É É t d k r”|  j  d k r}d } n |  j  d } t j j t j d É } | r¿t j j | | É } n  |  j j | É qct d k r|  j j t j j t j d d É É qct d k r;|  j j t j j t j d d É É qc|  j j t j j t j d d É É n  t j d k ró|  j j t j j t j d É É n  t j! d  d k sΩt j! d  d  k r&t j" j# t j j t j d! É É r|  j j t j j t j$ d" d# t% É  d$ É É q&|  j j d% É n  t& rs| j' d& É rs| j( s`|  j j | j' d' É É qs|  j j d% É n  |  j) r¶|  j) j d( É } t* d) Ñ  | É |  _) n  |  j+ r«|  j+ j d( É |  _+ n  |  j, d  k r‚g  |  _, n |  j, j d* É |  _, |  j- rát j j t. d+ É } t j j t. d" É } t j j/ | É rO|  j
 j | É n  t j j/ | É rá|  j j | É |  j j | É qán  d  S(2   Niˇˇˇˇ(   t	   sysconfigt   buildR#   R%   R.   R   R   R$   t   plat_specifici   R*   R
   t   libst   Debugt   Releaset   PCi	   t   win32t    i   t   PCbuildi   s   VS8.0i   s   VS7.1t   VC6t   os2t   Configi   t   cygwint   atheost   bint   libt   pythont   configt   .t   Py_ENABLE_SHAREDt   LIBDIRt   ,c         S   s
   |  d f S(   Nt   1(    (   t   symbol(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   <lambda>¸   s    t    t   include(   s	   build_libs	   build_lib(   s
   build_temps
   build_temp(   s   compilers   compiler(   s   debugs   debug(   s   forces   force(   s	   plat_names	   plat_name(0   t	   distutilsR4   t   set_undefined_optionsR&   R!   t   distributiont   ext_packaget   ext_modulesR"   t   get_python_incR'   t
   isinstancet   strt   splitt   ost   pathsept   appendt   ensure_string_listR*   R+   t   typet
   StringTypet   stringR,   t   namet   patht   joint   syst   exec_prefixR   R%   t   MSVC_VERSIONR$   t   platformt
   executablet
   startswitht   prefixR   t   Falset   get_config_vart   python_buildR(   t   mapR)   R1   R    R   t   isdir(	   R2   R4   t
   py_includet   plat_py_includet   suffixt   new_libt   definest   user_includet   user_lib(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   finalize_optionsÉ   s¢    	"	"	%&$
				c      	   C   s  d d l  m } |  j s d  S|  j j É  rm |  j d É } |  j j | j É  pS g  É |  j	 j
 | j É n  | d |  j d |  j d |  j d |  j É |  _ t |  j É t j d k r· |  j t É  k r· |  j j |  j É n  |  j d  k	 r|  j j |  j É n  |  j d  k	 rEx- |  j D] \ } } |  j j | | É qWn  |  j d  k	 r{x$ |  j D] } |  j j | É q^Wn  |  j d  k	 r†|  j j |  j É n  |  j	 d  k	 r≈|  j j |  j	 É n  |  j d  k	 rÍ|  j j  |  j É n  |  j! d  k	 r|  j j" |  j! É n  |  j# É  d  S(	   Niˇˇˇˇ(   t   new_compilert
   build_clibR.   t   verboset   dry_runR   R
   ($   R   Rw   R"   RR   t   has_c_librariest   get_finalized_commandR*   t   extendt   get_library_namesR+   R[   Rx   R.   Ry   Rz   R   R   RY   R`   R$   R   t
   initializeR'   R!   t   set_include_dirsR(   t   define_macroR)   t   undefine_macrot   set_librariest   set_library_dirsR,   t   set_runtime_library_dirsR-   t   set_link_objectst   build_extensions(   R2   Rw   Rx   R`   t   valuet   macro(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   run  s>    			!c   
      C   s!  t  | t É s t d Ç n  xˇt | É D]Ò\ } } t  | t É rI q( n  t  | t É sk t | É d k rw t d Ç n  | \ } } t j d | É t  | t	 É oØ t
 j | É sæ t d Ç n  t  | t É sŸ t d Ç n  t | | d É } x< d D]4 } | j | É } | d k	 rÛ t | | | É qÛ qÛ W| j d É | _ d | k rYt j d É n  | j d É } | rg  | _ g  | _ xå | D]Å }	 t  |	 t É o´t |	 É d k s∫t d Ç n  t |	 É d k r„| j j |	 d É qát |	 É d k rá| j j |	 É qáqáWn  | | | <q( Wd S(   s¨  Ensure that the list of extensions (presumably provided as a
        command option 'extensions') is valid, i.e. it is a list of
        Extension objects.  We also support the old-style list of 2-tuples,
        where the tuples are (ext_name, build_info), which are converted to
        Extension instances here.

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        s:   'ext_modules' option must be a list of Extension instancesi   sM   each element of 'ext_modules' option must be an Extension instance or 2-tuplesu   old-style (ext_name, build_info) tuple found in ext_modules for extension '%s'-- please convert to Extension instancesR   first element of each tuple in 'ext_modules' must be the extension name (a string)sO   second element of each tuple in 'ext_modules' must be a dictionary (build info)t   sourcesR'   R+   R*   t   extra_objectst   extra_compile_argst   extra_link_argsR,   t   def_files9   'def_file' element of build info dict no longer supportedt   macrosi   s9   'macros' element of build info dict must be 1- or 2-tuplei    N(   s   include_dirss   library_dirss	   librariess   extra_objectss   extra_compile_argss   extra_link_args(   i   i   (   RV   t   listt   DistutilsSetupErrort	   enumerateR   t   tuplet   lenR	   t   warnRW   t   extension_name_ret   matcht   dictt   getR!   t   setattrt   runtime_library_dirst   define_macrost   undef_macrosR[   (
   R2   R"   R   t   extt   ext_namet
   build_infot   keyt   valRê   Râ   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   check_extensions_listS  sT    
	"				 
		!	c         C   s>   |  j  |  j É g  } x! |  j D] } | j | j É q  W| S(   N(   R§   R"   R}   Rã   (   R2   t	   filenamesRü   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   get_source_files°  s
    c         C   sG   |  j  |  j É g  } x* |  j D] } | j |  j | j É É q  W| S(   N(   R§   R"   R[   t   get_ext_fullpathR`   (   R2   t   outputsRü   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   get_outputs´  s
    c         C   s5   |  j  |  j É x |  j D] } |  j | É q Wd  S(   N(   R§   R"   t   build_extension(   R2   Rü   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRá   π  s    c   
      C   s˛  | j  } | d  k s- t | É t t f k rH t d d d | j Ç n  t | É } |  j | j É } | | j	 } |  j
 pã t | | d É s• t j d | j É d  St j d | j É |  j | | É } | j p÷ g  } | j } x! | j D] } | j | f É qÌ W|  j j | d |  j d | d	 | j d
 |  j d | d | j	 É} | |  _ | j ro| j | j É n  | j p{g  } | j pñ|  j j | É }	 |  j j | | d |  j | É d | j  d | j! d | d |  j" | É d
 |  j d |  j d |	 Éd  S(   Ns*   in 'ext_modules' option (extension '%s'), s&   'sources' must be present and must be s   a list of source filenamest   newers$   skipping '%s' extension (up-to-date)s   building '%s' extensiont
   output_dirRê   R'   R   t   extra_postargst   dependsR*   R+   Rú   t   export_symbolsR%   t   target_lang(#   Rã   R!   R]   t   ListTypet	   TupleTypeRí   R`   Rë   Rß   RÆ   R   R   R	   R   t   infot   swig_sourcesRç   Rù   Rû   R[   R.   t   compileR%   R'   t   _built_objectsRå   R}   Ré   t   languaget   detect_languaget   link_shared_objectt   get_librariesR+   Rú   t   get_export_symbols(
   R2   Rü   Rã   t   ext_pathRÆ   t
   extra_argsRê   R)   t   objectsR∑   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR™   ¿  sN    	$
			
							c         C   s£  g  } g  } i  } |  j  r+ t j d É n  |  j  sR d |  j k sR d | j k r[ d } n d } xr | D]j } t j j | É \ } }	 |	 d k r≈ | j | d | É | j | É | d | | <qh | j | É qh W| s‡ | S|  j pÚ |  j	 É  }
 |
 d g } | j
 |  j É |  j  r*| j d É n  |  j sWx! | j D] } | j | É q=Wn  xE | D]= } | | } t j d	 | | É |  j | d
 | | g É q^W| S(   s¸   Walk the list of source files in 'sources', looking for SWIG
        interface (.i) files.  Run SWIG on all that are found, and
        return a modified 'sources' list with SWIG source files replaced
        by the generated C (or C++) files.
        s/   --swig-cpp is deprecated - use --swig-opts=-c++s   -c++s   .cpps   .cs   .it   _wrapiˇˇˇˇs   -pythons   swigging %s to %ss   -o(   R0   R	   Rñ   R1   RY   Ra   t   splitextR[   R/   t	   find_swigR}   R≥   t   spawn(   R2   Rã   t	   extensiont   new_sourcesR¥   t   swig_targetst
   target_extt   sourcet   baseRü   R/   t   swig_cmdt   ot   target(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR¥     s>    				
c         C   sê   t  j d k r d St  j d k ri xg d D]5 } t  j j d | d É } t  j j | É r) | Sq) Wd Sn# t  j d	 k r| d St d
 t  j Ç d S(   sõ   Return the name of the SWIG executable.  On Unix, this is
        just "swig" -- it should be in the PATH.  Tries a bit harder on
        Windows.
        t   posixR/   R
   s   1.3s   1.2s   1.1s	   c:\swig%ss   swig.exeR?   s>   I don't know how to find (much less run) SWIG on platform '%s'N(   s   1.3s   1.2s   1.1(   RY   R`   Ra   Rb   t   isfilet   DistutilsPlatformError(   R2   t   verst   fn(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR¡   M  s    c   	      C   s˙   t  j d t j d É } | j | É } |  j | É } | j d É } |  j | É } t j j | É d } |  j	 sß t j j
 | d  | g å  } t j j
 |  j | É Sd j
 | d d !É } |  j d É } t j j | j | É É } t j j
 | | É S(   s°   Returns the path of the filename for a given extension.

        The file is located in `build_lib` or directly in the package
        (inplace option).
        t   /s   ..RG   iˇˇˇˇi    t   build_py(   R_   t	   maketransRY   t   sept	   translatet   get_ext_fullnameRX   t   get_ext_filenameRa   R   Rb   R#   R|   t   abspatht   get_package_dir(	   R2   R†   t   all_dotst   fullnamet   modpatht   filenameR&   R“   t   package_dir(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRß   n  s    	c         C   s&   |  j  d k r | S|  j  d | Sd S(   sS   Returns the fullname of a given extension name.

        Adds the `package.` prefixRG   N(   R&   R!   (   R2   R†   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR÷   é  s    c         C   s™   d d l  m } t j | d É } t j d k rZ | t | É d d  | t | É d <n  | d É } t j d k rñ |  j rñ t j j	 | å  d	 | St j j	 | å  | S(
   s¶   Convert the name of an extension (eg. "foo.bar") into the name
        of the file from which it will be loaded (eg. "foo/bar.so", or
        "foo\bar.pyd").
        iˇˇˇˇ(   Rk   RG   R?   i   i   t   SOR
   t   _d(
   t   distutils.sysconfigRk   R_   RX   RY   R`   Rï   R   Ra   Rb   (   R2   R†   Rk   Rº   t   so_ext(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR◊   ó  s    )c         C   sC   d | j  j d É d } | | j k r< | j j | É n  | j S(   s  Return the list of symbols that a shared extension has to
        export.  This either uses 'ext.export_symbols' or, if it's not
        provided, "init" + module_name.  Only relevant on Windows, where
        the .pyd file (DLL) must export the module "init" function.
        t   initRG   iˇˇˇˇ(   R`   RX   RØ   R[   (   R2   Rü   t   initfunc_name(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRª   ß  s    c         C   sa  t  j d k rá d d l m } t |  j | É s} d } |  j rM | d } n  | t  j d ?t  j d ?d @f } | j | g S| j Sn÷t  j d	 k rÃ d } | t  j d ?t  j d ?d @f } | j | g St  j d
  d k rd } | t  j d ?t  j d ?d @f } | j | g St  j d
  d k rÀd d l	 m
 } d } | t  j d ?t  j d ?d @f } g  } xM | j d É j É  D]6 } | j d É r•| j | d É q|| j | É q|W| j | d g | St  j d k r·| j St  j d  d k r˚| j Sd d l	 m
 } t rV| j d É rVd } | t  j d ?t  j d ?d @f } | j | g S| j Sd S(   s‹   Return the list of libraries to link against when building a
        shared extension.  On most platforms, this is just 'ext.libraries';
        on Windows and OS/2, we add the Python library (eg. python20.dll).
        R;   iˇˇˇˇ(   t   MSVCCompilers
   python%d%dR‡   i   i   iˇ   t   os2emxi   RA   s   python%d.%dRB   (   R4   t   SHLIBSs   -li   t   mt   darwini   t   aixRH   N(   Rc   Rf   t   distutils.msvccompilerRÂ   RV   R.   R   t
   hexversionR*   RP   R4   Rk   RX   Rh   R[   Rj   (   R2   Rü   RÂ   t   templatet	   pythonlibR4   t   extraRD   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR∫   ≤  sT    
	
(   s
   build-lib=R   s(   directory for compiled extension modules(   s   build-temp=R   s1   directory for temporary files (build by-products)(   s   define=R   s   C preprocessor macros to define(   s   undef=R   s!   C preprocessor macros to undefine(   s
   libraries=R   s!   external C libraries to link with(   s   rpath=R   s7   directories to search for shared C libraries at runtime(   s   link-objects=R   s2   extra explicit link objects to include in the link(   s   debugR   s'   compile/link with debugging information(   s   forceR   s2   forcibly build everything (ignore file timestamps)(   s	   compiler=R   s   specify the compiler typeN(   s   swig-cppNs)   make SWIG create C++ files (default is C)(   s
   swig-opts=Ns!   list of SWIG command line options(   s   swig=Ns   path to the SWIG executable(   s   userNs#   add user include, library and rpath(   t   __name__t
   __module__t   descriptionRY   RZ   t   sep_byR   R!   t   user_optionst   boolean_optionsR   t   help_optionsR3   Rv   Rä   R§   R¶   R©   Rá   R™   R¥   R¡   Rß   R÷   R◊   Rª   R∫   (    (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR   %   st     

   
         			ê	@	N	
			S	:	!	 				(!   t   __doc__t   __revision__Rc   RY   R_   t   ret   typest   siteR   R   t   distutils.coreR   t   distutils.errorsR·   R   R   t   distutils.dep_utilR   t   distutils.extensionR   t   distutils.utilR   RP   R	   R`   RÎ   R   t   intRe   Rµ   Ró   R   R   (    (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   <module>   s$   0

		                                                                                                      usr/lib/python2.7/distutils/command/build_py.py                                                     0100644 0000000 0000000 00000037722 12734733743 020247  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.build_py

Implements the Distutils 'build_py' command."""

__revision__ = "$Id$"

import os
import sys
from glob import glob

from distutils.core import Command
from distutils.errors import DistutilsOptionError, DistutilsFileError
from distutils.util import convert_path
from distutils import log

class build_py(Command):

    description = "\"build\" pure Python modules (copy to build directory)"

    user_options = [
        ('build-lib=', 'd', "directory to \"build\" (copy) to"),
        ('compile', 'c', "compile .py to .pyc"),
        ('no-compile', None, "don't compile .py files [default]"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('force', 'f', "forcibly build everything (ignore file timestamps)"),
        ]

    boolean_options = ['compile', 'force']
    negative_opt = {'no-compile' : 'compile'}

    def initialize_options(self):
        self.build_lib = None
        self.py_modules = None
        self.package = None
        self.package_data = None
        self.package_dir = None
        self.compile = 0
        self.optimize = 0
        self.force = None

    def finalize_options(self):
        self.set_undefined_options('build',
                                   ('build_lib', 'build_lib'),
                                   ('force', 'force'))

        # Get the distribution options that are aliases for build_py
        # options -- list of packages and list of modules.
        self.packages = self.distribution.packages
        self.py_modules = self.distribution.py_modules
        self.package_data = self.distribution.package_data
        self.package_dir = {}
        if self.distribution.package_dir:
            for name, path in self.distribution.package_dir.items():
                self.package_dir[name] = convert_path(path)
        self.data_files = self.get_data_files()

        # Ick, copied straight from install_lib.py (fancy_getopt needs a
        # type system!  Hell, *everything* needs a type system!!!)
        if not isinstance(self.optimize, int):
            try:
                self.optimize = int(self.optimize)
                assert 0 <= self.optimize <= 2
            except (ValueError, AssertionError):
                raise DistutilsOptionError("optimize must be 0, 1, or 2")

    def run(self):
        # XXX copy_file by default preserves atime and mtime.  IMHO this is
        # the right thing to do, but perhaps it should be an option -- in
        # particular, a site administrator might want installed files to
        # reflect the time of installation rather than the last
        # modification time before the installed release.

        # XXX copy_file by default preserves mode, which appears to be the
        # wrong thing to do: if a file is read-only in the working
        # directory, we want it to be installed read/write so that the next
        # installation of the same module distribution can overwrite it
        # without problems.  (This might be a Unix-specific issue.)  Thus
        # we turn off 'preserve_mode' when copying to the build directory,
        # since the build directory is supposed to be exactly what the
        # installation will look like (ie. we preserve mode when
        # installing).

        # Two options control which modules will be installed: 'packages'
        # and 'py_modules'.  The former lets us work with whole packages, not
        # specifying individual modules at all; the latter is for
        # specifying modules one-at-a-time.

        if self.py_modules:
            self.build_modules()
        if self.packages:
            self.build_packages()
            self.build_package_data()

        self.byte_compile(self.get_outputs(include_bytecode=0))

    def get_data_files(self):
        """Generate list of '(package,src_dir,build_dir,filenames)' tuples"""
        data = []
        if not self.packages:
            return data
        for package in self.packages:
            # Locate package source directory
            src_dir = self.get_package_dir(package)

            # Compute package build directory
            build_dir = os.path.join(*([self.build_lib] + package.split('.')))

            # Length of path to strip from found files
            plen = 0
            if src_dir:
                plen = len(src_dir)+1

            # Strip directory from globbed filenames
            filenames = [
                file[plen:] for file in self.find_data_files(package, src_dir)
                ]
            data.append((package, src_dir, build_dir, filenames))
        return data

    def find_data_files(self, package, src_dir):
        """Return filenames for package's data files in 'src_dir'"""
        globs = (self.package_data.get('', [])
                 + self.package_data.get(package, []))
        files = []
        for pattern in globs:
            # Each pattern has to be converted to a platform-specific path
            filelist = glob(os.path.join(src_dir, convert_path(pattern)))
            # Files that match more than one pattern are only added once
            files.extend([fn for fn in filelist if fn not in files
                and os.path.isfile(fn)])
        return files

    def build_package_data(self):
        """Copy data files into build directory"""
        for package, src_dir, build_dir, filenames in self.data_files:
            for filename in filenames:
                target = os.path.join(build_dir, filename)
                self.mkpath(os.path.dirname(target))
                self.copy_file(os.path.join(src_dir, filename), target,
                               preserve_mode=False)

    def get_package_dir(self, package):
        """Return the directory, relative to the top of the source
           distribution, where package 'package' should be found
           (at least according to the 'package_dir' option, if any)."""

        path = package.split('.')

        if not self.package_dir:
            if path:
                return os.path.join(*path)
            else:
                return ''
        else:
            tail = []
            while path:
                try:
                    pdir = self.package_dir['.'.join(path)]
                except KeyError:
                    tail.insert(0, path[-1])
                    del path[-1]
                else:
                    tail.insert(0, pdir)
                    return os.path.join(*tail)
            else:
                # Oops, got all the way through 'path' without finding a
                # match in package_dir.  If package_dir defines a directory
                # for the root (nameless) package, then fallback on it;
                # otherwise, we might as well have not consulted
                # package_dir at all, as we just use the directory implied
                # by 'tail' (which should be the same as the original value
                # of 'path' at this point).
                pdir = self.package_dir.get('')
                if pdir is not None:
                    tail.insert(0, pdir)

                if tail:
                    return os.path.join(*tail)
                else:
                    return ''

    def check_package(self, package, package_dir):
        # Empty dir name means current directory, which we can probably
        # assume exists.  Also, os.path.exists and isdir don't know about
        # my "empty string means current dir" convention, so we have to
        # circumvent them.
        if package_dir != "":
            if not os.path.exists(package_dir):
                raise DistutilsFileError(
                      "package directory '%s' does not exist" % package_dir)
            if not os.path.isdir(package_dir):
                raise DistutilsFileError(
                       "supposed package directory '%s' exists, "
                       "but is not a directory" % package_dir)

        # Require __init__.py for all but the "root package"
        if package:
            init_py = os.path.join(package_dir, "__init__.py")
            if os.path.isfile(init_py):
                return init_py
            else:
                log.warn(("package init file '%s' not found " +
                          "(or not a regular file)"), init_py)

        # Either not in a package at all (__init__.py not expected), or
        # __init__.py doesn't exist -- so don't return the filename.
        return None

    def check_module(self, module, module_file):
        if not os.path.isfile(module_file):
            log.warn("file %s (for module %s) not found", module_file, module)
            return False
        else:
            return True

    def find_package_modules(self, package, package_dir):
        self.check_package(package, package_dir)
        module_files = glob(os.path.join(package_dir, "*.py"))
        modules = []
        setup_script = os.path.abspath(self.distribution.script_name)

        for f in module_files:
            abs_f = os.path.abspath(f)
            if abs_f != setup_script:
                module = os.path.splitext(os.path.basename(f))[0]
                modules.append((package, module, f))
            else:
                self.debug_print("excluding %s" % setup_script)
        return modules

    def find_modules(self):
        """Finds individually-specified Python modules, ie. those listed by
        module name in 'self.py_modules'.  Returns a list of tuples (package,
        module_base, filename): 'package' is a tuple of the path through
        package-space to the module; 'module_base' is the bare (no
        packages, no dots) module name, and 'filename' is the path to the
        ".py" file (relative to the distribution root) that implements the
        module.
        """
        # Map package names to tuples of useful info about the package:
        #    (package_dir, checked)
        # package_dir - the directory where we'll find source files for
        #   this package
        # checked - true if we have checked that the package directory
        #   is valid (exists, contains __init__.py, ... ?)
        packages = {}

        # List of (package, module, filename) tuples to return
        modules = []

        # We treat modules-in-packages almost the same as toplevel modules,
        # just the "package" for a toplevel is empty (either an empty
        # string or empty list, depending on context).  Differences:
        #   - don't check for __init__.py in directory for empty package
        for module in self.py_modules:
            path = module.split('.')
            package = '.'.join(path[0:-1])
            module_base = path[-1]

            try:
                (package_dir, checked) = packages[package]
            except KeyError:
                package_dir = self.get_package_dir(package)
                checked = 0

            if not checked:
                init_py = self.check_package(package, package_dir)
                packages[package] = (package_dir, 1)
                if init_py:
                    modules.append((package, "__init__", init_py))

            # XXX perhaps we should also check for just .pyc files
            # (so greedy closed-source bastards can distribute Python
            # modules too)
            module_file = os.path.join(package_dir, module_base + ".py")
            if not self.check_module(module, module_file):
                continue

            modules.append((package, module_base, module_file))

        return modules

    def find_all_modules(self):
        """Compute the list of all modules that will be built, whether
        they are specified one-module-at-a-time ('self.py_modules') or
        by whole packages ('self.packages').  Return a list of tuples
        (package, module, module_file), just like 'find_modules()' and
        'find_package_modules()' do."""
        modules = []
        if self.py_modules:
            modules.extend(self.find_modules())
        if self.packages:
            for package in self.packages:
                package_dir = self.get_package_dir(package)
                m = self.find_package_modules(package, package_dir)
                modules.extend(m)
        return modules

    def get_source_files(self):
        return [module[-1] for module in self.find_all_modules()]

    def get_module_outfile(self, build_dir, package, module):
        outfile_path = [build_dir] + list(package) + [module + ".py"]
        return os.path.join(*outfile_path)

    def get_outputs(self, include_bytecode=1):
        modules = self.find_all_modules()
        outputs = []
        for (package, module, module_file) in modules:
            package = package.split('.')
            filename = self.get_module_outfile(self.build_lib, package, module)
            outputs.append(filename)
            if include_bytecode:
                if self.compile:
                    outputs.append(filename + "c")
                if self.optimize > 0:
                    outputs.append(filename + "o")

        outputs += [
            os.path.join(build_dir, filename)
            for package, src_dir, build_dir, filenames in self.data_files
            for filename in filenames
            ]

        return outputs

    def build_module(self, module, module_file, package):
        if isinstance(package, str):
            package = package.split('.')
        elif not isinstance(package, (list, tuple)):
            raise TypeError(
                  "'package' must be a string (dot-separated), list, or tuple")

        # Now put the module source file into the "build" area -- this is
        # easy, we just copy it somewhere under self.build_lib (the build
        # directory for Python source).
        outfile = self.get_module_outfile(self.build_lib, package, module)
        dir = os.path.dirname(outfile)
        self.mkpath(dir)
        return self.copy_file(module_file, outfile, preserve_mode=0)

    def build_modules(self):
        modules = self.find_modules()
        for (package, module, module_file) in modules:

            # Now "build" the module -- ie. copy the source file to
            # self.build_lib (the build directory for Python source).
            # (Actually, it gets copied to the directory for this package
            # under self.build_lib.)
            self.build_module(module, module_file, package)

    def build_packages(self):
        for package in self.packages:

            # Get list of (package, module, module_file) tuples based on
            # scanning the package directory.  'package' is only included
            # in the tuple so that 'find_modules()' and
            # 'find_package_tuples()' have a consistent interface; it's
            # ignored here (apart from a sanity check).  Also, 'module' is
            # the *unqualified* module name (ie. no dots, no package -- we
            # already know its package!), and 'module_file' is the path to
            # the .py file, relative to the current directory
            # (ie. including 'package_dir').
            package_dir = self.get_package_dir(package)
            modules = self.find_package_modules(package, package_dir)

            # Now loop over the modules we found, "building" each one (just
            # copy it to self.build_lib).
            for (package_, module, module_file) in modules:
                assert package == package_
                self.build_module(module, module_file, package)

    def byte_compile(self, files):
        if sys.dont_write_bytecode:
            self.warn('byte-compiling is disabled, skipping.')
            return

        from distutils.util import byte_compile
        prefix = self.build_lib
        if prefix[-1] != os.sep:
            prefix = prefix + os.sep

        # XXX this code is essentially the same as the 'byte_compile()
        # method of the "install_lib" command, except for the determination
        # of the 'prefix' string.  Hmmm.

        if self.compile:
            byte_compile(files, optimize=0,
                         force=self.force, prefix=prefix, dry_run=self.dry_run)
        if self.optimize > 0:
            byte_compile(files, optimize=self.optimize,
                         force=self.force, prefix=prefix, dry_run=self.dry_run)
                                              usr/lib/python2.7/distutils/command/build_py.pyc                                                    0100644 0000000 0000000 00000026343 13077704274 020405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sî   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m Z m	 Z	 d d l
 m Z d d l m Z d	 e f d
 Ñ  É  YZ d S(   sH   distutils.command.build_py

Implements the Distutils 'build_py' command.s   $Id$iˇˇˇˇN(   t   glob(   t   Command(   t   DistutilsOptionErrort   DistutilsFileError(   t   convert_path(   t   logt   build_pyc           B   sÍ   e  Z d  Z d# d$ d& d' d( g Z d d g Z i d d 6Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d  Ñ  Z d! Ñ  Z d" Ñ  Z RS()   s5   "build" pure Python modules (copy to build directory)s
   build-lib=t   ds   directory to "build" (copy) tot   compilet   cs   compile .py to .pycs
   no-compiles!   don't compile .py files [default]s	   optimize=t   Osl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]t   forcet   fs2   forcibly build everything (ignore file timestamps)c         C   sL   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ d  |  _ d  S(   Ni    (	   t   Nonet	   build_libt
   py_modulest   packaget   package_datat   package_dirR   t   optimizeR   (   t   self(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   initialize_options!   s    							c         C   s  |  j  d d d É |  j j |  _ |  j j |  _ |  j j |  _ i  |  _ |  j j ré x6 |  j j j É  D] \ } } t | É |  j | <qh Wn  |  j É  |  _	 t
 |  j t É sy; t |  j É |  _ d |  j k oﬁ d k n sÈ t Ç Wqt t f k
 rt d É Ç qXn  d  S(	   Nt   buildR   R   i    i   s   optimize must be 0, 1, or 2(   s	   build_libs	   build_lib(   s   forces   force(   t   set_undefined_optionst   distributiont   packagesR   R   R   t   itemsR   t   get_data_filest
   data_filest
   isinstanceR   t   intt   AssertionErrort
   ValueErrorR   (   R   t   namet   path(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   finalize_options+   s"    		)c         C   sS   |  j  r |  j É  n  |  j r6 |  j É  |  j É  n  |  j |  j d d É É d  S(   Nt   include_bytecodei    (   R   t   build_modulesR   t   build_packagest   build_package_datat   byte_compilet   get_outputs(   R   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   runD   s    		
c         C   s¿   g  } |  j  s | Sx¶ |  j  D]õ } |  j | É } t j j |  j g | j d É å  } d } | rv t | É d } n  g  |  j | | É D] } | | ^ qâ } | j	 | | | | f É q W| S(   s?   Generate list of '(package,src_dir,build_dir,filenames)' tuplest   .i    i   (
   R   t   get_package_dirt   osR"   t   joinR   t   splitt   lent   find_data_filest   append(   R   t   dataR   t   src_dirt	   build_dirt   plent   filet	   filenames(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR   b   s    	%)c         C   s¢   |  j  j d g  É |  j  j | g  É } g  } xm | D]e } t t j j | t | É É É } | j g  | D]* } | | k ri t j j | É ri | ^ qi É q5 W| S(   s6   Return filenames for package's data files in 'src_dir't    (	   R   t   getR    R-   R"   R.   R   t   extendt   isfile(   R   R   R4   t   globst   filest   patternt   filelistt   fn(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR1   z   s    !#c         C   sà   xÅ |  j  D]v \ } } } } xa | D]Y } t j j | | É } |  j t j j | É É |  j t j j | | É | d t Éq# Wq
 Wd S(   s$   Copy data files into build directoryt   preserve_modeN(   R   R-   R"   R.   t   mkpatht   dirnamet	   copy_filet   False(   R   R   R4   R5   R8   t   filenamet   target(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR'   á   s    c         C   s   | j  d É } |  j s5 | r. t j j | å  Sd Sn« g  } xæ | r∞ y |  j d j | É } Wn, t k
 rå | j d | d É | d =q> X| j d | É t j j | å  Sq> W|  j j d É } | d k	 r‚ | j d | É n  | r¯ t j j | å  Sd Sd S(   sΩ   Return the directory, relative to the top of the source
           distribution, where package 'package' should be found
           (at least according to the 'package_dir' option, if any).R+   R9   i    iˇˇˇˇN(	   R/   R   R-   R"   R.   t   KeyErrort   insertR:   R   (   R   R   R"   t   tailt   pdir(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR,   ê   s(    			c         C   s•   | d k rY t  j j | É s1 t d | É Ç n  t  j j | É sY t d | É Ç qY n  | r° t  j j | d É } t  j j | É rä | St j d d | É n  d  S(   NR9   s%   package directory '%s' does not exists>   supposed package directory '%s' exists, but is not a directorys   __init__.pys!   package init file '%s' not found s   (or not a regular file)(
   R-   R"   t   existsR   t   isdirR.   R<   R   t   warnR   (   R   R   R   t   init_py(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   check_package∏   s    	c         C   s1   t  j j | É s) t j d | | É t St Sd  S(   Ns!   file %s (for module %s) not found(   R-   R"   R<   R   RO   RF   t   True(   R   t   modulet   module_file(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   check_module”   s    c   	      C   s»   |  j  | | É t t j j | d É É } g  } t j j |  j j É } xx | D]p } t j j | É } | | k rØ t j j t j j	 | É É d } | j
 | | | f É qP |  j d | É qP W| S(   Ns   *.pyi    s   excluding %s(   RQ   R    R-   R"   R.   t   abspathR   t   script_namet   splitextt   basenameR2   t   debug_print(	   R   R   R   t   module_filest   modulest   setup_scriptR   t   abs_fRS   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   find_package_modules⁄   s    "c         C   s!  i  } g  } x|  j  D]} | j d É } d j | d d !É } | d } y | | \ } } Wn& t k
 rá |  j | É } d } n X| s“ |  j | | É }	 | d f | | <|	 r“ | j | d |	 f É q“ n  t j j | | d É }
 |  j	 | |
 É sq n  | j | | |
 f É q W| S(   s»  Finds individually-specified Python modules, ie. those listed by
        module name in 'self.py_modules'.  Returns a list of tuples (package,
        module_base, filename): 'package' is a tuple of the path through
        package-space to the module; 'module_base' is the bare (no
        packages, no dots) module name, and 'filename' is the path to the
        ".py" file (relative to the distribution root) that implements the
        module.
        R+   i    iˇˇˇˇi   t   __init__s   .py(
   R   R/   R.   RI   R,   RQ   R2   R-   R"   RU   (   R   R   R\   RS   R"   R   t   module_baseR   t   checkedRP   RT   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   find_modulesÈ   s*    

c         C   sw   g  } |  j  r% | j |  j É  É n  |  j rs xB |  j D]4 } |  j | É } |  j | | É } | j | É q8 Wn  | S(   s4  Compute the list of all modules that will be built, whether
        they are specified one-module-at-a-time ('self.py_modules') or
        by whole packages ('self.packages').  Return a list of tuples
        (package, module, module_file), just like 'find_modules()' and
        'find_package_modules()' do.(   R   R;   Rc   R   R,   R_   (   R   R\   R   R   t   m(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   find_all_modules  s    		c         C   s!   g  |  j  É  D] } | d ^ q S(   Niˇˇˇˇ(   Re   (   R   RS   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   get_source_files-  s    c         C   s.   | g t  | É | d g } t j j | å  S(   Ns   .py(   t   listR-   R"   R.   (   R   R5   R   RS   t   outfile_path(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   get_module_outfile0  s    i   c         C   sı   |  j  É  } g  } xî | D]å \ } } } | j d É } |  j |  j | | É } | j | É | r |  j r | j | d É n  |  j d k r• | j | d É q• q q W| g  |  j D]4 \ } } }	 }
 |
 D] } t j	 j
 |	 | É ^ qÃ q∂ 7} | S(   NR+   R	   i    t   o(   Re   R/   Ri   R   R2   R   R   R   R-   R"   R.   (   R   R$   R\   t   outputsR   RS   RT   RG   R4   R5   R8   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR)   4  s     	)c         C   sí   t  | t É r! | j d É } n$ t  | t t f É sE t d É Ç n  |  j |  j | | É } t j	 j
 | É } |  j | É |  j | | d d ÉS(   NR+   s:   'package' must be a string (dot-separated), list, or tupleRB   i    (   R   t   strR/   Rg   t   tuplet	   TypeErrorRi   R   R-   R"   RD   RC   RE   (   R   RS   RT   R   t   outfilet   dir(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   build_moduleI  s    c         C   s=   |  j  É  } x* | D]" \ } } } |  j | | | É q Wd  S(   N(   Rc   Rq   (   R   R\   R   RS   RT   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR%   X  s    c         C   sx   xq |  j  D]f } |  j | É } |  j | | É } x< | D]4 \ } } } | | k sY t Ç |  j | | | É q8 Wq
 Wd  S(   N(   R   R,   R_   R   Rq   (   R   R   R   R\   t   package_RS   RT   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR&   b  s    c      
   C   sÀ   t  j r |  j d É d  Sd d l m } |  j } | d t j k rV | t j } n  |  j rä | | d d d |  j	 d | d |  j
 Én  |  j d k r« | | d |  j d |  j	 d | d |  j
 Én  d  S(	   Ns%   byte-compiling is disabled, skipping.iˇˇˇˇ(   R(   R   i    R   t   prefixt   dry_run(   t   syst   dont_write_bytecodeRO   t   distutils.utilR(   R   R-   t   sepR   R   Rt   R   (   R   R>   R(   Rs   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR(   w  s    			(   s
   build-lib=R   s   directory to "build" (copy) to(   s   compileR	   s   compile .py to .pycN(   s
   no-compileNs!   don't compile .py files [default](   s	   optimize=R
   sl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0](   s   forceR   s2   forcibly build everything (ignore file timestamps)(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionst   negative_optR   R#   R*   R   R1   R'   R,   RQ   RU   R_   Rc   Re   Rf   Ri   R)   Rq   R%   R&   R(   (    (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR      s8    		
							(				4					
	(   t   __doc__t   __revision__R-   Ru   R    t   distutils.coreR   t   distutils.errorsR   R   Rw   R   t	   distutilsR   R   (    (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   <module>   s                                                                                                                                                                                                                                                                                                usr/lib/python2.7/distutils/command/build_scripts.py                                                0100644 0000000 0000000 00000010766 12734733743 021305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.build_scripts

Implements the Distutils 'build_scripts' command."""

__revision__ = "$Id$"

import os, re
from stat import ST_MODE
from distutils.core import Command
from distutils.dep_util import newer
from distutils.util import convert_path
from distutils import log

# check if Python is called on the first line with this expression
first_line_re = re.compile('^#!.*python[0-9.]*([ \t].*)?$')

class build_scripts (Command):

    description = "\"build\" scripts (copy and fixup #! line)"

    user_options = [
        ('build-dir=', 'd', "directory to \"build\" (copy) to"),
        ('force', 'f', "forcibly build everything (ignore file timestamps"),
        ('executable=', 'e', "specify final destination interpreter path"),
        ]

    boolean_options = ['force']


    def initialize_options (self):
        self.build_dir = None
        self.scripts = None
        self.force = None
        self.executable = None
        self.outfiles = None

    def finalize_options (self):
        self.set_undefined_options('build',
                                   ('build_scripts', 'build_dir'),
                                   ('force', 'force'),
                                   ('executable', 'executable'))
        self.scripts = self.distribution.scripts

    def get_source_files(self):
        return self.scripts

    def run (self):
        if not self.scripts:
            return
        self.copy_scripts()


    def copy_scripts (self):
        """Copy each script listed in 'self.scripts'; if it's marked as a
        Python script in the Unix way (first line matches 'first_line_re',
        ie. starts with "\#!" and contains "python"), then adjust the first
        line to refer to the current Python interpreter as we copy.
        """
        _sysconfig = __import__('sysconfig')
        self.mkpath(self.build_dir)
        outfiles = []
        for script in self.scripts:
            adjust = 0
            script = convert_path(script)
            outfile = os.path.join(self.build_dir, os.path.basename(script))
            outfiles.append(outfile)

            if not self.force and not newer(script, outfile):
                log.debug("not copying %s (up-to-date)", script)
                continue

            # Always open the file, but ignore failures in dry-run mode --
            # that way, we'll get accurate feedback if we can read the
            # script.
            try:
                f = open(script, "r")
            except IOError:
                if not self.dry_run:
                    raise
                f = None
            else:
                first_line = f.readline()
                if not first_line:
                    self.warn("%s is an empty file (skipping)" % script)
                    continue

                match = first_line_re.match(first_line)
                if match:
                    adjust = 1
                    post_interp = match.group(1) or ''

            if adjust:
                log.info("copying and adjusting %s -> %s", script,
                         self.build_dir)
                if not self.dry_run:
                    outf = open(outfile, "w")
                    if not _sysconfig.is_python_build():
                        outf.write("#!%s%s\n" %
                                   (self.executable,
                                    post_interp))
                    else:
                        outf.write("#!%s%s\n" %
                                   (os.path.join(
                            _sysconfig.get_config_var("BINDIR"),
                           "python%s%s" % (_sysconfig.get_config_var("VERSION"),
                                           _sysconfig.get_config_var("EXE"))),
                                    post_interp))
                    outf.writelines(f.readlines())
                    outf.close()
                if f:
                    f.close()
            else:
                if f:
                    f.close()
                self.copy_file(script, outfile)

        if os.name == 'posix':
            for file in outfiles:
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    oldmode = os.stat(file)[ST_MODE] & 07777
                    newmode = (oldmode | 0555) & 07777
                    if newmode != oldmode:
                        log.info("changing mode of %s from %o to %o",
                                 file, oldmode, newmode)
                        os.chmod(file, newmode)

    # copy_scripts ()

# class build_scripts
          usr/lib/python2.7/distutils/command/build_scripts.pyc                                               0100644 0000000 0000000 00000010650 13077704274 021436  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sù   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z d d l m Z e j d	 É Z d
 e f d Ñ  É  YZ d S(   sR   distutils.command.build_scripts

Implements the Distutils 'build_scripts' command.s   $Id$iˇˇˇˇN(   t   ST_MODE(   t   Command(   t   newer(   t   convert_path(   t   logs   ^#!.*python[0-9.]*([ 	].*)?$t   build_scriptsc           B   sS   e  Z d  Z d d d g Z d g Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s(   "build" scripts (copy and fixup #! line)s
   build-dir=t   ds   directory to "build" (copy) tot   forcet   fs1   forcibly build everything (ignore file timestampss   executable=t   es*   specify final destination interpreter pathc         C   s1   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   t   Nonet	   build_dirt   scriptsR   t
   executablet   outfiles(   t   self(    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   initialize_options   s
    				c         C   s)   |  j  d d d d É |  j j |  _ d  S(	   Nt   buildR   R   R   R   (   s   build_scriptss	   build_dir(   s   forces   force(   s
   executables
   executable(   t   set_undefined_optionst   distributionR   (   R   (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   finalize_options%   s
    	c         C   s   |  j  S(   N(   R   (   R   (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   get_source_files,   s    c         C   s   |  j  s d  S|  j É  d  S(   N(   R   t   copy_scripts(   R   (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   run/   s    	c      	   C   sﬂ  t  d É } |  j |  j É g  } x|  j D]} d } t | É } t j j |  j t j j | É É } | j	 | É |  j
 r• t | | É r• t j d | É q, n  y t | d É } Wn& t k
 r‡ |  j s◊ Ç  n  d } n] X| j É  } | s
|  j d | É q, n  t j | É } | r=d } | j d É p7d }	 n  | rt j d | |  j É |  j st | d	 É }
 | j É  sö|
 j d
 |  j |	 f É nK |
 j d
 t j j | j d É d | j d É | j d É f É |	 f É |
 j | j É  É |
 j É  n  | r>| j É  q>q, | r.| j É  n  |  j | | É q, Wt j  d k r€xá | D]| } |  j rzt j d | É qXt j! | É t" d @} | d Bd @} | | k rXt j d | | | É t j# | | É qXqXWn  d S(   s"  Copy each script listed in 'self.scripts'; if it's marked as a
        Python script in the Unix way (first line matches 'first_line_re',
        ie. starts with "\#!" and contains "python"), then adjust the first
        line to refer to the current Python interpreter as we copy.
        t	   sysconfigi    s   not copying %s (up-to-date)t   rs   %s is an empty file (skipping)i   t    s   copying and adjusting %s -> %st   ws   #!%s%s
t   BINDIRs
   python%s%st   VERSIONt   EXEt   posixs   changing mode of %siˇ  im  s!   changing mode of %s from %o to %oN($   t
   __import__t   mkpathR   R   R   t   ost   patht   joint   basenamet   appendR   R   R   t   debugt   opent   IOErrort   dry_runR
   t   readlinet   warnt   first_line_ret   matcht   groupt   infot   is_python_buildt   writeR   t   get_config_vart
   writelinest	   readlinest   closet	   copy_filet   namet   statR    t   chmod(   R   t
   _sysconfigR   t   scriptt   adjustt   outfileR   t
   first_lineR.   t   post_interpt   outft   filet   oldmodet   newmode(    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyR   5   sr    $	

						(   s
   build-dir=R   s   directory to "build" (copy) to(   s   forceR   s1   forcibly build everything (ignore file timestamps(   s   executable=R	   s*   specify final destination interpreter path(
   t   __name__t
   __module__t   descriptiont   user_optionst   boolean_optionsR   R   R   R   R   (    (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyR      s   						(   t   __doc__t   __revision__R"   t   reR9   R    t   distutils.coreR   t   distutils.dep_utilR   t   distutils.utilR   t	   distutilsR   t   compileR-   R   (    (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   <module>   s                                                                                           usr/lib/python2.7/distutils/command/check.py                                                        0100644 0000000 0000000 00000012665 12734733743 017514  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.check

Implements the Distutils 'check' command.
"""
__revision__ = "$Id$"

from distutils.core import Command
from distutils.dist import PKG_INFO_ENCODING
from distutils.errors import DistutilsSetupError

try:
    # docutils is installed
    from docutils.utils import Reporter
    from docutils.parsers.rst import Parser
    from docutils import frontend
    from docutils import nodes
    from StringIO import StringIO

    class SilentReporter(Reporter):

        def __init__(self, source, report_level, halt_level, stream=None,
                     debug=0, encoding='ascii', error_handler='replace'):
            self.messages = []
            Reporter.__init__(self, source, report_level, halt_level, stream,
                              debug, encoding, error_handler)

        def system_message(self, level, message, *children, **kwargs):
            self.messages.append((level, message, children, kwargs))
            return nodes.system_message(message, level=level,
                                        type=self.levels[level],
                                        *children, **kwargs)

    HAS_DOCUTILS = True
except ImportError:
    # docutils is not installed
    HAS_DOCUTILS = False

class check(Command):
    """This command checks the meta-data of the package.
    """
    description = ("perform some checks on the package")
    user_options = [('metadata', 'm', 'Verify meta-data'),
                    ('restructuredtext', 'r',
                     ('Checks if long string meta-data syntax '
                      'are reStructuredText-compliant')),
                    ('strict', 's',
                     'Will exit with an error if a check fails')]

    boolean_options = ['metadata', 'restructuredtext', 'strict']

    def initialize_options(self):
        """Sets default values for options."""
        self.restructuredtext = 0
        self.metadata = 1
        self.strict = 0
        self._warnings = 0

    def finalize_options(self):
        pass

    def warn(self, msg):
        """Counts the number of warnings that occurs."""
        self._warnings += 1
        return Command.warn(self, msg)

    def run(self):
        """Runs the command."""
        # perform the various tests
        if self.metadata:
            self.check_metadata()
        if self.restructuredtext:
            if HAS_DOCUTILS:
                self.check_restructuredtext()
            elif self.strict:
                raise DistutilsSetupError('The docutils package is needed.')

        # let's raise an error in strict mode, if we have at least
        # one warning
        if self.strict and self._warnings > 0:
            raise DistutilsSetupError('Please correct your package.')

    def check_metadata(self):
        """Ensures that all required elements of meta-data are supplied.

        name, version, URL, (author and author_email) or
        (maintainer and maintainer_email)).

        Warns if any are missing.
        """
        metadata = self.distribution.metadata

        missing = []
        for attr in ('name', 'version', 'url'):
            if not (hasattr(metadata, attr) and getattr(metadata, attr)):
                missing.append(attr)

        if missing:
            self.warn("missing required meta-data: %s"  % ', '.join(missing))
        if metadata.author:
            if not metadata.author_email:
                self.warn("missing meta-data: if 'author' supplied, " +
                          "'author_email' must be supplied too")
        elif metadata.maintainer:
            if not metadata.maintainer_email:
                self.warn("missing meta-data: if 'maintainer' supplied, " +
                          "'maintainer_email' must be supplied too")
        else:
            self.warn("missing meta-data: either (author and author_email) " +
                      "or (maintainer and maintainer_email) " +
                      "must be supplied")

    def check_restructuredtext(self):
        """Checks if the long string fields are reST-compliant."""
        data = self.distribution.get_long_description()
        if not isinstance(data, unicode):
            data = data.decode(PKG_INFO_ENCODING)
        for warning in self._check_rst_data(data):
            line = warning[-1].get('line')
            if line is None:
                warning = warning[1]
            else:
                warning = '%s (line %s)' % (warning[1], line)
            self.warn(warning)

    def _check_rst_data(self, data):
        """Returns warnings when the provided data doesn't compile."""
        source_path = StringIO()
        parser = Parser()
        settings = frontend.OptionParser().get_default_values()
        settings.tab_width = 4
        settings.pep_references = None
        settings.rfc_references = None
        reporter = SilentReporter(source_path,
                          settings.report_level,
                          settings.halt_level,
                          stream=settings.warning_stream,
                          debug=settings.debug,
                          encoding=settings.error_encoding,
                          error_handler=settings.error_encoding_error_handler)

        document = nodes.document(settings, reporter, source=source_path)
        document.note_source(source_path, -1)
        try:
            parser.parse(data, document)
        except AttributeError:
            reporter.messages.append((-1, 'Could not finish the parsing.',
                                      '', {}))

        return reporter.messages
                                                                           usr/lib/python2.7/distutils/command/check.pyc                                                       0100644 0000000 0000000 00000014071 13077704274 017646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s‡   d  Z  d Z d d l m Z d d l m Z d d l m Z yp d d l m	 Z	 d d l
 m Z d d l m Z d d	 l m Z d d
 l m Z d e	 f d Ñ  É  YZ e Z Wn e k
 r≈ e Z n Xd e f d Ñ  É  YZ d S(   sC   distutils.command.check

Implements the Distutils 'check' command.
s   $Id$iˇˇˇˇ(   t   Command(   t   PKG_INFO_ENCODING(   t   DistutilsSetupError(   t   Reporter(   t   Parser(   t   frontend(   t   nodes(   t   StringIOt   SilentReporterc           B   s&   e  Z d d  d d d Ñ Z d Ñ  Z RS(   i    t   asciit   replacec      	   C   s/   g  |  _  t j |  | | | | | | | É d  S(   N(   t   messagesR   t   __init__(   t   selft   sourcet   report_levelt
   halt_levelt   streamt   debugt   encodingt   error_handler(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR      s    	c         O   sB   |  j  j | | | | f É t j | d | d |  j | | | éS(   Nt   levelt   type(   R   t   appendR   t   system_messaget   levels(   R   R   t   messaget   childrent   kwargs(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR      s    
N(   t   __name__t
   __module__t   NoneR   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/check.pyR      s   t   checkc           B   sq   e  Z d  Z d Z d d d g Z d d d g Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z RS(   s6   This command checks the meta-data of the package.
    s"   perform some checks on the packaget   metadatat   ms   Verify meta-datat   restructuredtextt   rsE   Checks if long string meta-data syntax are reStructuredText-compliantt   strictt   ss(   Will exit with an error if a check failsc         C   s(   d |  _  d |  _ d |  _ d |  _ d S(   s    Sets default values for options.i    i   N(   R#   R!   R%   t	   _warnings(   R   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   initialize_options3   s    			c         C   s   d  S(   N(    (   R   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   finalize_options:   s    c         C   s   |  j  d 7_  t j |  | É S(   s*   Counts the number of warnings that occurs.i   (   R'   R    t   warn(   R   t   msg(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR*   =   s    c         C   sx   |  j  r |  j É  n  |  j rM t r2 |  j É  qM |  j rM t d É Ç qM n  |  j rt |  j d k rt t d É Ç n  d S(   s   Runs the command.s   The docutils package is needed.i    s   Please correct your package.N(   R!   t   check_metadataR#   t   HAS_DOCUTILSt   check_restructuredtextR%   R   R'   (   R   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   runB   s    			c         C   sﬂ   |  j  j } g  } x< d D]4 } t | | É o: t | | É s | j | É q q W| rt |  j d d j | É É n  | j rù | j s€ |  j d d É q€ n> | j	 r∆ | j
 s€ |  j d d	 É q€ n |  j d
 d d É d S(   sœ   Ensures that all required elements of meta-data are supplied.

        name, version, URL, (author and author_email) or
        (maintainer and maintainer_email)).

        Warns if any are missing.
        t   namet   versiont   urls   missing required meta-data: %ss   , s)   missing meta-data: if 'author' supplied, s#   'author_email' must be supplied toos-   missing meta-data: if 'maintainer' supplied, s'   'maintainer_email' must be supplied toos4   missing meta-data: either (author and author_email) s%   or (maintainer and maintainer_email) s   must be suppliedN(   s   names   versionR2   (   t   distributionR!   t   hasattrt   getattrR   R*   t   joint   authort   author_emailt
   maintainert   maintainer_email(   R   R!   t   missingt   attr(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR,   R   s$    						c         C   sõ   |  j  j É  } t | t É s0 | j t É } n  xd |  j | É D]S } | d j d É } | d k rr | d } n d | d | f } |  j	 | É q@ Wd S(   s4   Checks if the long string fields are reST-compliant.iˇˇˇˇt   linei   s   %s (line %s)N(
   R3   t   get_long_descriptiont
   isinstancet   unicodet   decodeR   t   _check_rst_datat   getR   R*   (   R   t   datat   warningR=   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyR.   p   s    c         C   sÓ   t  É  } t É  } t j É  j É  } d | _ d
 | _ d
 | _ t	 | | j
 | j d | j d | j d | j d | j É} t j | | d | É} | j | d É y | j | | É Wn- t k
 rÊ | j j d d d	 i  f É n X| j S(   s8   Returns warnings when the provided data doesn't compile.i   R   R   R   R   R   iˇˇˇˇs   Could not finish the parsing.t    N(   R   R   R   t   OptionParsert   get_default_valuest	   tab_widthR   t   pep_referencest   rfc_referencesR   R   R   t   warning_streamR   t   error_encodingt   error_encoding_error_handlerR   t   documentt   note_sourcet   parset   AttributeErrorR   R   (   R   RD   t   source_patht   parsert   settingst   reporterRO   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyRB   }   s*    									(   s   metadataR"   s   Verify meta-data(   s   restructuredtextR$   sE   Checks if long string meta-data syntax are reStructuredText-compliant(   s   strictR&   s(   Will exit with an error if a check fails(   R   R   t   __doc__t   descriptiont   user_optionst   boolean_optionsR(   R)   R*   R/   R,   R.   RB   (    (    (    s-   /usr/lib/python2.7/distutils/command/check.pyR    &   s     							N(   RW   t   __revision__t   distutils.coreR    t   distutils.distR   t   distutils.errorsR   t   docutils.utilsR   t   docutils.parsers.rstR   t   docutilsR   R   R   R   t   TrueR-   t   ImportErrort   FalseR    (    (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   <module>   s   

                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python2.7/distutils/command/clean.py                                                        0100644 0000000 0000000 00000005376 12734733743 017522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.clean

Implements the Distutils 'clean' command."""

# contributed by Bastian Kleineidam <calvin@cs.uni-sb.de>, added 2000-03-18

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils import log

class clean(Command):

    description = "clean up temporary files from 'build' command"
    user_options = [
        ('build-base=', 'b',
         "base build directory (default: 'build.build-base')"),
        ('build-lib=', None,
         "build directory for all modules (default: 'build.build-lib')"),
        ('build-temp=', 't',
         "temporary build directory (default: 'build.build-temp')"),
        ('build-scripts=', None,
         "build directory for scripts (default: 'build.build-scripts')"),
        ('bdist-base=', None,
         "temporary directory for built distributions"),
        ('all', 'a',
         "remove all build output, not just temporary by-products")
    ]

    boolean_options = ['all']

    def initialize_options(self):
        self.build_base = None
        self.build_lib = None
        self.build_temp = None
        self.build_scripts = None
        self.bdist_base = None
        self.all = None

    def finalize_options(self):
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'),
                                   ('build_lib', 'build_lib'),
                                   ('build_scripts', 'build_scripts'),
                                   ('build_temp', 'build_temp'))
        self.set_undefined_options('bdist',
                                   ('bdist_base', 'bdist_base'))

    def run(self):
        # remove the build/temp.<plat> directory (unless it's already
        # gone)
        if os.path.exists(self.build_temp):
            remove_tree(self.build_temp, dry_run=self.dry_run)
        else:
            log.debug("'%s' does not exist -- can't clean it",
                      self.build_temp)

        if self.all:
            # remove build directories
            for directory in (self.build_lib,
                              self.bdist_base,
                              self.build_scripts):
                if os.path.exists(directory):
                    remove_tree(directory, dry_run=self.dry_run)
                else:
                    log.warn("'%s' does not exist -- can't clean it",
                             directory)

        # just for the heck of it, try to remove the base build directory:
        # we might have emptied it right now, but if not we don't care
        if not self.dry_run:
            try:
                os.rmdir(self.build_base)
                log.info("removing '%s'", self.build_base)
            except OSError:
                pass

# class clean
                                                                                                                                                                                                                                                                  usr/lib/python2.7/distutils/command/clean.pyc                                                       0100644 0000000 0000000 00000006136 13077704274 017656  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sb   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d e f d Ñ  É  YZ	 d S(	   sB   distutils.command.clean

Implements the Distutils 'clean' command.s   $Id$iˇˇˇˇN(   t   Command(   t   remove_tree(   t   logt   cleanc           B   sJ   e  Z d  Z d d d d d d g Z d g Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s-   clean up temporary files from 'build' commands   build-base=t   bs2   base build directory (default: 'build.build-base')s
   build-lib=s<   build directory for all modules (default: 'build.build-lib')s   build-temp=t   ts7   temporary build directory (default: 'build.build-temp')s   build-scripts=s<   build directory for scripts (default: 'build.build-scripts')s   bdist-base=s+   temporary directory for built distributionst   allt   as7   remove all build output, not just temporary by-productsc         C   s:   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   t   Nonet
   build_baset	   build_libt
   build_tempt   build_scriptst
   bdist_baseR   (   t   self(    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   initialize_options"   s    					c         C   s-   |  j  d d d	 d
 d É |  j  d d É d  S(   Nt   buildR	   R
   R   R   t   bdistR   (   s
   build_bases
   build_base(   s	   build_libs	   build_lib(   s   build_scriptss   build_scripts(   s
   build_temps
   build_temp(   s
   bdist_bases
   bdist_base(   t   set_undefined_options(   R   (    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   finalize_options*   s    		c         C   sÛ   t  j j |  j É r. t |  j d |  j Én t j d |  j É |  j r® x[ |  j	 |  j
 |  j f D]> } t  j j | É rë t | d |  j Éqc t j d | É qc Wn  |  j sÔ y' t  j |  j É t j d |  j É WqÔ t k
 rÎ qÔ Xn  d  S(   Nt   dry_runs%   '%s' does not exist -- can't clean its   removing '%s'(   t   ost   patht   existsR   R   R   R   t   debugR   R
   R   R   t   warnt   rmdirR	   t   infot   OSError(   R   t	   directory(    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   run3   s$    	
				(   s   build-base=R   s2   base build directory (default: 'build.build-base')N(   s
   build-lib=Ns<   build directory for all modules (default: 'build.build-lib')(   s   build-temp=R   s7   temporary build directory (default: 'build.build-temp')(   s   build-scripts=Ns<   build directory for scripts (default: 'build.build-scripts')(   s   bdist-base=Ns+   temporary directory for built distributions(   s   allR   s7   remove all build output, not just temporary by-products(	   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionsR   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/clean.pyR      s"         					(
   t   __doc__t   __revision__R   t   distutils.coreR    t   distutils.dir_utilR   t	   distutilsR   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/distutils/command/command_template                                                0100644 0000000 0000000 00000001317 12734733743 021311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.x

Implements the Distutils 'x' command.
"""

# created 2000/mm/dd, John Doe

__revision__ = "$Id$"

from distutils.core import Command


class x (Command):

    # Brief (40-50 characters) description of the command
    description = ""

    # List of option tuples: long name, short name (None if no short
    # name), and help string.
    user_options = [('', '',
                     ""),
                   ]


    def initialize_options (self):
        self. = None
        self. = None
        self. = None

    # initialize_options()


    def finalize_options (self):
        if self.x is None:
            self.x = 

    # finalize_options()


    def run (self):


    # run()

# class x
                                                                                                                                                                                                                                                                                                                 usr/lib/python2.7/distutils/command/config.py                                                       0100644 0000000 0000000 00000031512 12734733743 017674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
"""

__revision__ = "$Id$"

import os
import re

from distutils.core import Command
from distutils.errors import DistutilsExecError
from distutils.sysconfig import customize_compiler
from distutils import log

LANG_EXT = {'c': '.c', 'c++': '.cxx'}

class config(Command):

    description = "prepare to build"

    user_options = [
        ('compiler=', None,
         "specify the compiler type"),
        ('cc=', None,
         "specify the compiler executable"),
        ('include-dirs=', 'I',
         "list of directories to search for header files"),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries"),

        ('noisy', None,
         "show every action (compile, link, run, ...) taken"),
        ('dump-source', None,
         "dump generated source files before attempting to compile them"),
        ]


    # The three standard command methods: since the "config" command
    # does nothing by default, these are empty.

    def initialize_options(self):
        self.compiler = None
        self.cc = None
        self.include_dirs = None
        self.libraries = None
        self.library_dirs = None

        # maximal output for now
        self.noisy = 1
        self.dump_source = 1

        # list of temporary files generated along-the-way that we have
        # to clean at some point
        self.temp_files = []

    def finalize_options(self):
        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        elif isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        if self.libraries is None:
            self.libraries = []
        elif isinstance(self.libraries, str):
            self.libraries = [self.libraries]

        if self.library_dirs is None:
            self.library_dirs = []
        elif isinstance(self.library_dirs, str):
            self.library_dirs = self.library_dirs.split(os.pathsep)

    def run(self):
        pass


    # Utility methods for actual "config" commands.  The interfaces are
    # loosely based on Autoconf macros of similar names.  Sub-classes
    # may use these freely.

    def _check_compiler(self):
        """Check that 'self.compiler' really is a CCompiler object;
        if not, make it one.
        """
        # We do this late, and only on-demand, because this is an expensive
        # import.
        from distutils.ccompiler import CCompiler, new_compiler
        if not isinstance(self.compiler, CCompiler):
            self.compiler = new_compiler(compiler=self.compiler,
                                         dry_run=self.dry_run, force=1)
            customize_compiler(self.compiler)
            if self.include_dirs:
                self.compiler.set_include_dirs(self.include_dirs)
            if self.libraries:
                self.compiler.set_libraries(self.libraries)
            if self.library_dirs:
                self.compiler.set_library_dirs(self.library_dirs)


    def _gen_temp_sourcefile(self, body, headers, lang):
        filename = "_configtest" + LANG_EXT[lang]
        file = open(filename, "w")
        if headers:
            for header in headers:
                file.write("#include <%s>\n" % header)
            file.write("\n")
        file.write(body)
        if body[-1] != "\n":
            file.write("\n")
        file.close()
        return filename

    def _preprocess(self, body, headers, include_dirs, lang):
        src = self._gen_temp_sourcefile(body, headers, lang)
        out = "_configtest.i"
        self.temp_files.extend([src, out])
        self.compiler.preprocess(src, out, include_dirs=include_dirs)
        return (src, out)

    def _compile(self, body, headers, include_dirs, lang):
        src = self._gen_temp_sourcefile(body, headers, lang)
        if self.dump_source:
            dump_file(src, "compiling '%s':" % src)
        (obj,) = self.compiler.object_filenames([src])
        self.temp_files.extend([src, obj])
        self.compiler.compile([src], include_dirs=include_dirs)
        return (src, obj)

    def _link(self, body, headers, include_dirs, libraries, library_dirs,
              lang):
        (src, obj) = self._compile(body, headers, include_dirs, lang)
        prog = os.path.splitext(os.path.basename(src))[0]
        self.compiler.link_executable([obj], prog,
                                      libraries=libraries,
                                      library_dirs=library_dirs,
                                      target_lang=lang)

        if self.compiler.exe_extension is not None:
            prog = prog + self.compiler.exe_extension
        self.temp_files.append(prog)

        return (src, obj, prog)

    def _clean(self, *filenames):
        if not filenames:
            filenames = self.temp_files
            self.temp_files = []
        log.info("removing: %s", ' '.join(filenames))
        for filename in filenames:
            try:
                os.remove(filename)
            except OSError:
                pass


    # XXX these ignore the dry-run flag: what to do, what to do? even if
    # you want a dry-run build, you still need some sort of configuration
    # info.  My inclination is to make it up to the real config command to
    # consult 'dry_run', and assume a default (minimal) configuration if
    # true.  The problem with trying to do it here is that you'd have to
    # return either true or false from all the 'try' methods, neither of
    # which is correct.

    # XXX need access to the header search path and maybe default macros.

    def try_cpp(self, body=None, headers=None, include_dirs=None, lang="c"):
        """Construct a source file from 'body' (a string containing lines
        of C/C++ code) and 'headers' (a list of header files to include)
        and run it through the preprocessor.  Return true if the
        preprocessor succeeded, false if there were any errors.
        ('body' probably isn't of much use, but what the heck.)
        """
        from distutils.ccompiler import CompileError
        self._check_compiler()
        ok = 1
        try:
            self._preprocess(body, headers, include_dirs, lang)
        except CompileError:
            ok = 0

        self._clean()
        return ok

    def search_cpp(self, pattern, body=None, headers=None, include_dirs=None,
                   lang="c"):
        """Construct a source file (just like 'try_cpp()'), run it through
        the preprocessor, and return true if any line of the output matches
        'pattern'.  'pattern' should either be a compiled regex object or a
        string containing a regex.  If both 'body' and 'headers' are None,
        preprocesses an empty file -- which can be useful to determine the
        symbols the preprocessor and compiler set by default.
        """
        self._check_compiler()
        src, out = self._preprocess(body, headers, include_dirs, lang)

        if isinstance(pattern, str):
            pattern = re.compile(pattern)

        file = open(out)
        match = 0
        while 1:
            line = file.readline()
            if line == '':
                break
            if pattern.search(line):
                match = 1
                break

        file.close()
        self._clean()
        return match

    def try_compile(self, body, headers=None, include_dirs=None, lang="c"):
        """Try to compile a source file built from 'body' and 'headers'.
        Return true on success, false otherwise.
        """
        from distutils.ccompiler import CompileError
        self._check_compiler()
        try:
            self._compile(body, headers, include_dirs, lang)
            ok = 1
        except CompileError:
            ok = 0

        log.info(ok and "success!" or "failure.")
        self._clean()
        return ok

    def try_link(self, body, headers=None, include_dirs=None, libraries=None,
                 library_dirs=None, lang="c"):
        """Try to compile and link a source file, built from 'body' and
        'headers', to executable form.  Return true on success, false
        otherwise.
        """
        from distutils.ccompiler import CompileError, LinkError
        self._check_compiler()
        try:
            self._link(body, headers, include_dirs,
                       libraries, library_dirs, lang)
            ok = 1
        except (CompileError, LinkError):
            ok = 0

        log.info(ok and "success!" or "failure.")
        self._clean()
        return ok

    def try_run(self, body, headers=None, include_dirs=None, libraries=None,
                library_dirs=None, lang="c"):
        """Try to compile, link to an executable, and run a program
        built from 'body' and 'headers'.  Return true on success, false
        otherwise.
        """
        from distutils.ccompiler import CompileError, LinkError
        self._check_compiler()
        try:
            src, obj, exe = self._link(body, headers, include_dirs,
                                       libraries, library_dirs, lang)
            self.spawn([exe])
            ok = 1
        except (CompileError, LinkError, DistutilsExecError):
            ok = 0

        log.info(ok and "success!" or "failure.")
        self._clean()
        return ok


    # -- High-level methods --------------------------------------------
    # (these are the ones that are actually likely to be useful
    # when implementing a real-world config command!)

    def check_func(self, func, headers=None, include_dirs=None,
                   libraries=None, library_dirs=None, decl=0, call=0):

        """Determine if function 'func' is available by constructing a
        source file that refers to 'func', and compiles and links it.
        If everything succeeds, returns true; otherwise returns false.

        The constructed source file starts out by including the header
        files listed in 'headers'.  If 'decl' is true, it then declares
        'func' (as "int func()"); you probably shouldn't supply 'headers'
        and set 'decl' true in the same call, or you might get errors about
        a conflicting declarations for 'func'.  Finally, the constructed
        'main()' function either references 'func' or (if 'call' is true)
        calls it.  'libraries' and 'library_dirs' are used when
        linking.
        """

        self._check_compiler()
        body = []
        if decl:
            body.append("int %s ();" % func)
        body.append("int main () {")
        if call:
            body.append("  %s();" % func)
        else:
            body.append("  %s;" % func)
        body.append("}")
        body = "\n".join(body) + "\n"

        return self.try_link(body, headers, include_dirs,
                             libraries, library_dirs)

    # check_func ()

    def check_lib(self, library, library_dirs=None, headers=None,
                  include_dirs=None, other_libraries=[]):
        """Determine if 'library' is available to be linked against,
        without actually checking that any particular symbols are provided
        by it.  'headers' will be used in constructing the source file to
        be compiled, but the only effect of this is to check if all the
        header files listed are available.  Any libraries listed in
        'other_libraries' will be included in the link, in case 'library'
        has symbols that depend on other libraries.
        """
        self._check_compiler()
        return self.try_link("int main (void) { }",
                             headers, include_dirs,
                             [library]+other_libraries, library_dirs)

    def check_header(self, header, include_dirs=None, library_dirs=None,
                     lang="c"):
        """Determine if the system header file named by 'header_file'
        exists and can be found by the preprocessor; return true if so,
        false otherwise.
        """
        return self.try_cpp(body="/* No body */", headers=[header],
                            include_dirs=include_dirs)


def dump_file(filename, head=None):
    """Dumps a file content into log.info.

    If head is not None, will be dumped before the file content.
    """
    if head is None:
        log.info('%s' % filename)
    else:
        log.info(head)
    file = open(filename)
    try:
        log.info(file.read())
    finally:
        file.close()
                                                                                                                                                                                      usr/lib/python2.7/distutils/command/config.pyc                                                      0100644 0000000 0000000 00000030551 13077704274 020037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sû   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z i d d	 6d
 d 6Z d e f d Ñ  É  YZ e d Ñ Z d S(   sÍ  distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
s   $Id$iˇˇˇˇN(   t   Command(   t   DistutilsExecError(   t   customize_compiler(   t   logs   .ct   cs   .cxxs   c++t   configc           B   s.  e  Z d  Z d, d- d. d/ d0 d1 d2 d3 d4 g	 Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d  Ñ  Z d+ d+ d+ d! d" Ñ Z d+ d+ d+ d! d# Ñ Z d+ d+ d! d$ Ñ Z d+ d+ d+ d+ d! d% Ñ Z d+ d+ d+ d+ d! d& Ñ Z d+ d+ d+ d+ d' d' d( Ñ Z d+ d+ d+ g  d) Ñ Z d+ d+ d! d* Ñ Z RS(5   s   prepare to builds	   compiler=s   specify the compiler types   cc=s   specify the compiler executables   include-dirs=t   Is.   list of directories to search for header filess   define=t   Ds   C preprocessor macros to defines   undef=t   Us!   C preprocessor macros to undefines
   libraries=t   ls!   external C libraries to link withs   library-dirs=t   Ls.   directories to search for external C librariest   noisys1   show every action (compile, link, run, ...) takens   dump-sources=   dump generated source files before attempting to compile themc         C   sL   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ g  |  _ d  S(   Ni   (	   t   Nonet   compilert   cct   include_dirst	   librariest   library_dirsR   t   dump_sourcet
   temp_files(   t   self(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   initialize_options6   s    							c         C   sﬂ   |  j  d  k r' |  j j  p g  |  _  n- t |  j  t É rT |  j  j t j É |  _  n  |  j d  k ro g  |  _ n$ t |  j t É rì |  j g |  _ n  |  j	 d  k rÆ g  |  _	 n- t |  j	 t É r€ |  j	 j t j É |  _	 n  d  S(   N(
   R   R   t   distributiont
   isinstancet   strt   splitt   ost   pathsepR   R   (   R   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   finalize_optionsE   s    c         C   s   d  S(   N(    (   R   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   runU   s    c         C   sΩ   d d l  m } m } t |  j | É sπ | d |  j d |  j d d É |  _ t |  j É |  j rx |  j j |  j É n  |  j	 ró |  j j
 |  j	 É n  |  j rπ |  j j |  j É qπ n  d S(   s^   Check that 'self.compiler' really is a CCompiler object;
        if not, make it one.
        iˇˇˇˇ(   t	   CCompilert   new_compilerR   t   dry_runt   forcei   N(   t   distutils.ccompilerR   R   R   R   R    R   R   t   set_include_dirsR   t   set_librariesR   t   set_library_dirs(   R   R   R   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _check_compiler]   s    			c         C   sê   d t  | } t | d É } | rU x | D] } | j d | É q* W| j d É n  | j | É | d d k rÇ | j d É n  | j É  | S(   Nt   _configtestt   ws   #include <%s>
s   
iˇˇˇˇ(   t   LANG_EXTt   opent   writet   close(   R   t   bodyt   headerst   langt   filenamet   filet   header(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _gen_temp_sourcefilep   s    
c         C   sT   |  j  | | | É } d } |  j j | | g É |  j j | | d | É| | f S(   Ns   _configtest.iR   (   R3   R   t   extendR   t
   preprocess(   R   R-   R.   R   R/   t   srct   out(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _preprocess}   s
    c         C   sÉ   |  j  | | | É } |  j r2 t | d | É n  |  j j | g É \ } |  j j | | g É |  j j | g d | É| | f S(   Ns   compiling '%s':R   (   R3   R   t	   dump_fileR   t   object_filenamesR   R4   t   compile(   R   R-   R.   R   R/   R6   t   obj(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _compileÑ   s    	c   
   	   C   s™   |  j  | | | | É \ } } t j j t j j | É É d }	 |  j j | g |	 d | d | d | É|  j j d  k	 rç |	 |  j j }	 n  |  j	 j
 |	 É | | |	 f S(   Ni    R   R   t   target_lang(   R=   R   t   patht   splitextt   basenameR   t   link_executablet   exe_extensionR   R   t   append(
   R   R-   R.   R   R   R   R/   R6   R<   t   prog(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _linkç   s    "c         G   sn   | s |  j  } g  |  _  n  t j d d j | É É x3 | D]+ } y t j | É Wq; t k
 re q; Xq; Wd  S(   Ns   removing: %st    (   R   R   t   infot   joinR   t   removet   OSError(   R   t	   filenamesR0   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _cleanú   s    	R   c         C   sb   d d l  m } |  j É  d } y |  j | | | | É Wn | k
 rS d } n X|  j É  | S(   sQ  Construct a source file from 'body' (a string containing lines
        of C/C++ code) and 'headers' (a list of header files to include)
        and run it through the preprocessor.  Return true if the
        preprocessor succeeded, false if there were any errors.
        ('body' probably isn't of much use, but what the heck.)
        iˇˇˇˇ(   t   CompileErrori   i    (   R"   RN   R&   R8   RM   (   R   R-   R.   R   R/   RN   t   ok(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_cpp≤   s    


c         C   sÆ   |  j  É  |  j | | | | É \ } } t | t É rI t j | É } n  t | É } d }	 x8 | j É  }
 |
 d k rz Pn  | j |
 É r^ d }	 Pq^ q^ | j	 É  |  j
 É  |	 S(   s¥  Construct a source file (just like 'try_cpp()'), run it through
        the preprocessor, and return true if any line of the output matches
        'pattern'.  'pattern' should either be a compiled regex object or a
        string containing a regex.  If both 'body' and 'headers' are None,
        preprocesses an empty file -- which can be useful to determine the
        symbols the preprocessor and compiler set by default.
        i    t    i   (   R&   R8   R   R   t   reR;   R*   t   readlinet   searchR,   RM   (   R   t   patternR-   R.   R   R/   R6   R7   R1   t   matcht   line(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt
   search_cppƒ   s     	


c         C   s{   d d l  m } |  j É  y  |  j | | | | É d } Wn | k
 rS d } n Xt j | rf d pi d É |  j É  | S(   sw   Try to compile a source file built from 'body' and 'headers'.
        Return true on success, false otherwise.
        iˇˇˇˇ(   RN   i   i    s   success!s   failure.(   R"   RN   R&   R=   R   RH   RM   (   R   R-   R.   R   R/   RN   RO   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_compile·   s    



c   
      C   sç   d d l  m } m } |  j É  y& |  j | | | | | | É d }	 Wn | | f k
 re d }	 n Xt j |	 rx d p{ d É |  j É  |	 S(   sû   Try to compile and link a source file, built from 'body' and
        'headers', to executable form.  Return true on success, false
        otherwise.
        iˇˇˇˇ(   RN   t	   LinkErrori   i    s   success!s   failure.(   R"   RN   RZ   R&   RF   R   RH   RM   (
   R   R-   R.   R   R   R   R/   RN   RZ   RO   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_linkÒ   s    



c         C   s´   d d l  m } m } |  j É  yA |  j | | | | | | É \ }	 }
 } |  j | g É d } Wn  | | t f k
 rÉ d } n Xt j | rñ d pô d É |  j	 É  | S(   sú   Try to compile, link to an executable, and run a program
        built from 'body' and 'headers'.  Return true on success, false
        otherwise.
        iˇˇˇˇ(   RN   RZ   i   i    s   success!s   failure.(
   R"   RN   RZ   R&   RF   t   spawnR   R   RH   RM   (   R   R-   R.   R   R   R   R/   RN   RZ   R6   R<   t   exeRO   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_run  s    



i    c   	      C   sõ   |  j  É  g  } | r* | j d | É n  | j d É | rQ | j d | É n | j d | É | j d É d j | É d } |  j | | | | | É S(   s€  Determine if function 'func' is available by constructing a
        source file that refers to 'func', and compiles and links it.
        If everything succeeds, returns true; otherwise returns false.

        The constructed source file starts out by including the header
        files listed in 'headers'.  If 'decl' is true, it then declares
        'func' (as "int func()"); you probably shouldn't supply 'headers'
        and set 'decl' true in the same call, or you might get errors about
        a conflicting declarations for 'func'.  Finally, the constructed
        'main()' function either references 'func' or (if 'call' is true)
        calls it.  'libraries' and 'library_dirs' are used when
        linking.
        s
   int %s ();s   int main () {s     %s();s     %s;t   }s   
(   R&   RD   RI   R[   (	   R   t   funcR.   R   R   R   t   declt   callR-   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt
   check_func  s    
c         C   s*   |  j  É  |  j d | | | g | | É S(   s·  Determine if 'library' is available to be linked against,
        without actually checking that any particular symbols are provided
        by it.  'headers' will be used in constructing the source file to
        be compiled, but the only effect of this is to check if all the
        header files listed are available.  Any libraries listed in
        'other_libraries' will be included in the link, in case 'library'
        has symbols that depend on other libraries.
        s   int main (void) { }(   R&   R[   (   R   t   libraryR   R.   R   t   other_libraries(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt	   check_lib?  s    

	c         C   s   |  j  d d d | g d | É S(   s§   Determine if the system header file named by 'header_file'
        exists and can be found by the preprocessor; return true if so,
        false otherwise.
        R-   s   /* No body */R.   R   (   RP   (   R   R2   R   R   R/   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   check_headerN  s    N(   s	   compiler=Ns   specify the compiler type(   s   cc=Ns   specify the compiler executable(   s   include-dirs=R   s.   list of directories to search for header files(   s   define=R   s   C preprocessor macros to define(   s   undef=R   s!   C preprocessor macros to undefine(   s
   libraries=R	   s!   external C libraries to link with(   s   library-dirs=R
   s.   directories to search for external C libraries(   s   noisyNs1   show every action (compile, link, run, ...) taken(   s   dump-sourceNs=   dump generated source files before attempting to compile them(   t   __name__t
   __module__t   descriptionR   t   user_optionsR   R   R   R&   R3   R8   R=   RF   RM   RP   RX   RY   R[   R^   Rc   Rf   Rg   (    (    (    s.   /usr/lib/python2.7/distutils/command/config.pyR      sT            														!c         C   sb   | d k r  t j d |  É n t j | É t |  É } z t j | j É  É Wd | j É  Xd S(   sj   Dumps a file content into log.info.

    If head is not None, will be dumped before the file content.
    s   %sN(   R   R   RH   R*   t   readR,   (   R0   t   headR1   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyR9   X  s    (   t   __doc__t   __revision__R   RR   t   distutils.coreR    t   distutils.errorsR   t   distutils.sysconfigR   t	   distutilsR   R)   R   R   R9   (    (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   <module>
   s   ˇ A                                                                                                                                                       usr/lib/python2.7/distutils/command/install.py                                                      0100644 0000000 0000000 00000066536 12734733743 020113  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.install

Implements the Distutils 'install' command."""

from distutils import log

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import sys, os, string
from types import *
from distutils.core import Command
from distutils.debug import DEBUG
from distutils.sysconfig import get_config_vars
from distutils.errors import DistutilsPlatformError
from distutils.file_util import write_file
from distutils.util import convert_path, subst_vars, change_root
from distutils.util import get_platform
from distutils.errors import DistutilsOptionError
from site import USER_BASE
from site import USER_SITE


if sys.version < "2.2":
    WINDOWS_SCHEME = {
        'purelib': '$base',
        'platlib': '$base',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }
else:
    WINDOWS_SCHEME = {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }

INSTALL_SCHEMES = {
    'unix_prefix': {
        'purelib': '$base/lib/python$py_version_short/site-packages',
        'platlib': '$platbase/lib/python$py_version_short/site-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_local': {
        'purelib': '$base/local/lib/python$py_version_short/dist-packages',
        'platlib': '$platbase/local/lib/python$py_version_short/dist-packages',
        'headers': '$base/local/include/python$py_version_short/$dist_name',
        'scripts': '$base/local/bin',
        'data'   : '$base/local',
        },
    'deb_system': {
        'purelib': '$base/lib/python$py_version_short/dist-packages',
        'platlib': '$platbase/lib/python$py_version_short/dist-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_home': {
        'purelib': '$base/lib/python',
        'platlib': '$base/lib/python',
        'headers': '$base/include/python/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_user': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/include/python$py_version_short/$dist_name',
        'scripts': '$userbase/bin',
        'data'   : '$userbase',
        },
    'nt': WINDOWS_SCHEME,
    'nt_user': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/Python$py_version_nodot/Include/$dist_name',
        'scripts': '$userbase/Scripts',
        'data'   : '$userbase',
        },
    'os2': {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
        },
    'os2_home': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/include/python$py_version_short/$dist_name',
        'scripts': '$userbase/bin',
        'data'   : '$userbase',
        },
    }

# The keys to an installation scheme; if any new types of files are to be
# installed, be sure to add an entry to every installation scheme above,
# and to SCHEME_KEYS here.
SCHEME_KEYS = ('purelib', 'platlib', 'headers', 'scripts', 'data')


class install (Command):

    description = "install everything from build directory"

    user_options = [
        # Select installation scheme and set base director(y|ies)
        ('prefix=', None,
         "installation prefix"),
        ('exec-prefix=', None,
         "(Unix only) prefix for platform-specific files"),
        ('home=', None,
         "(Unix only) home directory to install under"),
        ('user', None,
         "install in user site-package '%s'" % USER_SITE),

        # Or, just set the base director(y|ies)
        ('install-base=', None,
         "base installation directory (instead of --prefix or --home)"),
        ('install-platbase=', None,
         "base installation directory for platform-specific files " +
         "(instead of --exec-prefix or --home)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),

        # Or, explicitly set the installation scheme
        ('install-purelib=', None,
         "installation directory for pure Python module distributions"),
        ('install-platlib=', None,
         "installation directory for non-pure module distributions"),
        ('install-lib=', None,
         "installation directory for all module distributions " +
         "(overrides --install-purelib and --install-platlib)"),

        ('install-headers=', None,
         "installation directory for C/C++ headers"),
        ('install-scripts=', None,
         "installation directory for Python scripts"),
        ('install-data=', None,
         "installation directory for data files"),

        # Byte-compilation options -- see install_lib.py for details, as
        # these are duplicated from there (but only install_lib does
        # anything with them).
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),

        # Miscellaneous control options
        ('force', 'f',
         "force installation (overwrite any existing files)"),
        ('skip-build', None,
         "skip rebuilding everything (for testing/debugging)"),

        # Where to install documentation (eventually!)
        #('doc-format=', None, "format of documentation to generate"),
        #('install-man=', None, "directory for Unix man pages"),
        #('install-html=', None, "directory for HTML documentation"),
        #('install-info=', None, "directory for GNU info files"),

        ('record=', None,
         "filename in which to record list of installed files"),

        ('install-layout=', None,
         "installation layout to choose (known values: deb, unix)"),
        ]

    boolean_options = ['compile', 'force', 'skip-build', 'user']
    negative_opt = {'no-compile' : 'compile'}


    def initialize_options (self):

        # High-level options: these select both an installation base
        # and scheme.
        self.prefix = None
        self.exec_prefix = None
        self.home = None
        self.user = 0
        self.prefix_option = None

        # These select only the installation base; it's up to the user to
        # specify the installation scheme (currently, that means supplying
        # the --install-{platlib,purelib,scripts,data} options).
        self.install_base = None
        self.install_platbase = None
        self.root = None

        # These options are the actual installation directories; if not
        # supplied by the user, they are filled in using the installation
        # scheme implied by prefix/exec-prefix/home and the contents of
        # that installation scheme.
        self.install_purelib = None     # for pure module distributions
        self.install_platlib = None     # non-pure (dists w/ extensions)
        self.install_headers = None     # for C/C++ headers
        self.install_lib = None         # set to either purelib or platlib
        self.install_scripts = None
        self.install_data = None
        self.install_userbase = USER_BASE
        self.install_usersite = USER_SITE

        # enable custom installation, known values: deb
        self.install_layout = None

        self.compile = None
        self.optimize = None

        # These two are for putting non-packagized distributions into their
        # own directory and creating a .pth file if it makes sense.
        # 'extra_path' comes from the setup file; 'install_path_file' can
        # be turned off if it makes no sense to install a .pth file.  (But
        # better to install it uselessly than to guess wrong and not
        # install it when it's necessary and would be used!)  Currently,
        # 'install_path_file' is always true unless some outsider meddles
        # with it.
        self.extra_path = None
        self.install_path_file = 1

        # 'force' forces installation, even if target files are not
        # out-of-date.  'skip_build' skips running the "build" command,
        # handy if you know it's not necessary.  'warn_dir' (which is *not*
        # a user option, it's just there so the bdist_* commands can turn
        # it off) determines whether we warn about installing to a
        # directory not in sys.path.
        self.force = 0
        self.skip_build = 0
        self.warn_dir = 1

        # These are only here as a conduit from the 'build' command to the
        # 'install_*' commands that do the real work.  ('build_base' isn't
        # actually used anywhere, but it might be useful in future.)  They
        # are not user options, because if the user told the install
        # command where the build directory is, that wouldn't affect the
        # build command.
        self.build_base = None
        self.build_lib = None

        # Not defined yet because we don't know anything about
        # documentation yet.
        #self.install_man = None
        #self.install_html = None
        #self.install_info = None

        self.record = None


    # -- Option finalizing methods -------------------------------------
    # (This is rather more involved than for most commands,
    # because this is where the policy for installing third-
    # party Python modules on various platforms given a wide
    # array of user input is decided.  Yes, it's quite complex!)

    def finalize_options (self):

        # This method (and its pliant slaves, like 'finalize_unix()',
        # 'finalize_other()', and 'select_scheme()') is where the default
        # installation directories for modules, extension modules, and
        # anything else we care to install from a Python module
        # distribution.  Thus, this code makes a pretty important policy
        # statement about how third-party stuff is added to a Python
        # installation!  Note that the actual work of installation is done
        # by the relatively simple 'install_*' commands; they just take
        # their orders from the installation directory options determined
        # here.

        # Check for errors/inconsistencies in the options; first, stuff
        # that's wrong on any platform.

        if ((self.prefix or self.exec_prefix or self.home) and
            (self.install_base or self.install_platbase)):
            raise DistutilsOptionError, \
                  ("must supply either prefix/exec-prefix/home or " +
                   "install-base/install-platbase -- not both")

        if self.home and (self.prefix or self.exec_prefix):
            raise DistutilsOptionError, \
                  "must supply either home or prefix/exec-prefix -- not both"

        if self.user and (self.prefix or self.exec_prefix or self.home or
                self.install_base or self.install_platbase):
            raise DistutilsOptionError("can't combine user with prefix, "
                                       "exec_prefix/home, or install_(plat)base")

        # Next, stuff that's wrong (or dubious) only on certain platforms.
        if os.name != "posix":
            if self.exec_prefix:
                self.warn("exec-prefix option ignored on this platform")
                self.exec_prefix = None

        # Now the interesting logic -- so interesting that we farm it out
        # to other methods.  The goal of these methods is to set the final
        # values for the install_{lib,scripts,data,...}  options, using as
        # input a heady brew of prefix, exec_prefix, home, install_base,
        # install_platbase, user-supplied versions of
        # install_{purelib,platlib,lib,scripts,data,...}, and the
        # INSTALL_SCHEME dictionary above.  Phew!

        self.dump_dirs("pre-finalize_{unix,other}")

        if os.name == 'posix':
            self.finalize_unix()
        else:
            self.finalize_other()

        self.dump_dirs("post-finalize_{unix,other}()")

        # Expand configuration variables, tilde, etc. in self.install_base
        # and self.install_platbase -- that way, we can use $base or
        # $platbase in the other installation directories and not worry
        # about needing recursive variable expansion (shudder).

        py_version = (string.split(sys.version))[0]
        (prefix, exec_prefix) = get_config_vars('prefix', 'exec_prefix')
        self.config_vars = {'dist_name': self.distribution.get_name(),
                            'dist_version': self.distribution.get_version(),
                            'dist_fullname': self.distribution.get_fullname(),
                            'py_version': py_version,
                            'py_version_short': py_version[0:3],
                            'py_version_nodot': py_version[0] + py_version[2],
                            'sys_prefix': prefix,
                            'prefix': prefix,
                            'sys_exec_prefix': exec_prefix,
                            'exec_prefix': exec_prefix,
                            'userbase': self.install_userbase,
                            'usersite': self.install_usersite,
                           }
        self.expand_basedirs()

        self.dump_dirs("post-expand_basedirs()")

        # Now define config vars for the base directories so we can expand
        # everything else.
        self.config_vars['base'] = self.install_base
        self.config_vars['platbase'] = self.install_platbase

        if DEBUG:
            from pprint import pprint
            print "config vars:"
            pprint(self.config_vars)

        # Expand "~" and configuration variables in the installation
        # directories.
        self.expand_dirs()

        self.dump_dirs("post-expand_dirs()")

        # Create directories in the home dir:
        if self.user:
            self.create_home_path()

        # Pick the actual directory to install all modules to: either
        # install_purelib or install_platlib, depending on whether this
        # module distribution is pure or not.  Of course, if the user
        # already specified install_lib, use their selection.
        if self.install_lib is None:
            if self.distribution.ext_modules: # has extensions: non-pure
                self.install_lib = self.install_platlib
            else:
                self.install_lib = self.install_purelib


        # Convert directories from Unix /-separated syntax to the local
        # convention.
        self.convert_paths('lib', 'purelib', 'platlib',
                           'scripts', 'data', 'headers',
                           'userbase', 'usersite')

        # Well, we're not actually fully completely finalized yet: we still
        # have to deal with 'extra_path', which is the hack for allowing
        # non-packagized module distributions (hello, Numerical Python!) to
        # get their own directories.
        self.handle_extra_path()
        self.install_libbase = self.install_lib # needed for .pth file
        self.install_lib = os.path.join(self.install_lib, self.extra_dirs)

        # If a new root directory was supplied, make all the installation
        # dirs relative to it.
        if self.root is not None:
            self.change_roots('libbase', 'lib', 'purelib', 'platlib',
                              'scripts', 'data', 'headers')

        self.dump_dirs("after prepending root")

        # Find out the build directories, ie. where to install from.
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'),
                                   ('build_lib', 'build_lib'))

        # Punt on doc directories for now -- after all, we're punting on
        # documentation completely!

    # finalize_options ()


    def dump_dirs (self, msg):
        if DEBUG:
            from distutils.fancy_getopt import longopt_xlate
            print msg + ":"
            for opt in self.user_options:
                opt_name = opt[0]
                if opt_name[-1] == "=":
                    opt_name = opt_name[0:-1]
                if opt_name in self.negative_opt:
                    opt_name = string.translate(self.negative_opt[opt_name],
                                                longopt_xlate)
                    val = not getattr(self, opt_name)
                else:
                    opt_name = string.translate(opt_name, longopt_xlate)
                    val = getattr(self, opt_name)
                print "  %s: %s" % (opt_name, val)


    def finalize_unix (self):

        if self.install_base is not None or self.install_platbase is not None:
            if ((self.install_lib is None and
                 self.install_purelib is None and
                 self.install_platlib is None) or
                self.install_headers is None or
                self.install_scripts is None or
                self.install_data is None):
                raise DistutilsOptionError, \
                      ("install-base or install-platbase supplied, but "
                      "installation scheme is incomplete")
            return

        if self.user:
            if self.install_userbase is None:
                raise DistutilsPlatformError(
                    "User base directory is not specified")
            self.install_base = self.install_platbase = self.install_userbase
            self.select_scheme("unix_user")
        elif self.home is not None:
            self.install_base = self.install_platbase = self.home
            self.select_scheme("unix_home")
        else:
            self.prefix_option = self.prefix
            if self.prefix is None:
                if self.exec_prefix is not None:
                    raise DistutilsOptionError, \
                          "must not supply exec-prefix without prefix"

                self.prefix = os.path.normpath(sys.prefix)
                self.exec_prefix = os.path.normpath(sys.exec_prefix)

            else:
                if self.exec_prefix is None:
                    self.exec_prefix = self.prefix

            self.install_base = self.prefix
            self.install_platbase = self.exec_prefix
            if self.install_layout:
                if self.install_layout.lower() in ['deb']:
                    self.select_scheme("deb_system")
                elif self.install_layout.lower() in ['posix', 'unix']:
                    self.select_scheme("unix_prefix")
                else:
                    raise DistutilsOptionError(
                        "unknown value for --install-layout")
            elif (self.prefix_option and os.path.normpath(self.prefix) != '/usr/local') \
                    or 'PYTHONUSERBASE' in os.environ \
                    or 'real_prefix' in sys.__dict__:
                self.select_scheme("unix_prefix")
            else:
                if os.path.normpath(self.prefix) == '/usr/local':
                    self.select_scheme("deb_system")
                else:
                    self.select_scheme("unix_local")

    # finalize_unix ()


    def finalize_other (self):          # Windows and Mac OS for now

        if self.user:
            if self.install_userbase is None:
                raise DistutilsPlatformError(
                    "User base directory is not specified")
            self.install_base = self.install_platbase = self.install_userbase
            self.select_scheme(os.name + "_user")
        elif self.home is not None:
            self.install_base = self.install_platbase = self.home
            self.select_scheme("unix_home")
        else:
            if self.prefix is None:
                self.prefix = os.path.normpath(sys.prefix)

            self.install_base = self.install_platbase = self.prefix
            try:
                self.select_scheme(os.name)
            except KeyError:
                raise DistutilsPlatformError, \
                      "I don't know how to install stuff on '%s'" % os.name

    # finalize_other ()


    def select_scheme (self, name):
        # it's the caller's problem if they supply a bad name!
        scheme = INSTALL_SCHEMES[name]
        for key in SCHEME_KEYS:
            attrname = 'install_' + key
            if getattr(self, attrname) is None:
                setattr(self, attrname, scheme[key])


    def _expand_attrs (self, attrs):
        for attr in attrs:
            val = getattr(self, attr)
            if val is not None:
                if os.name == 'posix' or os.name == 'nt':
                    val = os.path.expanduser(val)
                val = subst_vars(val, self.config_vars)
                setattr(self, attr, val)


    def expand_basedirs (self):
        self._expand_attrs(['install_base',
                            'install_platbase',
                            'root'])

    def expand_dirs (self):
        self._expand_attrs(['install_purelib',
                            'install_platlib',
                            'install_lib',
                            'install_headers',
                            'install_scripts',
                            'install_data',])


    def convert_paths (self, *names):
        for name in names:
            attr = "install_" + name
            setattr(self, attr, convert_path(getattr(self, attr)))


    def handle_extra_path (self):

        if self.extra_path is None:
            self.extra_path = self.distribution.extra_path

        if self.extra_path is not None:
            if type(self.extra_path) is StringType:
                self.extra_path = string.split(self.extra_path, ',')

            if len(self.extra_path) == 1:
                path_file = extra_dirs = self.extra_path[0]
            elif len(self.extra_path) == 2:
                (path_file, extra_dirs) = self.extra_path
            else:
                raise DistutilsOptionError, \
                      ("'extra_path' option must be a list, tuple, or "
                      "comma-separated string with 1 or 2 elements")

            # convert to local form in case Unix notation used (as it
            # should be in setup scripts)
            extra_dirs = convert_path(extra_dirs)

        else:
            path_file = None
            extra_dirs = ''

        # XXX should we warn if path_file and not extra_dirs? (in which
        # case the path file would be harmless but pointless)
        self.path_file = path_file
        self.extra_dirs = extra_dirs

    # handle_extra_path ()


    def change_roots (self, *names):
        for name in names:
            attr = "install_" + name
            setattr(self, attr, change_root(self.root, getattr(self, attr)))

    def create_home_path(self):
        """Create directories under ~
        """
        if not self.user:
            return
        home = convert_path(os.path.expanduser("~"))
        for name, path in self.config_vars.iteritems():
            if path.startswith(home) and not os.path.isdir(path):
                self.debug_print("os.makedirs('%s', 0700)" % path)
                os.makedirs(path, 0700)

    # -- Command execution methods -------------------------------------

    def run (self):

        # Obviously have to build before we can install
        if not self.skip_build:
            self.run_command('build')
            # If we built for any other platform, we can't install.
            build_plat = self.distribution.get_command_obj('build').plat_name
            # check warn_dir - it is a clue that the 'install' is happening
            # internally, and not to sys.path, so we don't check the platform
            # matches what we are running.
            if self.warn_dir and build_plat != get_platform():
                raise DistutilsPlatformError("Can't install when "
                                             "cross-compiling")

        # Run all sub-commands (at least those that need to be run)
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        if self.path_file:
            self.create_path_file()

        # write list of installed files, if requested.
        if self.record:
            outputs = self.get_outputs()
            if self.root:               # strip any package prefix
                root_len = len(self.root)
                for counter in xrange(len(outputs)):
                    outputs[counter] = outputs[counter][root_len:]
            self.execute(write_file,
                         (self.record, outputs),
                         "writing list of installed files to '%s'" %
                         self.record)

        sys_path = map(os.path.normpath, sys.path)
        sys_path = map(os.path.normcase, sys_path)
        install_lib = os.path.normcase(os.path.normpath(self.install_lib))
        if (self.warn_dir and
            not (self.path_file and self.install_path_file) and
            install_lib not in sys_path):
            log.debug(("modules installed to '%s', which is not in "
                       "Python's module search path (sys.path) -- "
                       "you'll have to change the search path yourself"),
                       self.install_lib)

    # run ()

    def create_path_file (self):
        filename = os.path.join(self.install_libbase,
                                self.path_file + ".pth")
        if self.install_path_file:
            self.execute(write_file,
                         (filename, [self.extra_dirs]),
                         "creating %s" % filename)
        else:
            self.warn("path file '%s' not created" % filename)


    # -- Reporting methods ---------------------------------------------

    def get_outputs (self):
        # Assemble the outputs of all the sub-commands.
        outputs = []
        for cmd_name in self.get_sub_commands():
            cmd = self.get_finalized_command(cmd_name)
            # Add the contents of cmd.get_outputs(), ensuring
            # that outputs doesn't contain duplicate entries
            for filename in cmd.get_outputs():
                if filename not in outputs:
                    outputs.append(filename)

        if self.path_file and self.install_path_file:
            outputs.append(os.path.join(self.install_libbase,
                                        self.path_file + ".pth"))

        return outputs

    def get_inputs (self):
        # XXX gee, this looks familiar ;-(
        inputs = []
        for cmd_name in self.get_sub_commands():
            cmd = self.get_finalized_command(cmd_name)
            inputs.extend(cmd.get_inputs())

        return inputs


    # -- Predicates for sub-command list -------------------------------

    def has_lib (self):
        """Return true if the current distribution has any Python
        modules to install."""
        return (self.distribution.has_pure_modules() or
                self.distribution.has_ext_modules())

    def has_headers (self):
        return self.distribution.has_headers()

    def has_scripts (self):
        return self.distribution.has_scripts()

    def has_data (self):
        return self.distribution.has_data_files()


    # 'sub_commands': a list of commands this command might have to run to
    # get its work done.  See cmd.py for more info.
    sub_commands = [('install_lib',     has_lib),
                    ('install_headers', has_headers),
                    ('install_scripts', has_scripts),
                    ('install_data',    has_data),
                    ('install_egg_info', lambda self:True),
                   ]

# class install
                                                                                                                                                                  usr/lib/python2.7/distutils/command/install.pyc                                                     0100644 0000000 0000000 00000043073 13077704274 020243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s◊  d  Z  d d l m Z d Z d d l Z d d l Z d d l Z d d l Td d l m	 Z	 d d l
 m Z d d l m Z d d	 l m Z d d
 l m Z d d l m Z m Z m Z d d l m Z d d l m Z d d l m Z d d l m Z e j d k  r1i d d 6d d 6d d 6d d 6d d 6Z n) i d d 6d d 6d d 6d d 6d d 6Z i	 i d d 6d d 6d d 6d d 6d d 6d 6i d d 6d  d 6d! d 6d" d 6d# d 6d$ 6i d% d 6d& d 6d d 6d d 6d d 6d' 6i d( d 6d( d 6d) d 6d d 6d d 6d* 6i d+ d 6d+ d 6d, d 6d- d 6d. d 6d/ 6e d0 6i d+ d 6d+ d 6d1 d 6d2 d 6d. d 6d3 6i d d 6d d 6d d 6d d 6d d 6d4 6i d+ d 6d+ d 6d, d 6d- d 6d. d 6d5 6Z d8 Z d6 e	 f d7 Ñ  É  YZ d S(9   sF   distutils.command.install

Implements the Distutils 'install' command.iˇˇˇˇ(   t   logs   $Id$N(   t   *(   t   Command(   t   DEBUG(   t   get_config_vars(   t   DistutilsPlatformError(   t
   write_file(   t   convert_patht
   subst_varst   change_root(   t   get_platform(   t   DistutilsOptionError(   t	   USER_BASE(   t	   USER_SITEs   2.2s   $baset   purelibt   platlibs   $base/Include/$dist_namet   headerss   $base/Scriptst   scriptst   datas   $base/Lib/site-packagess/   $base/lib/python$py_version_short/site-packagess3   $platbase/lib/python$py_version_short/site-packagess0   $base/include/python$py_version_short/$dist_names	   $base/bint   unix_prefixs5   $base/local/lib/python$py_version_short/dist-packagess9   $platbase/local/lib/python$py_version_short/dist-packagess6   $base/local/include/python$py_version_short/$dist_names   $base/local/bins   $base/localt
   unix_locals/   $base/lib/python$py_version_short/dist-packagess3   $platbase/lib/python$py_version_short/dist-packagest
   deb_systems   $base/lib/pythons   $base/include/python/$dist_namet	   unix_homes	   $usersites4   $userbase/include/python$py_version_short/$dist_names   $userbase/bins	   $userbaset	   unix_usert   nts4   $userbase/Python$py_version_nodot/Include/$dist_names   $userbase/Scriptst   nt_usert   os2t   os2_homet   installc           B   sâ  e  Z d  Z dJ dK dL d dI d e f dM d dI d d f dN dO dP d dI d d f dQ dR dS dT dU dV dW dX dY dZ g Z d d% d( d g Z i d d  6Z d. Ñ  Z d/ Ñ  Z	 d0 Ñ  Z
 d1 Ñ  Z d2 Ñ  Z d3 Ñ  Z d4 Ñ  Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z d< Ñ  Z d= Ñ  Z d> Ñ  Z d? Ñ  Z d@ Ñ  Z dA Ñ  Z dB Ñ  Z dC e f dD e f dE e f dF e f dG dH Ñ  f g Z RS([   s'   install everything from build directorys   prefix=s   installation prefixs   exec-prefix=s.   (Unix only) prefix for platform-specific filess   home=s+   (Unix only) home directory to install undert   users!   install in user site-package '%s's   install-base=s;   base installation directory (instead of --prefix or --home)s   install-platbase=s8   base installation directory for platform-specific files s$   (instead of --exec-prefix or --home)s   root=s<   install everything relative to this alternate root directorys   install-purelib=s;   installation directory for pure Python module distributionss   install-platlib=s8   installation directory for non-pure module distributionss   install-lib=s4   installation directory for all module distributions s3   (overrides --install-purelib and --install-platlib)s   install-headers=s(   installation directory for C/C++ headerss   install-scripts=s)   installation directory for Python scriptss   install-data=s%   installation directory for data filest   compilet   cs   compile .py to .pyc [default]s
   no-compiles   don't compile .py filess	   optimize=t   Osl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]t   forcet   fs1   force installation (overwrite any existing files)s
   skip-builds2   skip rebuilding everything (for testing/debugging)s   record=s3   filename in which to record list of installed filess   install-layout=s7   installation layout to choose (known values: deb, unix)c         C   s˜   d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ t |  _ t |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    i   (   t   Nonet   prefixt   exec_prefixt   homeR   t   prefix_optiont   install_baset   install_platbaset   roott   install_purelibt   install_platlibt   install_headerst   install_libt   install_scriptst   install_dataR   t   install_userbaseR   t   install_usersitet   install_layoutR   t   optimizet
   extra_patht   install_path_fileR!   t
   skip_buildt   warn_dirt
   build_baset	   build_libt   record(   t   self(    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   initialize_options¥   s6    																			
							c      	   C   sL  |  j  s |  j s |  j r= |  j s- |  j r= t d d Ç n  |  j rd |  j  sX |  j rd t d Ç n  |  j r© |  j  sö |  j sö |  j sö |  j sö |  j r© t d É Ç n  t j d k r› |  j r› |  j	 d É d  |  _ q› n  |  j d É t j d k r|  j É  n
 |  j É  |  j d É t j t j É d	 } t d
 d É \ } } i |  j j É  d 6|  j j É  d 6|  j j É  d 6| d 6| d	 d !d 6| d	 | d d 6| d 6| d
 6| d 6| d 6|  j d 6|  j d 6|  _ |  j É  |  j d É |  j |  j d <|  j |  j d <t r;d d l m } d GH| |  j É n  |  j É  |  j d É |  j rh|  j É  n  |  j d  k r°|  j j  rí|  j! |  _ q°|  j" |  _ n  |  j# d d  d! d" d# d$ d d É |  j$ É  |  j |  _% t j& j' |  j |  j( É |  _ |  j) d  k	 r(|  j* d% d d  d! d" d# d$ É n  |  j d& É |  j+ d' d* d+ É d  S(,   Ns.   must supply either prefix/exec-prefix/home or s)   install-base/install-platbase -- not boths9   must supply either home or prefix/exec-prefix -- not bothsG   can't combine user with prefix, exec_prefix/home, or install_(plat)baset   posixs+   exec-prefix option ignored on this platforms   pre-finalize_{unix,other}s   post-finalize_{unix,other}()i    R$   R%   t	   dist_namet   dist_versiont   dist_fullnamet
   py_versioni   t   py_version_shorti   t   py_version_nodott
   sys_prefixt   sys_exec_prefixt   userbaset   usersites   post-expand_basedirs()t   baset   platbaseiˇˇˇˇ(   t   pprints   config vars:s   post-expand_dirs()t   libR   R   R   R   R   t   libbases   after prepending roott   buildR9   R:   (   s
   build_bases
   build_base(   s	   build_libs	   build_lib(,   R$   R%   R&   R(   R)   R   R   t   ost   namet   warnR#   t	   dump_dirst   finalize_unixt   finalize_othert   stringt   splitt   syst   versionR   t   distributiont   get_namet   get_versiont   get_fullnameR1   R2   t   config_varst   expand_basedirsR   RK   t   expand_dirst   create_home_pathR.   t   ext_modulesR,   R+   t   convert_pathst   handle_extra_patht   install_libbaset   patht   joint
   extra_dirsR*   t   change_rootst   set_undefined_options(   R<   RB   R$   R%   RK   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   finalize_options  s~    
	$	




		

	c         C   sœ   t  rÀ d d l m } | d GHx© |  j D]õ } | d } | d d k rY | d d !} n  | |  j k rî t j |  j | | É } t |  | É } n! t j | | É } t |  | É } d | | f GHq) Wn  d  S(   Niˇˇˇˇ(   t   longopt_xlatet   :i    t   =s     %s: %s(   R   t   distutils.fancy_getoptRk   t   user_optionst   negative_optRU   t	   translatet   getattr(   R<   t   msgRk   t   optt   opt_namet   val(    (    s/   /usr/lib/python2.7/distutils/command/install.pyRR   ì  s    	
	c         C   sì  |  j  d  k	 s |  j d  k	 rà |  j d  k rK |  j d  k rK |  j d  k sx |  j d  k sx |  j d  k sx |  j d  k rÑ t	 d Ç n  d  S|  j
 r“ |  j d  k rØ t d É Ç n  |  j |  _  |  _ |  j d É nΩ|  j d  k	 r|  j |  _  |  _ |  j d É nã|  j |  _ |  j d  k rm|  j d  k	 r:t	 d Ç n  t j j t j É |  _ t j j t j É |  _ n |  j d  k rã|  j |  _ n  |  j |  _  |  j |  _ |  j r|  j j É  d k r—|  j d É qè|  j j É  d k rˆ|  j d
 É qèt	 d É Ç nä |  j r)t j j |  j É d k sGd t j k sGd t j k rW|  j d
 É n8 t j j |  j É d k rÇ|  j d É n |  j d É d  S(   NsP   install-base or install-platbase supplied, but installation scheme is incompletes$   User base directory is not specifiedR   R   s*   must not supply exec-prefix without prefixt   debR   R>   t   unixR   s"   unknown value for --install-layouts
   /usr/localt   PYTHONUSERBASEt   real_prefixR   (   Rw   (   s   posixRx   (   R(   R#   R)   R.   R+   R,   R-   R/   R0   R   R   R1   R   t   select_schemeR&   R$   R'   R%   RO   Re   t   normpathRW   R3   t   lowert   environt   __dict__(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRS   •  sX    				$c         C   s¸   |  j  rQ |  j d  k r' t d É Ç n  |  j |  _ |  _ |  j t j d É nß |  j	 d  k	 rÉ |  j	 |  _ |  _ |  j d É nu |  j
 d  k r≠ t j j t j
 É |  _
 n  |  j
 |  _ |  _ y |  j t j É Wn! t k
 r˜ t d t j Ç n Xd  S(   Ns$   User base directory is not specifiedt   _userR   s)   I don't know how to install stuff on '%s'(   R   R1   R#   R   R(   R)   R{   RO   RP   R&   R$   Re   R|   RW   t   KeyError(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRT   ·  s"    	c         C   sU   t  | } xD t D]< } d | } t |  | É d  k r t |  | | | É q q Wd  S(   Nt   install_(   t   INSTALL_SCHEMESt   SCHEME_KEYSRr   R#   t   setattr(   R<   RP   t   schemet   keyt   attrname(    (    s/   /usr/lib/python2.7/distutils/command/install.pyR{   ˙  s
    

c         C   sà   xÅ | D]y } t  |  | É } | d  k	 r t j d k sF t j d k r[ t j j | É } n  t | |  j É } t |  | | É q q Wd  S(   NR>   R   (	   Rr   R#   RO   RP   Re   t
   expanduserR   R]   RÖ   (   R<   t   attrst   attrRv   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   _expand_attrs  s    c         C   s   |  j  d d d g É d  S(   NR(   R)   R*   (   Rå   (   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR^     s    	c         C   s#   |  j  d d d d d d g É d  S(   NR+   R,   R.   R-   R/   R0   (   Rå   (   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR_     s    	c         G   s>   x7 | D]/ } d | } t  |  | t t |  | É É É q Wd  S(   NRÇ   (   RÖ   R   Rr   (   R<   t   namesRP   Rã   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRb     s    
c         C   sÍ   |  j  d  k r! |  j j  |  _  n  |  j  d  k	 r» t |  j  É t k r` t j |  j  d É |  _  n  t |  j  É d k râ |  j  d } } n0 t |  j  É d k r∞ |  j  \ } } n	 t d Ç t	 | É } n d  } d } | |  _
 | |  _ d  S(   Nt   ,i   i    i   sY   'extra_path' option must be a list, tuple, or comma-separated string with 1 or 2 elementst    (   R5   R#   RY   t   typet
   StringTypeRU   RV   t   lenR   R   t	   path_fileRg   (   R<   Rì   Rg   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRc   !  s     	c      	   G   sD   x= | D]5 } d | } t  |  | t |  j t |  | É É É q Wd  S(   NRÇ   (   RÖ   R	   R*   Rr   (   R<   Rç   RP   Rã   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRh   C  s    
c         C   sè   |  j  s d St t j j d É É } xc |  j j É  D]R \ } } | j | É r5 t j j | É r5 |  j	 d | É t j
 | d É q5 q5 Wd S(   s#   Create directories under ~
        Nt   ~s   os.makedirs('%s', 0700)i¿  (   R   R   RO   Re   Râ   R]   t	   iteritemst
   startswitht   isdirt   debug_printt   makedirs(   R<   R&   RP   Re   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR`   H  s    	"c         C   s§  |  j  sU |  j d É |  j j d É j } |  j rU | t É  k rU t d É Ç qU n  x! |  j É  D] } |  j | É qb W|  j	 rè |  j
 É  n  |  j r|  j É  } |  j rÓ t |  j É } x/ t t | É É D] } | | | | | <qœ Wn  |  j t |  j | f d |  j É n  t t j j t j É } t t j j | É } t j j t j j |  j É É } |  j r†|  j	 oz|  j r†| | k r†t j d |  j É n  d  S(   NRN   s"   Can't install when cross-compilings'   writing list of installed files to '%s'sÉ   modules installed to '%s', which is not in Python's module search path (sys.path) -- you'll have to change the search path yourself(   R7   t   run_commandRY   t   get_command_objt	   plat_nameR8   R
   R   t   get_sub_commandsRì   t   create_path_fileR;   t   get_outputsR*   Rí   t   xranget   executeR   t   mapRO   Re   R|   RW   t   normcaseR.   R6   R    t   debug(   R<   t
   build_platt   cmd_namet   outputst   root_lent   countert   sys_pathR.   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   runU  s6    					!		c         C   sc   t  j j |  j |  j d É } |  j rN |  j t | |  j g f d | É n |  j	 d | É d  S(   Ns   .pths   creating %ss   path file '%s' not created(
   RO   Re   Rf   Rd   Rì   R6   R°   R   Rg   RQ   (   R<   t   filename(    (    s/   /usr/lib/python2.7/distutils/command/install.pyRû   É  s    		c         C   sû   g  } xV |  j  É  D]H } |  j | É } x0 | j É  D]" } | | k r5 | j | É q5 q5 Wq W|  j rö |  j rö | j t j j |  j	 |  j d É É n  | S(   Ns   .pth(
   Rù   t   get_finalized_commandRü   t   appendRì   R6   RO   Re   Rf   Rd   (   R<   Rß   R¶   t   cmdR¨   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRü   ê  s    c         C   sC   g  } x6 |  j  É  D]( } |  j | É } | j | j É  É q W| S(   N(   Rù   R≠   t   extendt
   get_inputs(   R<   t   inputsR¶   RØ   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR±   °  s
    c         C   s   |  j  j É  p |  j  j É  S(   sR   Return true if the current distribution has any Python
        modules to install.(   RY   t   has_pure_modulest   has_ext_modules(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   has_lib≠  s    c         C   s   |  j  j É  S(   N(   RY   t   has_headers(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR∂   ≥  s    c         C   s   |  j  j É  S(   N(   RY   t   has_scripts(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR∑   ∂  s    c         C   s   |  j  j É  S(   N(   RY   t   has_data_files(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   has_dataπ  s    R.   R-   R/   R0   t   install_egg_infoc         C   s   t  S(   N(   t   True(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   <lambda>√  s    N(   s   prefix=Ns   installation prefix(   s   exec-prefix=Ns.   (Unix only) prefix for platform-specific files(   s   home=Ns+   (Unix only) home directory to install under(   s   install-base=Ns;   base installation directory (instead of --prefix or --home)(   s   root=Ns<   install everything relative to this alternate root directory(   s   install-purelib=Ns;   installation directory for pure Python module distributions(   s   install-platlib=Ns8   installation directory for non-pure module distributions(   s   install-headers=Ns(   installation directory for C/C++ headers(   s   install-scripts=Ns)   installation directory for Python scripts(   s   install-data=Ns%   installation directory for data files(   s   compileR   s   compile .py to .pyc [default](   s
   no-compileNs   don't compile .py files(   s	   optimize=R    sl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0](   s   forceR"   s1   force installation (overwrite any existing files)(   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   record=Ns3   filename in which to record list of installed files(   s   install-layout=Ns7   installation layout to choose (known values: deb, unix)(   t   __name__t
   __module__t   descriptionR#   R   Ro   t   boolean_optionsRp   R=   Rj   RR   RS   RT   R{   Rå   R^   R_   Rb   Rc   Rh   R`   R´   Rû   Rü   R±   Rµ   R∂   R∑   Rπ   t   sub_commands(    (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR   l   sä      
            		Q	é		<				
					"			.											(   s   purelibs   platlibs   headerss   scriptss   data(    t   __doc__t	   distutilsR    t   __revision__RW   RO   RU   t   typest   distutils.coreR   t   distutils.debugR   t   distutils.sysconfigR   t   distutils.errorsR   t   distutils.file_utilR   t   distutils.utilR   R   R	   R
   R   t   siteR   R   RX   t   WINDOWS_SCHEMERÉ   RÑ   R   (    (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   <module>   sû   $

                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/distutils/command/install_data.py                                                 0100644 0000000 0000000 00000005435 12734733743 021073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.install_data

Implements the Distutils 'install_data' command, for installing
platform-independent data files."""

# contributed by Bastian Kleineidam

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils.util import change_root, convert_path

class install_data(Command):

    description = "install data files"

    user_options = [
        ('install-dir=', 'd',
         "base directory for installing data files "
         "(default: installation base dir)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ]

    boolean_options = ['force']

    def initialize_options(self):
        self.install_dir = None
        self.outfiles = []
        self.root = None
        self.force = 0
        self.data_files = self.distribution.data_files
        self.warn_dir = 1

    def finalize_options(self):
        self.set_undefined_options('install',
                                   ('install_data', 'install_dir'),
                                   ('root', 'root'),
                                   ('force', 'force'),
                                  )

    def run(self):
        self.mkpath(self.install_dir)
        for f in self.data_files:
            if isinstance(f, str):
                # it's a simple file, so copy it
                f = convert_path(f)
                if self.warn_dir:
                    self.warn("setup script did not provide a directory for "
                              "'%s' -- installing right in '%s'" %
                              (f, self.install_dir))
                (out, _) = self.copy_file(f, self.install_dir)
                self.outfiles.append(out)
            else:
                # it's a tuple with path to install to and a list of files
                dir = convert_path(f[0])
                if not os.path.isabs(dir):
                    dir = os.path.join(self.install_dir, dir)
                elif self.root:
                    dir = change_root(self.root, dir)
                self.mkpath(dir)

                if f[1] == []:
                    # If there are no files listed, the user must be
                    # trying to create an empty directory, so add the
                    # directory to the list of output files.
                    self.outfiles.append(dir)
                else:
                    # Copy files, adding them to the list of output files.
                    for data in f[1]:
                        data = convert_path(data)
                        (out, _) = self.copy_file(data, dir)
                        self.outfiles.append(out)

    def get_inputs(self):
        return self.data_files or []

    def get_outputs(self):
        return self.outfiles
                                                                                                                                                                                                                                   usr/lib/python2.7/distutils/command/install_data.pyc                                                0100644 0000000 0000000 00000006116 13077704274 021231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sX   d  Z  d Z d d l Z d d l m Z d d l m Z m Z d e f d Ñ  É  YZ d S(   sÄ   distutils.command.install_data

Implements the Distutils 'install_data' command, for installing
platform-independent data files.s   $Id$iˇˇˇˇN(   t   Command(   t   change_roott   convert_patht   install_datac           B   sS   e  Z d  Z d d d g Z d g Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s   install data filess   install-dir=t   dsI   base directory for installing data files (default: installation base dir)s   root=s<   install everything relative to this alternate root directoryt   forcet   fs-   force installation (overwrite existing files)c         C   s@   d  |  _ g  |  _ d  |  _ d |  _ |  j j |  _ d |  _ d  S(   Ni    i   (   t   Nonet   install_dirt   outfilest   rootR   t   distributiont
   data_filest   warn_dir(   t   self(    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   initialize_options   s    				c         C   s   |  j  d d d d É d  S(	   Nt   installR   R   R
   R   (   s   install_datas   install_dir(   s   roots   root(   s   forces   force(   t   set_undefined_options(   R   (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   finalize_options%   s    	c         C   sk  |  j  |  j É xT|  j D]I} t | t É rè t | É } |  j ra |  j d | |  j f É n  |  j | |  j É \ } } |  j	 j
 | É q t | d É } t j j | É sÃ t j j |  j | É } n |  j rÍ t |  j | É } n  |  j  | É | d g  k r|  j	 j
 | É q xF | d D]: } t | É } |  j | | É \ } } |  j	 j
 | É q%Wq Wd  S(   NsM   setup script did not provide a directory for '%s' -- installing right in '%s'i    i   (   t   mkpathR   R   t
   isinstancet   strR   R   t   warnt	   copy_fileR	   t   appendt   ost   patht   isabst   joinR
   R   (   R   R   t   outt   _t   dirt   data(    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   run,   s*    			c         C   s   |  j  p g  S(   N(   R   (   R   (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt
   get_inputsM   s    c         C   s   |  j  S(   N(   R	   (   R   (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   get_outputsP   s    (   s   install-dir=R   sI   base directory for installing data files (default: installation base dir)N(   s   root=Ns<   install everything relative to this alternate root directory(   s   forceR   s-   force installation (overwrite existing files)(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionsR   R   R!   R"   R#   (    (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyR      s     					!	(	   t   __doc__t   __revision__R   t   distutils.coreR    t   distutils.utilR   R   R   (    (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/distutils/command/install_egg_info.py                                             0100644 0000000 0000000 00000007011 12734733743 021727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata."""


from distutils.cmd import Command
from distutils import log, dir_util
import os, sys, re

class install_egg_info(Command):
    """Install an .egg-info file for the package"""

    description = "Install package's PKG-INFO metadata as an .egg-info file"
    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('install-layout', None, "custom installation layout"),
    ]

    def initialize_options(self):
        self.install_dir = None
        self.install_layout = None
        self.prefix_option = None

    def finalize_options(self):
        self.set_undefined_options('install_lib',('install_dir','install_dir'))
        self.set_undefined_options('install',('install_layout','install_layout'))
        self.set_undefined_options('install',('prefix_option','prefix_option'))
        if self.install_layout:
            basename = "%s-%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version()))
                )
            if not self.install_layout.lower() in ['deb']:
                raise DistutilsOptionError(
                    "unknown value for --install-layout")
        elif self.prefix_option or 'real_prefix' in sys.__dict__:
            basename = "%s-%s-py%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version())),
                sys.version[:3]
                )
        else:
            basename = "%s-%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version()))
                )
        self.target = os.path.join(self.install_dir, basename)
        self.outputs = [self.target]

    def run(self):
        target = self.target
        if os.path.isdir(target) and not os.path.islink(target):
            dir_util.remove_tree(target, dry_run=self.dry_run)
        elif os.path.exists(target):
            self.execute(os.unlink,(self.target,),"Removing "+target)
        elif not os.path.isdir(self.install_dir):
            self.execute(os.makedirs, (self.install_dir,),
                         "Creating "+self.install_dir)
        log.info("Writing %s", target)
        if not self.dry_run:
            f = open(target, 'w')
            self.distribution.metadata.write_pkg_file(f)
            f.close()

    def get_outputs(self):
        return self.outputs


# The following routines are taken from setuptools' pkg_resources module and
# can be replaced by importing them from pkg_resources once it is included
# in the stdlib.

def safe_name(name):
    """Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub('[^A-Za-z0-9.]+', '-', name)


def safe_version(version):
    """Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    """
    version = version.replace(' ','.')
    return re.sub('[^A-Za-z0-9.]+', '-', version)


def to_filename(name):
    """Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace('-','_')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python2.7/distutils/command/install_egg_info.pyc                                            0100644 0000000 0000000 00000010515 13077704274 022073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sÖ   d  Z  d d l m Z d d l m Z m Z d d l Z d d l Z d d l Z d e f d Ñ  É  YZ	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d S(
   sÜ   distutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata.iˇˇˇˇ(   t   Command(   t   logt   dir_utilNt   install_egg_infoc           B   sD   e  Z d  Z d Z d d g Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z	 RS(   s)   Install an .egg-info file for the packages8   Install package's PKG-INFO metadata as an .egg-info files   install-dir=t   ds   directory to install tos   install-layouts   custom installation layoutc         C   s   d  |  _ d  |  _ d  |  _ d  S(   N(   t   Nonet   install_dirt   install_layoutt   prefix_option(   t   self(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   initialize_options   s    		c         C   sa  |  j  d d É |  j  d d É |  j  d d É |  j rö d t t |  j j É  É É t t |  j j É  É É f } |  j j É  d k r3t	 d É Ç q3nô |  j
 s≤ d	 t j k r˘ d
 t t |  j j É  É É t t |  j j É  É É t j d  f } n: d t t |  j j É  É É t t |  j j É  É É f } t j j |  j | É |  _ |  j g |  _ d  S(   Nt   install_libR   t   installR   R   s   %s-%s.egg-infot   debs"   unknown value for --install-layoutt   real_prefixs   %s-%s-py%s.egg-infoi   (   s   install_dirs   install_dir(   s   install_layouts   install_layout(   s   prefix_options   prefix_option(   R   (   t   set_undefined_optionsR   t   to_filenamet	   safe_namet   distributiont   get_namet   safe_versiont   get_versiont   lowert   DistutilsOptionErrorR   t   syst   __dict__t   versiont   ost   patht   joinR   t   targett   outputs(   R	   t   basename(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   finalize_options   s(    	c         C   s  |  j  } t j j | É rG t j j | É rG t j | d |  j Énp t j j | É r| |  j	 t j
 |  j  f d | É n; t j j |  j É s∑ |  j	 t j |  j f d |  j É n  t j d | É |  j sˇ t | d É } |  j j j | É | j É  n  d  S(   Nt   dry_runs	   Removing s	   Creating s
   Writing %st   w(   R   R   R   t   isdirt   islinkR   t   remove_treeR"   t   existst   executet   unlinkR   t   makedirsR   t   infot   openR   t   metadatat   write_pkg_filet   close(   R	   R   t   f(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   run3   s    	%#	c         C   s   |  j  S(   N(   R   (   R	   (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   get_outputsB   s    (   s   install-dir=R   s   directory to install toN(   s   install-layoutNs   custom installation layout(
   t   __name__t
   __module__t   __doc__t   descriptionR   t   user_optionsR
   R!   R1   R2   (    (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR      s   				c         C   s   t  j d d |  É S(   sè   Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    s   [^A-Za-z0-9.]+t   -(   t   ret   sub(   t   name(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR   J   s    c         C   s%   |  j  d d É }  t j d d |  É S(   sÃ   Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    t    t   .s   [^A-Za-z0-9.]+R8   (   t   replaceR9   R:   (   R   (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR   R   s    c         C   s   |  j  d d É S(   s|   Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    R8   t   _(   R>   (   R;   (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR   \   s    (   R5   t   distutils.cmdR    t	   distutilsR   R   R   R   R9   R   R   R   R   (    (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   <module>   s   $?		
                                                                                                                                                                                   usr/lib/python2.7/distutils/command/install_headers.py                                              0100644 0000000 0000000 00000002502 12734733743 021565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory."""

__revision__ = "$Id$"

from distutils.core import Command


# XXX force is never used
class install_headers(Command):

    description = "install C/C++ header files"

    user_options = [('install-dir=', 'd',
                     "directory to install header files to"),
                    ('force', 'f',
                     "force installation (overwrite existing files)"),
                   ]

    boolean_options = ['force']

    def initialize_options(self):
        self.install_dir = None
        self.force = 0
        self.outfiles = []

    def finalize_options(self):
        self.set_undefined_options('install',
                                   ('install_headers', 'install_dir'),
                                   ('force', 'force'))


    def run(self):
        headers = self.distribution.headers
        if not headers:
            return

        self.mkpath(self.install_dir)
        for header in headers:
            (out, _) = self.copy_file(header, self.install_dir)
            self.outfiles.append(out)

    def get_inputs(self):
        return self.distribution.headers or []

    def get_outputs(self):
        return self.outfiles

# class install_headers
                                                                                                                                                                                              usr/lib/python2.7/distutils/command/install_headers.pyc                                             0100644 0000000 0000000 00000004352 13077704274 021733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s6   d  Z  d Z d d l m Z d e f d Ñ  É  YZ d S(   sï   distutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory.s   $Id$iˇˇˇˇ(   t   Commandt   install_headersc           B   sP   e  Z d  Z d d g Z d g Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z	 RS(   s   install C/C++ header filess   install-dir=t   ds$   directory to install header files tot   forcet   fs-   force installation (overwrite existing files)c         C   s   d  |  _ d |  _ g  |  _ d  S(   Ni    (   t   Nonet   install_dirR   t   outfiles(   t   self(    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   initialize_options   s    		c         C   s   |  j  d d d É d  S(   Nt   installR   R   R   (   s   install_headerss   install_dir(   s   forces   force(   t   set_undefined_options(   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   finalize_options   s    	c         C   sf   |  j  j } | s d  S|  j |  j É x9 | D]1 } |  j | |  j É \ } } |  j j | É q- Wd  S(   N(   t   distributiont   headerst   mkpathR   t	   copy_fileR   t   append(   R   R   t   headert   outt   _(    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   run#   s    c         C   s   |  j  j p g  S(   N(   R   R   (   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt
   get_inputs-   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   get_outputs0   s    (   s   install-dir=R   s$   directory to install header files to(   s   forceR   s-   force installation (overwrite existing files)(
   t   __name__t
   __module__t   descriptiont   user_optionst   boolean_optionsR	   R   R   R   R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyR      s     					
	N(   t   __doc__t   __revision__t   distutils.coreR    R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   <module>   s                                                                                                                                                                                                                                                                                         usr/lib/python2.7/distutils/command/install_lib.py                                                  0100644 0000000 0000000 00000020222 12734733743 020717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.install_lib

Implements the Distutils 'install_lib' command
(install all Python modules)."""

__revision__ = "$Id$"

import os
import sys

from distutils.core import Command
from distutils.errors import DistutilsOptionError


# Extension for Python source files.
if hasattr(os, 'extsep'):
    PYTHON_SOURCE_EXTENSION = os.extsep + "py"
else:
    PYTHON_SOURCE_EXTENSION = ".py"

class install_lib(Command):

    description = "install all Python modules (extensions and pure Python)"

    # The byte-compilation options are a tad confusing.  Here are the
    # possible scenarios:
    #   1) no compilation at all (--no-compile --no-optimize)
    #   2) compile .pyc only (--compile --no-optimize; default)
    #   3) compile .pyc and "level 1" .pyo (--compile --optimize)
    #   4) compile "level 1" .pyo only (--no-compile --optimize)
    #   5) compile .pyc and "level 2" .pyo (--compile --optimize-more)
    #   6) compile "level 2" .pyo only (--no-compile --optimize-more)
    #
    # The UI for this is two option, 'compile' and 'optimize'.
    # 'compile' is strictly boolean, and only decides whether to
    # generate .pyc files.  'optimize' is three-way (0, 1, or 2), and
    # decides both whether to generate .pyo files and what level of
    # optimization to use.

    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('skip-build', None, "skip the build steps"),
        ]

    boolean_options = ['force', 'compile', 'skip-build']
    negative_opt = {'no-compile' : 'compile'}

    def initialize_options(self):
        # let the 'install' command dictate our installation directory
        self.install_dir = None
        self.build_dir = None
        self.force = 0
        self.compile = None
        self.optimize = None
        self.skip_build = None

    def finalize_options(self):
        # Get all the information we need to install pure Python modules
        # from the umbrella 'install' command -- build (source) directory,
        # install (target) directory, and whether to compile .py files.
        self.set_undefined_options('install',
                                   ('build_lib', 'build_dir'),
                                   ('install_lib', 'install_dir'),
                                   ('force', 'force'),
                                   ('compile', 'compile'),
                                   ('optimize', 'optimize'),
                                   ('skip_build', 'skip_build'),
                                  )

        if self.compile is None:
            self.compile = 1
        if self.optimize is None:
            self.optimize = 0

        if not isinstance(self.optimize, int):
            try:
                self.optimize = int(self.optimize)
                if self.optimize not in (0, 1, 2):
                    raise AssertionError
            except (ValueError, AssertionError):
                raise DistutilsOptionError, "optimize must be 0, 1, or 2"

    def run(self):
        # Make sure we have built everything we need first
        self.build()

        # Install everything: simply dump the entire contents of the build
        # directory to the installation directory (that's the beauty of
        # having a build directory!)
        outfiles = self.install()

        # (Optionally) compile .py to .pyc
        if outfiles is not None and self.distribution.has_pure_modules():
            self.byte_compile(outfiles)

    # -- Top-level worker functions ------------------------------------
    # (called from 'run()')

    def build(self):
        if not self.skip_build:
            if self.distribution.has_pure_modules():
                self.run_command('build_py')
            if self.distribution.has_ext_modules():
                self.run_command('build_ext')

    def install(self):
        if os.path.isdir(self.build_dir):
            outfiles = self.copy_tree(self.build_dir, self.install_dir)
        else:
            self.warn("'%s' does not exist -- no Python modules to install" %
                      self.build_dir)
            return
        return outfiles

    def byte_compile(self, files):
        if sys.dont_write_bytecode:
            self.warn('byte-compiling is disabled, skipping.')
            return

        from distutils.util import byte_compile

        # Get the "--root" directory supplied to the "install" command,
        # and use it as a prefix to strip off the purported filename
        # encoded in bytecode files.  This is far from complete, but it
        # should at least generate usable bytecode in RPM distributions.
        install_root = self.get_finalized_command('install').root

        if self.compile:
            byte_compile(files, optimize=0,
                         force=self.force, prefix=install_root,
                         dry_run=self.dry_run)
        if self.optimize > 0:
            byte_compile(files, optimize=self.optimize,
                         force=self.force, prefix=install_root,
                         verbose=self.verbose, dry_run=self.dry_run)


    # -- Utility methods -----------------------------------------------

    def _mutate_outputs(self, has_any, build_cmd, cmd_option, output_dir):
        if not has_any:
            return []

        build_cmd = self.get_finalized_command(build_cmd)
        build_files = build_cmd.get_outputs()
        build_dir = getattr(build_cmd, cmd_option)

        prefix_len = len(build_dir) + len(os.sep)
        outputs = []
        for file in build_files:
            outputs.append(os.path.join(output_dir, file[prefix_len:]))

        return outputs

    def _bytecode_filenames(self, py_filenames):
        bytecode_files = []
        for py_file in py_filenames:
            # Since build_py handles package data installation, the
            # list of outputs can contain more than just .py files.
            # Make sure we only report bytecode for the .py files.
            ext = os.path.splitext(os.path.normcase(py_file))[1]
            if ext != PYTHON_SOURCE_EXTENSION:
                continue
            if self.compile:
                bytecode_files.append(py_file + "c")
            if self.optimize > 0:
                bytecode_files.append(py_file + "o")

        return bytecode_files


    # -- External interface --------------------------------------------
    # (called by outsiders)

    def get_outputs(self):
        """Return the list of files that would be installed if this command
        were actually run.  Not affected by the "dry-run" flag or whether
        modules have actually been built yet.
        """
        pure_outputs = \
            self._mutate_outputs(self.distribution.has_pure_modules(),
                                 'build_py', 'build_lib',
                                 self.install_dir)
        if self.compile:
            bytecode_outputs = self._bytecode_filenames(pure_outputs)
        else:
            bytecode_outputs = []

        ext_outputs = \
            self._mutate_outputs(self.distribution.has_ext_modules(),
                                 'build_ext', 'build_lib',
                                 self.install_dir)

        return pure_outputs + bytecode_outputs + ext_outputs

    def get_inputs(self):
        """Get the list of files that are input to this command, ie. the
        files that get installed as they are named in the build tree.
        The files in this list correspond one-to-one to the output
        filenames returned by 'get_outputs()'.
        """
        inputs = []

        if self.distribution.has_pure_modules():
            build_py = self.get_finalized_command('build_py')
            inputs.extend(build_py.get_outputs())

        if self.distribution.has_ext_modules():
            build_ext = self.get_finalized_command('build_ext')
            inputs.extend(build_ext.get_outputs())

        return inputs
                                                                                                                                                                                                                                                                                                                                                                              usr/lib/python2.7/distutils/command/install_lib.pyc                                                 0100644 0000000 0000000 00000015150 13077704274 021064  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sÉ   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z e e d É rc e j	 d Z
 n d Z
 d	 e f d
 Ñ  É  YZ d S(   sk   distutils.command.install_lib

Implements the Distutils 'install_lib' command
(install all Python modules).s   $Id$iˇˇˇˇN(   t   Command(   t   DistutilsOptionErrort   extsept   pys   .pyt   install_libc        	   B   sü   e  Z d  Z d d d  d! d# d$ d% g Z d d
 d g Z i d
 d 6Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(&   s7   install all Python modules (extensions and pure Python)s   install-dir=t   ds   directory to install tos
   build-dir=t   bs'   build directory (where to install from)t   forcet   fs-   force installation (overwrite existing files)t   compilet   cs   compile .py to .pyc [default]s
   no-compiles   don't compile .py filess	   optimize=t   Osl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]s
   skip-builds   skip the build stepsc         C   s:   d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet   install_dirt	   build_dirR   R	   t   optimizet
   skip_build(   t   self(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   initialize_options7   s    					c      	   C   sø   |  j  d d d d d d d É |  j d  k r: d
 |  _ n  |  j d  k rU d |  _ n  t |  j t É sª y. t |  j É |  _ |  j d k rî t Ç n  Wqª t t f k
 r∑ t d Ç qª Xn  d  S(   Nt   installt	   build_libR   R   R   R   R	   R   R   i   i    i   s   optimize must be 0, 1, or 2(   R   s	   build_dir(   s   install_libs   install_dir(   s   forces   force(   s   compiles   compile(   s   optimizes   optimize(   s
   skip_builds
   skip_build(   i    i   i   (	   t   set_undefined_optionsR	   R   R   t
   isinstancet   intt   AssertionErrort
   ValueErrorR   (   R   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   finalize_options@   s$    	c         C   sE   |  j  É  |  j É  } | d  k	 rA |  j j É  rA |  j | É n  d  S(   N(   t   buildR   R   t   distributiont   has_pure_modulest   byte_compile(   R   t   outfiles(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   runZ   s    
c         C   sN   |  j  sJ |  j j É  r( |  j d É n  |  j j É  rJ |  j d É qJ n  d  S(   Nt   build_pyt	   build_ext(   R   R   R   t   run_commandt   has_ext_modules(   R   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR   j   s
    	c         C   sL   t  j j |  j É r0 |  j |  j |  j É } n |  j d |  j É d  S| S(   Ns3   '%s' does not exist -- no Python modules to install(   t   ost   patht   isdirR   t	   copy_treeR   t   warn(   R   R   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR   q   s    	c         C   s∫   t  j r |  j d É d  Sd d l m } |  j d É j } |  j rp | | d d d |  j d | d	 |  j	 Én  |  j
 d k r∂ | | d |  j
 d |  j d | d
 |  j d	 |  j	 Én  d  S(   Ns%   byte-compiling is disabled, skipping.iˇˇˇˇ(   R   R   R   i    R   t   prefixt   dry_runt   verbose(   t   syst   dont_write_bytecodeR)   t   distutils.utilR   t   get_finalized_commandt   rootR	   R   R+   R   R,   (   R   t   filesR   t   install_root(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR   z   s    		c   
      C   sà   | s
 g  S|  j  | É } | j É  } t | | É } t | É t t j É } g  } x. | D]& }	 | j t j j | |	 | É É qZ W| S(   N(	   R0   t   get_outputst   getattrt   lenR%   t   sept   appendR&   t   join(
   R   t   has_anyt	   build_cmdt
   cmd_optiont
   output_dirt   build_filesR   t
   prefix_lent   outputst   file(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   _mutate_outputsì   s    $c         C   sè   g  } xÇ | D]z } t  j j t  j j | É É d } | t k rG q n  |  j rd | j | d É n  |  j d k r | j | d É q q W| S(   Ni   R
   i    t   o(   R%   R&   t   splitextt   normcaset   PYTHON_SOURCE_EXTENSIONR	   R8   R   (   R   t   py_filenamest   bytecode_filest   py_filet   ext(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   _bytecode_filenames¢   s    "	c         C   su   |  j  |  j j É  d d |  j É } |  j r? |  j | É } n g  } |  j  |  j j É  d d |  j É } | | | S(   s¡   Return the list of files that would be installed if this command
        were actually run.  Not affected by the "dry-run" flag or whether
        modules have actually been built yet.
        R!   R   R"   (   RB   R   R   R   R	   RK   R$   (   R   t   pure_outputst   bytecode_outputst   ext_outputs(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR4   ∂   s    	c         C   sr   g  } |  j  j É  r: |  j d É } | j | j É  É n  |  j  j É  rn |  j d É } | j | j É  É n  | S(   s˛   Get the list of files that are input to this command, ie. the
        files that get installed as they are named in the build tree.
        The files in this list correspond one-to-one to the output
        filenames returned by 'get_outputs()'.
        R!   R"   (   R   R   R0   t   extendR4   R$   (   R   t   inputsR!   R"   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt
   get_inputsÀ   s    (   s   install-dir=R   s   directory to install to(   s
   build-dir=R   s'   build directory (where to install from)(   s   forceR   s-   force installation (overwrite existing files)(   s   compileR
   s   compile .py to .pyc [default]N(   s
   no-compileNs   don't compile .py files(   s	   optimize=R   sl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0](   s
   skip-buildNs   skip the build steps(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionst   negative_optR   R   R    R   R   R   RB   RK   R4   RQ   (    (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR      s*    												(   t   __doc__t   __revision__R%   R-   t   distutils.coreR    t   distutils.errorsR   t   hasattrR   RF   R   (    (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python2.7/distutils/command/install_scripts.py                                              0100644 0000000 0000000 00000004024 12734733743 021642  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts."""

# contributed by Bastian Kleineidam

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils import log
from stat import ST_MODE

class install_scripts (Command):

    description = "install scripts (Python or otherwise)"

    user_options = [
        ('install-dir=', 'd', "directory to install scripts to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('skip-build', None, "skip the build steps"),
    ]

    boolean_options = ['force', 'skip-build']


    def initialize_options (self):
        self.install_dir = None
        self.force = 0
        self.build_dir = None
        self.skip_build = None

    def finalize_options (self):
        self.set_undefined_options('build', ('build_scripts', 'build_dir'))
        self.set_undefined_options('install',
                                   ('install_scripts', 'install_dir'),
                                   ('force', 'force'),
                                   ('skip_build', 'skip_build'),
                                  )

    def run (self):
        if not self.skip_build:
            self.run_command('build_scripts')
        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)
        if os.name == 'posix':
            # Set the executable bits (owner, group, and world) on
            # all the scripts we just installed.
            for file in self.get_outputs():
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    mode = ((os.stat(file)[ST_MODE]) | 0555) & 07777
                    log.info("changing mode of %s to %o", file, mode)
                    os.chmod(file, mode)

    def get_inputs (self):
        return self.distribution.scripts or []

    def get_outputs(self):
        return self.outfiles or []

# class install_scripts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/distutils/command/install_scripts.pyc                                             0100644 0000000 0000000 00000005650 13077704274 022011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sb   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d e f d Ñ  É  YZ	 d S(	   su   distutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts.s   $Id$iˇˇˇˇN(   t   Command(   t   log(   t   ST_MODEt   install_scriptsc           B   sY   e  Z d  Z d d d d g Z d d
 g Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s%   install scripts (Python or otherwise)s   install-dir=t   ds   directory to install scripts tos
   build-dir=t   bs'   build directory (where to install from)t   forcet   fs-   force installation (overwrite existing files)s
   skip-builds   skip the build stepsc         C   s(   d  |  _ d |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet   install_dirR   t	   build_dirt
   skip_build(   t   self(    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   initialize_options   s    			c         C   s*   |  j  d d	 É |  j  d d
 d d É d  S(   Nt   buildt   build_scriptsR
   t   installR   R	   R   R   (   R   s	   build_dir(   s   install_scriptss   install_dir(   s   forces   force(   s
   skip_builds
   skip_build(   t   set_undefined_options(   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   finalize_options#   s
    	c         C   sª   |  j  s |  j d É n  |  j |  j |  j É |  _ t j d k r∑ xq |  j É  D]` } |  j	 rr t
 j d | É qP t j | É t d Bd @} t
 j d | | É t j | | É qP Wn  d  S(   NR   t   posixs   changing mode of %sim  iˇ  s   changing mode of %s to %o(   R   t   run_commandt	   copy_treeR
   R	   t   outfilest   ost   namet   get_outputst   dry_runR   t   infot   statR   t   chmod(   R   t   filet   mode(    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   run+   s    		c         C   s   |  j  j p g  S(   N(   t   distributiont   scripts(   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt
   get_inputs:   s    c         C   s   |  j  p g  S(   N(   R   (   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyR   =   s    (   s   install-dir=R   s   directory to install scripts to(   s
   build-dir=R   s'   build directory (where to install from)(   s   forceR   s-   force installation (overwrite existing files)N(   s
   skip-buildNs   skip the build steps(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionsR   R   R    R#   R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyR      s   					(
   t   __doc__t   __revision__R   t   distutils.coreR    t	   distutilsR   R   R   R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   <module>   s                                                                                           usr/lib/python2.7/distutils/command/register.py                                                     0100644 0000000 0000000 00000027077 12734733743 020266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.register

Implements the Distutils 'register' command (register with the repository).
"""

# created 2002/10/21, Richard Jones

__revision__ = "$Id$"

import urllib2
import getpass
import urlparse
from warnings import warn

from distutils.core import PyPIRCCommand
from distutils import log

class register(PyPIRCCommand):

    description = ("register the distribution with the Python package index")
    user_options = PyPIRCCommand.user_options + [
        ('list-classifiers', None,
         'list the valid Trove classifiers'),
        ('strict', None ,
         'Will stop the registering if the meta-data are not fully compliant')
        ]
    boolean_options = PyPIRCCommand.boolean_options + [
        'verify', 'list-classifiers', 'strict']

    sub_commands = [('check', lambda self: True)]

    def initialize_options(self):
        PyPIRCCommand.initialize_options(self)
        self.list_classifiers = 0
        self.strict = 0

    def finalize_options(self):
        PyPIRCCommand.finalize_options(self)
        # setting options for the `check` subcommand
        check_options = {'strict': ('register', self.strict),
                         'restructuredtext': ('register', 1)}
        self.distribution.command_options['check'] = check_options

    def run(self):
        self.finalize_options()
        self._set_config()

        # Run sub commands
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        if self.dry_run:
            self.verify_metadata()
        elif self.list_classifiers:
            self.classifiers()
        else:
            self.send_metadata()

    def check_metadata(self):
        """Deprecated API."""
        warn("distutils.command.register.check_metadata is deprecated, \
              use the check command instead", PendingDeprecationWarning)
        check = self.distribution.get_command_obj('check')
        check.ensure_finalized()
        check.strict = self.strict
        check.restructuredtext = 1
        check.run()

    def _set_config(self):
        ''' Reads the configuration file and set attributes.
        '''
        config = self._read_pypirc()
        if config != {}:
            self.username = config['username']
            self.password = config['password']
            self.repository = config['repository']
            self.realm = config['realm']
            self.has_config = True
        else:
            if self.repository not in ('pypi', self.DEFAULT_REPOSITORY):
                raise ValueError('%s not found in .pypirc' % self.repository)
            if self.repository == 'pypi':
                self.repository = self.DEFAULT_REPOSITORY
            self.has_config = False

    def classifiers(self):
        ''' Fetch the list of classifiers from the server.
        '''
        response = urllib2.urlopen(self.repository+'?:action=list_classifiers')
        log.info(response.read())

    def verify_metadata(self):
        ''' Send the metadata to the package index server to be checked.
        '''
        # send the info to the server and report the result
        (code, result) = self.post_to_server(self.build_post_data('verify'))
        log.info('Server response (%s): %s' % (code, result))


    def send_metadata(self):
        ''' Send the metadata to the package index server.

            Well, do the following:
            1. figure who the user is, and then
            2. send the data as a Basic auth'ed POST.

            First we try to read the username/password from $HOME/.pypirc,
            which is a ConfigParser-formatted file with a section
            [distutils] containing username and password entries (both
            in clear text). Eg:

                [distutils]
                index-servers =
                    pypi

                [pypi]
                username: fred
                password: sekrit

            Otherwise, to figure who the user is, we offer the user three
            choices:

             1. use existing login,
             2. register as a new user, or
             3. set the password to a random string and email the user.

        '''
        # see if we can short-cut and get the username/password from the
        # config
        if self.has_config:
            choice = '1'
            username = self.username
            password = self.password
        else:
            choice = 'x'
            username = password = ''

        # get the user's login info
        choices = '1 2 3 4'.split()
        while choice not in choices:
            self.announce('''\
We need to know who you are, so please choose either:
 1. use your existing login,
 2. register as a new user,
 3. have the server generate a new password for you (and email it to you), or
 4. quit
Your selection [default 1]: ''', log.INFO)

            choice = raw_input()
            if not choice:
                choice = '1'
            elif choice not in choices:
                print 'Please choose one of the four options!'

        if choice == '1':
            # get the username and password
            while not username:
                username = raw_input('Username: ')
            while not password:
                password = getpass.getpass('Password: ')

            # set up the authentication
            auth = urllib2.HTTPPasswordMgr()
            host = urlparse.urlparse(self.repository)[1]
            auth.add_password(self.realm, host, username, password)
            # send the info to the server and report the result
            code, result = self.post_to_server(self.build_post_data('submit'),
                auth)
            self.announce('Server response (%s): %s' % (code, result),
                          log.INFO)

            # possibly save the login
            if code == 200:
                if self.has_config:
                    # sharing the password in the distribution instance
                    # so the upload command can reuse it
                    self.distribution.password = password
                else:
                    self.announce(('I can store your PyPI login so future '
                                   'submissions will be faster.'), log.INFO)
                    self.announce('(the login will be stored in %s)' % \
                                  self._get_rc_file(), log.INFO)
                    choice = 'X'
                    while choice.lower() not in 'yn':
                        choice = raw_input('Save your login (y/N)?')
                        if not choice:
                            choice = 'n'
                    if choice.lower() == 'y':
                        self._store_pypirc(username, password)

        elif choice == '2':
            data = {':action': 'user'}
            data['name'] = data['password'] = data['email'] = ''
            data['confirm'] = None
            while not data['name']:
                data['name'] = raw_input('Username: ')
            while data['password'] != data['confirm']:
                while not data['password']:
                    data['password'] = getpass.getpass('Password: ')
                while not data['confirm']:
                    data['confirm'] = getpass.getpass(' Confirm: ')
                if data['password'] != data['confirm']:
                    data['password'] = ''
                    data['confirm'] = None
                    print "Password and confirm don't match!"
            while not data['email']:
                data['email'] = raw_input('   EMail: ')
            code, result = self.post_to_server(data)
            if code != 200:
                log.info('Server response (%s): %s' % (code, result))
            else:
                log.info('You will receive an email shortly.')
                log.info(('Follow the instructions in it to '
                          'complete registration.'))
        elif choice == '3':
            data = {':action': 'password_reset'}
            data['email'] = ''
            while not data['email']:
                data['email'] = raw_input('Your email address: ')
            code, result = self.post_to_server(data)
            log.info('Server response (%s): %s' % (code, result))

    def build_post_data(self, action):
        # figure the data to send - the metadata plus some additional
        # information used by the package server
        meta = self.distribution.metadata
        data = {
            ':action': action,
            'metadata_version' : '1.0',
            'name': meta.get_name(),
            'version': meta.get_version(),
            'summary': meta.get_description(),
            'home_page': meta.get_url(),
            'author': meta.get_contact(),
            'author_email': meta.get_contact_email(),
            'license': meta.get_licence(),
            'description': meta.get_long_description(),
            'keywords': meta.get_keywords(),
            'platform': meta.get_platforms(),
            'classifiers': meta.get_classifiers(),
            'download_url': meta.get_download_url(),
            # PEP 314
            'provides': meta.get_provides(),
            'requires': meta.get_requires(),
            'obsoletes': meta.get_obsoletes(),
        }
        if data['provides'] or data['requires'] or data['obsoletes']:
            data['metadata_version'] = '1.1'
        return data

    def post_to_server(self, data, auth=None):
        ''' Post a query to the server, and return a string response.
        '''
        if 'name' in data:
            self.announce('Registering %s to %s' % (data['name'],
                                                   self.repository),
                                                   log.INFO)
        # Build up the MIME payload for the urllib2 POST data
        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
        sep_boundary = '\n--' + boundary
        end_boundary = sep_boundary + '--'
        chunks = []
        for key, value in data.items():
            # handle multiple entries for the same name
            if type(value) not in (type([]), type( () )):
                value = [value]
            for value in value:
                chunks.append(sep_boundary)
                chunks.append('\nContent-Disposition: form-data; name="%s"'%key)
                chunks.append("\n\n")
                chunks.append(value)
                if value and value[-1] == '\r':
                    chunks.append('\n')  # write an extra newline (lurve Macs)
        chunks.append(end_boundary)
        chunks.append("\n")

        # chunks may be bytes (str) or unicode objects that we need to encode
        body = []
        for chunk in chunks:
            if isinstance(chunk, unicode):
                body.append(chunk.encode('utf-8'))
            else:
                body.append(chunk)

        body = ''.join(body)

        # build the Request
        headers = {
            'Content-type': 'multipart/form-data; boundary=%s; charset=utf-8'%boundary,
            'Content-length': str(len(body))
        }
        req = urllib2.Request(self.repository, body, headers)

        # handle HTTP and include the Basic Auth handler
        opener = urllib2.build_opener(
            urllib2.HTTPBasicAuthHandler(password_mgr=auth)
        )
        data = ''
        try:
            result = opener.open(req)
        except urllib2.HTTPError, e:
            if self.show_response:
                data = e.fp.read()
            result = e.code, e.msg
        except urllib2.URLError, e:
            result = 500, str(e)
        else:
            if self.show_response:
                data = result.read()
            result = 200, 'OK'
        if self.show_response:
            dashes = '-' * 75
            self.announce('%s%s%s' % (dashes, data, dashes))

        return result
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python2.7/distutils/command/register.pyc                                                    0100644 0000000 0000000 00000023724 13077704274 020422  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sz   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l	 m
 Z
 d e f d Ñ  É  YZ d S(	   sh   distutils.command.register

Implements the Distutils 'register' command (register with the repository).
s   $Id$iˇˇˇˇN(   t   warn(   t   PyPIRCCommand(   t   logt   registerc           B   s¶   e  Z d  Z e j d d g Z e j d d d g Z d d Ñ  f g Z d Ñ  Z d	 Ñ  Z	 d
 Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z RS(   s7   register the distribution with the Python package indexs   list-classifierss    list the valid Trove classifierst   strictsB   Will stop the registering if the meta-data are not fully compliantt   verifyt   checkc         C   s   t  S(   N(   t   True(   t   self(    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   <lambda>   s    c         C   s#   t  j |  É d |  _ d |  _ d  S(   Ni    (   R   t   initialize_optionst   list_classifiersR   (   R   (    (    s0   /usr/lib/python2.7/distutils/command/register.pyR
       s    	c         C   s>   t  j |  É i d |  j f d 6d d 6} | |  j j d <d  S(   NR   R   i   t   restructuredtextR   (   s   registeri   (   R   t   finalize_optionsR   t   distributiont   command_options(   R   t   check_options(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   %   s    
c         C   sr   |  j  É  |  j É  x! |  j É  D] } |  j | É q! W|  j rN |  j É  n  |  j rd |  j É  n
 |  j É  d  S(   N(	   R   t   _set_configt   get_sub_commandst   run_commandt   dry_runt   verify_metadataR   t   classifierst   send_metadata(   R   t   cmd_name(    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   run,   s    

		c         C   sL   t  d t É |  j j d É } | j É  |  j | _ d | _ | j É  d S(   s   Deprecated API.sd   distutils.command.register.check_metadata is deprecated,               use the check command insteadR   i   N(   R    t   PendingDeprecationWarningR   t   get_command_objt   ensure_finalizedR   R   R   (   R   R   (    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   check_metadata;   s    

	c         C   s±   |  j  É  } | i  k rX | d |  _ | d |  _ | d |  _ | d |  _ t |  _ nU |  j d |  j f k rÜ t d |  j É Ç n  |  j d k r§ |  j |  _ n  t	 |  _ d S(   s:    Reads the configuration file and set attributes.
        t   usernamet   passwordt
   repositoryt   realmt   pypis   %s not found in .pypircN(
   t   _read_pypircR   R   R    R!   R   t
   has_configt   DEFAULT_REPOSITORYt
   ValueErrort   False(   R   t   config(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   E   s    c         C   s-   t  j |  j d É } t j | j É  É d S(   s8    Fetch the list of classifiers from the server.
        s   ?:action=list_classifiersN(   t   urllib2t   urlopenR    R   t   infot   read(   R   t   response(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   V   s    c         C   s9   |  j  |  j d É É \ } } t j d | | f É d S(   sF    Send the metadata to the package index server to be checked.
        R   s   Server response (%s): %sN(   t   post_to_servert   build_post_dataR   R+   (   R   t   codet   result(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   \   s    c   
      C   sÊ  |  j  r$ d } |  j } |  j } n d } d } } d j É  } xO | | k rë |  j d t j É t É  } | sz d } qC | | k rC d GHqC qC W| d k rx | s∂ t d É } q° Wx | s“ t j d É } q∫ Wt	 j
 É  } t j |  j É d	 } | j |  j | | | É |  j |  j d
 É | É \ } } |  j d | | f t j É | d k r‚|  j  rp| |  j _ q|  j d t j É |  j d |  j É  t j É d } x1 | j É  d k rŸt d É } | s©d } q©q©W| j É  d k r|  j | | É qq‚n›| d k roi d d 6}	 d |	 d <|	 d <|	 d <d# |	 d <x |	 d sbt d É |	 d <qEWxê |	 d |	 d k rıx! |	 d sùt j d É |	 d <q}Wx! |	 d s¡t j d É |	 d <q°W|	 d |	 d k rfd |	 d <d# |	 d <d GHqfqfWx |	 d st d É |	 d <q˘W|  j |	 É \ } } | d k rRt j d | | f É q‚t j d É t j d É ns | d  k r‚i d! d 6}	 d |	 d <x |	 d s≤t d" É |	 d <qïW|  j |	 É \ } } t j d | | f É n  d# S($   s_   Send the metadata to the package index server.

            Well, do the following:
            1. figure who the user is, and then
            2. send the data as a Basic auth'ed POST.

            First we try to read the username/password from $HOME/.pypirc,
            which is a ConfigParser-formatted file with a section
            [distutils] containing username and password entries (both
            in clear text). Eg:

                [distutils]
                index-servers =
                    pypi

                [pypi]
                username: fred
                password: sekrit

            Otherwise, to figure who the user is, we offer the user three
            choices:

             1. use existing login,
             2. register as a new user, or
             3. set the password to a random string and email the user.

        t   1t   xt    s   1 2 3 4s‚   We need to know who you are, so please choose either:
 1. use your existing login,
 2. register as a new user,
 3. have the server generate a new password for you (and email it to you), or
 4. quit
Your selection [default 1]: s&   Please choose one of the four options!s
   Username: s
   Password: i   t   submits   Server response (%s): %si»   sA   I can store your PyPI login so future submissions will be faster.s    (the login will be stored in %s)t   Xt   yns   Save your login (y/N)?t   nt   yt   2t   users   :actiont   nameR   t   emailt   confirms
    Confirm: s!   Password and confirm don't match!s
      EMail: s"   You will receive an email shortly.s7   Follow the instructions in it to complete registration.t   3t   password_resets   Your email address: N(   R$   R   R   t   splitt   announceR   t   INFOt	   raw_inputt   getpassR)   t   HTTPPasswordMgrt   urlparseR    t   add_passwordR!   R.   R/   R   t   _get_rc_filet   lowert   _store_pypirct   NoneR+   (
   R   t   choiceR   R   t   choicest   autht   hostR0   R1   t   data(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   d   så    		
				
		
	



c         C   s  |  j  j } i | d 6d d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d	 6| j É  d
 6| j	 É  d 6| j
 É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6} | d s| d s| d rd | d <n  | S(   Ns   :actions   1.0t   metadata_versionR<   t   versiont   summaryt	   home_paget   authort   author_emailt   licenset   descriptiont   keywordst   platformR   t   download_urlt   providest   requirest	   obsoletess   1.1(   R   t   metadatat   get_namet   get_versiont   get_descriptiont   get_urlt   get_contactt   get_contact_emailt   get_licencet   get_long_descriptiont   get_keywordst   get_platformst   get_classifierst   get_download_urlt   get_providest   get_requirest   get_obsoletes(   R   t   actiont   metaRQ   (    (    s0   /usr/lib/python2.7/distutils/command/register.pyR/   ﬂ   s,    c         C   s≥  d | k r3 |  j  d | d |  j f t j É n  d } d | } | d } g  } xπ | j É  D]´ \ } } t | É t g  É t d É f k rú | g } n  xl | D]d } | j | É | j d | É | j d É | j | É | r£ | d d	 k r£ | j d
 É q£ q£ Wq` W| j | É | j d
 É g  }	 xC | D]; }
 t |
 t É rd|	 j |
 j	 d É É q6|	 j |
 É q6Wd j
 |	 É }	 i d | d 6t t |	 É É d 6} t j |  j |	 | É } t j t j d | É É } d } y | j | É } Wnj t j k
 r9} |  j r$| j j É  } n  | j | j f } nF t j k
 r`} d t | É f } n X|  j ry| j É  } n  d } |  j rØd d } |  j  d | | | f É n  | S(   sC    Post a query to the server, and return a string response.
        R<   s   Registering %s to %ss3   --------------GHSKFJDLGDS7543FJKLFHRE75642756743254s   
--s   --s*   
Content-Disposition: form-data; name="%s"s   

iˇˇˇˇs   s   
s   utf-8R4   s/   multipart/form-data; boundary=%s; charset=utf-8s   Content-types   Content-lengtht   password_mgriÙ  i»   t   OKt   -iK   s   %s%s%s(    (   i»   Rs   (   RB   R    R   RC   t   itemst   typet   appendt
   isinstancet   unicodet   encodet   joint   strt   lenR)   t   Requestt   build_openert   HTTPBasicAuthHandlert   opent	   HTTPErrort   show_responset   fpR,   R0   t   msgt   URLError(   R   RQ   RO   t   boundaryt   sep_boundaryt   end_boundaryt   chunkst   keyt   valuet   bodyt   chunkt   headerst   reqt   openerR1   t   et   dashes(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR.   ˚   s`    


$			
N(   s   list-classifiersNs    list the valid Trove classifiers(   s   strictNsB   Will stop the registering if the meta-data are not fully compliant(   t   __name__t
   __module__RY   R   t   user_optionsRL   t   boolean_optionst   sub_commandsR
   R   R   R   R   R   R   R   R/   R.   (    (    (    s0   /usr/lib/python2.7/distutils/command/register.pyR      s&     
				
				{	(   t   __doc__t   __revision__R)   RE   RG   t   warningsR    t   distutils.coreR   t	   distutilsR   R   (    (    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   <module>   s                                               usr/lib/python2.7/distutils/command/sdist.py                                                        0100644 0000000 0000000 00000044175 12734733743 017566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution)."""

__revision__ = "$Id$"

import os
import string
import sys
from glob import glob
from warnings import warn

from distutils.core import Command
from distutils import dir_util, dep_util, file_util, archive_util
from distutils.text_file import TextFile
from distutils.errors import (DistutilsPlatformError, DistutilsOptionError,
                              DistutilsTemplateError)
from distutils.filelist import FileList
from distutils import log
from distutils.util import convert_path

def show_formats():
    """Print all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    """
    from distutils.fancy_getopt import FancyGetopt
    from distutils.archive_util import ARCHIVE_FORMATS
    formats = []
    for format in ARCHIVE_FORMATS.keys():
        formats.append(("formats=" + format, None,
                        ARCHIVE_FORMATS[format][2]))
    formats.sort()
    FancyGetopt(formats).print_help(
        "List of available source distribution formats:")

class sdist(Command):

    description = "create a source distribution (tarball, zip file, etc.)"

    def checking_metadata(self):
        """Callable used for the check sub-command.

        Placed here so user_options can view it"""
        return self.metadata_check

    user_options = [
        ('template=', 't',
         "name of manifest template file [default: MANIFEST.in]"),
        ('manifest=', 'm',
         "name of manifest file [default: MANIFEST]"),
        ('use-defaults', None,
         "include the default file set in the manifest "
         "[default; disable with --no-defaults]"),
        ('no-defaults', None,
         "don't include the default file set"),
        ('prune', None,
         "specifically exclude files/directories that should not be "
         "distributed (build tree, RCS/CVS dirs, etc.) "
         "[default; disable with --no-prune]"),
        ('no-prune', None,
         "don't automatically exclude anything"),
        ('manifest-only', 'o',
         "just regenerate the manifest and then stop "
         "(implies --force-manifest)"),
        ('force-manifest', 'f',
         "forcibly regenerate the manifest and carry on as usual. "
         "Deprecated: now the manifest is always regenerated."),
        ('formats=', None,
         "formats for source distribution (comma-separated list)"),
        ('keep-temp', 'k',
         "keep the distribution tree around after creating " +
         "archive file(s)"),
        ('dist-dir=', 'd',
         "directory to put the source distribution archive(s) in "
         "[default: dist]"),
        ('metadata-check', None,
         "Ensure that all required elements of meta-data "
         "are supplied. Warn if any missing. [default]"),
        ('owner=', 'u',
         "Owner name used when creating a tar file [default: current user]"),
        ('group=', 'g',
         "Group name used when creating a tar file [default: current group]"),
        ]

    boolean_options = ['use-defaults', 'prune',
                       'manifest-only', 'force-manifest',
                       'keep-temp', 'metadata-check']

    help_options = [
        ('help-formats', None,
         "list available distribution formats", show_formats),
        ]

    negative_opt = {'no-defaults': 'use-defaults',
                    'no-prune': 'prune' }

    default_format = {'posix': 'gztar',
                      'nt': 'zip' }

    sub_commands = [('check', checking_metadata)]

    def initialize_options(self):
        # 'template' and 'manifest' are, respectively, the names of
        # the manifest template and manifest file.
        self.template = None
        self.manifest = None

        # 'use_defaults': if true, we will include the default file set
        # in the manifest
        self.use_defaults = 1
        self.prune = 1

        self.manifest_only = 0
        self.force_manifest = 0

        self.formats = None
        self.keep_temp = 0
        self.dist_dir = None

        self.archive_files = None
        self.metadata_check = 1
        self.owner = None
        self.group = None

    def finalize_options(self):
        if self.manifest is None:
            self.manifest = "MANIFEST"
        if self.template is None:
            self.template = "MANIFEST.in"

        self.ensure_string_list('formats')
        if self.formats is None:
            try:
                self.formats = [self.default_format[os.name]]
            except KeyError:
                raise DistutilsPlatformError, \
                      "don't know how to create source distributions " + \
                      "on platform %s" % os.name

        bad_format = archive_util.check_archive_formats(self.formats)
        if bad_format:
            raise DistutilsOptionError, \
                  "unknown archive format '%s'" % bad_format

        if self.dist_dir is None:
            self.dist_dir = "dist"

    def run(self):
        # 'filelist' contains the list of files that will make up the
        # manifest
        self.filelist = FileList()

        # Run sub commands
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        # Do whatever it takes to get the list of files to process
        # (process the manifest template, read an existing manifest,
        # whatever).  File list is accumulated in 'self.filelist'.
        self.get_file_list()

        # If user just wanted us to regenerate the manifest, stop now.
        if self.manifest_only:
            return

        # Otherwise, go ahead and create the source distribution tarball,
        # or zipfile, or whatever.
        self.make_distribution()

    def check_metadata(self):
        """Deprecated API."""
        warn("distutils.command.sdist.check_metadata is deprecated, \
              use the check command instead", PendingDeprecationWarning)
        check = self.distribution.get_command_obj('check')
        check.ensure_finalized()
        check.run()

    def get_file_list(self):
        """Figure out the list of files to include in the source
        distribution, and put it in 'self.filelist'.  This might involve
        reading the manifest template (and writing the manifest), or just
        reading the manifest, or just using the default file set -- it all
        depends on the user's options.
        """
        # new behavior when using a template:
        # the file list is recalculated every time because
        # even if MANIFEST.in or setup.py are not changed
        # the user might have added some files in the tree that
        # need to be included.
        #
        #  This makes --force the default and only behavior with templates.
        template_exists = os.path.isfile(self.template)
        if not template_exists and self._manifest_is_not_generated():
            self.read_manifest()
            self.filelist.sort()
            self.filelist.remove_duplicates()
            return

        if not template_exists:
            self.warn(("manifest template '%s' does not exist " +
                        "(using default file list)") %
                        self.template)
        self.filelist.findall()

        if self.use_defaults:
            self.add_defaults()

        if template_exists:
            self.read_template()

        if self.prune:
            self.prune_file_list()

        self.filelist.sort()
        self.filelist.remove_duplicates()
        self.write_manifest()

    def add_defaults(self):
        """Add all the default files to self.filelist:
          - README or README.txt
          - setup.py
          - test/test*.py
          - all pure Python modules mentioned in setup script
          - all files pointed by package_data (build_py)
          - all files defined in data_files.
          - all files defined as scripts.
          - all C sources listed as part of extensions or C libraries
            in the setup script (doesn't catch C headers!)
        Warns if (README or README.txt) or setup.py are missing; everything
        else is optional.
        """

        standards = [('README', 'README.txt'), self.distribution.script_name]
        for fn in standards:
            if isinstance(fn, tuple):
                alts = fn
                got_it = 0
                for fn in alts:
                    if os.path.exists(fn):
                        got_it = 1
                        self.filelist.append(fn)
                        break

                if not got_it:
                    self.warn("standard file not found: should have one of " +
                              string.join(alts, ', '))
            else:
                if os.path.exists(fn):
                    self.filelist.append(fn)
                else:
                    self.warn("standard file '%s' not found" % fn)

        optional = ['test/test*.py', 'setup.cfg']
        for pattern in optional:
            files = filter(os.path.isfile, glob(pattern))
            if files:
                self.filelist.extend(files)

        # build_py is used to get:
        #  - python modules
        #  - files defined in package_data
        build_py = self.get_finalized_command('build_py')

        # getting python files
        if self.distribution.has_pure_modules():
            self.filelist.extend(build_py.get_source_files())

        # getting package_data files
        # (computed in build_py.data_files by build_py.finalize_options)
        for pkg, src_dir, build_dir, filenames in build_py.data_files:
            for filename in filenames:
                self.filelist.append(os.path.join(src_dir, filename))

        # getting distribution.data_files
        if self.distribution.has_data_files():
            for item in self.distribution.data_files:
                if isinstance(item, str): # plain file
                    item = convert_path(item)
                    if os.path.isfile(item):
                        self.filelist.append(item)
                else:    # a (dirname, filenames) tuple
                    dirname, filenames = item
                    for f in filenames:
                        f = convert_path(f)
                        if os.path.isfile(f):
                            self.filelist.append(f)

        if self.distribution.has_ext_modules():
            build_ext = self.get_finalized_command('build_ext')
            self.filelist.extend(build_ext.get_source_files())

        if self.distribution.has_c_libraries():
            build_clib = self.get_finalized_command('build_clib')
            self.filelist.extend(build_clib.get_source_files())

        if self.distribution.has_scripts():
            build_scripts = self.get_finalized_command('build_scripts')
            self.filelist.extend(build_scripts.get_source_files())

    def read_template(self):
        """Read and parse manifest template file named by self.template.

        (usually "MANIFEST.in") The parsing and processing is done by
        'self.filelist', which updates itself accordingly.
        """
        log.info("reading manifest template '%s'", self.template)
        template = TextFile(self.template,
                            strip_comments=1,
                            skip_blanks=1,
                            join_lines=1,
                            lstrip_ws=1,
                            rstrip_ws=1,
                            collapse_join=1)

        try:
            while 1:
                line = template.readline()
                if line is None:            # end of file
                    break

                try:
                    self.filelist.process_template_line(line)
                # the call above can raise a DistutilsTemplateError for
                # malformed lines, or a ValueError from the lower-level
                # convert_path function
                except (DistutilsTemplateError, ValueError) as msg:
                    self.warn("%s, line %d: %s" % (template.filename,
                                                   template.current_line,
                                                   msg))
        finally:
            template.close()

    def prune_file_list(self):
        """Prune off branches that might slip into the file list as created
        by 'read_template()', but really don't belong there:
          * the build tree (typically "build")
          * the release tree itself (only an issue if we ran "sdist"
            previously with --keep-temp, or it aborted)
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
        """
        build = self.get_finalized_command('build')
        base_dir = self.distribution.get_fullname()

        self.filelist.exclude_pattern(None, prefix=build.build_base)
        self.filelist.exclude_pattern(None, prefix=base_dir)

        # pruning out vcs directories
        # both separators are used under win32
        if sys.platform == 'win32':
            seps = r'/|\\'
        else:
            seps = '/'

        vcs_dirs = ['RCS', 'CVS', r'\.svn', r'\.hg', r'\.git', r'\.bzr',
                    '_darcs']
        vcs_ptrn = r'(^|%s)(%s)(%s).*' % (seps, '|'.join(vcs_dirs), seps)
        self.filelist.exclude_pattern(vcs_ptrn, is_regex=1)

    def write_manifest(self):
        """Write the file list in 'self.filelist' (presumably as filled in
        by 'add_defaults()' and 'read_template()') to the manifest file
        named by 'self.manifest'.
        """
        if self._manifest_is_not_generated():
            log.info("not writing to manually maintained "
                     "manifest file '%s'" % self.manifest)
            return

        content = self.filelist.files[:]
        content.insert(0, '# file GENERATED by distutils, do NOT edit')
        self.execute(file_util.write_file, (self.manifest, content),
                     "writing manifest file '%s'" % self.manifest)

    def _manifest_is_not_generated(self):
        # check for special comment used in 2.7.1 and higher
        if not os.path.isfile(self.manifest):
            return False

        fp = open(self.manifest, 'rU')
        try:
            first_line = fp.readline()
        finally:
            fp.close()
        return first_line != '# file GENERATED by distutils, do NOT edit\n'

    def read_manifest(self):
        """Read the manifest file (named by 'self.manifest') and use it to
        fill in 'self.filelist', the list of files to include in the source
        distribution.
        """
        log.info("reading manifest file '%s'", self.manifest)
        manifest = open(self.manifest)
        for line in manifest:
            # ignore comments and blank lines
            line = line.strip()
            if line.startswith('#') or not line:
                continue
            self.filelist.append(line)
        manifest.close()

    def make_release_tree(self, base_dir, files):
        """Create the directory tree that will become the source
        distribution archive.  All directories implied by the filenames in
        'files' are created under 'base_dir', and then we hard link or copy
        (if hard linking is unavailable) those files into place.
        Essentially, this duplicates the developer's source tree, but in a
        directory named after the distribution, containing only the files
        to be distributed.
        """
        # Create all the directories under 'base_dir' necessary to
        # put 'files' there; the 'mkpath()' is just so we don't die
        # if the manifest happens to be empty.
        self.mkpath(base_dir)
        dir_util.create_tree(base_dir, files, dry_run=self.dry_run)

        # And walk over the list of files, either making a hard link (if
        # os.link exists) to each one that doesn't already exist in its
        # corresponding location under 'base_dir', or copying each file
        # that's out-of-date in 'base_dir'.  (Usually, all files will be
        # out-of-date, because by default we blow away 'base_dir' when
        # we're done making the distribution archives.)

        if hasattr(os, 'link'):        # can make hard links on this system
            link = 'hard'
            msg = "making hard links in %s..." % base_dir
        else:                           # nope, have to copy
            link = None
            msg = "copying files to %s..." % base_dir

        if not files:
            log.warn("no files to distribute -- empty manifest?")
        else:
            log.info(msg)
        for file in files:
            if not os.path.isfile(file):
                log.warn("'%s' not a regular file -- skipping" % file)
            else:
                dest = os.path.join(base_dir, file)
                self.copy_file(file, dest, link=link)

        self.distribution.metadata.write_pkg_info(base_dir)

    def make_distribution(self):
        """Create the source distribution(s).  First, we create the release
        tree with 'make_release_tree()'; then, we create all required
        archive files (according to 'self.formats') from the release tree.
        Finally, we clean up by blowing away the release tree (unless
        'self.keep_temp' is true).  The list of archive files created is
        stored so it can be retrieved later by 'get_archive_files()'.
        """
        # Don't warn about missing meta-data here -- should be (and is!)
        # done elsewhere.
        base_dir = self.distribution.get_fullname()
        base_name = os.path.join(self.dist_dir, base_dir)

        self.make_release_tree(base_dir, self.filelist.files)
        archive_files = []              # remember names of files we create
        # tar archive must be created last to avoid overwrite and remove
        if 'tar' in self.formats:
            self.formats.append(self.formats.pop(self.formats.index('tar')))

        for fmt in self.formats:
            file = self.make_archive(base_name, fmt, base_dir=base_dir,
                                     owner=self.owner, group=self.group)
            archive_files.append(file)
            self.distribution.dist_files.append(('sdist', '', file))

        self.archive_files = archive_files

        if not self.keep_temp:
            dir_util.remove_tree(base_dir, dry_run=self.dry_run)

    def get_archive_files(self):
        """Return the list of archive files created when the command
        was run, or None if the command hasn't run yet.
        """
        return self.archive_files
                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/distutils/command/sdist.pyc                                                       0100644 0000000 0000000 00000040430 13077704274 017715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s  d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z m Z m Z m Z d d l m Z d d	 l m Z m Z m Z d d
 l m Z d d l
 m Z d d l m Z d Ñ  Z d e	 f d Ñ  É  YZ d S(   sa   distutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution).s   $Id$iˇˇˇˇN(   t   glob(   t   warn(   t   Command(   t   dir_utilt   dep_utilt	   file_utilt   archive_util(   t   TextFile(   t   DistutilsPlatformErrort   DistutilsOptionErrort   DistutilsTemplateError(   t   FileList(   t   log(   t   convert_pathc          C   sÄ   d d l  m }  d d l m } g  } x6 | j É  D]( } | j d | d | | d f É q3 W| j É  |  | É j d É d S(   so   Print all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    iˇˇˇˇ(   t   FancyGetopt(   t   ARCHIVE_FORMATSs   formats=i   s.   List of available source distribution formats:N(	   t   distutils.fancy_getoptR   t   distutils.archive_utilR   t   keyst   appendt   Nonet   sortt
   print_help(   R   R   t   formatst   format(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   show_formats   s    
t   sdistc           B   s6  e  Z d  Z d Ñ  Z d< d= d? d@ dA dB dC dD dE d d d d f dF dG dH dI g Z d d d d d d g Z d' d> d( e f g Z i d d
 6d d 6Z	 i d) d* 6d+ d, 6Z
 d- e f g Z d. Ñ  Z d/ Ñ  Z d0 Ñ  Z d1 Ñ  Z d2 Ñ  Z d3 Ñ  Z d4 Ñ  Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z RS(J   s6   create a source distribution (tarball, zip file, etc.)c         C   s   |  j  S(   sY   Callable used for the check sub-command.

        Placed here so user_options can view it(   t   metadata_check(   t   self(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   checking_metadata(   s    s	   template=t   ts5   name of manifest template file [default: MANIFEST.in]s	   manifest=t   ms)   name of manifest file [default: MANIFEST]s   use-defaultssR   include the default file set in the manifest [default; disable with --no-defaults]s   no-defaultss"   don't include the default file sett   prunesâ   specifically exclude files/directories that should not be distributed (build tree, RCS/CVS dirs, etc.) [default; disable with --no-prune]s   no-prunes$   don't automatically exclude anythings   manifest-onlyt   osE   just regenerate the manifest and then stop (implies --force-manifest)s   force-manifestt   fsk   forcibly regenerate the manifest and carry on as usual. Deprecated: now the manifest is always regenerated.s   formats=s6   formats for source distribution (comma-separated list)s	   keep-tempt   ks1   keep the distribution tree around after creating s   archive file(s)s	   dist-dir=t   dsF   directory to put the source distribution archive(s) in [default: dist]s   metadata-checks[   Ensure that all required elements of meta-data are supplied. Warn if any missing. [default]s   owner=t   us@   Owner name used when creating a tar file [default: current user]s   group=t   gsA   Group name used when creating a tar file [default: current group]s   help-formatss#   list available distribution formatst   gztart   posixt   zipt   ntt   checkc         C   sy   d  |  _ d  |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d |  _ d  |  _	 d  |  _
 d |  _ d  |  _ d  |  _ d  S(   Ni   i    (   R   t   templatet   manifestt   use_defaultsR    t   manifest_onlyt   force_manifestR   t	   keep_tempt   dist_dirt   archive_filesR   t   ownert   group(   R   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   initialize_optionsf   s    												c         C   sﬁ   |  j  d  k r d |  _  n  |  j d  k r6 d |  _ n  |  j d É |  j d  k ró y |  j t j g |  _ Wqó t k
 rì t	 d d t j Ç qó Xn  t
 j |  j É } | rø t d | Ç n  |  j d  k r⁄ d |  _ n  d  S(   Nt   MANIFESTs   MANIFEST.inR   s.   don't know how to create source distributions s   on platform %ss   unknown archive format '%s't   dist(   R-   R   R,   t   ensure_string_listR   t   default_formatt   ost   namet   KeyErrorR   R   t   check_archive_formatsR	   R2   (   R   t
   bad_format(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   finalize_options}   s$    c         C   sU   t  É  |  _ x! |  j É  D] } |  j | É q W|  j É  |  j rG d  S|  j É  d  S(   N(   R   t   filelistt   get_sub_commandst   run_commandt   get_file_listR/   t   make_distribution(   R   t   cmd_name(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   runî   s    
	c         C   s7   t  d t É |  j j d É } | j É  | j É  d S(   s   Deprecated API.sa   distutils.command.sdist.check_metadata is deprecated,               use the check command insteadR+   N(   R   t   PendingDeprecationWarningt   distributiont   get_command_objt   ensure_finalizedRG   (   R   R+   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   check_metadata™   s
    

c         C   sÂ   t  j j |  j É } | rP |  j É  rP |  j É  |  j j É  |  j j É  d S| sq |  j	 d d |  j É n  |  j j
 É  |  j rî |  j É  n  | rß |  j É  n  |  j rΩ |  j É  n  |  j j É  |  j j É  |  j É  d S(   sC  Figure out the list of files to include in the source
        distribution, and put it in 'self.filelist'.  This might involve
        reading the manifest template (and writing the manifest), or just
        reading the manifest, or just using the default file set -- it all
        depends on the user's options.
        Ns&   manifest template '%s' does not exist s   (using default file list)(   R;   t   patht   isfileR,   t   _manifest_is_not_generatedt   read_manifestRA   R   t   remove_duplicatesR   t   findallR.   t   add_defaultst   read_templateR    t   prune_file_listt   write_manifest(   R   t   template_exists(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRD   ≤   s(    
			c         C   s  d |  j  j g } x≈ | D]Ω } t | t É r† | } d } x: | D]2 } t j j | É rA d } |  j j | É PqA qA W| s÷ |  j	 d t
 j | d É É q÷ q t j j | É r≈ |  j j | É q |  j	 d | É q Wd d	 g } xB | D]: } t t j j t | É É } | rÌ |  j j | É qÌ qÌ W|  j d
 É } |  j  j É  rb|  j j | j É  É n  xM | j D]B \ }	 }
 } } x- | D]% } |  j j t j j |
 | É É qÖWqlW|  j  j É  rlx® |  j  j D]ó } t | t É rt | É } t j j | É re|  j j | É qeqŒ| \ } } x? | D]7 } t | É } t j j | É r*|  j j | É q*q*WqŒWn  |  j  j É  r£|  j d É } |  j j | j É  É n  |  j  j É  r⁄|  j d É } |  j j | j É  É n  |  j  j É  r|  j d É } |  j j | j É  É n  d S(   s9  Add all the default files to self.filelist:
          - README or README.txt
          - setup.py
          - test/test*.py
          - all pure Python modules mentioned in setup script
          - all files pointed by package_data (build_py)
          - all files defined in data_files.
          - all files defined as scripts.
          - all C sources listed as part of extensions or C libraries
            in the setup script (doesn't catch C headers!)
        Warns if (README or README.txt) or setup.py are missing; everything
        else is optional.
        t   READMEs
   README.txti    i   s,   standard file not found: should have one of s   , s   standard file '%s' not founds   test/test*.pys	   setup.cfgt   build_pyt	   build_extt
   build_clibt   build_scriptsN(   RX   s
   README.txt(   RI   t   script_namet
   isinstancet   tupleR;   RM   t   existsRA   R   R   t   stringt   joint   filterRN   R    t   extendt   get_finalized_commandt   has_pure_modulest   get_source_filest
   data_filest   has_data_filest   strR   t   has_ext_modulest   has_c_librariest   has_scripts(   R   t	   standardst   fnt   altst   got_itt   optionalt   patternt   filesRY   t   pkgt   src_dirt	   build_dirt	   filenamest   filenamet   itemt   dirnameR"   RZ   R[   R\   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRS   ⁄   s^    	'c         C   sŒ   t  j d |  j É t |  j d d d d d d d d d d d d É} zv xo | j É  } | d
 k rh Pn  y |  j j | É WqL t t	 f k
 r∑ } |  j
 d	 | j | j | f É qL XqL Wd
 | j É  Xd
 S(   s»   Read and parse manifest template file named by self.template.

        (usually "MANIFEST.in") The parsing and processing is done by
        'self.filelist', which updates itself accordingly.
        s   reading manifest template '%s't   strip_commentsi   t   skip_blankst
   join_linest	   lstrip_wst	   rstrip_wst   collapse_joins   %s, line %d: %sN(   R   t   infoR,   R   t   readlineR   RA   t   process_template_lineR
   t
   ValueErrorR   Ry   t   current_linet   close(   R   R,   t   linet   msg(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRT   ,  s(    	c         C   sº   |  j  d É } |  j j É  } |  j j d d | j É|  j j d d | Ét j d k re d } n d } d d d d	 d
 d d g } d | d j	 | É | f } |  j j | d d Éd S(   sv  Prune off branches that might slip into the file list as created
        by 'read_template()', but really don't belong there:
          * the build tree (typically "build")
          * the release tree itself (only an issue if we ran "sdist"
            previously with --keep-temp, or it aborted)
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
        t   buildt   prefixt   win32s   /|\\t   /t   RCSt   CVSs   \.svns   \.hgs   \.gits   \.bzrt   _darcss   (^|%s)(%s)(%s).*t   |t   is_regexi   N(
   Re   RI   t   get_fullnameRA   t   exclude_patternR   t
   build_baset   syst   platformRb   (   R   Rä   t   base_dirt   sepst   vcs_dirst   vcs_ptrn(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRU   M  s    		c         C   sk   |  j  É  r$ t j d |  j É d S|  j j } | j d d É |  j t j	 |  j | f d |  j É d S(   s≤   Write the file list in 'self.filelist' (presumably as filled in
        by 'add_defaults()' and 'read_template()') to the manifest file
        named by 'self.manifest'.
        s5   not writing to manually maintained manifest file '%s'Ni    s*   # file GENERATED by distutils, do NOT edits   writing manifest file '%s'(
   RO   R   RÇ   R-   RA   Rt   t   insertt   executeR   t
   write_file(   R   t   content(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRV   g  s    	c         C   sS   t  j j |  j É s t St |  j d É } z | j É  } Wd  | j É  X| d k S(   Nt   rUs+   # file GENERATED by distutils, do NOT edit
(   R;   RM   RN   R-   t   Falset   openRÉ   Rá   (   R   t   fpt
   first_line(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRO   v  s    c         C   sy   t  j d |  j É t |  j É } xF | D]> } | j É  } | j d É s) | rW q) n  |  j j | É q) W| j É  d S(   s™   Read the manifest file (named by 'self.manifest') and use it to
        fill in 'self.filelist', the list of files to include in the source
        distribution.
        s   reading manifest file '%s't   #N(	   R   RÇ   R-   R¢   t   stript
   startswithRA   R   Rá   (   R   R-   Rà   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRP   Ç  s    c         C   sÙ   |  j  | É t j | | d |  j Ét t d É rH d } d | } n d } d | } | sn t j d É n t j	 | É x_ | D]W } t j
 j | É sÆ t j d | É qÇ t j
 j | | É } |  j | | d | ÉqÇ W|  j j j | É d S(	   s∆  Create the directory tree that will become the source
        distribution archive.  All directories implied by the filenames in
        'files' are created under 'base_dir', and then we hard link or copy
        (if hard linking is unavailable) those files into place.
        Essentially, this duplicates the developer's source tree, but in a
        directory named after the distribution, containing only the files
        to be distributed.
        t   dry_runt   linkt   hards   making hard links in %s...s   copying files to %s...s)   no files to distribute -- empty manifest?s#   '%s' not a regular file -- skippingN(   t   mkpathR   t   create_treeR®   t   hasattrR;   R   R   R   RÇ   RM   RN   Rb   t	   copy_fileRI   t   metadatat   write_pkg_info(   R   Rò   Rt   R©   Râ   t   filet   dest(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   make_release_treeë  s     	
c      
   C   s  |  j  j É  } t j j |  j | É } |  j | |  j j É g  } d |  j	 k r} |  j	 j
 |  j	 j |  j	 j d É É É n  xd |  j	 D]Y } |  j | | d | d |  j d |  j É} | j
 | É |  j  j j
 d d | f É qá W| |  _ |  j st j | d |  j Én  d S(	   sØ  Create the source distribution(s).  First, we create the release
        tree with 'make_release_tree()'; then, we create all required
        archive files (according to 'self.formats') from the release tree.
        Finally, we clean up by blowing away the release tree (unless
        'self.keep_temp' is true).  The list of archive files created is
        stored so it can be retrieved later by 'get_archive_files()'.
        t   tarRò   R4   R5   R   t    R®   N(   RI   Rì   R;   RM   Rb   R2   R≥   RA   Rt   R   R   t   popt   indext   make_archiveR4   R5   t
   dist_filesR3   R1   R   t   remove_treeR®   (   R   Rò   t	   base_nameR3   t   fmtR±   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRE   ª  s    
+ 		c         C   s   |  j  S(   sz   Return the list of archive files created when the command
        was run, or None if the command hasn't run yet.
        (   R3   (   R   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   get_archive_filesŸ  s    (   s	   template=R   s5   name of manifest template file [default: MANIFEST.in](   s	   manifest=R   s)   name of manifest file [default: MANIFEST]N(   s   use-defaultsNsR   include the default file set in the manifest [default; disable with --no-defaults](   s   no-defaultsNs"   don't include the default file set(   s   pruneNsâ   specifically exclude files/directories that should not be distributed (build tree, RCS/CVS dirs, etc.) [default; disable with --no-prune](   s   no-pruneNs$   don't automatically exclude anything(   s   manifest-onlyR!   sE   just regenerate the manifest and then stop (implies --force-manifest)(   s   force-manifestR"   sk   forcibly regenerate the manifest and carry on as usual. Deprecated: now the manifest is always regenerated.(   s   formats=Ns6   formats for source distribution (comma-separated list)(   s	   dist-dir=R$   sF   directory to put the source distribution archive(s) in [default: dist](   s   metadata-checkNs[   Ensure that all required elements of meta-data are supplied. Warn if any missing. [default](   s   owner=R%   s@   Owner name used when creating a tar file [default: current user](   s   group=R&   sA   Group name used when creating a tar file [default: current group](   t   __name__t
   __module__t   descriptionR   R   t   user_optionst   boolean_optionsR   t   help_optionst   negative_optR:   t   sub_commandsR6   R@   RG   RL   RD   RS   RT   RU   RV   RO   RP   R≥   RE   RΩ   (    (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyR   $   sn   	             	



					(	R	!					*	(   t   __doc__t   __revision__R;   Ra   Rñ   R    t   warningsR   t   distutils.coreR   t	   distutilsR   R   R   R   t   distutils.text_fileR   t   distutils.errorsR   R	   R
   t   distutils.filelistR   R   t   distutils.utilR   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   <module>   s   "	                                                                                                                                                                                                                                        usr/lib/python2.7/distutils/command/upload.py                                                       0100644 0000000 0000000 00000015605 12734733743 017720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI)."""
import os
import socket
import platform
from urllib2 import urlopen, Request, HTTPError
from base64 import standard_b64encode
import urlparse
import cStringIO as StringIO
from hashlib import md5

from distutils.errors import DistutilsError, DistutilsOptionError
from distutils.core import PyPIRCCommand
from distutils.spawn import spawn
from distutils import log

class upload(PyPIRCCommand):

    description = "upload binary package to PyPI"

    user_options = PyPIRCCommand.user_options + [
        ('sign', 's',
         'sign files to upload using gpg'),
        ('identity=', 'i', 'GPG identity used to sign files'),
        ]

    boolean_options = PyPIRCCommand.boolean_options + ['sign']

    def initialize_options(self):
        PyPIRCCommand.initialize_options(self)
        self.username = ''
        self.password = ''
        self.show_response = 0
        self.sign = False
        self.identity = None

    def finalize_options(self):
        PyPIRCCommand.finalize_options(self)
        if self.identity and not self.sign:
            raise DistutilsOptionError(
                "Must use --sign for --identity to have meaning"
            )
        config = self._read_pypirc()
        if config != {}:
            self.username = config['username']
            self.password = config['password']
            self.repository = config['repository']
            self.realm = config['realm']

        # getting the password from the distribution
        # if previously set by the register command
        if not self.password and self.distribution.password:
            self.password = self.distribution.password

    def run(self):
        if not self.distribution.dist_files:
            raise DistutilsOptionError("No dist file created in earlier command")
        for command, pyversion, filename in self.distribution.dist_files:
            self.upload_file(command, pyversion, filename)

    def upload_file(self, command, pyversion, filename):
        # Makes sure the repository URL is compliant
        schema, netloc, url, params, query, fragments = \
            urlparse.urlparse(self.repository)
        if params or query or fragments:
            raise AssertionError("Incompatible url %s" % self.repository)

        if schema not in ('http', 'https'):
            raise AssertionError("unsupported schema " + schema)

        # Sign if requested
        if self.sign:
            gpg_args = ["gpg", "--detach-sign", "-a", filename]
            if self.identity:
                gpg_args[2:2] = ["--local-user", self.identity]
            spawn(gpg_args,
                  dry_run=self.dry_run)

        # Fill in the data - send all the meta-data in case we need to
        # register a new release
        f = open(filename,'rb')
        try:
            content = f.read()
        finally:
            f.close()
        meta = self.distribution.metadata
        data = {
            # action
            ':action': 'file_upload',
            'protcol_version': '1',

            # identify release
            'name': meta.get_name(),
            'version': meta.get_version(),

            # file content
            'content': (os.path.basename(filename),content),
            'filetype': command,
            'pyversion': pyversion,
            'md5_digest': md5(content).hexdigest(),

            # additional meta-data
            'metadata_version' : '1.0',
            'summary': meta.get_description(),
            'home_page': meta.get_url(),
            'author': meta.get_contact(),
            'author_email': meta.get_contact_email(),
            'license': meta.get_licence(),
            'description': meta.get_long_description(),
            'keywords': meta.get_keywords(),
            'platform': meta.get_platforms(),
            'classifiers': meta.get_classifiers(),
            'download_url': meta.get_download_url(),
            # PEP 314
            'provides': meta.get_provides(),
            'requires': meta.get_requires(),
            'obsoletes': meta.get_obsoletes(),
            }
        comment = ''
        if command == 'bdist_rpm':
            dist, version, id = platform.dist()
            if dist:
                comment = 'built for %s %s' % (dist, version)
        elif command == 'bdist_dumb':
            comment = 'built for %s' % platform.platform(terse=1)
        data['comment'] = comment

        if self.sign:
            data['gpg_signature'] = (os.path.basename(filename) + ".asc",
                                     open(filename+".asc").read())

        # set up the authentication
        auth = "Basic " + standard_b64encode(self.username + ":" +
                                             self.password)

        # Build up the MIME payload for the POST data
        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
        sep_boundary = '\r\n--' + boundary
        end_boundary = sep_boundary + '--\r\n'
        body = StringIO.StringIO()
        for key, value in data.items():
            # handle multiple entries for the same name
            if not isinstance(value, list):
                value = [value]
            for value in value:
                if isinstance(value, tuple):
                    fn = ';filename="%s"' % value[0]
                    value = value[1]
                else:
                    fn = ""

                body.write(sep_boundary)
                body.write('\r\nContent-Disposition: form-data; name="%s"' % key)
                body.write(fn)
                body.write("\r\n\r\n")
                body.write(value)
                if value and value[-1] == '\r':
                    body.write('\n')  # write an extra newline (lurve Macs)
        body.write(end_boundary)
        body = body.getvalue()

        self.announce("Submitting %s to %s" % (filename, self.repository), log.INFO)

        # build the Request
        headers = {'Content-type':
                        'multipart/form-data; boundary=%s' % boundary,
                   'Content-length': str(len(body)),
                   'Authorization': auth}

        request = Request(self.repository, data=body,
                          headers=headers)
        # send the data
        try:
            result = urlopen(request)
            status = result.getcode()
            reason = result.msg
            if self.show_response:
                msg = '\n'.join(('-' * 75, result.read(), '-' * 75))
                self.announce(msg, log.INFO)
        except socket.error, e:
            self.announce(str(e), log.ERROR)
            raise
        except HTTPError, e:
            status = e.code
            reason = e.msg

        if status == 200:
            self.announce('Server response (%s): %s' % (status, reason),
                          log.INFO)
        else:
            msg = 'Upload failed (%s): %s' % (status, reason)
            self.announce(msg, log.ERROR)
            raise DistutilsError(msg)
                                                                                                                           usr/lib/python2.7/distutils/command/upload.pyc                                                      0100644 0000000 0000000 00000014243 13077704274 020056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sﬁ   d  Z  d d l Z d d l Z d d l Z d d l m Z m Z m Z d d l m	 Z	 d d l
 Z
 d d l Z d d l m Z d d l m Z m Z d d l m Z d d l m Z d d	 l m Z d
 e f d Ñ  É  YZ d S(   s`   distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI).iˇˇˇˇN(   t   urlopent   Requestt	   HTTPError(   t   standard_b64encode(   t   md5(   t   DistutilsErrort   DistutilsOptionError(   t   PyPIRCCommand(   t   spawn(   t   logt   uploadc           B   sU   e  Z d  Z e j d d g Z e j d g Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z	 RS(   s   upload binary package to PyPIt   signt   ss   sign files to upload using gpgs	   identity=t   is   GPG identity used to sign filesc         C   s>   t  j |  É d |  _ d |  _ d |  _ t |  _ d  |  _ d  S(   Nt    i    (	   R   t   initialize_optionst   usernamet   passwordt   show_responset   FalseR   t   Nonet   identity(   t   self(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR      s    				c         C   s™   t  j |  É |  j r/ |  j r/ t d É Ç n  |  j É  } | i  k r~ | d |  _ | d |  _ | d |  _ | d |  _	 n  |  j r¶ |  j
 j r¶ |  j
 j |  _ n  d  S(   Ns.   Must use --sign for --identity to have meaningR   R   t
   repositoryt   realm(   R   t   finalize_optionsR   R   R   t   _read_pypircR   R   R   R   t   distribution(   R   t   config(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR   &   s    c         C   sR   |  j  j s t d É Ç n  x0 |  j  j D]" \ } } } |  j | | | É q( Wd  S(   Ns'   No dist file created in earlier command(   R   t
   dist_filesR   t   upload_file(   R   t   commandt	   pyversiont   filename(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyt   run8   s    c   "      C   sÜ  t  j  |  j É \ } } } } } }	 | s6 | s6 |	 rL t d |  j É Ç n  | dG k rk t d | É Ç n  |  j ræ d d d | g }
 |  j r® d |  j g |
 d	 d	 +n  t |
 d
 |  j Én  t | d É } z | j É  } Wd  | j	 É  X|  j
 j } i d d 6d d 6| j É  d 6| j É  d 6t j j | É | f d 6| d 6| d 6t | É j É  d 6d d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d  6| j É  d! 6| j É  d" 6| j É  d# 6| j É  d$ 6} d% } | d& k rRt  j! É  \ } } } | rwd' | | f } qwn% | d( k rwd) t  j  d* d+ É } n  | | d, <|  j rΩt j j | É d- t | d- É j É  f | d. <n  d/ t" |  j# d0 |  j$ É } d1 } d2 | } | d3 } t% j% É  } x· | j& É  D]” \ } } t' | t( É s5| g } n  x© | D]° } t' | t) É rld4 | d5 } | d+ } n d% } | j* | É | j* d6 | É | j* | É | j* d7 É | j* | É | r<| d8 d9 k r<| j* d: É q<q<WqW| j* | É | j+ É  } |  j, d; | |  j f t- j. É i d< | d= 6t/ t0 | É É d> 6| d? 6} t1 |  j d@ | dA | É} yj t2 | É } | j3 É  } | j4 } |  j5 rÕd: j6 dB dC | j É  dB dC f É }  |  j, |  t- j. É n  WnV t7 j8 k
 r}! |  j, t/ |! É t- j9 É Ç  n% t: k
 r&}! |! j; } |! j4 } n X| dD k rS|  j, dE | | f t- j. É n/ dF | | f }  |  j, |  t- j9 É t< |  É Ç d  S(H   Ns   Incompatible url %st   httpt   httpss   unsupported schema t   gpgs   --detach-signs   -as   --local-useri   t   dry_runt   rbt   file_uploads   :actiont   1t   protcol_versiont   namet   versiont   contentt   filetypeR    t
   md5_digests   1.0t   metadata_versiont   summaryt	   home_paget   authort   author_emailt   licenset   descriptiont   keywordst   platformt   classifierst   download_urlt   providest   requirest	   obsoletesR   t	   bdist_rpms   built for %s %st
   bdist_dumbs   built for %st   tersei   t   comments   .asct   gpg_signatures   Basic t   :s3   --------------GHSKFJDLGDS7543FJKLFHRE75642756743254s   
--s   --
s   ;filename="%s"i    s+   
Content-Disposition: form-data; name="%s"s   

iˇˇˇˇs   s   
s   Submitting %s to %ss    multipart/form-data; boundary=%ss   Content-types   Content-lengtht   Authorizationt   datat   headerst   -iK   i»   s   Server response (%s): %ss   Upload failed (%s): %s(   R#   R$   (=   t   urlparseR   t   AssertionErrorR   R   R   R&   t   opent   readt   closeR   t   metadatat   get_namet   get_versiont   ost   patht   basenameR   t	   hexdigestt   get_descriptiont   get_urlt   get_contactt   get_contact_emailt   get_licencet   get_long_descriptiont   get_keywordst   get_platformst   get_classifierst   get_download_urlt   get_providest   get_requirest   get_obsoletesR8   t   distR   R   R   t   StringIOt   itemst
   isinstancet   listt   tuplet   writet   getvaluet   announceR	   t   INFOt   strt   lenR   R    t   getcodet   msgR   t   joint   sockett   errort   ERRORR   t   codeR   ("   R   R   R    R!   t   schemat   netloct   urlt   paramst   queryt	   fragmentst   gpg_argst   fR-   t   metaRE   RA   Ra   R,   t   idt   autht   boundaryt   sep_boundaryt   end_boundaryt   bodyt   keyt   valuet   fnRF   t   requestt   resultt   statust   reasonRn   t   e(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR   >   s∆    $			
	 

 
			&	(   s   signR   s   sign files to upload using gpg(   s	   identity=R   s   GPG identity used to sign files(
   t   __name__t
   __module__R6   R   t   user_optionst   boolean_optionsR   R   R"   R   (    (    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR
      s    
			(   t   __doc__RP   Rp   R8   t   urllib2R    R   R   t   base64R   RH   t	   cStringIORb   t   hashlibR   t   distutils.errorsR   R   t   distutils.coreR   t   distutils.spawnR   t	   distutilsR	   R
   (    (    (    s.   /usr/lib/python2.7/distutils/command/upload.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                usr/lib/python2.7/distutils/config.py                                                               0100644 0000000 0000000 00000010043 12734733743 016252  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.pypirc

Provides the PyPIRCCommand class, the base class for the command classes
that uses .pypirc in the distutils.command package.
"""
import os
from ConfigParser import ConfigParser

from distutils.cmd import Command

DEFAULT_PYPIRC = """\
[distutils]
index-servers =
    pypi

[pypi]
username:%s
password:%s
"""

class PyPIRCCommand(Command):
    """Base command that knows how to handle the .pypirc file
    """
    DEFAULT_REPOSITORY = 'https://pypi.python.org/pypi'
    DEFAULT_REALM = 'pypi'
    repository = None
    realm = None

    user_options = [
        ('repository=', 'r',
         "url of repository [default: %s]" % \
            DEFAULT_REPOSITORY),
        ('show-response', None,
         'display full response text from server')]

    boolean_options = ['show-response']

    def _get_rc_file(self):
        """Returns rc file path."""
        return os.path.join(os.path.expanduser('~'), '.pypirc')

    def _store_pypirc(self, username, password):
        """Creates a default .pypirc file."""
        rc = self._get_rc_file()
        f = os.fdopen(os.open(rc, os.O_CREAT | os.O_WRONLY, 0600), 'w')
        try:
            f.write(DEFAULT_PYPIRC % (username, password))
        finally:
            f.close()

    def _read_pypirc(self):
        """Reads the .pypirc file."""
        rc = self._get_rc_file()
        if os.path.exists(rc):
            self.announce('Using PyPI login from %s' % rc)
            repository = self.repository or self.DEFAULT_REPOSITORY
            config = ConfigParser()
            config.read(rc)
            sections = config.sections()
            if 'distutils' in sections:
                # let's get the list of servers
                index_servers = config.get('distutils', 'index-servers')
                _servers = [server.strip() for server in
                            index_servers.split('\n')
                            if server.strip() != '']
                if _servers == []:
                    # nothing set, let's try to get the default pypi
                    if 'pypi' in sections:
                        _servers = ['pypi']
                    else:
                        # the file is not properly defined, returning
                        # an empty dict
                        return {}
                for server in _servers:
                    current = {'server': server}
                    current['username'] = config.get(server, 'username')

                    # optional params
                    for key, default in (('repository',
                                          self.DEFAULT_REPOSITORY),
                                         ('realm', self.DEFAULT_REALM),
                                         ('password', None)):
                        if config.has_option(server, key):
                            current[key] = config.get(server, key)
                        else:
                            current[key] = default
                    if (current['server'] == repository or
                        current['repository'] == repository):
                        return current
            elif 'server-login' in sections:
                # old format
                server = 'server-login'
                if config.has_option(server, 'repository'):
                    repository = config.get(server, 'repository')
                else:
                    repository = self.DEFAULT_REPOSITORY
                return {'username': config.get(server, 'username'),
                        'password': config.get(server, 'password'),
                        'repository': repository,
                        'server': server,
                        'realm': self.DEFAULT_REALM}

        return {}

    def initialize_options(self):
        """Initialize options."""
        self.repository = None
        self.realm = None
        self.show_response = 0

    def finalize_options(self):
        """Finalizes options."""
        if self.repository is None:
            self.repository = self.DEFAULT_REPOSITORY
        if self.realm is None:
            self.realm = self.DEFAULT_REALM
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python2.7/distutils/config.pyc                                                              0100644 0000000 0000000 00000006744 13077704274 016430  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sR   d  Z  d d l Z d d l m Z d d l m Z d Z d e f d Ñ  É  YZ d S(   sè   distutils.pypirc

Provides the PyPIRCCommand class, the base class for the command classes
that uses .pypirc in the distutils.command package.
iˇˇˇˇN(   t   ConfigParser(   t   CommandsE   [distutils]
index-servers =
    pypi

[pypi]
username:%s
password:%s
t   PyPIRCCommandc           B   su   e  Z d  Z d Z d Z d Z d Z d d d e f d g Z d g Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z RS(   s;   Base command that knows how to handle the .pypirc file
    s   https://pypi.python.org/pypit   pypis   repository=t   rs   url of repository [default: %s]s   show-responses&   display full response text from serverc         C   s   t  j j t  j j d É d É S(   s   Returns rc file path.t   ~s   .pypirc(   t   ost   patht   joint
   expanduser(   t   self(    (    s&   /usr/lib/python2.7/distutils/config.pyt   _get_rc_file&   s    c         C   sd   |  j  É  } t j t j | t j t j Bd É d É } z | j t | | f É Wd | j É  Xd S(   s   Creates a default .pypirc file.iÄ  t   wN(	   R   R   t   fdopent   opent   O_CREATt   O_WRONLYt   writet   DEFAULT_PYPIRCt   close(   R
   t   usernamet   passwordt   rct   f(    (    s&   /usr/lib/python2.7/distutils/config.pyt   _store_pypirc*   s
    +c         C   s3  |  j  É  } t j j | É r/|  j d | É |  j p> |  j } t É  } | j | É | j	 É  } d | k r®| j
 d d É } g  | j d É D]$ } | j É  d k rë | j É  ^ që } | g  k rÊ d | k rﬂ d g } qÊ i  Sn  xC| D]¥ } i | d 6} | j
 | d É | d <xd d	 |  j f d
 |  j f d f D]A \ }	 }
 | j | |	 É ro| j
 | |	 É | |	 <q8|
 | |	 <q8W| d | k sù| d	 | k rÌ | SqÌ Wq/d | k r/d } | j | d	 É r·| j
 | d	 É } n	 |  j } i | j
 | d É d 6| j
 | d É d 6| d	 6| d 6|  j d
 6Sn  i  S(   s   Reads the .pypirc file.s   Using PyPI login from %st	   distutilss   index-serverss   
t    R   t   serverR   t
   repositoryt   realmR   s   server-loginN(   s   passwordN(   R   R   R   t   existst   announceR   t   DEFAULT_REPOSITORYR    t   readt   sectionst   gett   splitt   stript   DEFAULT_REALMt   Nonet
   has_option(   R
   R   R   t   configR"   t   index_serversR   t   _serverst   currentt   keyt   default(    (    s&   /usr/lib/python2.7/distutils/config.pyt   _read_pypirc3   sP    	$		c         C   s   d |  _ d |  _ d |  _ d S(   s   Initialize options.i    N(   R'   R   R   t   show_response(   R
   (    (    s&   /usr/lib/python2.7/distutils/config.pyt   initialize_optionsi   s    		c         C   s@   |  j  d k r |  j |  _  n  |  j d k r< |  j |  _ n  d S(   s   Finalizes options.N(   R   R'   R    R   R&   (   R
   (    (    s&   /usr/lib/python2.7/distutils/config.pyt   finalize_optionso   s    N(   s   show-responseNs&   display full response text from server(   t   __name__t
   __module__t   __doc__R    R&   R'   R   R   t   user_optionst   boolean_optionsR   R   R/   R1   R2   (    (    (    s&   /usr/lib/python2.7/distutils/config.pyR      s     						6	(   R5   R   R    t   distutils.cmdR   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/config.pyt   <module>   s
   
                            usr/lib/python2.7/distutils/core.py                                                                 0100644 0000000 0000000 00000021473 12734733743 015746  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.core

The only module that needs to be imported to use the Distutils; provides
the 'setup' function (which is to be called from the setup script).  Also
indirectly provides the Distribution and Command classes, although they are
really defined in distutils.dist and distutils.cmd.
"""

__revision__ = "$Id$"

import sys
import os

from distutils.debug import DEBUG
from distutils.errors import (DistutilsSetupError, DistutilsArgError,
                              DistutilsError, CCompilerError)

# Mainly import these so setup scripts can "from distutils.core import" them.
from distutils.dist import Distribution
from distutils.cmd import Command
from distutils.config import PyPIRCCommand
from distutils.extension import Extension

# This is a barebones help message generated displayed when the user
# runs the setup script with no arguments at all.  More useful help
# is generated with various --help options: global help, list commands,
# and per-command help.
USAGE = """\
usage: %(script)s [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: %(script)s --help [cmd1 cmd2 ...]
   or: %(script)s --help-commands
   or: %(script)s cmd --help
"""

def gen_usage(script_name):
    script = os.path.basename(script_name)
    return USAGE % {'script': script}


# Some mild magic to control the behaviour of 'setup()' from 'run_setup()'.
_setup_stop_after = None
_setup_distribution = None

# Legal keyword arguments for the setup() function
setup_keywords = ('distclass', 'script_name', 'script_args', 'options',
                  'name', 'version', 'author', 'author_email',
                  'maintainer', 'maintainer_email', 'url', 'license',
                  'description', 'long_description', 'keywords',
                  'platforms', 'classifiers', 'download_url',
                  'requires', 'provides', 'obsoletes',
                  )

# Legal keyword arguments for the Extension constructor
extension_keywords = ('name', 'sources', 'include_dirs',
                      'define_macros', 'undef_macros',
                      'library_dirs', 'libraries', 'runtime_library_dirs',
                      'extra_objects', 'extra_compile_args', 'extra_link_args',
                      'swig_opts', 'export_symbols', 'depends', 'language')

def setup(**attrs):
    """The gateway to the Distutils: do everything your setup script needs
    to do, in a highly flexible and user-driven way.  Briefly: create a
    Distribution instance; find and parse config files; parse the command
    line; run each Distutils command found there, customized by the options
    supplied to 'setup()' (as keyword arguments), in config files, and on
    the command line.

    The Distribution instance might be an instance of a class supplied via
    the 'distclass' keyword argument to 'setup'; if no such class is
    supplied, then the Distribution class (in dist.py) is instantiated.
    All other arguments to 'setup' (except for 'cmdclass') are used to set
    attributes of the Distribution instance.

    The 'cmdclass' argument, if supplied, is a dictionary mapping command
    names to command classes.  Each command encountered on the command line
    will be turned into a command class, which is in turn instantiated; any
    class found in 'cmdclass' is used in place of the default, which is
    (for command 'foo_bar') class 'foo_bar' in module
    'distutils.command.foo_bar'.  The command class must provide a
    'user_options' attribute which is a list of option specifiers for
    'distutils.fancy_getopt'.  Any command-line options between the current
    and the next command are used to set attributes of the current command
    object.

    When the entire command-line has been successfully parsed, calls the
    'run()' method on each command object in turn.  This method will be
    driven entirely by the Distribution object (which each command object
    has a reference to, thanks to its constructor), and the
    command-specific options that became attributes of each command
    object.
    """

    global _setup_stop_after, _setup_distribution

    # Determine the distribution class -- either caller-supplied or
    # our Distribution (see below).
    klass = attrs.get('distclass')
    if klass:
        del attrs['distclass']
    else:
        klass = Distribution

    if 'script_name' not in attrs:
        attrs['script_name'] = os.path.basename(sys.argv[0])
    if 'script_args' not in attrs:
        attrs['script_args'] = sys.argv[1:]

    # Create the Distribution instance, using the remaining arguments
    # (ie. everything except distclass) to initialize it
    try:
        _setup_distribution = dist = klass(attrs)
    except DistutilsSetupError, msg:
        if 'name' in attrs:
            raise SystemExit, "error in %s setup command: %s" % \
                  (attrs['name'], msg)
        else:
            raise SystemExit, "error in setup command: %s" % msg

    if _setup_stop_after == "init":
        return dist

    # Find and parse the config file(s): they will override options from
    # the setup script, but be overridden by the command line.
    dist.parse_config_files()

    if DEBUG:
        print "options (after parsing config files):"
        dist.dump_option_dicts()

    if _setup_stop_after == "config":
        return dist

    # Parse the command line and override config files; any
    # command-line errors are the end user's fault, so turn them into
    # SystemExit to suppress tracebacks.
    try:
        ok = dist.parse_command_line()
    except DistutilsArgError, msg:
        raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg

    if DEBUG:
        print "options (after parsing command line):"
        dist.dump_option_dicts()

    if _setup_stop_after == "commandline":
        return dist

    # And finally, run all the commands found on the command line.
    if ok:
        try:
            dist.run_commands()
        except KeyboardInterrupt:
            raise SystemExit, "interrupted"
        except (IOError, os.error), exc:
            if DEBUG:
                sys.stderr.write("error: %s\n" % (exc,))
                raise
            else:
                raise SystemExit, "error: %s" % (exc,)

        except (DistutilsError,
                CCompilerError), msg:
            if DEBUG:
                raise
            else:
                raise SystemExit, "error: " + str(msg)

    return dist


def run_setup(script_name, script_args=None, stop_after="run"):
    """Run a setup script in a somewhat controlled environment, and
    return the Distribution instance that drives things.  This is useful
    if you need to find out the distribution meta-data (passed as
    keyword args from 'script' to 'setup()', or the contents of the
    config files or command-line.

    'script_name' is a file that will be run with 'execfile()';
    'sys.argv[0]' will be replaced with 'script' for the duration of the
    call.  'script_args' is a list of strings; if supplied,
    'sys.argv[1:]' will be replaced by 'script_args' for the duration of
    the call.

    'stop_after' tells 'setup()' when to stop processing; possible
    values:
      init
        stop after the Distribution instance has been created and
        populated with the keyword arguments to 'setup()'
      config
        stop after config files have been parsed (and their data
        stored in the Distribution instance)
      commandline
        stop after the command-line ('sys.argv[1:]' or 'script_args')
        have been parsed (and the data stored in the Distribution)
      run [default]
        stop after all commands have been run (the same as if 'setup()'
        had been called in the usual way

    Returns the Distribution instance, which provides all information
    used to drive the Distutils.
    """
    if stop_after not in ('init', 'config', 'commandline', 'run'):
        raise ValueError, "invalid value for 'stop_after': %r" % (stop_after,)

    global _setup_stop_after, _setup_distribution
    _setup_stop_after = stop_after

    save_argv = sys.argv
    g = {'__file__': script_name}
    l = {}
    try:
        try:
            sys.argv[0] = script_name
            if script_args is not None:
                sys.argv[1:] = script_args
            f = open(script_name)
            try:
                exec f.read() in g, l
            finally:
                f.close()
        finally:
            sys.argv = save_argv
            _setup_stop_after = None
    except SystemExit:
        # Hmm, should we do something if exiting with a non-zero code
        # (ie. error)?
        pass
    except:
        raise

    if _setup_distribution is None:
        raise RuntimeError, \
              ("'distutils.core.setup()' was never called -- "
               "perhaps '%s' is not a Distutils setup script?") % \
              script_name

    # I wonder if the setup script's namespace -- g and l -- would be of
    # any interest to callers?
    return _setup_distribution
                                                                                                                                                                                                     usr/lib/python2.7/distutils/core.pyc                                                                0100644 0000000 0000000 00000016653 13077704274 016113  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sŸ   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 d d l m Z d d l m Z d d l m Z d d	 l m Z d
 Z d Ñ  Z d a d a d2 Z d3 Z d/ Ñ  Z d d0 d1 Ñ Z d S(4   s#  distutils.core

The only module that needs to be imported to use the Distutils; provides
the 'setup' function (which is to be called from the setup script).  Also
indirectly provides the Distribution and Command classes, although they are
really defined in distutils.dist and distutils.cmd.
s   $Id$iˇˇˇˇN(   t   DEBUG(   t   DistutilsSetupErrort   DistutilsArgErrort   DistutilsErrort   CCompilerError(   t   Distribution(   t   Command(   t   PyPIRCCommand(   t	   Extensions∞   usage: %(script)s [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: %(script)s --help [cmd1 cmd2 ...]
   or: %(script)s --help-commands
   or: %(script)s cmd --help
c         C   s!   t  j j |  É } t i | d 6S(   Nt   script(   t   ost   patht   basenamet   USAGE(   t   script_nameR	   (    (    s$   /usr/lib/python2.7/distutils/core.pyt	   gen_usage#   s    t	   distclassR   t   script_argst   optionst   namet   versiont   authort   author_emailt
   maintainert   maintainer_emailt   urlt   licenset   descriptiont   long_descriptiont   keywordst	   platformst   classifierst   download_urlt   requirest   providest	   obsoletest   sourcest   include_dirst   define_macrost   undef_macrost   library_dirst	   librariest   runtime_library_dirst   extra_objectst   extra_compile_argst   extra_link_argst	   swig_optst   export_symbolst   dependst   languagec          K   s5  |  j  d É } | r |  d =n t } d |  k rQ t j j t j d É |  d <n  d |  k rq t j d |  d <n  y | |  É a } WnF t k
 rÕ } d |  k rΩ t	 d |  d | f Ç qŒ t	 d | Ç n Xt
 d	 k rﬁ | S| j É  t r d
 GH| j É  n  t
 d k r| Sy | j É  } Wn- t k
 rO} t	 t | j É d | Ç n Xt rhd GH| j É  n  t
 d k rx| S| r1y | j É  Wq1t k
 r®t	 d Ç q1t t j f k
 rˆ} t r„t j j d | f É Ç  q.t	 d | f Ç q1t t f k
 r-} t rÇ  q.t	 d t | É Ç q1Xn  | S(   sÃ  The gateway to the Distutils: do everything your setup script needs
    to do, in a highly flexible and user-driven way.  Briefly: create a
    Distribution instance; find and parse config files; parse the command
    line; run each Distutils command found there, customized by the options
    supplied to 'setup()' (as keyword arguments), in config files, and on
    the command line.

    The Distribution instance might be an instance of a class supplied via
    the 'distclass' keyword argument to 'setup'; if no such class is
    supplied, then the Distribution class (in dist.py) is instantiated.
    All other arguments to 'setup' (except for 'cmdclass') are used to set
    attributes of the Distribution instance.

    The 'cmdclass' argument, if supplied, is a dictionary mapping command
    names to command classes.  Each command encountered on the command line
    will be turned into a command class, which is in turn instantiated; any
    class found in 'cmdclass' is used in place of the default, which is
    (for command 'foo_bar') class 'foo_bar' in module
    'distutils.command.foo_bar'.  The command class must provide a
    'user_options' attribute which is a list of option specifiers for
    'distutils.fancy_getopt'.  Any command-line options between the current
    and the next command are used to set attributes of the current command
    object.

    When the entire command-line has been successfully parsed, calls the
    'run()' method on each command object in turn.  This method will be
    driven entirely by the Distribution object (which each command object
    has a reference to, thanks to its constructor), and the
    command-specific options that became attributes of each command
    object.
    R   R   i    R   i   R   s   error in %s setup command: %ss   error in setup command: %st   inits%   options (after parsing config files):t   configs
   
error: %ss%   options (after parsing command line):t   commandlinet   interrupteds
   error: %s
s	   error: %ss   error: (   t   getR   R
   R   R   t   syst   argvt   _setup_distributionR   t
   SystemExitt   _setup_stop_aftert   parse_config_filesR    t   dump_option_dictst   parse_command_lineR   R   R   t   run_commandst   KeyboardInterruptt   IOErrort   errort   stderrt   writeR   R   t   str(   t   attrst   klasst   distt   msgt   okt   exc(    (    s$   /usr/lib/python2.7/distutils/core.pyt   setup<   s`    %
 
t   runc         B   s   | d k r e  d | f Ç n  | a e j } i |  d 6} i  } yr z[ |  e j d <| d	 k	 rp | e j d )n  e |  É } z | j É  | | UWd	 | j É  XWd	 | e _ d	 a XWn e k
 r∆ n
 Ç  n Xt	 d	 k rÏ e
 d
 |  Ç n  t	 S(   s)  Run a setup script in a somewhat controlled environment, and
    return the Distribution instance that drives things.  This is useful
    if you need to find out the distribution meta-data (passed as
    keyword args from 'script' to 'setup()', or the contents of the
    config files or command-line.

    'script_name' is a file that will be run with 'execfile()';
    'sys.argv[0]' will be replaced with 'script' for the duration of the
    call.  'script_args' is a list of strings; if supplied,
    'sys.argv[1:]' will be replaced by 'script_args' for the duration of
    the call.

    'stop_after' tells 'setup()' when to stop processing; possible
    values:
      init
        stop after the Distribution instance has been created and
        populated with the keyword arguments to 'setup()'
      config
        stop after config files have been parsed (and their data
        stored in the Distribution instance)
      commandline
        stop after the command-line ('sys.argv[1:]' or 'script_args')
        have been parsed (and the data stored in the Distribution)
      run [default]
        stop after all commands have been run (the same as if 'setup()'
        had been called in the usual way

    Returns the Distribution instance, which provides all information
    used to drive the Distutils.
    R2   R3   R4   RM   s"   invalid value for 'stop_after': %rt   __file__i    i   NsZ   'distutils.core.setup()' was never called -- perhaps '%s' is not a Distutils setup script?(   s   inits   configs   commandlineRM   (   t
   ValueErrorR;   R7   R8   t   Nonet   opent   readt   closeR:   R9   t   RuntimeError(   R   R   t
   stop_aftert	   save_argvt   gt   lt   f(    (    s$   /usr/lib/python2.7/distutils/core.pyt	   run_setup´   s4    		
(   s	   distclasss   script_names   script_argsR   s   names   versionR   R   R   R   R   R   R   R   R   R   R   R    R!   R"   R#   (   s   nameR$   R%   R&   R'   R(   R)   R*   R+   R,   R-   R.   R/   R0   R1   (   t   __doc__t   __revision__R7   R
   t   distutils.debugR    t   distutils.errorsR   R   R   R   t   distutils.distR   t   distutils.cmdR   t   distutils.configR   t   distutils.extensionR   R   R   RP   R;   R9   t   setup_keywordst   extension_keywordsRL   RZ   (    (    (    s$   /usr/lib/python2.7/distutils/core.pyt   <module>   s4   "	         	o                                                                                     usr/lib/python2.7/distutils/cygwinccompiler.py                                                      0100644 0000000 0000000 00000042504 12734733743 020212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.cygwinccompiler

Provides the CygwinCCompiler class, a subclass of UnixCCompiler that
handles the Cygwin port of the GNU C compiler to Windows.  It also contains
the Mingw32CCompiler class which handles the mingw32 port of GCC (same as
cygwin in no-cygwin mode).
"""

# problems:
#
# * if you use a msvc compiled python version (1.5.2)
#   1. you have to insert a __GNUC__ section in its config.h
#   2. you have to generate a import library for its dll
#      - create a def-file for python??.dll
#      - create a import library using
#             dlltool --dllname python15.dll --def python15.def \
#                       --output-lib libpython15.a
#
#   see also http://starship.python.net/crew/kernr/mingw32/Notes.html
#
# * We put export_symbols in a def-file, and don't use
#   --export-all-symbols because it doesn't worked reliable in some
#   tested configurations. And because other windows compilers also
#   need their symbols specified this no serious problem.
#
# tested configurations:
#
# * cygwin gcc 2.91.57/ld 2.9.4/dllwrap 0.2.4 works
#   (after patching python's config.h and for C++ some other include files)
#   see also http://starship.python.net/crew/kernr/mingw32/Notes.html
# * mingw32 gcc 2.95.2/ld 2.9.4/dllwrap 0.2.4 works
#   (ld doesn't support -shared, so we use dllwrap)
# * cygwin gcc 2.95.2/ld 2.10.90/dllwrap 2.10.90 works now
#   - its dllwrap doesn't work, there is a bug in binutils 2.10.90
#     see also http://sources.redhat.com/ml/cygwin/2000-06/msg01274.html
#   - using gcc -mdll instead dllwrap doesn't work without -static because
#     it tries to link against dlls instead their import libraries. (If
#     it finds the dll first.)
#     By specifying -static we force ld to link against the import libraries,
#     this is windows standard and there are normally not the necessary symbols
#     in the dlls.
#   *** only the version of June 2000 shows these problems
# * cygwin gcc 3.2/ld 2.13.90 works
#   (ld supports -shared)
# * mingw gcc 3.2/ld 2.13 works
#   (ld supports -shared)

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import os,sys,copy
from distutils.ccompiler import gen_preprocess_options, gen_lib_options
from distutils.unixccompiler import UnixCCompiler
from distutils.file_util import write_file
from distutils.errors import DistutilsExecError, CompileError, UnknownFileError
from distutils import log

def get_msvcr():
    """Include the appropriate MSVC runtime library if Python was built
    with MSVC 7.0 or later.
    """
    msc_pos = sys.version.find('MSC v.')
    if msc_pos != -1:
        msc_ver = sys.version[msc_pos+6:msc_pos+10]
        if msc_ver == '1300':
            # MSVC 7.0
            return ['msvcr70']
        elif msc_ver == '1310':
            # MSVC 7.1
            return ['msvcr71']
        elif msc_ver == '1400':
            # VS2005 / MSVC 8.0
            return ['msvcr80']
        elif msc_ver == '1500':
            # VS2008 / MSVC 9.0
            return ['msvcr90']
        else:
            raise ValueError("Unknown MS Compiler version %s " % msc_ver)


class CygwinCCompiler (UnixCCompiler):

    compiler_type = 'cygwin'
    obj_extension = ".o"
    static_lib_extension = ".a"
    shared_lib_extension = ".dll"
    static_lib_format = "lib%s%s"
    shared_lib_format = "%s%s"
    exe_extension = ".exe"

    def __init__ (self, verbose=0, dry_run=0, force=0):

        UnixCCompiler.__init__ (self, verbose, dry_run, force)

        (status, details) = check_config_h()
        self.debug_print("Python's GCC status: %s (details: %s)" %
                         (status, details))
        if status is not CONFIG_H_OK:
            self.warn(
                "Python's pyconfig.h doesn't seem to support your compiler. "
                "Reason: %s. "
                "Compiling may fail because of undefined preprocessor macros."
                % details)

        self.gcc_version, self.ld_version, self.dllwrap_version = \
            get_versions()
        self.debug_print(self.compiler_type + ": gcc %s, ld %s, dllwrap %s\n" %
                         (self.gcc_version,
                          self.ld_version,
                          self.dllwrap_version) )

        # ld_version >= "2.10.90" and < "2.13" should also be able to use
        # gcc -mdll instead of dllwrap
        # Older dllwraps had own version numbers, newer ones use the
        # same as the rest of binutils ( also ld )
        # dllwrap 2.10.90 is buggy
        if self.ld_version >= "2.10.90":
            self.linker_dll = "gcc"
        else:
            self.linker_dll = "dllwrap"

        # ld_version >= "2.13" support -shared so use it instead of
        # -mdll -static
        if self.ld_version >= "2.13":
            shared_option = "-shared"
        else:
            shared_option = "-mdll -static"

        # Hard-code GCC because that's what this is all about.
        # XXX optimization, warnings etc. should be customizable.
        self.set_executables(compiler='gcc -mcygwin -O -Wall',
                             compiler_so='gcc -mcygwin -mdll -O -Wall',
                             compiler_cxx='g++ -mcygwin -O -Wall',
                             linker_exe='gcc -mcygwin',
                             linker_so=('%s -mcygwin %s' %
                                        (self.linker_dll, shared_option)))

        # cygwin and mingw32 need different sets of libraries
        if self.gcc_version == "2.91.57":
            # cygwin shouldn't need msvcrt, but without the dlls will crash
            # (gcc version 2.91.57) -- perhaps something about initialization
            self.dll_libraries=["msvcrt"]
            self.warn(
                "Consider upgrading to a newer version of gcc")
        else:
            # Include the appropriate MSVC runtime library if Python was built
            # with MSVC 7.0 or later.
            self.dll_libraries = get_msvcr()

    # __init__ ()


    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        if ext == '.rc' or ext == '.res':
            # gcc needs '.res' and '.rc' compiled to object files !!!
            try:
                self.spawn(["windres", "-i", src, "-o", obj])
            except DistutilsExecError, msg:
                raise CompileError, msg
        else: # for other files use the C-compiler
            try:
                self.spawn(self.compiler_so + cc_args + [src, '-o', obj] +
                           extra_postargs)
            except DistutilsExecError, msg:
                raise CompileError, msg

    def link (self,
              target_desc,
              objects,
              output_filename,
              output_dir=None,
              libraries=None,
              library_dirs=None,
              runtime_library_dirs=None,
              export_symbols=None,
              debug=0,
              extra_preargs=None,
              extra_postargs=None,
              build_temp=None,
              target_lang=None):

        # use separate copies, so we can modify the lists
        extra_preargs = copy.copy(extra_preargs or [])
        libraries = copy.copy(libraries or [])
        objects = copy.copy(objects or [])

        # Additional libraries
        libraries.extend(self.dll_libraries)

        # handle export symbols by creating a def-file
        # with executables this only works with gcc/ld as linker
        if ((export_symbols is not None) and
            (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):
            # (The linker doesn't do anything if output is up-to-date.
            # So it would probably better to check if we really need this,
            # but for this we had to insert some unchanged parts of
            # UnixCCompiler, and this is not what we want.)

            # we want to put some files in the same directory as the
            # object files are, build_temp doesn't help much
            # where are the object files
            temp_dir = os.path.dirname(objects[0])
            # name of dll to give the helper files the same base name
            (dll_name, dll_extension) = os.path.splitext(
                os.path.basename(output_filename))

            # generate the filenames for these files
            def_file = os.path.join(temp_dir, dll_name + ".def")
            lib_file = os.path.join(temp_dir, 'lib' + dll_name + ".a")

            # Generate .def file
            contents = [
                "LIBRARY %s" % os.path.basename(output_filename),
                "EXPORTS"]
            for sym in export_symbols:
                contents.append(sym)
            self.execute(write_file, (def_file, contents),
                         "writing %s" % def_file)

            # next add options for def-file and to creating import libraries

            # dllwrap uses different options than gcc/ld
            if self.linker_dll == "dllwrap":
                extra_preargs.extend(["--output-lib", lib_file])
                # for dllwrap we have to use a special option
                extra_preargs.extend(["--def", def_file])
            # we use gcc/ld here and can be sure ld is >= 2.9.10
            else:
                # doesn't work: bfd_close build\...\libfoo.a: Invalid operation
                #extra_preargs.extend(["-Wl,--out-implib,%s" % lib_file])
                # for gcc/ld the def-file is specified as any object files
                objects.append(def_file)

        #end: if ((export_symbols is not None) and
        #        (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):

        # who wants symbols and a many times larger output file
        # should explicitly switch the debug mode on
        # otherwise we let dllwrap/ld strip the output file
        # (On my machine: 10KB < stripped_file < ??100KB
        #   unstripped_file = stripped_file + XXX KB
        #  ( XXX=254 for a typical python extension))
        if not debug:
            extra_preargs.append("-s")

        UnixCCompiler.link(self,
                           target_desc,
                           objects,
                           output_filename,
                           output_dir,
                           libraries,
                           library_dirs,
                           runtime_library_dirs,
                           None, # export_symbols, we do this in our def-file
                           debug,
                           extra_preargs,
                           extra_postargs,
                           build_temp,
                           target_lang)

    # link ()

    # -- Miscellaneous methods -----------------------------------------

    # overwrite the one from CCompiler to support rc and res-files
    def object_filenames (self,
                          source_filenames,
                          strip_dir=0,
                          output_dir=''):
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
            (base, ext) = os.path.splitext (os.path.normcase(src_name))
            if ext not in (self.src_extensions + ['.rc','.res']):
                raise UnknownFileError, \
                      "unknown file type '%s' (from '%s')" % \
                      (ext, src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext == '.res' or ext == '.rc':
                # these need to be compiled to object files
                obj_names.append (os.path.join (output_dir,
                                            base + ext + self.obj_extension))
            else:
                obj_names.append (os.path.join (output_dir,
                                            base + self.obj_extension))
        return obj_names

    # object_filenames ()

# class CygwinCCompiler


# the same as cygwin plus some additional parameters
class Mingw32CCompiler (CygwinCCompiler):

    compiler_type = 'mingw32'

    def __init__ (self,
                  verbose=0,
                  dry_run=0,
                  force=0):

        CygwinCCompiler.__init__ (self, verbose, dry_run, force)

        # ld_version >= "2.13" support -shared so use it instead of
        # -mdll -static
        if self.ld_version >= "2.13":
            shared_option = "-shared"
        else:
            shared_option = "-mdll -static"

        # A real mingw32 doesn't need to specify a different entry point,
        # but cygwin 2.91.57 in no-cygwin-mode needs it.
        if self.gcc_version <= "2.91.57":
            entry_point = '--entry _DllMain@12'
        else:
            entry_point = ''

        if self.gcc_version < '4' or is_cygwingcc():
            no_cygwin = ' -mno-cygwin'
        else:
            no_cygwin = ''

        self.set_executables(compiler='gcc%s -O -Wall' % no_cygwin,
                             compiler_so='gcc%s -mdll -O -Wall' % no_cygwin,
                             compiler_cxx='g++%s -O -Wall' % no_cygwin,
                             linker_exe='gcc%s' % no_cygwin,
                             linker_so='%s%s %s %s'
                                    % (self.linker_dll, no_cygwin,
                                       shared_option, entry_point))
        # Maybe we should also append -mthreads, but then the finished
        # dlls need another dll (mingwm10.dll see Mingw32 docs)
        # (-mthreads: Support thread-safe exception handling on `Mingw32')

        # no additional libraries needed
        self.dll_libraries=[]

        # Include the appropriate MSVC runtime library if Python was built
        # with MSVC 7.0 or later.
        self.dll_libraries = get_msvcr()

    # __init__ ()

# class Mingw32CCompiler

# Because these compilers aren't configured in Python's pyconfig.h file by
# default, we should at least warn the user if he is using a unmodified
# version.

CONFIG_H_OK = "ok"
CONFIG_H_NOTOK = "not ok"
CONFIG_H_UNCERTAIN = "uncertain"

def check_config_h():

    """Check if the current Python installation (specifically, pyconfig.h)
    appears amenable to building extensions with GCC.  Returns a tuple
    (status, details), where 'status' is one of the following constants:
      CONFIG_H_OK
        all is well, go ahead and compile
      CONFIG_H_NOTOK
        doesn't look good
      CONFIG_H_UNCERTAIN
        not sure -- unable to read pyconfig.h
    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    """

    # XXX since this function also checks sys.version, it's not strictly a
    # "pyconfig.h" check -- should probably be renamed...

    from distutils import sysconfig
    import string
    # if sys.version contains GCC then python was compiled with
    # GCC, and the pyconfig.h file should be OK
    if string.find(sys.version,"GCC") >= 0:
        return (CONFIG_H_OK, "sys.version mentions 'GCC'")

    fn = sysconfig.get_config_h_filename()
    try:
        # It would probably better to read single lines to search.
        # But we do this only once, and it is fast enough
        f = open(fn)
        try:
            s = f.read()
        finally:
            f.close()

    except IOError, exc:
        # if we can't read this file, we cannot say it is wrong
        # the compiler will complain later about this file as missing
        return (CONFIG_H_UNCERTAIN,
                "couldn't read '%s': %s" % (fn, exc.strerror))

    else:
        # "pyconfig.h" contains an "#ifdef __GNUC__" or something similar
        if string.find(s,"__GNUC__") >= 0:
            return (CONFIG_H_OK, "'%s' mentions '__GNUC__'" % fn)
        else:
            return (CONFIG_H_NOTOK, "'%s' does not mention '__GNUC__'" % fn)



def get_versions():
    """ Try to find out the versions of gcc, ld and dllwrap.
        If not possible it returns None for it.
    """
    from distutils.version import LooseVersion
    from distutils.spawn import find_executable
    import re

    gcc_exe = find_executable('gcc')
    if gcc_exe:
        out = os.popen(gcc_exe + ' -dumpversion','r')
        out_string = out.read()
        out.close()
        result = re.search('(\d+\.\d+(\.\d+)*)',out_string)
        if result:
            gcc_version = LooseVersion(result.group(1))
        else:
            gcc_version = None
    else:
        gcc_version = None
    ld_exe = find_executable('ld')
    if ld_exe:
        out = os.popen(ld_exe + ' -v','r')
        out_string = out.read()
        out.close()
        result = re.search('(\d+\.\d+(\.\d+)*)',out_string)
        if result:
            ld_version = LooseVersion(result.group(1))
        else:
            ld_version = None
    else:
        ld_version = None
    dllwrap_exe = find_executable('dllwrap')
    if dllwrap_exe:
        out = os.popen(dllwrap_exe + ' --version','r')
        out_string = out.read()
        out.close()
        result = re.search(' (\d+\.\d+(\.\d+)*)',out_string)
        if result:
            dllwrap_version = LooseVersion(result.group(1))
        else:
            dllwrap_version = None
    else:
        dllwrap_version = None
    return (gcc_version, ld_version, dllwrap_version)

def is_cygwingcc():
    '''Try to determine if the gcc that would be used is from cygwin.'''
    out = os.popen('gcc -dumpmachine', 'r')
    out_string = out.read()
    out.close()
    # out_string is the target triplet cpu-vendor-os
    # Cygwin's gcc sets the os to 'cygwin'
    return out_string.strip().endswith('cygwin')
                                                                                                                                                                                            usr/lib/python2.7/distutils/cygwinccompiler.pyc                                                     0100644 0000000 0000000 00000023111 13077704274 020344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s¯   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z d d l m	 Z	 d d l
 m Z d d l m Z m Z m Z d d l m Z d	 Ñ  Z d
 e	 f d Ñ  É  YZ d e f d Ñ  É  YZ d Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d S(   s  distutils.cygwinccompiler

Provides the CygwinCCompiler class, a subclass of UnixCCompiler that
handles the Cygwin port of the GNU C compiler to Windows.  It also contains
the Mingw32CCompiler class which handles the mingw32 port of GCC (same as
cygwin in no-cygwin mode).
s   $Id$iˇˇˇˇN(   t   gen_preprocess_optionst   gen_lib_options(   t   UnixCCompiler(   t
   write_file(   t   DistutilsExecErrort   CompileErrort   UnknownFileError(   t   logc          C   sô   t  j j d É }  |  d k rï t  j |  d |  d !} | d k rI d g S| d k r\ d g S| d	 k ro d
 g S| d k rÇ d g St d | É Ç n  d S(   sa   Include the appropriate MSVC runtime library if Python was built
    with MSVC 7.0 or later.
    s   MSC v.iˇˇˇˇi   i
   t   1300t   msvcr70t   1310t   msvcr71t   1400t   msvcr80t   1500t   msvcr90s   Unknown MS Compiler version %s N(   t   syst   versiont   findt
   ValueError(   t   msc_post   msc_ver(    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyt	   get_msvcr;   s    t   CygwinCCompilerc           B   sÉ   e  Z d  Z d Z d Z d Z d Z d Z d Z d d d d Ñ Z	 d	 Ñ  Z
 d d d d d d d d d d d
 Ñ
 Z d d d Ñ Z RS(   t   cygwins   .os   .as   .dlls   lib%s%ss   %s%ss   .exei    c         C   sS  t  j |  | | | É t É  \ } } |  j d | | f É | t k	 r\ |  j d | É n  t É  \ |  _ |  _ |  _	 |  j |  j
 d |  j |  j |  j	 f É |  j d k rº d |  _ n	 d |  _ |  j d k r› d } n d	 } |  j d
 d d d d d d d d d |  j | f É |  j d k rCd g |  _ |  j d É n t É  |  _ d  S(   Ns%   Python's GCC status: %s (details: %s)sÉ   Python's pyconfig.h doesn't seem to support your compiler. Reason: %s. Compiling may fail because of undefined preprocessor macros.s   : gcc %s, ld %s, dllwrap %s
s   2.10.90t   gcct   dllwraps   2.13s   -shareds   -mdll -statict   compilers   gcc -mcygwin -O -Wallt   compiler_sos   gcc -mcygwin -mdll -O -Wallt   compiler_cxxs   g++ -mcygwin -O -Wallt
   linker_exes   gcc -mcygwint	   linker_sos   %s -mcygwin %ss   2.91.57t   msvcrts,   Consider upgrading to a newer version of gcc(   R   t   __init__t   check_config_ht   debug_printt   CONFIG_H_OKt   warnt   get_versionst   gcc_versiont
   ld_versiont   dllwrap_versiont   compiler_typet
   linker_dllt   set_executablest   dll_librariesR   (   t   selft   verboset   dry_runt   forcet   statust   detailst   shared_option(    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyR!   \   s<    			
c         C   s¶   | d k s | d k rZ y  |  j  d d | d | g É Wq¢ t k
 rV } t | Ç q¢ XnH y) |  j  |  j | | d | g | É Wn t k
 r° } t | Ç n Xd  S(   Ns   .rcs   .rest   windress   -is   -o(   t   spawnR   R   R   (   R.   t   objt   srct   extt   cc_argst   extra_postargst   pp_optst   msg(    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyt   _compileö   s     c         C   s÷  t  j  |
 p g  É }
 t  j  | p$ g  É } t  j  | p9 g  É } | j |  j É | d  k	 rà| |  j k sy |  j d k ràt j j | d É } t j j	 t j j
 | É É \ } } t j j | | d É } t j j | d | d É } d t j j
 | É d g } x | D] } | j | É qW|  j t | | f d | É |  j d	 k rx|
 j d
 | g É |
 j d | g É qà| j | É n  |	 sû|
 j d É n  t j |  | | | | | | | d  |	 |
 | | | É d  S(   NR   i    s   .deft   libs   .as
   LIBRARY %st   EXPORTSs
   writing %sR   s   --output-libs   --defs   -s(   t   copyt   extendR-   t   Nonet
   EXECUTABLER+   t   ost   patht   dirnamet   splitextt   basenamet   joint   appendt   executeR   R   t   link(   R.   t   target_desct   objectst   output_filenamet
   output_dirt	   librariest   library_dirst   runtime_library_dirst   export_symbolst   debugt   extra_preargsR;   t
   build_tempt   target_langt   temp_dirt   dll_namet   dll_extensiont   def_filet   lib_filet   contentst   sym(    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyRM   ®   sJ    				t    c         C   s  | d  k r d } n  g  } x· | D]Ÿ } t j j t j j | É É \ } } | |  j d d g k r{ t d | | f Ç n  | rñ t j j | É } n  | d k sÆ | d k rÿ | j t j j	 | | | |  j
 É É q" | j t j j	 | | |  j
 É É q" W| S(   NRa   s   .rcs   .ress"   unknown file type '%s' (from '%s')(   RC   RE   RF   RH   t   normcaset   src_extensionsR   RI   RK   RJ   t   obj_extension(   R.   t   source_filenamest	   strip_dirRQ   t	   obj_namest   src_namet   baseR9   (    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyt   object_filenames  s"     	$N(   t   __name__t
   __module__R*   Rd   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatt   exe_extensionR!   R>   RC   RM   Rj   (    (    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyR   R   s*   >	Xt   Mingw32CCompilerc           B   s    e  Z d  Z d d d d Ñ Z RS(   t   mingw32i    c         C   s›   t  j |  | | | É |  j d k r. d } n d } |  j d k rL d } n d } |  j d k  sj t É  rs d } n d } |  j d	 d
 | d d | d d | d d | d d |  j | | | f É g  |  _ t É  |  _ d  S(   Ns   2.13s   -shareds   -mdll -statics   2.91.57s   --entry _DllMain@12Ra   t   4s    -mno-cygwinR   s   gcc%s -O -WallR   s   gcc%s -mdll -O -WallR   s   g++%s -O -WallR   s   gcc%sR   s
   %s%s %s %s(	   R   R!   R(   R'   t   is_cygwingccR,   R+   R-   R   (   R.   R/   R0   R1   R4   t   entry_pointt	   no_cygwin(    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyR!   -  s&    			


		(   Rk   Rl   R*   R!   (    (    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyRr   )  s   t   oks   not okt	   uncertainc          C   s›   d d l  m }  d d l } | j t j d É d k rA t d f S|  j É  } y. t | É } z | j	 É  } Wd | j
 É  XWn' t k
 r§ } t d | | j f f SX| j | d É d k rÀ t d	 | f St d
 | f Sd S(   s°  Check if the current Python installation (specifically, pyconfig.h)
    appears amenable to building extensions with GCC.  Returns a tuple
    (status, details), where 'status' is one of the following constants:
      CONFIG_H_OK
        all is well, go ahead and compile
      CONFIG_H_NOTOK
        doesn't look good
      CONFIG_H_UNCERTAIN
        not sure -- unable to read pyconfig.h
    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    iˇˇˇˇ(   t	   sysconfigNt   GCCi    s   sys.version mentions 'GCC's   couldn't read '%s': %st   __GNUC__s   '%s' mentions '__GNUC__'s    '%s' does not mention '__GNUC__'(   t	   distutilsRz   t   stringR   R   R   R$   t   get_config_h_filenamet   opent   readt   closet   IOErrort   CONFIG_H_UNCERTAINt   strerrort   CONFIG_H_NOTOK(   Rz   R~   t   fnt   ft   st   exc(    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyR"   e  s     
c          C   s∞  d d l  m }  d d l m } d d l } | d É } | r£ t j | d d É } | j É  } | j É  | j	 d | É } | rö |  | j
 d	 É É } q© d } n d } | d
 É } | r t j | d d É } | j É  } | j É  | j	 d | É } | r|  | j
 d	 É É }	 q&d }	 n d }	 | d É }
 |
 rùt j |
 d d É } | j É  } | j É  | j	 d | É } | rî|  | j
 d	 É É } q£d } n d } | |	 | f S(   sj    Try to find out the versions of gcc, ld and dllwrap.
        If not possible it returns None for it.
    iˇˇˇˇ(   t   LooseVersion(   t   find_executableNR   s    -dumpversiont   rs   (\d+\.\d+(\.\d+)*)i   t   lds    -vR   s
    --versions    (\d+\.\d+(\.\d+)*)(   t   distutils.versionRã   t   distutils.spawnRå   t   reRE   t   popenRÅ   RÇ   t   searcht   groupRC   (   Rã   Rå   Rë   t   gcc_exet   outt
   out_stringt   resultR'   t   ld_exeR(   t   dllwrap_exeR)   (    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyR&   ö  sD    
	
	
	c          C   s;   t  j d d É }  |  j É  } |  j É  | j É  j d É S(   s>   Try to determine if the gcc that would be used is from cygwin.s   gcc -dumpmachineRç   R   (   RE   Rí   RÅ   RÇ   t   stript   endswith(   Rñ   Ró   (    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyRu   »  s    
(   t   __doc__t   __revision__RE   R   RA   t   distutils.ccompilerR    R   t   distutils.unixccompilerR   t   distutils.file_utilR   t   distutils.errorsR   R   R   R}   R   R   R   Rr   R$   RÜ   RÑ   R"   R&   Ru   (    (    (    s/   /usr/lib/python2.7/distutils/cygwinccompiler.pyt   <module>   s    +$	◊8	5	.                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python2.7/distutils/debug.py                                                                0100644 0000000 0000000 00000000242 12734733743 016073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os

__revision__ = "$Id$"

# If DISTUTILS_DEBUG is anything other than the empty string, we run in
# debug mode.
DEBUG = os.environ.get('DISTUTILS_DEBUG')
                                                                                                                                                                                                                                                                                                                                                              usr/lib/python2.7/distutils/debug.pyc                                                               0100644 0000000 0000000 00000000374 13077704274 016242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s(   d  d l  Z  d Z e  j j d É Z d S(   iˇˇˇˇNs   $Id$t   DISTUTILS_DEBUG(   t   ost   __revision__t   environt   gett   DEBUG(    (    (    s%   /usr/lib/python2.7/distutils/debug.pyt   <module>   s                                                                                                                                                                                                                                                                       usr/lib/python2.7/distutils/dep_util.py                                                             0100644 0000000 0000000 00000006665 12734733743 016631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.dep_util

Utility functions for simple, timestamp-based dependency of files
and groups of files; also, function based entirely on such
timestamp dependency analysis."""

__revision__ = "$Id$"

import os
from stat import ST_MTIME
from distutils.errors import DistutilsFileError

def newer(source, target):
    """Tells if the target is newer than the source.

    Return true if 'source' exists and is more recently modified than
    'target', or if 'source' exists and 'target' doesn't.

    Return false if both exist and 'target' is the same age or younger
    than 'source'. Raise DistutilsFileError if 'source' does not exist.

    Note that this test is not very accurate: files created in the same second
    will have the same "age".
    """
    if not os.path.exists(source):
        raise DistutilsFileError("file '%s' does not exist" %
                                 os.path.abspath(source))
    if not os.path.exists(target):
        return True

    return os.stat(source)[ST_MTIME] > os.stat(target)[ST_MTIME]

def newer_pairwise(sources, targets):
    """Walk two filename lists in parallel, testing if each source is newer
    than its corresponding target.  Return a pair of lists (sources,
    targets) where source is newer than target, according to the semantics
    of 'newer()'.
    """
    if len(sources) != len(targets):
        raise ValueError, "'sources' and 'targets' must be same length"

    # build a pair of lists (sources, targets) where  source is newer
    n_sources = []
    n_targets = []
    for source, target in zip(sources, targets):
        if newer(source, target):
            n_sources.append(source)
            n_targets.append(target)

    return n_sources, n_targets

def newer_group(sources, target, missing='error'):
    """Return true if 'target' is out-of-date with respect to any file
    listed in 'sources'.

    In other words, if 'target' exists and is newer
    than every file in 'sources', return false; otherwise return true.
    'missing' controls what we do when a source file is missing; the
    default ("error") is to blow up with an OSError from inside 'stat()';
    if it is "ignore", we silently drop any missing source files; if it is
    "newer", any missing source files make us assume that 'target' is
    out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
    carry out commands that wouldn't work because inputs are missing, but
    that doesn't matter because you're not actually going to run the
    commands).
    """
    # If the target doesn't even exist, then it's definitely out-of-date.
    if not os.path.exists(target):
        return True

    # Otherwise we have to find out the hard way: if *any* source file
    # is more recent than 'target', then 'target' is out-of-date and
    # we can immediately return true.  If we fall through to the end
    # of the loop, then 'target' is up-to-date and we return false.
    target_mtime = os.stat(target)[ST_MTIME]

    for source in sources:
        if not os.path.exists(source):
            if missing == 'error':      # blow up when we stat() the file
                pass
            elif missing == 'ignore':   # missing source dropped from
                continue                #  target's dependency list
            elif missing == 'newer':    # missing source means target is
                return True             #  out-of-date

        if os.stat(source)[ST_MTIME] > target_mtime:
            return True

    return False
                                                                           usr/lib/python2.7/distutils/dep_util.pyc                                                            0100644 0000000 0000000 00000006144 13077704274 016762  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sZ   d  Z  d Z d d l Z d d l m Z d d l m Z d Ñ  Z d Ñ  Z d d	 Ñ Z	 d S(
   sØ   distutils.dep_util

Utility functions for simple, timestamp-based dependency of files
and groups of files; also, function based entirely on such
timestamp dependency analysis.s   $Id$iˇˇˇˇN(   t   ST_MTIME(   t   DistutilsFileErrorc         C   sk   t  j j |  É s1 t d t  j j |  É É Ç n  t  j j | É sG t St  j |  É t t  j | É t k S(   s±  Tells if the target is newer than the source.

    Return true if 'source' exists and is more recently modified than
    'target', or if 'source' exists and 'target' doesn't.

    Return false if both exist and 'target' is the same age or younger
    than 'source'. Raise DistutilsFileError if 'source' does not exist.

    Note that this test is not very accurate: files created in the same second
    will have the same "age".
    s   file '%s' does not exist(   t   ost   patht   existsR   t   abspatht   Truet   statR    (   t   sourcet   target(    (    s(   /usr/lib/python2.7/distutils/dep_util.pyt   newer   s    c         C   sÜ   t  |  É t  | É k r$ t d Ç n  g  } g  } xI t |  | É D]8 \ } } t | | É r@ | j | É | j | É q@ q@ W| | f S(   sÎ   Walk two filename lists in parallel, testing if each source is newer
    than its corresponding target.  Return a pair of lists (sources,
    targets) where source is newer than target, according to the semantics
    of 'newer()'.
    s+   'sources' and 'targets' must be same length(   t   lent
   ValueErrort   zipR
   t   append(   t   sourcest   targetst	   n_sourcest	   n_targetsR   R	   (    (    s(   /usr/lib/python2.7/distutils/dep_util.pyt   newer_pairwise!   s    t   errorc         C   s°   t  j j | É s t St  j | É t } xq |  D]i } t  j j | É s| | d k rW q| | d k ri q0 q| | d k r| t Sn  t  j | É t | k r0 t Sq0 Wt S(   s„  Return true if 'target' is out-of-date with respect to any file
    listed in 'sources'.

    In other words, if 'target' exists and is newer
    than every file in 'sources', return false; otherwise return true.
    'missing' controls what we do when a source file is missing; the
    default ("error") is to blow up with an OSError from inside 'stat()';
    if it is "ignore", we silently drop any missing source files; if it is
    "newer", any missing source files make us assume that 'target' is
    out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
    carry out commands that wouldn't work because inputs are missing, but
    that doesn't matter because you're not actually going to run the
    commands).
    R   t   ignoreR
   (   R   R   R   R   R   R    t   False(   R   R	   t   missingt   target_mtimeR   (    (    s(   /usr/lib/python2.7/distutils/dep_util.pyt   newer_group4   s    (
   t   __doc__t   __revision__R   R   R    t   distutils.errorsR   R
   R   R   (    (    (    s(   /usr/lib/python2.7/distutils/dep_util.pyt   <module>   s   		                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/distutils/dir_util.py                                                             0100644 0000000 0000000 00000017276 12734733743 016637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.dir_util

Utility functions for manipulating directories and directory trees."""

__revision__ = "$Id$"

import os
import errno
from distutils.errors import DistutilsFileError, DistutilsInternalError
from distutils import log

# cache for by mkpath() -- in addition to cheapening redundant calls,
# eliminates redundant "creating /foo/bar/baz" messages in dry-run mode
_path_created = {}

# I don't use os.makedirs because a) it's new to Python 1.5.2, and
# b) it blows up if the directory already exists (I want to silently
# succeed in that case).
def mkpath(name, mode=0777, verbose=1, dry_run=0):
    """Create a directory and any missing ancestor directories.

    If the directory already exists (or if 'name' is the empty string, which
    means the current directory, which of course exists), then do nothing.
    Raise DistutilsFileError if unable to create some directory along the way
    (eg. some sub-path exists, but is a file rather than a directory).
    If 'verbose' is true, print a one-line summary of each mkdir to stdout.
    Return the list of directories actually created.
    """

    global _path_created

    # Detect a common bug -- name is None
    if not isinstance(name, basestring):
        raise DistutilsInternalError, \
              "mkpath: 'name' must be a string (got %r)" % (name,)

    # XXX what's the better way to handle verbosity? print as we create
    # each directory in the path (the current behaviour), or only announce
    # the creation of the whole path? (quite easy to do the latter since
    # we're not using a recursive algorithm)

    name = os.path.normpath(name)
    created_dirs = []
    if os.path.isdir(name) or name == '':
        return created_dirs
    if _path_created.get(os.path.abspath(name)):
        return created_dirs

    (head, tail) = os.path.split(name)
    tails = [tail]                      # stack of lone dirs to create

    while head and tail and not os.path.isdir(head):
        (head, tail) = os.path.split(head)
        tails.insert(0, tail)          # push next higher dir onto stack

    # now 'head' contains the deepest directory that already exists
    # (that is, the child of 'head' in 'name' is the highest directory
    # that does *not* exist)
    for d in tails:
        #print "head = %s, d = %s: " % (head, d),
        head = os.path.join(head, d)
        abs_head = os.path.abspath(head)

        if _path_created.get(abs_head):
            continue

        if verbose >= 1:
            log.info("creating %s", head)

        if not dry_run:
            try:
                os.mkdir(head, mode)
            except OSError, exc:
                if not (exc.errno == errno.EEXIST and os.path.isdir(head)):
                    raise DistutilsFileError(
                          "could not create '%s': %s" % (head, exc.args[-1]))
            created_dirs.append(head)

        _path_created[abs_head] = 1
    return created_dirs

def create_tree(base_dir, files, mode=0777, verbose=1, dry_run=0):
    """Create all the empty directories under 'base_dir' needed to put 'files'
    there.

    'base_dir' is just the a name of a directory which doesn't necessarily
    exist yet; 'files' is a list of filenames to be interpreted relative to
    'base_dir'.  'base_dir' + the directory portion of every file in 'files'
    will be created if it doesn't already exist.  'mode', 'verbose' and
    'dry_run' flags are as for 'mkpath()'.
    """
    # First get the list of directories to create
    need_dir = {}
    for file in files:
        need_dir[os.path.join(base_dir, os.path.dirname(file))] = 1
    need_dirs = need_dir.keys()
    need_dirs.sort()

    # Now create them
    for dir in need_dirs:
        mkpath(dir, mode, verbose=verbose, dry_run=dry_run)

def copy_tree(src, dst, preserve_mode=1, preserve_times=1,
              preserve_symlinks=0, update=0, verbose=1, dry_run=0):
    """Copy an entire directory tree 'src' to a new location 'dst'.

    Both 'src' and 'dst' must be directory names.  If 'src' is not a
    directory, raise DistutilsFileError.  If 'dst' does not exist, it is
    created with 'mkpath()'.  The end result of the copy is that every
    file in 'src' is copied to 'dst', and directories under 'src' are
    recursively copied to 'dst'.  Return the list of files that were
    copied or might have been copied, using their output name.  The
    return value is unaffected by 'update' or 'dry_run': it is simply
    the list of all files under 'src', with the names changed to be
    under 'dst'.

    'preserve_mode' and 'preserve_times' are the same as for
    'copy_file'; note that they only apply to regular files, not to
    directories.  If 'preserve_symlinks' is true, symlinks will be
    copied as symlinks (on platforms that support them!); otherwise
    (the default), the destination of the symlink will be copied.
    'update' and 'verbose' are the same as for 'copy_file'.
    """
    from distutils.file_util import copy_file

    if not dry_run and not os.path.isdir(src):
        raise DistutilsFileError, \
              "cannot copy tree '%s': not a directory" % src
    try:
        names = os.listdir(src)
    except os.error, (errno, errstr):
        if dry_run:
            names = []
        else:
            raise DistutilsFileError, \
                  "error listing files in '%s': %s" % (src, errstr)

    if not dry_run:
        mkpath(dst, verbose=verbose)

    outputs = []

    for n in names:
        src_name = os.path.join(src, n)
        dst_name = os.path.join(dst, n)

        if n.startswith('.nfs'):
            # skip NFS rename files
            continue

        if preserve_symlinks and os.path.islink(src_name):
            link_dest = os.readlink(src_name)
            if verbose >= 1:
                log.info("linking %s -> %s", dst_name, link_dest)
            if not dry_run:
                os.symlink(link_dest, dst_name)
            outputs.append(dst_name)

        elif os.path.isdir(src_name):
            outputs.extend(
                copy_tree(src_name, dst_name, preserve_mode,
                          preserve_times, preserve_symlinks, update,
                          verbose=verbose, dry_run=dry_run))
        else:
            copy_file(src_name, dst_name, preserve_mode,
                      preserve_times, update, verbose=verbose,
                      dry_run=dry_run)
            outputs.append(dst_name)

    return outputs

def _build_cmdtuple(path, cmdtuples):
    """Helper for remove_tree()."""
    for f in os.listdir(path):
        real_f = os.path.join(path,f)
        if os.path.isdir(real_f) and not os.path.islink(real_f):
            _build_cmdtuple(real_f, cmdtuples)
        else:
            cmdtuples.append((os.remove, real_f))
    cmdtuples.append((os.rmdir, path))

def remove_tree(directory, verbose=1, dry_run=0):
    """Recursively remove an entire directory tree.

    Any errors are ignored (apart from being reported to stdout if 'verbose'
    is true).
    """
    global _path_created

    if verbose >= 1:
        log.info("removing '%s' (and everything under it)", directory)
    if dry_run:
        return
    cmdtuples = []
    _build_cmdtuple(directory, cmdtuples)
    for cmd in cmdtuples:
        try:
            cmd[0](cmd[1])
            # remove dir from cache if it's already there
            abspath = os.path.abspath(cmd[1])
            if abspath in _path_created:
                del _path_created[abspath]
        except (IOError, OSError), exc:
            log.warn("error removing %s: %s", directory, exc)

def ensure_relative(path):
    """Take the full path 'path', and make it a relative path.

    This is useful to make 'path' the second argument to os.path.join().
    """
    drive, path = os.path.splitdrive(path)
    if path[0:1] == os.sep:
        path = drive + path[1:]
    return path
                                                                                                                                                                                                                                                                                                                                  usr/lib/python2.7/distutils/dir_util.pyc                                                            0100644 0000000 0000000 00000015166 13077704274 016774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s¥   d  Z  d Z d d l Z d d l Z d d l m Z m Z d d l m Z i  a	 d d d d	 Ñ Z
 d d d d
 Ñ Z d d d d d d d Ñ Z d Ñ  Z d d d Ñ Z d Ñ  Z d S(   sW   distutils.dir_util

Utility functions for manipulating directories and directory trees.s   $Id$iˇˇˇˇN(   t   DistutilsFileErrort   DistutilsInternalError(   t   logiˇ  i   i    c         C   sË  t  |  t É s" t d |  f Ç n  t j j |  É }  g  } t j j |  É sX |  d k r\ | St j t j j	 |  É É r{ | St j j
 |  É \ } } | g } xK | rÈ | rÈ t j j | É rÈ t j j
 | É \ } } | j d | É qü Wx˜ | D]Ô } t j j | | É } t j j	 | É }	 t j |	 É r3qÒ n  | d k rRt j d | É n  | s÷y t j | | É WnW t k
 r≈}
 |
 j t j k oüt j j | É s∆t d | |
 j d f É Ç q∆n X| j | É n  d t |	 <qÒ W| S(   sÏ  Create a directory and any missing ancestor directories.

    If the directory already exists (or if 'name' is the empty string, which
    means the current directory, which of course exists), then do nothing.
    Raise DistutilsFileError if unable to create some directory along the way
    (eg. some sub-path exists, but is a file rather than a directory).
    If 'verbose' is true, print a one-line summary of each mkdir to stdout.
    Return the list of directories actually created.
    s(   mkpath: 'name' must be a string (got %r)t    i    i   s   creating %ss   could not create '%s': %siˇˇˇˇ(   t
   isinstancet
   basestringR   t   ost   patht   normpatht   isdirt   _path_createdt   gett   abspatht   splitt   insertt   joinR   t   infot   mkdirt   OSErrort   errnot   EEXISTR    t   argst   append(   t   namet   modet   verboset   dry_runt   created_dirst   headt   tailt   tailst   dt   abs_headt   exc(    (    s(   /usr/lib/python2.7/distutils/dir_util.pyt   mkpath   s>    	"$!c   	      C   sÄ   i  } x3 | D]+ } d | t  j j |  t  j j | É É <q W| j É  } | j É  x' | D] } t | | d | d | ÉqY Wd S(   sØ  Create all the empty directories under 'base_dir' needed to put 'files'
    there.

    'base_dir' is just the a name of a directory which doesn't necessarily
    exist yet; 'files' is a list of filenames to be interpreted relative to
    'base_dir'.  'base_dir' + the directory portion of every file in 'files'
    will be created if it doesn't already exist.  'mode', 'verbose' and
    'dry_run' flags are as for 'mkpath()'.
    i   R   R   N(   R   R   R   t   dirnamet   keyst   sortR"   (	   t   base_dirt   filesR   R   R   t   need_dirt   filet	   need_dirst   dir(    (    s(   /usr/lib/python2.7/distutils/dir_util.pyt   create_treeR   s    )
c         C   sÂ  d d l  m } | r: t j j |  É r: t d |  Ç n  y t j |  É }	 Wn> t j k
 rç \ }
 } | rw g  }	 qé t d |  | f Ç n X| sß t | d | Én  g  } x1|	 D])} t j j	 |  | É } t j j	 | | É } | j
 d É r˘ q¥ n  | rkt j j | É rkt j | É } | d k rBt j d | | É n  | s[t j | | É n  | j | É q¥ t j j | É rÆ| j t | | | | | | d | d	 | ÉÉ q¥ | | | | | | d | d	 | É| j | É q¥ W| S(
   s  Copy an entire directory tree 'src' to a new location 'dst'.

    Both 'src' and 'dst' must be directory names.  If 'src' is not a
    directory, raise DistutilsFileError.  If 'dst' does not exist, it is
    created with 'mkpath()'.  The end result of the copy is that every
    file in 'src' is copied to 'dst', and directories under 'src' are
    recursively copied to 'dst'.  Return the list of files that were
    copied or might have been copied, using their output name.  The
    return value is unaffected by 'update' or 'dry_run': it is simply
    the list of all files under 'src', with the names changed to be
    under 'dst'.

    'preserve_mode' and 'preserve_times' are the same as for
    'copy_file'; note that they only apply to regular files, not to
    directories.  If 'preserve_symlinks' is true, symlinks will be
    copied as symlinks (on platforms that support them!); otherwise
    (the default), the destination of the symlink will be copied.
    'update' and 'verbose' are the same as for 'copy_file'.
    iˇˇˇˇ(   t	   copy_files&   cannot copy tree '%s': not a directorys   error listing files in '%s': %sR   s   .nfsi   s   linking %s -> %sR   (   t   distutils.file_utilR-   R   R   R	   R    t   listdirt   errorR"   R   t
   startswitht   islinkt   readlinkR   R   t   symlinkR   t   extendt	   copy_tree(   t   srct   dstt   preserve_modet   preserve_timest   preserve_symlinkst   updateR   R   R-   t   namesR   t   errstrt   outputst   nt   src_namet   dst_namet	   link_dest(    (    s(   /usr/lib/python2.7/distutils/dir_util.pyR6   g   sH    	c         C   sî   xw t  j |  É D]f } t  j j |  | É } t  j j | É r` t  j j | É r` t | | É q | j t  j | f É q W| j t  j	 |  f É d S(   s   Helper for remove_tree().N(
   R   R/   R   R   R	   R2   t   _build_cmdtupleR   t   removet   rmdir(   R   t	   cmdtuplest   ft   real_f(    (    s(   /usr/lib/python2.7/distutils/dir_util.pyRD   ¨   s    %c         C   s¬   | d k r t  j d |  É n  | r) d Sg  } t |  | É x | D]w } yB | d | d É t j j | d É } | t k rä t | =n  WqC t t f k
 rπ } t  j	 d |  | É qC XqC Wd S(   sç   Recursively remove an entire directory tree.

    Any errors are ignored (apart from being reported to stdout if 'verbose'
    is true).
    i   s'   removing '%s' (and everything under it)Ni    s   error removing %s: %s(
   R   R   RD   R   R   R   R
   t   IOErrorR   t   warn(   t	   directoryR   R   RG   t   cmdR   R!   (    (    s(   /usr/lib/python2.7/distutils/dir_util.pyt   remove_tree∂   s    c         C   sC   t  j j |  É \ } }  |  d d !t  j k r? | |  d }  n  |  S(   sÜ   Take the full path 'path', and make it a relative path.

    This is useful to make 'path' the second argument to os.path.join().
    i    i   (   R   R   t
   splitdrivet   sep(   R   t   drive(    (    s(   /usr/lib/python2.7/distutils/dir_util.pyt   ensure_relativeŒ   s    (   t   __doc__t   __revision__R   R   t   distutils.errorsR    R   t	   distutilsR   R
   R"   R,   R6   RD   RN   RR   (    (    (    s(   /usr/lib/python2.7/distutils/dir_util.pyt   <module>   s   ?D	
                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python2.7/distutils/dist.py                                                                 0100644 0000000 0000000 00000141601 12734733743 015755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.dist

Provides the Distribution class, which represents the module distribution
being built/installed/distributed.
"""

__revision__ = "$Id$"

import sys, os, re
from email import message_from_file

try:
    import warnings
except ImportError:
    warnings = None

from distutils.errors import (DistutilsOptionError, DistutilsArgError,
                              DistutilsModuleError, DistutilsClassError)
from distutils.fancy_getopt import FancyGetopt, translate_longopt
from distutils.util import check_environ, strtobool, rfc822_escape
from distutils import log
from distutils.debug import DEBUG

# Encoding used for the PKG-INFO files
PKG_INFO_ENCODING = 'utf-8'

# Regex to define acceptable Distutils command names.  This is not *quite*
# the same as a Python NAME -- I don't allow leading underscores.  The fact
# that they're very similar is no coincidence; the default naming scheme is
# to look for a Python module named after the command.
command_re = re.compile (r'^[a-zA-Z]([a-zA-Z0-9_]*)$')


class Distribution:
    """The core of the Distutils.  Most of the work hiding behind 'setup'
    is really done within a Distribution instance, which farms the work out
    to the Distutils commands specified on the command line.

    Setup scripts will almost never instantiate Distribution directly,
    unless the 'setup()' function is totally inadequate to their needs.
    However, it is conceivable that a setup script might wish to subclass
    Distribution for some specialized purpose, and then pass the subclass
    to 'setup()' as the 'distclass' keyword argument.  If so, it is
    necessary to respect the expectations that 'setup' has of Distribution.
    See the code for 'setup()', in core.py, for details.
    """


    # 'global_options' describes the command-line options that may be
    # supplied to the setup script prior to any actual commands.
    # Eg. "./setup.py -n" or "./setup.py --quiet" both take advantage of
    # these global options.  This list should be kept to a bare minimum,
    # since every global option is also valid as a command option -- and we
    # don't want to pollute the commands with too many options that they
    # have minimal control over.
    # The fourth entry for verbose means that it can be repeated.
    global_options = [('verbose', 'v', "run verbosely (default)", 1),
                      ('quiet', 'q', "run quietly (turns verbosity off)"),
                      ('dry-run', 'n', "don't actually do anything"),
                      ('help', 'h', "show detailed help message"),
                      ('no-user-cfg', None,
                       'ignore pydistutils.cfg in your home directory'),
    ]

    # 'common_usage' is a short (2-3 line) string describing the common
    # usage of the setup script.
    common_usage = """\
Common commands: (see '--help-commands' for more)

  setup.py build      will build the package underneath 'build/'
  setup.py install    will install the package
"""

    # options that are not propagated to the commands
    display_options = [
        ('help-commands', None,
         "list all available commands"),
        ('name', None,
         "print package name"),
        ('version', 'V',
         "print package version"),
        ('fullname', None,
         "print <package name>-<version>"),
        ('author', None,
         "print the author's name"),
        ('author-email', None,
         "print the author's email address"),
        ('maintainer', None,
         "print the maintainer's name"),
        ('maintainer-email', None,
         "print the maintainer's email address"),
        ('contact', None,
         "print the maintainer's name if known, else the author's"),
        ('contact-email', None,
         "print the maintainer's email address if known, else the author's"),
        ('url', None,
         "print the URL for this package"),
        ('license', None,
         "print the license of the package"),
        ('licence', None,
         "alias for --license"),
        ('description', None,
         "print the package description"),
        ('long-description', None,
         "print the long package description"),
        ('platforms', None,
         "print the list of platforms"),
        ('classifiers', None,
         "print the list of classifiers"),
        ('keywords', None,
         "print the list of keywords"),
        ('provides', None,
         "print the list of packages/modules provided"),
        ('requires', None,
         "print the list of packages/modules required"),
        ('obsoletes', None,
         "print the list of packages/modules made obsolete")
        ]
    display_option_names = map(lambda x: translate_longopt(x[0]),
                               display_options)

    # negative options are options that exclude other options
    negative_opt = {'quiet': 'verbose'}


    # -- Creation/initialization methods -------------------------------

    def __init__ (self, attrs=None):
        """Construct a new Distribution instance: initialize all the
        attributes of a Distribution, and then use 'attrs' (a dictionary
        mapping attribute names to values) to assign some of those
        attributes their "real" values.  (Any attributes not mentioned in
        'attrs' will be assigned to some null value: 0, None, an empty list
        or dictionary, etc.)  Most importantly, initialize the
        'command_obj' attribute to the empty dictionary; this will be
        filled in with real command objects by 'parse_command_line()'.
        """

        # Default values for our command-line options
        self.verbose = 1
        self.dry_run = 0
        self.help = 0
        for attr in self.display_option_names:
            setattr(self, attr, 0)

        # Store the distribution meta-data (name, version, author, and so
        # forth) in a separate object -- we're getting to have enough
        # information here (and enough command-line options) that it's
        # worth it.  Also delegate 'get_XXX()' methods to the 'metadata'
        # object in a sneaky and underhanded (but efficient!) way.
        self.metadata = DistributionMetadata()
        for basename in self.metadata._METHOD_BASENAMES:
            method_name = "get_" + basename
            setattr(self, method_name, getattr(self.metadata, method_name))

        # 'cmdclass' maps command names to class objects, so we
        # can 1) quickly figure out which class to instantiate when
        # we need to create a new command object, and 2) have a way
        # for the setup script to override command classes
        self.cmdclass = {}

        # 'command_packages' is a list of packages in which commands
        # are searched for.  The factory for command 'foo' is expected
        # to be named 'foo' in the module 'foo' in one of the packages
        # named here.  This list is searched from the left; an error
        # is raised if no named package provides the command being
        # searched for.  (Always access using get_command_packages().)
        self.command_packages = None

        # 'script_name' and 'script_args' are usually set to sys.argv[0]
        # and sys.argv[1:], but they can be overridden when the caller is
        # not necessarily a setup script run from the command-line.
        self.script_name = None
        self.script_args = None

        # 'command_options' is where we store command options between
        # parsing them (from config files, the command-line, etc.) and when
        # they are actually needed -- ie. when the command in question is
        # instantiated.  It is a dictionary of dictionaries of 2-tuples:
        #   command_options = { command_name : { option : (source, value) } }
        self.command_options = {}

        # 'dist_files' is the list of (command, pyversion, file) that
        # have been created by any dist commands run so far. This is
        # filled regardless of whether the run is dry or not. pyversion
        # gives sysconfig.get_python_version() if the dist file is
        # specific to a Python version, 'any' if it is good for all
        # Python versions on the target platform, and '' for a source
        # file. pyversion should not be used to specify minimum or
        # maximum required Python versions; use the metainfo for that
        # instead.
        self.dist_files = []

        # These options are really the business of various commands, rather
        # than of the Distribution itself.  We provide aliases for them in
        # Distribution as a convenience to the developer.
        self.packages = None
        self.package_data = {}
        self.package_dir = None
        self.py_modules = None
        self.libraries = None
        self.headers = None
        self.ext_modules = None
        self.ext_package = None
        self.include_dirs = None
        self.extra_path = None
        self.scripts = None
        self.data_files = None
        self.password = ''

        # And now initialize bookkeeping stuff that can't be supplied by
        # the caller at all.  'command_obj' maps command names to
        # Command instances -- that's how we enforce that every command
        # class is a singleton.
        self.command_obj = {}

        # 'have_run' maps command names to boolean values; it keeps track
        # of whether we have actually run a particular command, to make it
        # cheap to "run" a command whenever we think we might need to -- if
        # it's already been done, no need for expensive filesystem
        # operations, we just check the 'have_run' dictionary and carry on.
        # It's only safe to query 'have_run' for a command class that has
        # been instantiated -- a false value will be inserted when the
        # command object is created, and replaced with a true value when
        # the command is successfully run.  Thus it's probably best to use
        # '.get()' rather than a straight lookup.
        self.have_run = {}

        # Now we'll use the attrs dictionary (ultimately, keyword args from
        # the setup script) to possibly override any or all of these
        # distribution options.

        if attrs:
            # Pull out the set of command options and work on them
            # specifically.  Note that this order guarantees that aliased
            # command options will override any supplied redundantly
            # through the general options dictionary.
            options = attrs.get('options')
            if options is not None:
                del attrs['options']
                for (command, cmd_options) in options.items():
                    opt_dict = self.get_option_dict(command)
                    for (opt, val) in cmd_options.items():
                        opt_dict[opt] = ("setup script", val)

            if 'licence' in attrs:
                attrs['license'] = attrs['licence']
                del attrs['licence']
                msg = "'licence' distribution option is deprecated; use 'license'"
                if warnings is not None:
                    warnings.warn(msg)
                else:
                    sys.stderr.write(msg + "\n")

            # Now work on the rest of the attributes.  Any attribute that's
            # not already defined is invalid!
            for (key, val) in attrs.items():
                if hasattr(self.metadata, "set_" + key):
                    getattr(self.metadata, "set_" + key)(val)
                elif hasattr(self.metadata, key):
                    setattr(self.metadata, key, val)
                elif hasattr(self, key):
                    setattr(self, key, val)
                else:
                    msg = "Unknown distribution option: %s" % repr(key)
                    if warnings is not None:
                        warnings.warn(msg)
                    else:
                        sys.stderr.write(msg + "\n")

        # no-user-cfg is handled before other command line args
        # because other args override the config files, and this
        # one is needed before we can load the config files.
        # If attrs['script_args'] wasn't passed, assume false.
        #
        # This also make sure we just look at the global options
        self.want_user_cfg = True

        if self.script_args is not None:
            for arg in self.script_args:
                if not arg.startswith('-'):
                    break
                if arg == '--no-user-cfg':
                    self.want_user_cfg = False
                    break

        self.finalize_options()

    def get_option_dict(self, command):
        """Get the option dictionary for a given command.  If that
        command's option dictionary hasn't been created yet, then create it
        and return the new dictionary; otherwise, return the existing
        option dictionary.
        """
        dict = self.command_options.get(command)
        if dict is None:
            dict = self.command_options[command] = {}
        return dict

    def dump_option_dicts(self, header=None, commands=None, indent=""):
        from pprint import pformat

        if commands is None:             # dump all command option dicts
            commands = self.command_options.keys()
            commands.sort()

        if header is not None:
            self.announce(indent + header)
            indent = indent + "  "

        if not commands:
            self.announce(indent + "no commands known yet")
            return

        for cmd_name in commands:
            opt_dict = self.command_options.get(cmd_name)
            if opt_dict is None:
                self.announce(indent +
                              "no option dict for '%s' command" % cmd_name)
            else:
                self.announce(indent +
                              "option dict for '%s' command:" % cmd_name)
                out = pformat(opt_dict)
                for line in out.split('\n'):
                    self.announce(indent + "  " + line)

    # -- Config file finding/parsing methods ---------------------------

    def find_config_files(self):
        """Find as many configuration files as should be processed for this
        platform, and return a list of filenames in the order in which they
        should be parsed.  The filenames returned are guaranteed to exist
        (modulo nasty race conditions).

        There are three possible config files: distutils.cfg in the
        Distutils installation directory (ie. where the top-level
        Distutils __inst__.py file lives), a file in the user's home
        directory named .pydistutils.cfg on Unix and pydistutils.cfg
        on Windows/Mac; and setup.cfg in the current directory.

        The file in the user's home directory can be disabled with the
        --no-user-cfg option.
        """
        files = []
        check_environ()

        # Where to look for the system-wide Distutils config file
        sys_dir = os.path.dirname(sys.modules['distutils'].__file__)

        # Look for the system config file
        sys_file = os.path.join(sys_dir, "distutils.cfg")
        if os.path.isfile(sys_file):
            files.append(sys_file)

        # What to call the per-user config file
        if os.name == 'posix':
            user_filename = ".pydistutils.cfg"
        else:
            user_filename = "pydistutils.cfg"

        # And look for the user config file
        if self.want_user_cfg:
            user_file = os.path.join(os.path.expanduser('~'), user_filename)
            if os.path.isfile(user_file):
                files.append(user_file)

        # All platforms support local setup.cfg
        local_file = "setup.cfg"
        if os.path.isfile(local_file):
            files.append(local_file)

        if DEBUG:
            self.announce("using config files: %s" % ', '.join(files))

        return files

    def parse_config_files(self, filenames=None):
        from ConfigParser import ConfigParser

        if filenames is None:
            filenames = self.find_config_files()

        if DEBUG:
            self.announce("Distribution.parse_config_files():")

        parser = ConfigParser()
        for filename in filenames:
            if DEBUG:
                self.announce("  reading %s" % filename)
            parser.read(filename)
            for section in parser.sections():
                options = parser.options(section)
                opt_dict = self.get_option_dict(section)

                for opt in options:
                    if opt != '__name__':
                        val = parser.get(section,opt)
                        opt = opt.replace('-', '_')
                        opt_dict[opt] = (filename, val)

            # Make the ConfigParser forget everything (so we retain
            # the original filenames that options come from)
            parser.__init__()

        # If there was a "global" section in the config file, use it
        # to set Distribution options.

        if 'global' in self.command_options:
            for (opt, (src, val)) in self.command_options['global'].items():
                alias = self.negative_opt.get(opt)
                try:
                    if alias:
                        setattr(self, alias, not strtobool(val))
                    elif opt in ('verbose', 'dry_run'): # ugh!
                        setattr(self, opt, strtobool(val))
                    else:
                        setattr(self, opt, val)
                except ValueError, msg:
                    raise DistutilsOptionError, msg

    # -- Command-line parsing methods ----------------------------------

    def parse_command_line(self):
        """Parse the setup script's command line, taken from the
        'script_args' instance attribute (which defaults to 'sys.argv[1:]'
        -- see 'setup()' in core.py).  This list is first processed for
        "global options" -- options that set attributes of the Distribution
        instance.  Then, it is alternately scanned for Distutils commands
        and options for that command.  Each new command terminates the
        options for the previous command.  The allowed options for a
        command are determined by the 'user_options' attribute of the
        command class -- thus, we have to be able to load command classes
        in order to parse the command line.  Any error in that 'options'
        attribute raises DistutilsGetoptError; any error on the
        command-line raises DistutilsArgError.  If no Distutils commands
        were found on the command line, raises DistutilsArgError.  Return
        true if command-line was successfully parsed and we should carry
        on with executing commands; false if no errors but we shouldn't
        execute commands (currently, this only happens if user asks for
        help).
        """
        #
        # We now have enough information to show the Macintosh dialog
        # that allows the user to interactively specify the "command line".
        #
        toplevel_options = self._get_toplevel_options()

        # We have to parse the command line a bit at a time -- global
        # options, then the first command, then its options, and so on --
        # because each command will be handled by a different class, and
        # the options that are valid for a particular class aren't known
        # until we have loaded the command class, which doesn't happen
        # until we know what the command is.

        self.commands = []
        parser = FancyGetopt(toplevel_options + self.display_options)
        parser.set_negative_aliases(self.negative_opt)
        parser.set_aliases({'licence': 'license'})
        args = parser.getopt(args=self.script_args, object=self)
        option_order = parser.get_option_order()
        log.set_verbosity(self.verbose)

        # for display options we return immediately
        if self.handle_display_options(option_order):
            return
        while args:
            args = self._parse_command_opts(parser, args)
            if args is None:            # user asked for help (and got it)
                return

        # Handle the cases of --help as a "global" option, ie.
        # "setup.py --help" and "setup.py --help command ...".  For the
        # former, we show global options (--verbose, --dry-run, etc.)
        # and display-only options (--name, --version, etc.); for the
        # latter, we omit the display-only options and show help for
        # each command listed on the command line.
        if self.help:
            self._show_help(parser,
                            display_options=len(self.commands) == 0,
                            commands=self.commands)
            return

        # Oops, no commands found -- an end-user error
        if not self.commands:
            raise DistutilsArgError, "no commands supplied"

        # All is well: return true
        return 1

    def _get_toplevel_options(self):
        """Return the non-display options recognized at the top level.

        This includes options that are recognized *only* at the top
        level as well as options recognized for commands.
        """
        return self.global_options + [
            ("command-packages=", None,
             "list of packages that provide distutils commands"),
            ]

    def _parse_command_opts(self, parser, args):
        """Parse the command-line options for a single command.
        'parser' must be a FancyGetopt instance; 'args' must be the list
        of arguments, starting with the current command (whose options
        we are about to parse).  Returns a new version of 'args' with
        the next command at the front of the list; will be the empty
        list if there are no more commands on the command line.  Returns
        None if the user asked for help on this command.
        """
        # late import because of mutual dependence between these modules
        from distutils.cmd import Command

        # Pull the current command from the head of the command line
        command = args[0]
        if not command_re.match(command):
            raise SystemExit, "invalid command name '%s'" % command
        self.commands.append(command)

        # Dig up the command class that implements this command, so we
        # 1) know that it's a valid command, and 2) know which options
        # it takes.
        try:
            cmd_class = self.get_command_class(command)
        except DistutilsModuleError, msg:
            raise DistutilsArgError, msg

        # Require that the command class be derived from Command -- want
        # to be sure that the basic "command" interface is implemented.
        if not issubclass(cmd_class, Command):
            raise DistutilsClassError, \
                  "command class %s must subclass Command" % cmd_class

        # Also make sure that the command object provides a list of its
        # known options.
        if not (hasattr(cmd_class, 'user_options') and
                isinstance(cmd_class.user_options, list)):
            raise DistutilsClassError, \
                  ("command class %s must provide " +
                   "'user_options' attribute (a list of tuples)") % \
                  cmd_class

        # If the command class has a list of negative alias options,
        # merge it in with the global negative aliases.
        negative_opt = self.negative_opt
        if hasattr(cmd_class, 'negative_opt'):
            negative_opt = negative_opt.copy()
            negative_opt.update(cmd_class.negative_opt)

        # Check for help_options in command class.  They have a different
        # format (tuple of four) so we need to preprocess them here.
        if (hasattr(cmd_class, 'help_options') and
            isinstance(cmd_class.help_options, list)):
            help_options = fix_help_options(cmd_class.help_options)
        else:
            help_options = []


        # All commands support the global options too, just by adding
        # in 'global_options'.
        parser.set_option_table(self.global_options +
                                cmd_class.user_options +
                                help_options)
        parser.set_negative_aliases(negative_opt)
        (args, opts) = parser.getopt(args[1:])
        if hasattr(opts, 'help') and opts.help:
            self._show_help(parser, display_options=0, commands=[cmd_class])
            return

        if (hasattr(cmd_class, 'help_options') and
            isinstance(cmd_class.help_options, list)):
            help_option_found=0
            for (help_option, short, desc, func) in cmd_class.help_options:
                if hasattr(opts, parser.get_attr_name(help_option)):
                    help_option_found=1
                    if hasattr(func, '__call__'):
                        func()
                    else:
                        raise DistutilsClassError(
                            "invalid help function %r for help option '%s': "
                            "must be a callable object (function, etc.)"
                            % (func, help_option))

            if help_option_found:
                return

        # Put the options from the command-line into their official
        # holding pen, the 'command_options' dictionary.
        opt_dict = self.get_option_dict(command)
        for (name, value) in vars(opts).items():
            opt_dict[name] = ("command line", value)

        return args

    def finalize_options(self):
        """Set final values for all the options on the Distribution
        instance, analogous to the .finalize_options() method of Command
        objects.
        """
        for attr in ('keywords', 'platforms'):
            value = getattr(self.metadata, attr)
            if value is None:
                continue
            if isinstance(value, str):
                value = [elm.strip() for elm in value.split(',')]
                setattr(self.metadata, attr, value)

    def _show_help(self, parser, global_options=1, display_options=1,
                   commands=[]):
        """Show help for the setup script command-line in the form of
        several lists of command-line options.  'parser' should be a
        FancyGetopt instance; do not expect it to be returned in the
        same state, as its option table will be reset to make it
        generate the correct help text.

        If 'global_options' is true, lists the global options:
        --verbose, --dry-run, etc.  If 'display_options' is true, lists
        the "display-only" options: --name, --version, etc.  Finally,
        lists per-command help for every command name or command class
        in 'commands'.
        """
        # late import because of mutual dependence between these modules
        from distutils.core import gen_usage
        from distutils.cmd import Command

        if global_options:
            if display_options:
                options = self._get_toplevel_options()
            else:
                options = self.global_options
            parser.set_option_table(options)
            parser.print_help(self.common_usage + "\nGlobal options:")
            print('')

        if display_options:
            parser.set_option_table(self.display_options)
            parser.print_help(
                "Information display options (just display " +
                "information, ignore any commands)")
            print('')

        for command in self.commands:
            if isinstance(command, type) and issubclass(command, Command):
                klass = command
            else:
                klass = self.get_command_class(command)
            if (hasattr(klass, 'help_options') and
                isinstance(klass.help_options, list)):
                parser.set_option_table(klass.user_options +
                                        fix_help_options(klass.help_options))
            else:
                parser.set_option_table(klass.user_options)
            parser.print_help("Options for '%s' command:" % klass.__name__)
            print('')

        print(gen_usage(self.script_name))

    def handle_display_options(self, option_order):
        """If there were any non-global "display-only" options
        (--help-commands or the metadata display options) on the command
        line, display the requested info and return true; else return
        false.
        """
        from distutils.core import gen_usage

        # User just wants a list of commands -- we'll print it out and stop
        # processing now (ie. if they ran "setup --help-commands foo bar",
        # we ignore "foo bar").
        if self.help_commands:
            self.print_commands()
            print('')
            print(gen_usage(self.script_name))
            return 1

        # If user supplied any of the "display metadata" options, then
        # display that metadata in the order in which the user supplied the
        # metadata options.
        any_display_options = 0
        is_display_option = {}
        for option in self.display_options:
            is_display_option[option[0]] = 1

        for (opt, val) in option_order:
            if val and is_display_option.get(opt):
                opt = translate_longopt(opt)
                value = getattr(self.metadata, "get_"+opt)()
                if opt in ['keywords', 'platforms']:
                    print(','.join(value))
                elif opt in ('classifiers', 'provides', 'requires',
                             'obsoletes'):
                    print('\n'.join(value))
                else:
                    print(value)
                any_display_options = 1

        return any_display_options

    def print_command_list(self, commands, header, max_length):
        """Print a subset of the list of all commands -- used by
        'print_commands()'.
        """
        print(header + ":")

        for cmd in commands:
            klass = self.cmdclass.get(cmd)
            if not klass:
                klass = self.get_command_class(cmd)
            try:
                description = klass.description
            except AttributeError:
                description = "(no description available)"

            print("  %-*s  %s" % (max_length, cmd, description))

    def print_commands(self):
        """Print out a help message listing all available commands with a
        description of each.  The list is divided into "standard commands"
        (listed in distutils.command.__all__) and "extra commands"
        (mentioned in self.cmdclass, but not a standard command).  The
        descriptions come from the command class attribute
        'description'.
        """
        import distutils.command
        std_commands = distutils.command.__all__
        is_std = {}
        for cmd in std_commands:
            is_std[cmd] = 1

        extra_commands = []
        for cmd in self.cmdclass.keys():
            if not is_std.get(cmd):
                extra_commands.append(cmd)

        max_length = 0
        for cmd in (std_commands + extra_commands):
            if len(cmd) > max_length:
                max_length = len(cmd)

        self.print_command_list(std_commands,
                                "Standard commands",
                                max_length)
        if extra_commands:
            print
            self.print_command_list(extra_commands,
                                    "Extra commands",
                                    max_length)

    def get_command_list(self):
        """Get a list of (command, description) tuples.
        The list is divided into "standard commands" (listed in
        distutils.command.__all__) and "extra commands" (mentioned in
        self.cmdclass, but not a standard command).  The descriptions come
        from the command class attribute 'description'.
        """
        # Currently this is only used on Mac OS, for the Mac-only GUI
        # Distutils interface (by Jack Jansen)

        import distutils.command
        std_commands = distutils.command.__all__
        is_std = {}
        for cmd in std_commands:
            is_std[cmd] = 1

        extra_commands = []
        for cmd in self.cmdclass.keys():
            if not is_std.get(cmd):
                extra_commands.append(cmd)

        rv = []
        for cmd in (std_commands + extra_commands):
            klass = self.cmdclass.get(cmd)
            if not klass:
                klass = self.get_command_class(cmd)
            try:
                description = klass.description
            except AttributeError:
                description = "(no description available)"
            rv.append((cmd, description))
        return rv

    # -- Command class/object methods ----------------------------------

    def get_command_packages(self):
        """Return a list of packages from which commands are loaded."""
        pkgs = self.command_packages
        if not isinstance(pkgs, list):
            if pkgs is None:
                pkgs = ''
            pkgs = [pkg.strip() for pkg in pkgs.split(',') if pkg != '']
            if "distutils.command" not in pkgs:
                pkgs.insert(0, "distutils.command")
            self.command_packages = pkgs
        return pkgs

    def get_command_class(self, command):
        """Return the class that implements the Distutils command named by
        'command'.  First we check the 'cmdclass' dictionary; if the
        command is mentioned there, we fetch the class object from the
        dictionary and return it.  Otherwise we load the command module
        ("distutils.command." + command) and fetch the command class from
        the module.  The loaded class is also stored in 'cmdclass'
        to speed future calls to 'get_command_class()'.

        Raises DistutilsModuleError if the expected module could not be
        found, or if that module does not define the expected class.
        """
        klass = self.cmdclass.get(command)
        if klass:
            return klass

        for pkgname in self.get_command_packages():
            module_name = "%s.%s" % (pkgname, command)
            klass_name = command

            try:
                __import__ (module_name)
                module = sys.modules[module_name]
            except ImportError:
                continue

            try:
                klass = getattr(module, klass_name)
            except AttributeError:
                raise DistutilsModuleError, \
                      "invalid command '%s' (no class '%s' in module '%s')" \
                      % (command, klass_name, module_name)

            self.cmdclass[command] = klass
            return klass

        raise DistutilsModuleError("invalid command '%s'" % command)


    def get_command_obj(self, command, create=1):
        """Return the command object for 'command'.  Normally this object
        is cached on a previous call to 'get_command_obj()'; if no command
        object for 'command' is in the cache, then we either create and
        return it (if 'create' is true) or return None.
        """
        cmd_obj = self.command_obj.get(command)
        if not cmd_obj and create:
            if DEBUG:
                self.announce("Distribution.get_command_obj(): " \
                              "creating '%s' command object" % command)

            klass = self.get_command_class(command)
            cmd_obj = self.command_obj[command] = klass(self)
            self.have_run[command] = 0

            # Set any options that were supplied in config files
            # or on the command line.  (NB. support for error
            # reporting is lame here: any errors aren't reported
            # until 'finalize_options()' is called, which means
            # we won't report the source of the error.)
            options = self.command_options.get(command)
            if options:
                self._set_command_options(cmd_obj, options)

        return cmd_obj

    def _set_command_options(self, command_obj, option_dict=None):
        """Set the options for 'command_obj' from 'option_dict'.  Basically
        this means copying elements of a dictionary ('option_dict') to
        attributes of an instance ('command').

        'command_obj' must be a Command instance.  If 'option_dict' is not
        supplied, uses the standard option dictionary for this command
        (from 'self.command_options').
        """
        command_name = command_obj.get_command_name()
        if option_dict is None:
            option_dict = self.get_option_dict(command_name)

        if DEBUG:
            self.announce("  setting options for '%s' command:" % command_name)
        for (option, (source, value)) in option_dict.items():
            if DEBUG:
                self.announce("    %s = %s (from %s)" % (option, value,
                                                         source))
            try:
                bool_opts = map(translate_longopt, command_obj.boolean_options)
            except AttributeError:
                bool_opts = []
            try:
                neg_opt = command_obj.negative_opt
            except AttributeError:
                neg_opt = {}

            try:
                is_string = isinstance(value, str)
                if option in neg_opt and is_string:
                    setattr(command_obj, neg_opt[option], not strtobool(value))
                elif option in bool_opts and is_string:
                    setattr(command_obj, option, strtobool(value))
                elif hasattr(command_obj, option):
                    setattr(command_obj, option, value)
                else:
                    raise DistutilsOptionError, \
                          ("error in %s: command '%s' has no such option '%s'"
                           % (source, command_name, option))
            except ValueError, msg:
                raise DistutilsOptionError, msg

    def reinitialize_command(self, command, reinit_subcommands=0):
        """Reinitializes a command to the state it was in when first
        returned by 'get_command_obj()': ie., initialized but not yet
        finalized.  This provides the opportunity to sneak option
        values in programmatically, overriding or supplementing
        user-supplied values from the config files and command line.
        You'll have to re-finalize the command object (by calling
        'finalize_options()' or 'ensure_finalized()') before using it for
        real.

        'command' should be a command name (string) or command object.  If
        'reinit_subcommands' is true, also reinitializes the command's
        sub-commands, as declared by the 'sub_commands' class attribute (if
        it has one).  See the "install" command for an example.  Only
        reinitializes the sub-commands that actually matter, ie. those
        whose test predicates return true.

        Returns the reinitialized command object.
        """
        from distutils.cmd import Command
        if not isinstance(command, Command):
            command_name = command
            command = self.get_command_obj(command_name)
        else:
            command_name = command.get_command_name()

        if not command.finalized:
            return command
        command.initialize_options()
        command.finalized = 0
        self.have_run[command_name] = 0
        self._set_command_options(command)

        if reinit_subcommands:
            for sub in command.get_sub_commands():
                self.reinitialize_command(sub, reinit_subcommands)

        return command

    # -- Methods that operate on the Distribution ----------------------

    def announce(self, msg, level=log.INFO):
        log.log(level, msg)

    def run_commands(self):
        """Run each command that was seen on the setup script command line.
        Uses the list of commands found and cache of command objects
        created by 'get_command_obj()'.
        """
        for cmd in self.commands:
            self.run_command(cmd)

    # -- Methods that operate on its Commands --------------------------

    def run_command(self, command):
        """Do whatever it takes to run a command (including nothing at all,
        if the command has already been run).  Specifically: if we have
        already created and run the command named by 'command', return
        silently without doing anything.  If the command named by 'command'
        doesn't even have a command object yet, create one.  Then invoke
        'run()' on that command object (or an existing one).
        """
        # Already been here, done that? then return silently.
        if self.have_run.get(command):
            return

        log.info("running %s", command)
        cmd_obj = self.get_command_obj(command)
        cmd_obj.ensure_finalized()
        cmd_obj.run()
        self.have_run[command] = 1


    # -- Distribution query methods ------------------------------------

    def has_pure_modules(self):
        return len(self.packages or self.py_modules or []) > 0

    def has_ext_modules(self):
        return self.ext_modules and len(self.ext_modules) > 0

    def has_c_libraries(self):
        return self.libraries and len(self.libraries) > 0

    def has_modules(self):
        return self.has_pure_modules() or self.has_ext_modules()

    def has_headers(self):
        return self.headers and len(self.headers) > 0

    def has_scripts(self):
        return self.scripts and len(self.scripts) > 0

    def has_data_files(self):
        return self.data_files and len(self.data_files) > 0

    def is_pure(self):
        return (self.has_pure_modules() and
                not self.has_ext_modules() and
                not self.has_c_libraries())

    # -- Metadata query methods ----------------------------------------

    # If you're looking for 'get_name()', 'get_version()', and so forth,
    # they are defined in a sneaky way: the constructor binds self.get_XXX
    # to self.metadata.get_XXX.  The actual code is in the
    # DistributionMetadata class, below.

class DistributionMetadata:
    """Dummy class to hold the distribution meta-data: name, version,
    author, and so forth.
    """

    _METHOD_BASENAMES = ("name", "version", "author", "author_email",
                         "maintainer", "maintainer_email", "url",
                         "license", "description", "long_description",
                         "keywords", "platforms", "fullname", "contact",
                         "contact_email", "license", "classifiers",
                         "download_url",
                         # PEP 314
                         "provides", "requires", "obsoletes",
                         )

    def __init__(self, path=None):
        if path is not None:
            self.read_pkg_file(open(path))
        else:
            self.name = None
            self.version = None
            self.author = None
            self.author_email = None
            self.maintainer = None
            self.maintainer_email = None
            self.url = None
            self.license = None
            self.description = None
            self.long_description = None
            self.keywords = None
            self.platforms = None
            self.classifiers = None
            self.download_url = None
            # PEP 314
            self.provides = None
            self.requires = None
            self.obsoletes = None

    def read_pkg_file(self, file):
        """Reads the metadata values from a file object."""
        msg = message_from_file(file)

        def _read_field(name):
            value = msg[name]
            if value == 'UNKNOWN':
                return None
            return value

        def _read_list(name):
            values = msg.get_all(name, None)
            if values == []:
                return None
            return values

        metadata_version = msg['metadata-version']
        self.name = _read_field('name')
        self.version = _read_field('version')
        self.description = _read_field('summary')
        # we are filling author only.
        self.author = _read_field('author')
        self.maintainer = None
        self.author_email = _read_field('author-email')
        self.maintainer_email = None
        self.url = _read_field('home-page')
        self.license = _read_field('license')

        if 'download-url' in msg:
            self.download_url = _read_field('download-url')
        else:
            self.download_url = None

        self.long_description = _read_field('description')
        self.description = _read_field('summary')

        if 'keywords' in msg:
            self.keywords = _read_field('keywords').split(',')

        self.platforms = _read_list('platform')
        self.classifiers = _read_list('classifier')

        # PEP 314 - these fields only exist in 1.1
        if metadata_version == '1.1':
            self.requires = _read_list('requires')
            self.provides = _read_list('provides')
            self.obsoletes = _read_list('obsoletes')
        else:
            self.requires = None
            self.provides = None
            self.obsoletes = None

    def write_pkg_info(self, base_dir):
        """Write the PKG-INFO file into the release tree.
        """
        pkg_info = open(os.path.join(base_dir, 'PKG-INFO'), 'w')
        try:
            self.write_pkg_file(pkg_info)
        finally:
            pkg_info.close()

    def write_pkg_file(self, file):
        """Write the PKG-INFO format data to a file object.
        """
        version = '1.0'
        if (self.provides or self.requires or self.obsoletes or
            self.classifiers or self.download_url):
            version = '1.1'

        self._write_field(file, 'Metadata-Version', version)
        self._write_field(file, 'Name', self.get_name())
        self._write_field(file, 'Version', self.get_version())
        self._write_field(file, 'Summary', self.get_description())
        self._write_field(file, 'Home-page', self.get_url())
        self._write_field(file, 'Author', self.get_contact())
        self._write_field(file, 'Author-email', self.get_contact_email())
        self._write_field(file, 'License', self.get_license())
        if self.download_url:
            self._write_field(file, 'Download-URL', self.download_url)

        long_desc = rfc822_escape(self.get_long_description())
        self._write_field(file, 'Description', long_desc)

        keywords = ','.join(self.get_keywords())
        if keywords:
            self._write_field(file, 'Keywords', keywords)

        self._write_list(file, 'Platform', self.get_platforms())
        self._write_list(file, 'Classifier', self.get_classifiers())

        # PEP 314
        self._write_list(file, 'Requires', self.get_requires())
        self._write_list(file, 'Provides', self.get_provides())
        self._write_list(file, 'Obsoletes', self.get_obsoletes())

    def _write_field(self, file, name, value):
        file.write('%s: %s\n' % (name, self._encode_field(value)))

    def _write_list (self, file, name, values):
        for value in values:
            self._write_field(file, name, value)

    def _encode_field(self, value):
        if value is None:
            return None
        if isinstance(value, unicode):
            return value.encode(PKG_INFO_ENCODING)
        return str(value)

    # -- Metadata query methods ----------------------------------------

    def get_name(self):
        return self.name or "UNKNOWN"

    def get_version(self):
        return self.version or "0.0.0"

    def get_fullname(self):
        return "%s-%s" % (self.get_name(), self.get_version())

    def get_author(self):
        return self._encode_field(self.author) or "UNKNOWN"

    def get_author_email(self):
        return self.author_email or "UNKNOWN"

    def get_maintainer(self):
        return self._encode_field(self.maintainer) or "UNKNOWN"

    def get_maintainer_email(self):
        return self.maintainer_email or "UNKNOWN"

    def get_contact(self):
        return (self._encode_field(self.maintainer) or
                self._encode_field(self.author) or "UNKNOWN")

    def get_contact_email(self):
        return self.maintainer_email or self.author_email or "UNKNOWN"

    def get_url(self):
        return self.url or "UNKNOWN"

    def get_license(self):
        return self.license or "UNKNOWN"
    get_licence = get_license

    def get_description(self):
        return self._encode_field(self.description) or "UNKNOWN"

    def get_long_description(self):
        return self._encode_field(self.long_description) or "UNKNOWN"

    def get_keywords(self):
        return self.keywords or []

    def get_platforms(self):
        return self.platforms or ["UNKNOWN"]

    def get_classifiers(self):
        return self.classifiers or []

    def get_download_url(self):
        return self.download_url or "UNKNOWN"

    # PEP 314
    def get_requires(self):
        return self.requires or []

    def set_requires(self, value):
        import distutils.versionpredicate
        for v in value:
            distutils.versionpredicate.VersionPredicate(v)
        self.requires = value

    def get_provides(self):
        return self.provides or []

    def set_provides(self, value):
        value = [v.strip() for v in value]
        for v in value:
            import distutils.versionpredicate
            distutils.versionpredicate.split_provision(v)
        self.provides = value

    def get_obsoletes(self):
        return self.obsoletes or []

    def set_obsoletes(self, value):
        import distutils.versionpredicate
        for v in value:
            distutils.versionpredicate.VersionPredicate(v)
        self.obsoletes = value

def fix_help_options(options):
    """Convert a 4-tuple 'help_options' list as found in various command
    classes to the 3-tuple form required by FancyGetopt.
    """
    new_options = []
    for help_tuple in options:
        new_options.append(help_tuple[0:3])
    return new_options
                                                                                                                               usr/lib/python2.7/distutils/dist.pyc                                                                0100644 0000000 0000000 00000115010 13077704274 016111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s&  d  Z  d Z d d l Z d d l Z d d l Z d d l m Z y d d l Z Wn e k
 ri e	 Z n Xd d l
 m Z m Z m Z m Z d d l m Z m Z d d l m Z m Z m Z d d l m Z d d	 l m Z d
 Z e j d É Z d f  d Ñ  É  YZ d f  d Ñ  É  YZ d Ñ  Z d S(   s}   distutils.dist

Provides the Distribution class, which represents the module distribution
being built/installed/distributed.
s   $Id$iˇˇˇˇN(   t   message_from_file(   t   DistutilsOptionErrort   DistutilsArgErrort   DistutilsModuleErrort   DistutilsClassError(   t   FancyGetoptt   translate_longopt(   t   check_environt	   strtoboolt   rfc822_escape(   t   log(   t   DEBUGs   utf-8s   ^[a-zA-Z]([a-zA-Z0-9_]*)$t   Distributionc           B   s¬  e  Z d  Z d] d^ d_ d` db g Z d Z dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw g Z e d< Ñ  e É Z i d d 6Z	 da d= Ñ Z
 d> Ñ  Z da da d? d@ Ñ Z dA Ñ  Z da dB Ñ Z dC Ñ  Z dD Ñ  Z dE Ñ  Z dF Ñ  Z d d g  dG Ñ Z dH Ñ  Z dI Ñ  Z dJ Ñ  Z dK Ñ  Z dL Ñ  Z dM Ñ  Z d dN Ñ Z da dO Ñ Z dP dQ Ñ Z e j dR Ñ Z dS Ñ  Z  dT Ñ  Z! dU Ñ  Z" dV Ñ  Z# dW Ñ  Z$ dX Ñ  Z% dY Ñ  Z& dZ Ñ  Z' d[ Ñ  Z( d\ Ñ  Z) RS(x   sΩ  The core of the Distutils.  Most of the work hiding behind 'setup'
    is really done within a Distribution instance, which farms the work out
    to the Distutils commands specified on the command line.

    Setup scripts will almost never instantiate Distribution directly,
    unless the 'setup()' function is totally inadequate to their needs.
    However, it is conceivable that a setup script might wish to subclass
    Distribution for some specialized purpose, and then pass the subclass
    to 'setup()' as the 'distclass' keyword argument.  If so, it is
    necessary to respect the expectations that 'setup' has of Distribution.
    See the code for 'setup()', in core.py, for details.
    t   verboset   vs   run verbosely (default)i   t   quiett   qs!   run quietly (turns verbosity off)s   dry-runt   ns   don't actually do anythingt   helpt   hs   show detailed help messages   no-user-cfgs-   ignore pydistutils.cfg in your home directorys£   Common commands: (see '--help-commands' for more)

  setup.py build      will build the package underneath 'build/'
  setup.py install    will install the package
s   help-commandss   list all available commandst   names   print package namet   versiont   Vs   print package versiont   fullnames   print <package name>-<version>t   authors   print the author's names   author-emails    print the author's email addresst
   maintainers   print the maintainer's names   maintainer-emails$   print the maintainer's email addresst   contacts7   print the maintainer's name if known, else the author'ss   contact-emails@   print the maintainer's email address if known, else the author'st   urls   print the URL for this packaget   licenses    print the license of the packaget   licences   alias for --licenset   descriptions   print the package descriptions   long-descriptions"   print the long package descriptiont	   platformss   print the list of platformst   classifierss   print the list of classifierst   keywordss   print the list of keywordst   providess+   print the list of packages/modules providedt   requiress+   print the list of packages/modules requiredt	   obsoletess0   print the list of packages/modules made obsoletec         C   s   t  |  d É S(   Ni    (   R   (   t   x(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   <lambda>w   s    c         C   si  d |  _  d |  _ d |  _ x! |  j D] } t |  | d É q% Wt É  |  _ x: |  j j D], } d | } t |  | t |  j | É É qX Wi  |  _	 d |  _ d |  _ d |  _ i  |  _ g  |  _ d |  _ i  |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ i  |  _ i  |  _ | r | j d É } | d k	 r…| d =xY | j  É  D]H \ } } |  j! | É } x* | j  É  D] \ }	 }
 d |
 f | |	 <q¢WqzWn  d | k r#| d | d <| d =d	 } t" d k	 rt" j# | É q#t$ j% j& | d
 É n  x⁄ | j  É  D]… \ } }
 t' |  j d | É rot |  j d | É |
 É q0t' |  j | É rót |  j | |
 É q0t' |  | É rπt |  | |
 É q0d t( | É } t" d k	 rÂt" j# | É q0t$ j% j& | d
 É q0Wn  t) |  _* |  j d k	 r[x@ |  j D]2 } | j+ d É s;Pn  | d k r"t, |  _* Pq"q"Wn  |  j- É  d S(   s0  Construct a new Distribution instance: initialize all the
        attributes of a Distribution, and then use 'attrs' (a dictionary
        mapping attribute names to values) to assign some of those
        attributes their "real" values.  (Any attributes not mentioned in
        'attrs' will be assigned to some null value: 0, None, an empty list
        or dictionary, etc.)  Most importantly, initialize the
        'command_obj' attribute to the empty dictionary; this will be
        filled in with real command objects by 'parse_command_line()'.
        i   i    t   get_t    t   optionss   setup scriptR   R   s:   'licence' distribution option is deprecated; use 'license's   
t   set_s   Unknown distribution option: %st   -s   --no-user-cfgN(.   R   t   dry_runR   t   display_option_namest   setattrt   DistributionMetadatat   metadatat   _METHOD_BASENAMESt   getattrt   cmdclasst   Nonet   command_packagest   script_namet   script_argst   command_optionst
   dist_filest   packagest   package_datat   package_dirt
   py_modulest	   librariest   headerst   ext_modulest   ext_packaget   include_dirst
   extra_patht   scriptst
   data_filest   passwordt   command_objt   have_runt   gett   itemst   get_option_dictt   warningst   warnt   syst   stderrt   writet   hasattrt   reprt   Truet   want_user_cfgt
   startswitht   Falset   finalize_options(   t   selft   attrst   attrt   basenamet   method_nameR)   t   commandt   cmd_optionst   opt_dictt   optt   valt   msgt   keyt   arg(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   __init__Ä   sÇ    			
 																							c         C   s6   |  j  j | É } | d k r2 i  } |  j  | <n  | S(   sÌ   Get the option dictionary for a given command.  If that
        command's option dictionary hasn't been created yet, then create it
        and return the new dictionary; otherwise, return the existing
        option dictionary.
        N(   R8   RI   R4   (   RX   R]   t   dict(    (    s$   /usr/lib/python2.7/distutils/dist.pyRK   !  s    R(   c   	      C   s  d d l  m } | d  k r8 |  j j É  } | j É  n  | d  k	 rb |  j | | É | d } n  | s} |  j | d É d  Sxî | D]å } |  j j | É } | d  k r¿ |  j | d | É qÑ |  j | d | É | | É } x, | j d É D] } |  j | d | É qÒ WqÑ Wd  S(   Niˇˇˇˇ(   t   pformats     s   no commands known yets   no option dict for '%s' commands   option dict for '%s' command:s   
(	   t   pprintRg   R4   R8   t   keyst   sortt   announceRI   t   split(	   RX   t   headert   commandst   indentRg   t   cmd_nameR_   t   outt   line(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   dump_option_dicts,  s(    		c         C   s  g  } t  É  t j j t j d j É } t j j | d É } t j j | É r` | j	 | É n  t j
 d k rx d } n d } |  j rÕ t j j t j j d É | É } t j j | É rÕ | j	 | É qÕ n  d } t j j | É rı | j	 | É n  t r|  j d d	 j | É É n  | S(
   sæ  Find as many configuration files as should be processed for this
        platform, and return a list of filenames in the order in which they
        should be parsed.  The filenames returned are guaranteed to exist
        (modulo nasty race conditions).

        There are three possible config files: distutils.cfg in the
        Distutils installation directory (ie. where the top-level
        Distutils __inst__.py file lives), a file in the user's home
        directory named .pydistutils.cfg on Unix and pydistutils.cfg
        on Windows/Mac; and setup.cfg in the current directory.

        The file in the user's home directory can be disabled with the
        --no-user-cfg option.
        t	   distutilss   distutils.cfgt   posixs   .pydistutils.cfgs   pydistutils.cfgt   ~s	   setup.cfgs   using config files: %ss   , (   R   t   ost   patht   dirnameRN   t   modulest   __file__t   joint   isfilet   appendR   RT   t
   expanduserR   Rk   (   RX   t   filest   sys_dirt   sys_filet   user_filenamet	   user_filet
   local_file(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   find_config_filesI  s&    		!c         C   sﬂ  d d l  m  } | d  k r+ |  j É  } n  t rA |  j d É n  | É  } x» | D]¿ } t rq |  j d | É n  | j | É xÜ | j É  D]x } | j | É } |  j | É } xQ | D]I } | d k r∂ | j	 | | É }	 | j
 d d É } | |	 f | | <q∂ q∂ Wqã W| j É  qQ Wd |  j k r€x¥ |  j d j É  D]ú \ } \ }
 }	 |  j j	 | É } yY | rt |  | t |	 É É n5 | d k r§t |  | t |	 É É n t |  | |	 É Wq8t k
 r”} t | Ç q8Xq8Wn  d  S(   Niˇˇˇˇ(   t   ConfigParsers"   Distribution.parse_config_files():s     reading %st   __name__R+   t   _t   globalR   R,   (   s   verboses   dry_run(   Rá   R4   RÜ   R   Rk   t   readt   sectionsR)   RK   RI   t   replaceRe   R8   RJ   t   negative_optR.   R   t
   ValueErrorR   (   RX   t	   filenamesRá   t   parsert   filenamet   sectionR)   R_   R`   Ra   t   srct   aliasRb   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   parse_config_filesy  s<    	&c         C   s  |  j  É  } g  |  _ t | |  j É } | j |  j É | j i d d 6É | j d |  j d |  É } | j	 É  } t
 j |  j É |  j | É rñ d Sx, | rƒ |  j | | É } | d k rô d Sqô W|  j r˝ |  j | d t |  j É d k d |  j Éd S|  j st d	 Ç n  d
 S(   sá  Parse the setup script's command line, taken from the
        'script_args' instance attribute (which defaults to 'sys.argv[1:]'
        -- see 'setup()' in core.py).  This list is first processed for
        "global options" -- options that set attributes of the Distribution
        instance.  Then, it is alternately scanned for Distutils commands
        and options for that command.  Each new command terminates the
        options for the previous command.  The allowed options for a
        command are determined by the 'user_options' attribute of the
        command class -- thus, we have to be able to load command classes
        in order to parse the command line.  Any error in that 'options'
        attribute raises DistutilsGetoptError; any error on the
        command-line raises DistutilsArgError.  If no Distutils commands
        were found on the command line, raises DistutilsArgError.  Return
        true if command-line was successfully parsed and we should carry
        on with executing commands; false if no errors but we shouldn't
        execute commands (currently, this only happens if user asks for
        help).
        R   R   t   argst   objectNt   display_optionsi    Rn   s   no commands suppliedi   (   t   _get_toplevel_optionsRn   R   Rô   t   set_negative_aliasesRé   t   set_aliasest   getoptR7   t   get_option_orderR
   t   set_verbosityR   t   handle_display_optionst   _parse_command_optsR4   R   t
   _show_helpt   lenR   (   RX   t   toplevel_optionsRë   Ró   t   option_order(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   parse_command_lineß  s,    				
	c         C   s   |  j  d g S(   s√   Return the non-display options recognized at the top level.

        This includes options that are recognized *only* at the top
        level as well as options recognized for commands.
        s   command-packages=s0   list of packages that provide distutils commandsN(   s   command-packages=Ns0   list of packages that provide distutils commands(   t   global_optionsR4   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyRö   Í  s     c         C   s¢  d d l  m } | d } t j | É s9 t d | Ç n  |  j j | É y |  j | É } Wn t k
 rz } t	 | Ç n Xt
 | | É sö t d | Ç n  t | d É o∏ t | j t É sœ t d d | Ç n  |  j } t | d	 É r| j É  } | j | j É n  t | d
 É r9t | j t É r9t | j É } n g  } | j |  j | j | É | j | É | j | d É \ } }	 t |	 d É r∏|	 j r∏|  j | d d d | g Éd St | d
 É r\t | j t É r\d }
 xm | j D]b \ } } } } t |	 | j | É É rÈd }
 t | d É r2| É  qKt d | | f É Ç qÈqÈW|
 r\d Sn  |  j | É } x0 t |	 É j É  D] \ } } d | f | | <q~W| S(   s⁄  Parse the command-line options for a single command.
        'parser' must be a FancyGetopt instance; 'args' must be the list
        of arguments, starting with the current command (whose options
        we are about to parse).  Returns a new version of 'args' with
        the next command at the front of the list; will be the empty
        list if there are no more commands on the command line.  Returns
        None if the user asked for help on this command.
        iˇˇˇˇ(   t   Commandi    s   invalid command name '%s's&   command class %s must subclass Commandt   user_optionss   command class %s must provide s+   'user_options' attribute (a list of tuples)Ré   t   help_optionsi   R   Rô   Rn   Nt   __call__sY   invalid help function %r for help option '%s': must be a callable object (function, etc.)s   command line(   t   distutils.cmdR®   t
   command_ret   matcht
   SystemExitRn   R~   t   get_command_classR   R   t
   issubclassR   RQ   t
   isinstanceR©   t   listRé   t   copyt   updateR™   t   fix_help_optionst   set_option_tableRß   Rõ   Rù   R   R¢   t   get_attr_nameRK   t   varsRJ   (   RX   Rë   Ró   R®   R]   t	   cmd_classRb   Ré   R™   t   optst   help_option_foundt   help_optiont   shortt   desct   funcR_   R   t   value(    (    s$   /usr/lib/python2.7/distutils/dist.pyR°   ı  sf    


	
c         C   sÜ   x d D]w } t  |  j | É } | d k r1 q n  t | t É r g  | j d É D] } | j É  ^ qP } t |  j | | É q q Wd S(   sõ   Set final values for all the options on the Distribution
        instance, analogous to the .finalize_options() method of Command
        objects.
        R!   R   t   ,N(   s   keywordss	   platforms(   R2   R0   R4   R≤   t   strRl   t   stripR.   (   RX   RZ   R¡   t   elm(    (    s$   /usr/lib/python2.7/distutils/dist.pyRW   R  s    (c   
      C   sb  d d l  m } d d l m } | rm | r; |  j É  } n	 |  j } | j | É | j |  j d É d GHn  | rú | j |  j	 É | j d d É d GHn  x± |  j
 D]¶ } t | t É r” t | | É r” | }	 n |  j | É }	 t |	 d É r#t |	 j t É r#| j |	 j t |	 j É É n | j |	 j É | j d	 |	 j É d GHq¶ W| |  j É GHd
 S(   sb  Show help for the setup script command-line in the form of
        several lists of command-line options.  'parser' should be a
        FancyGetopt instance; do not expect it to be returned in the
        same state, as its option table will be reset to make it
        generate the correct help text.

        If 'global_options' is true, lists the global options:
        --verbose, --dry-run, etc.  If 'display_options' is true, lists
        the "display-only" options: --name, --version, etc.  Finally,
        lists per-command help for every command name or command class
        in 'commands'.
        iˇˇˇˇ(   t	   gen_usage(   R®   s   
Global options:R(   s*   Information display options (just display s!   information, ignore any commands)R™   s   Options for '%s' command:N(   t   distutils.coreR∆   R¨   R®   Rö   Rß   R∑   t
   print_helpt   common_usageRô   Rn   R≤   t   typeR±   R∞   RQ   R™   R≥   R©   R∂   Rà   R6   (
   RX   Rë   Rß   Rô   Rn   R∆   R®   R)   R]   t   klass(    (    s$   /usr/lib/python2.7/distutils/dist.pyR¢   _  s6    			c   	      C   s  d d l  m } |  j r: |  j É  d GH| |  j É GHd Sd } i  } x |  j D] } d | | d <qP Wxñ | D]é \ } } | ro | j | É ro t | É } t |  j	 d | É É  } | d k r“ d	 j
 | É GHn" | d k rÔ d j
 | É GHn | GHd } qo qo W| S(   s⁄   If there were any non-global "display-only" options
        (--help-commands or the metadata display options) on the command
        line, display the requested info and return true; else return
        false.
        iˇˇˇˇ(   R∆   R(   i   i    R'   R!   R   R¬   R    R"   R#   R$   s   
(   s   keywordss	   platforms(   s   classifierss   providess   requiress	   obsoletes(   R«   R∆   t   help_commandst   print_commandsR6   Rô   RI   R   R2   R0   R|   (	   RX   R•   R∆   t   any_display_optionst   is_display_optiont   optionR`   Ra   R¡   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR†   ë  s,    	
	c         C   sÅ   | d GHxq | D]i } |  j  j | É } | s@ |  j | É } n  y | j } Wn t k
 rf d } n Xd | | | f GHq Wd S(   sZ   Print a subset of the list of all commands -- used by
        'print_commands()'.
        t   :s   (no description available)s
     %-*s  %sN(   R3   RI   R∞   R   t   AttributeError(   RX   Rn   Rm   t
   max_lengtht   cmdRÀ   R   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   print_command_listπ  s    	
c         C   sË   d d l  } | j j } i  } x | D] } d | | <q% Wg  } x6 |  j j É  D]% } | j | É sO | j | É qO qO Wd } x3 | | D]' } t | É | k râ t | É } qâ qâ W|  j | d | É | r‰ H|  j | d | É n  d S(   sn  Print out a help message listing all available commands with a
        description of each.  The list is divided into "standard commands"
        (listed in distutils.command.__all__) and "extra commands"
        (mentioned in self.cmdclass, but not a standard command).  The
        descriptions come from the command class attribute
        'description'.
        iˇˇˇˇNi   i    s   Standard commandss   Extra commands(	   t   distutils.commandR]   t   __all__R3   Ri   RI   R~   R£   R’   (   RX   Rt   t   std_commandst   is_stdR‘   t   extra_commandsR”   (    (    s$   /usr/lib/python2.7/distutils/dist.pyRÕ      s*    		c   	      C   s˚   d d l  } | j j } i  } x | D] } d | | <q% Wg  } x6 |  j j É  D]% } | j | É sO | j | É qO qO Wg  } xv | | D]j } |  j j | É } | sπ |  j | É } n  y | j } Wn t	 k
 rﬂ d } n X| j | | f É qâ W| S(   s>  Get a list of (command, description) tuples.
        The list is divided into "standard commands" (listed in
        distutils.command.__all__) and "extra commands" (mentioned in
        self.cmdclass, but not a standard command).  The descriptions come
        from the command class attribute 'description'.
        iˇˇˇˇNi   s   (no description available)(
   R÷   R]   R◊   R3   Ri   RI   R~   R∞   R   R“   (	   RX   Rt   Rÿ   RŸ   R‘   R⁄   t   rvRÀ   R   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_command_listÎ  s(    

c         C   sê   |  j  } t | t É så | d k r- d } n  g  | j d É D] } | d k r= | j É  ^ q= } d | k rÄ | j d d É n  | |  _  n  | S(   s9   Return a list of packages from which commands are loaded.R(   R¬   s   distutils.commandi    N(   R5   R≤   R≥   R4   Rl   Rƒ   t   insert(   RX   t   pkgst   pkg(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_command_packages  s    		4c         C   s⁄   |  j  j | É } | r | Sxß |  j É  D]ô } d | | f } | } y t | É t j | } Wn t k
 rv q) n Xy t | | É } Wn' t k
 r≥ t	 d | | | f Ç n X| |  j  | <| SWt	 d | É Ç d S(   so  Return the class that implements the Distutils command named by
        'command'.  First we check the 'cmdclass' dictionary; if the
        command is mentioned there, we fetch the class object from the
        dictionary and return it.  Otherwise we load the command module
        ("distutils.command." + command) and fetch the command class from
        the module.  The loaded class is also stored in 'cmdclass'
        to speed future calls to 'get_command_class()'.

        Raises DistutilsModuleError if the expected module could not be
        found, or if that module does not define the expected class.
        s   %s.%ss3   invalid command '%s' (no class '%s' in module '%s')s   invalid command '%s'N(
   R3   RI   R‡   t
   __import__RN   Rz   t   ImportErrorR2   R“   R   (   RX   R]   RÀ   t   pkgnamet   module_namet
   klass_namet   module(    (    s$   /usr/lib/python2.7/distutils/dist.pyR∞     s(    
c         C   sû   |  j  j | É } | rö | rö t r9 |  j d | É n  |  j | É } | |  É } |  j  | <d |  j | <|  j j | É } | rö |  j | | É qö n  | S(   s  Return the command object for 'command'.  Normally this object
        is cached on a previous call to 'get_command_obj()'; if no command
        object for 'command' is in the cache, then we either create and
        return it (if 'create' is true) or return None.
        s<   Distribution.get_command_obj(): creating '%s' command objecti    (   RG   RI   R   Rk   R∞   RH   R8   t   _set_command_options(   RX   R]   t   createt   cmd_objRÀ   R)   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_command_objA  s    	c         C   s™  | j  É  } | d k r* |  j | É } n  t rD |  j d | É n  x_| j É  D]Q\ } \ } } t rÜ |  j d | | | f É n  y t t | j É } Wn t	 k
 rµ g  } n Xy | j
 } Wn t	 k
 r‹ i  } n Xy¶ t | t É }	 | | k r|	 rt | | | t | É É nc | | k rJ|	 rJt | | t | É É n8 t | | É rlt | | | É n t d | | | f Ç WqQ t k
 r°}
 t |
 Ç qQ XqQ Wd S(   sy  Set the options for 'command_obj' from 'option_dict'.  Basically
        this means copying elements of a dictionary ('option_dict') to
        attributes of an instance ('command').

        'command_obj' must be a Command instance.  If 'option_dict' is not
        supplied, uses the standard option dictionary for this command
        (from 'self.command_options').
        s#     setting options for '%s' command:s       %s = %s (from %s)s1   error in %s: command '%s' has no such option '%s'N(   t   get_command_nameR4   RK   R   Rk   RJ   t   mapR   t   boolean_optionsR“   Ré   R≤   R√   R.   R   RQ   R   Rè   (   RX   RG   t   option_dictt   command_nameR–   t   sourceR¡   t	   bool_optst   neg_optt	   is_stringRb   (    (    s$   /usr/lib/python2.7/distutils/dist.pyRÁ   \  s<    	

i    c         C   s±   d d l  m } t | | É s7 | } |  j | É } n | j É  } | j sP | S| j É  d | _ d |  j | <|  j | É | r≠ x' | j	 É  D] } |  j
 | | É qê Wn  | S(   s≥  Reinitializes a command to the state it was in when first
        returned by 'get_command_obj()': ie., initialized but not yet
        finalized.  This provides the opportunity to sneak option
        values in programmatically, overriding or supplementing
        user-supplied values from the config files and command line.
        You'll have to re-finalize the command object (by calling
        'finalize_options()' or 'ensure_finalized()') before using it for
        real.

        'command' should be a command name (string) or command object.  If
        'reinit_subcommands' is true, also reinitializes the command's
        sub-commands, as declared by the 'sub_commands' class attribute (if
        it has one).  See the "install" command for an example.  Only
        reinitializes the sub-commands that actually matter, ie. those
        whose test predicates return true.

        Returns the reinitialized command object.
        iˇˇˇˇ(   R®   i    (   R¨   R®   R≤   RÍ   RÎ   t	   finalizedt   initialize_optionsRH   RÁ   t   get_sub_commandst   reinitialize_command(   RX   R]   t   reinit_subcommandsR®   RÔ   t   sub(    (    s$   /usr/lib/python2.7/distutils/dist.pyR˜   á  s    	
	c         C   s   t  j  | | É d  S(   N(   R
   (   RX   Rb   t   level(    (    s$   /usr/lib/python2.7/distutils/dist.pyRk   ∞  s    c         C   s%   x |  j  D] } |  j | É q
 Wd S(   s∂   Run each command that was seen on the setup script command line.
        Uses the list of commands found and cache of command objects
        created by 'get_command_obj()'.
        N(   Rn   t   run_command(   RX   R‘   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   run_commands≥  s    c         C   sZ   |  j  j | É r d St j d | É |  j | É } | j É  | j É  d |  j  | <d S(   s™  Do whatever it takes to run a command (including nothing at all,
        if the command has already been run).  Specifically: if we have
        already created and run the command named by 'command', return
        silently without doing anything.  If the command named by 'command'
        doesn't even have a command object yet, create one.  Then invoke
        'run()' on that command object (or an existing one).
        Ns
   running %si   (   RH   RI   R
   t   infoRÍ   t   ensure_finalizedt   run(   RX   R]   RÈ   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR˚   Ω  s    	

c         C   s"   t  |  j p |  j p g  É d k S(   Ni    (   R£   R:   R=   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_pure_modules“  s    c         C   s   |  j  o t |  j  É d k S(   Ni    (   R@   R£   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_ext_modules’  s    c         C   s   |  j  o t |  j  É d k S(   Ni    (   R>   R£   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_c_librariesÿ  s    c         C   s   |  j  É  p |  j É  S(   N(   R   R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_modules€  s    c         C   s   |  j  o t |  j  É d k S(   Ni    (   R?   R£   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_headersﬁ  s    c         C   s   |  j  o t |  j  É d k S(   Ni    (   RD   R£   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_scripts·  s    c         C   s   |  j  o t |  j  É d k S(   Ni    (   RE   R£   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   has_data_files‰  s    c         C   s$   |  j  É  o# |  j É  o# |  j É  S(   N(   R   R  R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   is_pureÁ  s    (   s   verboseR   s   run verbosely (default)i   (   R   R   s!   run quietly (turns verbosity off)(   s   dry-runR   s   don't actually do anything(   s   helpR   s   show detailed help messageN(   s   no-user-cfgNs-   ignore pydistutils.cfg in your home directory(   s   help-commandsNs   list all available commands(   s   nameNs   print package name(   s   versionR   s   print package version(   s   fullnameNs   print <package name>-<version>(   s   authorNs   print the author's name(   s   author-emailNs    print the author's email address(   s
   maintainerNs   print the maintainer's name(   s   maintainer-emailNs$   print the maintainer's email address(   R   Ns7   print the maintainer's name if known, else the author's(   s   contact-emailNs@   print the maintainer's email address if known, else the author's(   s   urlNs   print the URL for this package(   s   licenseNs    print the license of the package(   s   licenceNs   alias for --license(   s   descriptionNs   print the package description(   s   long-descriptionNs"   print the long package description(   s	   platformsNs   print the list of platforms(   s   classifiersNs   print the list of classifiers(   s   keywordsNs   print the list of keywords(   s   providesNs+   print the list of packages/modules provided(   s   requiresNs+   print the list of packages/modules required(   s	   obsoletesNs0   print the list of packages/modules made obsolete(*   Rà   t
   __module__t   __doc__R4   Rß   R…   Rô   RÏ   R-   Ré   Re   RK   Rs   RÜ   Rñ   R¶   Rö   R°   RW   R¢   R†   R’   RÕ   R‹   R‡   R∞   RÍ   RÁ   R˜   R
   t   INFORk   R¸   R˚   R   R  R  R  R  R  R  R  (    (    (    s$   /usr/lib/python2.7/distutils/dist.pyR   "   s®    	
                     			°		0.	C		]	1	(		!	#		'+)	
								R/   c           B   s+  e  Z d  Z d3 Z d4 d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d  Ñ  Z d! Ñ  Z d" Ñ  Z d# Ñ  Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z e Z d' Ñ  Z d( Ñ  Z d) Ñ  Z d* Ñ  Z d+ Ñ  Z d, Ñ  Z d- Ñ  Z d. Ñ  Z d/ Ñ  Z  d0 Ñ  Z! d1 Ñ  Z" d2 Ñ  Z# RS(5   s]   Dummy class to hold the distribution meta-data: name, version,
    author, and so forth.
    R   R   R   t   author_emailR   t   maintainer_emailR   R   R   t   long_descriptionR!   R   R   R   t   contact_emailR    t   download_urlR"   R#   R$   c         C   sø   | d  k	 r" |  j t | É É nô d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   R4   t   read_pkg_filet   openR   R   R   R  R   R  R   R   R   R  R!   R   R    R  R"   R#   R$   (   RX   Rx   (    (    s$   /usr/lib/python2.7/distutils/dist.pyRe     s&    																c            sî  t  | É â  á  f d Ü  } á  f d Ü  } à  d } | d É |  _ | d É |  _ | d É |  _ | d É |  _ d |  _ | d É |  _ d |  _ | d	 É |  _	 | d
 É |  _
 d à  k rÕ | d É |  _ n	 d |  _ | d É |  _ | d É |  _ d à  k r| d É j d É |  _ n  | d É |  _ | d É |  _ | d k ru| d É |  _ | d É |  _ | d É |  _ n d |  _ d |  _ d |  _ d S(   s-   Reads the metadata values from a file object.c            s   à  |  } | d k r d  S| S(   Nt   UNKNOWN(   R4   (   R   R¡   (   Rb   (    s$   /usr/lib/python2.7/distutils/dist.pyt   _read_field  s    
c            s&   à  j  |  d  É } | g  k r" d  S| S(   N(   t   get_allR4   (   R   t   values(   Rb   (    s$   /usr/lib/python2.7/distutils/dist.pyt
   _read_list#  s    s   metadata-versionR   R   t   summaryR   s   author-emails	   home-pageR   s   download-urlR   R!   R¬   t   platformt
   classifiers   1.1R#   R"   R$   N(   R    R   R   R   R   R4   R   R  R  R   R   R  R  Rl   R!   R   R    R#   R"   R$   (   RX   t   fileR  R  t   metadata_version(    (   Rb   s$   /usr/lib/python2.7/distutils/dist.pyR    s:    
					c         C   sA   t  t j j | d É d É } z |  j | É Wd | j É  Xd S(   s7   Write the PKG-INFO file into the release tree.
        s   PKG-INFOt   wN(   R  Rw   Rx   R|   t   write_pkg_filet   close(   RX   t   base_dirt   pkg_info(    (    s$   /usr/lib/python2.7/distutils/dist.pyt   write_pkg_infoM  s    c         C   s˜  d } |  j  s3 |  j s3 |  j s3 |  j s3 |  j r< d } n  |  j | d | É |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j	 É  É |  j | d |  j
 É  É |  j | d	 |  j É  É |  j | d
 |  j É  É |  j r |  j | d |  j É n  t |  j É  É } |  j | d | É d j |  j É  É } | rv|  j | d | É n  |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É d S(   s9   Write the PKG-INFO format data to a file object.
        s   1.0s   1.1s   Metadata-Versiont   Namet   Versiont   Summarys	   Home-paget   Authors   Author-emailt   Licenses   Download-URLt   DescriptionR¬   t   Keywordst   Platformt
   Classifiert   Requirest   Providest	   ObsoletesN(   R"   R#   R$   R    R  t   _write_fieldt   get_namet   get_versiont   get_descriptiont   get_urlt   get_contactt   get_contact_emailt   get_licenseR	   t   get_long_descriptionR|   t   get_keywordst   _write_listt   get_platformst   get_classifierst   get_requirest   get_providest   get_obsoletes(   RX   R  R   t	   long_descR!   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR  V  s0    		c         C   s$   | j  d | |  j | É f É d  S(   Ns   %s: %s
(   RP   t   _encode_field(   RX   R  R   R¡   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR.  x  s    c         C   s(   x! | D] } |  j  | | | É q Wd  S(   N(   R.  (   RX   R  R   R  R¡   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR8  {  s    c         C   s6   | d  k r d  St | t É r, | j t É St | É S(   N(   R4   R≤   t   unicodet   encodet   PKG_INFO_ENCODINGR√   (   RX   R¡   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR?    s
    c         C   s   |  j  p d S(   NR  (   R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR/  à  s    c         C   s   |  j  p d S(   Ns   0.0.0(   R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR0  ã  s    c         C   s   d |  j  É  |  j É  f S(   Ns   %s-%s(   R/  R0  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_fullnameé  s    c         C   s   |  j  |  j É p d S(   NR  (   R?  R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt
   get_authorë  s    c         C   s   |  j  p d S(   NR  (   R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_author_emailî  s    c         C   s   |  j  |  j É p d S(   NR  (   R?  R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_maintaineró  s    c         C   s   |  j  p d S(   NR  (   R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_maintainer_emailö  s    c         C   s(   |  j  |  j É p' |  j  |  j É p' d S(   NR  (   R?  R   R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR3  ù  s    c         C   s   |  j  p |  j p d S(   NR  (   R  R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR4  °  s    c         C   s   |  j  p d S(   NR  (   R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR2  §  s    c         C   s   |  j  p d S(   NR  (   R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR5  ß  s    c         C   s   |  j  |  j É p d S(   NR  (   R?  R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR1  ´  s    c         C   s   |  j  |  j É p d S(   NR  (   R?  R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR6  Æ  s    c         C   s   |  j  p g  S(   N(   R!   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR7  ±  s    c         C   s   |  j  p d g S(   NR  (   R   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR9  ¥  s    c         C   s   |  j  p g  S(   N(   R    (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR:  ∑  s    c         C   s   |  j  p d S(   NR  (   R  (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   get_download_url∫  s    c         C   s   |  j  p g  S(   N(   R#   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR;  æ  s    c         C   s:   d d  l  } x | D] } | j j | É q W| |  _ d  S(   Niˇˇˇˇ(   t   distutils.versionpredicatet   versionpredicatet   VersionPredicateR#   (   RX   R¡   Rt   R   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   set_requires¡  s    c         C   s   |  j  p g  S(   N(   R"   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR<  «  s    c         C   sY   g  | D] } | j  É  ^ q } x* | D]" } d d  l } | j j | É q& W| |  _ d  S(   Niˇˇˇˇ(   Rƒ   RI  RJ  t   split_provisionR"   (   RX   R¡   R   Rt   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   set_provides   s
    c         C   s   |  j  p g  S(   N(   R$   (   RX   (    (    s$   /usr/lib/python2.7/distutils/dist.pyR=  —  s    c         C   s:   d d  l  } x | D] } | j j | É q W| |  _ d  S(   Niˇˇˇˇ(   RI  RJ  RK  R$   (   RX   R¡   Rt   R   (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   set_obsoletes‘  s    (   s   names   versions   authors   author_emails
   maintainers   maintainer_emails   urls   licenses   descriptions   long_descriptions   keywordss	   platformss   fullnames   contactR  s   licenses   classifierss   download_urls   providess   requiress	   obsoletesN($   Rà   R  R	  R1   R4   Re   R  R!  R  R.  R8  R?  R/  R0  RC  RD  RE  RF  RG  R3  R4  R2  R5  t   get_licenceR1  R6  R7  R9  R:  RH  R;  RL  R<  RN  R=  RO  (    (    (    s$   /usr/lib/python2.7/distutils/dist.pyR/   Û  sN         	4			"																										c         C   s/   g  } x" |  D] } | j  | d d !É q W| S(   s   Convert a 4-tuple 'help_options' list as found in various command
    classes to the 3-tuple form required by FancyGetopt.
    i    i   (   R~   (   R)   t   new_optionst
   help_tuple(    (    s$   /usr/lib/python2.7/distutils/dist.pyR∂   ⁄  s    (    R	  t   __revision__RN   Rw   t   ret   emailR    RL   R‚   R4   t   distutils.errorsR   R   R   R   t   distutils.fancy_getoptR   R   t   distutils.utilR   R   R	   Rt   R
   t   distutils.debugR   RB  t   compileR≠   R   R/   R∂   (    (    (    s$   /usr/lib/python2.7/distutils/dist.pyt   <module>   s(   $
"ˇ ˇ ˇ ‘Á                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/distutils/emxccompiler.py                                                         0100644 0000000 0000000 00000027233 12734733743 017505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.emxccompiler

Provides the EMXCCompiler class, a subclass of UnixCCompiler that
handles the EMX port of the GNU C compiler to OS/2.
"""

# issues:
#
# * OS/2 insists that DLLs can have names no longer than 8 characters
#   We put export_symbols in a def-file, as though the DLL can have
#   an arbitrary length name, but truncate the output filename.
#
# * only use OMF objects and use LINK386 as the linker (-Zomf)
#
# * always build for multithreading (-Zmt) as the accompanying OS/2 port
#   of Python is only distributed with threads enabled.
#
# tested configurations:
#
# * EMX gcc 2.81/EMX 0.9d fix03

__revision__ = "$Id$"

import os,sys,copy
from distutils.ccompiler import gen_preprocess_options, gen_lib_options
from distutils.unixccompiler import UnixCCompiler
from distutils.file_util import write_file
from distutils.errors import DistutilsExecError, CompileError, UnknownFileError
from distutils import log

class EMXCCompiler (UnixCCompiler):

    compiler_type = 'emx'
    obj_extension = ".obj"
    static_lib_extension = ".lib"
    shared_lib_extension = ".dll"
    static_lib_format = "%s%s"
    shared_lib_format = "%s%s"
    res_extension = ".res"      # compiled resource file
    exe_extension = ".exe"

    def __init__ (self,
                  verbose=0,
                  dry_run=0,
                  force=0):

        UnixCCompiler.__init__ (self, verbose, dry_run, force)

        (status, details) = check_config_h()
        self.debug_print("Python's GCC status: %s (details: %s)" %
                         (status, details))
        if status is not CONFIG_H_OK:
            self.warn(
                "Python's pyconfig.h doesn't seem to support your compiler.  " +
                ("Reason: %s." % details) +
                "Compiling may fail because of undefined preprocessor macros.")

        (self.gcc_version, self.ld_version) = \
            get_versions()
        self.debug_print(self.compiler_type + ": gcc %s, ld %s\n" %
                         (self.gcc_version,
                          self.ld_version) )

        # Hard-code GCC because that's what this is all about.
        # XXX optimization, warnings etc. should be customizable.
        self.set_executables(compiler='gcc -Zomf -Zmt -O3 -fomit-frame-pointer -mprobe -Wall',
                             compiler_so='gcc -Zomf -Zmt -O3 -fomit-frame-pointer -mprobe -Wall',
                             linker_exe='gcc -Zomf -Zmt -Zcrtdll',
                             linker_so='gcc -Zomf -Zmt -Zcrtdll -Zdll')

        # want the gcc library statically linked (so that we don't have
        # to distribute a version dependent on the compiler we have)
        self.dll_libraries=["gcc"]

    # __init__ ()

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        if ext == '.rc':
            # gcc requires '.rc' compiled to binary ('.res') files !!!
            try:
                self.spawn(["rc", "-r", src])
            except DistutilsExecError, msg:
                raise CompileError, msg
        else: # for other files use the C-compiler
            try:
                self.spawn(self.compiler_so + cc_args + [src, '-o', obj] +
                           extra_postargs)
            except DistutilsExecError, msg:
                raise CompileError, msg

    def link (self,
              target_desc,
              objects,
              output_filename,
              output_dir=None,
              libraries=None,
              library_dirs=None,
              runtime_library_dirs=None,
              export_symbols=None,
              debug=0,
              extra_preargs=None,
              extra_postargs=None,
              build_temp=None,
              target_lang=None):

        # use separate copies, so we can modify the lists
        extra_preargs = copy.copy(extra_preargs or [])
        libraries = copy.copy(libraries or [])
        objects = copy.copy(objects or [])

        # Additional libraries
        libraries.extend(self.dll_libraries)

        # handle export symbols by creating a def-file
        # with executables this only works with gcc/ld as linker
        if ((export_symbols is not None) and
            (target_desc != self.EXECUTABLE)):
            # (The linker doesn't do anything if output is up-to-date.
            # So it would probably better to check if we really need this,
            # but for this we had to insert some unchanged parts of
            # UnixCCompiler, and this is not what we want.)

            # we want to put some files in the same directory as the
            # object files are, build_temp doesn't help much
            # where are the object files
            temp_dir = os.path.dirname(objects[0])
            # name of dll to give the helper files the same base name
            (dll_name, dll_extension) = os.path.splitext(
                os.path.basename(output_filename))

            # generate the filenames for these files
            def_file = os.path.join(temp_dir, dll_name + ".def")

            # Generate .def file
            contents = [
                "LIBRARY %s INITINSTANCE TERMINSTANCE" % \
                os.path.splitext(os.path.basename(output_filename))[0],
                "DATA MULTIPLE NONSHARED",
                "EXPORTS"]
            for sym in export_symbols:
                contents.append('  "%s"' % sym)
            self.execute(write_file, (def_file, contents),
                         "writing %s" % def_file)

            # next add options for def-file and to creating import libraries
            # for gcc/ld the def-file is specified as any other object files
            objects.append(def_file)

        #end: if ((export_symbols is not None) and
        #        (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):

        # who wants symbols and a many times larger output file
        # should explicitly switch the debug mode on
        # otherwise we let dllwrap/ld strip the output file
        # (On my machine: 10KB < stripped_file < ??100KB
        #   unstripped_file = stripped_file + XXX KB
        #  ( XXX=254 for a typical python extension))
        if not debug:
            extra_preargs.append("-s")

        UnixCCompiler.link(self,
                           target_desc,
                           objects,
                           output_filename,
                           output_dir,
                           libraries,
                           library_dirs,
                           runtime_library_dirs,
                           None, # export_symbols, we do this in our def-file
                           debug,
                           extra_preargs,
                           extra_postargs,
                           build_temp,
                           target_lang)

    # link ()

    # -- Miscellaneous methods -----------------------------------------

    # override the object_filenames method from CCompiler to
    # support rc and res-files
    def object_filenames (self,
                          source_filenames,
                          strip_dir=0,
                          output_dir=''):
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
            (base, ext) = os.path.splitext (os.path.normcase(src_name))
            if ext not in (self.src_extensions + ['.rc']):
                raise UnknownFileError, \
                      "unknown file type '%s' (from '%s')" % \
                      (ext, src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext == '.rc':
                # these need to be compiled to object files
                obj_names.append (os.path.join (output_dir,
                                            base + self.res_extension))
            else:
                obj_names.append (os.path.join (output_dir,
                                            base + self.obj_extension))
        return obj_names

    # object_filenames ()

    # override the find_library_file method from UnixCCompiler
    # to deal with file naming/searching differences
    def find_library_file(self, dirs, lib, debug=0):
        shortlib = '%s.lib' % lib
        longlib = 'lib%s.lib' % lib    # this form very rare

        # get EMX's default library directory search path
        try:
            emx_dirs = os.environ['LIBRARY_PATH'].split(';')
        except KeyError:
            emx_dirs = []

        for dir in dirs + emx_dirs:
            shortlibp = os.path.join(dir, shortlib)
            longlibp = os.path.join(dir, longlib)
            if os.path.exists(shortlibp):
                return shortlibp
            elif os.path.exists(longlibp):
                return longlibp

        # Oops, didn't find it in *any* of 'dirs'
        return None

# class EMXCCompiler


# Because these compilers aren't configured in Python's pyconfig.h file by
# default, we should at least warn the user if he is using a unmodified
# version.

CONFIG_H_OK = "ok"
CONFIG_H_NOTOK = "not ok"
CONFIG_H_UNCERTAIN = "uncertain"

def check_config_h():

    """Check if the current Python installation (specifically, pyconfig.h)
    appears amenable to building extensions with GCC.  Returns a tuple
    (status, details), where 'status' is one of the following constants:
      CONFIG_H_OK
        all is well, go ahead and compile
      CONFIG_H_NOTOK
        doesn't look good
      CONFIG_H_UNCERTAIN
        not sure -- unable to read pyconfig.h
    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    """

    # XXX since this function also checks sys.version, it's not strictly a
    # "pyconfig.h" check -- should probably be renamed...

    from distutils import sysconfig
    import string
    # if sys.version contains GCC then python was compiled with
    # GCC, and the pyconfig.h file should be OK
    if string.find(sys.version,"GCC") >= 0:
        return (CONFIG_H_OK, "sys.version mentions 'GCC'")

    fn = sysconfig.get_config_h_filename()
    try:
        # It would probably better to read single lines to search.
        # But we do this only once, and it is fast enough
        f = open(fn)
        try:
            s = f.read()
        finally:
            f.close()

    except IOError, exc:
        # if we can't read this file, we cannot say it is wrong
        # the compiler will complain later about this file as missing
        return (CONFIG_H_UNCERTAIN,
                "couldn't read '%s': %s" % (fn, exc.strerror))

    else:
        # "pyconfig.h" contains an "#ifdef __GNUC__" or something similar
        if string.find(s,"__GNUC__") >= 0:
            return (CONFIG_H_OK, "'%s' mentions '__GNUC__'" % fn)
        else:
            return (CONFIG_H_NOTOK, "'%s' does not mention '__GNUC__'" % fn)


def get_versions():
    """ Try to find out the versions of gcc and ld.
        If not possible it returns None for it.
    """
    from distutils.version import StrictVersion
    from distutils.spawn import find_executable
    import re

    gcc_exe = find_executable('gcc')
    if gcc_exe:
        out = os.popen(gcc_exe + ' -dumpversion','r')
        try:
            out_string = out.read()
        finally:
            out.close()
        result = re.search('(\d+\.\d+\.\d+)',out_string)
        if result:
            gcc_version = StrictVersion(result.group(1))
        else:
            gcc_version = None
    else:
        gcc_version = None
    # EMX ld has no way of reporting version number, and we use GCC
    # anyway - so we can link OMF DLLs
    ld_version = None
    return (gcc_version, ld_version)
                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/distutils/emxccompiler.pyc                                                        0100644 0000000 0000000 00000016431 13077704274 017644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s–   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z d d l m	 Z	 d d l
 m Z d d l m Z m Z m Z d d l m Z d	 e	 f d
 Ñ  É  YZ d Z d Z d Z d Ñ  Z d Ñ  Z d S(   sé   distutils.emxccompiler

Provides the EMXCCompiler class, a subclass of UnixCCompiler that
handles the EMX port of the GNU C compiler to OS/2.
s   $Id$iˇˇˇˇN(   t   gen_preprocess_optionst   gen_lib_options(   t   UnixCCompiler(   t
   write_file(   t   DistutilsExecErrort   CompileErrort   UnknownFileError(   t   logt   EMXCCompilerc           B   sï   e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 d d d d Ñ Z
 d	 Ñ  Z d d d d d d d d d d d
 Ñ
 Z d d d Ñ Z d d Ñ Z RS(   t   emxs   .objs   .libs   .dlls   %s%ss   .ress   .exei    c      	   C   sœ   t  j |  | | | É t É  \ } } |  j d | | f É | t k	 rd |  j d d | d É n  t É  \ |  _ |  _ |  j |  j	 d |  j |  j f É |  j
 d d d d d	 d
 d d É d g |  _ d  S(   Ns%   Python's GCC status: %s (details: %s)s<   Python's pyconfig.h doesn't seem to support your compiler.  s   Reason: %s.s<   Compiling may fail because of undefined preprocessor macros.s   : gcc %s, ld %s
t   compilers5   gcc -Zomf -Zmt -O3 -fomit-frame-pointer -mprobe -Wallt   compiler_sot
   linker_exes   gcc -Zomf -Zmt -Zcrtdllt	   linker_sos   gcc -Zomf -Zmt -Zcrtdll -Zdllt   gcc(   R   t   __init__t   check_config_ht   debug_printt   CONFIG_H_OKt   warnt   get_versionst   gcc_versiont
   ld_versiont   compiler_typet   set_executablest   dll_libraries(   t   selft   verboset   dry_runt   forcet   statust   details(    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyR   *   s"    	c         C   sî   | d k rH y |  j  d d | g É Wqê t k
 rD } t | Ç qê XnH y) |  j  |  j | | d | g | É Wn t k
 rè } t | Ç n Xd  S(   Ns   .rct   rcs   -rs   -o(   t   spawnR   R   R   (   R   t   objt   srct   extt   cc_argst   extra_postargst   pp_optst   msg(    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyt   _compileM   s    c         C   sâ  t  j  |
 p g  É }
 t  j  | p$ g  É } t  j  | p9 g  É } | j |  j É | d  k	 r;| |  j k r;t j j | d É } t j j t j j	 | É É \ } } t j j
 | | d É } d t j j t j j	 | É É d d d g } x | D] } | j d | É qÛ W|  j t | | f d | É | j | É n  |	 sQ|
 j d É n  t j |  | | | | | | | d  |	 |
 | | | É d  S(	   Ni    s   .defs$   LIBRARY %s INITINSTANCE TERMINSTANCEs   DATA MULTIPLE NONSHAREDt   EXPORTSs     "%s"s
   writing %ss   -s(   t   copyt   extendR   t   Nonet
   EXECUTABLEt   ost   patht   dirnamet   splitextt   basenamet   joint   appendt   executeR   R   t   link(   R   t   target_desct   objectst   output_filenamet
   output_dirt	   librariest   library_dirst   runtime_library_dirst   export_symbolst   debugt   extra_preargsR&   t
   build_tempt   target_langt   temp_dirt   dll_namet   dll_extensiont   def_filet   contentst   sym(    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyR7   [   sF    		 		t    c         C   s   | d  k r d } n  g  } xŒ | D]∆ } t j j t j j | É É \ } } | |  j d g k rx t d | | f Ç n  | rì t j j | É } n  | d k r≈ | j t j j	 | | |  j
 É É q" | j t j j	 | | |  j É É q" W| S(   NRJ   s   .rcs"   unknown file type '%s' (from '%s')(   R-   R/   R0   R2   t   normcaset   src_extensionsR   R3   R5   R4   t   res_extensiont   obj_extension(   R   t   source_filenamest	   strip_dirR;   t	   obj_namest   src_namet   baseR$   (    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyt   object_filenames∂   s"     	$c   
      C   s∑   d | } d | } y t  j d j d É } Wn t k
 rG g  } n Xxh | | D]\ } t  j j | | É } t  j j | | É }	 t  j j | É rô | St  j j |	 É rS |	 SqS Wd  S(   Ns   %s.libs	   lib%s.libt   LIBRARY_PATHt   ;(   R/   t   environt   splitt   KeyErrorR0   R4   t   existsR-   (
   R   t   dirst   libR@   t   shortlibt   longlibt   emx_dirst   dirt	   shortlibpt   longlibp(    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyt   find_library_file“   s    


N(   t   __name__t
   __module__R   RN   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatRM   t   exe_extensionR   R)   R-   R7   RT   Rc   (    (    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyR      s2    	Pt   oks   not okt	   uncertainc          C   s›   d d l  m }  d d l } | j t j d É d k rA t d f S|  j É  } y. t | É } z | j	 É  } Wd | j
 É  XWn' t k
 r§ } t d | | j f f SX| j | d É d k rÀ t d	 | f St d
 | f Sd S(   s°  Check if the current Python installation (specifically, pyconfig.h)
    appears amenable to building extensions with GCC.  Returns a tuple
    (status, details), where 'status' is one of the following constants:
      CONFIG_H_OK
        all is well, go ahead and compile
      CONFIG_H_NOTOK
        doesn't look good
      CONFIG_H_UNCERTAIN
        not sure -- unable to read pyconfig.h
    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    iˇˇˇˇ(   t	   sysconfigNt   GCCi    s   sys.version mentions 'GCC's   couldn't read '%s': %st   __GNUC__s   '%s' mentions '__GNUC__'s    '%s' does not mention '__GNUC__'(   t	   distutilsRm   t   stringt   findt   syst   versionR   t   get_config_h_filenamet   opent   readt   closet   IOErrort   CONFIG_H_UNCERTAINt   strerrort   CONFIG_H_NOTOK(   Rm   Rq   t   fnt   ft   st   exc(    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyR   Ú   s     
c    	      C   s¡   d d l  m }  d d l m } d d l } | d É } | r´ t j | d d É } z | j É  } Wd | j É  X| j	 d | É } | r¢ |  | j
 d	 É É } q± d } n d } d } | | f S(
   sa    Try to find out the versions of gcc and ld.
        If not possible it returns None for it.
    iˇˇˇˇ(   t   StrictVersion(   t   find_executableNR   s    -dumpversiont   rs   (\d+\.\d+\.\d+)i   (   t   distutils.versionRÅ   t   distutils.spawnRÇ   t   reR/   t   popenRw   Rx   t   searcht   groupR-   (	   RÅ   RÇ   RÜ   t   gcc_exet   outt
   out_stringt   resultR   R   (    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyR   &  s     	(   t   __doc__t   __revision__R/   Rs   R+   t   distutils.ccompilerR    R   t   distutils.unixccompilerR   t   distutils.file_utilR   t   distutils.errorsR   R   R   Rp   R   R   R   R|   Rz   R   R   (    (    (    s,   /usr/lib/python2.7/distutils/emxccompiler.pyt   <module>   s   $œ	4                                                                                                                                                                                                                                       usr/lib/python2.7/distutils/errors.py                                                               0100644 0000000 0000000 00000006646 12734733743 016337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.errors

Provides exceptions used by the Distutils modules.  Note that Distutils
modules may raise standard exceptions; in particular, SystemExit is
usually raised for errors that are obviously the end-user's fault
(eg. bad command-line arguments).

This module is safe to use in "from ... import *" mode; it only exports
symbols whose names start with "Distutils" and end with "Error"."""

__revision__ = "$Id$"

class DistutilsError(Exception):
    """The root of all Distutils evil."""

class DistutilsModuleError(DistutilsError):
    """Unable to load an expected module, or to find an expected class
    within some module (in particular, command modules and classes)."""

class DistutilsClassError(DistutilsError):
    """Some command class (or possibly distribution class, if anyone
    feels a need to subclass Distribution) is found not to be holding
    up its end of the bargain, ie. implementing some part of the
    "command "interface."""

class DistutilsGetoptError(DistutilsError):
    """The option table provided to 'fancy_getopt()' is bogus."""

class DistutilsArgError(DistutilsError):
    """Raised by fancy_getopt in response to getopt.error -- ie. an
    error in the command line usage."""

class DistutilsFileError(DistutilsError):
    """Any problems in the filesystem: expected file not found, etc.
    Typically this is for problems that we detect before IOError or
    OSError could be raised."""

class DistutilsOptionError(DistutilsError):
    """Syntactic/semantic errors in command options, such as use of
    mutually conflicting options, or inconsistent options,
    badly-spelled values, etc.  No distinction is made between option
    values originating in the setup script, the command line, config
    files, or what-have-you -- but if we *know* something originated in
    the setup script, we'll raise DistutilsSetupError instead."""

class DistutilsSetupError(DistutilsError):
    """For errors that can be definitely blamed on the setup script,
    such as invalid keyword arguments to 'setup()'."""

class DistutilsPlatformError(DistutilsError):
    """We don't know how to do something on the current platform (but
    we do know how to do it on some platform) -- eg. trying to compile
    C files on a platform not supported by a CCompiler subclass."""

class DistutilsExecError(DistutilsError):
    """Any problems executing an external program (such as the C
    compiler, when compiling C files)."""

class DistutilsInternalError(DistutilsError):
    """Internal inconsistencies or impossibilities (obviously, this
    should never be seen if the code is working!)."""

class DistutilsTemplateError(DistutilsError):
    """Syntax error in a file list template."""

class DistutilsByteCompileError(DistutilsError):
    """Byte compile error."""

# Exception classes used by the CCompiler implementation classes
class CCompilerError(Exception):
    """Some compile/link operation failed."""

class PreprocessError(CCompilerError):
    """Failure to preprocess one or more C/C++ files."""

class CompileError(CCompilerError):
    """Failure to compile one or more C/C++ source files."""

class LibError(CCompilerError):
    """Failure to create a static library from one or more C/C++ object
    files."""

class LinkError(CCompilerError):
    """Failure to link one or more C/C++ object files into an executable
    or shared library file."""

class UnknownFileError(CCompilerError):
    """Attempt to process an unknown file type."""
                                                                                          usr/lib/python2.7/distutils/errors.pyc                                                              0100644 0000000 0000000 00000014145 13077704274 016471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s≤  d  Z  d Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d	 Ñ  É  YZ d
 e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ	 d e f d Ñ  É  YZ
 d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d  e f d! Ñ  É  YZ d" e f d# Ñ  É  YZ d$ e f d% Ñ  É  YZ d& e f d' Ñ  É  YZ d( S()   sã  distutils.errors

Provides exceptions used by the Distutils modules.  Note that Distutils
modules may raise standard exceptions; in particular, SystemExit is
usually raised for errors that are obviously the end-user's fault
(eg. bad command-line arguments).

This module is safe to use in "from ... import *" mode; it only exports
symbols whose names start with "Distutils" and end with "Error".s   $Id$t   DistutilsErrorc           B   s   e  Z d  Z RS(   s   The root of all Distutils evil.(   t   __name__t
   __module__t   __doc__(    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR       s   t   DistutilsModuleErrorc           B   s   e  Z d  Z RS(   sÑ   Unable to load an expected module, or to find an expected class
    within some module (in particular, command modules and classes).(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR      s   t   DistutilsClassErrorc           B   s   e  Z d  Z RS(   s›   Some command class (or possibly distribution class, if anyone
    feels a need to subclass Distribution) is found not to be holding
    up its end of the bargain, ie. implementing some part of the
    "command "interface.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR      s   t   DistutilsGetoptErrorc           B   s   e  Z d  Z RS(   s7   The option table provided to 'fancy_getopt()' is bogus.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR      s   t   DistutilsArgErrorc           B   s   e  Z d  Z RS(   sa   Raised by fancy_getopt in response to getopt.error -- ie. an
    error in the command line usage.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR      s   t   DistutilsFileErrorc           B   s   e  Z d  Z RS(   sû   Any problems in the filesystem: expected file not found, etc.
    Typically this is for problems that we detect before IOError or
    OSError could be raised.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   !   s   t   DistutilsOptionErrorc           B   s   e  Z d  Z RS(   sâ  Syntactic/semantic errors in command options, such as use of
    mutually conflicting options, or inconsistent options,
    badly-spelled values, etc.  No distinction is made between option
    values originating in the setup script, the command line, config
    files, or what-have-you -- but if we *know* something originated in
    the setup script, we'll raise DistutilsSetupError instead.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR	   &   s   t   DistutilsSetupErrorc           B   s   e  Z d  Z RS(   sq   For errors that can be definitely blamed on the setup script,
    such as invalid keyword arguments to 'setup()'.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR
   .   s   t   DistutilsPlatformErrorc           B   s   e  Z d  Z RS(   s∆   We don't know how to do something on the current platform (but
    we do know how to do it on some platform) -- eg. trying to compile
    C files on a platform not supported by a CCompiler subclass.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   2   s   t   DistutilsExecErrorc           B   s   e  Z d  Z RS(   s`   Any problems executing an external program (such as the C
    compiler, when compiling C files).(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   7   s   t   DistutilsInternalErrorc           B   s   e  Z d  Z RS(   so   Internal inconsistencies or impossibilities (obviously, this
    should never be seen if the code is working!).(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   ;   s   t   DistutilsTemplateErrorc           B   s   e  Z d  Z RS(   s%   Syntax error in a file list template.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   ?   s   t   DistutilsByteCompileErrorc           B   s   e  Z d  Z RS(   s   Byte compile error.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   B   s   t   CCompilerErrorc           B   s   e  Z d  Z RS(   s#   Some compile/link operation failed.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   F   s   t   PreprocessErrorc           B   s   e  Z d  Z RS(   s.   Failure to preprocess one or more C/C++ files.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   I   s   t   CompileErrorc           B   s   e  Z d  Z RS(   s2   Failure to compile one or more C/C++ source files.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   L   s   t   LibErrorc           B   s   e  Z d  Z RS(   sK   Failure to create a static library from one or more C/C++ object
    files.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   O   s   t	   LinkErrorc           B   s   e  Z d  Z RS(   s]   Failure to link one or more C/C++ object files into an executable
    or shared library file.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   S   s   t   UnknownFileErrorc           B   s   e  Z d  Z RS(   s(   Attempt to process an unknown file type.(   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyR   W   s   N(   R   t   __revision__t	   ExceptionR    R   R   R   R   R   R	   R
   R   R   R   R   R   R   R   R   R   R   R   (    (    (    s&   /usr/lib/python2.7/distutils/errors.pyt   <module>	   s(                                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/python2.7/distutils/extension.py                                                            0100644 0000000 0000000 00000025230 12734733743 017025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts."""

__revision__ = "$Id$"

import os, string, sys
from types import *

try:
    import warnings
except ImportError:
    warnings = None

# This class is really only used by the "build_ext" command, so it might
# make sense to put it in distutils.command.build_ext.  However, that
# module is already big enough, and I want to make this class a bit more
# complex to simplify some common cases ("foo" module in "foo.c") and do
# better error-checking ("foo.c" actually exists).
#
# Also, putting this in build_ext.py means every setup script would have to
# import that large-ish module (indirectly, through distutils.core) in
# order to do anything.

class Extension:
    """Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
    """

    # When adding arguments to this constructor, be sure to update
    # setup_keywords in core.py.
    def __init__ (self, name, sources,
                  include_dirs=None,
                  define_macros=None,
                  undef_macros=None,
                  library_dirs=None,
                  libraries=None,
                  runtime_library_dirs=None,
                  extra_objects=None,
                  extra_compile_args=None,
                  extra_link_args=None,
                  export_symbols=None,
                  swig_opts = None,
                  depends=None,
                  language=None,
                  **kw                      # To catch unknown keywords
                 ):
        assert type(name) is StringType, "'name' must be a string"
        assert (type(sources) is ListType and
                map(type, sources) == [StringType]*len(sources)), \
                "'sources' must be a list of strings"

        self.name = name
        self.sources = sources
        self.include_dirs = include_dirs or []
        self.define_macros = define_macros or []
        self.undef_macros = undef_macros or []
        self.library_dirs = library_dirs or []
        self.libraries = libraries or []
        self.runtime_library_dirs = runtime_library_dirs or []
        self.extra_objects = extra_objects or []
        self.extra_compile_args = extra_compile_args or []
        self.extra_link_args = extra_link_args or []
        self.export_symbols = export_symbols or []
        self.swig_opts = swig_opts or []
        self.depends = depends or []
        self.language = language

        # If there are unknown keyword options, warn about them
        if len(kw):
            L = kw.keys() ; L.sort()
            L = map(repr, L)
            msg = "Unknown Extension options: " + string.join(L, ', ')
            if warnings is not None:
                warnings.warn(msg)
            else:
                sys.stderr.write(msg + '\n')
# class Extension


def read_setup_file (filename):
    from distutils.sysconfig import \
         parse_makefile, expand_makefile_vars, _variable_rx
    from distutils.text_file import TextFile
    from distutils.util import split_quoted

    # First pass over the file to gather "VAR = VALUE" assignments.
    vars = parse_makefile(filename)

    # Second pass to gobble up the real content: lines of the form
    #   <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
    file = TextFile(filename,
                    strip_comments=1, skip_blanks=1, join_lines=1,
                    lstrip_ws=1, rstrip_ws=1)
    try:
        extensions = []

        while 1:
            line = file.readline()
            if line is None:                # eof
                break
            if _variable_rx.match(line):    # VAR=VALUE, handled in first pass
                continue

                if line[0] == line[-1] == "*":
                    file.warn("'%s' lines not handled yet" % line)
                    continue

            #print "original line: " + line
            line = expand_makefile_vars(line, vars)
            words = split_quoted(line)
            #print "expanded line: " + line

            # NB. this parses a slightly different syntax than the old
            # makesetup script: here, there must be exactly one extension per
            # line, and it must be the first word of the line.  I have no idea
            # why the old syntax supported multiple extensions per line, as
            # they all wind up being the same.

            module = words[0]
            ext = Extension(module, [])
            append_next_word = None

            for word in words[1:]:
                if append_next_word is not None:
                    append_next_word.append(word)
                    append_next_word = None
                    continue

                suffix = os.path.splitext(word)[1]
                switch = word[0:2] ; value = word[2:]

                if suffix in (".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"):
                    # hmm, should we do something about C vs. C++ sources?
                    # or leave it up to the CCompiler implementation to
                    # worry about?
                    ext.sources.append(word)
                elif switch == "-I":
                    ext.include_dirs.append(value)
                elif switch == "-D":
                    equals = string.find(value, "=")
                    if equals == -1:        # bare "-DFOO" -- no value
                        ext.define_macros.append((value, None))
                    else:                   # "-DFOO=blah"
                        ext.define_macros.append((value[0:equals],
                                                  value[equals+2:]))
                elif switch == "-U":
                    ext.undef_macros.append(value)
                elif switch == "-C":        # only here 'cause makesetup has it!
                    ext.extra_compile_args.append(word)
                elif switch == "-l":
                    ext.libraries.append(value)
                elif switch == "-L":
                    ext.library_dirs.append(value)
                elif switch == "-R":
                    ext.runtime_library_dirs.append(value)
                elif word == "-rpath":
                    append_next_word = ext.runtime_library_dirs
                elif word == "-Xlinker":
                    append_next_word = ext.extra_link_args
                elif word == "-Xcompiler":
                    append_next_word = ext.extra_compile_args
                elif switch == "-u":
                    ext.extra_link_args.append(word)
                    if not value:
                        append_next_word = ext.extra_link_args
                elif word == "-Xcompiler":
                    append_next_word = ext.extra_compile_args
                elif switch == "-u":
                    ext.extra_link_args.append(word)
                    if not value:
                        append_next_word = ext.extra_link_args
                elif suffix in (".a", ".so", ".sl", ".o", ".dylib"):
                    # NB. a really faithful emulation of makesetup would
                    # append a .o file to extra_objects only if it
                    # had a slash in it; otherwise, it would s/.o/.c/
                    # and append it to sources.  Hmmmm.
                    ext.extra_objects.append(word)
                else:
                    file.warn("unrecognized argument '%s'" % word)

            extensions.append(ext)
    finally:
        file.close()

        #print "module:", module
        #print "source files:", source_files
        #print "cpp args:", cpp_args
        #print "lib args:", library_args

        #extensions[module] = { 'sources': source_files,
        #                       'cpp_args': cpp_args,
        #                       'lib_args': library_args }

    return extensions

# read_setup_file ()
                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/distutils/extension.pyc                                                           0100644 0000000 0000000 00000016353 13077704274 017174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sÑ   d  Z  d Z d d l Z d d l Z d d l Z d d l Ty d d l Z Wn e k
 rc d Z n Xd d d Ñ  É  YZ	 d Ñ  Z
 d S(	   sm   distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts.s   $Id$iˇˇˇˇN(   t   *t	   Extensionc           B   s>   e  Z d  Z d d d d d d d d d d d d d d Ñ Z RS(   s4  Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
    c         K   s´  t  | É t k s t d É Ç t  | É t k rR t t  | É t g t | É k s^ t d É Ç | |  _ | |  _ | py g  |  _ | pà g  |  _	 | pó g  |  _
 | p¶ g  |  _ | pµ g  |  _ | pƒ g  |  _ |	 p” g  |  _ |
 p‚ g  |  _ | pÒ g  |  _ | p g  |  _ | pg  |  _ | pg  |  _ | |  _ t | É rß| j É  } | j É  t t | É } d t j | d É } t d  k	 rêt j | É qßt j j | d É n  d  S(   Ns   'name' must be a strings#   'sources' must be a list of stringss   Unknown Extension options: s   , s   
(    t   typet
   StringTypet   AssertionErrort   ListTypet   mapt   lent   namet   sourcest   include_dirst   define_macrost   undef_macrost   library_dirst	   librariest   runtime_library_dirst   extra_objectst   extra_compile_argst   extra_link_argst   export_symbolst	   swig_optst   dependst   languaget   keyst   sortt   reprt   stringt   joint   warningst   Nonet   warnt   syst   stderrt   write(   t   selfR   R	   R
   R   R   R   R   R   R   R   R   R   R   R   R   t   kwt   Lt   msg(    (    s)   /usr/lib/python2.7/distutils/extension.pyt   __init__Z   s6    %				 
N(   t   __name__t
   __module__t   __doc__R   R&   (    (    (    s)   /usr/lib/python2.7/distutils/extension.pyR      s   <c         C   s‰  d d l  m } m } m } d d l m } d d l m } | |  É } | |  d d d d d d d	 d d
 d É} z`g  } xS| j É  }	 |	 d  k rö Pn  | j
 |	 É rÍ q~ |	 d |	 d k oÀ d k n rÍ | j d |	 É q~ qÍ n  | |	 | É }	 | |	 É }
 |
 d } t | g  É } d  } xö|
 d D]é} | d  k	 rZ| j | É d  } q/n  t j j | É d } | d d !} | d } | d( k r¶| j j | É q/| d k r≈| j j | É q/| d k r0t j | d É } | d k r| j j | d  f É qΩ| j j | d | !| | d f É q/| d k rO| j j | É q/| d k rn| j j | É q/| d k rç| j j | É q/| d k r¨| j j | É q/| d k rÀ| j j | É q/| d k r„| j } q/| d k r˚| j } q/| d  k r| j } q/| d! k rD| j j | É | sΩ| j } qΩq/| d  k r\| j } q/| d! k rç| j j | É | sΩ| j } qΩq/| d) k r¨| j j | É q/| j d' | É q/W| j | É q~ Wd  | j É  X| S(*   Niˇˇˇˇ(   t   parse_makefilet   expand_makefile_varst   _variable_rx(   t   TextFile(   t   split_quotedt   strip_commentsi   t   skip_blankst
   join_linest	   lstrip_wst	   rstrip_wsi    R    s   '%s' lines not handled yeti   s   .cs   .ccs   .cpps   .cxxs   .c++s   .ms   .mms   -Is   -Dt   =s   -Us   -Cs   -ls   -Ls   -Rs   -rpaths   -Xlinkers
   -Xcompilers   -us   .as   .sos   .sls   .os   .dylibs   unrecognized argument '%s'(   s   .cs   .ccs   .cpps   .cxxs   .c++s   .ms   .mm(   s   .as   .sos   .sls   .os   .dylib(   t   distutils.sysconfigR*   R+   R,   t   distutils.text_fileR-   t   distutils.utilR.   t   readlineR   t   matchR   R   t   appendt   ost   patht   splitextR	   R
   R   t   findR   R   R   R   R   R   R   R   t   close(   t   filenameR*   R+   R,   R-   R.   t   varst   filet
   extensionst   linet   wordst   modulet   extt   append_next_wordt   wordt   suffixt   switcht   valuet   equals(    (    s)   /usr/lib/python2.7/distutils/extension.pyt   read_setup_fileã   sí    	$		
 
(    (   R)   t   __revision__R;   R   R   t   typesR   t   ImportErrorR   R   RN   (    (    (    s)   /usr/lib/python2.7/distutils/extension.pyt   <module>   s   $

q                                                                                                                                                                                                                                                                                     usr/lib/python2.7/distutils/fancy_getopt.py                                                         0100644 0000000 0000000 00000043034 12734733743 017475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
"""

__revision__ = "$Id$"

import sys
import string
import re
import getopt
from distutils.errors import DistutilsGetoptError, DistutilsArgError

# Much like command_re in distutils.core, this is close to but not quite
# the same as a Python NAME -- except, in the spirit of most GNU
# utilities, we use '-' in place of '_'.  (The spirit of LISP lives on!)
# The similarities to NAME are again not a coincidence...
longopt_pat = r'[a-zA-Z](?:[a-zA-Z0-9-]*)'
longopt_re = re.compile(r'^%s$' % longopt_pat)

# For recognizing "negative alias" options, eg. "quiet=!verbose"
neg_alias_re = re.compile("^(%s)=!(%s)$" % (longopt_pat, longopt_pat))

# This is used to translate long options to legitimate Python identifiers
# (for use as attributes of some object).
longopt_xlate = string.maketrans('-', '_')

class FancyGetopt:
    """Wrapper around the standard 'getopt()' module that provides some
    handy extra functionality:
      * short and long options are tied together
      * options have help strings, and help text can be assembled
        from them
      * options set attributes of a passed-in object
      * boolean options can have "negative aliases" -- eg. if
        --quiet is the "negative alias" of --verbose, then "--quiet"
        on the command line sets 'verbose' to false
    """

    def __init__ (self, option_table=None):

        # The option table is (currently) a list of tuples.  The
        # tuples may have 3 or four values:
        #   (long_option, short_option, help_string [, repeatable])
        # if an option takes an argument, its long_option should have '='
        # appended; short_option should just be a single character, no ':'
        # in any case.  If a long_option doesn't have a corresponding
        # short_option, short_option should be None.  All option tuples
        # must have long options.
        self.option_table = option_table

        # 'option_index' maps long option names to entries in the option
        # table (ie. those 3-tuples).
        self.option_index = {}
        if self.option_table:
            self._build_index()

        # 'alias' records (duh) alias options; {'foo': 'bar'} means
        # --foo is an alias for --bar
        self.alias = {}

        # 'negative_alias' keeps track of options that are the boolean
        # opposite of some other option
        self.negative_alias = {}

        # These keep track of the information in the option table.  We
        # don't actually populate these structures until we're ready to
        # parse the command-line, since the 'option_table' passed in here
        # isn't necessarily the final word.
        self.short_opts = []
        self.long_opts = []
        self.short2long = {}
        self.attr_name = {}
        self.takes_arg = {}

        # And 'option_order' is filled up in 'getopt()'; it records the
        # original order of options (and their values) on the command-line,
        # but expands short options, converts aliases, etc.
        self.option_order = []

    # __init__ ()


    def _build_index (self):
        self.option_index.clear()
        for option in self.option_table:
            self.option_index[option[0]] = option

    def set_option_table (self, option_table):
        self.option_table = option_table
        self._build_index()

    def add_option (self, long_option, short_option=None, help_string=None):
        if long_option in self.option_index:
            raise DistutilsGetoptError, \
                  "option conflict: already an option '%s'" % long_option
        else:
            option = (long_option, short_option, help_string)
            self.option_table.append(option)
            self.option_index[long_option] = option


    def has_option (self, long_option):
        """Return true if the option table for this parser has an
        option with long name 'long_option'."""
        return long_option in self.option_index

    def get_attr_name (self, long_option):
        """Translate long option name 'long_option' to the form it
        has as an attribute of some object: ie., translate hyphens
        to underscores."""
        return string.translate(long_option, longopt_xlate)


    def _check_alias_dict (self, aliases, what):
        assert isinstance(aliases, dict)
        for (alias, opt) in aliases.items():
            if alias not in self.option_index:
                raise DistutilsGetoptError, \
                      ("invalid %s '%s': "
                       "option '%s' not defined") % (what, alias, alias)
            if opt not in self.option_index:
                raise DistutilsGetoptError, \
                      ("invalid %s '%s': "
                       "aliased option '%s' not defined") % (what, alias, opt)

    def set_aliases (self, alias):
        """Set the aliases for this option parser."""
        self._check_alias_dict(alias, "alias")
        self.alias = alias

    def set_negative_aliases (self, negative_alias):
        """Set the negative aliases for this option parser.
        'negative_alias' should be a dictionary mapping option names to
        option names, both the key and value must already be defined
        in the option table."""
        self._check_alias_dict(negative_alias, "negative alias")
        self.negative_alias = negative_alias


    def _grok_option_table (self):
        """Populate the various data structures that keep tabs on the
        option table.  Called by 'getopt()' before it can do anything
        worthwhile.
        """
        self.long_opts = []
        self.short_opts = []
        self.short2long.clear()
        self.repeat = {}

        for option in self.option_table:
            if len(option) == 3:
                long, short, help = option
                repeat = 0
            elif len(option) == 4:
                long, short, help, repeat = option
            else:
                # the option table is part of the code, so simply
                # assert that it is correct
                raise ValueError, "invalid option tuple: %r" % (option,)

            # Type- and value-check the option names
            if not isinstance(long, str) or len(long) < 2:
                raise DistutilsGetoptError, \
                      ("invalid long option '%s': "
                       "must be a string of length >= 2") % long

            if (not ((short is None) or
                     (isinstance(short, str) and len(short) == 1))):
                raise DistutilsGetoptError, \
                      ("invalid short option '%s': "
                       "must a single character or None") % short

            self.repeat[long] = repeat
            self.long_opts.append(long)

            if long[-1] == '=':             # option takes an argument?
                if short: short = short + ':'
                long = long[0:-1]
                self.takes_arg[long] = 1
            else:

                # Is option is a "negative alias" for some other option (eg.
                # "quiet" == "!verbose")?
                alias_to = self.negative_alias.get(long)
                if alias_to is not None:
                    if self.takes_arg[alias_to]:
                        raise DistutilsGetoptError, \
                              ("invalid negative alias '%s': "
                               "aliased option '%s' takes a value") % \
                               (long, alias_to)

                    self.long_opts[-1] = long # XXX redundant?!
                    self.takes_arg[long] = 0

                else:
                    self.takes_arg[long] = 0

            # If this is an alias option, make sure its "takes arg" flag is
            # the same as the option it's aliased to.
            alias_to = self.alias.get(long)
            if alias_to is not None:
                if self.takes_arg[long] != self.takes_arg[alias_to]:
                    raise DistutilsGetoptError, \
                          ("invalid alias '%s': inconsistent with "
                           "aliased option '%s' (one of them takes a value, "
                           "the other doesn't") % (long, alias_to)


            # Now enforce some bondage on the long option name, so we can
            # later translate it to an attribute name on some object.  Have
            # to do this a bit late to make sure we've removed any trailing
            # '='.
            if not longopt_re.match(long):
                raise DistutilsGetoptError, \
                      ("invalid long option name '%s' " +
                       "(must be letters, numbers, hyphens only") % long

            self.attr_name[long] = self.get_attr_name(long)
            if short:
                self.short_opts.append(short)
                self.short2long[short[0]] = long

        # for option_table

    # _grok_option_table()


    def getopt (self, args=None, object=None):
        """Parse command-line options in args. Store as attributes on object.

        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
        'object' is None or not supplied, creates a new OptionDummy
        object, stores option values there, and returns a tuple (args,
        object).  If 'object' is supplied, it is modified in place and
        'getopt()' just returns 'args'; in both cases, the returned
        'args' is a modified copy of the passed-in 'args' list, which
        is left untouched.
        """
        if args is None:
            args = sys.argv[1:]
        if object is None:
            object = OptionDummy()
            created_object = 1
        else:
            created_object = 0

        self._grok_option_table()

        short_opts = string.join(self.short_opts)
        try:
            opts, args = getopt.getopt(args, short_opts, self.long_opts)
        except getopt.error, msg:
            raise DistutilsArgError, msg

        for opt, val in opts:
            if len(opt) == 2 and opt[0] == '-': # it's a short option
                opt = self.short2long[opt[1]]
            else:
                assert len(opt) > 2 and opt[:2] == '--'
                opt = opt[2:]

            alias = self.alias.get(opt)
            if alias:
                opt = alias

            if not self.takes_arg[opt]:     # boolean option?
                assert val == '', "boolean option can't have value"
                alias = self.negative_alias.get(opt)
                if alias:
                    opt = alias
                    val = 0
                else:
                    val = 1

            attr = self.attr_name[opt]
            # The only repeating option at the moment is 'verbose'.
            # It has a negative option -q quiet, which should set verbose = 0.
            if val and self.repeat.get(attr) is not None:
                val = getattr(object, attr, 0) + 1
            setattr(object, attr, val)
            self.option_order.append((opt, val))

        # for opts
        if created_object:
            return args, object
        else:
            return args

    # getopt()


    def get_option_order (self):
        """Returns the list of (option, value) tuples processed by the
        previous run of 'getopt()'.  Raises RuntimeError if
        'getopt()' hasn't been called yet.
        """
        if self.option_order is None:
            raise RuntimeError, "'getopt()' hasn't been called yet"
        else:
            return self.option_order


    def generate_help (self, header=None):
        """Generate help text (a list of strings, one per suggested line of
        output) from the option table for this FancyGetopt object.
        """
        # Blithely assume the option table is good: probably wouldn't call
        # 'generate_help()' unless you've already called 'getopt()'.

        # First pass: determine maximum length of long option names
        max_opt = 0
        for option in self.option_table:
            long = option[0]
            short = option[1]
            l = len(long)
            if long[-1] == '=':
                l = l - 1
            if short is not None:
                l = l + 5                   # " (-x)" where short == 'x'
            if l > max_opt:
                max_opt = l

        opt_width = max_opt + 2 + 2 + 2     # room for indent + dashes + gutter

        # Typical help block looks like this:
        #   --foo       controls foonabulation
        # Help block for longest option looks like this:
        #   --flimflam  set the flim-flam level
        # and with wrapped text:
        #   --flimflam  set the flim-flam level (must be between
        #               0 and 100, except on Tuesdays)
        # Options with short names will have the short name shown (but
        # it doesn't contribute to max_opt):
        #   --foo (-f)  controls foonabulation
        # If adding the short option would make the left column too wide,
        # we push the explanation off to the next line
        #   --flimflam (-l)
        #               set the flim-flam level
        # Important parameters:
        #   - 2 spaces before option block start lines
        #   - 2 dashes for each long option name
        #   - min. 2 spaces between option and explanation (gutter)
        #   - 5 characters (incl. space) for short option name

        # Now generate lines of help text.  (If 80 columns were good enough
        # for Jesus, then 78 columns are good enough for me!)
        line_width = 78
        text_width = line_width - opt_width
        big_indent = ' ' * opt_width
        if header:
            lines = [header]
        else:
            lines = ['Option summary:']

        for option in self.option_table:
            long, short, help = option[:3]
            text = wrap_text(help, text_width)
            if long[-1] == '=':
                long = long[0:-1]

            # Case 1: no short option at all (makes life easy)
            if short is None:
                if text:
                    lines.append("  --%-*s  %s" % (max_opt, long, text[0]))
                else:
                    lines.append("  --%-*s  " % (max_opt, long))

            # Case 2: we have a short option, so we have to include it
            # just after the long option
            else:
                opt_names = "%s (-%s)" % (long, short)
                if text:
                    lines.append("  --%-*s  %s" %
                                 (max_opt, opt_names, text[0]))
                else:
                    lines.append("  --%-*s" % opt_names)

            for l in text[1:]:
                lines.append(big_indent + l)

        # for self.option_table

        return lines

    # generate_help ()

    def print_help (self, header=None, file=None):
        if file is None:
            file = sys.stdout
        for line in self.generate_help(header):
            file.write(line + "\n")

# class FancyGetopt


def fancy_getopt (options, negative_opt, object, args):
    parser = FancyGetopt(options)
    parser.set_negative_aliases(negative_opt)
    return parser.getopt(args, object)


WS_TRANS = string.maketrans(string.whitespace, ' ' * len(string.whitespace))

def wrap_text (text, width):
    """wrap_text(text : string, width : int) -> [string]

    Split 'text' into multiple lines of no more than 'width' characters
    each, and return the list of strings that results.
    """

    if text is None:
        return []
    if len(text) <= width:
        return [text]

    text = string.expandtabs(text)
    text = string.translate(text, WS_TRANS)
    chunks = re.split(r'( +|-+)', text)
    chunks = filter(None, chunks)      # ' - ' results in empty strings
    lines = []

    while chunks:

        cur_line = []                   # list of chunks (to-be-joined)
        cur_len = 0                     # length of current line

        while chunks:
            l = len(chunks[0])
            if cur_len + l <= width:    # can squeeze (at least) this chunk in
                cur_line.append(chunks[0])
                del chunks[0]
                cur_len = cur_len + l
            else:                       # this line is full
                # drop last chunk if all space
                if cur_line and cur_line[-1][0] == ' ':
                    del cur_line[-1]
                break

        if chunks:                      # any chunks left to process?

            # if the current line is still empty, then we had a single
            # chunk that's too big too fit on a line -- so we break
            # down and break it up at the line width
            if cur_len == 0:
                cur_line.append(chunks[0][0:width])
                chunks[0] = chunks[0][width:]

            # all-whitespace chunks at the end of a line can be discarded
            # (and we know from the re.split above that if a chunk has
            # *any* whitespace, it is *all* whitespace)
            if chunks[0][0] == ' ':
                del chunks[0]

        # and store this line in the list-of-all-lines -- as a single
        # string, of course!
        lines.append(string.join(cur_line, ''))

    # while chunks

    return lines


def translate_longopt(opt):
    """Convert a long option name to a valid Python identifier by
    changing "-" to "_".
    """
    return string.translate(opt, longopt_xlate)


class OptionDummy:
    """Dummy class just used as a place to hold command-line option
    values as instance attributes."""

    def __init__ (self, options=[]):
        """Create a new OptionDummy instance.  The attributes listed in
        'options' will be initialized to None."""
        for opt in options:
            setattr(self, opt, None)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python2.7/distutils/fancy_getopt.pyc                                                        0100644 0000000 0000000 00000027214 13077704274 017640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s˝   d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l m Z m Z d Z	 e j
 d e	 É Z e j
 d e	 e	 f É Z e j d d	 É Z d
 f  d Ñ  É  YZ d Ñ  Z e j e j d e e j É É Z d Ñ  Z d Ñ  Z d f  d Ñ  É  YZ d S(   s6  distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
s   $Id$iˇˇˇˇN(   t   DistutilsGetoptErrort   DistutilsArgErrors   [a-zA-Z](?:[a-zA-Z0-9-]*)s   ^%s$s   ^(%s)=!(%s)$t   -t   _t   FancyGetoptc           B   s§   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d d d Ñ Z d Ñ  Z d d Ñ Z d d d Ñ Z RS(   s’  Wrapper around the standard 'getopt()' module that provides some
    handy extra functionality:
      * short and long options are tied together
      * options have help strings, and help text can be assembled
        from them
      * options set attributes of a passed-in object
      * boolean options can have "negative aliases" -- eg. if
        --quiet is the "negative alias" of --verbose, then "--quiet"
        on the command line sets 'verbose' to false
    c         C   st   | |  _  i  |  _ |  j  r( |  j É  n  i  |  _ i  |  _ g  |  _ g  |  _ i  |  _ i  |  _ i  |  _	 g  |  _
 d  S(   N(   t   option_tablet   option_indext   _build_indext   aliast   negative_aliast
   short_optst	   long_optst
   short2longt	   attr_namet	   takes_argt   option_order(   t   selfR   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   __init__-   s    
										c         C   s6   |  j  j É  x" |  j D] } | |  j  | d <q Wd  S(   Ni    (   R   t   clearR   (   R   t   option(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR   Y   s    c         C   s   | |  _  |  j É  d  S(   N(   R   R   (   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   set_option_table^   s    	c         C   sO   | |  j  k r t d | Ç n, | | | f } |  j j | É | |  j  | <d  S(   Ns'   option conflict: already an option '%s'(   R   R    R   t   append(   R   t   long_optiont   short_optiont   help_stringR   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt
   add_optionb   s    c         C   s   | |  j  k S(   sc   Return true if the option table for this parser has an
        option with long name 'long_option'.(   R   (   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt
   has_optionl   s    c         C   s   t  j | t É S(   sí   Translate long option name 'long_option' to the form it
        has as an attribute of some object: ie., translate hyphens
        to underscores.(   t   stringt	   translatet   longopt_xlate(   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   get_attr_nameq   s    c         C   sÜ   t  | t É s t Ç xj | j É  D]\ \ } } | |  j k rV t d | | | f Ç n  | |  j k r" t d | | | f Ç q" q" Wd  S(   Ns(   invalid %s '%s': option '%s' not defineds0   invalid %s '%s': aliased option '%s' not defined(   t
   isinstancet   dictt   AssertionErrort   itemsR   R    (   R   t   aliasest   whatR   t   opt(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   _check_alias_dictx   s    c         C   s   |  j  | d É | |  _ d S(   s'   Set the aliases for this option parser.R   N(   R&   R   (   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   set_aliasesÑ   s    c         C   s   |  j  | d É | |  _ d S(   s⁄   Set the negative aliases for this option parser.
        'negative_alias' should be a dictionary mapping option names to
        option names, both the key and value must already be defined
        in the option table.s   negative aliasN(   R&   R	   (   R   R	   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   set_negative_aliasesâ   s    c         C   så  g  |  _  g  |  _ |  j j É  i  |  _ x]|  j D]R} t | É d k rb | \ } } } d } n7 t | É d k râ | \ } } } } n t d | f Ç t | t	 É sª t | É d k  rÀ t
 d | Ç n  | d k pı t | t	 É oı t | É d k st
 d | Ç n  | |  j | <|  j  j | É | d	 d
 k re| rH| d } n  | d d	 !} d |  j | <nk |  j j | É } | d k	 r√|  j | r¶t
 d | | f Ç n  | |  j  d	 <d |  j | <n d |  j | <|  j j | É } | d k	 r!|  j | |  j | k r!t
 d | | f Ç q!n  t j | É sDt
 d d | Ç n  |  j | É |  j | <| r2 |  j j | É | |  j | d <q2 q2 Wd S(   sù   Populate the various data structures that keep tabs on the
        option table.  Called by 'getopt()' before it can do anything
        worthwhile.
        i   i    i   s   invalid option tuple: %ri   s9   invalid long option '%s': must be a string of length >= 2i   s:   invalid short option '%s': must a single character or Noneiˇˇˇˇt   =t   :s>   invalid negative alias '%s': aliased option '%s' takes a valuesg   invalid alias '%s': inconsistent with aliased option '%s' (one of them takes a value, the other doesn'ts   invalid long option name '%s' s'   (must be letters, numbers, hyphens onlyN(   R   R
   R   R   t   repeatR   t   lent
   ValueErrorR   t   strR    t   NoneR   R   R	   t   getR   t
   longopt_ret   matchR   R   (   R   R   t   longt   shortt   helpR+   t   alias_to(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   _grok_option_tableí   sd    				"
!
 c         C   s  | d k r t j d } n  | d k r: t É  } d } n d } |  j É  t j |  j É } y" t j | | |  j	 É \ } } Wn t j
 k
 rü } t | Ç n Xx\| D]T\ } } t | É d k rÈ | d d k rÈ |  j | d } n2 t | É d k r| d  d k st Ç | d } |  j j | É }	 |	 r<|	 } n  |  j | së| d k sat d É Ç |  j j | É }	 |	 rà|	 } d } qëd } n  |  j | }
 | r’|  j j |
 É d k	 r’t | |
 d É d } n  t | |
 | É |  j j | | f É qß W| r| | f S| Sd S(	   s  Parse command-line options in args. Store as attributes on object.

        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
        'object' is None or not supplied, creates a new OptionDummy
        object, stores option values there, and returns a tuple (args,
        object).  If 'object' is supplied, it is modified in place and
        'getopt()' just returns 'args'; in both cases, the returned
        'args' is a modified copy of the passed-in 'args' list, which
        is left untouched.
        i   i    i   R   s   --t    s   boolean option can't have valueN(   R/   t   syst   argvt   OptionDummyR7   R   t   joinR
   t   getoptR   t   errorR   R,   R   R!   R   R0   R   R	   R   R+   t   getattrt   setattrR   R   (   R   t   argst   objectt   created_objectR
   t   optst   msgR%   t   valR   t   attr(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR=   Í   sF    		
""(
			
c         C   s&   |  j  d k r t d Ç n |  j  Sd S(   s´   Returns the list of (option, value) tuples processed by the
        previous run of 'getopt()'.  Raises RuntimeError if
        'getopt()' hasn't been called yet.
        s!   'getopt()' hasn't been called yetN(   R   R/   t   RuntimeError(   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   get_option_order*  s    c         C   s·  d } x| |  j  D]q } | d } | d } t | É } | d d k rS | d } n  | d k	 rl | d } n  | | k r | } q q W| d d d } d } | | }	 d | }
 | r√ | g } n	 d	 g } x|  j  D]} | d
  \ } } } t | |	 É } | d d k r| d d !} n  | d k rk| rQ| j d | | | d f É q≥| j d | | f É nH d | | f } | r¢| j d | | | d f É n | j d | É x# | d D] } | j |
 | É qæWq÷ W| S(   så   Generate help text (a list of strings, one per suggested line of
        output) from the option table for this FancyGetopt object.
        i    i   iˇˇˇˇR)   i   i   iN   t    s   Option summary:i   s     --%-*s  %ss
     --%-*s  s   %s (-%s)s     --%-*sN(   R   R,   R/   t	   wrap_textR   (   R   t   headert   max_optR   R3   R4   t   lt	   opt_widtht
   line_widtht
   text_widtht
   big_indentt   linesR5   t   textt	   opt_names(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   generate_help5  sF    



	!	c         C   sG   | d  k r t j } n  x( |  j | É D] } | j | d É q( Wd  S(   Ns   
(   R/   R9   t   stdoutRV   t   write(   R   RL   t   filet   line(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt
   print_helpâ  s    N(   t   __name__t
   __module__t   __doc__R/   R   R   R   R   R   R   R&   R'   R(   R7   R=   RI   RV   R[   (    (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR   !   s   
,		
							X@	Tc         C   s)   t  |  É } | j | É | j | | É S(   N(   R   R(   R=   (   t   optionst   negative_optRB   RA   t   parser(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   fancy_getoptí  s    RJ   c         C   s~  |  d k r g  St |  É | k r) |  g St j |  É }  t j |  t É }  t j d |  É } t d | É } g  } x| ryg  } d } xt | r¸ t | d É } | | | k r‘ | j	 | d É | d =| | } qâ | r¯ | d d d k r¯ | d =n  Pqâ W| r]| d k r<| j	 | d d | !É | d | | d <n  | d d d k r]| d =q]n  | j	 t j
 | d É É qt W| S(   s∂   wrap_text(text : string, width : int) -> [string]

    Split 'text' into multiple lines of no more than 'width' characters
    each, and return the list of strings that results.
    s   ( +|-+)i    iˇˇˇˇRJ   R8   N(   R/   R,   R   t
   expandtabsR   t   WS_TRANSt   ret   splitt   filterR   R<   (   RT   t   widtht   chunksRS   t   cur_linet   cur_lenRN   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyRK   ö  s:    		
c         C   s   t  j |  t É S(   sX   Convert a long option name to a valid Python identifier by
    changing "-" to "_".
    (   R   R   R   (   R%   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   translate_longopt’  s    R;   c           B   s   e  Z d  Z g  d Ñ Z RS(   s_   Dummy class just used as a place to hold command-line option
    values as instance attributes.c         C   s%   x | D] } t  |  | d É q Wd S(   sk   Create a new OptionDummy instance.  The attributes listed in
        'options' will be initialized to None.N(   R@   R/   (   R   R_   R%   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR   ‡  s    (   R\   R]   R^   R   (    (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR;   ‹  s   (   R^   t   __revision__R9   R   Re   R=   t   distutils.errorsR    R   t   longopt_patt   compileR1   t   neg_alias_ret	   maketransR   R   Rb   t
   whitespaceR,   Rd   RK   Rl   R;   (    (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   <module>	   s"   ˇ r	"	;	                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python2.7/distutils/file_util.py                                                            0100644 0000000 0000000 00000017703 12734733743 016773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.file_util

Utility functions for operating on single files.
"""

__revision__ = "$Id$"

import os
from distutils.errors import DistutilsFileError
from distutils import log

# for generating verbose output in 'copy_file()'
_copy_action = {None: 'copying',
                'hard': 'hard linking',
                'sym': 'symbolically linking'}


def _copy_file_contents(src, dst, buffer_size=16*1024):
    """Copy the file 'src' to 'dst'.

    Both must be filenames. Any error opening either file, reading from
    'src', or writing to 'dst', raises DistutilsFileError.  Data is
    read/written in chunks of 'buffer_size' bytes (default 16k).  No attempt
    is made to handle anything apart from regular files.
    """
    # Stolen from shutil module in the standard library, but with
    # custom error-handling added.
    fsrc = None
    fdst = None
    try:
        try:
            fsrc = open(src, 'rb')
        except os.error, (errno, errstr):
            raise DistutilsFileError("could not open '%s': %s" % (src, errstr))

        if os.path.exists(dst):
            try:
                os.unlink(dst)
            except os.error, (errno, errstr):
                raise DistutilsFileError(
                      "could not delete '%s': %s" % (dst, errstr))

        try:
            fdst = open(dst, 'wb')
        except os.error, (errno, errstr):
            raise DistutilsFileError(
                  "could not create '%s': %s" % (dst, errstr))

        while 1:
            try:
                buf = fsrc.read(buffer_size)
            except os.error, (errno, errstr):
                raise DistutilsFileError(
                      "could not read from '%s': %s" % (src, errstr))

            if not buf:
                break

            try:
                fdst.write(buf)
            except os.error, (errno, errstr):
                raise DistutilsFileError(
                      "could not write to '%s': %s" % (dst, errstr))

    finally:
        if fdst:
            fdst.close()
        if fsrc:
            fsrc.close()

def copy_file(src, dst, preserve_mode=1, preserve_times=1, update=0,
              link=None, verbose=1, dry_run=0):
    """Copy a file 'src' to 'dst'.

    If 'dst' is a directory, then 'src' is copied there with the same name;
    otherwise, it must be a filename.  (If the file exists, it will be
    ruthlessly clobbered.)  If 'preserve_mode' is true (the default),
    the file's mode (type and permission bits, or whatever is analogous on
    the current platform) is copied.  If 'preserve_times' is true (the
    default), the last-modified and last-access times are copied as well.
    If 'update' is true, 'src' will only be copied if 'dst' does not exist,
    or if 'dst' does exist but is older than 'src'.

    'link' allows you to make hard links (os.link) or symbolic links
    (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
    None (the default), files are copied.  Don't set 'link' on systems that
    don't support it: 'copy_file()' doesn't check if hard or symbolic
    linking is available. If hardlink fails, falls back to
    _copy_file_contents().

    Under Mac OS, uses the native file copy function in macostools; on
    other systems, uses '_copy_file_contents()' to copy file contents.

    Return a tuple (dest_name, copied): 'dest_name' is the actual name of
    the output file, and 'copied' is true if the file was copied (or would
    have been copied, if 'dry_run' true).
    """
    # XXX if the destination file already exists, we clobber it if
    # copying, but blow up if linking.  Hmmm.  And I don't know what
    # macostools.copyfile() does.  Should definitely be consistent, and
    # should probably blow up if destination exists and we would be
    # changing it (ie. it's not already a hard/soft link to src OR
    # (not update) and (src newer than dst).

    from distutils.dep_util import newer
    from stat import ST_ATIME, ST_MTIME, ST_MODE, S_IMODE

    if not os.path.isfile(src):
        raise DistutilsFileError(
              "can't copy '%s': doesn't exist or not a regular file" % src)

    if os.path.isdir(dst):
        dir = dst
        dst = os.path.join(dst, os.path.basename(src))
    else:
        dir = os.path.dirname(dst)

    if update and not newer(src, dst):
        if verbose >= 1:
            log.debug("not copying %s (output up-to-date)", src)
        return dst, 0

    try:
        action = _copy_action[link]
    except KeyError:
        raise ValueError("invalid value '%s' for 'link' argument" % link)

    if verbose >= 1:
        if os.path.basename(dst) == os.path.basename(src):
            log.info("%s %s -> %s", action, src, dir)
        else:
            log.info("%s %s -> %s", action, src, dst)

    if dry_run:
        return (dst, 1)

    # If linking (hard or symbolic), use the appropriate system call
    # (Unix only, of course, but that's the caller's responsibility)
    if link == 'hard':
        if not (os.path.exists(dst) and os.path.samefile(src, dst)):
            try:
                os.link(src, dst)
                return (dst, 1)
            except OSError:
                # If hard linking fails, fall back on copying file
                # (some special filesystems don't support hard linking
                #  even under Unix, see issue #8876).
                pass
    elif link == 'sym':
        if not (os.path.exists(dst) and os.path.samefile(src, dst)):
            os.symlink(src, dst)
            return (dst, 1)

    # Otherwise (non-Mac, not linking), copy the file contents and
    # (optionally) copy the times and mode.
    _copy_file_contents(src, dst)
    if preserve_mode or preserve_times:
        st = os.stat(src)

        # According to David Ascher <da@ski.org>, utime() should be done
        # before chmod() (at least under NT).
        if preserve_times:
            os.utime(dst, (st[ST_ATIME], st[ST_MTIME]))
        if preserve_mode:
            os.chmod(dst, S_IMODE(st[ST_MODE]))

    return (dst, 1)

# XXX I suspect this is Unix-specific -- need porting help!
def move_file (src, dst, verbose=1, dry_run=0):
    """Move a file 'src' to 'dst'.

    If 'dst' is a directory, the file will be moved into it with the same
    name; otherwise, 'src' is just renamed to 'dst'.  Return the new
    full name of the file.

    Handles cross-device moves on Unix using 'copy_file()'.  What about
    other systems???
    """
    from os.path import exists, isfile, isdir, basename, dirname
    import errno

    if verbose >= 1:
        log.info("moving %s -> %s", src, dst)

    if dry_run:
        return dst

    if not isfile(src):
        raise DistutilsFileError("can't move '%s': not a regular file" % src)

    if isdir(dst):
        dst = os.path.join(dst, basename(src))
    elif exists(dst):
        raise DistutilsFileError(
              "can't move '%s': destination '%s' already exists" %
              (src, dst))

    if not isdir(dirname(dst)):
        raise DistutilsFileError(
              "can't move '%s': destination '%s' not a valid path" % \
              (src, dst))

    copy_it = 0
    try:
        os.rename(src, dst)
    except os.error, (num, msg):
        if num == errno.EXDEV:
            copy_it = 1
        else:
            raise DistutilsFileError(
                  "couldn't move '%s' to '%s': %s" % (src, dst, msg))

    if copy_it:
        copy_file(src, dst, verbose=verbose)
        try:
            os.unlink(src)
        except os.error, (num, msg):
            try:
                os.unlink(dst)
            except os.error:
                pass
            raise DistutilsFileError(
                  ("couldn't move '%s' to '%s' by copy/delete: " +
                   "delete '%s' failed: %s") %
                  (src, dst, src, msg))
    return dst


def write_file (filename, contents):
    """Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators) to it.
    """
    f = open(filename, "w")
    try:
        for line in contents:
            f.write(line + "\n")
    finally:
        f.close()
                                                             usr/lib/python2.7/distutils/file_util.pyc                                                           0100644 0000000 0000000 00000015123 13077704274 017126  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sñ   d  Z  d Z d d l Z d d l m Z d d l m Z i d d 6d d 6d	 d
 6Z d d Ñ Z	 d d d d d d d Ñ Z
 d d d Ñ Z d Ñ  Z d S(   sF   distutils.file_util

Utility functions for operating on single files.
s   $Id$iˇˇˇˇN(   t   DistutilsFileError(   t   logt   copyings   hard linkingt   hards   symbolically linkingt   symi   i   c         C   s«  d } d } zçy t |  d É } Wn2 t j k
 rV \ } } t d |  | f É Ç n Xt j j | É r≤ y t j | É Wq≤ t j k
 rÆ \ } } t d | | f É Ç q≤ Xn  y t | d É } Wn2 t j k
 r˘ \ } } t d | | f É Ç n Xxõ y | j | É } Wn2 t j k
 rD\ } } t d |  | f É Ç n X| sOPn  y | j	 | É Wq˝ t j k
 rî\ } } t d | | f É Ç q˝ Xq˝ Wd | rØ| j
 É  n  | r¬| j
 É  n  Xd S(	   s5  Copy the file 'src' to 'dst'.

    Both must be filenames. Any error opening either file, reading from
    'src', or writing to 'dst', raises DistutilsFileError.  Data is
    read/written in chunks of 'buffer_size' bytes (default 16k).  No attempt
    is made to handle anything apart from regular files.
    t   rbs   could not open '%s': %ss   could not delete '%s': %st   wbs   could not create '%s': %ss   could not read from '%s': %ss   could not write to '%s': %sN(   t   Nonet   opent   ost   errorR    t   patht   existst   unlinkt   readt   writet   close(   t   srct   dstt   buffer_sizet   fsrct   fdstt   errnot   errstrt   buf(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt   _copy_file_contents   sF    
i   i    c         C   s¬  d d l  m } d d l m }	 m }
 m } m } t j j	 |  É sW t
 d |  É Ç n  t j j | É rì | } t j j | t j j |  É É } n t j j | É } | r‰ | |  | É r‰ | d k r⁄ t j d |  É n  | d f Sy t | } Wn! t k
 rt d | É Ç n X| d k rxt j j | É t j j |  É k r_t j d	 | |  | É qxt j d	 | |  | É n  | rà| d f S| d
 k rÛt j j | É o∏t j j |  | É sCy t j |  | É | d f SWqt k
 rÏqXqCnP | d k rCt j j | É o#t j j |  | É sCt j |  | É | d f Sn  t |  | É | s\| r∏t j |  É } | rít j | | |	 | |
 f É n  | r∏t j | | | | É É q∏n  | d f S(   s  Copy a file 'src' to 'dst'.

    If 'dst' is a directory, then 'src' is copied there with the same name;
    otherwise, it must be a filename.  (If the file exists, it will be
    ruthlessly clobbered.)  If 'preserve_mode' is true (the default),
    the file's mode (type and permission bits, or whatever is analogous on
    the current platform) is copied.  If 'preserve_times' is true (the
    default), the last-modified and last-access times are copied as well.
    If 'update' is true, 'src' will only be copied if 'dst' does not exist,
    or if 'dst' does exist but is older than 'src'.

    'link' allows you to make hard links (os.link) or symbolic links
    (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
    None (the default), files are copied.  Don't set 'link' on systems that
    don't support it: 'copy_file()' doesn't check if hard or symbolic
    linking is available. If hardlink fails, falls back to
    _copy_file_contents().

    Under Mac OS, uses the native file copy function in macostools; on
    other systems, uses '_copy_file_contents()' to copy file contents.

    Return a tuple (dest_name, copied): 'dest_name' is the actual name of
    the output file, and 'copied' is true if the file was copied (or would
    have been copied, if 'dry_run' true).
    iˇˇˇˇ(   t   newer(   t   ST_ATIMEt   ST_MTIMEt   ST_MODEt   S_IMODEs4   can't copy '%s': doesn't exist or not a regular filei   s"   not copying %s (output up-to-date)i    s&   invalid value '%s' for 'link' arguments   %s %s -> %sR   R   (   t   distutils.dep_utilR   t   statR   R   R   R   R	   R   t   isfileR    t   isdirt   joint   basenamet   dirnameR   t   debugt   _copy_actiont   KeyErrort
   ValueErrort   infoR   t   samefilet   linkt   OSErrort   symlinkR   t   utimet   chmod(   R   R   t   preserve_modet   preserve_timest   updateR,   t   verboset   dry_runR   R   R   R   R   t   dirt   actiont   st(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt	   copy_fileG   sT    ""$
$
'
'! c         C   s˚  d d l  m } m } m } m } m } d d l }	 | d k rV t j d |  | É n  | r` | S| |  É s t	 d |  É Ç n  | | É r© t
 j j | | |  É É } n% | | É rŒ t	 d |  | f É Ç n  | | | É É s˘ t	 d |  | f É Ç n  d	 }
 y t
 j |  | É WnM t
 j k
 rb\ } } | |	 j k rFd }
 qct	 d
 |  | | f É Ç n X|
 r˜t |  | d | Éy t
 j |  É Wq˜t
 j k
 rÛ\ } } y t
 j | É Wn t
 j k
 rœn Xt	 d d |  | |  | f É Ç q˜Xn  | S(   s)  Move a file 'src' to 'dst'.

    If 'dst' is a directory, the file will be moved into it with the same
    name; otherwise, 'src' is just renamed to 'dst'.  Return the new
    full name of the file.

    Handles cross-device moves on Unix using 'copy_file()'.  What about
    other systems???
    iˇˇˇˇ(   R   R!   R"   R$   R%   Ni   s   moving %s -> %ss#   can't move '%s': not a regular files0   can't move '%s': destination '%s' already existss2   can't move '%s': destination '%s' not a valid pathi    s   couldn't move '%s' to '%s': %sR4   s+   couldn't move '%s' to '%s' by copy/delete: s   delete '%s' failed: %s(   t   os.pathR   R!   R"   R$   R%   R   R   R*   R    R	   R   R#   t   renameR
   t   EXDEVR9   R   (   R   R   R4   R5   R   R!   R"   R$   R%   R   t   copy_itt   numt   msg(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt	   move_file™   sP    
(	c         C   sG   t  |  d É } z& x | D] } | j | d É q WWd | j É  Xd S(   s{   Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators) to it.
    t   ws   
N(   R   R   R   (   t   filenamet   contentst   ft   line(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt
   write_fileÊ   s
    i @  (   t   __doc__t   __revision__R	   t   distutils.errorsR    t	   distutilsR   R   R'   R   R9   R@   RF   (    (    (    s)   /usr/lib/python2.7/distutils/file_util.pyt   <module>   s   

5	b<                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python2.7/distutils/filelist.py                                                             0100644 0000000 0000000 00000030621 12734733743 016624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.filelist

Provides the FileList class, used for poking about the filesystem
and building lists of files.
"""

__revision__ = "$Id$"

import os, re
import fnmatch
from distutils.util import convert_path
from distutils.errors import DistutilsTemplateError, DistutilsInternalError
from distutils import log

class FileList:
    """A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.

    Instance attributes:
      dir
        directory from which files will be taken -- only used if
        'allfiles' not supplied to constructor
      files
        list of filenames currently being built/filtered/manipulated
      allfiles
        complete list of files under consideration (ie. without any
        filtering applied)
    """

    def __init__(self, warn=None, debug_print=None):
        # ignore argument to FileList, but keep them for backwards
        # compatibility
        self.allfiles = None
        self.files = []

    def set_allfiles(self, allfiles):
        self.allfiles = allfiles

    def findall(self, dir=os.curdir):
        self.allfiles = findall(dir)

    def debug_print(self, msg):
        """Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        """
        from distutils.debug import DEBUG
        if DEBUG:
            print msg

    # -- List-like methods ---------------------------------------------

    def append(self, item):
        self.files.append(item)

    def extend(self, items):
        self.files.extend(items)

    def sort(self):
        # Not a strict lexical sort!
        sortable_files = map(os.path.split, self.files)
        sortable_files.sort()
        self.files = []
        for sort_tuple in sortable_files:
            self.files.append(os.path.join(*sort_tuple))


    # -- Other miscellaneous utility methods ---------------------------

    def remove_duplicates(self):
        # Assumes list has been sorted!
        for i in range(len(self.files) - 1, 0, -1):
            if self.files[i] == self.files[i - 1]:
                del self.files[i]


    # -- "File template" methods ---------------------------------------

    def _parse_template_line(self, line):
        words = line.split()
        action = words[0]

        patterns = dir = dir_pattern = None

        if action in ('include', 'exclude',
                      'global-include', 'global-exclude'):
            if len(words) < 2:
                raise DistutilsTemplateError, \
                      "'%s' expects <pattern1> <pattern2> ..." % action

            patterns = map(convert_path, words[1:])

        elif action in ('recursive-include', 'recursive-exclude'):
            if len(words) < 3:
                raise DistutilsTemplateError, \
                      "'%s' expects <dir> <pattern1> <pattern2> ..." % action

            dir = convert_path(words[1])
            patterns = map(convert_path, words[2:])

        elif action in ('graft', 'prune'):
            if len(words) != 2:
                raise DistutilsTemplateError, \
                     "'%s' expects a single <dir_pattern>" % action

            dir_pattern = convert_path(words[1])

        else:
            raise DistutilsTemplateError, "unknown action '%s'" % action

        return (action, patterns, dir, dir_pattern)

    def process_template_line(self, line):
        # Parse the line: split it up, make sure the right number of words
        # is there, and return the relevant words.  'action' is always
        # defined: it's the first word of the line.  Which of the other
        # three are defined depends on the action; it'll be either
        # patterns, (dir and patterns), or (dir_pattern).
        action, patterns, dir, dir_pattern = self._parse_template_line(line)

        # OK, now we know that the action is valid and we have the
        # right number of words on the line for that action -- so we
        # can proceed with minimal error-checking.
        if action == 'include':
            self.debug_print("include " + ' '.join(patterns))
            for pattern in patterns:
                if not self.include_pattern(pattern, anchor=1):
                    log.warn("warning: no files found matching '%s'",
                             pattern)

        elif action == 'exclude':
            self.debug_print("exclude " + ' '.join(patterns))
            for pattern in patterns:
                if not self.exclude_pattern(pattern, anchor=1):
                    log.warn(("warning: no previously-included files "
                              "found matching '%s'"), pattern)

        elif action == 'global-include':
            self.debug_print("global-include " + ' '.join(patterns))
            for pattern in patterns:
                if not self.include_pattern(pattern, anchor=0):
                    log.warn(("warning: no files found matching '%s' " +
                              "anywhere in distribution"), pattern)

        elif action == 'global-exclude':
            self.debug_print("global-exclude " + ' '.join(patterns))
            for pattern in patterns:
                if not self.exclude_pattern(pattern, anchor=0):
                    log.warn(("warning: no previously-included files matching "
                              "'%s' found anywhere in distribution"),
                             pattern)

        elif action == 'recursive-include':
            self.debug_print("recursive-include %s %s" %
                             (dir, ' '.join(patterns)))
            for pattern in patterns:
                if not self.include_pattern(pattern, prefix=dir):
                    log.warn(("warning: no files found matching '%s' " +
                                "under directory '%s'"),
                             pattern, dir)

        elif action == 'recursive-exclude':
            self.debug_print("recursive-exclude %s %s" %
                             (dir, ' '.join(patterns)))
            for pattern in patterns:
                if not self.exclude_pattern(pattern, prefix=dir):
                    log.warn(("warning: no previously-included files matching "
                              "'%s' found under directory '%s'"),
                             pattern, dir)

        elif action == 'graft':
            self.debug_print("graft " + dir_pattern)
            if not self.include_pattern(None, prefix=dir_pattern):
                log.warn("warning: no directories found matching '%s'",
                         dir_pattern)

        elif action == 'prune':
            self.debug_print("prune " + dir_pattern)
            if not self.exclude_pattern(None, prefix=dir_pattern):
                log.warn(("no previously-included directories found " +
                          "matching '%s'"), dir_pattern)
        else:
            raise DistutilsInternalError, \
                  "this cannot happen: invalid action '%s'" % action

    # -- Filtering/selection methods -----------------------------------

    def include_pattern(self, pattern, anchor=1, prefix=None, is_regex=0):
        """Select strings (presumably filenames) from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob) pattern.

        Patterns are not quite the same as implemented by the 'fnmatch'
        module: '*' and '?'  match non-special characters, where "special"
        is platform-dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default), then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern) and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return 1 if files are found.
        """
        # XXX docstring lying about what the special chars are?
        files_found = 0
        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)
        self.debug_print("include_pattern: applying regex r'%s'" %
                         pattern_re.pattern)

        # delayed loading of allfiles list
        if self.allfiles is None:
            self.findall()

        for name in self.allfiles:
            if pattern_re.search(name):
                self.debug_print(" adding " + name)
                self.files.append(name)
                files_found = 1

        return files_found


    def exclude_pattern(self, pattern, anchor=1, prefix=None, is_regex=0):
        """Remove strings (presumably filenames) from 'files' that match
        'pattern'.

        Other parameters are the same as for 'include_pattern()', above.
        The list 'self.files' is modified in place. Return 1 if files are
        found.
        """
        files_found = 0
        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)
        self.debug_print("exclude_pattern: applying regex r'%s'" %
                         pattern_re.pattern)
        for i in range(len(self.files)-1, -1, -1):
            if pattern_re.search(self.files[i]):
                self.debug_print(" removing " + self.files[i])
                del self.files[i]
                files_found = 1

        return files_found


# ----------------------------------------------------------------------
# Utility functions

def findall(dir = os.curdir):
    """Find all files under 'dir' and return the list of full filenames
    (relative to 'dir').
    """
    from stat import ST_MODE, S_ISREG, S_ISDIR, S_ISLNK

    list = []
    stack = [dir]
    pop = stack.pop
    push = stack.append

    while stack:
        dir = pop()
        names = os.listdir(dir)

        for name in names:
            if dir != os.curdir:        # avoid the dreaded "./" syndrome
                fullname = os.path.join(dir, name)
            else:
                fullname = name

            # Avoid excess stat calls -- just one will do, thank you!
            stat = os.stat(fullname)
            mode = stat[ST_MODE]
            if S_ISREG(mode):
                list.append(fullname)
            elif S_ISDIR(mode) and not S_ISLNK(mode):
                push(fullname)

    return list


def glob_to_re(pattern):
    """Translate a shell-like glob pattern to a regular expression.

    Return a string containing the regex.  Differs from
    'fnmatch.translate()' in that '*' does not match "special characters"
    (which are platform-specific).
    """
    pattern_re = fnmatch.translate(pattern)

    # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
    # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
    # and by extension they shouldn't match such "special characters" under
    # any OS.  So change all non-escaped dots in the RE to match any
    # character except the special characters (currently: just os.sep).
    sep = os.sep
    if os.sep == '\\':
        # we're using a regex to manipulate a regex, so we need
        # to escape the backslash twice
        sep = r'\\\\'
    escaped = r'\1[^%s]' % sep
    pattern_re = re.sub(r'((?<!\\)(\\\\)*)\.', escaped, pattern_re)
    return pattern_re


def translate_pattern(pattern, anchor=1, prefix=None, is_regex=0):
    """Translate a shell-like wildcard pattern to a compiled regular
    expression.

    Return the compiled regex.  If 'is_regex' true,
    then 'pattern' is directly compiled to a regex (if it's a string)
    or just returned as-is (assumes it's a regex object).
    """
    if is_regex:
        if isinstance(pattern, str):
            return re.compile(pattern)
        else:
            return pattern

    if pattern:
        pattern_re = glob_to_re(pattern)
    else:
        pattern_re = ''

    if prefix is not None:
        # ditch end of pattern character
        empty_pattern = glob_to_re('')
        prefix_re = glob_to_re(prefix)[:-len(empty_pattern)]
        sep = os.sep
        if os.sep == '\\':
            sep = r'\\'
        pattern_re = "^" + sep.join((prefix_re, ".*" + pattern_re))
    else:                               # no prefix -- respect anchor flag
        if anchor:
            pattern_re = "^" + pattern_re

    return re.compile(pattern_re)
                                                                                                               usr/lib/python2.7/distutils/filelist.pyc                                                            0100644 0000000 0000000 00000024742 13077704274 016774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sß   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z m	 Z	 d d l
 m Z d d d Ñ  É  YZ e j d	 Ñ Z d
 Ñ  Z d d d d Ñ Z d S(   ss   distutils.filelist

Provides the FileList class, used for poking about the filesystem
and building lists of files.
s   $Id$iˇˇˇˇN(   t   convert_path(   t   DistutilsTemplateErrort   DistutilsInternalError(   t   logt   FileListc           B   sò   e  Z d  Z d d d Ñ Z d Ñ  Z e j d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d d d d Ñ Z d d d d Ñ Z RS(   s—  A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.

    Instance attributes:
      dir
        directory from which files will be taken -- only used if
        'allfiles' not supplied to constructor
      files
        list of filenames currently being built/filtered/manipulated
      allfiles
        complete list of files under consideration (ie. without any
        filtering applied)
    c         C   s   d  |  _ g  |  _ d  S(   N(   t   Nonet   allfilest   files(   t   selft   warnt   debug_print(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   __init__   s    	c         C   s   | |  _  d  S(   N(   R   (   R   R   (    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   set_allfiles$   s    c         C   s   t  | É |  _ d  S(   N(   t   findallR   (   R   t   dir(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   '   s    c         C   s"   d d l  m } | r | GHn  d S(   s~   Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        iˇˇˇˇ(   t   DEBUGN(   t   distutils.debugR   (   R   t   msgR   (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR
   *   s    c         C   s   |  j  j | É d  S(   N(   R   t   append(   R   t   item(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   4   s    c         C   s   |  j  j | É d  S(   N(   R   t   extend(   R   t   items(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   7   s    c         C   s\   t  t j j |  j É } | j É  g  |  _ x* | D]" } |  j j t j j | å  É q2 Wd  S(   N(   t   mapt   ost   patht   splitR   t   sortR   t   join(   R   t   sortable_filest
   sort_tuple(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   :   s
    
	c         C   sY   xR t  t |  j É d d d É D]1 } |  j | |  j | d k r  |  j | =q  q  Wd  S(   Ni   i    iˇˇˇˇ(   t   ranget   lenR   (   R   t   i(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   remove_duplicatesE   s    &c         C   s  | j  É  } | d } d  } } } | d k rh t | É d k  rR t d | Ç n  t t | d É } n¢ | d k rº t | É d k  rñ t d | Ç n  t | d É } t t | d É } nN | d k r˝ t | É d k rÍ t d | Ç n  t | d É } n t d | Ç | | | | f S(   Ni    t   includet   excludes   global-includes   global-excludei   s&   '%s' expects <pattern1> <pattern2> ...i   s   recursive-includes   recursive-excludei   s,   '%s' expects <dir> <pattern1> <pattern2> ...t   graftt   prunes#   '%s' expects a single <dir_pattern>s   unknown action '%s'(   R"   R#   s   global-includes   global-exclude(   s   recursive-includes   recursive-exclude(   R$   R%   (   R   R   R   R   R   R    (   R   t   linet   wordst   actiont   patternsR   t   dir_pattern(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   _parse_template_lineN   s,    
	c         C   s&  |  j  | É \ } } } } | d k r} |  j d d j | É É xﬁ| D]. } |  j | d d ÉsH t j d | É qH qH Wn•| d k rﬂ |  j d d j | É É x|| D]. } |  j | d d És™ t j d	 | É q™ q™ WnC| d
 k rE|  j d d j | É É x| D]2 } |  j | d d Ést j d d | É qqWn›| d k rß|  j d d j | É É x¥| D]. } |  j | d d Ésrt j d | É qrqrWn{| d k r|  j d | d j | É f É xL| D]5 } |  j | d | És⁄t j d d | | É q⁄q⁄Wn| d k rÅ|  j d | d j | É f É x› | D]1 } |  j | d | ÉsIt j d | | É qIqIWn° | d k r…|  j d | É |  j d  d | És"t j d | É q"nY | d k r|  j d | É |  j d  d | És"t j d d | É q"n t d  | Ç d  S(!   NR"   s   include t    t   anchori   s%   warning: no files found matching '%s'R#   s   exclude s9   warning: no previously-included files found matching '%s's   global-includes   global-include i    s&   warning: no files found matching '%s' s   anywhere in distributions   global-excludes   global-exclude sR   warning: no previously-included files matching '%s' found anywhere in distributions   recursive-includes   recursive-include %s %st   prefixs   under directory '%s's   recursive-excludes   recursive-exclude %s %ssN   warning: no previously-included files matching '%s' found under directory '%s'R$   s   graft s+   warning: no directories found matching '%s'R%   s   prune s)   no previously-included directories found s   matching '%s's'   this cannot happen: invalid action '%s'(	   R+   R
   R   t   include_patternR   R	   t   exclude_patternR   R   (   R   R&   R(   R)   R   R*   t   pattern(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   process_template_linep   sh    										i   i    c         C   sú   d } t  | | | | É } |  j d | j É |  j d k rK |  j É  n  xJ |  j D]? } | j | É rU |  j d | É |  j j | É d } qU qU W| S(   sÇ  Select strings (presumably filenames) from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob) pattern.

        Patterns are not quite the same as implemented by the 'fnmatch'
        module: '*' and '?'  match non-special characters, where "special"
        is platform-dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default), then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern) and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return 1 if files are found.
        i    s%   include_pattern: applying regex r'%s's    adding i   N(	   t   translate_patternR
   R1   R   R   R   t   searchR   R   (   R   R1   R-   R.   t   is_regext   files_foundt
   pattern_ret   name(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR/   ª   s    	c         C   sû   d } t  | | | | É } |  j d | j É xh t t |  j É d d d É D]G } | j |  j | É rO |  j d |  j | É |  j | =d } qO qO W| S(   s¸   Remove strings (presumably filenames) from 'files' that match
        'pattern'.

        Other parameters are the same as for 'include_pattern()', above.
        The list 'self.files' is modified in place. Return 1 if files are
        found.
        i    s%   exclude_pattern: applying regex r'%s'i   iˇˇˇˇs
    removing (   R3   R
   R1   R   R   R   R4   (   R   R1   R-   R.   R5   R6   R7   R    (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR0   Ë   s    	&
N(   t   __name__t
   __module__t   __doc__R   R   R   R   t   curdirR   R
   R   R   R   R!   R+   R2   R/   R0   (    (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR      s   		
						"	K-c         C   s  d d l  m } m } m } m } g  } |  g } | j } | j } xª | r | É  }  t j |  É }	 xñ |	 D]é }
 |  t j	 k rò t j
 j |  |
 É } n |
 } t j  | É } | | } | | É r” | j | É qk | | É rk | | É rk | | É qk qk WqF W| S(   s^   Find all files under 'dir' and return the list of full filenames
    (relative to 'dir').
    iˇˇˇˇ(   t   ST_MODEt   S_ISREGt   S_ISDIRt   S_ISLNK(   t   statR=   R>   R?   R@   t   popR   R   t   listdirR<   R   R   (   R   R=   R>   R?   R@   t   listt   stackRB   t   pusht   namesR8   t   fullnameRA   t   mode(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR      s&    "					
c         C   sS   t  j |  É } t j } t j d k r0 d } n  d | } t j d | | É } | S(   sÁ   Translate a shell-like glob pattern to a regular expression.

    Return a string containing the regex.  Differs from
    'fnmatch.translate()' in that '*' does not match "special characters"
    (which are platform-specific).
    s   \s   \\\\s   \1[^%s]s   ((?<!\\)(\\\\)*)\.(   t   fnmatcht	   translateR   t   sept   ret   sub(   R1   R7   RL   t   escaped(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt
   glob_to_re   s    		
i   i    c         C   s‘   | r) t  |  t É r" t j |  É S|  Sn  |  r> t |  É } n d } | d k	 r¥ t d É } t | É t | É  } t j } t j d k rî d } n  d | j	 | d | f É } n | r« d | } n  t j | É S(   s  Translate a shell-like wildcard pattern to a compiled regular
    expression.

    Return the compiled regex.  If 'is_regex' true,
    then 'pattern' is directly compiled to a regex (if it's a string)
    or just returned as-is (assumes it's a regex object).
    t    s   \s   \\t   ^s   .*N(
   t
   isinstancet   strRM   t   compileRP   R   R   R   RL   R   (   R1   R-   R.   R5   R7   t   empty_patternt	   prefix_reRL   (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR3   8  s"    		 (    (   R;   t   __revision__R   RM   RJ   t   distutils.utilR    t   distutils.errorsR   R   t	   distutilsR   R   R<   R   RP   R   R3   (    (    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   <module>   s   Ò 	                              usr/lib/python2.7/distutils/log.py                                                                  0100644 0000000 0000000 00000003226 12734733743 015573  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """A simple log mechanism styled after PEP 282."""

# The class here is styled after PEP 282 so that it could later be
# replaced with a standard Python logging implementation.

DEBUG = 1
INFO = 2
WARN = 3
ERROR = 4
FATAL = 5

import sys

class Log:

    def __init__(self, threshold=WARN):
        self.threshold = threshold

    def _log(self, level, msg, args):
        if level not in (DEBUG, INFO, WARN, ERROR, FATAL):
            raise ValueError('%s wrong log level' % str(level))

        if level >= self.threshold:
            if args:
                msg = msg % args
            if level in (WARN, ERROR, FATAL):
                stream = sys.stderr
            else:
                stream = sys.stdout
            stream.write('%s\n' % msg)
            stream.flush()

    def log(self, level, msg, *args):
        self._log(level, msg, args)

    def debug(self, msg, *args):
        self._log(DEBUG, msg, args)

    def info(self, msg, *args):
        self._log(INFO, msg, args)

    def warn(self, msg, *args):
        self._log(WARN, msg, args)

    def error(self, msg, *args):
        self._log(ERROR, msg, args)

    def fatal(self, msg, *args):
        self._log(FATAL, msg, args)

_global_log = Log()
log = _global_log.log
debug = _global_log.debug
info = _global_log.info
warn = _global_log.warn
error = _global_log.error
fatal = _global_log.fatal

def set_threshold(level):
    # return the old threshold for use from tests
    old = _global_log.threshold
    _global_log.threshold = level
    return old

def set_verbosity(v):
    if v <= 0:
        set_threshold(WARN)
    elif v == 1:
        set_threshold(INFO)
    elif v >= 2:
        set_threshold(DEBUG)
                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python2.7/distutils/log.pyc                                                                 0100644 0000000 0000000 00000005312 13077704274 015732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sò   d  Z  d Z d Z d Z d Z d Z d d l Z d d d	 Ñ  É  YZ e É  Z e j	 Z	 e j
 Z
 e j Z e j Z e j Z e j Z d
 Ñ  Z d Ñ  Z d S(   s,   A simple log mechanism styled after PEP 282.i   i   i   i   i   iˇˇˇˇNt   Logc           B   sS   e  Z e d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   c         C   s   | |  _  d  S(   N(   t	   threshold(   t   selfR   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   __init__   s    c         C   s¢   | t  t t t t f k r4 t d t | É É Ç n  | |  j k rû | rV | | } n  | t t t f k rw t j	 } n	 t j
 } | j d | É | j É  n  d  S(   Ns   %s wrong log levels   %s
(   t   DEBUGt   INFOt   WARNt   ERRORt   FATALt
   ValueErrort   strR   t   syst   stderrt   stdoutt   writet   flush(   R   t   levelt   msgt   argst   stream(    (    s#   /usr/lib/python2.7/distutils/log.pyt   _log   s    	c         G   s   |  j  | | | É d  S(   N(   R   (   R   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   log!   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   debug$   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   info'   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   warn*   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   error-   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   fatal0   s    (   t   __name__t
   __module__R   R   R   R   R   R   R   R   R   (    (    (    s#   /usr/lib/python2.7/distutils/log.pyR       s   						c         C   s   t  j } |  t  _ | S(   N(   t   _global_logR   (   R   t   old(    (    s#   /usr/lib/python2.7/distutils/log.pyt   set_threshold;   s    		c         C   sO   |  d k r t  t É n2 |  d k r2 t  t É n |  d k rK t  t É n  d  S(   Ni    i   i   (   R   R   R   R   (   t   v(    (    s#   /usr/lib/python2.7/distutils/log.pyt   set_verbosityA   s    (    (   t   __doc__R   R   R   R   R   R   R    R   R   R   R   R   R   R   R   R!   (    (    (    s#   /usr/lib/python2.7/distutils/log.pyt   <module>   s    %								                                                                                                                                                                                                                                                                                                                      usr/lib/python2.7/distutils/msvc9compiler.py                                                        0100644 0000000 0000000 00000074452 12734733743 017617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.msvc9compiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio 2008.

The module is compatible with VS 2005 and VS 2008. You can find legacy support
for older versions of VS in distutils.msvccompiler.
"""

# Written by Perry Stoll
# hacked by Robin Becker and Thomas Heller to do a better job of
#   finding DevStudio (through the registry)
# ported to VS2005 and VS 2008 by Christian Heimes

__revision__ = "$Id$"

import os
import subprocess
import sys
import re

from distutils.errors import (DistutilsExecError, DistutilsPlatformError,
                              CompileError, LibError, LinkError)
from distutils.ccompiler import CCompiler, gen_lib_options
from distutils import log
from distutils.util import get_platform

import _winreg

RegOpenKeyEx = _winreg.OpenKeyEx
RegEnumKey = _winreg.EnumKey
RegEnumValue = _winreg.EnumValue
RegError = _winreg.error

HKEYS = (_winreg.HKEY_USERS,
         _winreg.HKEY_CURRENT_USER,
         _winreg.HKEY_LOCAL_MACHINE,
         _winreg.HKEY_CLASSES_ROOT)

NATIVE_WIN64 = (sys.platform == 'win32' and sys.maxsize > 2**32)
if NATIVE_WIN64:
    # Visual C++ is a 32-bit application, so we need to look in
    # the corresponding registry branch, if we're running a
    # 64-bit Python on Win64
    VS_BASE = r"Software\Wow6432Node\Microsoft\VisualStudio\%0.1f"
    VSEXPRESS_BASE = r"Software\Wow6432Node\Microsoft\VCExpress\%0.1f"
    WINSDK_BASE = r"Software\Wow6432Node\Microsoft\Microsoft SDKs\Windows"
    NET_BASE = r"Software\Wow6432Node\Microsoft\.NETFramework"
else:
    VS_BASE = r"Software\Microsoft\VisualStudio\%0.1f"
    VSEXPRESS_BASE = r"Software\Microsoft\VCExpress\%0.1f"
    WINSDK_BASE = r"Software\Microsoft\Microsoft SDKs\Windows"
    NET_BASE = r"Software\Microsoft\.NETFramework"

# A map keyed by get_platform() return values to values accepted by
# 'vcvarsall.bat'.  Note a cross-compile may combine these (eg, 'x86_amd64' is
# the param to cross-compile on x86 targetting amd64.)
PLAT_TO_VCVARS = {
    'win32' : 'x86',
    'win-amd64' : 'amd64',
    'win-ia64' : 'ia64',
}

class Reg:
    """Helper class to read values from the registry
    """

    def get_value(cls, path, key):
        for base in HKEYS:
            d = cls.read_values(base, path)
            if d and key in d:
                return d[key]
        raise KeyError(key)
    get_value = classmethod(get_value)

    def read_keys(cls, base, key):
        """Return list of registry keys."""
        try:
            handle = RegOpenKeyEx(base, key)
        except RegError:
            return None
        L = []
        i = 0
        while True:
            try:
                k = RegEnumKey(handle, i)
            except RegError:
                break
            L.append(k)
            i += 1
        return L
    read_keys = classmethod(read_keys)

    def read_values(cls, base, key):
        """Return dict of registry keys and values.

        All names are converted to lowercase.
        """
        try:
            handle = RegOpenKeyEx(base, key)
        except RegError:
            return None
        d = {}
        i = 0
        while True:
            try:
                name, value, type = RegEnumValue(handle, i)
            except RegError:
                break
            name = name.lower()
            d[cls.convert_mbcs(name)] = cls.convert_mbcs(value)
            i += 1
        return d
    read_values = classmethod(read_values)

    def convert_mbcs(s):
        dec = getattr(s, "decode", None)
        if dec is not None:
            try:
                s = dec("mbcs")
            except UnicodeError:
                pass
        return s
    convert_mbcs = staticmethod(convert_mbcs)

class MacroExpander:

    def __init__(self, version):
        self.macros = {}
        self.vsbase = VS_BASE % version
        self.load_macros(version)

    def set_macro(self, macro, path, key):
        self.macros["$(%s)" % macro] = Reg.get_value(path, key)

    def load_macros(self, version):
        self.set_macro("VCInstallDir", self.vsbase + r"\Setup\VC", "productdir")
        self.set_macro("VSInstallDir", self.vsbase + r"\Setup\VS", "productdir")
        self.set_macro("FrameworkDir", NET_BASE, "installroot")
        try:
            if version >= 8.0:
                self.set_macro("FrameworkSDKDir", NET_BASE,
                               "sdkinstallrootv2.0")
            else:
                raise KeyError("sdkinstallrootv2.0")
        except KeyError:
            raise DistutilsPlatformError(
            """Python was built with Visual Studio 2008;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2008 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.""")

        if version >= 9.0:
            self.set_macro("FrameworkVersion", self.vsbase, "clr version")
            self.set_macro("WindowsSdkDir", WINSDK_BASE, "currentinstallfolder")
        else:
            p = r"Software\Microsoft\NET Framework Setup\Product"
            for base in HKEYS:
                try:
                    h = RegOpenKeyEx(base, p)
                except RegError:
                    continue
                key = RegEnumKey(h, 0)
                d = Reg.get_value(base, r"%s\%s" % (p, key))
                self.macros["$(FrameworkVersion)"] = d["version"]

    def sub(self, s):
        for k, v in self.macros.items():
            s = s.replace(k, v)
        return s

def get_build_version():
    """Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    """
    prefix = "MSC v."
    i = sys.version.find(prefix)
    if i == -1:
        return 6
    i = i + len(prefix)
    s, rest = sys.version[i:].split(" ", 1)
    majorVersion = int(s[:-2]) - 6
    minorVersion = int(s[2:3]) / 10.0
    # I don't think paths are affected by minor version in version 6
    if majorVersion == 6:
        minorVersion = 0
    if majorVersion >= 6:
        return majorVersion + minorVersion
    # else we don't know what version of the compiler this is
    return None

def normalize_and_reduce_paths(paths):
    """Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    """
    # Paths are normalized so things like:  /a and /a/ aren't both preserved.
    reduced_paths = []
    for p in paths:
        np = os.path.normpath(p)
        # XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.
        if np not in reduced_paths:
            reduced_paths.append(np)
    return reduced_paths

def removeDuplicates(variable):
    """Remove duplicate values of an environment variable.
    """
    oldList = variable.split(os.pathsep)
    newList = []
    for i in oldList:
        if i not in newList:
            newList.append(i)
    newVariable = os.pathsep.join(newList)
    return newVariable

def find_vcvarsall(version):
    """Find the vcvarsall.bat file

    At first it tries to find the productdir of VS 2008 in the registry. If
    that fails it falls back to the VS90COMNTOOLS env var.
    """
    vsbase = VS_BASE % version
    try:
        productdir = Reg.get_value(r"%s\Setup\VC" % vsbase,
                                   "productdir")
    except KeyError:
        productdir = None

    # trying Express edition
    if productdir is None:
        vsbase = VSEXPRESS_BASE % version
        try:
            productdir = Reg.get_value(r"%s\Setup\VC" % vsbase,
                                       "productdir")
        except KeyError:
            productdir = None
            log.debug("Unable to find productdir in registry")

    if not productdir or not os.path.isdir(productdir):
        toolskey = "VS%0.f0COMNTOOLS" % version
        toolsdir = os.environ.get(toolskey, None)

        if toolsdir and os.path.isdir(toolsdir):
            productdir = os.path.join(toolsdir, os.pardir, os.pardir, "VC")
            productdir = os.path.abspath(productdir)
            if not os.path.isdir(productdir):
                log.debug("%s is not a valid directory" % productdir)
                return None
        else:
            log.debug("Env var %s is not set or invalid" % toolskey)
    if not productdir:
        log.debug("No productdir found")
        return None
    vcvarsall = os.path.join(productdir, "vcvarsall.bat")
    if os.path.isfile(vcvarsall):
        return vcvarsall
    log.debug("Unable to find vcvarsall.bat")
    return None

def query_vcvarsall(version, arch="x86"):
    """Launch vcvarsall.bat and read the settings from its environment
    """
    vcvarsall = find_vcvarsall(version)
    interesting = set(("include", "lib", "libpath", "path"))
    result = {}

    if vcvarsall is None:
        raise DistutilsPlatformError("Unable to find vcvarsall.bat")
    log.debug("Calling 'vcvarsall.bat %s' (version=%s)", arch, version)
    popen = subprocess.Popen('"%s" %s & set' % (vcvarsall, arch),
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
    try:
        stdout, stderr = popen.communicate()
        if popen.wait() != 0:
            raise DistutilsPlatformError(stderr.decode("mbcs"))

        stdout = stdout.decode("mbcs")
        for line in stdout.split("\n"):
            line = Reg.convert_mbcs(line)
            if '=' not in line:
                continue
            line = line.strip()
            key, value = line.split('=', 1)
            key = key.lower()
            if key in interesting:
                if value.endswith(os.pathsep):
                    value = value[:-1]
                result[key] = removeDuplicates(value)

    finally:
        popen.stdout.close()
        popen.stderr.close()

    if len(result) != len(interesting):
        raise ValueError(str(list(result.keys())))

    return result

# More globals
VERSION = get_build_version()
if VERSION < 8.0:
    raise DistutilsPlatformError("VC %0.1f is not supported by this module" % VERSION)
# MACROS = MacroExpander(VERSION)

class MSVCCompiler(CCompiler) :
    """Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class."""

    compiler_type = 'msvc'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']
    _rc_extensions = ['.rc']
    _mc_extensions = ['.mc']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = (_c_extensions + _cpp_extensions +
                      _rc_extensions + _mc_extensions)
    res_extension = '.res'
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'

    def __init__(self, verbose=0, dry_run=0, force=0):
        CCompiler.__init__ (self, verbose, dry_run, force)
        self.__version = VERSION
        self.__root = r"Software\Microsoft\VisualStudio"
        # self.__macros = MACROS
        self.__paths = []
        # target platform (.plat_name is consistent with 'bdist')
        self.plat_name = None
        self.__arch = None # deprecated name
        self.initialized = False

    def initialize(self, plat_name=None):
        # multi-init means we would need to check platform same each time...
        assert not self.initialized, "don't init multiple times"
        if plat_name is None:
            plat_name = get_platform()
        # sanity check for platforms to prevent obscure errors later.
        ok_plats = 'win32', 'win-amd64', 'win-ia64'
        if plat_name not in ok_plats:
            raise DistutilsPlatformError("--plat-name must be one of %s" %
                                         (ok_plats,))

        if "DISTUTILS_USE_SDK" in os.environ and "MSSdk" in os.environ and self.find_exe("cl.exe"):
            # Assume that the SDK set up everything alright; don't try to be
            # smarter
            self.cc = "cl.exe"
            self.linker = "link.exe"
            self.lib = "lib.exe"
            self.rc = "rc.exe"
            self.mc = "mc.exe"
        else:
            # On x86, 'vcvars32.bat amd64' creates an env that doesn't work;
            # to cross compile, you use 'x86_amd64'.
            # On AMD64, 'vcvars32.bat amd64' is a native build env; to cross
            # compile use 'x86' (ie, it runs the x86 compiler directly)
            # No idea how itanium handles this, if at all.
            if plat_name == get_platform() or plat_name == 'win32':
                # native build or cross-compile to win32
                plat_spec = PLAT_TO_VCVARS[plat_name]
            else:
                # cross compile from win32 -> some 64bit
                plat_spec = PLAT_TO_VCVARS[get_platform()] + '_' + \
                            PLAT_TO_VCVARS[plat_name]

            vc_env = query_vcvarsall(VERSION, plat_spec)

            # take care to only use strings in the environment.
            self.__paths = vc_env['path'].encode('mbcs').split(os.pathsep)
            os.environ['lib'] = vc_env['lib'].encode('mbcs')
            os.environ['include'] = vc_env['include'].encode('mbcs')

            if len(self.__paths) == 0:
                raise DistutilsPlatformError("Python was built with %s, "
                       "and extensions need to be built with the same "
                       "version of the compiler, but it isn't installed."
                       % self.__product)

            self.cc = self.find_exe("cl.exe")
            self.linker = self.find_exe("link.exe")
            self.lib = self.find_exe("lib.exe")
            self.rc = self.find_exe("rc.exe")   # resource compiler
            self.mc = self.find_exe("mc.exe")   # message compiler
            #self.set_path_env_var('lib')
            #self.set_path_env_var('include')

        # extend the MSVC path with the current path
        try:
            for p in os.environ['path'].split(';'):
                self.__paths.append(p)
        except KeyError:
            pass
        self.__paths = normalize_and_reduce_paths(self.__paths)
        os.environ['path'] = ";".join(self.__paths)

        self.preprocess_options = None
        if self.__arch == "x86":
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3',
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3',
                                          '/Z7', '/D_DEBUG']
        else:
            # Win64
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GS-' ,
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GS-',
                                          '/Z7', '/D_DEBUG']

        self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']
        if self.__version >= 7:
            self.ldflags_shared_debug = [
                '/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG', '/pdb:None'
                ]
        self.ldflags_static = [ '/nologo']

        self.initialized = True

    # -- Worker methods ------------------------------------------------

    def object_filenames(self,
                         source_filenames,
                         strip_dir=0,
                         output_dir=''):
        # Copied from ccompiler.py, extended to return .res as 'object'-file
        # for .rc input file
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            (base, ext) = os.path.splitext (src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            if ext not in self.src_extensions:
                # Better to raise an exception instead of silently continuing
                # and later complain about sources and targets having
                # different lengths
                raise CompileError ("Don't know how to compile %s" % src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext in self._rc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            elif ext in self._mc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            else:
                obj_names.append (os.path.join (output_dir,
                                                base + self.obj_extension))
        return obj_names


    def compile(self, sources,
                output_dir=None, macros=None, include_dirs=None, debug=0,
                extra_preargs=None, extra_postargs=None, depends=None):

        if not self.initialized:
            self.initialize()
        compile_info = self._setup_compile(output_dir, macros, include_dirs,
                                           sources, depends, extra_postargs)
        macros, objects, extra_postargs, pp_opts, build = compile_info

        compile_opts = extra_preargs or []
        compile_opts.append ('/c')
        if debug:
            compile_opts.extend(self.compile_options_debug)
        else:
            compile_opts.extend(self.compile_options)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            if debug:
                # pass the full pathname to MSVC in debug mode,
                # this allows the debugger to find the source file
                # without asking the user to browse for it
                src = os.path.abspath(src)

            if ext in self._c_extensions:
                input_opt = "/Tc" + src
            elif ext in self._cpp_extensions:
                input_opt = "/Tp" + src
            elif ext in self._rc_extensions:
                # compile .RC to .RES file
                input_opt = src
                output_opt = "/fo" + obj
                try:
                    self.spawn([self.rc] + pp_opts +
                               [output_opt] + [input_opt])
                except DistutilsExecError, msg:
                    raise CompileError(msg)
                continue
            elif ext in self._mc_extensions:
                # Compile .MC to .RC file to .RES file.
                #   * '-h dir' specifies the directory for the
                #     generated include file
                #   * '-r dir' specifies the target directory of the
                #     generated RC file and the binary message resource
                #     it includes
                #
                # For now (since there are no options to change this),
                # we use the source-directory for the include file and
                # the build directory for the RC file and message
                # resources. This works at least for win32all.
                h_dir = os.path.dirname(src)
                rc_dir = os.path.dirname(obj)
                try:
                    # first compile .MC to .RC and .H file
                    self.spawn([self.mc] +
                               ['-h', h_dir, '-r', rc_dir] + [src])
                    base, _ = os.path.splitext (os.path.basename (src))
                    rc_file = os.path.join (rc_dir, base + '.rc')
                    # then compile .RC to .RES file
                    self.spawn([self.rc] +
                               ["/fo" + obj] + [rc_file])

                except DistutilsExecError, msg:
                    raise CompileError(msg)
                continue
            else:
                # how to handle this file?
                raise CompileError("Don't know how to compile %s to %s"
                                   % (src, obj))

            output_opt = "/Fo" + obj
            try:
                self.spawn([self.cc] + compile_opts + pp_opts +
                           [input_opt, output_opt] +
                           extra_postargs)
            except DistutilsExecError, msg:
                raise CompileError(msg)

        return objects


    def create_static_lib(self,
                          objects,
                          output_libname,
                          output_dir=None,
                          debug=0,
                          target_lang=None):

        if not self.initialized:
            self.initialize()
        (objects, output_dir) = self._fix_object_args(objects, output_dir)
        output_filename = self.library_filename(output_libname,
                                                output_dir=output_dir)

        if self._need_link(objects, output_filename):
            lib_args = objects + ['/OUT:' + output_filename]
            if debug:
                pass # XXX what goes here?
            try:
                self.spawn([self.lib] + lib_args)
            except DistutilsExecError, msg:
                raise LibError(msg)
        else:
            log.debug("skipping %s (up-to-date)", output_filename)


    def link(self,
             target_desc,
             objects,
             output_filename,
             output_dir=None,
             libraries=None,
             library_dirs=None,
             runtime_library_dirs=None,
             export_symbols=None,
             debug=0,
             extra_preargs=None,
             extra_postargs=None,
             build_temp=None,
             target_lang=None):

        if not self.initialized:
            self.initialize()
        (objects, output_dir) = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs,
                                        runtime_library_dirs)
        (libraries, library_dirs, runtime_library_dirs) = fixed_args

        if runtime_library_dirs:
            self.warn ("I don't know what to do with 'runtime_library_dirs': "
                       + str (runtime_library_dirs))

        lib_opts = gen_lib_options(self,
                                   library_dirs, runtime_library_dirs,
                                   libraries)
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)

        if self._need_link(objects, output_filename):
            if target_desc == CCompiler.EXECUTABLE:
                if debug:
                    ldflags = self.ldflags_shared_debug[1:]
                else:
                    ldflags = self.ldflags_shared[1:]
            else:
                if debug:
                    ldflags = self.ldflags_shared_debug
                else:
                    ldflags = self.ldflags_shared

            export_opts = []
            for sym in (export_symbols or []):
                export_opts.append("/EXPORT:" + sym)

            ld_args = (ldflags + lib_opts + export_opts +
                       objects + ['/OUT:' + output_filename])

            # The MSVC linker generates .lib and .exp files, which cannot be
            # suppressed by any linker switches. The .lib files may even be
            # needed! Make sure they are generated in the temporary build
            # directory. Since they have different names for debug and release
            # builds, they can go into the same directory.
            build_temp = os.path.dirname(objects[0])
            if export_symbols is not None:
                (dll_name, dll_ext) = os.path.splitext(
                    os.path.basename(output_filename))
                implib_file = os.path.join(
                    build_temp,
                    self.library_filename(dll_name))
                ld_args.append ('/IMPLIB:' + implib_file)

            self.manifest_setup_ldargs(output_filename, build_temp, ld_args)

            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)

            self.mkpath(os.path.dirname(output_filename))
            try:
                self.spawn([self.linker] + ld_args)
            except DistutilsExecError, msg:
                raise LinkError(msg)

            # embed the manifest
            # XXX - this is somewhat fragile - if mt.exe fails, distutils
            # will still consider the DLL up-to-date, but it will not have a
            # manifest.  Maybe we should link to a temp file?  OTOH, that
            # implies a build environment error that shouldn't go undetected.
            mfinfo = self.manifest_get_embed_info(target_desc, ld_args)
            if mfinfo is not None:
                mffilename, mfid = mfinfo
                out_arg = '-outputresource:%s;%s' % (output_filename, mfid)
                try:
                    self.spawn(['mt.exe', '-nologo', '-manifest',
                                mffilename, out_arg])
                except DistutilsExecError, msg:
                    raise LinkError(msg)
        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    def manifest_setup_ldargs(self, output_filename, build_temp, ld_args):
        # If we need a manifest at all, an embedded manifest is recommended.
        # See MSDN article titled
        # "How to: Embed a Manifest Inside a C/C++ Application"
        # (currently at http://msdn2.microsoft.com/en-us/library/ms235591(VS.80).aspx)
        # Ask the linker to generate the manifest in the temp dir, so
        # we can check it, and possibly embed it, later.
        temp_manifest = os.path.join(
                build_temp,
                os.path.basename(output_filename) + ".manifest")
        ld_args.append('/MANIFESTFILE:' + temp_manifest)

    def manifest_get_embed_info(self, target_desc, ld_args):
        # If a manifest should be embedded, return a tuple of
        # (manifest_filename, resource_id).  Returns None if no manifest
        # should be embedded.  See http://bugs.python.org/issue7833 for why
        # we want to avoid any manifest for extension modules if we can)
        for arg in ld_args:
            if arg.startswith("/MANIFESTFILE:"):
                temp_manifest = arg.split(":", 1)[1]
                break
        else:
            # no /MANIFESTFILE so nothing to do.
            return None
        if target_desc == CCompiler.EXECUTABLE:
            # by default, executables always get the manifest with the
            # CRT referenced.
            mfid = 1
        else:
            # Extension modules try and avoid any manifest if possible.
            mfid = 2
            temp_manifest = self._remove_visual_c_ref(temp_manifest)
        if temp_manifest is None:
            return None
        return temp_manifest, mfid

    def _remove_visual_c_ref(self, manifest_file):
        try:
            # Remove references to the Visual C runtime, so they will
            # fall through to the Visual C dependency of Python.exe.
            # This way, when installed for a restricted user (e.g.
            # runtimes are not in WinSxS folder, but in Python's own
            # folder), the runtimes do not need to be in every folder
            # with .pyd's.
            # Returns either the filename of the modified manifest or
            # None if no manifest should be embedded.
            manifest_f = open(manifest_file)
            try:
                manifest_buf = manifest_f.read()
            finally:
                manifest_f.close()
            pattern = re.compile(
                r"""<assemblyIdentity.*?name=("|')Microsoft\."""\
                r"""VC\d{2}\.CRT("|').*?(/>|</assemblyIdentity>)""",
                re.DOTALL)
            manifest_buf = re.sub(pattern, "", manifest_buf)
            pattern = "<dependentAssembly>\s*</dependentAssembly>"
            manifest_buf = re.sub(pattern, "", manifest_buf)
            # Now see if any other assemblies are referenced - if not, we
            # don't want a manifest embedded.
            pattern = re.compile(
                r"""<assemblyIdentity.*?name=(?:"|')(.+?)(?:"|')"""
                r""".*?(?:/>|</assemblyIdentity>)""", re.DOTALL)
            if re.search(pattern, manifest_buf) is None:
                return None

            manifest_f = open(manifest_file, 'w')
            try:
                manifest_f.write(manifest_buf)
                return manifest_file
            finally:
                manifest_f.close()
        except IOError:
            pass

    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function, in
    # ccompiler.py.

    def library_dir_option(self, dir):
        return "/LIBPATH:" + dir

    def runtime_library_dir_option(self, dir):
        raise DistutilsPlatformError(
              "don't know how to set runtime library search path for MSVC++")

    def library_option(self, lib):
        return self.library_filename(lib)


    def find_library_file(self, dirs, lib, debug=0):
        # Prefer a debugging library if found (and requested), but deal
        # with it if we don't have one.
        if debug:
            try_names = [lib + "_d", lib]
        else:
            try_names = [lib]
        for dir in dirs:
            for name in try_names:
                libfile = os.path.join(dir, self.library_filename (name))
                if os.path.exists(libfile):
                    return libfile
        else:
            # Oops, didn't find it in *any* of 'dirs'
            return None

    # Helper methods for using the MSVC registry settings

    def find_exe(self, exe):
        """Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        """
        for p in self.__paths:
            fn = os.path.join(os.path.abspath(p), exe)
            if os.path.isfile(fn):
                return fn

        # didn't find it; try existing path
        for p in os.environ['Path'].split(';'):
            fn = os.path.join(os.path.abspath(p),exe)
            if os.path.isfile(fn):
                return fn

        return exe
                                                                                                                                                                                                                      usr/lib/python2.7/distutils/msvc9compiler.pyc                                                       0100644 0000000 0000000 00000051723 13077704274 017754  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sÚ  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l m Z m Z m	 Z	 m
 Z
 m Z d d l m Z m Z d d l m Z d d l m Z d d l Z e j Z e j Z e j Z e j Z e j e j e j e j f Z  e j! d k oe j" d% k Z# e# r'd Z$ d Z% d Z& d Z' n d Z$ d Z% d Z& d Z' i d d 6d d 6d d 6Z( d d& d Ñ  É  YZ) d d' d Ñ  É  YZ* d Ñ  Z+ d Ñ  Z, d Ñ  Z- d Ñ  Z. d d  Ñ Z/ e+ É  Z0 e0 d! k  rÿe d" e0 É Ç n  d# e f d$ Ñ  É  YZ1 d S((   s  distutils.msvc9compiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio 2008.

The module is compatible with VS 2005 and VS 2008. You can find legacy support
for older versions of VS in distutils.msvccompiler.
s   $Id$iˇˇˇˇN(   t   DistutilsExecErrort   DistutilsPlatformErrort   CompileErrort   LibErrort	   LinkError(   t	   CCompilert   gen_lib_options(   t   log(   t   get_platformt   win32i   i    s1   Software\Wow6432Node\Microsoft\VisualStudio\%0.1fs.   Software\Wow6432Node\Microsoft\VCExpress\%0.1fs5   Software\Wow6432Node\Microsoft\Microsoft SDKs\Windowss,   Software\Wow6432Node\Microsoft\.NETFrameworks%   Software\Microsoft\VisualStudio\%0.1fs"   Software\Microsoft\VCExpress\%0.1fs)   Software\Microsoft\Microsoft SDKs\Windowss    Software\Microsoft\.NETFrameworkt   x86t   amd64s	   win-amd64t   ia64s   win-ia64t   Regc           B   sb   e  Z d  Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z RS(   s2   Helper class to read values from the registry
    c         C   sM   x: t  D]2 } |  j | | É } | r | | k r | | Sq Wt | É Ç d  S(   N(   t   HKEYSt   read_valuest   KeyError(   t   clst   patht   keyt   baset   d(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt	   get_valueD   s
    c         C   sÑ   y t  | | É } Wn t k
 r' d SXg  } d } xI t r y t | | É } Wn t k
 rd Pn X| j | É | d 7} q7 W| S(   s   Return list of registry keys.i    i   N(   t   RegOpenKeyExt   RegErrort   Nonet   Truet
   RegEnumKeyt   append(   R   R   R   t   handlet   Lt   it   k(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt	   read_keysL   s    	c   	      C   s®   y t  | | É } Wn t k
 r' d SXi  } d } xm t r£ y t | | É \ } } } Wn t k
 rm Pn X| j É  } |  j | É | |  j | É <| d 7} q7 W| S(   s`   Return dict of registry keys and values.

        All names are converted to lowercase.
        i    i   N(   R   R   R   R   t   RegEnumValuet   lowert   convert_mbcs(	   R   R   R   R   R   R   t   namet   valuet   type(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR   ^   s    	c         C   sI   t  |  d d  É } | d  k	 rE y | d É }  WqE t k
 rA qE Xn  |  S(   Nt   decodet   mbcs(   t   getattrR   t   UnicodeError(   t   st   dec(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR$   t   s    (	   t   __name__t
   __module__t   __doc__R   t   classmethodR!   R   R$   t   staticmethod(    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR   @   s   				t   MacroExpanderc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s'   i  |  _  t | |  _ |  j | É d  S(   N(   t   macrost   VS_BASEt   vsbaset   load_macros(   t   selft   version(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   __init__Ä   s    	c         C   s!   t  j | | É |  j d | <d  S(   Ns   $(%s)(   R   R   R4   (   R8   t   macroR   R   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt	   set_macroÖ   s    c         C   sR  |  j  d |  j d d É |  j  d |  j d d É |  j  d t d É y2 | d k rl |  j  d	 t d
 É n t d
 É Ç Wn t k
 rò t d É Ç n X| d k r— |  j  d |  j d É |  j  d t d É n} d } xt t D]l } y t | | É } Wn t k
 rqﬁ n Xt	 | d É } t
 j | d | | f É } | d |  j d <qﬁ Wd  S(   Nt   VCInstallDirs	   \Setup\VCt
   productdirt   VSInstallDirs	   \Setup\VSt   FrameworkDirt   installrootg       @t   FrameworkSDKDirs   sdkinstallrootv2.0s  Python was built with Visual Studio 2008;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2008 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.g      "@t   FrameworkVersions   clr versiont   WindowsSdkDirt   currentinstallfolders.   Software\Microsoft\NET Framework Setup\Producti    s   %s\%sR9   s   $(FrameworkVersion)(   R<   R6   t   NET_BASER   R   t   WINSDK_BASER   R   R   R   R   R   R4   (   R8   R9   t   pR   t   hR   R   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR7   à   s.    
c         C   s6   x/ |  j  j É  D] \ } } | j | | É } q W| S(   N(   R4   t   itemst   replace(   R8   R,   R    t   v(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   subß   s    (   R.   R/   R:   R<   R7   RM   (    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR3   ~   s   			c          C   sØ   d }  t  j j |  É } | d k r( d S| t |  É } t  j | j d d É \ } } t | d  É d } t | d d !É d	 } | d k ró d
 } n  | d k r´ | | Sd S(   s√   Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    s   MSC v.iˇˇˇˇi   t    i   i˛ˇˇˇi   i   g      $@i    N(   t   sysR9   t   findt   lent   splitt   intR   (   t   prefixR   R,   t   restt   majorVersiont   minorVersion(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   get_build_version¨   s    	c         C   sI   g  } x< |  D]4 } t  j j | É } | | k r | j | É q q W| S(   sn   Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    (   t   osR   t   normpathR   (   t   pathst   reduced_pathsRH   t   np(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   normalize_and_reduce_paths¬   s    c         C   s[   |  j  t j É } g  } x* | D]" } | | k r | j | É q q Wt j j | É } | S(   s8   Remove duplicate values of an environment variable.
    (   RR   RY   t   pathsepR   t   join(   t   variablet   oldListt   newListR   t   newVariable(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   removeDuplicates–   s    c         C   s≠  t  |  } y t j d | d É } Wn t k
 r= d } n X| d k rò t |  } y t j d | d É } Wqò t k
 rî d } t j d É qò Xn  | s≤ t j	 j
 | É rZd |  } t j j | d É } | rFt j	 j
 | É rFt j	 j | t j t j d É } t j	 j | É } t j	 j
 | É sWt j d | É d SqZt j d | É n  | sqt j d É d St j	 j | d	 É } t j	 j | É rú| St j d
 É d S(   s®   Find the vcvarsall.bat file

    At first it tries to find the productdir of VS 2008 in the registry. If
    that fails it falls back to the VS90COMNTOOLS env var.
    s   %s\Setup\VCR>   s%   Unable to find productdir in registrys   VS%0.f0COMNTOOLSt   VCs   %s is not a valid directorys    Env var %s is not set or invalids   No productdir founds   vcvarsall.bats   Unable to find vcvarsall.batN(   R5   R   R   R   R   t   VSEXPRESS_BASER   t   debugRY   R   t   isdirt   environt   getR`   t   pardirt   abspatht   isfile(   R9   R6   R>   t   toolskeyt   toolsdirt	   vcvarsall(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   find_vcvarsall€   s@    



!c         C   s   t  |  É } t d É } i  } | d k r9 t d É Ç n  t j d | |  É t j d | | f d t j d	 t j É} z¯ | j	 É  \ } } | j
 É  d
 k r∂ t | j d É É Ç n  | j d É } x¶ | j d É D]ï } t j | É } d | k r¸ q’ n  | j É  } | j d d É \ }	 }
 |	 j É  }	 |	 | k r’ |
 j t j É rW|
 d  }
 n  t |
 É | |	 <q’ q’ WWd | j j É  | j j É  Xt | É t | É k r∆t t t | j É  É É É Ç n  | S(   sD   Launch vcvarsall.bat and read the settings from its environment
    t   includet   libt   libpathR   s   Unable to find vcvarsall.bats'   Calling 'vcvarsall.bat %s' (version=%s)s   "%s" %s & sett   stdoutt   stderri    R)   s   
t   =i   iˇˇˇˇN(   Rs   s   libRu   s   path(   Rr   t   setR   R   R   Rh   t
   subprocesst   Popent   PIPEt   communicatet   waitR(   RR   R   R$   t   stripR#   t   endswithRY   R_   Re   Rv   t   closeRw   RQ   t
   ValueErrort   strt   listt   keys(   R9   t   archRq   t   interestingt   resultt   popenRv   Rw   t   lineR   R&   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   query_vcvarsall  s<    	!g       @s(   VC %0.1f is not supported by this modulet   MSVCCompilerc           B   sM  e  Z d  Z d Z i  Z d g Z d d d g Z d g Z d g Z e e e e Z	 d Z
 d	 Z d
 Z d Z d Z Z d Z d d d d Ñ Z d d Ñ Z d d d Ñ Z d d d d d d d d Ñ Z d d d d Ñ Z d d d d d d d d d d d Ñ
 Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   sw   Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class.t   msvcs   .cs   .ccs   .cpps   .cxxs   .rcs   .mcs   .ress   .objs   .libs   .dlls   %s%ss   .exei    c         C   sP   t  j |  | | | É t |  _ d |  _ g  |  _ d  |  _ d  |  _ t	 |  _
 d  S(   Ns   Software\Microsoft\VisualStudio(   R   R:   t   VERSIONt   _MSVCCompiler__versiont   _MSVCCompiler__roott   _MSVCCompiler__pathsR   t	   plat_namet   _MSVCCompiler__archt   Falset   initialized(   R8   t   verboset   dry_runt   force(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR:   S  s    					c         C   s.  |  j  s t d É Ç | d  k r. t É  } n  d& } | | k rV t d | f É Ç n  d t j k r≥ d t j k r≥ |  j d É r≥ d |  _ d	 |  _	 d
 |  _
 d |  _ d |  _ n+| t É  k sŒ | d k r€ t | } n t t É  d t | } t t | É } | d j d É j t j É |  _ | d j d É t j d <| d j d É t j d <t |  j É d k rÑt d |  j É Ç n  |  j d É |  _ |  j d	 É |  _	 |  j d
 É |  _
 |  j d É |  _ |  j d É |  _ y5 x. t j d j d É D] } |  j j | É q¯WWn t k
 r&n Xt |  j É |  _ d j |  j É t j d <d  |  _ |  j d k r†d d d d d g |  _ d d d d d d g |  _ n9 d d d d d d g |  _ d d d d d d d g |  _ d  d d! g |  _ |  j d" k rd  d d# d$ d% g |  _  n  d g |  _! t" |  _  d  S('   Ns   don't init multiple timesR	   s	   win-amd64s   win-ia64s   --plat-name must be one of %st   DISTUTILS_USE_SDKt   MSSdks   cl.exes   link.exes   lib.exes   rc.exes   mc.exet   _R   R)   Rt   Rs   i    sx   Python was built with %s, and extensions need to be built with the same version of the compiler, but it isn't installed.t   ;R
   s   /nologos   /Oxs   /MDs   /W3s   /DNDEBUGs   /Ods   /MDds   /Z7s   /D_DEBUGs   /GS-s   /DLLs   /INCREMENTAL:NOi   s   /INCREMENTAL:nos   /DEBUGs	   /pdb:None(   R	   s	   win-amd64s   win-ia64(#   Rï   t   AssertionErrorR   R   R   RY   Rj   t   find_exet   cct   linkerRt   t   rct   mct   PLAT_TO_VCVARSRã   Ré   t   encodeRR   R_   Rë   RQ   t   _MSVCCompiler__productR   R   R^   R`   t   preprocess_optionsRì   t   compile_optionst   compile_options_debugt   ldflags_sharedRè   t   ldflags_shared_debugt   ldflags_staticR   (   R8   Rí   t   ok_platst	   plat_spect   vc_envRH   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt
   initialize^  sf    -				"	t    c         C   s>  | d  k r d } n  g  } x| D]} t j j | É \ } } t j j | É d } | t j j | É } | |  j k ré t d | É Ç n  | r© t j j | É } n  | |  j	 k rﬁ | j
 t j j | | |  j É É q" | |  j k r| j
 t j j | | |  j É É q" | j
 t j j | | |  j É É q" W| S(   NR∞   i   s   Don't know how to compile %s(   R   RY   R   t   splitextt
   splitdrivet   isabst   src_extensionsR   t   basenamet   _rc_extensionsR   R`   t   res_extensiont   _mc_extensionst   obj_extension(   R8   t   source_filenamest	   strip_dirt
   output_dirt	   obj_namest   src_nameR   t   ext(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   object_filenamesµ  s(     	c	         C   sË  |  j  s |  j É  n  |  j | | | | | | É }	 |	 \ } }
 } } } | pR g  } | j d É | r{ | j |  j É n | j |  j É xV|
 D]N} y | | \ } } Wn t k
 r¬ qí n X| rﬁ t j	 j
 | É } n  | |  j k r˙ d | } nç| |  j k rd | } nq| |  j k rÜ| } d | } y) |  j |  j g | | g | g É Wqí t k
 r} t | É Ç qí Xqí n| |  j k rqt j	 j | É } t j	 j | É } yê |  j |  j g d | d | g | g É t j	 j t j	 j | É É \ } } t j	 j | | d É } |  j |  j g d | g | g É Wqí t k
 rj} t | É Ç qí Xqí n t d | | f É Ç d	 | } y- |  j |  j g | | | | g | É Wqí t k
 rﬂ} t | É Ç qí Xqí W|
 S(
   Ns   /cs   /Tcs   /Tps   /fos   -hs   -rs   .rcs"   Don't know how to compile %s to %ss   /Fo(   Rï   RØ   t   _setup_compileR   t   extendR®   Rß   R   RY   R   Rm   t   _c_extensionst   _cpp_extensionsR∂   t   spawnR°   R    R   R∏   t   dirnameR¢   R±   Rµ   R`   Rü   (   R8   t   sourcesRº   R4   t   include_dirsRh   t   extra_preargst   extra_postargst   dependst   compile_infot   objectst   pp_optst   buildt   compile_optst   objt   srcRø   t	   input_optt
   output_optt   msgt   h_dirt   rc_dirR   Rõ   t   rc_file(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   compile‘  sj    	
#$$#
c   	      C   s√   |  j  s |  j É  n  |  j | | É \ } } |  j | d | É} |  j | | É rØ | d | g } | ro n  y |  j |  j g | É Wqø t k
 r´ } t | É Ç qø Xn t	 j
 d | É d  S(   NRº   s   /OUT:s   skipping %s (up-to-date)(   Rï   RØ   t   _fix_object_argst   library_filenamet
   _need_linkR≈   Rt   R    R   R   Rh   (	   R8   RÕ   t   output_libnameRº   Rh   t   target_langt   output_filenamet   lib_argsR’   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   create_static_lib)  s    		c         C   s¯  |  j  s |  j É  n  |  j | | É \ } } |  j | | | É } | \ } } } | rr |  j d t | É É n  t |  | | | É } | d  k	 r´ t j	 j
 | | É } n  |  j | | É r‰| t j k rÚ |	 r‚ |  j d } q|  j d } n |	 r|  j } n	 |  j } g  } x% | pg  D] } | j d | É q W| | | | d | g } t j	 j | d É } | d  k	 r–t j	 j t j	 j | É É \ } } t j	 j
 | |  j | É É } | j d | É n  |  j | | | É |
 rˆ|
 | d *n  | r| j | É n  |  j t j	 j | É É y |  j |  j g | É Wn t k
 ra} t | É Ç n X|  j | | É } | d  k	 rÙ| \ } } d | | f } y  |  j d d	 d
 | | g É Wq·t k
 r›} t | É Ç q·XqÙn t j d | É d  S(   Ns5   I don't know what to do with 'runtime_library_dirs': i   s   /EXPORT:s   /OUT:i    s   /IMPLIB:s   -outputresource:%s;%ss   mt.exes   -nologos	   -manifests   skipping %s (up-to-date)(   Rï   RØ   R⁄   t   _fix_lib_argst   warnRÉ   R   R   RY   R   R`   R‹   R   t
   EXECUTABLER™   R©   R   R∆   R±   Rµ   R€   t   manifest_setup_ldargsR¬   t   mkpathR≈   R†   R    R   t   manifest_get_embed_infoR   Rh   (   R8   t   target_descRÕ   Rﬂ   Rº   t	   librariest   library_dirst   runtime_library_dirst   export_symbolsRh   R…   R    t
   build_tempRﬁ   t
   fixed_argst   lib_optst   ldflagst   export_optst   symt   ld_argst   dll_namet   dll_extt   implib_fileR’   t   mfinfot
   mffilenamet   mfidt   out_arg(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   linkB  sl    							c         C   s:   t  j j | t  j j | É d É } | j d | É d  S(   Ns	   .manifests   /MANIFESTFILE:(   RY   R   R`   Rµ   R   (   R8   Rﬂ   RÌ   RÛ   t   temp_manifest(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRÂ   °  s    	c         C   sÖ   x; | D]/ } | j  d É r | j d d É d } Pq q Wd  S| t j k rV d } n d } |  j | É } | d  k r{ d  S| | f S(   Ns   /MANIFESTFILE:t   :i   i   (   t
   startswithRR   R   R   R‰   t   _remove_visual_c_ref(   R8   RË   RÛ   t   argR¸   R˘   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRÁ   ≠  s    	c         C   sÓ   y÷ t  | É } z | j É  } Wd  | j É  Xt j d t j É } t j | d | É } d } t j | d | É } t j d t j É } t j | | É d  k r£ d  St  | d É } z | j	 | É | SWd  | j É  XWn t
 k
 rÈ n Xd  S(   NsU   <assemblyIdentity.*?name=("|')Microsoft\.VC\d{2}\.CRT("|').*?(/>|</assemblyIdentity>)R∞   s*   <dependentAssembly>\s*</dependentAssembly>sI   <assemblyIdentity.*?name=(?:"|')(.+?)(?:"|').*?(?:/>|</assemblyIdentity>)t   w(   t   opent   readRÅ   t   reRŸ   t   DOTALLRM   t   searchR   t   writet   IOError(   R8   t   manifest_filet
   manifest_ft   manifest_buft   pattern(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRˇ   ≈  s.    	c         C   s   d | S(   Ns	   /LIBPATH:(    (   R8   t   dir(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   library_dir_option  s    c         C   s   t  d É Ç d  S(   Ns<   don't know how to set runtime library search path for MSVC++(   R   (   R8   R  (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   runtime_library_dir_optionÛ  s    c         C   s   |  j  | É S(   N(   R€   (   R8   Rt   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   library_option˜  s    c         C   sÄ   | r | d | g } n	 | g } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É r6 | Sq6 Wq) Wd  Sd  S(   Nt   _d(   RY   R   R`   R€   t   existsR   (   R8   t   dirsRt   Rh   t	   try_namesR  R%   t   libfile(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   find_library_file˚  s    	c         C   sß   xH |  j  D]= } t j j t j j | É | É } t j j | É r
 | Sq
 WxU t j d j d É D]= } t j j t j j | É | É } t j j | É rb | Sqb W| S(   så  Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        t   PathRú   (   Rë   RY   R   R`   Rm   Rn   Rj   RR   (   R8   t   exeRH   t   fn(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRû     s    	!!N(    R.   R/   R0   t   compiler_typet   executablesR√   Rƒ   R∂   R∏   R¥   R∑   Rπ   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatt   exe_extensionR:   R   RØ   R¿   RŸ   R·   R˚   RÂ   RÁ   Rˇ   R  R  R  R  Rû   (    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRå   5  sR   			
YVR			+			I       (    (    (2   R0   t   __revision__RY   Rz   RO   R  t   distutils.errorsR    R   R   R   R   t   distutils.ccompilerR   R   t	   distutilsR   t   distutils.utilR   t   _winregt	   OpenKeyExR   t   EnumKeyR   t	   EnumValueR"   t   errorR   t
   HKEY_USERSt   HKEY_CURRENT_USERt   HKEY_LOCAL_MACHINEt   HKEY_CLASSES_ROOTR   t   platformt   maxsizet   NATIVE_WIN64R5   Rg   RG   RF   R£   R   R3   RX   R^   Re   Rr   Rã   Ré   Rå   (    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   <module>   sV   (					
>.				,)	                                             usr/lib/python2.7/distutils/msvccompiler.py                                                         0100644 0000000 0000000 00000056125 12734733743 017523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.msvccompiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio.
"""

# Written by Perry Stoll
# hacked by Robin Becker and Thomas Heller to do a better job of
#   finding DevStudio (through the registry)

__revision__ = "$Id$"

import sys
import os
import string

from distutils.errors import (DistutilsExecError, DistutilsPlatformError,
                              CompileError, LibError, LinkError)
from distutils.ccompiler import CCompiler, gen_lib_options
from distutils import log

_can_read_reg = 0
try:
    import _winreg

    _can_read_reg = 1
    hkey_mod = _winreg

    RegOpenKeyEx = _winreg.OpenKeyEx
    RegEnumKey = _winreg.EnumKey
    RegEnumValue = _winreg.EnumValue
    RegError = _winreg.error

except ImportError:
    try:
        import win32api
        import win32con
        _can_read_reg = 1
        hkey_mod = win32con

        RegOpenKeyEx = win32api.RegOpenKeyEx
        RegEnumKey = win32api.RegEnumKey
        RegEnumValue = win32api.RegEnumValue
        RegError = win32api.error

    except ImportError:
        log.info("Warning: Can't read registry to find the "
                 "necessary compiler setting\n"
                 "Make sure that Python modules _winreg, "
                 "win32api or win32con are installed.")
        pass

if _can_read_reg:
    HKEYS = (hkey_mod.HKEY_USERS,
             hkey_mod.HKEY_CURRENT_USER,
             hkey_mod.HKEY_LOCAL_MACHINE,
             hkey_mod.HKEY_CLASSES_ROOT)

def read_keys(base, key):
    """Return list of registry keys."""

    try:
        handle = RegOpenKeyEx(base, key)
    except RegError:
        return None
    L = []
    i = 0
    while 1:
        try:
            k = RegEnumKey(handle, i)
        except RegError:
            break
        L.append(k)
        i = i + 1
    return L

def read_values(base, key):
    """Return dict of registry keys and values.

    All names are converted to lowercase.
    """
    try:
        handle = RegOpenKeyEx(base, key)
    except RegError:
        return None
    d = {}
    i = 0
    while 1:
        try:
            name, value, type = RegEnumValue(handle, i)
        except RegError:
            break
        name = name.lower()
        d[convert_mbcs(name)] = convert_mbcs(value)
        i = i + 1
    return d

def convert_mbcs(s):
    enc = getattr(s, "encode", None)
    if enc is not None:
        try:
            s = enc("mbcs")
        except UnicodeError:
            pass
    return s

class MacroExpander:

    def __init__(self, version):
        self.macros = {}
        self.load_macros(version)

    def set_macro(self, macro, path, key):
        for base in HKEYS:
            d = read_values(base, path)
            if d:
                self.macros["$(%s)" % macro] = d[key]
                break

    def load_macros(self, version):
        vsbase = r"Software\Microsoft\VisualStudio\%0.1f" % version
        self.set_macro("VCInstallDir", vsbase + r"\Setup\VC", "productdir")
        self.set_macro("VSInstallDir", vsbase + r"\Setup\VS", "productdir")
        net = r"Software\Microsoft\.NETFramework"
        self.set_macro("FrameworkDir", net, "installroot")
        try:
            if version > 7.0:
                self.set_macro("FrameworkSDKDir", net, "sdkinstallrootv1.1")
            else:
                self.set_macro("FrameworkSDKDir", net, "sdkinstallroot")
        except KeyError:
            raise DistutilsPlatformError, \
                  ("""Python was built with Visual Studio 2003;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2003 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.""")

        p = r"Software\Microsoft\NET Framework Setup\Product"
        for base in HKEYS:
            try:
                h = RegOpenKeyEx(base, p)
            except RegError:
                continue
            key = RegEnumKey(h, 0)
            d = read_values(base, r"%s\%s" % (p, key))
            self.macros["$(FrameworkVersion)"] = d["version"]

    def sub(self, s):
        for k, v in self.macros.items():
            s = string.replace(s, k, v)
        return s

def get_build_version():
    """Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    """

    prefix = "MSC v."
    i = string.find(sys.version, prefix)
    if i == -1:
        return 6
    i = i + len(prefix)
    s, rest = sys.version[i:].split(" ", 1)
    majorVersion = int(s[:-2]) - 6
    minorVersion = int(s[2:3]) / 10.0
    # I don't think paths are affected by minor version in version 6
    if majorVersion == 6:
        minorVersion = 0
    if majorVersion >= 6:
        return majorVersion + minorVersion
    # else we don't know what version of the compiler this is
    return None

def get_build_architecture():
    """Return the processor architecture.

    Possible results are "Intel", "Itanium", or "AMD64".
    """

    prefix = " bit ("
    i = string.find(sys.version, prefix)
    if i == -1:
        return "Intel"
    j = string.find(sys.version, ")", i)
    return sys.version[i+len(prefix):j]

def normalize_and_reduce_paths(paths):
    """Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    """
    # Paths are normalized so things like:  /a and /a/ aren't both preserved.
    reduced_paths = []
    for p in paths:
        np = os.path.normpath(p)
        # XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.
        if np not in reduced_paths:
            reduced_paths.append(np)
    return reduced_paths


class MSVCCompiler (CCompiler) :
    """Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class."""

    compiler_type = 'msvc'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']
    _rc_extensions = ['.rc']
    _mc_extensions = ['.mc']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = (_c_extensions + _cpp_extensions +
                      _rc_extensions + _mc_extensions)
    res_extension = '.res'
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'

    def __init__ (self, verbose=0, dry_run=0, force=0):
        CCompiler.__init__ (self, verbose, dry_run, force)
        self.__version = get_build_version()
        self.__arch = get_build_architecture()
        if self.__arch == "Intel":
            # x86
            if self.__version >= 7:
                self.__root = r"Software\Microsoft\VisualStudio"
                self.__macros = MacroExpander(self.__version)
            else:
                self.__root = r"Software\Microsoft\Devstudio"
            self.__product = "Visual Studio version %s" % self.__version
        else:
            # Win64. Assume this was built with the platform SDK
            self.__product = "Microsoft SDK compiler %s" % (self.__version + 6)

        self.initialized = False

    def initialize(self):
        self.__paths = []
        if "DISTUTILS_USE_SDK" in os.environ and "MSSdk" in os.environ and self.find_exe("cl.exe"):
            # Assume that the SDK set up everything alright; don't try to be
            # smarter
            self.cc = "cl.exe"
            self.linker = "link.exe"
            self.lib = "lib.exe"
            self.rc = "rc.exe"
            self.mc = "mc.exe"
        else:
            self.__paths = self.get_msvc_paths("path")

            if len (self.__paths) == 0:
                raise DistutilsPlatformError, \
                      ("Python was built with %s, "
                       "and extensions need to be built with the same "
                       "version of the compiler, but it isn't installed." % self.__product)

            self.cc = self.find_exe("cl.exe")
            self.linker = self.find_exe("link.exe")
            self.lib = self.find_exe("lib.exe")
            self.rc = self.find_exe("rc.exe")   # resource compiler
            self.mc = self.find_exe("mc.exe")   # message compiler
            self.set_path_env_var('lib')
            self.set_path_env_var('include')

        # extend the MSVC path with the current path
        try:
            for p in string.split(os.environ['path'], ';'):
                self.__paths.append(p)
        except KeyError:
            pass
        self.__paths = normalize_and_reduce_paths(self.__paths)
        os.environ['path'] = string.join(self.__paths, ';')

        self.preprocess_options = None
        if self.__arch == "Intel":
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GX' ,
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GX',
                                          '/Z7', '/D_DEBUG']
        else:
            # Win64
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GS-' ,
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GS-',
                                          '/Z7', '/D_DEBUG']

        self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']
        if self.__version >= 7:
            self.ldflags_shared_debug = [
                '/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG'
                ]
        else:
            self.ldflags_shared_debug = [
                '/DLL', '/nologo', '/INCREMENTAL:no', '/pdb:None', '/DEBUG'
                ]
        self.ldflags_static = [ '/nologo']

        self.initialized = True

    # -- Worker methods ------------------------------------------------

    def object_filenames (self,
                          source_filenames,
                          strip_dir=0,
                          output_dir=''):
        # Copied from ccompiler.py, extended to return .res as 'object'-file
        # for .rc input file
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            (base, ext) = os.path.splitext (src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            if ext not in self.src_extensions:
                # Better to raise an exception instead of silently continuing
                # and later complain about sources and targets having
                # different lengths
                raise CompileError ("Don't know how to compile %s" % src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext in self._rc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            elif ext in self._mc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            else:
                obj_names.append (os.path.join (output_dir,
                                                base + self.obj_extension))
        return obj_names

    # object_filenames ()


    def compile(self, sources,
                output_dir=None, macros=None, include_dirs=None, debug=0,
                extra_preargs=None, extra_postargs=None, depends=None):

        if not self.initialized: self.initialize()
        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)

        compile_opts = extra_preargs or []
        compile_opts.append ('/c')
        if debug:
            compile_opts.extend(self.compile_options_debug)
        else:
            compile_opts.extend(self.compile_options)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            if debug:
                # pass the full pathname to MSVC in debug mode,
                # this allows the debugger to find the source file
                # without asking the user to browse for it
                src = os.path.abspath(src)

            if ext in self._c_extensions:
                input_opt = "/Tc" + src
            elif ext in self._cpp_extensions:
                input_opt = "/Tp" + src
            elif ext in self._rc_extensions:
                # compile .RC to .RES file
                input_opt = src
                output_opt = "/fo" + obj
                try:
                    self.spawn ([self.rc] + pp_opts +
                                [output_opt] + [input_opt])
                except DistutilsExecError, msg:
                    raise CompileError, msg
                continue
            elif ext in self._mc_extensions:

                # Compile .MC to .RC file to .RES file.
                #   * '-h dir' specifies the directory for the
                #     generated include file
                #   * '-r dir' specifies the target directory of the
                #     generated RC file and the binary message resource
                #     it includes
                #
                # For now (since there are no options to change this),
                # we use the source-directory for the include file and
                # the build directory for the RC file and message
                # resources. This works at least for win32all.

                h_dir = os.path.dirname (src)
                rc_dir = os.path.dirname (obj)
                try:
                    # first compile .MC to .RC and .H file
                    self.spawn ([self.mc] +
                                ['-h', h_dir, '-r', rc_dir] + [src])
                    base, _ = os.path.splitext (os.path.basename (src))
                    rc_file = os.path.join (rc_dir, base + '.rc')
                    # then compile .RC to .RES file
                    self.spawn ([self.rc] +
                                ["/fo" + obj] + [rc_file])

                except DistutilsExecError, msg:
                    raise CompileError, msg
                continue
            else:
                # how to handle this file?
                raise CompileError (
                    "Don't know how to compile %s to %s" % \
                    (src, obj))

            output_opt = "/Fo" + obj
            try:
                self.spawn ([self.cc] + compile_opts + pp_opts +
                            [input_opt, output_opt] +
                            extra_postargs)
            except DistutilsExecError, msg:
                raise CompileError, msg

        return objects

    # compile ()


    def create_static_lib (self,
                           objects,
                           output_libname,
                           output_dir=None,
                           debug=0,
                           target_lang=None):

        if not self.initialized: self.initialize()
        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        output_filename = \
            self.library_filename (output_libname, output_dir=output_dir)

        if self._need_link (objects, output_filename):
            lib_args = objects + ['/OUT:' + output_filename]
            if debug:
                pass                    # XXX what goes here?
            try:
                self.spawn ([self.lib] + lib_args)
            except DistutilsExecError, msg:
                raise LibError, msg

        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # create_static_lib ()

    def link (self,
              target_desc,
              objects,
              output_filename,
              output_dir=None,
              libraries=None,
              library_dirs=None,
              runtime_library_dirs=None,
              export_symbols=None,
              debug=0,
              extra_preargs=None,
              extra_postargs=None,
              build_temp=None,
              target_lang=None):

        if not self.initialized: self.initialize()
        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        (libraries, library_dirs, runtime_library_dirs) = \
            self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

        if runtime_library_dirs:
            self.warn ("I don't know what to do with 'runtime_library_dirs': "
                       + str (runtime_library_dirs))

        lib_opts = gen_lib_options (self,
                                    library_dirs, runtime_library_dirs,
                                    libraries)
        if output_dir is not None:
            output_filename = os.path.join (output_dir, output_filename)

        if self._need_link (objects, output_filename):

            if target_desc == CCompiler.EXECUTABLE:
                if debug:
                    ldflags = self.ldflags_shared_debug[1:]
                else:
                    ldflags = self.ldflags_shared[1:]
            else:
                if debug:
                    ldflags = self.ldflags_shared_debug
                else:
                    ldflags = self.ldflags_shared

            export_opts = []
            for sym in (export_symbols or []):
                export_opts.append("/EXPORT:" + sym)

            ld_args = (ldflags + lib_opts + export_opts +
                       objects + ['/OUT:' + output_filename])

            # The MSVC linker generates .lib and .exp files, which cannot be
            # suppressed by any linker switches. The .lib files may even be
            # needed! Make sure they are generated in the temporary build
            # directory. Since they have different names for debug and release
            # builds, they can go into the same directory.
            if export_symbols is not None:
                (dll_name, dll_ext) = os.path.splitext(
                    os.path.basename(output_filename))
                implib_file = os.path.join(
                    os.path.dirname(objects[0]),
                    self.library_filename(dll_name))
                ld_args.append ('/IMPLIB:' + implib_file)

            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)

            self.mkpath (os.path.dirname (output_filename))
            try:
                self.spawn ([self.linker] + ld_args)
            except DistutilsExecError, msg:
                raise LinkError, msg

        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # link ()


    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function, in
    # ccompiler.py.

    def library_dir_option (self, dir):
        return "/LIBPATH:" + dir

    def runtime_library_dir_option (self, dir):
        raise DistutilsPlatformError, \
              "don't know how to set runtime library search path for MSVC++"

    def library_option (self, lib):
        return self.library_filename (lib)


    def find_library_file (self, dirs, lib, debug=0):
        # Prefer a debugging library if found (and requested), but deal
        # with it if we don't have one.
        if debug:
            try_names = [lib + "_d", lib]
        else:
            try_names = [lib]
        for dir in dirs:
            for name in try_names:
                libfile = os.path.join(dir, self.library_filename (name))
                if os.path.exists(libfile):
                    return libfile
        else:
            # Oops, didn't find it in *any* of 'dirs'
            return None

    # find_library_file ()

    # Helper methods for using the MSVC registry settings

    def find_exe(self, exe):
        """Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        """

        for p in self.__paths:
            fn = os.path.join(os.path.abspath(p), exe)
            if os.path.isfile(fn):
                return fn

        # didn't find it; try existing path
        for p in string.split(os.environ['Path'],';'):
            fn = os.path.join(os.path.abspath(p),exe)
            if os.path.isfile(fn):
                return fn

        return exe

    def get_msvc_paths(self, path, platform='x86'):
        """Get a list of devstudio directories (include, lib or path).

        Return a list of strings.  The list will be empty if unable to
        access the registry or appropriate registry keys not found.
        """

        if not _can_read_reg:
            return []

        path = path + " dirs"
        if self.__version >= 7:
            key = (r"%s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directories"
                   % (self.__root, self.__version))
        else:
            key = (r"%s\6.0\Build System\Components\Platforms"
                   r"\Win32 (%s)\Directories" % (self.__root, platform))

        for base in HKEYS:
            d = read_values(base, key)
            if d:
                if self.__version >= 7:
                    return string.split(self.__macros.sub(d[path]), ";")
                else:
                    return string.split(d[path], ";")
        # MSVC 6 seems to create the registry entries we need only when
        # the GUI is run.
        if self.__version == 6:
            for base in HKEYS:
                if read_values(base, r"%s\6.0" % self.__root) is not None:
                    self.warn("It seems you have Visual Studio 6 installed, "
                        "but the expected registry settings are not present.\n"
                        "You must at least run the Visual Studio GUI once "
                        "so that these entries are created.")
                    break
        return []

    def set_path_env_var(self, name):
        """Set environment variable 'name' to an MSVC path type value.

        This is equivalent to a SET command prior to execution of spawned
        commands.
        """

        if name == "lib":
            p = self.get_msvc_paths("library")
        else:
            p = self.get_msvc_paths(name)
        if p:
            os.environ[name] = string.join(p, ';')


if get_build_version() >= 8.0:
    log.debug("Importing new compiler from distutils.msvc9compiler")
    OldMSVCCompiler = MSVCCompiler
    from distutils.msvc9compiler import MSVCCompiler
    # get_build_architecture not really relevant now we support cross-compile
    from distutils.msvc9compiler import MacroExpander
                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python2.7/distutils/msvccompiler.pyc                                                        0100644 0000000 0000000 00000042077 13077704274 017665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s  d  Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z m Z m	 Z	 m
 Z
 d d l m Z m Z d d l m Z d Z y@ d d l Z d Z e Z e j Z e j Z e j Z e j Z Wn~ e k
 rDyL d d l Z d d l Z d Z e Z e j Z e j Z e j Z e j Z Wn e k
 r@e j d	 É n Xn Xe rle j e j  e j! e j" f Z# n  d
 Ñ  Z$ d Ñ  Z% d Ñ  Z& d f  d Ñ  É  YZ' d Ñ  Z( d Ñ  Z) d Ñ  Z* d e f d Ñ  É  YZ+ e( É  d k re j, d É e+ Z- d d l. m+ Z+ d d l. m' Z' n  d S(   sÇ   distutils.msvccompiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio.
s   $Id$iˇˇˇˇN(   t   DistutilsExecErrort   DistutilsPlatformErrort   CompileErrort   LibErrort	   LinkError(   t	   CCompilert   gen_lib_options(   t   logi    i   sé   Warning: Can't read registry to find the necessary compiler setting
Make sure that Python modules _winreg, win32api or win32con are installed.c         C   s}   y t  |  | É } Wn t k
 r' d SXg  } d } xB y t | | É } Wn t k
 r^ Pn X| j | É | d } q7 | S(   s   Return list of registry keys.i    i   N(   t   RegOpenKeyExt   RegErrort   Nonet
   RegEnumKeyt   append(   t   baset   keyt   handlet   Lt   it   k(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt	   read_keys;   s    c         C   sõ   y t  |  | É } Wn t k
 r' d SXi  } d } x` y t | | É \ } } } Wn t k
 rg Pn X| j É  } t | É | t | É <| d } q7 | S(   sX   Return dict of registry keys and values.

    All names are converted to lowercase.
    i    i   N(   R   R	   R
   t   RegEnumValuet   lowert   convert_mbcs(   R   R   R   t   dR   t   namet   valuet   type(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   read_valuesM   s    c         C   sI   t  |  d d  É } | d  k	 rE y | d É }  WqE t k
 rA qE Xn  |  S(   Nt   encodet   mbcs(   t   getattrR
   t   UnicodeError(   t   st   enc(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR   b   s    t   MacroExpanderc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   i  |  _  |  j | É d  S(   N(   t   macrost   load_macros(   t   selft   version(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   __init__m   s    	c         C   sC   x< t  D]4 } t | | É } | r | | |  j d | <Pq q Wd  S(   Ns   $(%s)(   t   HKEYSR   R#   (   R%   t   macrot   pathR   R   R   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt	   set_macroq   s
    c   	      C   s%  d | } |  j  d | d d É |  j  d | d d É d } |  j  d | d	 É y9 | d
 k rv |  j  d | d É n |  j  d | d É Wn t k
 r¶ t d Ç n Xd } xq t D]i } y t | | É } Wn t k
 r„ q¥ n Xt | d É } t | d | | f É } | d |  j d <q¥ Wd  S(   Ns%   Software\Microsoft\VisualStudio\%0.1ft   VCInstallDirs	   \Setup\VCt
   productdirt   VSInstallDirs	   \Setup\VSs    Software\Microsoft\.NETFrameworkt   FrameworkDirt   installrootg      @t   FrameworkSDKDirs   sdkinstallrootv1.1t   sdkinstallroots  Python was built with Visual Studio 2003;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2003 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.s.   Software\Microsoft\NET Framework Setup\Producti    s   %s\%sR&   s   $(FrameworkVersion)(	   R+   t   KeyErrorR   R(   R   R	   R   R   R#   (	   R%   R&   t   vsbaset   nett   pR   t   hR   R   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR$   x   s*    

c         C   s9   x2 |  j  j É  D]! \ } } t j | | | É } q W| S(   N(   R#   t   itemst   stringt   replace(   R%   R    R   t   v(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   subî   s    (   t   __name__t
   __module__R'   R+   R$   R<   (    (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR"   k   s   			c          C   s≤   d }  t  j t j |  É } | d k r+ d S| t |  É } t j | j d d É \ } } t | d  É d } t | d d !É d	 } | d k rö d
 } n  | d k rÆ | | Sd S(   s√   Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    s   MSC v.iˇˇˇˇi   t    i   i˛ˇˇˇi   i   g      $@i    N(   R9   t   findt   sysR&   t   lent   splitt   intR
   (   t   prefixR   R    t   restt   majorVersiont   minorVersion(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   get_build_versionô   s    	c          C   s[   d }  t  j t j |  É } | d k r+ d St  j t j d | É } t j | t |  É | !S(   sa   Return the processor architecture.

    Possible results are "Intel", "Itanium", or "AMD64".
    s    bit (iˇˇˇˇt   Intelt   )(   R9   R@   RA   R&   RB   (   RE   R   t   j(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   get_build_architecture∞   s    c         C   sI   g  } x< |  D]4 } t  j j | É } | | k r | j | É q q W| S(   sn   Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    (   t   osR*   t   normpathR   (   t   pathst   reduced_pathsR6   t   np(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   normalize_and_reduce_pathsΩ   s    t   MSVCCompilerc           B   sD  e  Z d  Z d Z i  Z d g Z d d d g Z d g Z d g Z e e e e Z	 d Z
 d	 Z d
 Z d Z d Z Z d Z d d d d Ñ Z d Ñ  Z d d d Ñ Z d d d d d d d d Ñ Z d d d d Ñ Z d d d d d d d d d d d Ñ
 Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   sw   Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class.t   msvcs   .cs   .ccs   .cpps   .cxxs   .rcs   .mcs   .ress   .objs   .libs   .dlls   %s%ss   .exei    c         C   sß   t  j |  | | | É t É  |  _ t É  |  _ |  j d k rÜ |  j d k rj d |  _ t |  j É |  _ n	 d |  _ d |  j |  _	 n d |  j d |  _	 t
 |  _ d  S(   NRJ   i   s   Software\Microsoft\VisualStudios   Software\Microsoft\Devstudios   Visual Studio version %ss   Microsoft SDK compiler %si   (   R   R'   RI   t   _MSVCCompiler__versionRM   t   _MSVCCompiler__archt   _MSVCCompiler__rootR"   t   _MSVCCompiler__macrost   _MSVCCompiler__productt   Falset   initialized(   R%   t   verboset   dry_runt   force(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR'   Í   s    		c         C   sÖ  g  |  _  d t j k rf d t j k rf |  j d É rf d |  _ d |  _ d |  _ d |  _ d |  _ nÆ |  j	 d É |  _  t
 |  j  É d	 k r† t d
 |  j Ç n  |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  j d É y8 x1 t j t j d d É D] } |  j  j | É q1WWn t k
 r_n Xt |  j  É |  _  t j |  j  d É t j d <d  |  _ |  j d k r‚d d d d d d g |  _ d d d d d d d g |  _ n9 d d d d d d g |  _ d d d d d d d g |  _ d d d g |  _ |  j d k rTd d d d g |  _ n d d d d d g |  _ d g |  _ t |  _ d  S(    Nt   DISTUTILS_USE_SDKt   MSSdks   cl.exes   link.exes   lib.exes   rc.exes   mc.exeR*   i    sx   Python was built with %s, and extensions need to be built with the same version of the compiler, but it isn't installed.t   libt   includet   ;RJ   s   /nologos   /Oxs   /MDs   /W3s   /GXs   /DNDEBUGs   /Ods   /MDds   /Z7s   /D_DEBUGs   /GS-s   /DLLs   /INCREMENTAL:NOi   s   /INCREMENTAL:nos   /DEBUGs	   /pdb:None(   t   _MSVCCompiler__pathsRN   t   environt   find_exet   cct   linkerRb   t   rct   mct   get_msvc_pathsRB   R   RZ   t   set_path_env_varR9   RC   R   R3   RS   t   joinR
   t   preprocess_optionsRW   t   compile_optionst   compile_options_debugt   ldflags_sharedRV   t   ldflags_shared_debugt   ldflags_statict   TrueR\   (   R%   R6   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt
   initialize¸   sT    	-				 	t    c         C   s>  | d  k r d } n  g  } x| D]} t j j | É \ } } t j j | É d } | t j j | É } | |  j k ré t d | É Ç n  | r© t j j | É } n  | |  j	 k rﬁ | j
 t j j | | |  j É É q" | |  j k r| j
 t j j | | |  j É É q" | j
 t j j | | |  j É É q" W| S(   NRw   i   s   Don't know how to compile %s(   R
   RN   R*   t   splitextt
   splitdrivet   isabst   src_extensionsR   t   basenamet   _rc_extensionsR   Rn   t   res_extensiont   _mc_extensionst   obj_extension(   R%   t   source_filenamest	   strip_dirt
   output_dirt	   obj_namest   src_nameR   t   ext(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   object_filenames<  s(     	c	         C   sŸ  |  j  s |  j É  n  |  j | | | | | | É \ } }	 } }
 } | pL g  } | j d É | ru | j |  j É n | j |  j É xM|	 D]E} y | | \ } } Wn t k
 rº qå n X| rÿ t j	 j
 | É } n  | |  j k rÙ d | } ná| |  j k rd | } nk| |  j k r}| } d | } y) |  j |  j g |
 | g | g É Wqå t k
 rv} t | Ç qå Xqå n˛ | |  j k ret j	 j | É } t j	 j | É } yê |  j |  j g d | d | g | g É t j	 j t j	 j | É É \ } } t j	 j | | d É } |  j |  j g d | g | g É Wqå t k
 r^} t | Ç qå Xqå n t d | | f É Ç d	 | } y- |  j |  j g | |
 | | g | É Wqå t k
 r–} t | Ç qå Xqå W|	 S(
   Ns   /cs   /Tcs   /Tps   /fos   -hs   -rs   .rcs"   Don't know how to compile %s to %ss   /Fo(   R\   Rv   t   _setup_compileR   t   extendRq   Rp   R3   RN   R*   t   abspatht   _c_extensionst   _cpp_extensionsR}   t   spawnRj   R    R   R   t   dirnameRk   Rx   R|   Rn   Rh   (   R%   t   sourcesRÉ   R#   t   include_dirst   debugt   extra_preargst   extra_postargst   dependst   objectst   pp_optst   buildt   compile_optst   objt   srcRÜ   t	   input_optt
   output_optt   msgt   h_dirt   rc_dirR   t   _t   rc_file(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   compile]  sj    	 
#$$#
c   	      C   s¿   |  j  s |  j É  n  |  j | | É \ } } |  j | d | É} |  j | | É r¨ | d | g } | ro n  y |  j |  j g | É Wqº t k
 r® } t | Ç qº Xn t	 j
 d | É d  S(   NRÉ   s   /OUT:s   skipping %s (up-to-date)(   R\   Rv   t   _fix_object_argst   library_filenamet
   _need_linkRç   Rb   R    R   R   Rë   (	   R%   Rï   t   output_libnameRÉ   Rë   t   target_langt   output_filenamet   lib_argsRù   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   create_static_lib∂  s    	 c         C   sW  |  j  s |  j É  n  |  j | | É \ } } |  j | | | É \ } } } | rl |  j d t | É É n  t |  | | | É } | d  k	 r• t j	 j
 | | É } n  |  j | | É rC| t j k rÏ |	 r‹ |  j d } q|  j d } n |	 r˛ |  j } n	 |  j } g  } x% | pg  D] } | j d | É qW| | | | d | g } | d  k	 rƒt j	 j t j	 j | É É \ } } t j	 j
 t j	 j | d É |  j | É É } | j d | É n  |
 r◊|
 | d *n  | rÌ| j | É n  |  j t j	 j | É É y |  j |  j g | É WqSt k
 r?} t | Ç qSXn t j d | É d  S(   Ns5   I don't know what to do with 'runtime_library_dirs': i   s   /EXPORT:s   /OUT:i    s   /IMPLIB:s   skipping %s (up-to-date)(   R\   Rv   R£   t   _fix_lib_argst   warnt   strR   R
   RN   R*   Rn   R•   R   t
   EXECUTABLERs   Rr   R   Rx   R|   Ré   R§   Râ   t   mkpathRç   Ri   R    R   R   Rë   (   R%   t   target_descRï   R®   RÉ   t	   librariest   library_dirst   runtime_library_dirst   export_symbolsRë   Rí   Rì   t
   build_tempRß   t   lib_optst   ldflagst   export_optst   symt   ld_argst   dll_namet   dll_extt   implib_fileRù   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   link–  sR    	 					c         C   s   d | S(   Ns	   /LIBPATH:(    (   R%   t   dir(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   library_dir_option$  s    c         C   s   t  d Ç d  S(   Ns<   don't know how to set runtime library search path for MSVC++(   R   (   R%   Rø   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   runtime_library_dir_option'  s    c         C   s   |  j  | É S(   N(   R§   (   R%   Rb   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   library_option+  s    c         C   sÄ   | r | d | g } n	 | g } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É r6 | Sq6 Wq) Wd  Sd  S(   Nt   _d(   RN   R*   Rn   R§   t   existsR
   (   R%   t   dirsRb   Rë   t	   try_namesRø   R   t   libfile(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   find_library_file/  s    	c         C   s™   xH |  j  D]= } t j j t j j | É | É } t j j | É r
 | Sq
 WxX t j t j d d É D]= } t j j t j j | É | É } t j j | É re | Sqe W| S(   så  Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        t   PathRd   (	   Re   RN   R*   Rn   Rä   t   isfileR9   RC   Rf   (   R%   t   exeR6   t   fn(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRg   C  s    
! !t   x86c         C   s  t  s
 g  S| d } |  j d k r< d |  j |  j f } n d |  j | f } xi t D]a } t | | É } | rV |  j d k r† t j |  j j | | É d É St j | | d É SqV qV W|  j d k rx> t D]3 } t | d |  j É d	 k	 r— |  j
 d É Pq— q— Wn  g  S(
   s–   Get a list of devstudio directories (include, lib or path).

        Return a list of strings.  The list will be empty if unable to
        access the registry or appropriate registry keys not found.
        s    dirsi   s6   %s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directoriess?   %s\6.0\Build System\Components\Platforms\Win32 (%s)\DirectoriesRd   i   s   %s\6.0s¥   It seems you have Visual Studio 6 installed, but the expected registry settings are not present.
You must at least run the Visual Studio GUI once so that these entries are created.N(   t   _can_read_regRV   RX   R(   R   R9   RC   RY   R<   R
   R¨   (   R%   R*   t   platformR   R   R   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRl   Z  s(    
 c         C   sS   | d k r |  j  d É } n |  j  | É } | rO t j | d É t j | <n  d S(   s°   Set environment variable 'name' to an MSVC path type value.

        This is equivalent to a SET command prior to execution of spawned
        commands.
        Rb   t   libraryRd   N(   Rl   R9   Rn   RN   Rf   (   R%   R   R6   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRm     s
    N(   R=   R>   t   __doc__t   compiler_typet   executablesRã   Rå   R}   R   R{   R~   RÄ   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatt   exe_extensionR'   Rv   Rá   R
   R¢   R™   Ræ   R¿   R¡   R¬   R»   Rg   Rl   Rm   (    (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRT   Ã   sP   			
	BZG				%g       @s3   Importing new compiler from distutils.msvc9compiler(   RT   (   R"   (/   R—   t   __revision__RA   RN   R9   t   distutils.errorsR    R   R   R   R   t   distutils.ccompilerR   R   t	   distutilsR   RŒ   t   _winregt   hkey_modt	   OpenKeyExR   t   EnumKeyR   t	   EnumValueR   t   errorR	   t   ImportErrort   win32apit   win32cont   infot
   HKEY_USERSt   HKEY_CURRENT_USERt   HKEY_LOCAL_MACHINEt   HKEY_CLASSES_ROOTR(   R   R   R   R"   RI   RM   RS   RT   Rë   t   OldMSVCCompilert   distutils.msvc9compiler(    (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   <module>   s`   (										.			ˇ √                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python2.7/distutils/spawn.py                                                                0100644 0000000 0000000 00000020667 12734733743 016152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
"""

__revision__ = "$Id$"

import sys
import os

from distutils.errors import DistutilsPlatformError, DistutilsExecError
from distutils.debug import DEBUG
from distutils import log

def spawn(cmd, search_path=1, verbose=0, dry_run=0):
    """Run another program, specified as a command list 'cmd', in a new process.

    'cmd' is just the argument list for the new process, ie.
    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
    There is no way to run a program with a name different from that of its
    executable.

    If 'search_path' is true (the default), the system's executable
    search path will be used to find the program; otherwise, cmd[0]
    must be the exact path to the executable.  If 'dry_run' is true,
    the command will not actually be run.

    Raise DistutilsExecError if running the program fails in any way; just
    return on success.
    """
    # cmd is documented as a list, but just in case some code passes a tuple
    # in, protect our %-formatting code against horrible death
    cmd = list(cmd)
    if os.name == 'posix':
        _spawn_posix(cmd, search_path, dry_run=dry_run)
    elif os.name == 'nt':
        _spawn_nt(cmd, search_path, dry_run=dry_run)
    elif os.name == 'os2':
        _spawn_os2(cmd, search_path, dry_run=dry_run)
    else:
        raise DistutilsPlatformError, \
              "don't know how to spawn programs on platform '%s'" % os.name

def _nt_quote_args(args):
    """Quote command-line arguments for DOS/Windows conventions.

    Just wraps every argument which contains blanks in double quotes, and
    returns a new argument list.
    """
    # XXX this doesn't seem very robust to me -- but if the Windows guys
    # say it'll work, I guess I'll have to accept it.  (What if an arg
    # contains quotes?  What other magic characters, other than spaces,
    # have to be escaped?  Is there an escaping mechanism other than
    # quoting?)
    for i, arg in enumerate(args):
        if ' ' in arg:
            args[i] = '"%s"' % arg
    return args

def _spawn_nt(cmd, search_path=1, verbose=0, dry_run=0):
    executable = cmd[0]
    cmd = _nt_quote_args(cmd)
    if search_path:
        # either we find one or it stays the same
        executable = find_executable(executable) or executable
    log.info(' '.join([executable] + cmd[1:]))
    if not dry_run:
        # spawn for NT requires a full path to the .exe
        try:
            rc = os.spawnv(os.P_WAIT, executable, cmd)
        except OSError, exc:
            # this seems to happen when the command isn't found
            if not DEBUG:
                cmd = executable
            raise DistutilsExecError, \
                  "command %r failed: %s" % (cmd, exc[-1])
        if rc != 0:
            # and this reflects the command running but failing
            if not DEBUG:
                cmd = executable
            raise DistutilsExecError, \
                  "command %r failed with exit status %d" % (cmd, rc)

def _spawn_os2(cmd, search_path=1, verbose=0, dry_run=0):
    executable = cmd[0]
    if search_path:
        # either we find one or it stays the same
        executable = find_executable(executable) or executable
    log.info(' '.join([executable] + cmd[1:]))
    if not dry_run:
        # spawnv for OS/2 EMX requires a full path to the .exe
        try:
            rc = os.spawnv(os.P_WAIT, executable, cmd)
        except OSError, exc:
            # this seems to happen when the command isn't found
            if not DEBUG:
                cmd = executable
            raise DistutilsExecError, \
                  "command %r failed: %s" % (cmd, exc[-1])
        if rc != 0:
            # and this reflects the command running but failing
            if not DEBUG:
                cmd = executable
            log.debug("command %r failed with exit status %d" % (cmd, rc))
            raise DistutilsExecError, \
                  "command %r failed with exit status %d" % (cmd, rc)

if sys.platform == 'darwin':
    from distutils import sysconfig
    _cfg_target = None
    _cfg_target_split = None

def _spawn_posix(cmd, search_path=1, verbose=0, dry_run=0):
    log.info(' '.join(cmd))
    if dry_run:
        return
    executable = cmd[0]
    exec_fn = search_path and os.execvp or os.execv
    env = None
    if sys.platform == 'darwin':
        global _cfg_target, _cfg_target_split
        if _cfg_target is None:
            _cfg_target = sysconfig.get_config_var(
                                  'MACOSX_DEPLOYMENT_TARGET') or ''
            if _cfg_target:
                _cfg_target_split = [int(x) for x in _cfg_target.split('.')]
        if _cfg_target:
            # ensure that the deployment target of build process is not less
            # than that used when the interpreter was built. This ensures
            # extension modules are built with correct compatibility values
            cur_target = os.environ.get('MACOSX_DEPLOYMENT_TARGET', _cfg_target)
            if _cfg_target_split > [int(x) for x in cur_target.split('.')]:
                my_msg = ('$MACOSX_DEPLOYMENT_TARGET mismatch: '
                          'now "%s" but "%s" during configure'
                                % (cur_target, _cfg_target))
                raise DistutilsPlatformError(my_msg)
            env = dict(os.environ,
                       MACOSX_DEPLOYMENT_TARGET=cur_target)
            exec_fn = search_path and os.execvpe or os.execve
    pid = os.fork()

    if pid == 0:  # in the child
        try:
            if env is None:
                exec_fn(executable, cmd)
            else:
                exec_fn(executable, cmd, env)
        except OSError, e:
            if not DEBUG:
                cmd = executable
            sys.stderr.write("unable to execute %r: %s\n" %
                             (cmd, e.strerror))
            os._exit(1)

        if not DEBUG:
            cmd = executable
        sys.stderr.write("unable to execute %r for unknown reasons" % cmd)
        os._exit(1)
    else:   # in the parent
        # Loop until the child either exits or is terminated by a signal
        # (ie. keep waiting if it's merely stopped)
        while 1:
            try:
                pid, status = os.waitpid(pid, 0)
            except OSError, exc:
                import errno
                if exc.errno == errno.EINTR:
                    continue
                if not DEBUG:
                    cmd = executable
                raise DistutilsExecError, \
                      "command %r failed: %s" % (cmd, exc[-1])
            if os.WIFSIGNALED(status):
                if not DEBUG:
                    cmd = executable
                raise DistutilsExecError, \
                      "command %r terminated by signal %d" % \
                      (cmd, os.WTERMSIG(status))

            elif os.WIFEXITED(status):
                exit_status = os.WEXITSTATUS(status)
                if exit_status == 0:
                    return   # hey, it succeeded!
                else:
                    if not DEBUG:
                        cmd = executable
                    raise DistutilsExecError, \
                          "command %r failed with exit status %d" % \
                          (cmd, exit_status)

            elif os.WIFSTOPPED(status):
                continue

            else:
                if not DEBUG:
                    cmd = executable
                raise DistutilsExecError, \
                      "unknown error executing %r: termination status %d" % \
                      (cmd, status)

def find_executable(executable, path=None):
    """Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    """
    if path is None:
        path = os.environ['PATH']
    paths = path.split(os.pathsep)
    base, ext = os.path.splitext(executable)

    if (sys.platform == 'win32' or os.name == 'os2') and (ext != '.exe'):
        executable = executable + '.exe'

    if not os.path.isfile(executable):
        for p in paths:
            f = os.path.join(p, executable)
            if os.path.isfile(f):
                # the file exists, we have a shot at spawn working
                return f
        return None
    else:
        return executable
                                                                         usr/lib/python2.7/distutils/spawn.pyc                                                               0100644 0000000 0000000 00000014360 13077704274 016304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sÈ   d  Z  d Z d d l Z d d l Z d d l m Z m Z d d l m Z d d l	 m
 Z
 d d d d	 Ñ Z d
 Ñ  Z d d d d Ñ Z d d d d Ñ Z e j d k r« d d l	 m Z d a d a n  d d d d Ñ Z d d Ñ Z d S(   sÏ   distutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
s   $Id$iˇˇˇˇN(   t   DistutilsPlatformErrort   DistutilsExecError(   t   DEBUG(   t   logi   i    c         C   sè   t  |  É }  t j d k r1 t |  | d | ÉnZ t j d k rV t |  | d | Én5 t j d k r{ t |  | d | Én t d t j Ç d S(   sè  Run another program, specified as a command list 'cmd', in a new process.

    'cmd' is just the argument list for the new process, ie.
    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
    There is no way to run a program with a name different from that of its
    executable.

    If 'search_path' is true (the default), the system's executable
    search path will be used to find the program; otherwise, cmd[0]
    must be the exact path to the executable.  If 'dry_run' is true,
    the command will not actually be run.

    Raise DistutilsExecError if running the program fails in any way; just
    return on success.
    t   posixt   dry_runt   ntt   os2s1   don't know how to spawn programs on platform '%s'N(   t   listt   ost   namet   _spawn_posixt	   _spawn_ntt
   _spawn_os2R    (   t   cmdt   search_patht   verboseR   (    (    s%   /usr/lib/python2.7/distutils/spawn.pyt   spawn   s    c         C   s>   x7 t  |  É D]) \ } } d | k r d | |  | <q q W|  S(   s™   Quote command-line arguments for DOS/Windows conventions.

    Just wraps every argument which contains blanks in double quotes, and
    returns a new argument list.
    t    s   "%s"(   t	   enumerate(   t   argst   it   arg(    (    s%   /usr/lib/python2.7/distutils/spawn.pyt   _nt_quote_args/   s    c         C   sË   |  d } t  |  É }  | r1 t | É p+ | } n  t j d j | g |  d É É | s‰ y t j t j | |  É } Wn9 t k
 rØ } t	 sï | }  n  t
 d |  | d f Ç n X| d k r‰ t	 sÀ | }  n  t
 d |  | f Ç q‰ n  d  S(   Ni    R   i   s   command %r failed: %siˇˇˇˇs%   command %r failed with exit status %d(   R   t   find_executableR   t   infot   joinR	   t   spawnvt   P_WAITt   OSErrorR   R   (   R   R   R   R   t
   executablet   rct   exc(    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   ?   s$    
!		c         C   sÛ   |  d } | r% t  | É p | } n  t j d j | g |  d É É | sÔ y t j t j | |  É } Wn9 t k
 r£ } t sâ | }  n  t	 d |  | d f Ç n X| d k rÔ t sø | }  n  t j
 d |  | f É t	 d |  | f Ç qÔ n  d  S(   Ni    R   i   s   command %r failed: %siˇˇˇˇs%   command %r failed with exit status %d(   R   R   R   R   R	   R   R   R   R   R   t   debug(   R   R   R   R   R   R   R    (    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   W   s$    
!		t   darwin(   t	   sysconfigc         C   s^  t  j d j |  É É | r  d  S|  d } | r9 t j p? t j } d  } t j d k rGt	 d  k r¨ t
 j d É pu d a	 t	 r¨ g  t	 j d É D] } t | É ^ qé a q¨ n  t	 rGt j j d t	 É } t g  | j d É D] } t | É ^ q⁄ k rd | t	 f }	 t |	 É Ç n  t t j d | É} | r8t j p>t j } qGn  t j É  }
 |
 d k ry0 | d  k r~| | |  É n | | |  | É WnL t k
 r›} t s∞| }  n  t j j d |  | j f É t j d	 É n Xt sÌ| }  n  t j j d
 |  É t j d	 É nIxFy t j |
 d É \ }
 } Wn] t k
 rè} d d  l } | j | j k rfqn  t su| }  n  t d |  | d f Ç n Xt j  | É rÕt sÆ| }  n  t d |  t j! | É f Ç qt j" | É r t j# | É } | d k r˚d  St s
| }  n  t d |  | f Ç qt j$ | É r5qqt sD| }  n  t d |  | f Ç qd  S(   NR   i    R"   t   MACOSX_DEPLOYMENT_TARGETt    t   .sF   $MACOSX_DEPLOYMENT_TARGET mismatch: now "%s" but "%s" during configures   unable to execute %r: %s
i   s(   unable to execute %r for unknown reasonsiˇˇˇˇs   command %r failed: %ss"   command %r terminated by signal %ds%   command %r failed with exit status %ds1   unknown error executing %r: termination status %d(%   R   R   R   R	   t   execvpt   execvt   Nonet   syst   platformt   _cfg_targetR#   t   get_config_vart   splitt   intt   _cfg_target_splitt   environt   getR    t   dictt   execvpet   execvet   forkR   R   t   stderrt   writet   strerrort   _exitt   waitpidt   errnot   EINTRR   t   WIFSIGNALEDt   WTERMSIGt	   WIFEXITEDt   WEXITSTATUSt
   WIFSTOPPED(   R   R   R   R   R   t   exec_fnt   envt   xt
   cur_targett   my_msgt   pidt   et   statusR    R<   t   exit_status(    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   t   så    
..							c         C   s◊   | d k r t j d } n  | j t j É } t j j |  É \ } } t j d k sd t j	 d k r} | d k r} |  d }  n  t j j
 |  É sœ x9 | D]1 } t j j | |  É } t j j
 | É rñ | Sqñ Wd S|  Sd S(   s⁄   Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    t   PATHt   win32R   s   .exeN(   R)   R	   R1   R.   t   pathsept   patht   splitextR*   R+   R
   t   isfileR   (   R   RO   t   pathst   baset   extt   pt   f(    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   Ã   s    *(   t   __doc__t   __revision__R*   R	   t   distutils.errorsR    R   t   distutils.debugR   t	   distutilsR   R   R   R   R   R+   R#   R)   R,   R0   R   R   (    (    (    s%   /usr/lib/python2.7/distutils/spawn.pyt   <module>   s    		X                                                                                                                                                                                                                                                                                usr/lib/python2.7/distutils/sysconfig.py                                                            0100644 0000000 0000000 00000046220 12734733743 017017  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        <fdrake@acm.org>
"""

__revision__ = "$Id$"

import os
import re
import string
import sys

from distutils.errors import DistutilsPlatformError

# These are needed in a couple of spots, so just compute them once.
PREFIX = os.path.normpath(sys.prefix)
EXEC_PREFIX = os.path.normpath(sys.exec_prefix)

# Path to the base directory of the project. On Windows the binary may
# live in project/PCBuild9.  If we're dealing with an x64 Windows build,
# it'll live in project/PCbuild/amd64.
project_base = os.path.dirname(os.path.abspath(sys.executable))
if os.name == "nt" and "pcbuild" in project_base[-8:].lower():
    project_base = os.path.abspath(os.path.join(project_base, os.path.pardir))
# PC/VS7.1
if os.name == "nt" and "\\pc\\v" in project_base[-10:].lower():
    project_base = os.path.abspath(os.path.join(project_base, os.path.pardir,
                                                os.path.pardir))
# PC/AMD64
if os.name == "nt" and "\\pcbuild\\amd64" in project_base[-14:].lower():
    project_base = os.path.abspath(os.path.join(project_base, os.path.pardir,
                                                os.path.pardir))

# set for cross builds
if "_PYTHON_PROJECT_BASE" in os.environ:
    # this is the build directory, at least for posix
    project_base = os.path.normpath(os.environ["_PYTHON_PROJECT_BASE"])

# python_build: (Boolean) if true, we're either building Python or
# building an extension with an un-installed Python, so we use
# different (hard-wired) directories.
# Setup.local is available for Makefile builds including VPATH builds,
# Setup.dist is available on Windows
def _python_build():
    for fn in ("Setup.dist", "Setup.local"):
        if os.path.isfile(os.path.join(project_base, "Modules", fn)):
            return True
    return False
python_build = _python_build()


def get_python_version():
    """Return a string containing the major and minor Python version,
    leaving off the patchlevel.  Sample return values could be '1.5'
    or '2.2'.
    """
    return sys.version[:3]


def get_python_inc(plat_specific=0, prefix=None):
    """Return the directory containing installed Python header files.

    If 'plat_specific' is false (the default), this is the path to the
    non-platform-specific header files, i.e. Python.h and so on;
    otherwise, this is the path to platform-specific header files
    (namely pyconfig.h).

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    """

    if os.name == "posix":
        if python_build:
            buildir = os.path.dirname(sys.executable)
            if plat_specific:
                # python.h is located in the buildir
                inc_dir = buildir
            else:
                # the source dir is relative to the buildir
                srcdir = os.path.abspath(os.path.join(buildir,
                                         get_config_var('srcdir')))
                # Include is located in the srcdir
                inc_dir = os.path.join(srcdir, "Include")
            return inc_dir
        else:
            if not (prefix is None):
                return os.path.join(prefix, "include",
                                    "python" + get_python_version())+(sys.pydebug and "_d" or "")
            if plat_specific:
                return get_config_var('CONFINCLUDEPY')
            else:
                return get_config_var('INCLUDEPY')
    elif os.name == "nt":
        return os.path.join(prefix, "include")
    elif os.name == "os2":
        return os.path.join(prefix, "Include")
    else:
        raise DistutilsPlatformError(
            "I don't know where Python installs its C header files "
            "on platform '%s'" % os.name)


def get_python_lib(plat_specific=0, standard_lib=0, prefix=None):
    """Return the directory containing the Python library (standard or
    site additions).

    If 'plat_specific' is true, return the directory containing
    platform-specific modules, i.e. any module from a non-pure-Python
    module distribution; otherwise, return the platform-shared library
    directory.  If 'standard_lib' is true, return the directory
    containing standard Python library modules; otherwise, return the
    directory for site-specific modules.

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    """
    is_default_prefix = not prefix or os.path.normpath(prefix) in ('/usr', '/usr/local')
    if prefix is None:
        prefix = plat_specific and EXEC_PREFIX or PREFIX

    if os.name == "posix":
        libpython = os.path.join(prefix,
                                 "lib", "python" + get_python_version())
        if standard_lib:
            return libpython
        elif is_default_prefix and 'PYTHONUSERBASE' not in os.environ and 'real_prefix' not in sys.__dict__:
            return os.path.join(libpython, "dist-packages")
        else:
            return os.path.join(libpython, "site-packages")

    elif os.name == "nt":
        if standard_lib:
            return os.path.join(prefix, "Lib")
        else:
            if get_python_version() < "2.2":
                return prefix
            else:
                return os.path.join(prefix, "Lib", "site-packages")

    elif os.name == "os2":
        if standard_lib:
            return os.path.join(prefix, "Lib")
        else:
            return os.path.join(prefix, "Lib", "site-packages")

    else:
        raise DistutilsPlatformError(
            "I don't know where Python installs its library "
            "on platform '%s'" % os.name)



def customize_compiler(compiler):
    """Do any platform-specific customization of a CCompiler instance.

    Mainly needed on Unix, so we can plug in the information that
    varies across Unices and is stored in Python's Makefile.
    """
    if compiler.compiler_type == "unix":
        if sys.platform == "darwin":
            # Perform first-time customization of compiler-related
            # config vars on OS X now that we know we need a compiler.
            # This is primarily to support Pythons from binary
            # installers.  The kind and paths to build tools on
            # the user system may vary significantly from the system
            # that Python itself was built on.  Also the user OS
            # version and build tools may not support the same set
            # of CPU architectures for universal builds.
            global _config_vars
            # Use get_config_var() to ensure _config_vars is initialized.
            if not get_config_var('CUSTOMIZED_OSX_COMPILER'):
                import _osx_support
                _osx_support.customize_compiler(_config_vars)
                _config_vars['CUSTOMIZED_OSX_COMPILER'] = 'True'

        (cc, cxx, opt, cflags, extra_cflags, basecflags,
         ccshared, ldshared, so_ext, ar, ar_flags,
         configure_cppflags, configure_cflags, configure_ldflags) = \
            get_config_vars('CC', 'CXX', 'OPT', 'CFLAGS', 'EXTRA_CFLAGS', 'BASECFLAGS',
                            'CCSHARED', 'LDSHARED', 'SO', 'AR', 'ARFLAGS',
                            'CONFIGURE_CPPFLAGS', 'CONFIGURE_CFLAGS', 'CONFIGURE_LDFLAGS')

        if 'CC' in os.environ:
            newcc = os.environ['CC']
            if (sys.platform == 'darwin'
                    and 'LDSHARED' not in os.environ
                    and ldshared.startswith(cc)):
                # On OS X, if CC is overridden, use that as the default
                #       command for LDSHARED as well
                ldshared = newcc + ldshared[len(cc):]
            cc = newcc
        if 'CXX' in os.environ:
            cxx = os.environ['CXX']
        if 'LDSHARED' in os.environ:
            ldshared = os.environ['LDSHARED']
        if 'CPP' in os.environ:
            cpp = os.environ['CPP']
        else:
            cpp = cc + " -E"           # not always
        if 'LDFLAGS' in os.environ:
            ldshared = ldshared + ' ' + os.environ['LDFLAGS']
        elif configure_ldflags:
            ldshared = ldshared + ' ' + configure_ldflags
        if 'BASECFLAGS' in os.environ:
            basecflags = os.environ['BASECFLAGS']
        if 'OPT' in os.environ:
            opt = os.environ['OPT']
        cflags = ' '.join(str(x) for x in (basecflags, opt, extra_cflags) if x)
        if 'CFLAGS' in os.environ:
            cflags = ' '.join(str(x) for x in (opt, basecflags, os.environ['CFLAGS'], extra_cflags) if x)
            ldshared = ldshared + ' ' + os.environ['CFLAGS']
        elif configure_cflags:
            cflags = ' '.join(str(x) for x in (opt, basecflags, configure_cflags, extra_cflags) if x)
            ldshared = ldshared + ' ' + configure_cflags
        if 'CPPFLAGS' in os.environ:
            cpp = cpp + ' ' + os.environ['CPPFLAGS']
            cflags = cflags + ' ' + os.environ['CPPFLAGS']
            ldshared = ldshared + ' ' + os.environ['CPPFLAGS']
        elif configure_cppflags:
            cpp = cpp + ' ' + configure_cppflags
            cflags = cflags + ' ' + configure_cppflags
            ldshared = ldshared + ' ' + configure_cppflags
        if 'AR' in os.environ:
            ar = os.environ['AR']
        if 'ARFLAGS' in os.environ:
            archiver = ar + ' ' + os.environ['ARFLAGS']
        else:
            archiver = ar + ' ' + ar_flags

        cc_cmd = cc + ' ' + cflags
        compiler.set_executables(
            preprocessor=cpp,
            compiler=cc_cmd,
            compiler_so=cc_cmd + ' ' + ccshared,
            compiler_cxx=cxx,
            linker_so=ldshared,
            linker_exe=cc,
            archiver=archiver)

        compiler.shared_lib_extension = so_ext


def get_config_h_filename():
    """Return full pathname of installed pyconfig.h file."""
    if python_build:
        if os.name == "nt":
            inc_dir = os.path.join(project_base, "PC")
        else:
            inc_dir = project_base
    else:
        inc_dir = get_python_inc(plat_specific=1)
    if get_python_version() < '2.2':
        config_h = 'config.h'
    else:
        # The name of the config.h file changed in 2.2
        config_h = 'pyconfig.h'
    return os.path.join(inc_dir, config_h)


def get_makefile_filename():
    """Return full pathname of installed Makefile from the Python build."""
    if python_build:
        return os.path.join(project_base, "Makefile")
    lib_dir = get_python_lib(plat_specific=1, standard_lib=1)
    return os.path.join(get_config_var('LIBPL'), "Makefile")


def parse_config_h(fp, g=None):
    """Parse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    if g is None:
        g = {}
    define_rx = re.compile("#define ([A-Z][A-Za-z0-9_]+) (.*)\n")
    undef_rx = re.compile("/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/\n")
    #
    while 1:
        line = fp.readline()
        if not line:
            break
        m = define_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            try: v = int(v)
            except ValueError: pass
            g[n] = v
        else:
            m = undef_rx.match(line)
            if m:
                g[m.group(1)] = 0
    return g


# Regexes needed for parsing Makefile (and similar syntaxes,
# like old-style Setup files).
_variable_rx = re.compile("([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)")
_findvar1_rx = re.compile(r"\$\(([A-Za-z][A-Za-z0-9_]*)\)")
_findvar2_rx = re.compile(r"\${([A-Za-z][A-Za-z0-9_]*)}")

def parse_makefile(fn, g=None):
    """Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    from distutils.text_file import TextFile
    fp = TextFile(fn, strip_comments=1, skip_blanks=1, join_lines=1)

    if g is None:
        g = {}
    done = {}
    notdone = {}

    while 1:
        line = fp.readline()
        if line is None:  # eof
            break
        m = _variable_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            v = v.strip()
            # `$$' is a literal `$' in make
            tmpv = v.replace('$$', '')

            if "$" in tmpv:
                notdone[n] = v
            else:
                try:
                    v = int(v)
                except ValueError:
                    # insert literal `$'
                    done[n] = v.replace('$$', '$')
                else:
                    done[n] = v

    # do variable interpolation here
    variables = list(notdone.keys())

    # Variables with a 'PY_' prefix in the makefile. These need to
    # be made available without that prefix through sysconfig.
    # Special care is needed to ensure that variable expansion works, even
    # if the expansion uses the name without a prefix.
    renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS')

    while len(variables) > 0:
        for name in tuple(variables):
            value = notdone[name]
            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)
            if m is not None:
                n = m.group(1)
                found = True
                if n in done:
                    item = str(done[n])
                elif n in notdone:
                    # get it on a subsequent round
                    found = False
                elif n in os.environ:
                    # do it like make: fall back to environment
                    item = os.environ[n]

                elif n in renamed_variables:
                    if name.startswith('PY_') and name[3:] in renamed_variables:
                        item = ""

                    elif 'PY_' + n in notdone:
                        found = False

                    else:
                        item = str(done['PY_' + n])

                else:
                    done[n] = item = ""

                if found:
                    after = value[m.end():]
                    value = value[:m.start()] + item + after
                    if "$" in after:
                        notdone[name] = value
                    else:
                        try:
                            value = int(value)
                        except ValueError:
                            done[name] = value.strip()
                        else:
                            done[name] = value
                        variables.remove(name)

                        if name.startswith('PY_') \
                        and name[3:] in renamed_variables:

                            name = name[3:]
                            if name not in done:
                                done[name] = value


            else:
                # bogus variable reference (e.g. "prefix=$/opt/python");
                # just drop it since we can't deal
                done[name] = value
                variables.remove(name)

    # strip spurious spaces
    for k, v in done.items():
        if isinstance(v, str):
            done[k] = v.strip()

    # save the results in the global dictionary
    g.update(done)
    return g


def expand_makefile_vars(s, vars):
    """Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in
    'string' according to 'vars' (a dictionary mapping variable names to
    values).  Variables not present in 'vars' are silently expanded to the
    empty string.  The variable values in 'vars' should not contain further
    variable expansions; if 'vars' is the output of 'parse_makefile()',
    you're fine.  Returns a variable-expanded version of 's'.
    """

    # This algorithm does multiple expansion, so if vars['foo'] contains
    # "${bar}", it will expand ${foo} to ${bar}, and then expand
    # ${bar}... and so forth.  This is fine as long as 'vars' comes from
    # 'parse_makefile()', which takes care of such expansions eagerly,
    # according to make's variable expansion semantics.

    while 1:
        m = _findvar1_rx.search(s) or _findvar2_rx.search(s)
        if m:
            (beg, end) = m.span()
            s = s[0:beg] + vars.get(m.group(1)) + s[end:]
        else:
            break
    return s


_config_vars = None

def _init_posix():
    """Initialize the module as appropriate for POSIX systems."""
    # _sysconfigdata is generated at build time, see the sysconfig module
    from _sysconfigdata import build_time_vars
    global _config_vars
    _config_vars = {}
    _config_vars.update(build_time_vars)


def _init_nt():
    """Initialize the module as appropriate for NT"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    g['SO'] = '.pyd'
    g['EXE'] = ".exe"
    g['VERSION'] = get_python_version().replace(".", "")
    g['BINDIR'] = os.path.dirname(os.path.abspath(sys.executable))

    global _config_vars
    _config_vars = g


def _init_os2():
    """Initialize the module as appropriate for OS/2"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    g['SO'] = '.pyd'
    g['EXE'] = ".exe"

    global _config_vars
    _config_vars = g


def get_config_vars(*args):
    """With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.  Generally this includes
    everything needed to build extensions and install both pure modules and
    extensions.  On Unix, this means every variable defined in Python's
    installed Makefile; on Windows and Mac OS it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    """
    global _config_vars
    if _config_vars is None:
        func = globals().get("_init_" + os.name)
        if func:
            func()
        else:
            _config_vars = {}

        # Normalized versions of prefix and exec_prefix are handy to have;
        # in fact, these are the standard versions used most places in the
        # Distutils.
        _config_vars['prefix'] = PREFIX
        _config_vars['exec_prefix'] = EXEC_PREFIX

        # OS X platforms require special customization to handle
        # multi-architecture, multi-os-version installers
        if sys.platform == 'darwin':
            import _osx_support
            _osx_support.customize_config_vars(_config_vars)

    if args:
        vals = []
        for name in args:
            vals.append(_config_vars.get(name))
        return vals
    else:
        return _config_vars

def get_config_var(name):
    """Return the value of a single variable using the dictionary
    returned by 'get_config_vars()'.  Equivalent to
    get_config_vars().get(name)
    """
    return get_config_vars().get(name)
                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python2.7/distutils/sysconfig.pyc                                                           0100644 0000000 0000000 00000035070 13077704274 017161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sù  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l m Z e j j	 e j
 É Z e j j	 e j É Z e j j e j j e j É É Z e j d k rÊ d e d j É  k rÊ e j j e j j e e j j É É Z n  e j d k r>d e d	 j É  k r>e j j e j j e e j j e j j É É Z n  e j d k rñd
 e d j É  k rñe j j e j j e e j j e j j É É Z n  d e j k r¡e j j	 e j d É Z n  d Ñ  Z e É  Z d Ñ  Z d d d Ñ Z d d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z  e j! d É Z" e j! d É Z# e j! d É Z$ d d Ñ Z% d Ñ  Z& d a' d Ñ  Z( d Ñ  Z) d Ñ  Z* d Ñ  Z+ d Ñ  Z, d S(    sç  Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        <fdrake@acm.org>
s   $Id$iˇˇˇˇN(   t   DistutilsPlatformErrort   ntt   pcbuildi¯ˇˇˇs   \pc\viˆˇˇˇs   \pcbuild\amd64iÚˇˇˇt   _PYTHON_PROJECT_BASEc          C   s=   x6 d D]. }  t  j j t  j j t d |  É É r t Sq Wt S(   Ns
   Setup.dists   Setup.localt   Modules(   s
   Setup.dists   Setup.local(   t   ost   patht   isfilet   joint   project_baset   Truet   False(   t   fn(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   _python_build2   s    $c           C   s   t  j d  S(   sñ   Return a string containing the major and minor Python version,
    leaving off the patchlevel.  Sample return values could be '1.5'
    or '2.2'.
    i   (   t   syst   version(    (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   get_python_version:   s    i    c         C   s-  t  j d k r“ t ry t  j j t j É } |  r9 | } n< t  j j t  j j | t	 d É É É } t  j j | d É } | S| d k	 rµ t  j j | d d t É  É t j r∞ d p≥ d S|  r≈ t	 d É St	 d	 É SnW t  j d
 k rÙ t  j j | d É St  j d k rt  j j | d É St d t  j É Ç d S(   sö  Return the directory containing installed Python header files.

    If 'plat_specific' is false (the default), this is the path to the
    non-platform-specific header files, i.e. Python.h and so on;
    otherwise, this is the path to platform-specific header files
    (namely pyconfig.h).

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    t   posixt   srcdirt   Includet   includet   pythont   _dt    t   CONFINCLUDEPYt	   INCLUDEPYR   t   os2sF   I don't know where Python installs its C header files on platform '%s'N(   R   t   namet   python_buildR   t   dirnameR   t
   executablet   abspathR   t   get_config_vart   NoneR   t   pydebugR    (   t   plat_specifict   prefixt   buildirt   inc_dirR   (    (    s)   /usr/lib/p