et; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_bool.3                                   0100644 0001750 0001750 00000036664 12566167025 022575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_bytes.3                                  0100644 0001750 0001750 00000036664 12566167025 022770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_callhdr.3                                0100644 0001750 0001750 00000073141 12566167025 023242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_callmsg.3                                0100644 0001750 0001750 00000073141 12566167025 023253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_char.3                                   0100644 0001750 0001750 00000036664 12566167025 022557  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_destroy.3                                0100644 0001750 0001750 00000036664 12566167025 023333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_double.3                                 0100644 0001750 0001750 00000036664 12566167025 023114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_enum.3                                   0100644 0001750 0001750 00000036664 12566167025 022606  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_float.3                                  0100644 0001750 0001750 00000036664 12566167025 022747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_free.3                                   0100644 0001750 0001750 00000036664 12566167025 022563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_getpos.3                                 0100644 0001750 0001750 00000036664 12566167025 023143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_inline.3                                 0100644 0001750 0001750 00000036664 12566167025 023120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_int.3                                    0100644 0001750 0001750 00000036664 12566167025 022434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_long.3                                   0100644 0001750 0001750 00000036664 12566167025 022601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_opaque.3                                 0100644 0001750 0001750 00000036664 12566167025 023134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_opaque_auth.3                            0100644 0001750 0001750 00000073141 12566167025 024144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_pmap.3                                   0100644 0001750 0001750 00000073141 12566167025 022566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_pmaplist.3                               0100644 0001750 0001750 00000073141 12566167025 023462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_pointer.3                                0100644 0001750 0001750 00000036664 12566167025 023322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_reference.3                              0100644 0001750 0001750 00000036664 12566167025 023600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_rejected_reply.3                         0100644 0001750 0001750 00000073141 12566167025 024631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_replymsg.3                               0100644 0001750 0001750 00000073141 12566167025 023473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_setpos.3                                 0100644 0001750 0001750 00000036664 12566167025 023157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_short.3                                  0100644 0001750 0001750 00000036664 12566167025 023001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_string.3                                 0100644 0001750 0001750 00000036664 12566167025 023150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_u_char.3                                 0100644 0001750 0001750 00000036664 12566167025 023103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_u_long.3                                 0100644 0001750 0001750 00000036664 12566167025 023125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_u_short.3                                0100644 0001750 0001750 00000036664 12566167025 023325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_union.3                                  0100644 0001750 0001750 00000036664 12566167025 022772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_vector.3                                 0100644 0001750 0001750 00000036664 12566167025 023144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_void.3                                   0100644 0001750 0001750 00000036664 12566167025 022603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdr_wrapstring.3                             0100644 0001750 0001750 00000036664 12566167025 024042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdrmem_create.3                              0100644 0001750 0001750 00000036664 12566167025 023604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdrrec_create.3                              0100644 0001750 0001750 00000036664 12566167025 023577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdrrec_endofrecord.3                         0100644 0001750 0001750 00000036664 12566167025 024626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdrrec_eof.3                                 0100644 0001750 0001750 00000036664 12566167025 023105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdrrec_skiprecord.3                          0100644 0001750 0001750 00000036664 12566167025 024501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xdrstdio_create.3                            0100644 0001750 0001750 00000036664 12566167025 024150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\" $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
.\"
.Dd February 16, 1988
.Dt XDR 3
.Os
.Sh NAME
.Nm xdr ,
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_hyper ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_longlong_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_hyper ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_longlong_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd "library routines for external data representation"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In rpc/types.h
.In rpc/xdr.h
.Pp
See
.Sx DESCRIPTION
for function declarations.
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_array
.Fa "XDR *xdrs"
.Fa "char **arrp"
.Fa "u_int *sizep"
.Fa "u_int maxsize"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between variable-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Xc
.Pp
A filter primitive that translates between booleans (C
integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between counted byte
strings and their external representations.
The
.Fa sp
argument
is the address of the string pointer.
The length of the
string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_char "XDR *xdrs" "char *cp"
.Xc
.Pp
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each.
For arrays of characters, it is worthwhile to
consider
.Fn xdr_bytes ,
.Fn xdr_opaque
or
.Fn xdr_string .
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_destroy "XDR *xdrs"
.Xc
.Pp
A macro that invokes the destroy routine associated with the
.Tn XDR
stream,
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_double "XDR *xdrs" "double *dp"
.Xc
.Pp
A filter primitive that translates between C
.Vt double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Xc
.Pp
A filter primitive that translates between C
.Vt enum Ns s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_float "XDR *xdrs" "float *fp"
.Xc
.Pp
A filter primitive that translates between C
.Vt float Ns s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdr_free "xdrproc_t proc" "void *objp"
.Xc
.Pp
Generic freeing routine.
The first argument is the
.Tn XDR
routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed
to this routine is
.Em not
freed, but what it points to
.Em is
freed (recursively).
.Pp
.It Xo
.Ft u_int
.Xc
.It Xo
.Fn xdr_getpos "XDR *xdrs"
.Xc
.Pp
A macro that invokes the get\-position routine
associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
streams is that simple arithmetic works with this number,
although the
.Tn XDR
stream instances need not guarantee this.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_hyper "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft "long *"
.Xc
.It Xo
.Fn xdr_inline "XDR *xdrs" "int len"
.Xc
.Pp
A macro that invokes the in-line routine associated with the
.Tn XDR
stream,
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Vt "long *" .
.Pp
Warning:
.Fn xdr_inline
may return
.Dv NULL
(0)
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_int "XDR *xdrs" "int *ip"
.Xc
.Pp
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_long "XDR *xdrs" "long *lp"
.Xc
.Pp
A filter primitive that translates between C
.Vt long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_longlong_t "XDR *xdrs" "quad_t *llp"
.Xc
A filter primitive that translates between ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Xc
.Pp
A filter primitive that translates between fixed size opaque
data
and its external representation.
The
.Fa cp
argument
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Xc
.Pp
Like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.It Xo
.Ft void
.Xc
.It Xo
.Fo xdrrec_create
.Fa "XDR *xdrs"
.Fa "u_int sendsize"
.Fa "u_int recvsize"
.Fa "void *handle"
.Fa "int \*(lp*readit\*(rp\*(lp\*(rp"
.Fa "int \*(lp*writeit\*(rp\*(lp\*(rp"
.Fc
.Xc
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn writeit
is called.
Similarly, when a stream's input buffer is empty,
.Fn readit
is called.
The behavior of these two routines is similar to
the
system calls
.Xr read 2
and
.Xr write 2 ,
except that
.Fa handle
is passed to the former routines as the first argument.
Note: the
.Tn XDR
stream's
.Fa op
field must be set by the caller.
.Pp
Warning: this
.Tn XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero
otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_eof "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdrrec_skiprecord "XDR *xdrs"
.Xc
.Pp
This routine can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the
.Tn XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Xc
.Pp
A primitive that provides pointer chasing within structures.
The
.Fa pp
argument
is the address of the pointer;
.Fa size
is the
.Ic sizeof
the structure that
.Fa *pp
points to; and
.Fa proc
is an
.Tn XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Xc
.Pp
A macro that invokes the set position routine associated with
the
.Tn XDR
stream
.Fa xdrs .
The
.Fa pos
argument
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the
.Tn XDR
stream could be repositioned,
and zero otherwise.
.Pp
Warning: it is difficult to reposition some types of
.Tn XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_short "XDR *xdrs" "short *sp"
.Xc
.Pp
A filter primitive that translates between C
.Vt short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Li "#ifdef _STDIO_H_"
.It Li "/* XDR using stdio library */"
.It Xo
.Ft void
.Xc
.It Xo
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Xc
.It Li "#endif"
.Pp
This routine initializes the
.Tn XDR
stream object pointed to by
.Fa xdrs .
The
.Tn XDR
stream data is written to, or read from, the Standard
.Tn I/O
stream
.Fa file .
The
.Fa op
argument
determines the direction of the
.Tn XDR
stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
Warning: the destroy routine associated with such
.Tn XDR
streams calls
.Xr fflush 3
on the
.Fa file
stream, but never
.Xr fclose 3 .
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Xc
.Pp
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Xc
.Pp
A filter primitive that translates between
.Vt unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_hyper "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt long long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_int "XDR *xdrs" "unsigned *up"
.Xc
.Pp
A filter primitive that translates between C
.Vt unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_longlong_t "XDR *xdrs" "u_quad_t *ullp"
.Xc
A filter primitive that translates between
.Vt unsigned
ANSI C
.Vt "long long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Xc
.Pp
A filter primitive that translates between C
.Vt "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_union
.Fa "XDR *xdrs"
.Fa "enum_t *dscmp"
.Fa "char *unp"
.Fa "const struct xdr_discrim *choices"
.Fa "xdrproc_t defaultarm"
.Fc
.Xc
.Pp
A filter primitive that translates between a discriminated C
.Vt union
and its corresponding external representation.
It first
translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Vt enum_t .
Next the union located at
.Fa unp
is translated.
The
.Fa choices
argument
is a pointer to an array of
.Vt xdr_discrim
structures.
Each structure contains an ordered pair of
.Bq Va value , proc .
If the union's discriminant is equal to the associated
.Va value ,
then the
.Fn proc
is called to translate the union.
The end of the
.Vt xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn defaultarm
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fo xdr_vector
.Fa "XDR *xdrs"
.Fa "char *arrp"
.Fa "u_int size"
.Fa "u_int elsize"
.Fa "xdrproc_t elproc"
.Fc
.Xc
.Pp
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.
The
.Fa arrp
argument
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The
.Fa elsize
argument
is the
.Ic sizeof
each of the array's elements, and
.Fa elproc
is an
.Tn XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_void void
.Xc
.Pp
This routine always returns one.
It may be passed to
.Tn RPC
routines that require a function argument,
where nothing is to be done.
.Pp
.It Xo
.Ft int
.Xc
.It Xo
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Xc
.Pp
A primitive that calls
.Fn xdr_string xdrs sp MAXUN.UNSIGNED ;
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
The
.Fn xdr_wrapstring
function
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
routines as arguments, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.El
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T "eXternal Data Representation Standard: Protocol Specification"
.Re
.Rs
.%T "eXternal Data Representation: Sun Technical Notes"
.Re
.Rs
.%T "XDR: External Data Representation Standard"
.%O RFC1014
.%Q "Sun Microsystems, Inc., USC\-ISI"
.Re
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xlocale.3                                    0100644 0001750 0001750 00000012421 12566166147 022401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd March 11, 2005
.Dt XLOCALE 3
.Os
.Sh NAME
.Nm xlocale
.Nd Extended locale support.
.Sh LIBRARY
.Lb libc
.Sh DESCRIPTION
Include
.Aq xlocale.h
for extended locale support.
It can be used alone or with the POSIX locale API in
.Aq locale.h .
.Pp
The extended locale, or "xlocale" API consists of five basic routines,
which are documented separately:
.Xr duplocale 3 ,
.Xr freelocale 3 ,
.Xr newlocale 3 ,
.Xr querylocale 3 ,
and
.Xr uselocale 3 .
For each of these routines, if a NULL
.Vt locale_t
is given, the current locale is used.
.Pp
In addition,
.Aq xlocale.h
defines a few macros:
.Pp
.Bl -dash
.It
LC_GLOBAL_LOCALE - A special
.Vt locale_t
value that corresponds to the global, process-wide locale.
.It
MB_CUR_MAX - This macro is traditionally defined as an integer
containing the value of the longest multi-byte string
that a single-wide character in the global locale can translate into.
With extended locales, this macro is replaced with a function
that returns the value of the longest multi-byte string
that a single-wide character in the current locale (per-thread or global)
can translate into.
.It
MB_CUR_MAX_L(loc) - This macro is equivalent to MB_CUR_MAX,
except that it may be passed a specific locale directly.
.El
.Sh CAVEATS
The POSIX
.Xr setlocale 3
function only affects the global locale,
so using it when a per-thread locale is in effect
will not change locale behavior for that thread.
However, it will change behavior for threads
with no per-thread locale in effect.
.Pp
The routines defined in
.Aq rune.h
are deprecated, and may not be fully consistent with the xlocale API.
Of particular note is
.Fn setinvalidrune ,
which would normally modify the value in the global locale.
Since this value resides in a sub-structure of
.Vt locale_t
and sub-structures may be shared by multiple locales,
.Fn setinvalidrune
has been modified to make a copy of the sub-structure.
This prevents it from affecting other locales.
.Sh SEE ALSO
.Xr duplocale 3 ,
.Xr freelocale 3 ,
.Xr localeconv 3 ,
.Xr newlocale 3 ,
.Xr querylocale 3 ,
.Xr uselocale 3
.Sh CONVENIENCE FUNCTIONS
The xlocale API also includes "convenience functions":
functions that can be executed using a given locale,
rather than the current locale.
These functions all take one extra
.Vt locale_t
argument at the end of the traditional argument list,
except in the case of variable-argument functions,
in which case the extra argument comes before the format string.
If a NULL
.Vt locale_t
is passed, the C locale will be used.
.Pp
For completeness,
the convenience functions are listed here
(organized by the header file that contains the original function).
.Pp
.Bl -tag -width monetary.h
.It Aq _wctype.h
.Xr iswalnum_l 3 ,
.Xr iswalpha_l 3 ,
.Xr iswcntrl_l 3 ,
.Xr iswctype_l 3 ,
.Xr iswdigit_l 3 ,
.Xr iswgraph_l 3 ,
.Xr iswlower_l 3 ,
.Xr iswprint_l 3 ,
.Xr iswpunct_l 3 ,
.Xr iswspace_l 3 ,
.Xr iswupper_l 3 ,
.Xr iswxdigit_l 3 ,
.Xr towlower_l 3 ,
.Xr towupper_l 3 ,
.Xr wctype_l 3
.It Aq ctype.h
.Xr digittoint_l 3 ,
.Xr isalnum_l 3 ,
.Xr isalpha_l 3 ,
.Xr isblank_l 3 ,
.Xr iscntrl_l 3 ,
.Xr isdigit_l 3 ,
.Xr isgraph_l 3 ,
.Xr ishexnumber_l 3 ,
.Xr isideogram_l 3 ,
.Xr islower_l 3 ,
.Xr isnumber_l 3 ,
.Xr isphonogram_l 3 ,
.Xr isprint_l 3 ,
.Xr ispunct_l 3 ,
.Xr isrune_l 3 ,
.Xr isspace_l 3 ,
.Xr isspecial_l 3 ,
.Xr isupper_l 3 ,
.Xr isxdigit_l 3 ,
.Xr tolower_l 3 ,
.Xr toupper_l 3
.It Aq inttypes.h
.Xr strtoimax_l 3 ,
.Xr strtoumax_l 3 ,
.Xr wcstoimax_l 3 ,
.Xr wcstoumax_l 3
.It Aq langinfo.h
.Xr nl_langinfo_l 3
.It Aq monetary.h
.Xr strfmon_l 3
.It Aq stdio.h
.Xr asprintf_l 3 ,
.Xr fprintf_l 3 ,
.Xr fscanf_l 3 ,
.Xr printf_l 3 ,
.Xr scanf_l 3 ,
.Xr snprintf_l 3 ,
.Xr sprintf_l 3 ,
.Xr sscanf_l 3 ,
.Xr vasprintf_l 3 ,
.Xr vfprintf_l 3 ,
.Xr vfscanf_l 3 ,
.Xr vprintf_l 3 ,
.Xr vscanf_l 3 ,
.Xr vsnprintf_l 3 ,
.Xr vsprintf_l 3 ,
.Xr vsscanf_l 3
.It Aq stdlib.h
.Xr atof_l 3 ,
.Xr atoi_l 3 ,
.Xr atol_l 3 ,
.Xr atoll_l 3 ,
.Xr mblen_l 3 ,
.Xr mbstowcs_l 3 ,
.Xr mbtowc_l 3 ,
.Xr strtod_l 3 ,
.Xr strtof_l 3 ,
.Xr strtol_l 3 ,
.Xr strtold_l 3 ,
.Xr strtoll_l 3 ,
.Xr strtoq_l 3 ,
.Xr strtoul_l 3 ,
.Xr strtoull_l 3 ,
.Xr strtouq_l 3 ,
.Xr wcstombs_l 3 ,
.Xr wctomb_l 3
.It Aq string.h
.Xr strcoll_l 3 ,
.Xr strxfrm_l 3 ,
.Xr strcasecmp_l 3 ,
.Xr strcasestr_l 3 ,
.Xr strncasecmp_l 3
.It Aq time.h
.Xr strftime_l 3 ,
.Xr strptime_l 3
.It Aq wchar.h
.Xr btowc_l 3 ,
.Xr fgetwc_l 3 ,
.Xr *fgetws_l 3 ,
.Xr fputwc_l 3 ,
.Xr fputws_l 3 ,
.Xr fwprintf_l 3 ,
.Xr fwscanf_l 3 ,
.Xr getwc_l 3 ,
.Xr getwchar_l 3 ,
.Xr mbrlen_l 3 ,
.Xr mbrtowc_l 3 ,
.Xr mbsinit_l 3 ,
.Xr mbsnrtowcs_l 3 ,
.Xr mbsrtowcs_l 3 ,
.Xr putwc_l 3 ,
.Xr putwchar_l 3 ,
.Xr swprintf_l 3 ,
.Xr swscanf_l 3 ,
.Xr ungetwc_l 3 ,
.Xr vfwprintf_l 3 ,
.Xr vfwscanf_l 3 ,
.Xr vswprintf_l 3 ,
.Xr vswscanf_l 3 ,
.Xr vwprintf_l 3 ,
.Xr vwscanf_l 3 ,
.Xr wcrtomb_l 3 ,
.Xr wcscoll_l 3 ,
.Xr wcsftime_l 3 ,
.Xr wcsnrtombs_l 3 ,
.Xr wcsrtombs_l 3 ,
.Xr wcstod_l 3 ,
.Xr wcstof_l 3 ,
.Xr wcstol_l 3 ,
.Xr wcstold_l 3 ,
.Xr wcstoll_l 3 ,
.Xr wcstoul_l 3 ,
.Xr wcstoull_l 3 ,
.Xr wcswidth_l 3 ,
.Xr wcsxfrm_l 3 ,
.Xr wctob_l 3 ,
.Xr wcwidth_l 3 ,
.Xr wprintf_l 3 ,
.Xr wscanf_l 3
.It Aq wctype.h
.Xr iswblank_l 3 ,
.Xr iswhexnumber_l 3 ,
.Xr iswideogram_l 3 ,
.Xr iswnumber_l 3 ,
.Xr iswphonogram_l 3 ,
.Xr iswrune_l 3 ,
.Xr iswspecial_l 3 ,
.Xr nextwctype_l 3 ,
.Xr towctrans_l 3 ,
.Xr wctrans_l 3
.It Aq xlocale.h
.Xr localeconv_l 3
.El
                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc.3                                        0100644 0001750 0001750 00000003550 12566166531 021544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc 3
.Os Darwin
.Sh NAME
.Nm xpc
.Nd a structured, asynchronous interprocess communication library
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Sh DESCRIPTION
The XPC framework facilitates interprocess communication using structured
messages. Messages are structured using property list style objects such as
dictionaries, arrays, strings, integers and UUIDs. Out-of-line types such as
file descriptors and shared memory regions are also supported. The root object
of each message is a dictionary.
.Pp
Messages are sent via connections created using
.Xr xpc_connection_create 3
and
.Xr xpc_connection_create_mach_service 3 .
.Pp
XPC significantly leverages the on-demand process management features of
.Xr launchd 8
to provide transparent process life-cycle management.
As such, clients of the XPC framework have little to no responsibility for
managing their corresponding service processes.
.Pp
Consequently, there is no facility in XPC to directly query the execution status
of a service. XPC services are simply made available when they are needed, so
clients needn't be concerned with remote process state.
.Pp
Dynamic service registrations (ala
.Fn bootstrap_register ,
.Fn bootstrap_create_service
and
.Fn bootstrap_create_server )
are also purposefully disallowed.
.Pp
XPC's integration with
.Xr launchd 8
also extends to being able to launch jobs on-demand with higher-level events
than have been historically available. Using XPC and launchd together, jobs can
be launched based on events in IOKit or the posting of BSD Notifications.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_main 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_connection_create_mach_service 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_events 3 ,
.Xr xpc_abort 3 ,
.Xr xpcproxy 8 ,
.Xr notify 3 ,
.Xr launchd 8
                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_abort.3                                  0100644 0001750 0001750 00000005703 12566166531 022735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_abort 3
.Os Darwin
.Sh NAME
.Nm xpc_abort
.Nd conditions which cause XPC to abort
.Sh DESCRIPTION
The XPC API will aggressively defend itself against perceived misuse. Wherever 
XPC can definitively detect misuse of its APIs or data corruption, it will
abort. For example, if the retain count of an object underflows by calling
.Xr xpc_release 3
on it too many times, XPC will abort the process.
.Pp
Many frameworks opt to keep the program limping along in such a state (and will
perhaps print a warning message to the system log), but aborting upon detection
provides unmistakable warning that there is a bug present in the application
which should be fixed before shipping.
.Pp
When XPC aborts a process, it will place information about the condition which
triggered the abort in the
.Em Application Specific Information
section of the crash report. The message will be human-readable, prefixed with
"XPC API Misuse:", and the crash report will indicate the stack trace which
caused the abort.
.Pp
XPC will also abort if it detects unrecoverable data corruption in its internal
state. The messages for these conditions will be prefixd with "Bug in libxpc:".
If you come across such a crash, please file a bug and include the generated
crash log, system log and steps to reproduce (if there are any identifiable
steps).
.Pp
Currently, the manner in which XPC aborts the process will result in termination
due to SIGILL (illegal instruction). The exact signal raised may change from
release to release (or platform to platform). But on OS X Lion, SIGILL may be
used as a hint that the process was terminated intentionally.
.Sh DEBUGGING
When debugging in Xcode or at the gdb command prompt, the debugger acts as the
exception handler for the process being debugged. As a result, if the process
is aborted by XPC, no crash report will be generated, and thus it may not be
obvious why the program was terminated.
.Pp
As mentioned before, SIGILL is an indication that the process was terminated
intentionally. If you observe the last frame in the crashing stack to be
.Fn _xpc_api_misuse ,
you may use the
.Fn xpc_debugger_api_misuse_info
API from within the debugger to obtain a human-readable string describing why
the process was aborted. For example:
.Pp
.Bd -literal -offset indent
Program received signal EXC_BAD_INSTRUCTION, Illegal instruction/operand.
0x000000010012b25e in _xpc_api_misuse ()
(gdb) p (char *)xpc_debugger_api_misuse_info()
$1 = 0x7fff5fbff908 "XPC API Misuse: Over-release of object."
(gdb)
.Ed
.Pp
This message indicates that
.Xr xpc_release 3
was called too many times on an object.
.Pp
.Em IMPORTANT :
The
.Fn xpc_debugger_api_misuse_info
API can ONLY be called from within a debugger. It is not meant to be called
directly from the program. Do not call it directly from your code, and do not
rely on the address of the result for any reason.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_object 3 ,
.Xr xpc_objects 3
                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_apply.3                            0100644 0001750 0001750 00000011055 12566166531 024146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_create.3                           0100644 0001750 0001750 00000011055 12566166531 024264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_dup_fd.3                           0100644 0001750 0001750 00000011055 12566166531 024262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_bool.3                         0100644 0001750 0001750 00000011055 12566166531 024613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_connection.3                   0100644 0001750 0001750 00000011055 12566166531 026017  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_count.3                        0100644 0001750 0001750 00000011055 12566166531 025010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_data.3                         0100644 0001750 0001750 00000011055 12566166531 024571  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_date.3                         0100644 0001750 0001750 00000011055 12566166531 024575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_double.3                       0100644 0001750 0001750 00000011055 12566166531 025132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_int64.3                        0100644 0001750 0001750 00000011055 12566166531 024624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_string.3                       0100644 0001750 0001750 00000011055 12566166531 025166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_uint64.3                       0100644 0001750 0001750 00000011055 12566166531 025011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_uuid.3                         0100644 0001750 0001750 00000011055 12566166531 024626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_get_value.3                        0100644 0001750 0001750 00000011055 12566166531 024774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_bool.3                         0100644 0001750 0001750 00000011055 12566166531 024627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_connection.3                   0100644 0001750 0001750 00000011055 12566166531 026033  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_data.3                         0100644 0001750 0001750 00000011055 12566166531 024605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_date.3                         0100644 0001750 0001750 00000011055 12566166531 024611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_double.3                       0100644 0001750 0001750 00000011055 12566166531 025146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_fd.3                           0100644 0001750 0001750 00000011055 12566166531 024265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_int64.3                        0100644 0001750 0001750 00000011055 12566166531 024640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_string.3                       0100644 0001750 0001750 00000011055 12566166531 025202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_uint64.3                       0100644 0001750 0001750 00000011055 12566166531 025025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_uuid.3                         0100644 0001750 0001750 00000011055 12566166531 024642  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_array_set_value.3                        0100644 0001750 0001750 00000011055 12566166531 025010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_array_create 3
.Os Darwin
.Sh NAME
.Nm xpc_array_create
.Nd creation and management of XPC arrays
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_array_create
.Fa "const xpc_object_t *objects"
.Fa "size_t count"
.Fc
.Ft void
.Fo xpc_array_set_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_object_t value"
.Fc
.Ft void
.Fo xpc_array_append_value
.Fa "xpc_object_t array"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_array_get_value
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft size_t
.Fo xpc_array_get_count
.Fa "xpc_object_t array"
.Fc
.Ft bool
.Fo xpc_array_apply
.Fa "xpc_object_t array"
.Fa "xpc_array_applier_t applier"
.Fc
.Ft void
.Fo xpc_array_set_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_array_set_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_array_set_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_array_set_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_array_set_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_array_set_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_array_set_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_array_set_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_array_set_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "xpc_connection_t value"
.Fc
.Ft bool
.Fo xpc_array_get_bool
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_int64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft uint64_t
.Fo xpc_array_get_uint64
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft double
.Fo xpc_array_get_double
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int64_t
.Fo xpc_array_get_date
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const void *
.Fo xpc_array_get_data
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_array_get_uuid
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft const char *
.Fo xpc_array_get_string
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft int
.Fo xpc_array_dup_fd
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Ft xpc_connection_t
.Fo xpc_array_get_connection
.Fa "xpc_object_t array"
.Fa "size_t index"
.Fc
.Sh ARRAYS
XPC arrays are collections of XPC objects ordered by index. The index is
zero-based. XPC arrays are contiguous, and values must exist at all indexes
between zero and the greatest index of the array. A hole in the array can be
simulated by using a null object as returned by
.Xr xpc_null_create 3 .
.Sh CREATION
The
.Fn xpc_array_create
function returns a newly created array. The caller may optionally provide
.Fa objects ,
a C array of XPC object references,
to initialize the array. The
.Fa count
is used to specify the size of the C array.
If
.Fa objects
is NULL, then
.Fa count
must be zero. If
.Fa count
specifies more elements than are actually present in
.Fa values
or if
.Fa values
is NULL
and
.Fa count
is non-zero, the behavior is undefined.
.Sh GETTING AND SETTING VALUES
The
.Fn xpc_array_append_value
function may be used to append a
.Fa value
to the end of an
.Fa array .
This operation increases the count of the values in the array by one.
.Pp
The
.Fa value
of a specific
.Fa index
in the
.Fa array
may be set using the
.Fn xpc_array_set_value
function.
The
.Fa value
must be non-NULL, and the
.Fa index
must already exist (i.e. less than the
.Fa count
provided at creation or extended through previous append operations).
.Pp
The value at a specific
.Fa index
of an
.Fa array
may be retrieved using the
.Fn xpc_array_get_value
function.
The result of getting a non-existing
.Fa index
(i.e. one that was not specified at creation or through a previous append
operation) in undefined.
.Sh PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from an array without the need for an intermediate boxed object. See
.Xr xpc_object 3
for more information.
.Pp
The special
.Ft XPC_ARRAY_APPEND
constant may be used to append a value to the end of the
.Fa array
instead of operating on a specific
.Fa index .
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_dictionary_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_bool_create.3                            0100644 0001750 0001750 00000031100 12566166531 024072  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_bool_get_value.3                         0100644 0001750 0001750 00000031100 12566166531 024602  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_cancel.3                      0100644 0001750 0001750 00000064614 12566166531 025300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_create.3                      0100644 0001750 0001750 00000064614 12566166531 025316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_create_from_endpoint.3        0100644 0001750 0001750 00000064614 12566166531 030241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_create_mach_service.3         0100644 0001750 0001750 00000064614 12566166531 030026  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_get_asid.3                    0100644 0001750 0001750 00000064614 12566166531 025632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context 