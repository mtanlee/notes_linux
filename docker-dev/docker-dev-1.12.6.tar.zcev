ve_LIBS=$LIBS
LIBS="-lc++abi  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char __cxa_demangle ();
int
main ()
{
return __cxa_demangle ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_cppabi___cxa_demangle=yes
else
  ac_cv_lib_cppabi___cxa_demangle=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_cppabi___cxa_demangle" >&5
$as_echo "$ac_cv_lib_cppabi___cxa_demangle" >&6; }
if test "x$ac_cv_lib_cppabi___cxa_demangle" = xyes; then :
  CXXABI_LIB=-lc++abi
else

  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __cxa_demangle in -lc++" >&5
$as_echo_n "checking for __cxa_demangle in -lc++... " >&6; }
if ${ac_cv_lib_cpp___cxa_demangle+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_check_lib_save_LIBS=$LIBS
LIBS="-lc++  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char __cxa_demangle ();
int
main ()
{
return __cxa_demangle ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_cpp___cxa_demangle=yes
else
  ac_cv_lib_cpp___cxa_demangle=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_cpp___cxa_demangle" >&5
$as_echo "$ac_cv_lib_cpp___cxa_demangle" >&6; }
if test "x$ac_cv_lib_cpp___cxa_demangle" = xyes; then :
  CXXABI_LIB=-lc++
else

    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __cxa_demangle in -lsupc++" >&5
$as_echo_n "checking for __cxa_demangle in -lsupc++... " >&6; }
if ${ac_cv_lib_supcpp___cxa_demangle+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_check_lib_save_LIBS=$LIBS
LIBS="-lsupc++  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char __cxa_demangle ();
int
main ()
{
return __cxa_demangle ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_supcpp___cxa_demangle=yes
else
  ac_cv_lib_supcpp___cxa_demangle=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_supcpp___cxa_demangle" >&5
$as_echo "$ac_cv_lib_supcpp___cxa_demangle" >&6; }
if test "x$ac_cv_lib_supcpp___cxa_demangle" = xyes; then :
  CXXABI_LIB=-lsupc++
else

      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __cxa_demangle in -lstdc++" >&5
$as_echo_n "checking for __cxa_demangle in -lstdc++... " >&6; }
if ${ac_cv_lib_stdcpp___cxa_demangle+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_check_lib_save_LIBS=$LIBS
LIBS="-lstdc++  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char __cxa_demangle ();
int
main ()
{
return __cxa_demangle ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_stdcpp___cxa_demangle=yes
else
  ac_cv_lib_stdcpp___cxa_demangle=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_stdcpp___cxa_demangle" >&5
$as_echo "$ac_cv_lib_stdcpp___cxa_demangle" >&6; }
if test "x$ac_cv_lib_stdcpp___cxa_demangle" = xyes; then :
  CXXABI_LIB=-lstdc++
else
  exit 1
fi


fi


fi


fi




### Check for supported warning options ###

ORIGCFLAGS=$CFLAGS
CFLAGS="$CFLAGS -Werror -Wno-shift-negative-value"
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wno-shift-negative-value" >&5
$as_echo_n "checking whether $CC supports -Wno-shift-negative-value... " >&6; }
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
int dummy;
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  WARNINGS="$WARNINGS -Wno-shift-negative-value"
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
CFLAGS=$ORIGCFLAGS

WARNINGS=$WARNINGS

OBJCWARNINGS=$OBJCWARNINGS


### Check for libLTO ###

ORIGLDFLAGS=$LDFLAGS
LDFLAGS="$LDFLAGS -Wl,-rpath,/usr/local/lib,--enable-new-dtags"
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ld supports -rpath,<path>,--enable-new-dtags" >&5
$as_echo_n "checking whether ld supports -rpath,<path>,--enable-new-dtags... " >&6; }
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
int main(){}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  rpathlink=yes
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LDFLAGS=$ORIGLDFLAGS


    # Check whether --enable-lto-support was given.
if test "${enable_lto_support+set}" = set; then :
  enableval=$enable_lto_support;
else
  enable_lto_support=yes
fi



# Check whether --with-llvm-config was given.
if test "${with_llvm_config+set}" = set; then :
  withval=$with_llvm_config; LLVM_CONFIG=$with_llvm_config
else
  LLVM_CONFIG=no
fi


    if test "x$enable_lto_support" = "xyes"; then
        if test "x$LLVM_CONFIG" = "xno"; then
            for ac_prog in llvm-config                                    \
                llvm-config-3.8 llvm-config-3.7 llvm-config-3.6 \
                llvm-config-3.5 llvm-config-3.4 llvm-config-3.3 \
                llvm-config-3.2 llvm-config-3.1                 \
                llvm-config38 llvm-config37 llvm-config36       \
                llvm-config35 llvm-config34 llvm-config33       \
                llvm-config32 llvm-config31
do
  # Extract the first word of "$ac_prog", so it can be a program name with args.
set dummy $ac_prog; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_path_LLVM_CONFIG+:} false; then :
  $as_echo_n "(cached) " >&6
else
  case $LLVM_CONFIG in
  [\\/]* | ?:[\\/]*)
  ac_cv_path_LLVM_CONFIG="$LLVM_CONFIG" # Let the user override the test with a path.
  ;;
  *)
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_path_LLVM_CONFIG="$as_dir/$ac_word$ac_exec_ext"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

  ;;
esac
fi
LLVM_CONFIG=$ac_cv_path_LLVM_CONFIG
if test -n "$LLVM_CONFIG"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LLVM_CONFIG" >&5
$as_echo "$LLVM_CONFIG" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


  test -n "$LLVM_CONFIG" && break
done
test -n "$LLVM_CONFIG" || LLVM_CONFIG="no"

        fi

        if test "x$LLVM_CONFIG" != "xno"; then
            LLVM_INCLUDE_DIR="`${LLVM_CONFIG} --includedir`"
            LLVM_LIB_DIR="`${LLVM_CONFIG} --libdir`"

            ORIGLDFLAGS=$LDFLAGS
            LDFLAGS="$LDFLAGS -L${LLVM_LIB_DIR}"

            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for lto_get_version in -lLTO" >&5
$as_echo_n "checking for lto_get_version in -lLTO... " >&6; }
if ${ac_cv_lib_LTO_lto_get_version+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_check_lib_save_LIBS=$LIBS
LIBS="-lLTO  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char lto_get_version ();
int
main ()
{
return lto_get_version ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_LTO_lto_get_version=yes
else
  ac_cv_lib_LTO_lto_get_version=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_LTO_lto_get_version" >&5
$as_echo "$ac_cv_lib_LTO_lto_get_version" >&6; }
if test "x$ac_cv_lib_LTO_lto_get_version" = xyes; then :
   LTO_LIB="-L${LLVM_LIB_DIR} -lLTO"
               if test "x$rpathlink" = "xyes"; then
                   LTO_RPATH="-Wl,-rpath,$LLVM_LIB_DIR,--enable-new-dtags"
                   LTO_LIB="$LTO_LIB"
               fi
               LTO_DEF=-DLTO_SUPPORT
               # DO NOT include the LLVM include dir directly,
               # it may cause the build to fail.
               cp -f $LLVM_INCLUDE_DIR/llvm-c/lto.h `dirname ${0}`/include/llvm-c/lto.h



fi


            LDFLAGS=$ORIGLDFLAGS
        else
            { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: llvm-config not found, disabling LTO support" >&5
$as_echo "$as_me: WARNING: llvm-config not found, disabling LTO support" >&2;}
        fi
    fi






LDFLAGS="$LDFLAGS $LTO_RPATH"

### Check for libxar ###

if test "x$LLVM_CONFIG" != "xno"; then

{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for xar_prop_create in -lxar" >&5
$as_echo_n "checking for xar_prop_create in -lxar... " >&6; }
if ${ac_cv_lib_xar_xar_prop_create+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_check_lib_save_LIBS=$LIBS
LIBS="-lxar  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char xar_prop_create ();
int
main ()
{
return xar_prop_create ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_xar_xar_prop_create=yes
else
  ac_cv_lib_xar_xar_prop_create=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xar_xar_prop_create" >&5
$as_echo "$ac_cv_lib_xar_xar_prop_create" >&6; }
if test "x$ac_cv_lib_xar_xar_prop_create" = xyes; then :

  for ac_header in xar/xar.h
do :
  ac_fn_c_check_header_mongrel "$LINENO" "xar/xar.h" "ac_cv_header_xar_xar_h" "$ac_includes_default"
if test "x$ac_cv_header_xar_xar_h" = xyes; then :
  cat >>confdefs.h <<_ACEOF
#define HAVE_XAR_XAR_H 1
_ACEOF
 XAR_LIB=-lxar
fi

done

fi



fi

### Check whether we want to use clang as assembler ###

# Check whether --enable-clang-as was given.
if test "${enable_clang_as+set}" = set; then :
  enableval=$enable_clang_as;
else
  enable_clang_as=yes
fi


if test "x$enable_clang_as" != "xyes"; then
  CFLAGS="$CFLAGS -DDISABLE_CLANG_AS"
fi

### Check endianness ###

 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian" >&5
$as_echo_n "checking whether byte ordering is bigendian... " >&6; }
if ${ac_cv_c_bigendian+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_cv_c_bigendian=unknown
    # See if we're dealing with a universal compiler.
    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#ifndef __APPLE_CC__
	       not a universal capable compiler
	     #endif
	     typedef int dummy;

_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :

	# Check for potential -arch flags.  It is not universal unless
	# there are at least two -arch flags with different values.
	ac_arch=
	ac_prev=
	for ac_word in $CC $CFLAGS $CPPFLAGS $LDFLAGS; do
	 if test -n "$ac_prev"; then
	   case $ac_word in
	     i?86 | x86_64 | ppc | ppc64)
	       if test -z "$ac_arch" || test "$ac_arch" = "$ac_word"; then
		 ac_arch=$ac_word
	       else
		 ac_cv_c_bigendian=universal
		 break
	       fi
	       ;;
	   esac
	   ac_prev=
	 elif test "x$ac_word" = "x-arch"; then
	   ac_prev=arch
	 fi
       done
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
    if test $ac_cv_c_bigendian = unknown; then
      # See if sys/param.h defines the BYTE_ORDER macro.
      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <sys/types.h>
	     #include <sys/param.h>

int
main ()
{
#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \
		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \
		     && LITTLE_ENDIAN)
	      bogus endian macros
	     #endif

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  # It does; now see whether it defined to BIG_ENDIAN or not.
	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <sys/types.h>
		#include <sys/param.h>

int
main ()
{
#if BYTE_ORDER != BIG_ENDIAN
		 not big endian
		#endif

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_c_bigendian=yes
else
  ac_cv_c_bigendian=no
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
    fi
    if test $ac_cv_c_bigendian = unknown; then
      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).
      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <limits.h>

int
main ()
{
#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
	      bogus endian macros
	     #endif

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  # It does; now see whether it defined to _BIG_ENDIAN or not.
	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <limits.h>

int
main ()
{
#ifndef _BIG_ENDIAN
		 not big endian
		#endif

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_c_bigendian=yes
else
  ac_cv_c_bigendian=no
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
    fi
    if test $ac_cv_c_bigendian = unknown; then
      # Compile a test program.
      if test "$cross_compiling" = yes; then :
  # Try to guess by grepping values from an object file.
	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
short int ascii_mm[] =
		  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
		short int ascii_ii[] =
		  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
		int use_ascii (int i) {
		  return ascii_mm[i] + ascii_ii[i];
		}
		short int ebcdic_ii[] =
		  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
		short int ebcdic_mm[] =
		  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
		int use_ebcdic (int i) {
		  return ebcdic_mm[i] + ebcdic_ii[i];
		}
		extern int foo;

int
main ()
{
return use_ascii (foo) == use_ebcdic (foo);
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then
	      ac_cv_c_bigendian=yes
	    fi
	    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
	      if test "$ac_cv_c_bigendian" = unknown; then
		ac_cv_c_bigendian=no
	      else
		# finding both strings is unlikely to happen, but who knows?
		ac_cv_c_bigendian=unknown
	      fi
	    fi
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
$ac_includes_default
int
main ()
{

	     /* Are we little or big endian?  From Harbison&Steele.  */
	     union
	     {
	       long int l;
	       char c[sizeof (long int)];
	     } u;
	     u.l = 1;
	     return u.c[sizeof (long int) - 1] == 1;

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_run "$LINENO"; then :
  ac_cv_c_bigendian=no
else
  ac_cv_c_bigendian=yes
fi
rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
  conftest.$ac_objext conftest.beam conftest.$ac_ext
fi

    fi
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_bigendian" >&5
$as_echo "$ac_cv_c_bigendian" >&6; }
 case $ac_cv_c_bigendian in #(
   yes)
     ENDIAN_FLAG=-D__BIG_ENDIAN__=1
;; #(
   no)
     ENDIAN_FLAG=-D__LITTLE_ENDIAN__=1
 ;; #(
   universal)

$as_echo "#define AC_APPLE_UNIVERSAL_BUILD 1" >>confdefs.h

     ;; #(
   *)
     as_fn_error $? "unknown endianness
 presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5 ;;
 esac



ac_config_files="$ac_config_files Makefile libstuff/Makefile"

ac_config_files="$ac_config_files ar/Makefile"

ac_config_files="$ac_config_files as/Makefile"

ac_config_files="$ac_config_files as/arm/Makefile"

ac_config_files="$ac_config_files as/i386/Makefile"

ac_config_files="$ac_config_files as/x86_64/Makefile"

ac_config_files="$ac_config_files as/ppc/Makefile"

ac_config_files="$ac_config_files as/ppc64/Makefile"

#AC_CONFIG_FILES([man/Makefile])
ac_config_files="$ac_config_files misc/Makefile"

ac_config_files="$ac_config_files otool/Makefile"


if test "x$isdarwin" != "xyes"; then
  ac_config_files="$ac_config_files libobjc2/Makefile"

fi

ac_config_files="$ac_config_files ld/Makefile"


ac_config_files="$ac_config_files ld64/Makefile"

ac_config_files="$ac_config_files ld64/src/Makefile"

ac_config_files="$ac_config_files ld64/src/3rd/Makefile"

ac_config_files="$ac_config_files ld64/src/3rd/BlocksRuntime/Makefile"

ac_config_files="$ac_config_files ld64/src/ld/Makefile"

ac_config_files="$ac_config_files ld64/src/ld/parsers/Makefile"

ac_config_files="$ac_config_files ld64/src/ld/passes/Makefile"

ac_config_files="$ac_config_files ld64/src/other/Makefile"


cat >confcache <<\_ACEOF
# This file is a shell script that caches the results of configure
# tests run on this system so they can be shared between configure
# scripts and configure runs, see configure's option --config-cache.
# It is not useful on other systems.  If it contains results you don't
# want to keep, you may remove or edit it.
#
# config.status only pays attention to the cache file if you give it
# the --recheck option to rerun configure.
#
# `ac_cv_env_foo' variables (set or unset) will be overridden when
# loading this file, other *unset* `ac_cv_foo' will be assigned the
# following values.

_ACEOF

# The following way of writing the cache mishandles newlines in values,
# but we know of no workaround that is simple, portable, and efficient.
# So, we kill variables containing newlines.
# Ultrix sh set writes to stderr and can't be redirected directly,
# and sets the high bit in the cache file unless we assign to the vars.
(
  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
    eval ac_val=\$$ac_var
    case $ac_val in #(
    *${as_nl}*)
      case $ac_var in #(
      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      esac
      case $ac_var in #(
      _ | IFS | as_nl) ;; #(
      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
      *) { eval $ac_var=; unset $ac_var;} ;;
      esac ;;
    esac
  done

  (set) 2>&1 |
    case $as_nl`(ac_space=' '; set) 2>&1` in #(
    *${as_nl}ac_space=\ *)
      # `set' does not quote correctly, so add quotes: double-quote
      # substitution turns \\\\ into \\, and sed turns \\ into \.
      sed -n \
	"s/'/'\\\\''/g;
	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
      ;; #(
    *)
      # `set' quotes correctly as required by POSIX, so do not add quotes.
      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
      ;;
    esac |
    sort
) |
  sed '
     /^ac_cv_env_/b end
     t clear
     :clear
     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
     t end
     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
     :end' >>confcache
if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
  if test -w "$cache_file"; then
    if test "x$cache_file" != "x/dev/null"; then
      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
$as_echo "$as_me: updating cache $cache_file" >&6;}
      if test ! -f "$cache_file" || test -h "$cache_file"; then
	cat confcache >"$cache_file"
      else
        case $cache_file in #(
        */* | ?:*)
	  mv -f confcache "$cache_file"$$ &&
	  mv -f "$cache_file"$$ "$cache_file" ;; #(
        *)
	  mv -f confcache "$cache_file" ;;
	esac
      fi
    fi
  else
    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
  fi
fi
rm -f confcache

test "x$prefix" = xNONE && prefix=$ac_default_prefix
# Let make expand exec_prefix.
test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'

# Transform confdefs.h into DEFS.
# Protect against shell expansion while executing Makefile rules.
# Protect against Makefile macro expansion.
#
# If the first sed substitution is executed (which looks for macros that
# take arguments), then branch to the quote section.  Otherwise,
# look for a macro that doesn't take arguments.
ac_script='
:mline
/\\$/{
 N
 s,\\\n,,
 b mline
}
t clear
:clear
s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
t quote
s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
t quote
b any
:quote
s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
s/\[/\\&/g
s/\]/\\&/g
s/\$/$$/g
H
:any
${
	g
	s/^\n//
	s/\n/ /g
	p
}
'
DEFS=`sed -n "$ac_script" confdefs.h`


ac_libobjs=
ac_ltlibobjs=
U=
for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
  # 1. Remove the extension, and $U if already installed.
  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
  #    will be set to the directory where LIBOBJS objects are built.
  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
done
LIBOBJS=$ac_libobjs

LTLIBOBJS=$ac_ltlibobjs


if test -z "${ISDARWIN_TRUE}" && test -z "${ISDARWIN_FALSE}"; then
  as_fn_error $? "conditional \"ISDARWIN\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
if test -z "${ISDARWIN_TRUE}" && test -z "${ISDARWIN_FALSE}"; then
  as_fn_error $? "conditional \"ISDARWIN\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
$as_echo_n "checking that generated files are newer than configure... " >&6; }
   if test -n "$am_sleep_pid"; then
     # Hide warnings about reused PIDs.
     wait $am_sleep_pid 2>/dev/null
   fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
$as_echo "done" >&6; }
 if test -n "$EXEEXT"; then
  am__EXEEXT_TRUE=
  am__EXEEXT_FALSE='#'
else
  am__EXEEXT_TRUE='#'
  am__EXEEXT_FALSE=
fi

if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi


: "${CONFIG_STATUS=./config.status}"
ac_write_fail=0
ac_clean_files_save=$ac_clean_files
ac_clean_files="$ac_clean_files $CONFIG_STATUS"
{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
as_write_fail=0
cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
#! $SHELL
# Generated by $as_me.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.

debug=false
ac_cs_recheck=false
ac_cs_silent=false

SHELL=\${CONFIG_SHELL-$SHELL}
export SHELL
_ASEOF
cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error


# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -pR'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -pR'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -pR'
  fi
else
  as_ln_s='cp -pR'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null


# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p
if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi


# as_fn_executable_p FILE
# -----------------------
# Test if FILE is an executable regular file.
as_fn_executable_p ()
{
  test -f "$1" && test -x "$1"
} # as_fn_executable_p
as_test_x='test -x'
as_executable_p=as_fn_executable_p

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"


exec 6>&1
## ----------------------------------- ##
## Main body of $CONFIG_STATUS script. ##
## ----------------------------------- ##
_ASEOF
test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# Save the log message, to keep $0 and so on meaningful, and to
# report actual input values of CONFIG_FILES etc. instead of their
# values after options handling.
ac_log="
This file was extended by cctools $as_me 877.5, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  CONFIG_FILES    = $CONFIG_FILES
  CONFIG_HEADERS  = $CONFIG_HEADERS
  CONFIG_LINKS    = $CONFIG_LINKS
  CONFIG_COMMANDS = $CONFIG_COMMANDS
  $ $0 $@

on `(hostname || uname -n) 2>/dev/null | sed 1q`
"

_ACEOF

case $ac_config_files in *"
"*) set x $ac_config_files; shift; ac_config_files=$*;;
esac



cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
# Files that config.status was made for.
config_files="$ac_config_files"
config_commands="$ac_config_commands"

_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
ac_cs_usage="\
\`$as_me' instantiates files and other configuration actions
from templates according to the current configuration.  Unless the files
and actions are specified as TAGs, all are instantiated by default.

Usage: $0 [OPTION]... [TAG]...

  -h, --help       print this help, then exit
  -V, --version    print version number and configuration settings, then exit
      --config     print configuration, then exit
  -q, --quiet, --silent
                   do not print progress messages
  -d, --debug      don't remove temporary files
      --recheck    update $as_me by reconfiguring in the same conditions
      --file=FILE[:TEMPLATE]
                   instantiate the configuration file FILE

Configuration files:
$config_files

Configuration commands:
$config_commands

Report bugs to <t.poechtrager@gmail.com>."

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
ac_cs_version="\\
cctools config.status 877.5
configured by $0, generated by GNU Autoconf 2.69,
  with options \\"\$ac_cs_config\\"

Copyright (C) 2012 Free Software Foundation, Inc.
This config.status script is free software; the Free Software Foundation
gives unlimited permission to copy, distribute and modify it."

ac_pwd='$ac_pwd'
srcdir='$srcdir'
INSTALL='$INSTALL'
MKDIR_P='$MKDIR_P'
AWK='$AWK'
test -n "\$AWK" || AWK=awk
_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# The default lists apply if the user does not specify any file.
ac_need_defaults=:
while test $# != 0
do
  case $1 in
  --*=?*)
    ac_option=`expr "X$1" : 'X\([^=]*\)='`
    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
    ac_shift=:
    ;;
  --*=)
    ac_option=`expr "X$1" : 'X\([^=]*\)='`
    ac_optarg=
    ac_shift=:
    ;;
  *)
    ac_option=$1
    ac_optarg=$2
    ac_shift=shift
    ;;
  esac

  case $ac_option in
  # Handling of the options.
  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
    ac_cs_recheck=: ;;
  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
    $as_echo "$ac_cs_version"; exit ;;
  --config | --confi | --conf | --con | --co | --c )
    $as_echo "$ac_cs_config"; exit ;;
  --debug | --debu | --deb | --de | --d | -d )
    debug=: ;;
  --file | --fil | --fi | --f )
    $ac_shift
    case $ac_optarg in
    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
    '') as_fn_error $? "missing file argument" ;;
    esac
    as_fn_append CONFIG_FILES " '$ac_optarg'"
    ac_need_defaults=false;;
  --he | --h |  --help | --hel | -h )
    $as_echo "$ac_cs_usage"; exit ;;
  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
  | -silent | --silent | --silen | --sile | --sil | --si | --s)
    ac_cs_silent=: ;;

  # This is an error.
  -*) as_fn_error $? "unrecognized option: \`$1'
Try \`$0 --help' for more information." ;;

  *) as_fn_append ac_config_targets " $1"
     ac_need_defaults=false ;;

  esac
  shift
done

ac_configure_extra_args=

if $ac_cs_silent; then
  exec 6>/dev/null
  ac_configure_extra_args="$ac_configure_extra_args --silent"
fi

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
if \$ac_cs_recheck; then
  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
  shift
  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
  CONFIG_SHELL='$SHELL'
  export CONFIG_SHELL
  exec "\$@"
fi

_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
exec 5>>config.log
{
  echo
  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## Running $as_me. ##
_ASBOX
  $as_echo "$ac_log"
} >&5

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
#
# INIT-COMMANDS
#


# The HP-UX ksh and POSIX shell print the target directory to stdout
# if CDPATH is set.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

sed_quote_subst='$sed_quote_subst'
double_quote_subst='$double_quote_subst'
delay_variable_subst='$delay_variable_subst'
macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
shared_archive_member_spec='`$ECHO "$shared_archive_member_spec" | $SED "$delay_single_quote_subst"`'
SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
PATH_SEPARATOR='`$ECHO "$PATH_SEPARATOR" | $SED "$delay_single_quote_subst"`'
host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
lt_cv_to_host_file_cmd='`$ECHO "$lt_cv_to_host_file_cmd" | $SED "$delay_single_quote_subst"`'
lt_cv_to_tool_file_cmd='`$ECHO "$lt_cv_to_tool_file_cmd" | $SED "$delay_single_quote_subst"`'
reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
file_magic_glob='`$ECHO "$file_magic_glob" | $SED "$delay_single_quote_subst"`'
want_nocaseglob='`$ECHO "$want_nocaseglob" | $SED "$delay_single_quote_subst"`'
DLLTOOL='`$ECHO "$DLLTOOL" | $SED "$delay_single_quote_subst"`'
sharedlib_from_linklib_cmd='`$ECHO "$sharedlib_from_linklib_cmd" | $SED "$delay_single_quote_subst"`'
AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
archiver_list_spec='`$ECHO "$archiver_list_spec" | $SED "$delay_single_quote_subst"`'
STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_import='`$ECHO "$lt_cv_sys_global_symbol_to_import" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
lt_cv_nm_interface='`$ECHO "$lt_cv_nm_interface" | $SED "$delay_single_quote_subst"`'
nm_file_list_spec='`$ECHO "$nm_file_list_spec" | $SED "$delay_single_quote_subst"`'
lt_sysroot='`$ECHO "$lt_sysroot" | $SED "$delay_single_quote_subst"`'
lt_cv_truncate_bin='`$ECHO "$lt_cv_truncate_bin" | $SED "$delay_single_quote_subst"`'
objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
MANIFEST_TOOL='`$ECHO "$MANIFEST_TOOL" | $SED "$delay_single_quote_subst"`'
DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
postlink_cmds='`$ECHO "$postlink_cmds" | $SED "$delay_single_quote_subst"`'
file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
configure_time_dlsearch_path='`$ECHO "$configure_time_dlsearch_path" | $SED "$delay_single_quote_subst"`'
configure_time_lt_sys_library_path='`$ECHO "$configure_time_lt_sys_library_path" | $SED "$delay_single_quote_subst"`'
hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
compiler_lib_search_dirs='`$ECHO "$compiler_lib_search_dirs" | $SED "$delay_single_quote_subst"`'
predep_objects='`$ECHO "$predep_objects" | $SED "$delay_single_quote_subst"`'
postdep_objects='`$ECHO "$postdep_objects" | $SED "$delay_single_quote_subst"`'
predeps='`$ECHO "$predeps" | $SED "$delay_single_quote_subst"`'
postdeps='`$ECHO "$postdeps" | $SED "$delay_single_quote_subst"`'
compiler_lib_search_path='`$ECHO "$compiler_lib_search_path" | $SED "$delay_single_quote_subst"`'
LD_CXX='`$ECHO "$LD_CXX" | $SED "$delay_single_quote_subst"`'
reload_flag_CXX='`$ECHO "$reload_flag_CXX" | $SED "$delay_single_quote_subst"`'
reload_cmds_CXX='`$ECHO "$reload_cmds_CXX" | $SED "$delay_single_quote_subst"`'
old_archive_cmds_CXX='`$ECHO "$old_archive_cmds_CXX" | $SED "$delay_single_quote_subst"`'
compiler_CXX='`$ECHO "$compiler_CXX" | $SED "$delay_single_quote_subst"`'
GCC_CXX='`$ECHO "$GCC_CXX" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_no_builtin_flag_CXX='`$ECHO "$lt_prog_compiler_no_builtin_flag_CXX" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_pic_CXX='`$ECHO "$lt_prog_compiler_pic_CXX" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_wl_CXX='`$ECHO "$lt_prog_compiler_wl_CXX" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_static_CXX='`$ECHO "$lt_prog_compiler_static_CXX" | $SED "$delay_single_quote_subst"`'
lt_cv_prog_compiler_c_o_CXX='`$ECHO "$lt_cv_prog_compiler_c_o_CXX" | $SED "$delay_single_quote_subst"`'
archive_cmds_need_lc_CXX='`$ECHO "$archive_cmds_need_lc_CXX" | $SED "$delay_single_quote_subst"`'
enable_shared_with_static_runtimes_CXX='`$ECHO "$enable_shared_with_static_runtimes_CXX" | $SED "$delay_single_quote_subst"`'
export_dynamic_flag_spec_CXX='`$ECHO "$export_dynamic_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
whole_archive_flag_spec_CXX='`$ECHO "$whole_archive_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
compiler_needs_object_CXX='`$ECHO "$compiler_needs_object_CXX" | $SED "$delay_single_quote_subst"`'
old_archive_from_new_cmds_CXX='`$ECHO "$old_archive_from_new_cmds_CXX" | $SED "$delay_single_quote_subst"`'
old_archive_from_expsyms_cmds_CXX='`$ECHO "$old_archive_from_expsyms_cmds_CXX" | $SED "$delay_single_quote_subst"`'
archive_cmds_CXX='`$ECHO "$archive_cmds_CXX" | $SED "$delay_single_quote_subst"`'
archive_expsym_cmds_CXX='`$ECHO "$archive_expsym_cmds_CXX" | $SED "$delay_single_quote_subst"`'
module_cmds_CXX='`$ECHO "$module_cmds_CXX" | $SED "$delay_single_quote_subst"`'
module_expsym_cmds_CXX='`$ECHO "$module_expsym_cmds_CXX" | $SED "$delay_single_quote_subst"`'
with_gnu_ld_CXX='`$ECHO "$with_gnu_ld_CXX" | $SED "$delay_single_quote_subst"`'
allow_undefined_flag_CXX='`$ECHO "$allow_undefined_flag_CXX" | $SED "$delay_single_quote_subst"`'
no_undefined_flag_CXX='`$ECHO "$no_undefined_flag_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_libdir_flag_spec_CXX='`$ECHO "$hardcode_libdir_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_libdir_separator_CXX='`$ECHO "$hardcode_libdir_separator_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_direct_CXX='`$ECHO "$hardcode_direct_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_direct_absolute_CXX='`$ECHO "$hardcode_direct_absolute_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_minus_L_CXX='`$ECHO "$hardcode_minus_L_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_shlibpath_var_CXX='`$ECHO "$hardcode_shlibpath_var_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_automatic_CXX='`$ECHO "$hardcode_automatic_CXX" | $SED "$delay_single_quote_subst"`'
inherit_rpath_CXX='`$ECHO "$inherit_rpath_CXX" | $SED "$delay_single_quote_subst"`'
link_all_deplibs_CXX='`$ECHO "$link_all_deplibs_CXX" | $SED "$delay_single_quote_subst"`'
always_export_symbols_CXX='`$ECHO "$always_export_symbols_CXX" | $SED "$delay_single_quote_subst"`'
export_symbols_cmds_CXX='`$ECHO "$export_symbols_cmds_CXX" | $SED "$delay_single_quote_subst"`'
exclude_expsyms_CXX='`$ECHO "$exclude_expsyms_CXX" | $SED "$delay_single_quote_subst"`'
include_expsyms_CXX='`$ECHO "$include_expsyms_CXX" | $SED "$delay_single_quote_subst"`'
prelink_cmds_CXX='`$ECHO "$prelink_cmds_CXX" | $SED "$delay_single_quote_subst"`'
postlink_cmds_CXX='`$ECHO "$postlink_cmds_CXX" | $SED "$delay_single_quote_subst"`'
file_list_spec_CXX='`$ECHO "$file_list_spec_CXX" | $SED "$delay_single_quote_subst"`'
hardcode_action_CXX='`$ECHO "$hardcode_action_CXX" | $SED "$delay_single_quote_subst"`'
compiler_lib_search_dirs_CXX='`$ECHO "$compiler_lib_search_dirs_CXX" | $SED "$delay_single_quote_subst"`'
predep_objects_CXX='`$ECHO "$predep_objects_CXX" | $SED "$delay_single_quote_subst"`'
postdep_objects_CXX='`$ECHO "$postdep_objects_CXX" | $SED "$delay_single_quote_subst"`'
predeps_CXX='`$ECHO "$predeps_CXX" | $SED "$delay_single_quote_subst"`'
postdeps_CXX='`$ECHO "$postdeps_CXX" | $SED "$delay_single_quote_subst"`'
compiler_lib_search_path_CXX='`$ECHO "$compiler_lib_search_path_CXX" | $SED "$delay_single_quote_subst"`'

LTCC='$LTCC'
LTCFLAGS='$LTCFLAGS'
compiler='$compiler_DEFAULT'

# A function that is used when there is no print builtin or printf.
func_fallback_echo ()
{
  eval 'cat <<_LTECHO_EOF
\$1
_LTECHO_EOF'
}

# Quote evaled strings.
for var in SHELL \
ECHO \
PATH_SEPARATOR \
SED \
GREP \
EGREP \
FGREP \
LD \
NM \
LN_S \
lt_SP2NL \
lt_NL2SP \
reload_flag \
OBJDUMP \
deplibs_check_method \
file_magic_cmd \
file_magic_glob \
want_nocaseglob \
DLLTOOL \
sharedlib_from_linklib_cmd \
AR \
AR_FLAGS \
archiver_list_spec \
STRIP \
RANLIB \
CC \
CFLAGS \
compiler \
lt_cv_sys_global_symbol_pipe \
lt_cv_sys_global_symbol_to_cdecl \
lt_cv_sys_global_symbol_to_import \
lt_cv_sys_global_symbol_to_c_name_address \
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
lt_cv_nm_interface \
nm_file_list_spec \
lt_cv_truncate_bin \
lt_prog_compiler_no_builtin_flag \
lt_prog_compiler_pic \
lt_prog_compiler_wl \
lt_prog_compiler_static \
lt_cv_prog_compiler_c_o \
need_locks \
MANIFEST_TOOL \
DSYMUTIL \
NMEDIT \
LIPO \
OTOOL \
OTOOL64 \
shrext_cmds \
export_dynamic_flag_spec \
whole_archive_flag_spec \
compiler_needs_object \
with_gnu_ld \
allow_undefined_flag \
no_undefined_flag \
hardcode_libdir_flag_spec \
hardcode_libdir_separator \
exclude_expsyms \
include_expsyms \
file_list_spec \
variables_saved_for_relink \
libname_spec \
library_names_spec \
soname_spec \
install_override_mode \
finish_eval \
old_striplib \
striplib \
compiler_lib_search_dirs \
predep_objects \
postdep_objects \
predeps \
postdeps \
compiler_lib_search_path \
LD_CXX \
reload_flag_CXX \
compiler_CXX \
lt_prog_compiler_no_builtin_flag_CXX \
lt_prog_compiler_pic_CXX \
lt_prog_compiler_wl_CXX \
lt_prog_compiler_static_CXX \
lt_cv_prog_compiler_c_o_CXX \
export_dynamic_flag_spec_CXX \
whole_archive_flag_spec_CXX \
compiler_needs_object_CXX \
with_gnu_ld_CXX \
allow_undefined_flag_CXX \
no_undefined_flag_CXX \
hardcode_libdir_flag_spec_CXX \
hardcode_libdir_separator_CXX \
exclude_expsyms_CXX \
include_expsyms_CXX \
file_list_spec_CXX \
compiler_lib_search_dirs_CXX \
predep_objects_CXX \
postdep_objects_CXX \
predeps_CXX \
postdeps_CXX \
compiler_lib_search_path_CXX; do
    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
    *[\\\\\\\`\\"\\\$]*)
      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\"" ## exclude from sc_prohibit_nested_quotes
      ;;
    *)
      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
      ;;
    esac
done

# Double-quote double-evaled strings.
for var in reload_cmds \
old_postinstall_cmds \
old_postuninstall_cmds \
old_archive_cmds \
extract_expsyms_cmds \
old_archive_from_new_cmds \
old_archive_from_expsyms_cmds \
archive_cmds \
archive_expsym_cmds \
module_cmds \
module_expsym_cmds \
export_symbols_cmds \
prelink_cmds \
postlink_cmds \
postinstall_cmds \
postuninstall_cmds \
finish_cmds \
sys_lib_search_path_spec \
configure_time_dlsearch_path \
configure_time_lt_sys_library_path \
reload_cmds_CXX \
old_archive_cmds_CXX \
old_archive_from_new_cmds_CXX \
old_archive_from_expsyms_cmds_CXX \
archive_cmds_CXX \
archive_expsym_cmds_CXX \
module_cmds_CXX \
module_expsym_cmds_CXX \
export_symbols_cmds_CXX \
prelink_cmds_CXX \
postlink_cmds_CXX; do
    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
    *[\\\\\\\`\\"\\\$]*)
      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\"" ## exclude from sc_prohibit_nested_quotes
      ;;
    *)
      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
      ;;
    esac
done

ac_aux_dir='$ac_aux_dir'

# See if we are running on zsh, and set the options that allow our
# commands through without removal of \ escapes INIT.
if test -n "\${ZSH_VERSION+set}"; then
   setopt NO_GLOB_SUBST
fi


    PACKAGE='$PACKAGE'
    VERSION='$VERSION'
    RM='$RM'
    ofile='$ofile'






_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1

# Handling of arguments.
for ac_config_target in $ac_config_targets
do
  case $ac_config_target in
    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
    "libstuff/Makefile") CONFIG_FILES="$CONFIG_FILES libstuff/Makefile" ;;
    "ar/Makefile") CONFIG_FILES="$CONFIG_FILES ar/Makefile" ;;
    "as/Makefile") CONFIG_FILES="$CONFIG_FILES as/Makefile" ;;
    "as/arm/Makefile") CONFIG_FILES="$CONFIG_FILES as/arm/Makefile" ;;
    "as/i386/Makefile") CONFIG_FILES="$CONFIG_FILES as/i386/Makefile" ;;
    "as/x86_64/Makefile") CONFIG_FILES="$CONFIG_FILES as/x86_64/Makefile" ;;
    "as/ppc/Makefile") CONFIG_FILES="$CONFIG_FILES as/ppc/Makefile" ;;
    "as/ppc64/Makefile") CONFIG_FILES="$CONFIG_FILES as/ppc64/Makefile" ;;
    "misc/Makefile") CONFIG_FILES="$CONFIG_FILES misc/Makefile" ;;
    "otool/Makefile") CONFIG_FILES="$CONFIG_FILES otool/Makefile" ;;
    "libobjc2/Makefile") CONFIG_FILES="$CONFIG_FILES libobjc2/Makefile" ;;
    "ld/Makefile") CONFIG_FILES="$CONFIG_FILES ld/Makefile" ;;
    "ld64/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/Makefile" ;;
    "ld64/src/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/Makefile" ;;
    "ld64/src/3rd/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/3rd/Makefile" ;;
    "ld64/src/3rd/BlocksRuntime/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/3rd/BlocksRuntime/Makefile" ;;
    "ld64/src/ld/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/ld/Makefile" ;;
    "ld64/src/ld/parsers/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/ld/parsers/Makefile" ;;
    "ld64/src/ld/passes/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/ld/passes/Makefile" ;;
    "ld64/src/other/Makefile") CONFIG_FILES="$CONFIG_FILES ld64/src/other/Makefile" ;;

  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
  esac
done


# If the user did not use the arguments to specify the items to instantiate,
# then the envvar interface is used.  Set only those that are not.
# We use the long form for the default assignment because of an extremely
# bizarre bug on SunOS 4.1.3.
if $ac_need_defaults; then
  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
fi

# Have a temporary directory for convenience.  Make it in the build tree
# simply because there is no reason against having it here, and in addition,
# creating and moving files from /tmp can sometimes cause problems.
# Hook for its removal unless debugging.
# Note that there is a small window in which the directory will not be cleaned:
# after its creation but before its name has been assigned to `$tmp'.
$debug ||
{
  tmp= ac_tmp=
  trap 'exit_status=$?
  : "${ac_tmp:=$tmp}"
  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
' 0
  trap 'as_fn_exit 1' 1 2 13 15
}
# Create a (secure) tmp directory for tmp files.

{
  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
  test -d "$tmp"
}  ||
{
  tmp=./conf$$-$RANDOM
  (umask 077 && mkdir "$tmp")
} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
ac_tmp=$tmp

# Set up the scripts for CONFIG_FILES section.
# No need to generate them if there are no CONFIG_FILES.
# This happens for instance with `./config.status config.h'.
if test -n "$CONFIG_FILES"; then


ac_cr=`echo X | tr X '\015'`
# On cygwin, bash can eat \r inside `` if the user requested igncr.
# But we know of no other shell where ac_cr would be empty at this
# point, so we can use a bashism as a fallback.
if test "x$ac_cr" = x; then
  eval ac_cr=\$\'\\r\'
fi
ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
  ac_cs_awk_cr='\\r'
else
  ac_cs_awk_cr=$ac_cr
fi

echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
_ACEOF


{
  echo "cat >conf$$subs.awk <<_ACEOF" &&
  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
  echo "_ACEOF"
} >conf$$subs.sh ||
  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
ac_delim='%!_!# '
for ac_last_try in false false false false false :; do
  . ./conf$$subs.sh ||
    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5

  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
  if test $ac_delim_n = $ac_delim_num; then
    break
  elif $ac_last_try; then
    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
  else
    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
  fi
done
rm -f conf$$subs.sh

cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
_ACEOF
sed -n '
h
s/^/S["/; s/!.*/"]=/
p
g
s/^[^!]*!//
:repl
t repl
s/'"$ac_delim"'$//
t delim
:nl
h
s/\(.\{148\}\)..*/\1/
t more1
s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
p
n
b repl
:more1
s/["\\]/\\&/g; s/^/"/; s/$/"\\/
p
g
s/.\{148\}//
t nl
:delim
h
s/\(.\{148\}\)..*/\1/
t more2
s/["\\]/\\&/g; s/^/"/; s/$/"/
p
b
:more2
s/["\\]/\\&/g; s/^/"/; s/$/"\\/
p
g
s/.\{148\}//
t delim
' <conf$$subs.awk | sed '
/^[^""]/{
  N
  s/\n//
}
' >>$CONFIG_STATUS || ac_write_fail=1
rm -f conf$$subs.awk
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
_ACAWK
cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
  for (key in S) S_is_set[key] = 1
  FS = ""

}
{
  line = $ 0
  nfields = split(line, field, "@")
  substed = 0
  len = length(field[1])
  for (i = 2; i < nfields; i++) {
    key = field[i]
    keylen = length(key)
    if (S_is_set[key]) {
      value = S[key]
      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
      len += length(value) + length(field[++i])
      substed = 1
    } else
      len += 1 + keylen
  }

  print line
}

_ACAWK
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
else
  cat
fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
_ACEOF

# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
# trailing colons and then remove the whole line if VPATH becomes empty
# (actually we leave an empty line to preserve line numbers).
if test "x$srcdir" = x.; then
  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
h
s///
s/^/:/
s/[	 ]*$/:/
s/:\$(srcdir):/:/g
s/:\${srcdir}:/:/g
s/:@srcdir@:/:/g
s/^:*//
s/:*$//
x
s/\(=[	 ]*\).*/\1/
G
s/\n//
s/^[^=]*=[	 ]*$//
}'
fi

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
fi # test -n "$CONFIG_FILES"


eval set X "  :F $CONFIG_FILES      :C $CONFIG_COMMANDS"
shift
for ac_tag
do
  case $ac_tag in
  :[FHLC]) ac_mode=$ac_tag; continue;;
  esac
  case $ac_mode$ac_tag in
  :[FHL]*:*);;
  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
  :[FH]-) ac_tag=-:-;;
  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
  esac
  ac_save_IFS=$IFS
  IFS=:
  set x $ac_tag
  IFS=$ac_save_IFS
  shift
  ac_file=$1
  shift

  case $ac_mode in
  :L) ac_source=$1;;
  :[FH])
    ac_file_inputs=
    for ac_f
    do
      case $ac_f in
      -) ac_f="$ac_tmp/stdin";;
      *) # Look for the file first in the build tree, then in the source tree
	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
	 # because $ac_f cannot contain `:'.
	 test -f "$ac_f" ||
	   case $ac_f in
	   [\\/$]*) false;;
	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
	   esac ||
	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
      esac
      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
      as_fn_append ac_file_inputs " '$ac_f'"
    done

    # Let's still pretend it is `configure' which instantiates (i.e., don't
    # use $as_me), people would be surprised to read:
    #    /* config.h.  Generated by config.status.  */
    configure_input='Generated from '`
	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
	`' by configure.'
    if test x"$ac_file" != x-; then
      configure_input="$ac_file.  $configure_input"
      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
$as_echo "$as_me: creating $ac_file" >&6;}
    fi
    # Neutralize special characters interpreted by sed in replacement strings.
    case $configure_input in #(
    *\&* | *\|* | *\\* )
       ac_sed_conf_input=`$as_echo "$configure_input" |
       sed 's/[\\\\&|]/\\\\&/g'`;; #(
    *) ac_sed_conf_input=$configure_input;;
    esac

    case $ac_tag in
    *:-:* | *:-) cat >"$ac_tmp/stdin" \
      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
    esac
    ;;
  esac

  ac_dir=`$as_dirname -- "$ac_file" ||
$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$ac_file" : 'X\(//\)[^/]' \| \
	 X"$ac_file" : 'X\(//\)$' \| \
	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$ac_file" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
  as_dir="$ac_dir"; as_fn_mkdir_p
  ac_builddir=.

case "$ac_dir" in
.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
*)
  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
  # A ".." for each directory in $ac_dir_suffix.
  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
  case $ac_top_builddir_sub in
  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
  esac ;;
esac
ac_abs_top_builddir=$ac_pwd
ac_abs_builddir=$ac_pwd$ac_dir_suffix
# for backward compatibility:
ac_top_builddir=$ac_top_build_prefix

case $srcdir in
  .)  # We are building in place.
    ac_srcdir=.
    ac_top_srcdir=$ac_top_builddir_sub
    ac_abs_top_srcdir=$ac_pwd ;;
  [\\/]* | ?:[\\/]* )  # Absolute name.
    ac_srcdir=$srcdir$ac_dir_suffix;
    ac_top_srcdir=$srcdir
    ac_abs_top_srcdir=$srcdir ;;
  *) # Relative name.
    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
    ac_top_srcdir=$ac_top_build_prefix$srcdir
    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
esac
ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix


  case $ac_mode in
  :F)
  #
  # CONFIG_FILE
  #

  case $INSTALL in
  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
  esac
  ac_MKDIR_P=$MKDIR_P
  case $MKDIR_P in
  [\\/$]* | ?:[\\/]* ) ;;
  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
  esac
_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# If the template does not know about datarootdir, expand it.
# FIXME: This hack should be removed a few years after 2.60.
ac_datarootdir_hack=; ac_datarootdir_seen=
ac_sed_dataroot='
/datarootdir/ {
  p
  q
}
/@datadir@/p
/@docdir@/p
/@infodir@/p
/@localedir@/p
/@mandir@/p'
case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
*datarootdir*) ac_datarootdir_seen=yes;;
*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  ac_datarootdir_hack='
  s&@datadir@&$datadir&g
  s&@docdir@&$docdir&g
  s&@infodir@&$infodir&g
  s&@localedir@&$localedir&g
  s&@mandir@&$mandir&g
  s&\\\${datarootdir}&$datarootdir&g' ;;
esac
_ACEOF

# Neutralize VPATH when `$srcdir' = `.'.
# Shell code in configure.ac might set extrasub.
# FIXME: do we really want to maintain this feature?
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
ac_sed_extra="$ac_vpsub
$extrasub
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
:t
/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
s|@configure_input@|$ac_sed_conf_input|;t t
s&@top_builddir@&$ac_top_builddir_sub&;t t
s&@top_build_prefix@&$ac_top_build_prefix&;t t
s&@srcdir@&$ac_srcdir&;t t
s&@abs_srcdir@&$ac_abs_srcdir&;t t
s&@top_srcdir@&$ac_top_srcdir&;t t
s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
s&@builddir@&$ac_builddir&;t t
s&@abs_builddir@&$ac_abs_builddir&;t t
s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
s&@INSTALL@&$ac_INSTALL&;t t
s&@MKDIR_P@&$ac_MKDIR_P&;t t
$ac_datarootdir_hack
"
eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5

test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
      "$ac_tmp/out"`; test -z "$ac_out"; } &&
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
which seems to be undefined.  Please make sure it is defined" >&5
$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
which seems to be undefined.  Please make sure it is defined" >&2;}

  rm -f "$ac_tmp/stdin"
  case $ac_file in
  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
  esac \
  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 ;;


  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
$as_echo "$as_me: executing $ac_file commands" >&6;}
 ;;
  esac


  case $ac_file$ac_mode in
    "libtool":C)

    # See if we are running on zsh, and set the options that allow our
    # commands through without removal of \ escapes.
    if test -n "${ZSH_VERSION+set}"; then
      setopt NO_GLOB_SUBST
    fi

    cfgfile=${ofile}T
    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
    $RM "$cfgfile"

    cat <<_LT_EOF >> "$cfgfile"
#! $SHELL
# Generated automatically by $as_me ($PACKAGE) $VERSION
# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
# NOTE: Changes made to this file will be lost: look at ltmain.sh.

# Provide generalized library-building support services.
# Written by Gordon Matzigkeit, 1996

# Copyright (C) 2014 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# GNU Libtool is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of of the License, or
# (at your option) any later version.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program or library that is built
# using GNU Libtool, you may include this file under the  same
# distribution terms that you use for the rest of that program.
#
# GNU Libtool is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# The names of the tagged configurations supported by this script.
available_tags='CXX '

# Configured defaults for sys_lib_dlsearch_path munging.
: \${LT_SYS_LIBRARY_PATH="$configure_time_lt_sys_library_path"}

# ### BEGIN LIBTOOL CONFIG

# Which release of libtool.m4 was used?
macro_version=$macro_version
macro_revision=$macro_revision

# Whether or not to build static libraries.
build_old_libs=$enable_static

# Whether or not to build shared libraries.
build_libtool_libs=$enable_shared

# What type of objects to build.
pic_mode=$pic_mode

# Whether or not to optimize for fast installation.
fast_install=$enable_fast_install

# Shared archive member basename,for filename based shared library versioning on AIX.
shared_archive_member_spec=$shared_archive_member_spec

# Shell to use when invoking shell scripts.
SHELL=$lt_SHELL

# An echo program that protects backslashes.
ECHO=$lt_ECHO

# The PATH separator for the build system.
PATH_SEPARATOR=$lt_PATH_SEPARATOR

# The host system.
host_alias=$host_alias
host=$host
host_os=$host_os

# The build system.
build_alias=$build_alias
build=$build
build_os=$build_os

# A sed program that does not truncate output.
SED=$lt_SED

# Sed that helps us avoid accidentally triggering echo(1) options like -n.
Xsed="\$SED -e 1s/^X//"

# A grep program that handles long lines.
GREP=$lt_GREP

# An ERE matcher.
EGREP=$lt_EGREP

# A literal string matcher.
FGREP=$lt_FGREP

# A BSD- or MS-compatible name lister.
NM=$lt_NM

# Whether we need soft or hard links.
LN_S=$lt_LN_S

# What is the maximum length of a command?
max_cmd_len=$max_cmd_len

# Object file suffix (normally "o").
objext=$ac_objext

# Executable file suffix (normally "").
exeext=$exeext

# whether the shell understands "unset".
lt_unset=$lt_unset

# turn spaces into newlines.
SP2NL=$lt_lt_SP2NL

# turn newlines into spaces.
NL2SP=$lt_lt_NL2SP

# convert \$build file names to \$host format.
to_host_file_cmd=$lt_cv_to_host_file_cmd

# convert \$build files to toolchain format.
to_tool_file_cmd=$lt_cv_to_tool_file_cmd

# An object symbol dumper.
OBJDUMP=$lt_OBJDUMP

# Method to check whether dependent libraries are shared objects.
deplibs_check_method=$lt_deplibs_check_method

# Command to use when deplibs_check_method = "file_magic".
file_magic_cmd=$lt_file_magic_cmd

# How to find potential files when deplibs_check_method = "file_magic".
file_magic_glob=$lt_file_magic_glob

# Find potential files using nocaseglob when deplibs_check_method = "file_magic".
want_nocaseglob=$lt_want_nocaseglob

# DLL creation program.
DLLTOOL=$lt_DLLTOOL

# Command to associate shared and link libraries.
sharedlib_from_linklib_cmd=$lt_sharedlib_from_linklib_cmd

# The archiver.
AR=$lt_AR

# Flags to create an archive.
AR_FLAGS=$lt_AR_FLAGS

# How to feed a file listing to the archiver.
archiver_list_spec=$lt_archiver_list_spec

# A symbol stripping program.
STRIP=$lt_STRIP

# Commands used to install an old-style archive.
RANLIB=$lt_RANLIB
old_postinstall_cmds=$lt_old_postinstall_cmds
old_postuninstall_cmds=$lt_old_postuninstall_cmds

# Whether to use a lock for old archive extraction.
lock_old_archive_extraction=$lock_old_archive_extraction

# A C compiler.
LTCC=$lt_CC

# LTCC compiler flags.
LTCFLAGS=$lt_CFLAGS

# Take the output of nm and produce a listing of raw symbols and C names.
global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe

# Transform the output of nm in a proper C declaration.
global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl

# Transform the output of nm into a list of symbols to manually relocate.
global_symbol_to_import=$lt_lt_cv_sys_global_symbol_to_import

# Transform the output of nm in a C name address pair.
global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address

# Transform the output of nm in a C name address pair when lib prefix is needed.
global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix

# The name lister interface.
nm_interface=$lt_lt_cv_nm_interface

# Specify filename containing input files for \$NM.
nm_file_list_spec=$lt_nm_file_list_spec

# The root where to search for dependent libraries,and where our libraries should be installed.
lt_sysroot=$lt_sysroot

# Command to truncate a binary pipe.
lt_truncate_bin=$lt_lt_cv_truncate_bin

# The name of the directory that contains temporary libtool files.
objdir=$objdir

# Used to examine libraries when file_magic_cmd begins with "file".
MAGIC_CMD=$MAGIC_CMD

# Must we lock files when doing compilation?
need_locks=$lt_need_locks

# Manifest tool.
MANIFEST_TOOL=$lt_MANIFEST_TOOL

# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
DSYMUTIL=$lt_DSYMUTIL

# Tool to change global to local symbols on Mac OS X.
NMEDIT=$lt_NMEDIT

# Tool to manipulate fat objects and archives on Mac OS X.
LIPO=$lt_LIPO

# ldd/readelf like tool for Mach-O binaries on Mac OS X.
OTOOL=$lt_OTOOL

# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
OTOOL64=$lt_OTOOL64

# Old archive suffix (normally "a").
libext=$libext

# Shared library suffix (normally ".so").
shrext_cmds=$lt_shrext_cmds

# The commands to extract the exported symbol list from a shared archive.
extract_expsyms_cmds=$lt_extract_expsyms_cmds

# Variables whose values should be saved in libtool wrapper scripts and
# restored at link time.
variables_saved_for_relink=$lt_variables_saved_for_relink

# Do we need the "lib" prefix for modules?
need_lib_prefix=$need_lib_prefix

# Do we need a version for libraries?
need_version=$need_version

# Library versioning type.
version_type=$version_type

# Shared library runtime path variable.
runpath_var=$runpath_var

# Shared library path variable.
shlibpath_var=$shlibpath_var

# Is shlibpath searched before the hard-coded library search path?
shlibpath_overrides_runpath=$shlibpath_overrides_runpath

# Format of library name prefix.
libname_spec=$lt_libname_spec

# List of archive names.  First name is the real one, the rest are links.
# The last name is the one that the linker finds with -lNAME
library_names_spec=$lt_library_names_spec

# The coded name of the library, if different from the real name.
soname_spec=$lt_soname_spec

# Permission mode override for installation of shared libraries.
install_override_mode=$lt_install_override_mode

# Command to use after installation of a shared archive.
postinstall_cmds=$lt_postinstall_cmds

# Command to use after uninstallation of a shared archive.
postuninstall_cmds=$lt_postuninstall_cmds

# Commands used to finish a libtool library installation in a directory.
finish_cmds=$lt_finish_cmds

# As "finish_cmds", except a single script fragment to be evaled but
# not shown.
finish_eval=$lt_finish_eval

# Whether we should hardcode library paths into libraries.
hardcode_into_libs=$hardcode_into_libs

# Compile-time system search path for libraries.
sys_lib_search_path_spec=$lt_sys_lib_search_path_spec

# Detected run-time system search path for libraries.
sys_lib_dlsearch_path_spec=$lt_configure_time_dlsearch_path

# Explicit LT_SYS_LIBRARY_PATH set during ./configure time.
configure_time_lt_sys_library_path=$lt_configure_time_lt_sys_library_path

# Whether dlopen is supported.
dlopen_support=$enable_dlopen

# Whether dlopen of programs is supported.
dlopen_self=$enable_dlopen_self

# Whether dlopen of statically linked programs is supported.
dlopen_self_static=$enable_dlopen_self_static

# Commands to strip libraries.
old_striplib=$lt_old_striplib
striplib=$lt_striplib


# The linker used to build libraries.
LD=$lt_LD

# How to create reloadable object files.
reload_flag=$lt_reload_flag
reload_cmds=$lt_reload_cmds

# Commands used to build an old-style archive.
old_archive_cmds=$lt_old_archive_cmds

# A language specific compiler.
CC=$lt_compiler

# Is the compiler the GNU compiler?
with_gcc=$GCC

# Compiler flag to turn off builtin functions.
no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag

# Additional compiler flags for building library objects.
pic_flag=$lt_lt_prog_compiler_pic

# How to pass a linker flag through the compiler.
wl=$lt_lt_prog_compiler_wl

# Compiler flag to prevent dynamic linking.
link_static_flag=$lt_lt_prog_compiler_static

# Does compiler simultaneously support -c and -o options?
compiler_c_o=$lt_lt_cv_prog_compiler_c_o

# Whether or not to add -lc for building shared libraries.
build_libtool_need_lc=$archive_cmds_need_lc

# Whether or not to disallow shared libs when runtime libs are static.
allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes

# Compiler flag to allow reflexive dlopens.
export_dynamic_flag_spec=$lt_export_dynamic_flag_spec

# Compiler flag to generate shared objects directly from archives.
whole_archive_flag_spec=$lt_whole_archive_flag_spec

# Whether the compiler copes with passing no objects directly.
compiler_needs_object=$lt_compiler_needs_object

# Create an old-style archive from a shared archive.
old_archive_from_new_cmds=$lt_old_archive_from_new_cmds

# Create a temporary old-style archive to link instead of a shared archive.
old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds

# Commands used to build a shared archive.
archive_cmds=$lt_archive_cmds
archive_expsym_cmds=$lt_archive_expsym_cmds

# Commands used to build a loadable module if different from building
# a shared archive.
module_cmds=$lt_module_cmds
module_expsym_cmds=$lt_module_expsym_cmds

# Whether we are building with GNU ld or not.
with_gnu_ld=$lt_with_gnu_ld

# Flag that allows shared libraries with undefined symbols to be built.
allow_undefined_flag=$lt_allow_undefined_flag

# Flag that enforces no undefined symbols.
no_undefined_flag=$lt_no_undefined_flag

# Flag to hardcode \$libdir into a binary during linking.
# This must work even if \$libdir does not exist
hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec

# Whether we need a single "-rpath" flag with a separated argument.
hardcode_libdir_separator=$lt_hardcode_libdir_separator

# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
# DIR into the resulting binary.
hardcode_direct=$hardcode_direct

# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
# DIR into the resulting binary and the resulting library dependency is
# "absolute",i.e impossible to change by setting \$shlibpath_var if the
# library is relocated.
hardcode_direct_absolute=$hardcode_direct_absolute

# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
# into the resulting binary.
hardcode_minus_L=$hardcode_minus_L

# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
# into the resulting binary.
hardcode_shlibpath_var=$hardcode_shlibpath_var

# Set to "yes" if building a shared library automatically hardcodes DIR
# into the library and all subsequent libraries and executables linked
# against it.
hardcode_automatic=$hardcode_automatic

# Set to yes if linker adds runtime paths of dependent libraries
# to runtime path list.
inherit_rpath=$inherit_rpath

# Whether libtool must link a program against all its dependency libraries.
link_all_deplibs=$link_all_deplibs

# Set to "yes" if exported symbols are required.
always_export_symbols=$always_export_symbols

# The commands to list exported symbols.
export_symbols_cmds=$lt_export_symbols_cmds

# Symbols that should not be listed in the preloaded symbols.
exclude_expsyms=$lt_exclude_expsyms

# Symbols that must always be exported.
include_expsyms=$lt_include_expsyms

# Commands necessary for linking programs (against libraries) with templates.
prelink_cmds=$lt_prelink_cmds

# Commands necessary for finishing linking programs.
postlink_cmds=$lt_postlink_cmds

# Specify filename containing input files.
file_list_spec=$lt_file_list_spec

# How to hardcode a shared library path into an executable.
hardcode_action=$hardcode_action

# The directories searched by this compiler when creating a shared library.
compiler_lib_search_dirs=$lt_compiler_lib_search_dirs

# Dependencies to place before and after the objects being linked to
# create a shared library.
predep_objects=$lt_predep_objects
postdep_objects=$lt_postdep_objects
predeps=$lt_predeps
postdeps=$lt_postdeps

# The library search path used internally by the compiler when linking
# a shared library.
compiler_lib_search_path=$lt_compiler_lib_search_path

# ### END LIBTOOL CONFIG

_LT_EOF

    cat <<'_LT_EOF' >> "$cfgfile"

# ### BEGIN FUNCTIONS SHARED WITH CONFIGURE

# func_munge_path_list VARIABLE PATH
# -----------------------------------
# VARIABLE is name of variable containing _space_ separated list of
# directories to be munged by the contents of PATH, which is string
# having a format:
# "DIR[:DIR]:"
#       string "DIR[ DIR]" will be prepended to VARIABLE
# ":DIR[:DIR]"
#       string "DIR[ DIR]" will be appended to VARIABLE
# "DIRP[:DIRP]::[DIRA:]DIRA"
#       string "DIRP[ DIRP]" will be prepended to VARIABLE and string
#       "DIRA[ DIRA]" will be appended to VARIABLE
# "DIR[:DIR]"
#       VARIABLE will be replaced by "DIR[ DIR]"
func_munge_path_list ()
{
    case x$2 in
    x)
        ;;
    *:)
        eval $1=\"`$ECHO $2 | $SED 's/:/ /g'` \$$1\"
        ;;
    x:*)
        eval $1=\"\$$1 `$ECHO $2 | $SED 's/:/ /g'`\"
        ;;
    *::*)
        eval $1=\"\$$1\ `$ECHO $2 | $SED -e 's/.*:://' -e 's/:/ /g'`\"
        eval $1=\"`$ECHO $2 | $SED -e 's/::.*//' -e 's/:/ /g'`\ \$$1\"
        ;;
    *)
        eval $1=\"`$ECHO $2 | $SED 's/:/ /g'`\"
        ;;
    esac
}


# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
func_cc_basename ()
{
    for cc_temp in $*""; do
      case $cc_temp in
        compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
        distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
        \-*) ;;
        *) break;;
      esac
    done
    func_cc_basename_result=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
}


# ### END FUNCTIONS SHARED WITH CONFIGURE

_LT_EOF

  case $host_os in
  aix3*)
    cat <<\_LT_EOF >> "$cfgfile"
# AIX sometimes has problems with the GCC collect2 program.  For some
# reason, if we set the COLLECT_NAMES environment variable, the problems
# vanish in a puff of smoke.
if test set != "${COLLECT_NAMES+set}"; then
  COLLECT_NAMES=
  export COLLECT_NAMES
fi
_LT_EOF
    ;;
  esac


ltmain=$ac_aux_dir/ltmain.sh


  # We use sed instead of cat because bash on DJGPP gets confused if
  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
  # text mode, it properly converts lines to CR/LF.  This bash problem
  # is reportedly fixed, but why not run on old versions too?
  sed '$q' "$ltmain" >> "$cfgfile" \
     || (rm -f "$cfgfile"; exit 1)

   mv -f "$cfgfile" "$ofile" ||
    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
  chmod +x "$ofile"


    cat <<_LT_EOF >> "$ofile"

# ### BEGIN LIBTOOL TAG CONFIG: CXX

# The linker used to build libraries.
LD=$lt_LD_CXX

# How to create reloadable object files.
reload_flag=$lt_reload_flag_CXX
reload_cmds=$lt_reload_cmds_CXX

# Commands used to build an old-style archive.
old_archive_cmds=$lt_old_archive_cmds_CXX

# A language specific compiler.
CC=$lt_compiler_CXX

# Is the compiler the GNU compiler?
with_gcc=$GCC_CXX

# Compiler flag to turn off builtin functions.
no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_CXX

# Additional compiler flags for building library objects.
pic_flag=$lt_lt_prog_compiler_pic_CXX

# How to pass a linker flag through the compiler.
wl=$lt_lt_prog_compiler_wl_CXX

# Compiler flag to prevent dynamic linking.
link_static_flag=$lt_lt_prog_compiler_static_CXX

# Does compiler simultaneously support -c and -o options?
compiler_c_o=$lt_lt_cv_prog_compiler_c_o_CXX

# Whether or not to add -lc for building shared libraries.
build_libtool_need_lc=$archive_cmds_need_lc_CXX

# Whether or not to disallow shared libs when runtime libs are static.
allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_CXX

# Compiler flag to allow reflexive dlopens.
export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_CXX

# Compiler flag to generate shared objects directly from archives.
whole_archive_flag_spec=$lt_whole_archive_flag_spec_CXX

# Whether the compiler copes with passing no objects directly.
compiler_needs_object=$lt_compiler_needs_object_CXX

# Create an old-style archive from a shared archive.
old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_CXX

# Create a temporary old-style archive to link instead of a shared archive.
old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_CXX

# Commands used to build a shared archive.
archive_cmds=$lt_archive_cmds_CXX
archive_expsym_cmds=$lt_archive_expsym_cmds_CXX

# Commands used to build a loadable module if different from building
# a shared archive.
module_cmds=$lt_module_cmds_CXX
module_expsym_cmds=$lt_module_expsym_cmds_CXX

# Whether we are building with GNU ld or not.
with_gnu_ld=$lt_with_gnu_ld_CXX

# Flag that allows shared libraries with undefined symbols to be built.
allow_undefined_flag=$lt_allow_undefined_flag_CXX

# Flag that enforces no undefined symbols.
no_undefined_flag=$lt_no_undefined_flag_CXX

# Flag to hardcode \$libdir into a binary during linking.
# This must work even if \$libdir does not exist
hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX

# Whether we need a single "-rpath" flag with a separated argument.
hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX

# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
# DIR into the resulting binary.
hardcode_direct=$hardcode_direct_CXX

# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
# DIR into the resulting binary and the resulting library dependency is
# "absolute",i.e impossible to change by setting \$shlibpath_var if the
# library is relocated.
hardcode_direct_absolute=$hardcode_direct_absolute_CXX

# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
# into the resulting binary.
hardcode_minus_L=$hardcode_minus_L_CXX

# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
# into the resulting binary.
hardcode_shlibpath_var=$hardcode_shlibpath_var_CXX

# Set to "yes" if building a shared library automatically hardcodes DIR
# into the library and all subsequent libraries and executables linked
# against it.
hardcode_automatic=$hardcode_automatic_CXX

# Set to yes if linker adds runtime paths of dependent libraries
# to runtime path list.
inherit_rpath=$inherit_rpath_CXX

# Whether libtool must link a program against all its dependency libraries.
link_all_deplibs=$link_all_deplibs_CXX

# Set to "yes" if exported symbols are required.
always_export_symbols=$always_export_symbols_CXX

# The commands to list exported symbols.
export_symbols_cmds=$lt_export_symbols_cmds_CXX

# Symbols that should not be listed in the preloaded symbols.
exclude_expsyms=$lt_exclude_expsyms_CXX

# Symbols that must always be exported.
include_expsyms=$lt_include_expsyms_CXX

# Commands necessary for linking programs (against libraries) with templates.
prelink_cmds=$lt_prelink_cmds_CXX

# Commands necessary for finishing linking programs.
postlink_cmds=$lt_postlink_cmds_CXX

# Specify filename containing input files.
file_list_spec=$lt_file_list_spec_CXX

# How to hardcode a shared library path into an executable.
hardcode_action=$hardcode_action_CXX

# The directories searched by this compiler when creating a shared library.
compiler_lib_search_dirs=$lt_compiler_lib_search_dirs_CXX

# Dependencies to place before and after the objects being linked to
# create a shared library.
predep_objects=$lt_predep_objects_CXX
postdep_objects=$lt_postdep_objects_CXX
predeps=$lt_predeps_CXX
postdeps=$lt_postdeps_CXX

# The library search path used internally by the compiler when linking
# a shared library.
compiler_lib_search_path=$lt_compiler_lib_search_path_CXX

# ### END LIBTOOL TAG CONFIG: CXX
_LT_EOF

 ;;

  esac
done # for ac_tag


as_fn_exit 0
_ACEOF
ac_clean_files=$ac_clean_files_save

test $ac_write_fail = 0 ||
  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5


# configure is writing to config.log, and then calls config.status.
# config.status does its own redirection, appending to config.log.
# Unfortunately, on DOS this fails, as config.log is still kept open
# by configure, so config.status won't be able to write to it; its
# output is simply discarded.  So we exec the FD to /dev/null,
# effectively closing config.log, so it can be properly (re)opened and
# appended to by config.status.  When coming back to configure, we
# need to make the FD available again.
if test "$no_create" != yes; then
  ac_cs_success=:
  ac_config_status_args=
  test "$silent" = yes &&
    ac_config_status_args="$ac_config_status_args --quiet"
  exec 5>/dev/null
  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
  exec 5>>config.log
  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
  # would make configure fail if this is the last instruction.
  $ac_cs_success || as_fn_exit 1
fi
if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
fi

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/configure.ac                                0100644 0001750 0001750 00000021702 12612724206 022730  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        AC_INIT([cctools], [877.5], [t.poechtrager@gmail.com])

AC_CANONICAL_BUILD
AC_CANONICAL_HOST
AC_CANONICAL_TARGET

AC_ARG_PROGRAM

AM_CONDITIONAL([ISDARWIN], [false])

isdarwin=no
iscygwin=no

if test "x$CFLAGS" = "x"; then
  CFLAGS="-O3"
fi

if test "x$CXXFLAGS" = "x"; then
  CXXFLAGS="-O3"
fi

if test "x$OBJCFLAGS" = "x"; then
  OBJCFLAGS="-O3"
fi

CXXFLAGS="$CXXFLAGS -std=c++0x"

if test "x$build" = "x$host"; then
  CFLAGS="$CFLAGS -isystem /usr/local/include -isystem /usr/pkg/include"
  CXXFLAGS="$CXXFLAGS -isystem /usr/local/include -isystem /usr/pkg/include"
  LDFLAGS="$LDFLAGS -L/usr/local/lib -L/usr/pkg/lib"
fi

CWARNINGS=""
OBJCWARNINGS=""
CXXWARNINGS=""
EXTRAFLAGS=""
EXTRACXXFLAGS=""
WARNINGS=""

case $host_os in
  darwin* )
    isdarwin=yes
    AM_CONDITIONAL([ISDARWIN], [true])
  ;;
  openbsd* )
    XCC="egcc"
    XCXX="eg++"
  ;;
  cygwin* )
    iscygwin=yes
    EXTRAFLAGS="-D__LARGE64_FILES -fno-PIC"
    WARNINGS="-Wno-attributes"
    XCC="gcc"
    XCXX="g++"
  ;;
esac

if test "x$isdarwin" = "xno"; then
  case $host_cpu in
    arm* )
      # clang miscompiles ld64 on arm
      if test "x$isdarwin" = "xno"; then
        XCC="gcc"
        XCXX="g++"
      fi
    ;;
  esac
fi

if test "x$XCC" = "x"; then
  XCC="clang"
fi

if test "x$XCXX" = "x"; then
  XCXX="clang++"
fi

if test "x$CC" = "x"; then
  if test "x$build" != "x$host"; then
    CC="${host_alias}-${XCC}"
    which $CC 2>/dev/null 1>&2
    if test $? -ne 0; then
      CC="${host_alias}-gcc"
    fi
   else
    CC=$XCC
    which $CC 2>/dev/null 1>&2
    if test $? -ne 0; then
      CC="gcc"
    fi
  fi
fi

if test "x$CXX" = "x"; then
  if test "x$build" != "x$host"; then
    CXX="${host_alias}-${XCXX}"
    which $CXX 2>/dev/null 1>&2
    if test $? -ne 0; then
      CXX="${host_alias}-g++"
    fi
  else
    CXX=$XCXX
    which $CXX 2>/dev/null 1>&2
    if test $? -ne 0; then
      CXX="g++"
    fi
  fi
fi

CCVERSION="`$CC --version`"
CXXVERSION="`$CXX --version`"

case "$CCVERSION" in
  *clang* )
    WARNINGS="$WARNINGS -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable"
    WARNINGS="$WARNINGS -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof"
    WARNINGS="$WARNINGS -Wno-int-conversion -Wno-char-subscripts"
    OBJCWARNINGS="-Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage"
  ;;
  * )
    WARNINGS="$WARNINGS -Wall -Wno-format -Wno-enum-compare -Wno-unused-result -Wno-unused-variable"
    WARNINGS="$WARNINGS -Wno-unused-but-set-variable -Wno-deprecated -Wno-deprecated-declarations"
    WARNINGS="$WARNINGS -Wno-char-subscripts -Wno-strict-aliasing"
    OBJCWARNINGS="-Wall"
    CFLAGS="$CFLAGS -std=gnu99 -D__private_extern__="
    CXXFLAGS="$CXXFLAGS -D__private_extern__="
  ;;
esac

case "$CXXVERSION" in
  *clang* )
    if test "x$isdarwin" = "xyes"; then
      CXXFLAGS="$CXXFLAGS -stdlib=libc++"
    fi
    # can't use -fblocks on cyggwin due to a clang driver bug
    if test "x$iscygwin" = "xno"; then
      EXTRACXXFLAGS="$EXTRACXXFLAGS -fblocks"
    else
      EXTRAFLAGS="$EXTRAFLAGS -integrated-as"
    fi
  ;;
esac

case $host_cpu in
  powerpc)
    EXTRAFLAGS="$EXTRAFLAGS -D__ppc__"
  ;;
  powerpc64*)
    EXTRAFLAGS="$EXTRAFLAGS -D__ppc__ -D__ppc64__"
  ;;
  arm64*|aarch64)
    EXTRAFLAGS="$EXTRAFLAGS -D__arm64__"
  ;;
  arm*)
    case "$CXXVERSION" in
      *clang* )
        echo "" >&2
        echo "clang is known to miscompile ld64 on arm platforms:" >&2
        echo "https://github.com/tpoechtrager/cctools-port/issues/1#issuecomment-59118615" >&2
        if test "x$isdarwin" = "xno"; then
          echo "" >&2
          echo "please use gcc instead;  CC=gcc CXX=g++ ./configure" >&2
          echo "" >&2
          exit 1
        fi
        echo "" >&2
        sleep 2
      ;;
    esac
    EXTRAFLAGS="$EXTRAFLAGS -D__arm__"
  ;;
esac

if test "x$EXTRAFLAGS" != "x"; then
  CFLAGS="$CFLAGS $EXTRAFLAGS"
  OBJCFLAGS="$OBJCFLAGS $EXTRAFLAGS"
  CXXFLAGS="$CXXFLAGS $EXTRAFLAGS"
fi

if test "xEXTRACXXFLAGS" != "x"; then
  CXXFLAGS="$CXXFLAGS $EXTRACXXFLAGS"
fi

CPP="$CC -E"
OBJC="$CC"

# FIXME 'subdir-objects' breaks dependency tracking
AM_INIT_AUTOMAKE([1.10 no-define no-dist-gzip dist-bzip2 tar-ustar subdir-objects no-dependencies])

AC_CONFIG_MACRO_DIR([m4])
AM_MAINTAINER_MODE

AC_PREREQ([2.57])
AC_REVISION([$Revision: 1.37 $])

AC_CONFIG_SRCDIR([APPLE_LICENSE])
LT_PREREQ([2.2.6])
LT_INIT(disable-static)

AC_PROG_INSTALL

AC_PROG_CC([clang])
AC_PROG_CXX([clang++])
AM_PROG_CC_C_O
AC_PROG_OBJC([clang])
AM_PROG_AS([clang])

AC_CHECK_TOOL([HOST_RANLIB], [ranlib], :)
AC_CHECK_TOOL([HOST_AR], [ar], :)

#for libstuff emulated.c
case $target_cpu in
     powerpc)
        AC_DEFINE(EMULATED_HOST_CPU_TYPE, 18, [Emulated CPU type])
        AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 100, [Emulated CPU subtype])
    ;;
     powerpc64*)
        AC_DEFINE(EMULATED_HOST_CPU_TYPE, 16777234, [Emulated CPU type])
        AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 0, [Emulated CPU subtype])
       ;;
     i?86)
        AC_DEFINE(EMULATED_HOST_CPU_TYPE, 7, [Emulated CPU type])
        AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 10, [Emulated CPU subtype])
    ;;
     x86_64|amd64)
        AC_DEFINE(EMULATED_HOST_CPU_TYPE, 16777223, [Emulated CPU type])
        AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 3, [Emulated CPU subtype])
    ;;
     arm64*|aarch64)
        AC_DEFINE(EMULATED_HOST_CPU_TYPE, 16777228, [Emulated CPU type])
        AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 0, [Emulated CPU subtype])
    ;;
     arm*)
        AC_DEFINE(EMULATED_HOST_CPU_TYPE, 12, [Emulated CPU type])
        AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 0, [Emulated CPU subtype])
    ;;
     *)
    AC_MSG_ERROR([Unsupported target $target_cpu])
    ;;
esac

# as reported, some users may use llvm-c/Disassembler.h instead of a local copy in include dir.
# add these macros to avoid compilation failures.

AC_DEFINE(__STDC_LIMIT_MACROS)
AC_DEFINE(__STDC_CONSTANT_MACROS)

AC_SUBST([ASLIBEXECDIR], ['${libexecdir}/as'])

# set PROGRAM PREFIX
if test "$target_alias"; then
  AC_SUBST([PROGRAM_PREFIX], ['${target_alias}-'])
fi

AC_CHECK_LIB([dl],[dlopen],[DL_LIB=-ldl])
AC_SUBST(DL_LIB)

AC_CHECK_LIB([pthread],[pthread_create],[PTHREAD_FLAGS=-pthread])
AC_SUBST(PTHREAD_FLAGS)

AC_CHECK_HEADERS([execinfo.h], [
  AC_CHECK_LIB([execinfo],[backtrace],[EXECINFO_LIB=-lexecinfo])], [])
AC_SUBST(EXECINFO_LIB)

AC_CHECK_LIB([uuid],[uuid_generate_random],[
  AC_CHECK_HEADERS([uuid/uuid.h], [UUID_LIB=-luuid])], [])
AC_SUBST(UUID_LIB)

AC_CHECK_FUNCS([strmode])

### Check for __cxa_demangle in various C++ ABI libs ###

AC_CHECK_LIB([c++abi],[__cxa_demangle],[CXXABI_LIB=-lc++abi],[
  AC_CHECK_LIB([c++],[__cxa_demangle],[CXXABI_LIB=-lc++],[
    AC_CHECK_LIB([supc++],[__cxa_demangle],[CXXABI_LIB=-lsupc++],[
      AC_CHECK_LIB([stdc++],[__cxa_demangle],[CXXABI_LIB=-lstdc++],[exit 1])
    ])
  ])
])

AC_SUBST(CXXABI_LIB)

### Check for supported warning options ###

ORIGCFLAGS=$CFLAGS
CFLAGS="$CFLAGS -Werror -Wno-shift-negative-value"
AC_MSG_CHECKING([whether $CC supports -Wno-shift-negative-value])
AC_COMPILE_IFELSE(
  [AC_LANG_SOURCE([[int dummy;]])],
  [WARNINGS="$WARNINGS -Wno-shift-negative-value"
   AC_MSG_RESULT([yes])],
  [AC_MSG_RESULT([no])]
)
CFLAGS=$ORIGCFLAGS

AC_SUBST([WARNINGS], [$WARNINGS])
AC_SUBST([OBJCWARNINGS], [$OBJCWARNINGS])

### Check for libLTO ###

ORIGLDFLAGS=$LDFLAGS
LDFLAGS="$LDFLAGS -Wl,-rpath,/usr/local/lib,--enable-new-dtags"
AC_MSG_CHECKING([whether ld supports -rpath,<path>,--enable-new-dtags])
AC_LINK_IFELSE(
  [AC_LANG_SOURCE([[int main(){}]])],
  [rpathlink=yes
  AC_MSG_RESULT([yes])],
  [AC_MSG_RESULT([no])]
)
LDFLAGS=$ORIGLDFLAGS

CHECK_LLVM

LDFLAGS="$LDFLAGS $LTO_RPATH"

### Check for libxar ###

if test "x$LLVM_CONFIG" != "xno"; then

AC_CHECK_LIB([xar],[xar_prop_create],[
  AC_CHECK_HEADERS([xar/xar.h], [XAR_LIB=-lxar])], [])
AC_SUBST(XAR_LIB)

fi

### Check whether we want to use clang as assembler ###

AC_ARG_ENABLE([clang-as],
AS_HELP_STRING([--disable-clang-as],
               [do not use clang for assembling]),
[], [enable_clang_as=yes])

if test "x$enable_clang_as" != "xyes"; then
  CFLAGS="$CFLAGS -DDISABLE_CLANG_AS"
fi

### Check endianness ###

AC_C_BIGENDIAN([AC_SUBST([ENDIAN_FLAG],[-D__BIG_ENDIAN__=1])],
      [AC_SUBST([ENDIAN_FLAG],[-D__LITTLE_ENDIAN__=1])])


AC_CONFIG_FILES([Makefile libstuff/Makefile])
AC_CONFIG_FILES([ar/Makefile])
AC_CONFIG_FILES([as/Makefile])
AC_CONFIG_FILES([as/arm/Makefile])
AC_CONFIG_FILES([as/i386/Makefile])
AC_CONFIG_FILES([as/x86_64/Makefile])
AC_CONFIG_FILES([as/ppc/Makefile])
AC_CONFIG_FILES([as/ppc64/Makefile])
#AC_CONFIG_FILES([man/Makefile])
AC_CONFIG_FILES([misc/Makefile])
AC_CONFIG_FILES([otool/Makefile])

if test "x$isdarwin" != "xyes"; then
  AC_CONFIG_FILES([libobjc2/Makefile])
fi

AC_CONFIG_FILES([ld/Makefile])

AC_CONFIG_FILES([ld64/Makefile])
AC_CONFIG_FILES([ld64/src/Makefile])
AC_CONFIG_FILES([ld64/src/3rd/Makefile])
AC_CONFIG_FILES([ld64/src/3rd/BlocksRuntime/Makefile])
AC_CONFIG_FILES([ld64/src/ld/Makefile])
AC_CONFIG_FILES([ld64/src/ld/parsers/Makefile])
AC_CONFIG_FILES([ld64/src/ld/passes/Makefile])
AC_CONFIG_FILES([ld64/src/other/Makefile])

AC_OUTPUT
                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/efitools/                                   0040755 0001750 0001750 00000000000 12612724206 022267  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/efitools/makerelocs.c                       0100644 0001750 0001750 00000034643 12612724206 024567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#include "stuff/bool.h"
#include "stuff/ofile.h"
#include "stuff/errors.h"
#include "stuff/reloc.h"
#include "coff/base_relocs.h"
#include "coff/bytesex.h"
#include "mach-o/x86_64/reloc.h"

/* used by error routines as the name of this program */
char *progname = NULL;

/* used for debugging this program */
static enum bool verbose = FALSE;

/* the bytesex of our target object file and of this host machine */
static enum byte_sex target_byte_sex;
static enum byte_sex host_byte_sex;

/*
 * This is the internal structure that we gather the base relocation in from
 * the Mach-O relocation entries.
 */
struct base_reloc {
    uint64_t addr;
    uint32_t type;
};
struct base_reloc *base_relocs = NULL;
uint32_t nbase_reloc = 0;

static void process(
    struct ofile *ofile,
    char *arch_name,
    void *cookie);
static void gather_base_reloc_info(
    uint32_t addr,
    struct relocation_info *relocs, 
    uint32_t nreloc,
    cpu_type_t cpu_type,
    uint32_t length,
    int macho_reloc_type,
    int base_reloc_type);
static void add_base_reloc(
    uint64_t addr,
    uint32_t type);
static void output_base_relocs(
    char *out);
static int cmp_base_relocs(
    struct base_reloc *x1,
    struct base_reloc *x2);
static void usage(
    void);

/* apple_version is created by the libstuff/Makefile */
extern char apple_version[];
char *version = apple_version;

/*
 * The makerelocs(1) tool makes a file of PECOFF base relocation entries from a 
 * fully linked Mach-O file compiled with dynamic code gen and relocation
 * entries saved (linked with -r).  The file of PECOFF base relocation entries
 * then are put in a Mach-O section called .reloc and is then used with
 * objcopy(1) to convert that Mach-O file into a PECOFF file. The makerelocs(1)
 * program has the current usage:
 *
 *	makerelocs [-v] input_Mach-O output_relocs
 * 
 * Where the -v flag provides verbose output used to debug the this programs
 * creation of the PECOFF base relocation entries.
 *
 * TODO: This code can be used for the basis to replace the makerelocs(1)
 * program from the efitools project.  Its current state is that it works for
 * building the efiboot project and the Bluetooth.efi hardware diag.
 */
int
main(
int argc,
char **argv,
char **envp)
{
    int i;
    char *input, *output;

	progname = argv[0];
	host_byte_sex = get_host_byte_sex();

	input = NULL;
	output = NULL;

	for(i = 1; i < argc; i++){
	    if(strcmp(argv[i], "-v") == 0)
		verbose = TRUE;
	    else if(input == NULL)
		input = argv[i];
	    else if(output == NULL)
		output = argv[i];
	    else
		usage();
	}
	if(input == NULL){
	    warning("no input file specified");
	    usage();
	}
	if(output == NULL){
	    warning("no output file specified");
	    usage();
	}

	ofile_process(input, NULL, 0, FALSE, FALSE, FALSE, FALSE,
		      process, NULL);
	if(errors != 0)
	    return(EXIT_FAILURE);

	/* create the output file */
	output_base_relocs(output);

	if(errors == 0)
	    return(EXIT_SUCCESS);
	else
	    return(EXIT_FAILURE);
}

/*
 * process() is the routine that gets called by ofile_process() to process the
 * object file and gather the info to create the base relocation entries.
 */
static
void
process(
struct ofile *ofile,
char *arch_name,
void *cookie)
{
    uint32_t ncmds, i, j;
    uint64_t addr, first_addr;
    struct load_command *lc;
    struct segment_command *sg;
    struct segment_command_64 *sg64;
    struct section *s;
    struct section_64 *s64;
    enum bool swapped;
    struct relocation_info *relocs;

    struct symtab_command *st;
    struct dysymtab_command *dyst;
    struct nlist *symbols;
    struct nlist_64 *symbols64;

	st = NULL;
	dyst = NULL;
	swapped = host_byte_sex != ofile->object_byte_sex;
	target_byte_sex = ofile->object_byte_sex;
	if(ofile->mh != NULL)
	    ncmds = ofile->mh->ncmds;
	else
	    ncmds = ofile->mh64->ncmds;

	lc = ofile->load_commands;
	for(i = 0; i < ncmds; i++){
	    if(st == NULL && lc->cmd == LC_SYMTAB){
		st = (struct symtab_command *)lc;
	    }
	    else if(dyst == NULL && lc->cmd == LC_DYSYMTAB){
		dyst = (struct dysymtab_command *)lc;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	/* TODO this would be need to to do checking for undefined symbols */
	if(ofile->mh != NULL){
	    symbols = (struct nlist *)(ofile->object_addr + st->symoff);
	    if(swapped)
		swap_nlist(symbols, st->nsyms, host_byte_sex);
	    symbols64 = NULL;
	}
	else{
	    symbols = NULL;
	    symbols64 = (struct nlist_64 *)(ofile->object_addr +st->symoff);
	    if(swapped)
		swap_nlist_64(symbols64, st->nsyms, host_byte_sex);
	}

	first_addr = 0;
	lc = ofile->load_commands;
	for(i = 0; i < ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		if(first_addr == 0)
		    first_addr = sg->vmaddr;
		s = (struct section *)
		      ((char *)sg + sizeof(struct segment_command));
		for(j = 0; j < sg->nsects; j++){
		    relocs = (struct relocation_info *)(ofile->object_addr +
						        s[j].reloff);
		    if(swapped)
			swap_relocation_info(relocs, s[j].nreloc,
					     host_byte_sex);
		    if(ofile->mh_cputype == CPU_TYPE_I386)
			gather_base_reloc_info(s[j].addr, relocs, s[j].nreloc,
				CPU_TYPE_I386, 2, GENERIC_RELOC_VANILLA,
				IMAGE_REL_BASED_HIGHLOW);
		    else if(ofile->mh_cputype == CPU_TYPE_ARM)
			gather_base_reloc_info(s[j].addr, relocs, s[j].nreloc,
				CPU_TYPE_ARM, 2, GENERIC_RELOC_VANILLA,
				IMAGE_REL_BASED_HIGHLOW);
		    else
			fatal("unsupported cputype %d", ofile->mh_cputype);
		    if((s[j].flags & SECTION_TYPE) ==
			S_NON_LAZY_SYMBOL_POINTERS){
			for(addr = s[j].addr;
			    addr < s[j].addr + s[j].size;
			    addr += 4) {
			    add_base_reloc(addr, IMAGE_REL_BASED_HIGHLOW);
			}
		    }
		}
	    }
	    else if(lc->cmd == LC_SEGMENT_64){
		sg64 = (struct segment_command_64 *)lc;
		if(first_addr == 0)
		    first_addr = sg64->vmaddr;
		s64 = (struct section_64 *)
		      ((char *)sg64 + sizeof(struct segment_command_64));
		for(j = 0; j < sg64->nsects; j++){
		    relocs = (struct relocation_info *)(ofile->object_addr +
						        s64[j].reloff);
		    if(swapped)
			swap_relocation_info(relocs, s64[j].nreloc,
					     host_byte_sex);
		    if(ofile->mh_cputype == CPU_TYPE_X86_64)
			gather_base_reloc_info(s64[j].addr, relocs,
			    s64[j].nreloc, CPU_TYPE_X86_64, 3,
			    X86_64_RELOC_UNSIGNED, IMAGE_REL_BASED_DIR64);
		    else
			fatal("unsupported cputype %d", ofile->mh_cputype);
		    if((s64[j].flags & SECTION_TYPE) ==
			S_NON_LAZY_SYMBOL_POINTERS){
			for(addr = s64[j].addr;
			    addr < s64[j].addr + s64[j].size;
			    addr += 8) {
			    add_base_reloc(addr, IMAGE_REL_BASED_DIR64);
			}
		    }
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	if(dyst != NULL && dyst->nlocrel != 0){
	    relocs = (struct relocation_info *)(ofile->object_addr +
						dyst->locreloff);
	    if(swapped)
		swap_relocation_info(relocs, dyst->nlocrel, host_byte_sex);
	    if(ofile->mh_cputype == CPU_TYPE_I386)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_I386, 2, GENERIC_RELOC_VANILLA,
		    IMAGE_REL_BASED_HIGHLOW);
	    if(ofile->mh_cputype == CPU_TYPE_ARM)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_ARM, 2, GENERIC_RELOC_VANILLA,
		    IMAGE_REL_BASED_HIGHLOW);
	    else if(ofile->mh_cputype == CPU_TYPE_X86_64)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_X86_64, 3, X86_64_RELOC_UNSIGNED,
		    IMAGE_REL_BASED_DIR64);
	    else
		fatal("unsupported cputype %d", ofile->mh_cputype);
	}
	if(dyst != NULL && dyst->nextrel != 0)
	    fatal("input Mach-O file has external relocation entries");
}

/*
 * gather_base_reloc_info() is passed the base address for the set of Mach-O
 * relocation entries. And is passed the cpu_type, length and macho_reloc_type
 * to look for and the base_reloc_type to create if found.
 */
static
void
gather_base_reloc_info(
uint32_t addr,
struct relocation_info *relocs, 
uint32_t nreloc,
cpu_type_t cpu_type,
uint32_t length,
int macho_reloc_type,
int base_reloc_type)
{
    uint32_t i, r_address, r_pcrel, r_length, r_extern, r_type;
    struct scattered_relocation_info *sreloc;

	for(i = 0; i < nreloc; i++){
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_type = (enum reloc_type_generic)sreloc->r_type;
		r_extern = 0;
	    }
	    else{
		r_address = relocs[i].r_address;
		r_pcrel = relocs[i].r_pcrel;
		r_length = relocs[i].r_length;
		r_extern = relocs[i].r_extern;
		r_type = (enum reloc_type_generic)relocs[i].r_type;
	    }

	    if(r_extern == 0 && r_pcrel == 0 &&
	       r_length == length && r_type == macho_reloc_type)
		add_base_reloc(addr + r_address, base_reloc_type);
	    else
	    	; /* TODO add checking and error messages here */

	    if((relocs[i].r_address & R_SCATTERED) == 0){
		if(reloc_has_pair(cpu_type, relocs[i].r_type))
		    i++;
	    }
	    else{
		sreloc = (struct scattered_relocation_info *)relocs + i;
		if(reloc_has_pair(cpu_type, sreloc->r_type))
		    i++;
	    }
	}
}

/*
 * add_base_reloc() is passed a addr and a type for a base relocation entry to
 * add to the list.
 */
static
void
add_base_reloc(
uint64_t addr,
uint32_t type)
{
    static int max = 0;
    struct base_reloc *new_base_relocs;
    
	if(!max){
	    max = 128;
	    base_relocs = (struct base_reloc *)
			  malloc(max * sizeof(struct base_reloc));
	}
	if(nbase_reloc >= max){
	    new_base_relocs = malloc(2 * max * sizeof(struct base_reloc));
	    memcpy(new_base_relocs, base_relocs,
		   max * sizeof(struct base_reloc));
	    max *= 2;
	    free(base_relocs);
	    base_relocs = new_base_relocs;
	}
	base_relocs[nbase_reloc].addr = addr;
        base_relocs[nbase_reloc].type = type;
	nbase_reloc++;
}

/*
 * usage() prints the current usage message and exits indicating failure.
 */
static
void
usage(
void)
{
	fprintf(stderr, "Usage: %s [-v] input_Mach-O output_relocs\n",
		progname);
	exit(EXIT_FAILURE);
}

/*
 * The base relocation table in a PECOFF file is divided into blocks. Each
 * block represents the base relocations for a 4K page. Each block must start
 * on a 32-bit boundary.  Which is why one "nop" base relocation entry may be
 * be added as padding in a block.
 */
#define MAX_BLOCK_OFFSET 0x1000
#define BLOCK_MASK (MAX_BLOCK_OFFSET-1)

/*
 * output_base_relocs() takes the info for the base relocation entries gathered
 * and outputs the fixup blocks as they would be in a PECOFF file in to the
 * specified file name.
 */
static
void
output_base_relocs(
char *out)
{
    int blockcnt;
    int i, entries;
    uint64_t base;
    int size;
    char *fb;
    struct base_relocation_block_header *h;
    struct base_relocation_entry *b;
    int f;
    uint32_t offset;
    enum bool swapped;
	
	blockcnt = 0;
	swapped = host_byte_sex != target_byte_sex;

	if(nbase_reloc == 0)
	    goto done;
	
	qsort(base_relocs, nbase_reloc, sizeof(struct base_reloc),
	      (int (*)(const void *, const void *))cmp_base_relocs);
	
	/*
	 * The size of the base relocation tables must be a multiple of 4 bytes.
	 * so we may need to add one relocation entry as padding.  We make this
	 * fixup block large enought to hold all the base relocation entries.
	 * But it will be broken up for the base relocation entries for each
	 * each group that refers to the same 4K page.
	 */
	size = sizeof(struct base_relocation_block_header) +
	       (nbase_reloc + 1) * sizeof(struct base_relocation_entry);
	fb = malloc(size);
	
	f = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644);
	if(f == -1){
	    fatal("open output file");
	}
	
	entries = 0;
	base = base_relocs[0].addr & ~BLOCK_MASK;
	h = (struct base_relocation_block_header *)fb;
	b = (struct base_relocation_entry *)
	    (fb + sizeof(struct base_relocation_block_header));
	for(i = 0; i < nbase_reloc; i++){
	    offset = base_relocs[i].addr - base;
	    if(offset >= MAX_BLOCK_OFFSET) {
		/* add padding if needed */
		if((entries % 2) != 0){
		    b[entries].type = IMAGE_REL_BASED_ABSOLUTE;
		    b[entries].offset = 0;
		    entries++;
		}
		h->page_rva = base;
		size = sizeof(struct base_relocation_block_header) +
		       entries * sizeof(struct base_relocation_entry);
		h->block_size = size;
		if(swapped){
		    swap_base_relocation_block_header(h,
						      target_byte_sex);
		    swap_base_relocation_entry(b, entries,
					       target_byte_sex);
		}
		// write out the block then start a new one
		write(f, fb, size);

		entries = 0;
		blockcnt++;
		base = base_relocs[i].addr & ~BLOCK_MASK;
		offset = base_relocs[i].addr - base;
	    }
	    b[entries].type = base_relocs[i].type;
	    b[entries].offset = offset;
	    entries++;
	}
	
	/* add padding if needed */
	if((entries % 2) != 0){
	    b[entries].type = IMAGE_REL_BASED_ABSOLUTE;
	    b[entries].offset = 0;
	    entries++;
	}
	h->page_rva = base;
	size = sizeof(struct base_relocation_block_header) +
	       entries * sizeof(struct base_relocation_entry);
	h->block_size = size;
	if(swapped){
	    swap_base_relocation_block_header(h, target_byte_sex);
	    swap_base_relocation_entry(b, entries, target_byte_sex);
	}
	/* write out the last block */
	write(f, fb, size);

	blockcnt++;
	close(f);
done:
	printf("wrote %d relocations in %d block%s\n", nbase_reloc, blockcnt,
	       blockcnt == 1 ? "" : "s");
}

static
int
cmp_base_relocs(
struct base_reloc *x1,
struct base_reloc *x2)
{
	if(x1->addr < x2->addr)
	    return(-1);
	if(x1->addr == x2->addr)
	    return(0);
	/* x1->addr > x2->addr */
	    return(1);
}
                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/efitools/mtoc.c                             0100644 0001750 0001750 00000226044 12612724206 023402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#define __eip eip
#define __rip rip

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#include "stuff/breakout.h"
#include "stuff/errors.h"
#include "stuff/allocate.h"
#include "stuff/reloc.h"
#include "stuff/rnd.h"

#include "coff/ms_dos_stub.h"
#include "coff/filehdr.h"
#include "coff/aouthdr.h"
#include "coff/scnhdr.h"
#include "coff/syment.h"
#include "coff/bytesex.h"

#include "coff/base_relocs.h"
#include "mach-o/x86_64/reloc.h"
#include "mach-o/arm64/reloc.h"

/* used by error routines as the name of this program */
char *progname = NULL;

/* the bytesex of our target object file and of this host machine */
static enum byte_sex target_byte_sex;
static enum byte_sex host_byte_sex;
static enum bool swapped;

/* the size of the pecoff output file */
static uint32_t output_size = 0;

/*
 * The headers, and elements of them in the pecoff output file.
 */
static struct ms_dos_stub ms_dos_stub;
static char signature[4];
static struct filehdr filehdr;
static struct aouthdr aouthdr;
static struct aouthdr_64 aouthdr64;
uint32_t entry = 0; /* the entry point */
uint32_t nscns = 0; /* the number of section headers and contents pointers */
static struct scnhdr *scnhdrs = NULL;  /* the section headers */
static char **scn_contents = NULL; /* pointers to the section contents */

/*
 * The value of the -subsystem argument to then set in the PECOFF aouthdr.
 */
static uint16_t Subsystem = IMAGE_SUBSYSTEM_EFI_APPLICATION;

struct subsystem_argument {
    char *name;
    uint16_t value;
};

struct subsystem_argument subsystem_arguments[] = {
    { "application",		IMAGE_SUBSYSTEM_EFI_APPLICATION },
    { "app",			IMAGE_SUBSYSTEM_EFI_APPLICATION },
    { "UEFI_APPLICATION",	IMAGE_SUBSYSTEM_EFI_APPLICATION },
    { "APPLICATION",	        IMAGE_SUBSYSTEM_EFI_APPLICATION },

    { "boot",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "bsdrv",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "DXE_DRIVER",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "SEC",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "peim",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "BASE",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "PEI_CORE",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "PEIM",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "DXE_SMM_DRIVER",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "TOOL",			IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "USER_DEFINED",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "UEFI_DRIVER",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "DXE_CORE",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "SECURITY_CORE",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "COMBINED_PEIM_DRIVER",	IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "PIC_PEIM",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "RELOCATABLE_PEIM",	IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "BS_DRIVER",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
    { "SMM_CORE",		IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },

    { "runtime",		IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER },
    { "rtdrv",			IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER },
    { "DXE_RUNTIME_DRIVER",	IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER },

    { NULL, 0 }
};

/*
 * The value of the -section_alignment argument (or the -align argument) to
 * layout the added PECOFF sections and set into the PECOFF aouthdr.
 */
static uint32_t section_alignment = SECTIONALIGNMENT;

/*
 * The value of the -align argument to layout the PECOFF file.
 */
static uint32_t file_alignment = FILEALIGNMENT;

/* The maximum alignment allowed to be specified, in hex */
#define MAXALIGN		0x8000

/* Static routine to help parse arguments */
static enum bool ispoweroftwo(uint32_t x);

/*
 * The string for the -d argument.
 */
char *debug_filename = NULL;

/*
 * The string for the -u argument.
 */
char *debug_uuid = NULL;

/*
 * Format specifier for scanf() to convert UUID to individual bytes
 */
#define UUID_FORMAT_STRING "%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx"

/*
 * The string for the entry point symbol name.
 */
char *entry_point = NULL;

#ifdef HACK_TO_MATCH_TEST_CASE
/*
 * These are are used for the HACK to get the symbol table for 32-bit files to
 * match the one produced by objcopy.  They are the pecoff section numbers of
 * the .common and .bss sections.
 */
static uint32_t common_scnum = 0;
static uint32_t bss_scnum = 0;
#endif

/*
 * These are for the .reloc section that contains the base relocations.
 */
static struct scnhdr *reloc_scnhdr = NULL;
static uint32_t reloc_size = 0;
static char *reloc_contents = NULL;

/*
 * These are for the pecoff symbol table and string table.
 */
static uint32_t nsyments = 0;		/* number of symbols */
static struct syment *syments = NULL;	/* pointer to symbol table elements */
static uint32_t syment_offset = 0;	/* file offset of the symbol table */
static uint32_t strsize = 0;		/* size of the string table */
static char *strings = NULL;		/* pointer to the string table */
static uint32_t section_names_size = 0;	/* size of the section names */
static char *section_names = NULL;	/* pointer to section names */
static uint32_t string_offset = 0;	/* file offset of the string table */

/*
 * These are for the .debug section that contains the -d filename information.
 */
static struct scnhdr *debug_scnhdr = NULL;
static uint32_t debug_size = 0;
static char *debug_contents = NULL;
static struct debug_directory_entry *dde = NULL;
static struct mtoc_debug_info *mdi = NULL;

static void process_arch(
    struct arch *archs,
    uint32_t narchs);
static void process_32bit_arch(
    struct arch *arch);
static void process_64bit_arch(
    struct arch *arch);
static void layout_output(
    struct ofile *ofile);
static void create_output(
    struct ofile *ofile,
    char *out);
static void create_ms_dos_stub(
    struct ms_dos_stub *p);
static void usage(
    void);

static void create_32bit_symbol_table(
    struct arch *arch);
static void create_64bit_symbol_table(
    struct arch *arch);

/*
 * This is the internal structure that we gather the base relocation in from
 * the Mach-O relocation entries.
 */
struct base_reloc {
    uint64_t addr;
    uint32_t type;
};
struct base_reloc *base_relocs = NULL;
uint32_t nbase_reloc = 0;

static void create_base_reloc(
    struct arch *arch);
static void gather_base_reloc_info(
    uint32_t addr,
    struct relocation_info *relocs, 
    uint32_t nreloc,
    cpu_type_t cpu_type,
    uint32_t length,
    int macho_reloc_type,
    int base_reloc_type);
static void add_base_reloc(
    uint64_t addr,
    uint32_t type);
static void make_base_relocs(
    void);
static int cmp_base_relocs(
    struct base_reloc *x1,
    struct base_reloc *x2);
static uint32_t checksum(
    unsigned char *buf);
static void string_to_uuid(
    char *string,
    uint8_t *uuid);

static void create_debug(
    struct arch *arch);
static void set_debug_addrs_and_offsets(
    void);

/* apple_version is created by the libstuff/Makefile */
extern char apple_version[];
char *version = apple_version;

/*
 * The mtoc(1) tool makes a PECOFF file from a fully linked Mach-O file
 * compiled with dynamic code gen and relocation entries saved (linked with -r).
 *
 *	mtoc [-subsystem type] [-section_alignment hexvalue] [-align hexvalue]
 *	     [-d filename] input_Mach-O output_pecoff
 */
int
main(
int argc,
char **argv,
char **envp)
{
    int i, j;
    char *input, *output;
    struct ofile *ofile;
    struct arch *archs;
    uint32_t narchs;
    char *endp;
    enum bool section_alignment_specified, align_specified;

	progname = argv[0];
	host_byte_sex = get_host_byte_sex();

	input = NULL;
	output = NULL;

	section_alignment_specified = FALSE;
	align_specified = FALSE;

	for(i = 1; i < argc; i++){
	    if(strcmp(argv[i], "-subsystem") == 0){
		if(i + 1 >= argc){
		    warning("no argument specified for -subsystem option");
		    usage();
		}
		for(j = 0; subsystem_arguments[j].name != NULL; j++){
		    if(strcmp(argv[i+1], subsystem_arguments[j].name) == 0){
			Subsystem = subsystem_arguments[j].value;
			break;
		    }
		}
		if(subsystem_arguments[j].name == NULL){
		    warning("unknown argument: %s specified for -subsystem "
			    "argument can be:", argv[i+1]);
		    for(j = 0; subsystem_arguments[j].name != NULL; j++)
			fprintf(stderr, "%s\n", subsystem_arguments[j].name);
		    usage();
		}
		i++;
	    }
	    else if(strcmp(argv[i], "-d") == 0){
		if(i + 1 >= argc){
		    warning("no argument specified for -d option");
		    usage();
		}
		debug_filename = argv[i+1];
		i++;
	    }
	    else if(strcmp(argv[i], "-e") == 0){
		if(i + 1 >= argc){
		    warning("no argument specified for -e option");
		    usage();
		}
		entry_point = argv[i+1];
		i++;
	    }
	    else if(strcmp(argv[i], "-u") == 0){
		if(i + 1 >= argc){
		    warning("no argument specified for -u option");
		    usage();
		}
		if(debug_filename == NULL) {
		    fatal("-u option requires -d option");
		}
		debug_uuid = argv[i+1];
		i++;
	    }
	    else if(strcmp(argv[i], "-section_alignment") == 0){
		if(i + 1 >= argc){
		    warning("no argument specified for -section_alignment "
			    "option");
		    usage();
		}
		section_alignment = strtoul(argv[i+1], &endp, 16);
		if(*endp != '\0')
		    fatal("argument for -section_alignment %s not a proper "
			  "hexadecimal number", argv[i+1]);
		if(!ispoweroftwo(section_alignment) || section_alignment == 0)
		    fatal("argument to -section_alignment: %x (hex) must be a "
			  "non-zero power of two", section_alignment);
		if(section_alignment > MAXALIGN)
		    fatal("argument to -section_alignment: %x (hex) must "
			  "equal to or less than %x (hex)", section_alignment,
			  (unsigned int)MAXALIGN);
		section_alignment_specified = TRUE;
		if(align_specified == TRUE &&
		   section_alignment != file_alignment)
		    fatal("can't specifiy a -section_alignment value %x (hex) "
			  "different from the -align value %x (hex)",
			  section_alignment, file_alignment);
		i++;
	    }
	    else if(strcmp(argv[i], "-align") == 0){
		if(i + 1 >= argc){
		    warning("no argument specified for -align option");
		    usage();
		}
		file_alignment = strtoul(argv[i+1], &endp, 16);
		if(*endp != '\0')
		    fatal("argument for -align %s not a proper hexadecimal "
			  "number", argv[i+1]);
		if(!ispoweroftwo(file_alignment) || file_alignment == 0)
		    fatal("argument to -align: %x (hex) must be a non-zero "
			  "power of two", file_alignment);
		if(file_alignment > MAXALIGN)
		    fatal("argument to -file_alignment: %x (hex) must "
			  "equal to or less than %x (hex)", file_alignment,
			  (unsigned int)MAXALIGN);
		align_specified = TRUE;
		if(section_alignment_specified == TRUE &&
		   section_alignment != file_alignment)
		    fatal("can't specifiy a -section_alignment value %x (hex) "
			  "different from the -align value %x (hex)",
			  section_alignment, file_alignment);
		section_alignment = file_alignment;
		i++;
	    }
	    else if(input == NULL)
		input = argv[i];
	    else if(output == NULL)
		output = argv[i];
	    else
		usage();
	}
	if(input == NULL){
	    warning("no input file specified");
	    usage();
	}
	if(output == NULL){
	    warning("no output file specified");
	    usage();
	}

	/* breakout the file for processing */
	ofile = breakout(input, &archs, &narchs, FALSE);
	if(errors)
	    return(EXIT_FAILURE);

	/* checkout the file for symbol table replacement processing */
	checkout(archs, narchs);

	/* process the input file */
	process_arch(archs, narchs);
	if(errors){
	    free_archs(archs, narchs);
	    ofile_unmap(ofile);
	    return(EXIT_FAILURE);
	}

	/*
	 * Layout the pecoff output file from the information gathered from
	 * the input file creating the needed headers, relocs, etc.
	 */
	layout_output(ofile);

	create_output(ofile, output);

	if(errors == 0)
	    return(EXIT_SUCCESS);
	else
	    return(EXIT_FAILURE);
}

/*
 * usage() prints the current usage message and exits indicating failure.
 */
static
void
usage(
void)
{
	fprintf(stderr, "Usage: %s [-subsystem type] "
		"[-section_alignment hexvalue] [-align hexvalue] [-d debug_filename] "
		"[-u debug_guid] input_Mach-O output_pecoff\n", progname);
	exit(EXIT_FAILURE);
}

/*
 * ispoweroftwo() returns TRUE or FALSE depending if x is a power of two.
 */
static
enum
bool
ispoweroftwo(
uint32_t x)
{
	if(x == 0)
	    return(TRUE);
	while((x & 0x1) != 0x1){
	    x >>= 1;
	}
	if((x & ~0x1) != 0)
	    return(FALSE);
	else
	    return(TRUE);
}

/*
 * process_arch() is the routine that process the broken out ofile to gather
 * the info to create the pecoff file.  This routine basically counts and adds
 * up the sizes of the elements that will be in the pecoff output file.
 */
static
void
process_arch(
struct arch *archs,
uint32_t narchs)
{
	/*
	 * Check to see the input file is something this program can convert to
	 * a pecoff file.
	 */
	if(narchs != 1)
	    fatal("input file: %s must only have one architecture",
		  archs->file_name);
	if(archs->type != OFILE_Mach_O)
	    fatal("input file: %s must be a Mach-O file", archs->file_name);
	if(archs->object->mh_cputype != CPU_TYPE_I386 &&
	   archs->object->mh_cputype != CPU_TYPE_ARM &&
	   archs->object->mh_cputype != CPU_TYPE_ARM64 &&
	   archs->object->mh_cputype != CPU_TYPE_X86_64)
	    fatal("input file: %s must be an i386 or ARM architecture",
		  archs->file_name);
	if(archs->object->mh != NULL){
	    if(archs->object->mh->filetype == MH_PRELOAD ||
	       (archs->object->mh->filetype == MH_EXECUTE &&
		(archs->object->mh->flags & MH_PIE) == MH_PIE)){
		if(entry_point != NULL)
		    fatal("entry point option, -e %s, not allowed with "
			  "MH_PRELOAD or MH_EXECUTE file types", entry_point);
	    }
	    else{
		fatal("input file: %s must be an MH_PRELOAD file type or "
		      "MH_EXECUTE file type with MH_PIE flag",
		      archs->file_name);
	    }
	}
	else{
	    if(archs->object->mh64->filetype == MH_DYLIB ||
	       (archs->object->mh64->filetype == MH_EXECUTE &&
		(archs->object->mh64->flags & MH_PIE) == MH_PIE)){
		if(entry_point == NULL &&
		   archs->object->mh64->filetype == MH_DYLIB)
		    fatal("input file: %s is a MH_DYLIB file type, so entry "
			  "point option, -e name, must be specified", 
			  archs->file_name);
	    }
	    else if(archs->object->mh64->filetype == MH_PRELOAD ||
		    (archs->object->mh64->filetype == MH_EXECUTE &&
		     (archs->object->mh64->flags & MH_PIE) == MH_PIE)){
		if(entry_point != NULL)
		    fatal("entry point option, -e %s, not allowed with "
		          "MH_PRELOAD or MH_EXECUTE file types",
			  archs->file_name);
	    }
	    else
		fatal("input file: %s must be an MH_PRELOAD or MH_DYLIB file "
		      "type or MH_EXECUTE file type with MH_PIE flag",
		      archs->file_name);
	}

	target_byte_sex = archs->object->object_byte_sex;
	swapped = host_byte_sex != target_byte_sex;

	/*
	 * Create base relocation entries for this Mach-O file.  This is done
	 * before the sections are created as this produces the contents for
	 * the .reloc section and determines it size.
	 */
	create_base_reloc(archs);

	/*
	 * If there is a -d flag create the information that will be in .debug
	 * section for it.
	 */
	if(debug_filename != NULL)
	    create_debug(archs);

	if(archs->object->mh != NULL)
	    process_32bit_arch(archs);
	else
	    process_64bit_arch(archs);
}

/*
 * process_32bit_arch() is the routine that processes a 32-bit broken out ofile
 * to gather the info to create the pecoff file.  This routine basically counts
 * and adds up the sizes of the elements that will be in the pecoff output file.
 */
static
void
process_32bit_arch(
struct arch *arch)
{
    uint32_t i, j, reloc_addr, debug_addr;
    struct load_command *lc;
    struct segment_command *sg;
    struct thread_command *ut;
    char *p, *state;
    uint32_t flavor, count;
    char *object_addr, *section_name;
#ifdef HACK_TO_MATCH_TEST_CASE
    uint32_t len;
    struct section *s;
#endif

	/*
	 * Determine the number of sections in the pecoff output file.
	 * 
#ifdef HACK_TO_MATCH_TEST_CASE
	 *
	 * The hack implementation of this routine is done to match the
	 * current ld_efi(1) script that uses objcopy(1) to make the pecoff
	 * file.  So for 32-bit file the contents of the Mach-O file gets
	 * placed into pecoff sections as follows:
	 *
	 * the entire __TEXT segment becomes the .text section
	 * the entire __DATA segment becomes the .data section
	 * the zero fill section (__DATA,__common) becomes .common
	 * the zero fill section (__DATA,__bss) becomes .bss
	 * the (__IMPORT,__pointers) section becomes .pointers
	 * the base relocation entries go into the .reloc section
	 *
#else
	 *
	 * The whole Mach-O segments __TEXT, __DATA and __IMPORT are placed in
	 * the pecoff file from the Mach-O file.  And then the .reloc section
	 * added for the base relocations.
	 *
#endif
	 */
	nscns = 0;
	reloc_addr = 0;
	lc = arch->object->load_commands;
	for(i = 0; i < arch->object->mh->ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		if(strcmp(sg->segname, SEG_LINKEDIT) != 0 &&
		   sg->vmaddr + sg->vmsize > reloc_addr)
		    reloc_addr = sg->vmaddr + sg->vmsize;
		if(strcmp(sg->segname, SEG_TEXT) == 0)
		    nscns++;
		else if(strcmp(sg->segname, SEG_DATA) == 0){
		    nscns++;
#ifdef HACK_TO_MATCH_TEST_CASE
		    s = (struct section *)
			 ((char *)sg + sizeof(struct segment_command));
		    for(j = 0; j < sg->nsects; j++, s++){
			if(strcmp(s->sectname, SECT_COMMON) == 0 ||
			   strcmp(s->sectname, SECT_BSS) == 0){
			    nscns++;
			}
			else if(s->size != 0 &&
				strcmp(s->sectname, SECT_DATA) != 0)
			    fatal("input file: %s contains Mach-O section "
				  "(%.16s,%.16s) unsupported for conversion "
				  "to a pecoff file", arch->file_name,
				  s->segname, s->sectname);
		    }
#endif /* HACK_TO_MATCH_TEST_CASE */
		}
		else if(strcmp(sg->segname, SEG_IMPORT) == 0){
#ifndef HACK_TO_MATCH_TEST_CASE
		    nscns++;
#else
		    s = (struct section *)
			 ((char *)sg + sizeof(struct segment_command));
		    for(j = 0; j < sg->nsects; j++, s++){
			if(strcmp(s->sectname, "__pointers") == 0){
			    section_names_size += strlen(".pointers") + 1;
			    nscns++;
			}
			else if(s->size != 0)
			    fatal("input file: %s contains Mach-O section "
				  "(%.16s,%.16s) unsupported for conversion "
				  "to a pecoff file", arch->file_name,
				  s->segname, s->sectname);
		    }

#endif /* HACK_TO_MATCH_TEST_CASE */
		}
		else if((arch->object->mh->flags & MH_PIE) != MH_PIE ||
			strcmp(sg->segname, SEG_LINKEDIT) != 0){
		    fatal("input file: %s contains Mach-O segment %.16s "
			  "unsupported for conversion to a pecoff file",
			  arch->file_name, sg->segname);
		}
	    }
	    /*
	     * Also while processing the Mach-O file pick up the entry point.
	     */
	    else if(lc->cmd == LC_UNIXTHREAD){
		ut = (struct thread_command *)lc;
		state = (char *)ut + sizeof(struct thread_command);
		p = (char *)ut + ut->cmdsize;
		while(state < p){
		    flavor = *((uint32_t *)state);
		    state += sizeof(uint32_t);
		    count = *((uint32_t *)state);
		    state += sizeof(uint32_t);
		    switch(arch->object->mh_cputype){
		    case CPU_TYPE_I386:
			switch((int)flavor){
			i386_thread_state_t *cpu;
			case i386_THREAD_STATE:
#if i386_THREAD_STATE == 1
			case -1:
#endif /* i386_THREAD_STATE == 1 */
/* i386 thread states on older releases */
#if i386_THREAD_STATE == -1
			case 1:
#endif /* i386_THREAD_STATE == -1 */
			    cpu = (i386_thread_state_t *)state;
			    entry = cpu->eip;
			    state += sizeof(i386_thread_state_t);
			    break;
			default:
			    state += count * sizeof(uint32_t);
			    break;
			}
		        break;
		    case CPU_TYPE_ARM:
			switch(flavor){
			arm_thread_state_t *cpu;
			case ARM_THREAD_STATE:
			    cpu = (arm_thread_state_t *)state;
			    entry = cpu->__pc;
			    state += sizeof(arm_thread_state_t);
			    break;
			default:
			    state += count * sizeof(uint32_t);
			    break;
			}
		        break;
		    default:
			break;
		    }
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	if(reloc_size != 0){
	    /* add one for the .reloc section to contain the base relocations */
	    nscns++;
	}

	/*
	 * If there is a -d flag add one for the .debug section to contain
	 * the information.
	 */
	if(debug_filename != NULL)
	    nscns++;

	/*
	 * At the beginning of the COFF string table are 4 bytes that contain
	 * the total size (in bytes) of the rest of the string table. This size
	 * includes the size field itself, so that the value in this location
	 * would be 4 if no strings were present.
	 */
	strsize = sizeof(uint32_t);

	/*
	 * Section names longer than 8 bytes are placed in the string table.
	 * So here we allocate memory to put them into, which later will be
	 * copied to the start of the string table.
	 */
	section_names = allocate(section_names_size);
	section_name = section_names;
	if(section_names_size != 0)
	    *section_name = '\0';

	/*
	 * Allocate space for the section headers and fill in everything but
	 * their file offsets.
	 *
#ifndef HACK_TO_MATCH_TEST_CASE
	 *
	 * We use the SizeOfRawData field (s_size) as the unrounded value of
	 * the size of the initialized section contents coming from the
	 * segment's filesize.  The VirtualSize field s_vsize may be bigger
	 * with the remaining space zero filled coming from the segment's
	 * vmsize.
#else
	 *
	 * Note to match what objcopy(1) does the s_vsize is an unrounded value
	 * of the size (more like the actual size) and the s_size is a value
	 * rounded to the file_alignment.  So the s_vsize can be smaller than
	 * the s_size, as in the case of pecoff sections created from Mach-O
	 * sections (and not segments).  This seems to volate the spec where
	 * s_vsize can be bigger than s_size with the remaining space zero
	 * filled but does NOT allow the s_vsize to be smaller than the s_size.
#endif
	 */
	scnhdrs = allocate(nscns * sizeof(struct scnhdr));
	memset(scnhdrs, '\0', nscns * sizeof(struct scnhdr));
	scn_contents = allocate(nscns * sizeof(char *));
	object_addr = arch->object->object_addr;
	j = 0;
	lc = arch->object->load_commands;
	for(i = 0; i < arch->object->mh->ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		if(strcmp(sg->segname, SEG_TEXT) == 0){
		    strcpy(scnhdrs[j].s_name, ".text");
#ifdef HACK_TO_MATCH_TEST_CASE
		    scnhdrs[j].s_vsize = sg->filesize;
#else
		    scnhdrs[j].s_vsize = sg->vmsize;
#endif
		    scnhdrs[j].s_vaddr = sg->vmaddr;
		    scnhdrs[j].s_size = rnd(sg->filesize, file_alignment);
		    scnhdrs[j].s_relptr = 0;
		    scnhdrs[j].s_lnnoptr = 0;
		    scnhdrs[j].s_nlnno = 0;
		    scnhdrs[j].s_flags = IMAGE_SCN_MEM_EXECUTE |
					 IMAGE_SCN_MEM_READ |
					 IMAGE_SCN_CNT_CODE;
		    scn_contents[j] = object_addr + sg->fileoff;
		    j++;
		}
		else if(strcmp(sg->segname, SEG_DATA) == 0){
		    strcpy(scnhdrs[j].s_name, ".data");
#ifdef HACK_TO_MATCH_TEST_CASE
		    scnhdrs[j].s_vsize = sg->filesize;
#else
		    scnhdrs[j].s_vsize = sg->vmsize;
#endif
		    scnhdrs[j].s_vaddr = sg->vmaddr;
		    scnhdrs[j].s_size = rnd(sg->filesize, file_alignment);
		    scnhdrs[j].s_relptr = 0;
		    scnhdrs[j].s_lnnoptr = 0;
		    scnhdrs[j].s_nlnno = 0;
		    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
					 IMAGE_SCN_MEM_WRITE |
					 IMAGE_SCN_CNT_CODE |
				         IMAGE_SCN_CNT_INITIALIZED_DATA |
					 IMAGE_SCN_MEM_EXECUTE;
		    scn_contents[j] = object_addr + sg->fileoff;
		    j++;
#ifdef HACK_TO_MATCH_TEST_CASE
		    s = (struct section *)
			 ((char *)sg + sizeof(struct segment_command));
		    for(i = 0; i < sg->nsects; i++, s++){
			if(s->size == 0)
			    continue;
			scnhdrs[j].s_vsize = s->size;
			scnhdrs[j].s_vaddr = s->addr;
			scnhdrs[j].s_size = 0;
			scnhdrs[j].s_relptr = 0;
			scnhdrs[j].s_lnnoptr = 0;
			scnhdrs[j].s_nlnno = 0;
			scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
					     IMAGE_SCN_MEM_WRITE |
					     IMAGE_SCN_CNT_UNINITIALIZED_DATA;
			if(strcmp(s->sectname, SECT_DATA) == 0){
			    continue;
			}
			else if(strcmp(s->sectname, SECT_COMMON) == 0){
			    strcpy(scnhdrs[j].s_name, ".common");
			    common_scnum = j + 1;
			}
			else if(strcmp(s->sectname, SECT_BSS) == 0){
			    strcpy(scnhdrs[j].s_name, ".bss");
			    bss_scnum = j + 1;
			}
			scn_contents[j] = NULL;
			j++;
		    }
#endif /* HACK_TO_MATCH_TEST_CASE */
		}
		else if(strcmp(sg->segname, SEG_IMPORT) == 0){
#ifndef HACK_TO_MATCH_TEST_CASE
		    strcpy(scnhdrs[j].s_name, ".import");
		    scnhdrs[j].s_vsize = sg->vmsize;
		    scnhdrs[j].s_vaddr = sg->vmaddr;
		    scnhdrs[j].s_size = rnd(sg->filesize, file_alignment);
		    scnhdrs[j].s_relptr = 0;
		    scnhdrs[j].s_lnnoptr = 0;
		    scnhdrs[j].s_nlnno = 0;
		    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
					 IMAGE_SCN_MEM_WRITE |
				         IMAGE_SCN_CNT_INITIALIZED_DATA;
		    scn_contents[j] = object_addr + sg->fileoff;
		    j++;
#else /* defined(HACK_TO_MATCH_TEST_CASE) */
		    s = (struct section *)
			 ((char *)sg + sizeof(struct segment_command));
		    for(i = 0; i < sg->nsects; i++, s++){
			if(s->size == 0)
			    continue;
			scnhdrs[j].s_vsize = s->size;
			scnhdrs[j].s_vaddr = s->addr;
			scnhdrs[j].s_size = rnd(s->size, file_alignment);
			scnhdrs[j].s_relptr = 0;
			scnhdrs[j].s_lnnoptr = 0;
			scnhdrs[j].s_nlnno = 0;
			scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
					     IMAGE_SCN_MEM_WRITE |
					     IMAGE_SCN_CNT_INITIALIZED_DATA;
			if(strcmp(s->sectname, "__pointers") == 0){
			    sprintf(scnhdrs[j].s_name, "/%d", strsize);
			    strcat(section_name, ".pointers");
			    len = strlen(section_name) + 1;
			    strsize += len;
			}
			scn_contents[j] = object_addr + s->offset;
			j++;
		    }
#endif /* HACK_TO_MATCH_TEST_CASE */
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	if(reloc_size != 0){
	    strcpy(scnhdrs[j].s_name, ".reloc");
	    scnhdrs[j].s_vsize = reloc_size;
	    reloc_addr = rnd(reloc_addr, section_alignment);
	    scnhdrs[j].s_vaddr = reloc_addr;
	    scnhdrs[j].s_size = rnd(reloc_size, file_alignment);
	    scnhdrs[j].s_relptr = 0;
	    scnhdrs[j].s_lnnoptr = 0;
	    scnhdrs[j].s_nlnno = 0;
	    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
				 IMAGE_SCN_CNT_INITIALIZED_DATA |
				 IMAGE_SCN_MEM_DISCARDABLE;
	    reloc_scnhdr = scnhdrs + j;
	    scn_contents[j] = reloc_contents;
	    j++;
	    debug_addr = reloc_addr + reloc_scnhdr->s_size;
	}
	else{
	    debug_addr = rnd(reloc_addr, section_alignment);
	}

	if(debug_filename != NULL){
	    strcpy(scnhdrs[j].s_name, ".debug");
	    scnhdrs[j].s_vsize = debug_size;
	    scnhdrs[j].s_vaddr = debug_addr;
	    scnhdrs[j].s_size = rnd(debug_size, file_alignment);
	    scnhdrs[j].s_relptr = 0;
	    scnhdrs[j].s_lnnoptr = 0;
	    scnhdrs[j].s_nlnno = 0;
	    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
				 IMAGE_SCN_CNT_INITIALIZED_DATA |
				 IMAGE_SCN_MEM_DISCARDABLE;
	    debug_scnhdr = scnhdrs + j;
	    scn_contents[j] = debug_contents;
	    j++;
	}

	/*
	 * Create the pecoff symbol and string table from this Mach-O file.
	 */
	create_32bit_symbol_table(arch);
}

/*
 * process_64bit_arch() is the routine that processes a 64-bit broken out ofile
 * to gather the info to create the pecoff file.  This routine basically counts
 * and adds up the sizes of the elements that will be in the pecoff output file.
 */
static
void
process_64bit_arch(
struct arch *arch)
{
    uint32_t i, j;
    uint64_t reloc_addr, debug_addr;
    struct load_command *lc;
    struct segment_command_64 *sg64;
    struct thread_command *ut;
    char *p, *state;
    uint32_t flavor, count;
    char *object_addr, *section_name;
#ifdef HACK_TO_MATCH_TEST_CASE
    struct section_64 *s64;
    uint32_t len;
#endif

	/*
	 * Determine the number of sections in the pecoff output file.
	 * 
#ifdef HACK_TO_MATCH_TEST_CASE
	 * 
	 * The hack implementation of this routine is done to match the
	 * current ld_efi(1) script that uses objcopy(1) to make the pecoff
	 * file.  So for 64-bit files the contents of the Mach-O sections get
	 * placed into pecoff sections with a section name made up of the
	 * strings "LC_SEGMENT" the segment and section names separated with
	 * a dot, '.', character.  So the Mach-O (__TEXT,__text) section becomes
	 * a pecoff section with the name "LC_SEGMENT.__TEXT.__text".  The base
	 * relocation entries go into a ".reloc" section.
	 *
#else
	 *
	 * The whole Mach-O __TEXT and __DATA segments are placed in the
	 * pecoff file from the Mach-O file.  And then the .reloc section added
	 * for the base relocations.
	 *
#endif
	 */
	nscns = 0;
	reloc_addr = 0;
	lc = arch->object->load_commands;
	for(i = 0; i < arch->object->mh64->ncmds; i++){
	    if(lc->cmd == LC_SEGMENT_64){
		sg64 = (struct segment_command_64 *)lc;
#ifndef HACK_TO_MATCH_TEST_CASE
		if(strcmp(sg64->segname, SEG_LINKEDIT) != 0 &&
		   sg64->vmaddr + sg64->vmsize > reloc_addr)
		    reloc_addr = sg64->vmaddr + sg64->vmsize;
		if(strcmp(sg64->segname, SEG_TEXT) == 0)
		    nscns++;
		else if(strcmp(sg64->segname, SEG_DATA) == 0)
		    nscns++;
		else if(strcmp(sg64->segname, SEG_LINKEDIT) != 0){
		    fatal("input file: %s contains Mach-O segment %.16s "
			  "unsupported for conversion to a pecoff file",
			  arch->file_name, sg64->segname);
		}
#else /* defined(HACK_TO_MATCH_TEST_CASE) */
		s64 = (struct section_64 *)
		      ((char *)sg64 + sizeof(struct segment_command_64));
		for(i = 0; i < sg64->nsects; i++, s64++){
		    if(s64->addr + s64->size > reloc_addr)
			reloc_addr = s64->addr + s64->size;
		    section_names_size += strlen("LC_SEGMENT.") +
					  strlen(s64->segname) + 1 +
					  strlen(s64->sectname) + 1;
		    nscns++;
		}
#endif /* HACK_TO_MATCH_TEST_CASE */
	    }
	    /*
	     * Also while process the Mach-O file pick up the entry point.
	     */
	    else if(lc->cmd == LC_UNIXTHREAD){
		ut = (struct thread_command *)lc;
		state = (char *)ut + sizeof(struct thread_command);
		p = (char *)ut + ut->cmdsize;
		while(state < p){
		    flavor = *((uint32_t *)state);
		    state += sizeof(uint32_t);
		    count = *((uint32_t *)state);
		    state += sizeof(uint32_t);
		    switch(arch->object->mh_cputype){
#ifdef x86_THREAD_STATE64
		    case CPU_TYPE_X86_64:
			switch(flavor){
		        x86_thread_state64_t *cpu64;
			case x86_THREAD_STATE64:
			    cpu64 = (x86_thread_state64_t *)state;
			    entry = cpu64->rip;
			    state += sizeof(x86_thread_state64_t);
			    break;
			default:
			    state += count * sizeof(uint32_t);
			    break;
			}
			break;
#endif /* x86_THREAD_STATE64 */
#ifdef ARM_THREAD_STATE64
		    case CPU_TYPE_ARM64:
			switch(flavor){
		        arm_thread_state64_t *cpu64;
			case ARM_THREAD_STATE64:
			    cpu64 = (arm_thread_state64_t *)state;
			    entry = cpu64->__pc;
			    state += sizeof(arm_thread_state64_t);
			    break;
			default:
			    state += count * sizeof(uint32_t);
			    break;
			}
			break;
#endif /* ARM_THREAD_STATE64 */
		    }
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	if(reloc_size != 0){
	    /* add one for the .reloc section to contain the base relocations */
	    nscns++;
	}

	/*
	 * If there is a -d flag add one for the .debug section to contain
	 * the information.
	 */
	if(debug_filename != NULL)
	    nscns++;

	/*
	 * At the beginning of the COFF string table are 4 bytes that contain
	 * the total size (in bytes) of the rest of the string table. This size
	 * includes the size field itself, so that the value in this location
	 * would be 4 if no strings were present.
	 */
	strsize = sizeof(uint32_t);

	/*
	 * Section names longer than 8 bytes are placed in the string table.
	 * So here we allocate memory to put them into, which later will be
	 * copied to the start of the string table.
	 */
	section_names = allocate(section_names_size) + 1;
	section_name = section_names;
	if(section_names_size != 0)
	    *section_name = '\0';

	/*
	 * Allocate space for the section headers and fill in everything but
	 * their file offsets.
	 *
#ifndef HACK_TO_MATCH_TEST_CASE
	 *
	 * We use the SizeOfRawData field (s_size) as the unrounded value of
	 * the size of the initialized section contents coming from the
	 * segment's filesize.  The VirtualSize field s_vsize may be bigger
	 * with the remaining space zero filled coming from the segment's
	 * vmsize.
#else
	 *
	 * Note to match what objcopy(1) does the s_vsize is an unrounded value
	 * of the size (more like the actual size) and the s_size is a value
	 * rounded to the file_alignment.  So the s_vsize can be smaller than
	 * the s_size, as in the case of pecoff sections created from Mach-O
	 * sections (and not segments).  This seems to volate the spec where
	 * s_vsize can be bigger than s_size with the remaining space zero
	 * filled but does NOT allow the s_vsize to be smaller than the s_size.
#endif
	 */
	scnhdrs = allocate(nscns * sizeof(struct scnhdr));
	memset(scnhdrs, '\0', nscns * sizeof(struct scnhdr));
	scn_contents = allocate(nscns * sizeof(char *));
	object_addr = arch->object->object_addr;
	j = 0;
	lc = arch->object->load_commands;
	for(i = 0; i < arch->object->mh64->ncmds; i++){
	    if(lc->cmd == LC_SEGMENT_64){
		sg64 = (struct segment_command_64 *)lc;
#ifndef HACK_TO_MATCH_TEST_CASE
		if(strcmp(sg64->segname, SEG_TEXT) == 0){
		    strcpy(scnhdrs[j].s_name, ".text");
		    scnhdrs[j].s_vsize = sg64->vmsize;
		    scnhdrs[j].s_vaddr = sg64->vmaddr;
		    scnhdrs[j].s_size = rnd(sg64->filesize, file_alignment);
		    scnhdrs[j].s_relptr = 0;
		    scnhdrs[j].s_lnnoptr = 0;
		    scnhdrs[j].s_nlnno = 0;
		    scnhdrs[j].s_flags = IMAGE_SCN_MEM_EXECUTE |
					 IMAGE_SCN_MEM_READ |
					 IMAGE_SCN_CNT_CODE;
		    scn_contents[j] = object_addr + sg64->fileoff;
		    j++;
		}
		else if(strcmp(sg64->segname, SEG_DATA) == 0){
		    strcpy(scnhdrs[j].s_name, ".data");
		    scnhdrs[j].s_vsize = sg64->vmsize;
		    scnhdrs[j].s_vaddr = sg64->vmaddr;
		    scnhdrs[j].s_size = rnd(sg64->filesize, file_alignment);
		    scnhdrs[j].s_relptr = 0;
		    scnhdrs[j].s_lnnoptr = 0;
		    scnhdrs[j].s_nlnno = 0;
		    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
					 IMAGE_SCN_MEM_WRITE |
					 IMAGE_SCN_CNT_CODE |
				         IMAGE_SCN_CNT_INITIALIZED_DATA |
					 IMAGE_SCN_MEM_EXECUTE;
		    scn_contents[j] = object_addr + sg64->fileoff;
		    j++;
		}
#else /* defined(HACK_TO_MATCH_TEST_CASE) */
		s64 = (struct section_64 *)
		      ((char *)sg64 + sizeof(struct segment_command_64));
		for(i = 0; i < sg64->nsects; i++, s64++){
		    sprintf(scnhdrs[j].s_name, "/%d", strsize);
		    strcat(section_name, "LC_SEGMENT.");
		    strcat(section_name, s64->segname);
		    strcat(section_name, ".");
		    strcat(section_name, s64->sectname);
		    len = strlen(section_name);
		    strsize += len + 1;
		    section_name += len + 1;
		    *section_name = '\0'; /* start of next section name */

		    /* NOTE zerofill sections are not handled */
		    scnhdrs[j].s_vsize = s64->size;
		    scnhdrs[j].s_vaddr = s64->addr;
		    scnhdrs[j].s_size = rnd(s64->size, file_alignment);
		    scnhdrs[j].s_relptr = 0;
		    scnhdrs[j].s_lnnoptr = 0;
		    scnhdrs[j].s_nlnno = 0;
		    scnhdrs[j].s_flags = IMAGE_SCN_MEM_EXECUTE |
		    			 IMAGE_SCN_CNT_CODE |
		    			 IMAGE_SCN_MEM_WRITE;
		    if(sg64->initprot & VM_PROT_READ)
			scnhdrs[j].s_flags |= IMAGE_SCN_MEM_READ;
		    scn_contents[j] = object_addr + s64->offset;
		    j++;
		}
#endif /* HACK_TO_MATCH_TEST_CASE */
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	if(reloc_size != 0){
	    strcpy(scnhdrs[j].s_name, ".reloc");
	    scnhdrs[j].s_vsize = reloc_size;
	    reloc_addr = rnd(reloc_addr, section_alignment);
	    scnhdrs[j].s_vaddr = reloc_addr;
	    scnhdrs[j].s_size = rnd(reloc_size, file_alignment);
	    scnhdrs[j].s_relptr = 0;
	    scnhdrs[j].s_lnnoptr = 0;
	    scnhdrs[j].s_nlnno = 0;
	    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
				 IMAGE_SCN_CNT_INITIALIZED_DATA |
				 IMAGE_SCN_MEM_DISCARDABLE |
				 IMAGE_SCN_CNT_CODE |
				 IMAGE_SCN_MEM_EXECUTE;
	    reloc_scnhdr = scnhdrs + j;
	    scn_contents[j] = reloc_contents;
	    j++;
	    debug_addr = reloc_addr + reloc_scnhdr->s_size;
	}
	else{
	    debug_addr = rnd(reloc_addr, section_alignment);
	}

	if(debug_filename != NULL){
	    strcpy(scnhdrs[j].s_name, ".debug");
	    scnhdrs[j].s_vsize = debug_size;
	    scnhdrs[j].s_vaddr = debug_addr;
	    scnhdrs[j].s_size = rnd(debug_size, file_alignment);
	    scnhdrs[j].s_relptr = 0;
	    scnhdrs[j].s_lnnoptr = 0;
	    scnhdrs[j].s_nlnno = 0;
	    scnhdrs[j].s_flags = IMAGE_SCN_MEM_READ |
				 IMAGE_SCN_CNT_INITIALIZED_DATA |
				 IMAGE_SCN_MEM_DISCARDABLE |
				 IMAGE_SCN_CNT_CODE |
				 IMAGE_SCN_MEM_EXECUTE;
	    debug_scnhdr = scnhdrs + j;
	    scn_contents[j] = debug_contents;
	    j++;
	}

	/*
	 * Create the pecoff symbol and string table from this Mach-O file.
	 */
	create_64bit_symbol_table(arch);
}

/*
 * layout_output() takes the info gathered from the input Mach-O file and
 * layouts the pecoff output file and creates and fills in the elements of
 * the coff file.  This routine basically sets of the offsets of the elements
 * of the output file from the previously determined sizes.
 */
static
void
layout_output(
struct ofile *ofile)
{
    uint32_t i, header_size, offset, least_vaddr;

	/*
	 * Determine the size of the output file and where each element will be
	 * in the output file.
	 */
	header_size = sizeof(struct ms_dos_stub) +
		      sizeof(signature) +
		      sizeof(struct filehdr) +
		      nscns * sizeof(struct scnhdr);
	if(ofile->mh != NULL)
	    header_size += sizeof(struct aouthdr);
	else
	    header_size += sizeof(struct aouthdr_64);
	header_size = rnd(header_size, file_alignment);
#ifdef HACK_TO_MATCH_TEST_CASE
	/* for some unknown reason the header size is 0x488 not 0x400 */
	if(ofile->mh64 != NULL)
	    header_size += 0x88;
#endif
	/* 
	 * If the lowest section virtual address is greater than the header
	 * size, pad the header up to the virtual address.  This modification
	 * will make the file offset and virtual address equal, and fixes
	 * problems with XIP rebasing in the EFI tools.
	 */
	least_vaddr = 0xffffffff;
	for(i = 0; i < nscns; i++){
	    if(scnhdrs[i].s_vaddr < least_vaddr)
		least_vaddr = scnhdrs[i].s_vaddr;      
	}
	if(least_vaddr > header_size)
	    header_size = least_vaddr;

	offset = header_size;
	for(i = 0; i < nscns; i++){
	    if((scnhdrs[i].s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) == 0){
		/*
		 * We need to check that the headers can be mapped starting at
		 * the ImageBase, fixed at zero in this program, and fit before
		 * the Virtual Address of the first section (really any section)
		 * and if it doesn't then we need the Mach-O file relinked.
		 */
		if(scnhdrs[i].s_vaddr < header_size)
		    fatal("input file: %s must be relinked so PECOFF headers "
			  "can be mapped before its sections (use a -seg1addr "
			  "0x%x or greater)", ofile->file_name, header_size);
		/*
		 * The s_scnptr is set to the offset and then the offset is
		 * incremented by the SizeOfRawData field (s_vsize).
		 */
		scnhdrs[i].s_scnptr = offset;
#ifndef HACK_TO_MATCH_TEST_CASE
		offset += scnhdrs[i].s_vsize;
#else
		/* for some unknown reason the offset after the __dyld section
		   is changed from 0x10 bytes to 0x20 bytes */
		if(ofile->mh64 != NULL && scnhdrs[i].s_vsize < 0x20)
		    offset += 0x20;
		/* for some unknown reason the offset after the __data section
		   is changed from 0x380 bytes to 0x3e0 bytes */
		else if(ofile->mh64 != NULL && scnhdrs[i].s_vsize == 0x380)
		    offset += scnhdrs[i].s_vsize + 0x60;
		else
		    /*
		     * Note to match what objcopy(1) does the offset is
		     * incremented by the VirtualSize field (s_vsize) not the
		     * SizeOfRawData field (s_size) field as that is what was
		     * previously set up.
		     */
		    offset += scnhdrs[i].s_vsize;
#endif
#ifdef HACK_TO_MATCH_TEST_CASE
		if(ofile->mh != NULL)
#endif
		    offset = rnd(offset, file_alignment);
#ifdef HACK_TO_MATCH_TEST_CASE
		else{
		    /* for some unknown reason the next offset is moved up
		       0x200 then rounded to 8 bytes */
		    offset += 0x200;
		    offset = rnd(offset, 8);
		}
#endif
	    }
	}
#ifdef HACK_TO_MATCH_TEST_CASE
	/* for some unknown reason the offset of the symbol is moved back 0x58
	   bytes */
	if(ofile->mh64 != NULL)
	    offset -= 0x58;
#endif
	syment_offset = offset;
	offset += nsyments * sizeof(struct syment);
	string_offset = offset;
	offset += strsize;

	output_size = offset;

	/*
	 * Now with all the sizes and placement of things know fill in headers
	 * of the pecoff file for this Mach-O file.
	 */

	/* first in the pecoff file is the MS-DOS stub */
	create_ms_dos_stub(&ms_dos_stub);

	/*
	 * Second in the pecoff file is the PE format image file signature.
	 * This signature is PE\0\0 (the letters P and E followed by two null
	 * bytes).
	 */
	signature[0] = 'P';
	signature[1] = 'E';
	signature[2] = '\0';
	signature[3] = '\0';

	/* next is the filehdr */
	if(ofile->mh != NULL){
	    if(ofile->mh->cputype == CPU_TYPE_I386)
		filehdr.f_magic = IMAGE_FILE_MACHINE_I386;
	    else
		filehdr.f_magic = IMAGE_FILE_MACHINE_ARM;
	}
	else{
	    if(ofile->mh64->cputype == CPU_TYPE_X86_64)
		filehdr.f_magic = IMAGE_FILE_MACHINE_AMD64;
	    else
		filehdr.f_magic = IMAGE_FILE_MACHINE_ARM64;
	}
	filehdr.f_nscns = nscns;
#ifdef HACK_TO_MATCH_TEST_CASE
	if(ofile->mh != NULL){
	    filehdr.f_timdat = 0x46cb5980;
	}
	else
	    filehdr.f_timdat = 0x47671e62;
#else
	filehdr.f_timdat = time(NULL);
#endif
	filehdr.f_symptr = syment_offset;
	filehdr.f_nsyms = nsyments;
	if(ofile->mh != NULL)
	    filehdr.f_opthdr = sizeof(struct aouthdr);
	else
	    filehdr.f_opthdr = sizeof(struct aouthdr_64);
	filehdr.f_flags = IMAGE_FILE_EXECUTABLE_IMAGE |
			  IMAGE_FILE_LINE_NUMS_STRIPPED |
			  IMAGE_FILE_32BIT_MACHINE |
			  IMAGE_FILE_DEBUG_STRIPPED;
	if(ofile->mh64 != NULL)
	    filehdr.f_flags |= IMAGE_FILE_LOCAL_SYMS_STRIPPED;

	/* next is the aouthdr */
	if(ofile->mh != NULL){
	    aouthdr.magic = PE32MAGIC;
	    aouthdr.vstamp = VSTAMP;

      /* 
       * EFI does not use t, d, or b size. 
       * EFI uses SizeOfImage to errorcheck vaddrs in the image
       */
	    aouthdr.tsize = 0;
	    aouthdr.dsize = 0;
	    aouthdr.bsize = 0;
	    aouthdr.SizeOfImage = rnd(header_size, section_alignment);
	    for(i = 0; i < nscns; i++){
	        aouthdr.SizeOfImage += rnd(scnhdrs[i].s_vsize, section_alignment); 
		}

	    aouthdr.entry = entry;

	    aouthdr.text_start = 0;
	    aouthdr.data_start = 0;
	    for(i = 0; i < nscns; i++){
		if((scnhdrs[i].s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ==0){
		    if((scnhdrs[i].s_flags & IMAGE_SCN_MEM_WRITE) == 0){
			if(aouthdr.text_start == 0)
			    aouthdr.text_start = scnhdrs[i].s_vaddr;
		    }
		    else{
			if(aouthdr.data_start == 0)
			    aouthdr.data_start = scnhdrs[i].s_vaddr;
		    }
		}
	    }

	    aouthdr.ImageBase = 0;
	    aouthdr.SectionAlignment = section_alignment;
	    aouthdr.FileAlignment = file_alignment;
	    aouthdr.MajorOperatingSystemVersion = 0;
	    aouthdr.MinorOperatingSystemVersion = 0;
	    aouthdr.MajorImageVersion = 0;
	    aouthdr.MinorImageVersion = 0;
	    aouthdr.MajorSubsystemVersion = 0;
	    aouthdr.MinorSubsystemVersion = 0;
	    aouthdr.Win32VersionValue = 0;
				  
				  
	    aouthdr.SizeOfHeaders = header_size;
	    aouthdr.CheckSum = 0;
	    aouthdr.Subsystem = Subsystem;
	    aouthdr.DllCharacteristics = 0;
	    aouthdr.SizeOfStackReserve = 0;
	    aouthdr.SizeOfStackCommit = 0;
	    aouthdr.SizeOfHeapReserve = 0;
	    aouthdr.SizeOfHeapCommit = 0;
	    aouthdr.LoaderFlags = 0;
	    aouthdr.NumberOfRvaAndSizes = 16;
	    /* Entry 5, Base Relocation Directory [.reloc] address & size */
	    if(reloc_size != 0){
		aouthdr.DataDirectory[5][0] = reloc_scnhdr->s_vaddr;
		aouthdr.DataDirectory[5][1] = reloc_scnhdr->s_vsize;
	    }
	    /*  Entry 6, Debug Directory [.debug] address & size */
	    if(debug_filename != NULL){
		aouthdr.DataDirectory[6][0] = debug_scnhdr->s_vaddr;
		aouthdr.DataDirectory[6][1] = debug_scnhdr->s_vsize;
	    }
	}
	else{
	    aouthdr64.magic = PE32PMAGIC;
	    aouthdr64.vstamp = VSTAMP;

      /* 
       * EFI does not use t, d, or b size. 
       * EFI uses SizeOfImage to errorcheck vaddrs in the image
       */
	    aouthdr64.tsize = 0;
	    aouthdr64.dsize = 0;
	    aouthdr64.bsize = 0;
	    
	    aouthdr64.SizeOfImage = rnd(header_size, section_alignment);
	    for(i = 0; i < nscns; i++){
	        aouthdr64.SizeOfImage += rnd(scnhdrs[i].s_vsize, section_alignment); 
	    }
#ifdef HACK_TO_MATCH_TEST_CASE
	    /* with the IMAGE_SCN_CNT_CODE flag set on all sections this is
	       just a quick hack to match the PECOFF file */
	    aouthdr64.dsize = 0x200;
#endif

	    aouthdr64.entry = entry;
#ifdef HACK_TO_MATCH_TEST_CASE
            aouthdr64.entry = 0x4a2;
#endif
	    aouthdr64.text_start = 0;
	    for(i = 0; i < nscns; i++){
		if((scnhdrs[i].s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ==0){
		    if((scnhdrs[i].s_flags & IMAGE_SCN_MEM_WRITE) == 0){
			if(aouthdr64.text_start == 0)
			    aouthdr64.text_start = scnhdrs[i].s_vaddr;
		    }
		}
	    }
#ifdef HACK_TO_MATCH_TEST_CASE
	    /* this is a hack as the start of the text for 64-bit Mach-O files
	       built with -dylib does not have the text section starting at 0 */
	    aouthdr64.text_start = 0;
#endif

	    aouthdr64.ImageBase = 0;
	    aouthdr64.SectionAlignment = section_alignment;
	    aouthdr64.FileAlignment = file_alignment;
	    aouthdr64.MajorOperatingSystemVersion = 0;
	    aouthdr64.MinorOperatingSystemVersion = 0;
	    aouthdr64.MajorImageVersion = 0;
	    aouthdr64.MinorImageVersion = 0;
	    aouthdr64.MajorSubsystemVersion = 0;
	    aouthdr64.MinorSubsystemVersion = 0;
	    aouthdr64.Win32VersionValue = 0;
				    
				    
#ifdef HACK_TO_MATCH_TEST_CASE
	    /* this is a hack as it seams that the minimum size is 0x10000 */
	    if(aouthdr64.SizeOfImage < 0x10000)
		aouthdr64.SizeOfImage = 0x10000;
#endif
	    aouthdr64.SizeOfHeaders = header_size;
	    aouthdr64.CheckSum = 0;
	    aouthdr64.Subsystem = Subsystem;
#ifdef HACK_TO_MATCH_TEST_CASE
	    aouthdr64.Subsystem = IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER;
#endif
	    aouthdr64.DllCharacteristics = 0;
	    aouthdr64.SizeOfStackReserve = 0;
	    aouthdr64.SizeOfStackCommit = 0;
	    aouthdr64.SizeOfHeapReserve = 0;
	    aouthdr64.SizeOfHeapCommit = 0;
	    aouthdr64.LoaderFlags = 0;
	    aouthdr64.NumberOfRvaAndSizes = 16;
	    /* Entry 5, Base Relocation Directory [.reloc] address & size */
	    if(reloc_size != 0){
		aouthdr64.DataDirectory[5][0] = reloc_scnhdr->s_vaddr;
		aouthdr64.DataDirectory[5][1] = reloc_scnhdr->s_vsize;
	    }
	    /*  Entry 6, Debug Directory [.debug] address & size */
	    if(debug_filename != NULL){
		aouthdr64.DataDirectory[6][0] = debug_scnhdr->s_vaddr;
		aouthdr64.DataDirectory[6][1] = debug_scnhdr->s_vsize;
	    }
	}

	/*
 	 * If there is a debug directory entry set the address and offsets in
	 * it now that the values are known.
	 */
	if(debug_filename != NULL)
	    set_debug_addrs_and_offsets();
}

/*
 * create_output() takes the info gathered from the input Mach-O file and
 * creates the pecoff output file.
 */
static
void
create_output(
struct ofile *ofile,
char *out)
{
    int i, f;
    unsigned char *buf, *p, *p_aouthdr;

	/*
	 * Allocate the buffer to place the pecoff file in.
	 */
	buf = calloc(1, output_size);
	if(buf == NULL)
	    fatal("Can't allocate buffer for output file (size = %u)",
		  output_size);

	/*
	 * Copy the parts of the pecoff file into the buffer.
	 */
	p = buf;

	memcpy(p, &ms_dos_stub, sizeof(struct ms_dos_stub));
	if(swapped)
	    swap_ms_dos_stub((struct ms_dos_stub *)p, target_byte_sex);
	p += sizeof(struct ms_dos_stub);

	memcpy(p, signature, sizeof(signature));
	p += sizeof(signature);

	memcpy(p, &filehdr, sizeof(struct filehdr));
	if(swapped)
	    swap_filehdr((struct filehdr *)p, target_byte_sex);
	p += sizeof(struct filehdr);

	p_aouthdr = p;
	if(ofile->mh != NULL){
	    memcpy(p, &aouthdr, sizeof(struct aouthdr));
	    if(swapped)
		swap_aouthdr((struct aouthdr *)p, target_byte_sex);
	    p += sizeof(struct aouthdr);
	}
	else{
	    memcpy(p, &aouthdr64, sizeof(struct aouthdr_64));
	    if(swapped)
		swap_aouthdr_64((struct aouthdr_64 *)p, target_byte_sex);
	    p += sizeof(struct aouthdr_64);
	}

	/*
	 * Now copy in the section contents.  Note the base relocations
	 * (the contents of the .reloc section) has already been swapped if
	 * that was needed.
	 */ 
	for(i = 0; i < nscns; i++){
	    if((scnhdrs[i].s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) == 0){
		memcpy(buf + scnhdrs[i].s_scnptr,
		       scn_contents[i],
#ifndef HACK_TO_MATCH_TEST_CASE
		       scnhdrs[i].s_size);
#else
		       scnhdrs[i].s_vsize);
#endif

#ifdef HACK_TO_MATCH_TEST_CASE
		/* this is a hack as this is zero in 64-bit file */
		if(ofile->mh64 != NULL)
		    scnhdrs[i].s_vsize = 0;
#endif
	    }
	}

	memcpy(p, scnhdrs, nscns * sizeof(struct scnhdr));
	if(swapped)
	    swap_scnhdr((struct scnhdr *)p, nscns, target_byte_sex);
	p += nscns * sizeof(struct scnhdr);

	/*
	 * Note the base relocations (the contents of the reloc section),
	 * the symbol table and string table all have already been swapped if
	 * that was needed.
	 */
	memcpy(buf + syment_offset, syments, nsyments * sizeof(struct syment));
	memcpy(buf + string_offset, strings, strsize);

	/*
	 * Now with the file contents complete compute the CheckSum in the
	 * optional header and update that in the output buffer.
	 */
	if(ofile->mh != NULL){
	    aouthdr.CheckSum = checksum(buf) + output_size;
	    memcpy(p_aouthdr, &aouthdr, sizeof(struct aouthdr));
	    if(swapped)
		swap_aouthdr((struct aouthdr *)p_aouthdr, target_byte_sex);
	}
	else{
	    aouthdr64.CheckSum = checksum(buf) + output_size;
	    memcpy(p_aouthdr, &aouthdr64, sizeof(struct aouthdr_64));
	    if(swapped)
		swap_aouthdr_64((struct aouthdr_64 *)p_aouthdr,target_byte_sex);
	}

	/*
	 * Create the pecoff file and write the buffer to the file.
	 */
	f = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644);
	if(f == -1)
	    system_fatal("Can't create output file: %s", out);

	if(write(f, buf, output_size) != output_size)
	    system_fatal("Can't write output file: %s", out);

	if(close(f) == -1)
	    system_fatal("Can't close output file: %s", out);
}

/*
 * create_ms_dos_stub() is pass a pointer to the buffer where to fill in the
 * MS-DOS stub.
 */
static
void
create_ms_dos_stub(
struct ms_dos_stub *p)
{
    int i;

	p->e_magic    = DOSMAGIC;
	p->e_cblp     = 0x90;
	p->e_cp       = 0x3;
	p->e_crlc     = 0x0;
	p->e_cparhdr  = 0x4;
	p->e_minalloc = 0x0;
	p->e_maxalloc = 0xffff;
	p->e_ss       = 0x0;
	p->e_sp       = 0xb8;
	p->e_csum     = 0x0;
	p->e_ip       = 0x0;
	p->e_cs       = 0x0;
	p->e_lfarlc   = 0x40;
	p->e_ovno     = 0x0;

	for(i = 0; i < 4; i++)
	    p->e_res[i] = 0x0;

	p->e_oemid   = 0x0;
	p->e_oeminfo = 0x0;

	for(i = 0; i < 10; i++)
	    p->e_res2[i] = 0x0;

	p->e_lfanew = 0x80;

	/*
	 * The sub dos program that prints "This program cannot be run in DOS
	 * mode".
	 */
	p->dos_program[0]  = 0x0e;
	p->dos_program[1]  = 0x1f;
	p->dos_program[2]  = 0xba;
	p->dos_program[3]  = 0x0e;
	p->dos_program[4]  = 0x00;
	p->dos_program[5]  = 0xb4;
	p->dos_program[6]  = 0x09;
	p->dos_program[7]  = 0xcd;
	p->dos_program[8]  = 0x21;
	p->dos_program[9]  = 0xb8;
	p->dos_program[10] = 0x01;
	p->dos_program[11] = 0x4c;
	p->dos_program[12] = 0xcd;
	p->dos_program[13] = 0x21;
	p->dos_program[14] = 0x54;
	p->dos_program[15] = 0x68;
	p->dos_program[16] = 0x69;
	p->dos_program[17] = 0x73;
	p->dos_program[18] = 0x20;
	p->dos_program[19] = 0x70;
	p->dos_program[20] = 0x72;
	p->dos_program[21] = 0x6f;
	p->dos_program[22] = 0x67;
	p->dos_program[23] = 0x72;
	p->dos_program[24] = 0x61;
	p->dos_program[25] = 0x6d;
	p->dos_program[26] = 0x20;
	p->dos_program[27] = 0x63;
	p->dos_program[28] = 0x61;
	p->dos_program[29] = 0x6e;
	p->dos_program[30] = 0x6e;
	p->dos_program[31] = 0x6f;
	p->dos_program[32] = 0x74;
	p->dos_program[33] = 0x20;
	p->dos_program[34] = 0x62;
	p->dos_program[35] = 0x65;
	p->dos_program[36] = 0x20;
	p->dos_program[37] = 0x72;
	p->dos_program[38] = 0x75;
	p->dos_program[39] = 0x6e;
	p->dos_program[40] = 0x20;
	p->dos_program[41] = 0x69;
	p->dos_program[42] = 0x6e;
	p->dos_program[43] = 0x20;
	p->dos_program[44] = 0x44;
	p->dos_program[45] = 0x4f;
	p->dos_program[46] = 0x53;
	p->dos_program[47] = 0x20;
	p->dos_program[48] = 0x6d;
	p->dos_program[49] = 0x6f;
	p->dos_program[50] = 0x64;
	p->dos_program[51] = 0x65;
	p->dos_program[52] = 0x2e;
	p->dos_program[53] = 0x0d;
	p->dos_program[54] = 0x0d;
	p->dos_program[55] = 0x0a;
	p->dos_program[56] = 0x24;
	p->dos_program[57] = 0x0;
	p->dos_program[58] = 0x0;
	p->dos_program[59] = 0x0;
	p->dos_program[60] = 0x0;
	p->dos_program[61] = 0x0;
	p->dos_program[62] = 0x0;
	p->dos_program[63] = 0x0;
}


/*
 * create_32bit_symbol_table() is called to process the input Mach-O file and
 * create the pecoff symbol and string table.
 */
static
void
create_32bit_symbol_table(
struct arch *arch)
{
    char *object_addr;
    struct symtab_command *st;
    struct nlist *syms;
    char *strs;
    enum bool found_undef;
#ifdef HACK_TO_MATCH_TEST_CASE
    uint32_t j, n_sect, bss_n_sect, common_n_sect,
	     bss_addr, common_addr, size;
    struct load_command *lc;
    struct segment_command *sg;
    struct section *s;
#endif /* HACK_TO_MATCH_TEST_CASE */
    uint32_t i;
    char *p;

	/*
	 * No symbols are actually needed in the pecoff file from the Mach-O
	 * file so create an empty symbol table.
	 */
	nsyments = 0;

	/*
	 * Make sure the Mach-O file does not have any undefined symbols.
	 */
	st = arch->object->st;
	object_addr = arch->object->object_addr;
	syms = (struct nlist *)(object_addr + st->symoff);
	strs = object_addr + st->stroff;
	if(swapped)
	    swap_nlist(syms, st->nsyms, host_byte_sex);
	found_undef = FALSE;
	for(i = 0; i < st->nsyms; i++){
	    if((syms[i].n_type & N_STAB) != 0)
		continue;
	    if((syms[i].n_type & N_TYPE) == N_UNDF){
		if(found_undef == FALSE){
		    error("input file: %s contains undefined symbols:",
			  arch->file_name);
		}
		found_undef = TRUE;
		if(syms[i].n_un.n_strx != 0)
		    printf("%s\n", strs + syms[i].n_un.n_strx);
		else
		    printf("symbol at index %u is undefined but has NULL "
			   "name (like a malformed Mach-O file)\n", i);
	    }
	}
	if(found_undef == TRUE)
	    fatal("undefined symbols are unsupported for conversion to a "
		  "pecoff file");

#ifdef HACK_TO_MATCH_TEST_CASE
	/*
	 * The hack implementation of this routine exist only in order to
	 * match the current ld_efi(1) script that uses objcopy(1) to make the
	 * pecoff file.  So for that only the common symbols and bss symbols
	 * make it into the output pecoff file.
	 *
	 */

	/*
	 * First figure out the section number of the common and bss sections
	 * and address of those sections.
	 */
	n_sect = 1;
	bss_n_sect = 0;
	bss_addr = 0;
	common_n_sect = 0;
	common_addr = 0;
	lc = arch->object->load_commands;
	for(i = 0; i < arch->object->mh->ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		if(strcmp(sg->segname, SEG_DATA) == 0){
		    s = (struct section *)
			  ((char *)sg + sizeof(struct segment_command));
		    for(j = 0; j < sg->nsects; j++){
			if(strcmp(s->sectname, SECT_BSS) == 0){
			    bss_n_sect = n_sect;
			    bss_addr = s->addr;
			}
			else if(strcmp(s->sectname, SECT_COMMON) == 0){
			    common_n_sect = n_sect;
			    common_addr = s->addr;
			}
			s++;
			n_sect++;
		    }
		}
		else{
		    n_sect += sg->nsects;
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}

	/*
	 * Count the number of the common and bss sections symbols and add up
	 * the size of their strings.  Note the size of long section names is
	 * already accounted for in strsize by the code in process_32bit_arch().
	 */
	for(i = 0; i < st->nsyms; i++){
	    if((syms[i].n_type & N_STAB) == 0 &&
	       (syms[i].n_type & N_TYPE) == N_SECT &&
	       (syms[i].n_sect == bss_n_sect ||
	        syms[i].n_sect == common_n_sect)){
		nsyments++;
		if(syms[i].n_un.n_strx != 0){
		    size = strlen(strs + syms[i].n_un.n_strx);
		    if(size > E_SYMNMLEN)
			strsize += strlen(strs + syms[i].n_un.n_strx) + 1;
		}
	    }
	}
#endif /* HACK_TO_MATCH_TEST_CASE */

	/*
	 * Allocate space for the pecoff symbol table and string table.
	 */
	syments = allocate(nsyments * sizeof(struct syment));
	memset(syments, '\0', nsyments * sizeof(struct syment));
	strings = allocate(strsize);

	/*
	 * Put the size of the string table in the string table first.  Then
	 * the strings for the long section names right after the size.
	 */
	p = strings;

	i = strsize;
	if(swapped)
	    i = SWAP_INT(i);
	memcpy(p, &i, sizeof(uint32_t));
	p += sizeof(uint32_t);

	memcpy(p, section_names, section_names_size);
	p += section_names_size;

#ifdef HACK_TO_MATCH_TEST_CASE
	/*
	 * First put in the bss symbols, again to match what is done by
	 * objcopy.
	 */
	j = 0;
	for(i = 0; i < st->nsyms; i++){
	    if((syms[i].n_type & N_STAB) == 0 &&
	       (syms[i].n_type & N_TYPE) == N_SECT &&
	       syms[i].n_sect == bss_n_sect){
		if(syms[i].n_un.n_strx != 0){
		    size = strlen(strs + syms[i].n_un.n_strx);
		    if(size > E_SYMNMLEN){
			syments[j].e.e.e_zeroes = 0;
			syments[j].e.e.e_offset = p - strings;
			strcpy(p, strs + syms[i].n_un.n_strx);
			p += strlen(strs + syms[i].n_un.n_strx) + 1;
		    }
		    else{
			strncpy(syments[j].e.e_name,
				strs + syms[i].n_un.n_strx, E_SYMNMLEN);
		    }
		}
		syments[j].e_value = syms[i].n_value - bss_addr;
		syments[j].e_scnum = bss_scnum;
		syments[j].e_type = 0;
		syments[j].e_sclass = IMAGE_SYM_CLASS_EXTERNAL;
		syments[j].e_numaux = 0;
		j++;
	    }
	}
	/*
	 * Next put in the common symbols, again to match what is done by
	 * objcopy.
	 */
	for(i = 0; i < st->nsyms; i++){
	    if((syms[i].n_type & N_STAB) == 0 &&
	       (syms[i].n_type & N_TYPE) == N_SECT &&
	       syms[i].n_sect == common_n_sect){
		if(syms[i].n_un.n_strx != 0){
		    size = strlen(strs + syms[i].n_un.n_strx);
		    if(size > E_SYMNMLEN){
			syments[j].e.e.e_zeroes = 0;
			syments[j].e.e.e_offset = p - strings;
			strcpy(p, strs + syms[i].n_un.n_strx);
			p += strlen(strs + syms[i].n_un.n_strx) + 1;
		    }
		    else{
			strncpy(syments[j].e.e_name,
				strs + syms[i].n_un.n_strx, E_SYMNMLEN);
		    }
		}
		syments[j].e_value = syms[i].n_value - common_addr;
		syments[j].e_scnum = common_scnum;
		syments[j].e_type = 0;
		syments[j].e_sclass = IMAGE_SYM_CLASS_EXTERNAL;
		syments[j].e_numaux = 0;
		j++;
	    }
	}

	if(swapped)
	    swap_syment(syments, nsyments, target_byte_sex);

#endif /* HACK_TO_MATCH_TEST_CASE */
}

/*
 * create_64bit_symbol_table() is called to process the input Mach-O file and
 * create the pecoff symbol and string table.
 */
static
void
create_64bit_symbol_table(
struct arch *arch)
{
    char *p;
    uint32_t i;
    char *object_addr;
    struct symtab_command *st;
    struct nlist_64 *syms64;
    char *strs;
    enum bool found_undef;

	st = arch->object->st;
	object_addr = arch->object->object_addr;
	syms64 = (struct nlist_64 *)(object_addr + st->symoff);
	strs = object_addr + st->stroff;
	if(swapped)
	    swap_nlist_64(syms64, st->nsyms, host_byte_sex);
	/*
	 * If the entry point option was specified then look for that symbol
	 * and set the entry point value.
	 */
	if(entry_point != NULL){
	    for(i = 0; i < st->nsyms; i++){
		if((syms64[i].n_type & N_STAB) == 0 &&
		    syms64[i].n_un.n_strx != 0 &&
		    strcmp(strs + syms64[i].n_un.n_strx, entry_point) == 0){
		    entry = syms64[i].n_value;
		    break;
		}
	    }
	    if(i == st->nsyms)
		fatal("can't find symbol for -e %s in input file: %s",
		      entry_point, arch->file_name);
	}

	/*
	 * Make sure the Mach-O file does not have any undefined symbols.
	 */
	found_undef = FALSE;
	for(i = 0; i < st->nsyms; i++){
	    if((syms64[i].n_type & N_STAB) != 0)
		continue;
	    if((syms64[i].n_type & N_TYPE) == N_UNDF){
		if(found_undef == FALSE){
		    error("input file: %s contains undefined symbols:",
			  arch->file_name);
		}
		found_undef = TRUE;
		if(syms64[i].n_un.n_strx != 0)
		    printf("%s\n", strs + syms64[i].n_un.n_strx);
		else
		    printf("symbol at index %u is undefined but has NULL "
			   "name (like a malformed Mach-O file)\n", i);
	    }
	}
	if(found_undef == TRUE)
	    fatal("undefined symbols are unsupported for conversion to a "
		  "pecoff file");

	/*
	 * No symbols are actually needed in the pecoff file from the Mach-O
	 * file so create an empty symbol table.
	 *
	 * Set the number of symbols to zero and allocate the string table.
	 * Note the size of long section names is already accounted for in
	 * strsize by the code in process_64bit_arch().
	 */
	nsyments = 0;
	strings = allocate(strsize);

	/*
	 * Put the size of the string table in the string table first.  Then
	 * the strings for the long section names right after the size.
	 */
	p = strings;

	i = strsize;
	if(swapped)
	    i = SWAP_INT(i);
	memcpy(p, &i, sizeof(uint32_t));
	p += sizeof(uint32_t);

	memcpy(p, section_names, section_names_size);
}

/*
 * create_base_reloc() is called to process the input Mach-O file and gather
 * the info needed and then to create the base relocation entries.
 */
static
void
create_base_reloc(
struct arch *arch)
{
    uint32_t ncmds, i, j;
    uint64_t addr, first_addr;
    struct load_command *lc;
    struct segment_command *sg;
    struct segment_command_64 *sg64;
    struct section *s;
    struct section_64 *s64;
    struct relocation_info *relocs;

    char *object_addr;
    struct dysymtab_command *dyst;

	if(arch->object->mh != NULL)
	    ncmds = arch->object->mh->ncmds;
	else
	    ncmds = arch->object->mh64->ncmds;
	dyst = arch->object->dyst;
	object_addr = arch->object->object_addr;

	first_addr = 0;
	lc = arch->object->load_commands;
	for(i = 0; i < ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		if(first_addr == 0)
		    first_addr = sg->vmaddr;
		s = (struct section *)
		      ((char *)sg + sizeof(struct segment_command));
		for(j = 0; j < sg->nsects; j++){
		    relocs = (struct relocation_info *)(object_addr +
						        s[j].reloff);
		    if(swapped)
			swap_relocation_info(relocs, s[j].nreloc,
					     host_byte_sex);
		    if(arch->object->mh_cputype == CPU_TYPE_I386)
			gather_base_reloc_info(s[j].addr, relocs, s[j].nreloc,
				CPU_TYPE_I386, 2, GENERIC_RELOC_VANILLA,
				IMAGE_REL_BASED_HIGHLOW);
		    else if(arch->object->mh_cputype == CPU_TYPE_ARM)
			gather_base_reloc_info(s[j].addr, relocs, s[j].nreloc,
				CPU_TYPE_ARM, 2, GENERIC_RELOC_VANILLA,
				IMAGE_REL_BASED_HIGHLOW);
		    if((s[j].flags & SECTION_TYPE) ==
			S_NON_LAZY_SYMBOL_POINTERS){
			for(addr = s[j].addr;
			    addr < s[j].addr + s[j].size;
			    addr += 4) {
			    add_base_reloc(addr, IMAGE_REL_BASED_HIGHLOW);
			}
		    }
		}
	    }
	    else if(lc->cmd == LC_SEGMENT_64){
		sg64 = (struct segment_command_64 *)lc;
		if(arch->object->mh_cputype == CPU_TYPE_X86_64) {
		    /*
		     * X86_64 relocations are relative to the first writable
		     * segment.
		     */
		    /*
		     * But arm64 relocations are NOT relative to the first
		     * writable segment but just the first segment.
		     */
		    if((first_addr == 0) &&
		       ((sg64->initprot & VM_PROT_WRITE) != 0)) {
		      first_addr = sg64->vmaddr;
		    }
		} else { 
		if(first_addr == 0)
		    first_addr = sg64->vmaddr;
		}
		s64 = (struct section_64 *)
		      ((char *)sg64 + sizeof(struct segment_command_64));
		for(j = 0; j < sg64->nsects; j++){
		    relocs = (struct relocation_info *)(object_addr +
						        s64[j].reloff);
		    if(swapped)
			swap_relocation_info(relocs, s64[j].nreloc,
					     host_byte_sex);
		    if(arch->object->mh_cputype == CPU_TYPE_X86_64)
			gather_base_reloc_info(s64[j].addr, relocs,
			    s64[j].nreloc, CPU_TYPE_X86_64, 3,
			    X86_64_RELOC_UNSIGNED, IMAGE_REL_BASED_DIR64);
		    else if(arch->object->mh_cputype == CPU_TYPE_ARM64)
			gather_base_reloc_info(s64[j].addr, relocs,
			    s64[j].nreloc, CPU_TYPE_ARM64, 3,
			    ARM64_RELOC_UNSIGNED, IMAGE_REL_BASED_DIR64);
		    if((s64[j].flags & SECTION_TYPE) ==
			S_NON_LAZY_SYMBOL_POINTERS){
			for(addr = s64[j].addr;
			    addr < s64[j].addr + s64[j].size;
			    addr += 8) {
			    add_base_reloc(addr, IMAGE_REL_BASED_DIR64);
			}
		    }
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	if(dyst != NULL && dyst->nlocrel != 0){
	    relocs = (struct relocation_info *)(object_addr +
						dyst->locreloff);
	    if(swapped)
		swap_relocation_info(relocs, dyst->nlocrel, host_byte_sex);
	    if(arch->object->mh_cputype == CPU_TYPE_I386)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_I386, 2, GENERIC_RELOC_VANILLA,
		    IMAGE_REL_BASED_HIGHLOW);
	    else if(arch->object->mh_cputype == CPU_TYPE_ARM)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_ARM, 2, GENERIC_RELOC_VANILLA,
		    IMAGE_REL_BASED_HIGHLOW);
	    else if(arch->object->mh_cputype == CPU_TYPE_X86_64)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_X86_64, 3, X86_64_RELOC_UNSIGNED,
		    IMAGE_REL_BASED_DIR64);
	    else if(arch->object->mh_cputype == CPU_TYPE_ARM64)
		gather_base_reloc_info(first_addr, relocs, dyst->nlocrel,
		    CPU_TYPE_ARM64, 3, ARM64_RELOC_UNSIGNED,
		    IMAGE_REL_BASED_DIR64);
	}
	/*
	if(dyst != NULL && dyst->nextrel != 0)
	    ; TODO error if there are external relocation entries */

	/*
	 * Now with all the info gathered make the base relocation entries.
	 */
	make_base_relocs();
}

/*
 * gather_base_reloc_info() is passed the base address for the set of Mach-O
 * relocation entries. And is passed the cpu_type, length and macho_reloc_type
 * to look for and the base_reloc_type to create if found.
 */
static
void
gather_base_reloc_info(
uint32_t addr,
struct relocation_info *relocs, 
uint32_t nreloc,
cpu_type_t cpu_type,
uint32_t length,
int macho_reloc_type,
int base_reloc_type)
{
    uint32_t i, r_address, r_pcrel, r_length, r_extern, r_type;
    struct scattered_relocation_info *sreloc;

	for(i = 0; i < nreloc; i++){
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_type = (enum reloc_type_generic)sreloc->r_type;
		r_extern = 0;
	    }
	    else{
		r_address = relocs[i].r_address;
		r_pcrel = relocs[i].r_pcrel;
		r_length = relocs[i].r_length;
		r_extern = relocs[i].r_extern;
		r_type = (enum reloc_type_generic)relocs[i].r_type;
	    }

	    if(r_extern == 0 && r_pcrel == 0 &&
	       r_length == length && r_type == macho_reloc_type)
		add_base_reloc(addr + r_address, base_reloc_type);
	    else
	    	; /* TODO add checking and error messages here */

	    if((relocs[i].r_address & R_SCATTERED) == 0){
		if(reloc_has_pair(cpu_type, relocs[i].r_type))
		    i++;
	    }
	    else{
		sreloc = (struct scattered_relocation_info *)relocs + i;
		if(reloc_has_pair(cpu_type, sreloc->r_type))
		    i++;
	    }
	}
}

/*
 * add_base_reloc() is passed a addr and a type for a base relocation entry to
 * add to the list.
 */
static
void
add_base_reloc(
uint64_t addr,
uint32_t type)
{
    static int max = 0;
    struct base_reloc *new_base_relocs;
    
	if(!max){
	    max = 128;
	    base_relocs = (struct base_reloc *)
			  malloc(max * sizeof(struct base_reloc));
	}
	if(nbase_reloc >= max){
	    new_base_relocs = malloc(2 * max * sizeof(struct base_reloc));
	    memcpy(new_base_relocs, base_relocs,
		   max * sizeof(struct base_reloc));
	    max *= 2;
	    free(base_relocs);
	    base_relocs = new_base_relocs;
	}
	base_relocs[nbase_reloc].addr = addr;
        base_relocs[nbase_reloc].type = type;
	nbase_reloc++;
}

/*
 * The base relocation table in a PECOFF file is divided into blocks. Each
 * block represents the base relocations for a 4K page. Each block must start
 * on a 32-bit boundary.  Which is why one "nop" base relocation entry may be
 * be added as padding in a block.
 */
#define MAX_BLOCK_OFFSET 0x1000
#define BLOCK_MASK (MAX_BLOCK_OFFSET-1)

/*
 * make_base_relocs() takes the info for the base relocation entries gathered
 * and creates the fixup blocks as they would be in a PECOFF file and sets the
 * static variables reloc_contents and reloc_size to the pointer to contents
 * and the size of that contents.
 */
static
void
make_base_relocs(
void)
{
    int blockcnt;
    int i, entries;
    uint64_t base;
    int size;
    char *fb;
    struct base_relocation_block_header *h;
    struct base_relocation_entry *b;
    uint32_t offset;
	
	blockcnt = 0;

	/*
	 * After we create each base relocation block we will allocate space
	 * for it in the .reloc section contents buffer and copy it into the
	 * buffer.
	 */
	reloc_size = 0;
	reloc_contents = NULL;

	/*
	 * If there are no base relocation entries return so we don't create a
	 * base relocation block with 0 entries.
	 */
	if(nbase_reloc == 0)
	    return;
	
	qsort(base_relocs, nbase_reloc, sizeof(struct base_reloc),
	      (int (*)(const void *, const void *))cmp_base_relocs);
	
	/*
	 * The size of the base relocation tables must be a multiple of 4 bytes.
	 * so we may need to add one relocation entry as padding.  We make this
	 * fixup block large enought to hold all the base relocation entries.
	 * But it will be broken up for the base relocation entries for each
	 * each group that refers to the same 4K page.
	 */
	size = sizeof(struct base_relocation_block_header) +
	       (nbase_reloc + 1) * sizeof(struct base_relocation_entry);
	fb = malloc(size);
	
	
	entries = 0;
	base = base_relocs[0].addr & ~BLOCK_MASK;
	h = (struct base_relocation_block_header *)fb;
	b = (struct base_relocation_entry *)
	    (fb + sizeof(struct base_relocation_block_header));
	for(i = 0; i < nbase_reloc; i++){
	    offset = base_relocs[i].addr - base;
	    if(offset >= MAX_BLOCK_OFFSET) {
		/* add padding if needed */
		if((entries % 2) != 0){
		    b[entries].type = IMAGE_REL_BASED_ABSOLUTE;
		    b[entries].offset = 0;
		    entries++;
		}
		h->page_rva = base;
		size = sizeof(struct base_relocation_block_header) +
		       entries * sizeof(struct base_relocation_entry);
		h->block_size = size;
		if(swapped){
		    swap_base_relocation_block_header(h,
						      target_byte_sex);
		    swap_base_relocation_entry(b, entries,
					       target_byte_sex);
		}
		/* copy this finished block into the .reloc contents buffer */
		reloc_contents = reallocate(reloc_contents, reloc_size + size);
		memcpy(reloc_contents + reloc_size, fb, size);
		reloc_size += size;

		entries = 0;
		blockcnt++;
		base = base_relocs[i].addr & ~BLOCK_MASK;
		offset = base_relocs[i].addr - base;
	    }
	    b[entries].type = base_relocs[i].type;
	    b[entries].offset = offset;
	    entries++;
	}
	
	/* add padding if needed */
	if((entries % 2) != 0){
	    b[entries].type = IMAGE_REL_BASED_ABSOLUTE;
	    b[entries].offset = 0;
	    entries++;
	}
	h->page_rva = base;
	size = sizeof(struct base_relocation_block_header) +
	       entries * sizeof(struct base_relocation_entry);
	h->block_size = size;
	if(swapped){
	    swap_base_relocation_block_header(h, target_byte_sex);
	    swap_base_relocation_entry(b, entries, target_byte_sex);
	}

	/* copy this last block into the .reloc contents buffer */
	reloc_contents = reallocate(reloc_contents, reloc_size + size);
	memcpy(reloc_contents + reloc_size, fb, size);
	reloc_size += size;

	blockcnt++;
	free(fb);
}

static
int
cmp_base_relocs(
struct base_reloc *x1,
struct base_reloc *x2)
{
	if(x1->addr < x2->addr)
	    return(-1);
	if(x1->addr == x2->addr)
	    return(0);
	/* x1->addr > x2->addr */
	    return(1);
}

/*
 * create_debug() is called to create the .debug section contents from
 * the -d filename argument.
 */
static
void
create_debug(
struct arch *arch)
{
    char *p;
    uint32_t i, ncmds;
    struct load_command *lc;
    struct uuid_command *uuid;

	/*
	 * Allocate space for everything that will be in the .debug section:
	 *	the debug_directory_entry struct
	 *	the mtoc_debug_info struct
	 *	the name of the -d filename argument null terminated.
	 */
	debug_size = sizeof(struct debug_directory_entry) +
		     sizeof(struct mtoc_debug_info) +
		     strlen(debug_filename) + 1;
	debug_contents = allocate(debug_size);
	memset(debug_contents, '\0', debug_size);
	/*
	 * Set up pointers to all the parts to be filled in.
	 */
	p = debug_contents;
	dde = (struct debug_directory_entry *)p;
	p += sizeof(struct debug_directory_entry);
	mdi = (struct mtoc_debug_info *)p;
	p += sizeof(struct mtoc_debug_info);

	dde->Characteristics = 0;
	dde->TimeDateStamp = time(NULL);
	dde->MajorVersion = 0;
	dde->MinorVersion = 0;
	dde->Type = IMAGE_DEBUG_TYPE_CODEVIEW;
	dde->SizeOfData = sizeof(struct mtoc_debug_info) +
			  strlen(debug_filename) + 1;
	/*
	 * These two will be filled in later when address and offsets
	 * are known.
	 */
	dde->AddressOfRawData = 0;
	dde->PointerToRawData = 0;

	mdi->Signature = MTOC_SIGNATURE;
	if(arch->object->mh != NULL)
	    ncmds = arch->object->mh->ncmds;
	else
	    ncmds = arch->object->mh64->ncmds;
	lc = arch->object->load_commands;
	for(i = 0; i < ncmds; i++){
	    if(lc->cmd == LC_UUID){
		uuid = (struct uuid_command *)lc;
		if (debug_uuid != NULL) {
		    string_to_uuid (debug_uuid, uuid->uuid);
		}
		/* Swizzle UUID to match EFI GUID definition */
		mdi->uuid[0] = uuid->uuid[3];
		mdi->uuid[1] = uuid->uuid[2];
		mdi->uuid[2] = uuid->uuid[1];
		mdi->uuid[3] = uuid->uuid[0];
		mdi->uuid[4] = uuid->uuid[5];
		mdi->uuid[5] = uuid->uuid[4];
		mdi->uuid[6] = uuid->uuid[7];
		mdi->uuid[7] = uuid->uuid[6];
		mdi->uuid[8] = uuid->uuid[8];
		mdi->uuid[9] = uuid->uuid[9];
		mdi->uuid[10] = uuid->uuid[10];
		mdi->uuid[11] = uuid->uuid[11];
		mdi->uuid[12] = uuid->uuid[12];
		mdi->uuid[13] = uuid->uuid[13];
		mdi->uuid[14] = uuid->uuid[14];
		mdi->uuid[15] = uuid->uuid[15];
		break;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}

	strcpy(p, debug_filename);
}

/*
 * set_debug_addrs_and_offsets() is called after the .debug section's address
 * and offset has been set and this routine sets the other needed addresses
 * and offsets in the section contents.  And swaps the section contents if
 * needed for output.
 */
static
void
set_debug_addrs_and_offsets(
void)
{
	dde->AddressOfRawData = debug_scnhdr->s_vaddr +
				sizeof(struct debug_directory_entry);
	dde->PointerToRawData = debug_scnhdr->s_scnptr +
				sizeof(struct debug_directory_entry);
	if(swapped){
	    swap_debug_directory_entry(dde, target_byte_sex);
	    swap_mtoc_debug_info(mdi, target_byte_sex);
	}
}

/*
 * checksum() calculates the value for the CheckSum field in the optional
 * header from the bytes in the output buffer passed to it which has the
 * size output_size.
 */
static
uint32_t
checksum(
unsigned char *buf)
{
    uint32_t i, v, t;

	t = 0;
	for(i = 0; i < output_size; i += 2){
	    if(output_size - i == 1)
		v = buf[i];
	    else
		v = buf[i] + (buf[i+1] << 8);
	    t += v;
	    t = 0xffff & (t + (t >> 0x10));
	}
	return(0xffff & (t + (t >> 0x10)));
}

/*
 * string_to_uuid() creates a 128-bit uuid from a well-formatted UUID string
 * (i.e. aabbccdd-eeff-gghh-iijj-kkllmmnnoopp)
 */
static
void
string_to_uuid(
char *string,
uint8_t *uuid)
{
    uint8_t count;

	count = sscanf (string, UUID_FORMAT_STRING,
	&uuid[0], &uuid[1], &uuid[2], &uuid[3],
	&uuid[4], &uuid[5], &uuid[6], &uuid[7],
	&uuid[8], &uuid[9], &uuid[10], &uuid[11],
	&uuid[12], &uuid[13], &uuid[14], &uuid[15]);

	if (count != 16) {
	    fatal ("invalid UUID specified for -u option");
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/                                      0040755 0001750 0001750 00000000000 12612724206 021560  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/arcs.c                                0100644 0001750 0001750 00000042146 12612724206 022660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: arcs.c,v 1.2 1996/06/26 05:33:47 deraadt Exp $	*/
/*	$NetBSD: arcs.c,v 1.6 1995/04/19 07:15:52 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <stdlib.h>
#include "stuff/errors.h"
#include "gprof.h"

static int topcmp(
    nltype **npp1,
    nltype **npp2);
static void dotime(
    void);
static void timepropagate(
    nltype *parentp);
static void cyclelink(
    void);
static void cycletime(
    void);
static void doflags(
    void);
static void inheritflags(
    nltype *childp);

/*
 * add (or just increment) an arc
 */
void
addarc(
nltype *parentp,
nltype *childp,
uint32_t count,
uint32_t order)
{
    arctype *arcp;

#ifdef DEBUG
	if(debug & TALLYDEBUG){
	    printf("[addarc] %u arcs from %s to %s\n" ,
		   count, parentp->name, childp->name);
	}
#endif
	arcp = arclookup(parentp, childp);
	if(arcp != NULL){
	    /*
	     * a hit: just increment the count.
	     */
#ifdef DEBUG
	    if(debug & TALLYDEBUG){
		printf("[tally] hit %u += %u\n",
		       arcp->arc_count, count);
	    }
#endif
	    arcp->arc_count += count;
	    return;
	}
	arcp = (arctype *)calloc(1, sizeof(arctype));
	arcp->arc_parentp = parentp;
	arcp->arc_childp = childp;
	arcp->arc_count = count;
	arcp->arc_order = order;
	/*
	 * Prepend this child to the children of this parent.
	 */
	arcp->arc_childlist = parentp->children;
	parentp->children = arcp;
	/*
	 * Prepend this parent to the parents of this child.
	 */
	arcp->arc_parentlist = childp->parents;
	childp->parents = arcp;
}

/*
 * The code below topologically sorts the graph (collapsing cycles),
 * and propagates time bottom up and flags top down.
 */

/*
 * The topologically sorted name list pointers.
 */
static nltype **topsortnlp = NULL;

static
int
topcmp(
nltype **npp1,
nltype **npp2)
{
	return((*npp1)->toporder - (*npp2)->toporder);
}

nltype **
doarcs(
void)
{
    nltype	*parentp, **timesortnlp;
    arctype	*arcp;
    uint32_t index;

	/*
	 * initialize various things:
	 *     zero out child times.
	 *     count self-recursive calls.
	 *     indicate that nothing is on cycles.
	 */
	for(parentp = nl; parentp < npe; parentp++){
	    parentp->childtime = 0.0;
	    arcp = arclookup(parentp, parentp);
	    if(arcp != NULL){
		parentp->ncall -= arcp->arc_count;
		parentp->selfcalls = arcp->arc_count;
	    }
	    else{
		parentp->selfcalls = 0;
	    }
	    parentp->propfraction = 0.0;
	    parentp->propself = 0.0;
	    parentp->propchild = 0.0;
	    parentp->printflag = FALSE;
	    parentp->toporder = DFN_NAN;
	    parentp->cycleno = 0;
	    parentp->cyclehead = parentp;
	    parentp->cnext = 0;
/*
	    if(cflag == TRUE){
		findcalls(parentp, parentp->value, (parentp+1)->value);
	    }
*/
	}
	/*
	 * topologically order things
	 * if any node is unnumbered,
	 *     number it and any of its descendents.
	 */
	for(parentp = nl; parentp < npe; parentp++){
	    if(parentp->toporder == DFN_NAN){
		dfn(parentp);
	    }
	}
	/*
	 * Link together nodes on the same cycle.
	 */
	cyclelink();
	/*
	 * Sort the symbol table in reverse topological order.
	 */
	topsortnlp = (nltype **)calloc(nname, sizeof(nltype *));
	if(topsortnlp == (nltype **)0){
	    fprintf(stderr, "[doarcs] ran out of memory for topo sorting\n");
	}
	for(index = 0; index < nname; index += 1){
	    topsortnlp[index] = &nl[index];
	}
	qsort(topsortnlp, nname, sizeof(nltype *),
	      (int (*)(const void *, const void *))topcmp);
#ifdef DEBUG
	if(debug & DFNDEBUG){
	    printf( "[doarcs] topological sort listing\n");
	    for(index = 0; index < nname; index += 1){
		printf("[doarcs] ");
		printf("%d:", topsortnlp[index]->toporder);
		printname(topsortnlp[index]);
		printf("\n");
	    }
	}
#endif
	/*
	 * Starting from the topological top,
	 * propagate print flags to children.
	 * Also, calculate propagation fractions.
	 * This happens before time propagation
	 * since time propagation uses the fractions.
	 */
	doflags();
	/*
	 * Starting from the topological bottom, 
	 * propogate children times up to parents.
	 */
	dotime();
	/*
	 * Now, sort by propself + propchild.
	 * sorting both the regular function names
	 * and cycle headers.
	 */
	timesortnlp = (nltype **)calloc(nname + ncycle, sizeof(nltype *));
	if(timesortnlp == NULL)
	    fatal("ran out of memory for sorting");
	for(index = 0; index < nname; index++){
	    timesortnlp[index] = &nl[index];
	}
	for(index = 1; index <= (uint32_t)ncycle; index++){
	    timesortnlp[nname + index - 1] = &cyclenl[index];
	}
	qsort(timesortnlp, nname + ncycle, sizeof(nltype *),
	      (int (*)(const void *, const void *))totalcmp);
	for(index = 0; index < nname + ncycle; index++){
	    timesortnlp[index]->index = index + 1;
	}
	return(timesortnlp);
}

static
void
dotime(
void)
{
    uint32_t index;

	cycletime();
	for(index = 0; index < nname; index += 1){
	    timepropagate(topsortnlp[index]);
	}
}

static
void
timepropagate(
nltype *parentp)
{
    arctype	*arcp;
    nltype	*childp;
    double	share;
    double	propshare;

	if(parentp->propfraction == 0.0){
	    return;
	}
	/*
	 * Gather time from children of this parent.
	 */
	for(arcp = parentp->children; arcp; arcp = arcp->arc_childlist){
	    childp = arcp->arc_childp;
	    if(arcp->arc_count == 0){
		continue;
	    }
	    if(childp == parentp){
		continue;
	    }
	    if(childp->propfraction == 0.0){
		continue;
	    }
	    if(childp->cyclehead != childp){
		if(parentp->cycleno == childp->cycleno){
		    continue;
		}
		if(parentp->toporder <= childp->toporder){
		    fprintf(stderr, "[propagate] toporder botches\n");
		}
		childp = childp->cyclehead;
	    }
	    else{
		if(parentp->toporder <= childp->toporder){
		    fprintf(stderr, "[propagate] toporder botches\n");
		    continue;
		}
	    }
	    if(childp->ncall == 0){
		continue;
	    }
	    /*
	     * Distribute time for this arc.
	     */
	    arcp->arc_time = childp->time *
				      ( ((double)arcp->arc_count) /
					((double)childp->ncall) );
	    arcp->arc_childtime = childp->childtime *
				      ( ((double)arcp->arc_count) /
					((double)childp->ncall) );
	    share = arcp->arc_time + arcp->arc_childtime;
	    parentp->childtime += share;
	    /*
	     * ( 1 - propfraction ) gets lost along the way
	     */
	    propshare = parentp->propfraction * share;
	    /*
	     * fix things for printing
	     */
	    parentp->propchild += propshare;
	    arcp->arc_time *= parentp->propfraction;
	    arcp->arc_childtime *= parentp->propfraction;
	    /*
	     * add this share to the parent's cycle header, if any.
	     */
	    if(parentp->cyclehead != parentp){
		parentp->cyclehead->childtime += share;
		parentp->cyclehead->propchild += propshare;
	    }
#ifdef DEBUG
	    if(debug & PROPDEBUG){
		printf("[dotime] child \t");
		printname(childp);
		printf(" with %f %f %u/%u\n",
			childp->time, childp->childtime,
			arcp->arc_count, childp->ncall);
		printf("[dotime] parent\t");
		printname(parentp);
		printf("\n[dotime] share %f\n", share);
	    }
#endif
	}
}

static
void
cyclelink(
void)
{
    nltype	*nlp;
    nltype	*cyclenlp;
    int		cycle;
    nltype	*memberp;
    arctype	*arcp;

	/*
	 * Count the number of cycles, and initialze the cycle lists
	 */
	ncycle = 0;
	for(nlp = nl; nlp < npe; nlp++){
	    /*
	     * This is how you find unattached cycles
	     */
	    if(nlp->cyclehead == nlp && nlp->cnext != 0){
		ncycle += 1;
	    }
	}
	/*
	 * cyclenl is indexed by cycle number:
	 * i.e. it is origin 1, not origin 0.
	 */
	cyclenl = (nltype *)calloc(ncycle + 1, sizeof(nltype));
	if(cyclenl == NULL)
	    fatal("no room for %lu bytes of cycle headers",
		  (ncycle + 1) * sizeof(nltype));
	/*
	 * now link cycles to true cycleheads,
	 * number them, accumulate the data for the cycle
	 */
	cycle = 0;
	for(nlp = nl; nlp < npe; nlp++){
	    if(!(nlp->cyclehead == nlp && nlp->cnext != 0)){
		continue;
	    }
	    cycle += 1;
	    cyclenlp = &cyclenl[cycle];
	    cyclenlp->name = 0;		/* the name */
	    cyclenlp->value = 0;	/* the pc entry point */
	    cyclenlp->time = 0.0;	/* ticks in this routine */
	    cyclenlp->childtime = 0.0;	/* cumulative ticks in children */
	    cyclenlp->ncall = 0;	/* how many times called */
	    cyclenlp->selfcalls = 0;	/* how many calls to self */
	    cyclenlp->propfraction = 0.0;/* what % of time propagates */
	    cyclenlp->propself = 0.0;	/* how much self time propagates */
	    cyclenlp->propchild = 0.0;	/* how much child time propagates */
	    cyclenlp->printflag = TRUE;	/* should this be printed? */
	    cyclenlp->index = 0;	/* index in the graph list */
	    cyclenlp->toporder = DFN_NAN;/* graph call chain top-sort order */
	    cyclenlp->cycleno = cycle;	/* internal number of cycle on */
	    cyclenlp->cyclehead = cyclenlp;/* pointer to head of cycle */
	    cyclenlp->cnext = nlp;	/* pointer to next member of cycle */
	    cyclenlp->parents = 0;	/* list of caller arcs */
	    cyclenlp->children = 0;	/* list of callee arcs */
#ifdef DEBUG
	    if(debug & CYCLEDEBUG){
		printf("[cyclelink] ");
		printname(nlp);
		printf(" is the head of cycle %d\n", cycle);
	    }
#endif
	    /*
	     * link members to cycle header
	     */
	    for(memberp = nlp; memberp; memberp = memberp->cnext){ 
		memberp->cycleno = cycle;
		memberp->cyclehead = cyclenlp;
	    }
	    /*
	     * count calls from outside the cycle
	     * and those among cycle members
	     */
	    for(memberp = nlp; memberp; memberp = memberp->cnext){
		for(arcp = memberp->parents; arcp; arcp = arcp->arc_parentlist){
		    if(arcp->arc_parentp == memberp){
			continue;
		    }
		    if(arcp->arc_parentp->cycleno == cycle){
			cyclenlp->selfcalls += arcp->arc_count;
		    }
		    else{
			cyclenlp->ncall += arcp->arc_count;
		    }
		}
	    }
	}
}

static
void
cycletime(
void)
{
    int cycle;
    nltype *cyclenlp;
    nltype *childp;

    for(cycle = 1; cycle <= ncycle; cycle += 1){
	cyclenlp = &cyclenl[cycle];
	for(childp = cyclenlp->cnext; childp; childp = childp->cnext){
	    if(childp->propfraction == 0.0){
		/*
		 * all members have the same propfraction except those
		 * that were excluded with -E
		 */
		continue;
	    }
	    cyclenlp->time += childp->time;
	}
	cyclenlp->propself = cyclenlp->propfraction * cyclenlp->time;
    }
}

/*
 * in one top to bottom pass over the topologically sorted namelist
 * propagate:
 * 	printflag as the union of parents' printflags
 * 	propfraction as the sum of fractional parents' propfractions
 * and while we're here, sum time for functions.
 */
static
void
doflags(
void)
{
    int32_t index;
    nltype *childp;
    nltype *oldhead;

	oldhead = 0;
	for(index = nname-1; index >= 0; index -= 1){
	    childp = topsortnlp[index];
	    /*
	     * if we haven't done this function or cycle,
	     * inherit things from parent.
	     * this way, we are linear in the number of arcs
	     * since we do all members of a cycle (and the cycle itself)
	     * as we hit the first member of the cycle.
	     */
	    if(childp->cyclehead != oldhead){
		oldhead = childp->cyclehead;
		inheritflags(childp);
	    }
#ifdef DEBUG
	    if(debug & PROPDEBUG){
		printf("[doflags] ");
		printname(childp);
		printf(" inherits printflag %d and propfraction %f\n",
		       childp->printflag, childp->propfraction);
	    }
#endif
	    if(!childp->printflag){
		/*
		 * printflag is off
		 * it gets turned on by
		 * being on -f list,
		 * or there not being any -f list and not being on -e list.
		 */
		if(onlist(flist, childp->name) ||
		   (!fflag && !onlist(elist, childp->name))){
		    childp->printflag = TRUE;
		}
	    }
	    else{
		/*
		 * this function has printing parents:
		 * maybe someone wants to shut it up
		 * by putting it on -e list.  (but favor -f over -e)
		 */
		if((!onlist(flist, childp->name)) &&
		    onlist(elist, childp->name)){
		    childp->printflag = FALSE;
		}
	    }
	    if(childp->propfraction == 0.0){
		/*
		 * no parents to pass time to.
		 * collect time from children if
		 * its on -F list,
		 * or there isn't any -F list and its not on -E list.
		 */
		if(onlist(Flist, childp->name) ||
		   (!Fflag && !onlist(Elist, childp->name))){
			childp->propfraction = 1.0;
		}
	    }
	    else{
		/*
		 * it has parents to pass time to, 
		 * but maybe someone wants to shut it up
		 * by puttting it on -E list.  (but favor -F over -E)
		 */
		if(!onlist(Flist, childp->name) &&
		   onlist(Elist, childp->name)){
		    childp->propfraction = 0.0;
		}
	    }
	    childp->propself = childp->time * childp->propfraction;
	    printtime += childp->propself;
#ifdef DEBUG
	    if(debug & PROPDEBUG){
		printf("[doflags] ");
		printname(childp);
		printf(" ends up with printflag %d and propfraction %f\n",
		       childp->printflag, childp->propfraction);
		printf("time %f propself %f printtime %f\n",
		       childp->time, childp->propself, printtime);
	    }
#endif
	}
}

/*
 * check if any parent of this child
 * (or outside parents of this cycle)
 * have their print flags on and set the 
 * print flag of the child (cycle) appropriately.
 * similarly, deal with propagation fractions from parents.
 */
static
void
inheritflags(
nltype *childp)
{
    nltype *headp;
    arctype *arcp;
    nltype *parentp;
    nltype *memp;

	headp = childp->cyclehead;
	if(childp == headp){
	    /*
	     * just a regular child, check its parents
	     */
	    childp->printflag = FALSE;
	    childp->propfraction = 0.0;
	    for(arcp = childp->parents; arcp ; arcp = arcp->arc_parentlist){
		parentp = arcp->arc_parentp;
		if(childp == parentp){
		    continue;
		}
		childp->printflag |= parentp->printflag;
		/*
		 * if the child was never actually called
		 * (e.g. this arc is static (and all others are, too))
		 * no time propagates along this arc.
		 */
		if(childp->ncall){
		    childp->propfraction += parentp->propfraction *
					     (((double)arcp->arc_count) /
					      ((double)childp->ncall));
		}
	    }
	}
	else{
	    /*
	     * its a member of a cycle, look at all parents from 
	     * outside the cycle
	     */
	    headp->printflag = FALSE;
	    headp->propfraction = 0.0;
	    for(memp = headp->cnext; memp; memp = memp->cnext){
		for(arcp = memp->parents; arcp; arcp = arcp->arc_parentlist){
		    if(arcp->arc_parentp->cyclehead == headp){
			continue;
		    }
		    parentp = arcp->arc_parentp;
		    headp->printflag |= parentp->printflag;
		    /*
		     * if the cycle was never actually called
		     * (e.g. this arc is static (and all others are, too))
		     * no time propagates along this arc.
		     */
		    if(headp->ncall){
			headp->propfraction += parentp->propfraction *
						(((double)arcp->arc_count) /
						 ((double)headp->ncall));
		    }
		}
	    }
	    for(memp = headp; memp; memp = memp->cnext){
		memp->printflag = headp->printflag;
		memp->propfraction = headp->propfraction;
	    }
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/calls.c                               0100644 0001750 0001750 00000030501 12612724206 023016  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "gprof.h"
#ifdef vax
#include "vax.h"
#endif

#ifdef m68k
#include "m68k.h"
#endif

/*
 * A namelist entry to be the child of indirect calls.
 */
static nltype indirectchild = {
	"(*)" ,				/* the name */
	(uint64_t) 0 ,			/* the pc entry point */
	(uint64_t) 0 ,			/* entry point aligned to histogram */
	(double) 0.0 ,			/* ticks in this routine */
	(double) 0.0 ,			/* cumulative ticks in children */
	(uint32_t) 0 ,			/* order called */
	(int32_t) 0 ,			/* how many times called */
	(int32_t) 0 ,			/* how many calls to self */
	(double) 1.0 ,			/* propagation fraction */
	(double) 0.0 ,			/* self propagation time */
	(double) 0.0 ,			/* child propagation time */
	(enum bool) 0 ,			/* print flag */
	(int) 0 ,			/* index in the graph list */
	(int) 0 , 			/* graph call chain top-sort order */
	(int) 0 ,			/* internal number of cycle on */
	(struct nl *) &indirectchild ,	/* pointer to head of cycle */
	(struct nl *) 0 ,		/* pointer to next member of cycle */
	(arctype *) 0 ,			/* list of caller arcs */
	(arctype *) 0 			/* list of callee arcs */
};

#ifdef vax
operandenum
operandmode( modep )
    struct modebyte	*modep;
{
    uint32_t	usesreg = modep -> regfield;
    
    switch ( modep -> modefield ) {
	case 0:
	case 1:
	case 2:
	case 3:
	    return literal;
	case 4:
	    return indexed;
	case 5:
	    return reg;
	case 6:
	    return regdef;
	case 7:
	    return autodec;
	case 8:
	    return ( usesreg != PC ? autoinc : immediate );
	case 9:
	    return ( usesreg != PC ? autoincdef : absolute );
	case 10:
	    return ( usesreg != PC ? bytedisp : byterel );
	case 11:
	    return ( usesreg != PC ? bytedispdef : bytereldef );
	case 12:
	    return ( usesreg != PC ? worddisp : wordrel );
	case 13:
	    return ( usesreg != PC ? worddispdef : wordreldef );
	case 14:
	    return ( usesreg != PC ? longdisp : longrel );
	case 15:
	    return ( usesreg != PC ? longdispdef : longreldef );
    }
    /* NOTREACHED */
}

static
char *
operandname( mode )
    operandenum	mode;
{
    
    switch ( mode ) {
	case literal:
	    return "literal";
	case indexed:
	    return "indexed";
	case reg:
	    return "register";
	case regdef:
	    return "register deferred";
	case autodec:
	    return "autodecrement";
	case autoinc:
	    return "autoincrement";
	case autoincdef:
	    return "autoincrement deferred";
	case bytedisp:
	    return "byte displacement";
	case bytedispdef:
	    return "byte displacement deferred";
	case byterel:
	    return "byte relative";
	case bytereldef:
	    return "byte relative deferred";
	case worddisp:
	    return "word displacement";
	case worddispdef:
	    return "word displacement deferred";
	case wordrel:
	    return "word relative";
	case wordreldef:
	    return "word relative deferred";
	case immediate:
	    return "immediate";
	case absolute:
	    return "absolute";
	case longdisp:
	    return "long displacement";
	case longdispdef:
	    return "long displacement deferred";
	case longrel:
	    return "long relative";
	case longreldef:
	    return "long relative deferred";
    }
    /* NOTREACHED */
}

static
uint32_t
operandlength( modep )
    struct modebyte	*modep;
{
    
    switch ( operandmode( modep ) ) {
	case literal:
	case reg:
	case regdef:
	case autodec:
	case autoinc:
	case autoincdef:
	    return 1;
	case bytedisp:
	case bytedispdef:
	case byterel:
	case bytereldef:
	    return 2;
	case worddisp:
	case worddispdef:
	case wordrel:
	case wordreldef:
	    return 3;
	case immediate:
	case absolute:
	case longdisp:
	case longdispdef:
	case longrel:
	case longreldef:
	    return 5;
	case indexed:
	    return 1+operandlength( (struct modebyte *) ((char *) modep) + 1 );
    }
    /* NOTREACHED */
}

static
uint32_t
reladdr( modep )
    struct modebyte	*modep;
{
    operandenum	mode = operandmode( modep );
    char	*cp;
    short	*sp;
    int32_t	*lp;

    cp = (char *) modep;
    cp += 1;			/* skip over the mode */
    switch ( mode ) {
	default:
	    fprintf( stderr , "[reladdr] not relative address\n" );
	    return (uint32_t) modep;
	case byterel:
	    return (uint32_t) ( cp + sizeof *cp + *cp );
	case wordrel:
	    sp = (short *) cp;
	    return (uint32_t) ( cp + sizeof *sp + *sp );
	case longrel:
	    lp = (int32_t *) cp;
	    return (uint32_t) ( cp + sizeof *lp + *lp );
    }
}

findcalls( parentp , p_lowpc , p_highpc )
    nltype		*parentp;
    uint32_t		p_lowpc;
    uint32_t		p_highpc;
{
    unsigned char	*instructp;
    int32_t		length;
    nltype		*childp;
    operandenum		mode;
    operandenum		firstmode;
    uint32_t	destpc;

    if ( textspace == 0 ) {
	return;
    }
    if ( p_lowpc < s_lowpc ) {
	p_lowpc = s_lowpc;
    }
    if ( p_highpc > s_highpc ) {
	p_highpc = s_highpc;
    }
#   ifdef DEBUG
	if ( debug & CALLSDEBUG ) {
	    printf( "[findcalls] %s: 0x%x to 0x%x\n" ,
		    parentp -> name , p_lowpc , p_highpc );
	}
#   endif /* DEBUG */
    for (   instructp = textspace + p_lowpc ;
	    instructp < textspace + p_highpc ;
	    instructp += length ) {
	length = 1;
	if ( *instructp == CALLS ) {
		/*
		 *	maybe a calls, better check it out.
		 *	skip the count of the number of arguments.
		 */
#	    ifdef DEBUG
		if ( debug & CALLSDEBUG ) {
		    printf( "[findcalls]\t0x%x:calls" , instructp - textspace );
		}
#	    endif /* DEBUG */
	    firstmode = operandmode( (struct modebyte *) (instructp+length) );
	    switch ( firstmode ) {
		case literal:
		case immediate:
		    break;
		default:
		    goto botched;
	    }
	    length += operandlength( (struct modebyte *) (instructp+length) );
	    mode = operandmode( (struct modebyte *) ( instructp + length ) );
#	    ifdef DEBUG
		if ( debug & CALLSDEBUG ) {
		    printf( "\tfirst operand is %s", operandname( firstmode ) );
		    printf( "\tsecond operand is %s\n" , operandname( mode ) );
		}
#	    endif /* DEBUG */
	    switch ( mode ) {
		case regdef:
		case bytedispdef:
		case worddispdef:
		case longdispdef:
		case bytereldef:
		case wordreldef:
		case longreldef:
			/*
			 *	indirect call: call through pointer
			 *	either	*d(r)	as a parameter or local
			 *		(r)	as a return value
			 *		*f	as a global pointer
			 *	[are there others that we miss?,
			 *	 e.g. arrays of pointers to functions???]
			 */
		    addarc( parentp , &indirectchild , (uint32_t) 0 , 0);
		    length += operandlength(
				(struct modebyte *) ( instructp + length ) );
		    continue;
		case byterel:
		case wordrel:
		case longrel:
			/*
			 *	regular pc relative addressing
			 *	check that this is the address of 
			 *	a function.
			 */
		    destpc = reladdr( (struct modebyte *) (instructp+length) )
				- (uint32_t) textspace;
		    if ( destpc >= s_lowpc && destpc <= s_highpc ) {
			childp = nllookup( destpc );
#			ifdef DEBUG
			    if ( debug & CALLSDEBUG ) {
				printf( "[findcalls]\tdestpc 0x%x" , destpc );
				printf( " childp->name %s" , childp -> name );
				printf( " childp->value 0x%x\n" ,
					childp -> value );
			    }
#			endif /* DEBUG */
			if ( childp -> value == destpc ) {
				/*
				 *	a hit
				 */
			    addarc( parentp , childp , (uint32_t) 0 , 0);
			    length += operandlength( (struct modebyte *)
					    ( instructp + length ) );
			    continue;
			}
			goto botched;
		    }
			/*
			 *	else:
			 *	it looked like a calls,
			 *	but it wasn't to anywhere.
			 */
		    goto botched;
		default:
		botched:
			/*
			 *	something funny going on.
			 */
#		    ifdef DEBUG
			if ( debug & CALLSDEBUG ) {
			    printf( "[findcalls]\tbut it's a botch\n" );
			}
#		    endif /* DEBUG */
		    length = 1;
		    continue;
	    }
	}
    }
}
#endif /* vax */

#ifdef m68k
void
findcalls(
nltype *parentp,
uint32_t p_lowpc,
uint32_t p_highpc)
{
    unsigned short	*instructp;
    int32_t		length;
    nltype		*childp;
    uint32_t		destpc;

	if(textspace == NULL){
	    return;
	}
	if(p_lowpc < sample_sets->s_lowpc){
	    p_lowpc = sample_sets->s_lowpc;
	}
	if(p_highpc > sample_sets->s_highpc){
	    p_highpc = sample_sets->s_highpc;
	}
#ifdef DEBUG
	if(debug & CALLSDEBUG){
	    printf("[findcalls] %s: 0x%x to 0x%x\n", parentp->name,
		   (unsigned int)p_lowpc, (unsigned int)p_highpc);
	}
#endif
	for(instructp = (unsigned short *)(textspace + p_lowpc);
	    instructp < (unsigned short *)(textspace + p_highpc);
	    instructp += length){

	    length = 1;			/* 1 word */

	    if((*instructp & BSR_MASK) == BSR_OP){
		/* bsr instruction */
		short disp;

		if(*instructp & 0xff)
		    disp = (char)(*instructp & 0xff);
		else{
		    length = 2;	/* 2 words */
		    disp = instructp[1];
		}
		destpc = (uint32_t)instructp + disp + 2 - 
			 (uint32_t)textspace;
gotdestpc:
		if(destpc >= sample_sets->s_lowpc &&
		   destpc <= sample_sets->s_highpc){
		    childp = nllookup(destpc);
#ifdef DEBUG
		    if(debug & CALLSDEBUG){
			printf("[findcalls]\tdestpc 0x%x",
			       (unsigned int)destpc);
			printf("childp->name %s", childp->name);
			printf("childp->value 0x%x\n",
			       (unsigned int)childp->value );
		    }
#endif
		    if(childp->value == destpc){
			/*
			 * a hit
			 */
			addarc(parentp, childp, 0, 0);
			continue;
		    }
		    goto botched;
		}
	    }
	    else if((*instructp & JBSR_MASK) == JBSR_OP){
		/* jbsr instruction */
		if((*instructp & 0x38) != 0x38) {
indirect:
		    addarc(parentp, &indirectchild, 0, 0);
		    continue;
		}
		switch(*instructp & 7) {
		case 0:			/* Abs.W */
		    destpc = instructp[1];
		    length = 2;
		    goto gotdestpc;
		case 1:			/* Abs.L */
		    destpc = (instructp[1] << 16) + (instructp[2] & 0xffff);
		    length = 3;
		    goto gotdestpc;
		default:
		    goto indirect;
		}
	    }
	    else
		continue;
botched:
	    /*
	     *	something funny going on.
	     */
#ifdef DEBUG
	    if(debug & CALLSDEBUG){
		printf("[findcalls]\tbut it's a botch\n");
	    }
#endif
	    length = 1;
	}
}
#endif /* m68k */
                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/dfn.c                                 0100644 0001750 0001750 00000021615 12612724206 022475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: dfn.c,v 1.2 1996/06/26 05:33:49 deraadt Exp $	*/
/*	$NetBSD: dfn.c,v 1.5 1995/04/19 07:15:56 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <stdio.h>
#include <stdlib.h>
#include "stuff/errors.h"
#include "gprof.h"

#define	DFN_DEPTH	1000
struct dfnstruct {
    nltype	*nlentryp;
    int		cycletop;
};
typedef struct dfnstruct dfntype;

static dfntype	dfn_stack[DFN_DEPTH] = { {0} };
static int dfn_depth = 0;

static int dfn_counter = DFN_NAN;

static void dfn_pre_visit(
    nltype *parentp);
static enum bool dfn_numbered(
    nltype *childp);
static enum bool dfn_busy(
    nltype *childp);
static void dfn_findcycle(
    nltype *childp);
static void dfn_self_cycle(
    nltype *parentp);
static void dfn_self_cycle(
    nltype *parentp);
static void dfn_post_visit(
    nltype *parentp);

/*
 * given this parent, depth first number its children.
 */
void
dfn(
nltype *parentp)
{
    arctype *arcp;

#ifdef DEBUG
	if(debug & DFNDEBUG){
	    printf("[dfn] dfn(");
	    printname(parentp);
	    printf(")\n");
	}
#endif
	/*
	 * if we're already numbered, no need to look any furthur.
	 */
	if(dfn_numbered(parentp)){
	    return;
	}
	/*
	 * if we're already busy, must be a cycle
	 */
	if(dfn_busy(parentp)){
	    dfn_findcycle(parentp);
	    return;
	}
	/*
	 * visit yourself before your children
	 */
	dfn_pre_visit(parentp);
	/*
	 * visit children
	 */
	for(arcp = parentp->children; arcp ; arcp = arcp->arc_childlist){
	    dfn(arcp->arc_childp);
	}
	/*
	 * visit yourself after your children
	 */
	dfn_post_visit(parentp);
}

/*
 * push a parent onto the stack and mark it busy
 */
static
void
dfn_pre_visit(
nltype *parentp)
{
	dfn_depth += 1;
	if(dfn_depth >= DFN_DEPTH){
	    fprintf(stderr, "[dfn] out of my depth (dfn_stack overflow)\n");
	    exit(1);
	}
	dfn_stack[dfn_depth].nlentryp = parentp;
	dfn_stack[dfn_depth].cycletop = dfn_depth;
	parentp->toporder = DFN_BUSY;
#ifdef DEBUG
	if(debug & DFNDEBUG){
	    printf("[dfn_pre_visit]\t\t%d:", dfn_depth);
	    printname(parentp);
	    printf("\n");
	}
#endif
}

/*
 * are we already numbered?
 */
static
enum bool
dfn_numbered(
nltype *childp)
{
    
	return(childp->toporder != DFN_NAN && childp->toporder != DFN_BUSY);
}

/*
 * are we already busy?
 */
static
enum bool
dfn_busy(
nltype *childp)
{

    if(childp->toporder == DFN_NAN){
	return(FALSE);
    }
    return(TRUE);
}

/*
 * MISSING: an explanation
 */
static
void
dfn_findcycle(
nltype *childp)
{
    int cycletop;
    nltype *cycleheadp;
    nltype *tailp;
    int index;

	cycleheadp = NULL;
	for(cycletop = dfn_depth; cycletop > 0; cycletop -= 1){
	    cycleheadp = dfn_stack[cycletop].nlentryp;
	    if(childp == cycleheadp){
		break;
	    }
	    if(childp->cyclehead != childp && childp->cyclehead == cycleheadp){
		break;
	    }
	}
	if(cycletop <= 0){
	    fatal("[dfn_findcycle] couldn't find head of cycle");
	}
#ifdef DEBUG
	if(debug & DFNDEBUG){
	    printf("[dfn_findcycle] dfn_depth %d cycletop %d ",
		   dfn_depth, cycletop);
	    printname(cycleheadp);
	    printf("\n");
	}
#endif
	if(cycletop == dfn_depth){
	    /*
	     * this is previous function, e.g. this calls itself
	     * sort of boring
	     */
	    dfn_self_cycle(childp);
	}
	else{
	    /*
	     * glom intervening functions that aren't already
	     * glommed into this cycle.
	     * things have been glommed when their cyclehead field
	     * points to the head of the cycle they are glommed into.
	     */
	    for(tailp = cycleheadp; tailp->cnext; tailp = tailp->cnext){
		/* void: chase down to tail of things already glommed */
#ifdef DEBUG
		if(debug & DFNDEBUG){
		    printf("[dfn_findcycle] tail ");
		    printname(tailp);
		    printf("\n");
		}
#endif /* DEBUG */
	    }
	    /*
	     * if what we think is the top of the cycle
	     * has a cyclehead field, then it's not really the
	     * head of the cycle, which is really what we want
	     */	
	    if(cycleheadp->cyclehead != cycleheadp){
		cycleheadp = cycleheadp->cyclehead;
#ifdef DEBUG
		if(debug & DFNDEBUG){
		    printf("[dfn_findcycle] new cyclehead ");
		    printname(cycleheadp);
		    printf("\n");
		}
#endif
	    }
	    for(index = cycletop + 1; index <= dfn_depth; index += 1){
		childp = dfn_stack[index].nlentryp;
		if(childp->cyclehead == childp){
		    /*
		     * not yet glommed anywhere, glom it
		     * and fix any children it has glommed
		     */
		    tailp -> cnext = childp;
		    childp -> cyclehead = cycleheadp;
#ifdef DEBUG
		    if(debug & DFNDEBUG){
			printf("[dfn_findcycle] glomming ");
			printname(childp);
			printf(" onto ");
			printname(cycleheadp);
			printf("\n");
		    }
#endif
		    for(tailp = childp; tailp->cnext; tailp = tailp->cnext){
			tailp->cnext->cyclehead = cycleheadp;
#ifdef DEBUG
			if(debug & DFNDEBUG){
			    printf("[dfn_findcycle] and its tail ");
			    printname(tailp->cnext);
			    printf(" onto ");
			    printname(cycleheadp);
			    printf("\n");
			}
#endif
		    }
		}
		else if(childp->cyclehead != cycleheadp /* firewall */ ){
		    fprintf(stderr,
			    "[dfn_busy] glommed, but not to cyclehead\n");
		}
	    }
	}
}

/*
 * deal with self-cycles
 * for lint: ARGSUSED
 */
static
void
dfn_self_cycle(
nltype *parentp)
{
	/*
	 * since we are taking out self-cycles elsewhere
	 * no need for the special case, here.
	 */
#ifdef DEBUG
	if(debug & DFNDEBUG){
	    printf("[dfn_self_cycle] ");
	    printname(parentp);
	    printf("\n");
	}
#endif
}

/*
 * visit a node after all its children
 * [MISSING: an explanation]
 * and pop it off the stack
 */
static
void
dfn_post_visit(
nltype *parentp)
{
    nltype *memberp;

#ifdef DEBUG
	if(debug & DFNDEBUG){
	    printf("[dfn_post_visit]\t%d: ", dfn_depth);
	    printname(parentp);
	    printf("\n");
	}
#endif
	/*
	 * number functions and things in their cycles
	 * unless the function is itself part of a cycle
	 */
	if(parentp->cyclehead == parentp){
	    dfn_counter += 1;
	    for(memberp = parentp; memberp; memberp = memberp->cnext){
		memberp->toporder = dfn_counter;
#ifdef DEBUG
		if(debug & DFNDEBUG){
		    printf("[dfn_post_visit]\t\tmember ");
		    printname(memberp);
		    printf(" -> toporder = %d\n", dfn_counter);
		}
#endif
	    }
	}
	else{
#ifdef DEBUG
	    if(debug & DFNDEBUG){
		printf("[dfn_post_visit]\t\tis part of a cycle\n");
	    }
#endif
	}
	dfn_depth -= 1;
}
                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/getnfile.c                            0100644 0001750 0001750 00000054203 12612724206 023522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdlib.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/stab.h>
#ifdef __OPENSTEP__
#include <mach-o/rld.h>
#endif /* defined(__OPENSTEP__) */
#include "stuff/ofile.h"
#include "stuff/allocate.h"
#include "stuff/errors.h"
#include "gprof.h"

struct shlib_text_range *shlib_text_ranges = NULL;
uint32_t nshlib_text_ranges = 0;

static struct ofile ofile = { 0 };

#ifdef __OPENSTEP__
static uint32_t link_edit_address;
static uint32_t address_func(
    uint32_t size,
    uint32_t headers_size);
#endif

static void count_func_symbols(
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strsize);

static void load_func_symbols(
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strsize,
    uint64_t vmaddr_slide);

static enum bool funcsymbol(
    uint8_t n_type,
    uint8_t n_sect,
    char *name);

static int valcmp(
    nltype *p1,
    nltype *p2);

static void count_N_SO_stabs(
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strsize);

static void load_files(
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strsize);

static struct arch_flag host_arch_flag;

void
getnfile(
void)
{
    uint32_t i, j, ncmds;
    uint64_t text_highpc;
    struct load_command *lc;
    struct segment_command *sg;
    struct segment_command_64 *sg64;
    struct section *s;
    struct section_64 *s64;
    struct symtab_command *st;
    struct nlist *symbols;
    struct nlist_64 *symbols64;
#ifdef notdef
    struct ofile lib_ofile;
    uint32_t k;
    struct fvmlib_command *fl;
    struct load_command *lib_lc;
    struct symtab_command *lib_st;
    char *lib_name;
#endif

	nname = 0;
	n_files = 0;

	if(get_arch_from_host(&host_arch_flag, NULL) == 0)
	    fatal("can't determine the host architecture");

	if(ofile_map(a_outname, NULL, NULL, &ofile, FALSE) == FALSE)
	    return;

	/*
	 * Pick the host architecture first if it is there, or the 64-bit
	 * version of the host architecture next if it is there.
	 */
	if(ofile.file_type == OFILE_FAT){
	    (void)ofile_first_arch(&ofile);
	    do{
		if(host_arch_flag.cputype == ofile.mh_cputype)
		    goto good;
	    }while(ofile_next_arch(&ofile) == TRUE);

	    (void)ofile_first_arch(&ofile);
	    do{
		if((host_arch_flag.cputype | CPU_ARCH_ABI64) ==
		   ofile.mh_cputype){
		    host_arch_flag.cputype |= CPU_ARCH_ABI64;
		    goto good;
		}
	    }while(ofile_next_arch(&ofile) == TRUE);

	    error("file: %s does not contain the host architecture", a_outname);
	    return;
	}
	else if(ofile.file_type == OFILE_ARCHIVE){
	    error("file: %s is not an Mach-O file executable", a_outname);
	    return;
	}
	else if(ofile.file_type == OFILE_Mach_O){
	    if(host_arch_flag.cputype == ofile.mh_cputype)
		goto good;
	    if((host_arch_flag.cputype | CPU_ARCH_ABI64) == ofile.mh_cputype){
		host_arch_flag.cputype |= CPU_ARCH_ABI64;
		goto good;
	    }
	    error("file: %s is not of the host architecture", a_outname);
	    return;
	}
	else{ /* ofile.file_type == OFILE_UNKNOWN */
	    error("file: %s is not an Mach-O file executable", a_outname);
	    return;
	}
good:

	if((ofile.mh == NULL && ofile.mh64 == NULL) ||
	   (ofile.mh_filetype != MH_EXECUTE &&
	    ofile.mh_filetype != MH_DYLIB &&
	    ofile.mh_filetype != MH_DYLINKER))
	    fatal("file: %s is not a Mach-O executable file", a_outname);

	/*
	 * Pass 1 count symbols and files.
	 */
	st = NULL;
	lc = ofile.load_commands;
	if(ofile.mh != NULL){
	    text_highpc = 0xfffffffe;
	    ncmds = ofile.mh->ncmds;
	}
	else{
	    text_highpc = 0xfffffffffffffffeULL;
	    ncmds = ofile.mh64->ncmds;
	}
	for(i = 0; i < ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		s = (struct section *)
		      ((char *)sg + sizeof(struct segment_command));
		for(j = 0; j < sg->nsects; j++){
		    if(strcmp(s->sectname, SECT_TEXT) == 0 &&
		       strcmp(s->segname, SEG_TEXT) == 0){
			textspace = (unsigned char *)ofile.object_addr +
				    s->offset;
			text_highpc = s->addr + s->size;
		    }
		    s++;
		}
	    }
	    else if(lc->cmd == LC_SEGMENT_64){
		sg64 = (struct segment_command_64 *)lc;
		s64 = (struct section_64 *)
		      ((char *)sg64 + sizeof(struct segment_command_64));
		for(j = 0; j < sg64->nsects; j++){
		    if(strcmp(s64->sectname, SECT_TEXT) == 0 &&
		       strcmp(s64->segname, SEG_TEXT) == 0){
			textspace = (unsigned char *)ofile.object_addr +
				    s64->offset;
			text_highpc = s64->addr + s64->size;
		    }
		    s64++;
		}
	    }
#ifdef notdef
	    else if(lc->cmd == LC_LOADFVMLIB){
		fl = (struct fvmlib_command *)lc;
		lib_name = (char *)fl + fl->fvmlib.name.offset;
		if(ofile_map(lib_name, &host_arch_flag, NULL, &lib_ofile,
			     FALSE) == FALSE)
		    goto done1;
		if(lib_ofile.mh == NULL || lib_ofile.mh->filetype != MH_FVMLIB){
		    warning("file: %s is not a shared library file", lib_name);
		    goto done_and_unmap1;
		}
		lib_st = NULL;
		lib_lc = lib_ofile.load_commands;
		for(j = 0; j < lib_ofile.mh->ncmds; j++){
		    if(lib_st == NULL && lib_lc->cmd == LC_SYMTAB){
			lib_st = (struct symtab_command *)lib_lc;
			count_func_symbols((struct nlist *)
				(lib_ofile.object_addr + lib_st->symoff),
				lib_st->nsyms,
				lib_ofile.object_addr + lib_st->stroff,
				lib_st->strsize);
			break;
		    }
		    else if(lib_lc->cmd == LC_SEGMENT){
			sg = (struct segment_command *)lib_lc;
			s = (struct section *)
			      ((char *)sg + sizeof(struct segment_command));
			for(k = 0; k < sg->nsects; k++){
			    if(strcmp(s->sectname, SECT_TEXT) == 0 &&
			       strcmp(s->segname, SEG_TEXT) == 0){
				shlib_text_ranges =
				    reallocate(shlib_text_ranges,
					       (nshlib_text_ranges + 1) *
					       sizeof(struct shlib_text_range));
				shlib_text_ranges[nshlib_text_ranges].lowpc = 
				    s->addr;
				shlib_text_ranges[nshlib_text_ranges].highpc = 
				    s->addr + s->size;
				nshlib_text_ranges++;
			    }
			    s++;
			}
		    }
		    lib_lc = (struct load_command *)
				((char *)lib_lc + lib_lc->cmdsize);
		}
done_and_unmap1:
		ofile_unmap(&lib_ofile);
done1:		;
	    }
#endif
	    else if(st == NULL && lc->cmd == LC_SYMTAB){
		st = (struct symtab_command *)lc;
		if(ofile.mh != NULL){
		    symbols = (struct nlist *)
			      (ofile.object_addr + st->symoff);
		    symbols64 = NULL;
		}
		else{
		    symbols64 = (struct nlist_64 *)
				(ofile.object_addr + st->symoff);
		    symbols = NULL;
		}
		count_func_symbols(symbols, symbols64, st->nsyms,
				   ofile.object_addr + st->stroff, st->strsize);
		count_N_SO_stabs(symbols, symbols64, st->nsyms,
				 ofile.object_addr + st->stroff, st->strsize);
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}

	if(nname == 0)
	    fatal("executable file %s: has no symbols", a_outname);
	/*
	 * Allocate the data structures for the symbols and files.
	 */
	nl = (nltype *)calloc(nname + 2, sizeof(nltype));
	if(nl == NULL)
	    fatal("No room for %lu bytes of symbol table\n",
		  (nname + 2) * sizeof(nltype));
	npe = nl;
	files = (struct file *)calloc(n_files/2, sizeof(struct file));
	if(files == NULL)
	    fatal("No room for %lu bytes of file table\n",
		  n_files/2 * sizeof(struct file));
	n_files = 0;

	/*
	 * Pass 2 load symbols and files.
	 */
	if(st != NULL){
	    if(ofile.mh != NULL){
		symbols = (struct nlist *)
			  (ofile.object_addr + st->symoff);
		symbols64 = NULL;
	    }
	    else{
		symbols64 = (struct nlist_64 *)
			    (ofile.object_addr + st->symoff);
		symbols = NULL;
	    }
	    load_func_symbols(symbols, symbols64, st->nsyms,
			      ofile.object_addr + st->stroff, st->strsize, 0);
	    load_files(symbols, symbols64, st->nsyms,
		       ofile.object_addr + st->stroff, st->strsize);
	}
#ifdef notdef
	lc = ofile.load_commands;
	for(i = 0; i < ofile.mh->ncmds; i++){
	    if(lc->cmd == LC_LOADFVMLIB){
		fl = (struct fvmlib_command *)lc;
		lib_name = (char *)fl + fl->fvmlib.name.offset;
		if(ofile_map(lib_name, &host_arch_flag, NULL, &lib_ofile, 
			     FALSE) == TRUE){
		    lib_st = NULL;
		    lib_lc = lib_ofile.load_commands;
		    for(j = 0; j < lib_ofile.mh->ncmds; j++){
			lib_lc = (struct load_command *)
				    ((char *)lib_lc + lib_lc->cmdsize);
			if(lib_st == NULL && lib_lc->cmd == LC_SYMTAB){
			    lib_st = (struct symtab_command *)lib_lc;
			    load_func_symbols((struct nlist *)
				    (lib_ofile.object_addr + lib_st->symoff),
				    lib_st->nsyms,
				    lib_ofile.object_addr + lib_st->stroff,
				    lib_st->strsize, 0);
			    break;
			}
		    }
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
#endif

	npe->value = text_highpc;
	npe->name = "past end of text";
	npe++;
	nname++;

	if(ofile.mh != NULL)
	    npe->value = npe->svalue = 0xffffffff;
	else
	    npe->value = npe->svalue = 0xffffffffffffffffULL;
	npe->name = "top of memory";

	qsort(nl, nname, sizeof(nltype),
	      (int (*)(const void *, const void *))valcmp);
#ifdef DEBUG
	if(debug & AOUTDEBUG){
	    for(i = 0; i < nname; i++){
		printf("[getnfile] ");
		if(ofile.mh != NULL)
		    printf("0x%08x", (unsigned int)nl[i].value);
		else
		    printf("%016llx", nl[i].value);
		printf("\t%s\n", nl[i].name);
	    }
	}
#endif /* DEBUG */
}

#ifdef __OPENSTEP__
void
get_rld_state_symbols(
void)
{
    uint32_t i, j, save_nname;
    NXStream *stream;
    struct mach_header **headers;
    char *object_addr;
    struct load_command *lc;
    struct symtab_command *st;

	if(grld_nloaded_states == 0)
	    return;
	headers = allocate(grld_nloaded_states * sizeof(struct mach_header *));

	/*
	 * Load the a_outname file as the base file.
	 */
	stream = NXOpenFile(fileno(stdout), NX_WRITEONLY);
	if(rld_load_basefile(stream, a_outname) == 0){
	    NXFlush(stream);
	    fflush(stdout);
	    fatal("can't load: %s as base file", a_outname);
	}
	/*
	 * Preform an rld_load() for each state at the state's address.
	 */
	for(i = 0; i < grld_nloaded_states; i++){
	    link_edit_address = (uint32_t)grld_loaded_state[i].header_addr;
	    rld_address_func(address_func);
	    if(rld_load(stream, &(headers[i]),
			grld_loaded_state[i].object_filenames,
			RLD_DEBUG_OUTPUT_FILENAME) == 0){
		NXFlush(stream);
		fflush(stdout);
		fatal("rld_load() failed");
	    }
	}

	/*
	 * Pass 1 count symbols
	 */
	save_nname = nname;
	for(i = 0; i < grld_nloaded_states; i++){
	    st = NULL;
	    object_addr = (char *)headers[i];
	    lc = (struct load_command *)
		 (object_addr + sizeof(struct mach_header));
	    for(j = 0; j < headers[i]->ncmds; j++){
		if(st == NULL && lc->cmd == LC_SYMTAB){
		    st = (struct symtab_command *)lc;
		    count_func_symbols((struct nlist *)
				       (object_addr + st->symoff),
				       st->nsyms,
				       object_addr + st->stroff,
				       st->strsize);
		}
		lc = (struct load_command *)((char *)lc + lc->cmdsize);
	    }
	}
	/*
	 * Reallocate the data structures for the symbols.
	 */
	nl = (nltype *)realloc(nl, (nname + 1) * sizeof(nltype));
	if(nl == NULL)
	    fatal("No room for %lu bytes of symbol table\n",
		  (nname + 1) * sizeof(nltype));
	npe = nl + (save_nname + 1);
	memset(npe, '\0', (nname - save_nname) * sizeof(nltype));
	/*
	 * Pass 2 load symbols.
	 */
	for(i = 0; i < grld_nloaded_states; i++){
	    st = NULL;
	    object_addr = (char *)headers[i];
	    lc = (struct load_command *)
		 (object_addr + sizeof(struct mach_header));
	    for(j = 0; j < headers[i]->ncmds; j++){
		if(st == NULL && lc->cmd == LC_SYMTAB){
		    st = (struct symtab_command *)lc;
		    load_func_symbols((struct nlist *)
				      (object_addr + st->symoff),
				      st->nsyms,
				      object_addr + st->stroff,
				      st->strsize,
				      0);
		}
		lc = (struct load_command *)((char *)lc + lc->cmdsize);
	    }
	}
#ifdef DEBUG
	if(debug & RLDDEBUG){
	    for(i = save_nname + 1; i < nname + 1; i++){
		printf("[get_rld_state_symbols] 0x%08x\t%s\n",
			(unsigned int)nl[i].value, nl[i].name);
	    }
	}
#endif /* DEBUG */
	/*
	 * Resort the symbol table.
	 */
	qsort(nl, nname + 1, sizeof(nltype),
	      (int (*)(const void *, const void *))valcmp);
	free(headers);
}

static
uint32_t
address_func(
uint32_t size,
uint32_t headers_size)
{
	return(link_edit_address);
}
#endif /* defined(__OPENSTEP__) */

void
get_dyld_state_symbols(
void)
{
    uint32_t i, j, save_nname, ncmds;
    struct ofile *ofiles;
    struct load_command *lc;
    struct segment_command *sg;
    struct segment_command_64 *sg64;
    struct symtab_command *st;
    struct nlist *symbols;
    struct nlist_64 *symbols64;

	if(image_count == 0)
	    return;
	/*
	 * Create an ofile for each image.
	 */
	ofiles = allocate(image_count * sizeof(struct ofile));
	for(i = 0; i < image_count; i++){
	    if(ofile_map(dyld_images[i].name, &host_arch_flag, NULL, ofiles + i,
			 FALSE) == 0)
		fatal("ofile_map() failed");
	    if(ofiles[i].mh == NULL && ofiles[i].mh64 == NULL)
		fatal("file from dyld loaded state: %s is not a Mach-O file",
		      dyld_images[i].name);
	}

	/*
	 * Pass 1 count symbols
	 */
	save_nname = nname;
	for(i = 0; i < image_count; i++){
	    st = NULL;
	    lc = ofiles[i].load_commands;
	    if(ofiles[i].mh != NULL)
		ncmds = ofiles[i].mh->ncmds;
	    else
		ncmds = ofiles[i].mh64->ncmds;
	    for(j = 0; j < ncmds; j++){
		if(st == NULL && lc->cmd == LC_SYMTAB){
		    st = (struct symtab_command *)lc;
		    if(ofiles[i].mh != NULL){
			symbols = (struct nlist *)
				  (ofiles[i].object_addr + st->symoff);
			symbols64 = NULL;
		    }
		    else{
			symbols64 = (struct nlist_64 *)
				    (ofiles[i].object_addr + st->symoff);
			symbols = NULL;
		    }
		    count_func_symbols(symbols, symbols64, st->nsyms,
				       ofiles[i].object_addr + st->stroff,
				       st->strsize);
		}
		if(dyld_images[i].image_header != 0 &&
		   dyld_images[i].vmaddr_slide == 0){
		    if(lc->cmd == LC_SEGMENT){
			sg = (struct segment_command *)lc;
			if(sg->filesize != 0){
			    dyld_images[i].vmaddr_slide = 
				dyld_images[i].image_header - sg->vmaddr;
			}
		    }
		    else if(lc->cmd == LC_SEGMENT_64){
			sg64 = (struct segment_command_64 *)lc;
			if(sg64->filesize != 0){
			    dyld_images[i].vmaddr_slide = 
				dyld_images[i].image_header - sg64->vmaddr;
			}
		    }
		}
		lc = (struct load_command *)((char *)lc + lc->cmdsize);
	    }
	}
	/*
	 * Reallocate the data structures for the symbols.
	 */
	nl = (nltype *)realloc(nl, (nname + 1) * sizeof(nltype));
	if(nl == NULL)
	    fatal("No room for %lu bytes of symbol table\n",
		  (nname + 1) * sizeof(nltype));
	npe = nl + (save_nname + 1);
	memset(npe, '\0', (nname - save_nname) * sizeof(nltype));
	/*
	 * Pass 2 load symbols.
	 */
	for(i = 0; i < image_count; i++){
	    st = NULL;
	    lc = ofiles[i].load_commands;
	    if(ofiles[i].mh != NULL)
		ncmds = ofiles[i].mh->ncmds;
	    else
		ncmds = ofiles[i].mh64->ncmds;
	    for(j = 0; j < ncmds; j++){
		if(st == NULL && lc->cmd == LC_SYMTAB){
		    st = (struct symtab_command *)lc;
		    if(ofiles[i].mh != NULL){
			symbols = (struct nlist *)
				  (ofiles[i].object_addr + st->symoff);
			symbols64 = NULL;
		    }
		    else{
			symbols64 = (struct nlist_64 *)
				    (ofiles[i].object_addr + st->symoff);
			symbols = NULL;
		    }
		    load_func_symbols(symbols, symbols64, st->nsyms,
				      ofiles[i].object_addr + st->stroff,
				      st->strsize,
				      dyld_images[i].vmaddr_slide);
		}
		lc = (struct load_command *)((char *)lc + lc->cmdsize);
	    }
	}
#ifdef DEBUG
	if(debug & DYLDDEBUG){
	    for(i = save_nname + 1; i < nname + 1; i++){
		printf("[get_dyld_state_symbols] ");
		if(ofiles[0].mh != NULL)
		    printf("0x%08x", (unsigned int)nl[i].value);
		else
		    printf("%016llx", nl[i].value);
		printf("\t%s\n", nl[i].name);
	    }
	}
#endif /* DEBUG */
	/*
	 * Resort the symbol table.
	 */
	qsort(nl, nname + 1, sizeof(nltype),
	      (int (*)(const void *, const void *))valcmp);
	free(ofiles);
}

static
void
count_func_symbols(
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strsize)
{
    uint32_t i;
    uint32_t n_strx;
    uint8_t n_type;
    uint8_t n_sect;

	for(i = 0; i < nsymbols; i++){
	    if(symbols != NULL){
		n_strx = symbols[i].n_un.n_strx;
		n_type = symbols[i].n_type;
		n_sect = symbols[i].n_sect;
	    }
	    else{
		n_strx = symbols64[i].n_un.n_strx;
		n_type = symbols64[i].n_type;
		n_sect = symbols64[i].n_sect;
	    }
	    if(n_strx != 0 && n_strx < strsize){
		if(funcsymbol(n_type, n_sect, strings + n_strx))
		    nname++;
	    }
	}
}

static
void
load_func_symbols(
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strsize,
uint64_t vmaddr_slide)
{
    uint32_t i;
    uint32_t n_strx;
    uint8_t n_type;
    uint8_t n_sect;
    uint64_t n_value;

	for(i = 0; i < nsymbols; i++){
	    if(symbols != NULL){
		n_strx = symbols[i].n_un.n_strx;
		n_type = symbols[i].n_type;
		n_sect = symbols[i].n_sect;
		n_value = symbols[i].n_value;
	    }
	    else{
		n_strx = symbols64[i].n_un.n_strx;
		n_type = symbols64[i].n_type;
		n_sect = symbols64[i].n_sect;
		n_value = symbols64[i].n_value;
	    }
	    if(n_strx != 0 && n_strx < strsize){
		if(funcsymbol(n_type, n_sect, strings + n_strx)){
		    npe->value = n_value + vmaddr_slide;
		    npe->name = strings + n_strx;
		    npe++;
		}
	    }
	}
}

static
enum bool
funcsymbol(
uint8_t n_type,
uint8_t n_sect,
char *name)
{
    int type;

	/*
	 *	must be a text symbol,
	 *	and static text symbols don't qualify if aflag set.
	 */
	if(n_type & N_STAB)
	    return(FALSE);
	type = n_type & N_TYPE;
	if(type == N_SECT && n_sect == 1)
	    type = N_TEXT;
	if(type != N_TEXT)
	    return FALSE;
	if((!(n_type & N_EXT)) && aflag)
	    return(FALSE);
	/*
	 * can't have any `funny' characters in name,
	 * where `funny' includes	`.', .o file names
	 *			and	`$', pascal labels.
	 */
	for( ; *name ; name += 1 ){
	    if(*name == '.' || *name == '$'){
		return(FALSE);
	    }
	}
	return(TRUE);
}

static
int
valcmp(
nltype *p1,
nltype *p2)
{
	if(p1->value < p2->value){
	    return(LESSTHAN);
	}
	if(p1->value > p2->value){
	    return(GREATERTHAN);
	}
	return(EQUALTO);
}

static
void
count_N_SO_stabs(
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strsize)
{
    uint32_t i, len;
    char *name;
    uint32_t n_strx;
    uint8_t n_type;
    uint64_t n_value;

	for(i = 0; i < nsymbols; i++){
	    if(symbols != NULL){
		n_strx = symbols[i].n_un.n_strx;
		n_type = symbols[i].n_type;
		n_value = symbols[i].n_value;
	    }
	    else{
		n_strx = symbols64[i].n_un.n_strx;
		n_type = symbols64[i].n_type;
		n_value = symbols64[i].n_value;
	    }
	    if(n_type == N_SO){
		/* skip the N_SO for the directory name that ends in a '/' */
		if(n_strx != 0 && n_strx < strsize){
		    name = strings + n_strx;
		    len = strlen(name);
		    if(len != 0 && name[len-1] == '/')
			continue;
		}
		n_files++;
	    }
	}
}

static
void
load_files(
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strsize)
{
    uint32_t i;
    char *s, *name;
    int len;
    int oddeven;
    uint32_t n_strx;
    uint8_t n_type;
    uint64_t n_value;

	oddeven = 0;
	for(i = 0; i < nsymbols; i++){
	    if(symbols != NULL){
		n_strx = symbols[i].n_un.n_strx;
		n_type = symbols[i].n_type;
		n_value = symbols[i].n_value;
	    }
	    else{
		n_strx = symbols64[i].n_un.n_strx;
		n_type = symbols64[i].n_type;
		n_value = symbols64[i].n_value;
	    }
	    if(n_type == N_SO){
		/* skip the N_SO for the directory name that ends in a '/' */
		if(n_strx != 0 && n_strx < strsize){
		    name = strings + n_strx;
		    len = strlen(name);
		    if(len != 0 && name[len-1] == '/')
			continue;
		}
		if(oddeven){
		    files[n_files++].lastpc = n_value;
		    oddeven = 0;
		}
		else {
		    s = strings + n_strx;
		    len = strlen(s);
		    if(len > 0)
			s[len-1] = 'o';
		    files[n_files].name = files[n_files].what_name = s;
		    files[n_files].firstpc = n_value; 
		    oddeven = 1;
		}
	    }
	}
#ifdef notdef
	for(i = 0; i < n_files; i++){
	    fprintf(stderr, "files[%lu] firstpc = 0x%x name = %s\n", i,
		    (unsigned int)(files[i].firstpc), files[i].name);
	}
#endif
}

void
get_text_min_max(
uint64_t *text_min,
uint64_t *text_max)
{
    uint32_t i, j, ncmds;
    struct load_command *lc;
    struct segment_command *sg;
    struct segment_command_64 *sg64;
    struct section *s;
    struct section_64 *s64;

	*text_min = 0;
	if(ofile.mh != NULL){
	    *text_max = 0xffffffff;
	    ncmds = ofile.mh->ncmds;
	}
	else{
	    *text_max = 0xffffffffffffffffULL;
	    ncmds = ofile.mh64->ncmds;
	}

	lc = ofile.load_commands;
	for (i = 0; i < ncmds; i++){
	    if(lc->cmd == LC_SEGMENT){
		sg = (struct segment_command *)lc;
		s = (struct section *)
		      ((char *)sg + sizeof(struct segment_command));
		for(j = 0; j < sg->nsects; j++){
		    if(strcmp(s->sectname, SECT_TEXT) == 0 &&
		       strcmp(s->segname, SEG_TEXT) == 0){
			*text_min = s->addr;
			*text_max = s->addr + s->size;
			return;
		    }
		    s++;
		}
	    }
	    else if(lc->cmd == LC_SEGMENT_64){
		sg64 = (struct segment_command_64 *)lc;
		s64 = (struct section_64 *)
		      ((char *)sg64 + sizeof(struct segment_command_64));
		for(j = 0; j < sg64->nsects; j++){
		    if(strcmp(s64->sectname, SECT_TEXT) == 0 &&
		       strcmp(s64->segname, SEG_TEXT) == 0){
			*text_min = s64->addr;
			*text_max = s64->addr + s64->size;
			return;
		    }
		    s++;
		}
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
}
                                                                                                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/gprof.c                               0100644 0001750 0001750 00000114202 12612724206 023036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: gprof.c,v 1.3 1996/10/02 02:59:49 tholo Exp $	*/
/*	$NetBSD: gprof.c,v 1.8 1995/04/19 07:15:59 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <libc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "stuff/errors.h"
#include "gprof.h"

#ifdef vax
#include "vax.h"
#endif

/*
 * Progname for error messages.
 */
char *progname = NULL;

/*
 * Ticks per second.
 */
uint32_t hz = 0;

/*
 * Filename of the a.out file.
 */
char *a_outname = NULL;

/*
 * Filename of the gmon.out file.
 */
char *gmonname = NULL;

__private_extern__
nltype	*nl = NULL;	/* the whole namelist */
nltype	*npe = NULL;	/* the virtual end of the namelist */
uint32_t nname = 0;	/* the number of function names */

/*
 * The list of file names and the ranges their pc's cover used for building
 * order files with the -S option.
 */
struct file *files = NULL;
uint32_t n_files = 0;

/* 
 * namelist entries for cycle headers.
 * the number of discovered cycles.
 */
nltype	*cyclenl = NULL;	/* cycle header namelist */
int	ncycle = 0;		/* number of cycles discovered */

/*
 * The information for the pc sample sets from the gmon.out file.
 */
struct sample_set *sample_sets = NULL;
uint32_t nsample_sets = 0;

#ifdef __OPENSTEP__
/*
 * The rld loaded state from the gmon.out file.
 */
struct rld_loaded_state *grld_loaded_state = NULL;
uint32_t grld_nloaded_states = 0;
#endif

/*
 * The dyld images from the gmon.out file.
 */
uint32_t image_count = 0;
struct dyld_image *dyld_images = NULL;

unsigned char *textspace = NULL;/* text space of a.out in core */
double	totime = 0.0;		/* total time for all routines */
double	printtime = 0.0;	/* total of time being printed */
double	actime = 0.0;		/* accumulated time thus far for
				   putprofline */

/*
 * Option flags, from a to z.
 */
enum bool aflag = FALSE;	/* suppress static functions */
enum bool bflag = FALSE;	/* blurbs, too */
enum bool cflag = FALSE;	/* discovered call graph, too */
enum bool dflag = FALSE;	/* debugging options */
enum bool eflag = FALSE;	/* specific functions excluded */
enum bool Eflag = FALSE;	/* functions excluded with time */
enum bool fflag = FALSE;	/* specific functions requested */
enum bool Fflag = FALSE;	/* functions requested with time */
enum bool sflag = FALSE;	/* sum multiple gmon.out files */
enum bool Sflag = FALSE;	/* produce order file for scatter loading */
enum bool xflag = FALSE;	/* don't produce gmon.order file */
enum bool zflag = FALSE;	/* zero time/called functions, too */

/*
 * The debug value for debugging gprof.
 */
uint32_t debug = 0;

/*
 * Things which get -E excluded by default.
 */
static char *defaultEs[] = {
/* from the original gprof code */
    "mcount",
    /* "__mcleanup", obsolete */
/* missing from gprof for the 4.3bsd implementaion */
    "_monitor",
    "_monstartup",
    "_moncontrol",
    "_profil",
/* added to the NeXT implementation for 3.0 */
    "_moninit",
    "_monoutput",
    "_monreset",
/* added to the NeXT implementation for 3.1 */
    "_monaddition",
    "_moncount",
    "_add_profil",
    0
};

/*
 * Static function declarations.
 */
static void getpfile(
    char *filename);

#ifdef __OPENSTEP__
static void read_rld_state(
    int fd,
    char *filename,
    uint32_t nbytes);
#endif

static void read_dyld_state(
    uint32_t type,
    int fd,
    char *filename,
    uint32_t nbytes,
    uint32_t magic);

static uint32_t new_sample_set(
    int fd,
    char *filename,
    uint32_t nbytes,
    enum bool old_style,
    uint32_t magic);

static void readarcs(
    int fd,
    char *filename,
    uint32_t nbytes);

static void readarcs_64(
    int fd,
    char *filename,
    uint32_t nbytes);

static void readarcs_orders(
    int fd,
    char *filename,
    uint32_t nbytes);

static void readarcs_orders_64(
    int fd,
    char *filename,
    uint32_t nbytes);

static void tally(
    uint64_t frompc,
    uint64_t selfpc,
    uint32_t count,
    uint32_t order);

static void dumpsum(
    char *sumfile);

static void asgnsamples(
    struct sample_set *s);

static uint64_t min(
    uint64_t a,
    uint64_t b);

static uint64_t max(
    uint64_t a,
    uint64_t b);

static void alignentries(
    void);

/* apple_version is created by the libstuff/Makefile */
extern char apple_version[];
char *version = apple_version;

int
main(
int argc,
char **argv,
char **envp)
{
    uint32_t i;
    char **sp;
    nltype **timesortnlp;

	progname = argv[0];
	--argc;
	argv++;
	debug = 0;
	bflag = TRUE;
	while(*argv != 0 && **argv == '-'){
	    (*argv)++;
	    switch(**argv){
	    case 'a':
		aflag = TRUE;
		break;
	    case 'b':
		bflag = FALSE;
		break;
	    case 'c':
		printf("%s: -c not supported\n", progname);
		/* cflag = TRUE; */
		break;
	    case 'd':
		dflag = TRUE;
		(*argv)++;
		debug |= atoi(*argv);
		debug |= ANYDEBUG;
#ifdef DEBUG
		printf("[main] debug = %u\n", debug);
#else
		printf("%s: -d ignored\n", progname);
#endif
		break;
	    case 'E':
		++argv;
		addlist(Elist, *argv);
		Eflag = TRUE;
		addlist(elist, *argv);
		eflag = TRUE;
		break;
	    case 'e':
		addlist(elist, *++argv);
		eflag = TRUE;
		break;
	    case 'F':
		++argv;
		addlist(Flist, *argv);
		Fflag = TRUE;
		addlist(flist, *argv);
		fflag = TRUE;
		break;
	    case 'f':
		addlist(flist, *++argv);
		fflag = TRUE;
		break;
	    case 'S':
		Sflag = TRUE;
		break;
	    case 's':
		sflag = TRUE;
		break;
	    case 'x':
		xflag = TRUE;
		break;
	    case 'z':
		zflag = TRUE;
		break;
	    }
	    argv++;
	}

	if(*argv != 0){
	    a_outname = *argv;
	    argv++;
	}
	else{
	    a_outname = A_OUTNAME;
	}

	if(*argv != 0){
	    gmonname = *argv;
	    argv++;
	}
	else{
	    gmonname = GMONNAME;
	}

	/*
	 * Turn off default functions.
	 */
	for(sp = &defaultEs[0]; *sp; sp++){
	    Eflag = TRUE;
	    addlist(Elist, *sp);
	    eflag = TRUE;
	    addlist(elist, *sp);
	}

	/*
	 * Get information about a.out file.
	 */
	getnfile();
	if(errors != 0)
	    exit(1);

	/*
	 * Get information about mon.out file(s).
	 */
	hz = 0;
	do{
	    getpfile(gmonname);
	    if(*argv != 0){
		gmonname = *argv;
	    }
	}while(*argv++ != 0);

	/*
	 * How many ticks per second?  If we can't tell, report time in ticks.
	 * If this was picked up from the mon.out files use that value.
	 */
#ifndef __OPENSTEP__
	if(hz == 0)
#endif
	    hz = hertz();
	if(hz == 0){
	    hz = 1;
	    fprintf(stderr, "time is in ticks, not seconds\n");
	}

	/*
	 * Dump out a gmon.sum file if requested.
	 */
	if(sflag){
	    dumpsum(GMONSUM);
	    exit(0);
	}

	/*
	 * Assign samples to procedures.
	 */
	alignentries();
	for(i = 0; i < nsample_sets; i++)
	    asgnsamples(sample_sets + i);

	/*
	 * Assemble the dynamic profile.
	 */
	timesortnlp = doarcs();

	/*
	 * Print the dynamic profile.
	 */
	printgprof(timesortnlp);	

	/*
	 * Print the flat profile.
	 */
	printprof();	

	/*
	 * Print the index.
	 */
	printindex();	

	/*
	 * Dump out the order files if requested.
	 */
	if(Sflag)
	    printscatter();

	return(0);
}

static
void
getpfile(
char *filename)
{
    uint32_t magic, left;
    gmon_data_t data;
    int fd;
    struct stat stat;

	if((fd = open(filename, O_RDONLY)) == -1)
	    system_fatal("can't open: %s", filename);
	if(fstat(fd, &stat) == -1)
	    system_fatal("can't stat: %s", filename);
	/*
	 * See if this gmon.out file is an old format or new format by looking
	 * for the magic number of the new format.
	 */
	if(read(fd, &magic, sizeof(uint32_t)) != sizeof(uint32_t))
	    system_fatal("malformed gmon.out file: %s (can't read magic "
			 "number)", filename);
	if(magic == GMON_MAGIC || magic == GMON_MAGIC_64){
#ifdef DEBUG_GMON_OUT
	    if(magic == GMON_MAGIC)
		printf("GMON_MAGIC\n");
	    else
		printf("GMON_MAGIC_64\n");
#endif
	    /*
	     * This is a new format gmon.out file.  After the magic number comes
	     * any number of pairs of gmon_data structs and some typed data.
	     */
	    left = stat.st_size - sizeof(uint32_t);
	    while(left >= sizeof(struct gmon_data)){
		if(read(fd, &data, sizeof(struct gmon_data)) !=
			sizeof(struct gmon_data))
		    system_fatal("malformed gmon.out file: %s (can't read "
				 "gmon_data struct)", filename);
		left -= sizeof(struct gmon_data);
		if(left < data.size)
		    fatal("truncated or malformed gmon.out file: %s (value in "
			  "size field in gmon_data struct more than left in "
			  "file)", filename);
#ifdef DEBUG_GMON_OUT
		printf("gmon_data struct: type = %u size = %u\n", data.type,
		       data.size);
#endif
		switch(data.type){
		case GMONTYPE_SAMPLES:
#ifdef DEBUG_GMON_OUT
		    printf("GMONTYPE_SAMPLES\n");
#endif
		    new_sample_set(fd, filename, data.size, FALSE, magic);
		    break;
		case GMONTYPE_RAWARCS:
#ifdef DEBUG_GMON_OUT
		    printf("GMONTYPE_RAWARCS\n");
#endif
		    if(magic == GMON_MAGIC)
			readarcs(fd, filename, data.size);
		    else
			readarcs_64(fd, filename, data.size);
		    break;
		case GMONTYPE_ARCS_ORDERS:
#ifdef DEBUG_GMON_OUT
		    printf("GMONTYPE_ARCS_ORDERS\n");
#endif
		    if(magic == GMON_MAGIC)
			readarcs_orders(fd, filename, data.size);
		    else
			readarcs_orders_64(fd, filename, data.size);
		    break;
#ifdef __OPENSTEP__
		case GMONTYPE_RLD_STATE:
#ifdef DEBUG_GMON_OUT
		    printf("GMONTYPE_RLD_STATE\n");
#endif
		    if(grld_nloaded_states == 0){
			read_rld_state(fd, filename, data.size);
			get_rld_state_symbols();
		    }
		    else{
			warning("can't process more than one rld loaded state "
			        "(ignoring rld state from: %s)", filename);
			lseek(fd, data.size, L_INCR);
		    }
		    break;
#endif
		case GMONTYPE_DYLD_STATE:
#ifdef DEBUG_GMON_OUT
		    printf("GMONTYPE_DYLD_STATE\n");
#endif
		    goto setup_dyld_state;
		case GMONTYPE_DYLD2_STATE:
#ifdef DEBUG_GMON_OUT
		    printf("GMONTYPE_DYLD2_STATE\n");
#endif
setup_dyld_state:
		    if(image_count == 0){
			read_dyld_state(data.type, fd, filename, data.size,
					magic);
			get_dyld_state_symbols();
		    }
		    else{
			warning("can't process more than one dyld state "
			        "(ignoring dyld state from: %s)", filename);
			lseek(fd, data.size, L_INCR);
		    }
		    break;
		default:
#ifdef DEBUG_GMON_OUT
		    printf("Unknown data.type = %u\n", data.type);
#endif
		    fatal("truncated or malformed gmon.out file: %s (value in "
			  "type field in gmon_data struct unknown)", filename);
		}
		left -= data.size;
	    }
	    if(left != 0)
		fatal("truncated or malformed gmon.out file: %s (file end in "
		      "the middle of a gmon_data struct %u)", filename, left);
	}
	else{
	    /*
	     * This is an old format gmon.out file.  It has a profile header
	     * then * an array of sampling hits within pc ranges, and then arcs.
	     */
	    lseek(fd, 0, L_SET);
	    left = stat.st_size;
	    left -= new_sample_set(fd, filename, left, TRUE, GMON_MAGIC);
	    readarcs(fd, filename, left);
	}
	close(fd);
}

#ifdef __OPENSTEP__
static
void
read_rld_state(
int fd,
char *filename,
uint32_t nbytes)
{
    uint32_t i, j, size, size_read, str_size;
    char *strings;

	size_read = 0;
	size = sizeof(uint32_t);
	if(read(fd, &grld_nloaded_states, size) != size)
	    system_fatal("malformed gmon.out file: %s (can't read number of "
			 "rld states)", filename);
	size_read += size;

	grld_loaded_state = (struct rld_loaded_state *)
		malloc(grld_nloaded_states * sizeof(struct rld_loaded_state));
	if(grld_loaded_state == NULL)
	    fatal("no room for rld states (malloc failed)");

	for(i = 0; i < grld_nloaded_states; i++){
	    size = sizeof(uint32_t);
	    if(read(fd, &(grld_loaded_state[i].header_addr), size) != size)
		system_fatal("malformed gmon.out file: %s (can't read header "
		    "address of rld state %lu)", filename, i);
	    size_read += size;

	    size = sizeof(uint32_t);
	    if(read(fd, &(grld_loaded_state[i].nobject_filenames), size) != size)
		system_fatal("malformed gmon.out file: %s (can't read number "
		    "of object file names of rld state %lu)", filename, i);
	    size_read += size;

	    grld_loaded_state[i].object_filenames = (char **)
		malloc((grld_loaded_state[i].nobject_filenames + 1) *
		       sizeof(char *));
	    if(grld_loaded_state[i].object_filenames == NULL)
		fatal("no room for rld state %lu object file names (malloc "
		      "failed)", i);

	    size = grld_loaded_state[i].nobject_filenames * sizeof(char *);
	    if(read(fd, grld_loaded_state[i].object_filenames, size) != size)
		system_fatal("malformed gmon.out file: %s (can't read offsets "
		    "to file names of rld state %lu)", filename, i);
	    size_read += size;

	    size = sizeof(uint32_t);
	    if(read(fd, &str_size, size) != size)
		system_fatal("malformed gmon.out file: %s (can't read string "
		    "size of rld state %lu)", filename, i);
	    size_read += size;

	    strings = (char *)malloc(str_size);
	    if(strings == NULL)
		fatal("no room for rld state %lu object file names (malloc "
		      "failed)", i);

	    size = str_size;
	    if(read(fd, strings, size) != size)
		system_fatal("malformed gmon.out file: %s (can't read strings "
		    "of file names of rld state %lu)", filename, i);
	    size_read += size;

	    for(j = 0; j < grld_loaded_state[i].nobject_filenames; j++){
		if((uint32_t)(grld_loaded_state[i].object_filenames[j]) >
		   str_size)
		    fatal("malformed gmon.out file: %s (bad offset to object "
			  "filename %lu of rld state %lu)", filename, j, i);
		grld_loaded_state[i].object_filenames[j] = strings +
		    (uint32_t)(grld_loaded_state[i].object_filenames[j]);
	    }
	    grld_loaded_state[i].object_filenames[j] = NULL;
	}

#ifdef DEBUG
	if(debug & RLDDEBUG){
	    printf("grld_nloaded_states = %lu\n", grld_nloaded_states);
	    printf("grld_loaded_state 0x%x\n", (unsigned int)grld_loaded_state);
	    for(i = 0; i < grld_nloaded_states; i++){
		printf("state %lu\n\tnobject_filenames %lu\n\tobject_filenames "
		      "0x%x\n\theader_addr 0x%x\n", i,
		      grld_loaded_state[i].nobject_filenames,
		      (unsigned int)(grld_loaded_state[i].object_filenames),
		      (unsigned int)(grld_loaded_state[i].header_addr));
		for(j = 0; j < grld_loaded_state[i].nobject_filenames; j++)
		    printf("\t\t%s\n", grld_loaded_state[i].object_filenames[j]);
	    }
	}
#endif
}
#endif

static
void
read_dyld_state(
uint32_t type,
int fd,
char *filename,
uint32_t nbytes,
uint32_t magic)
{
    uint32_t i, offset, sizeof_vmaddr, vmaddr32;
    uint64_t vmaddr64;
    char *buf;

	buf = malloc(nbytes);
	if(buf == NULL)
	    fatal("no room for dyld state (malloc failed)");

	if(read(fd, buf, nbytes) != (int)nbytes)
	    system_fatal("malformed gmon.out file: %s (can't read dyld state)",
			 filename);

	offset = 0;
	if(offset + sizeof(uint32_t) > nbytes)
	    fatal("truncated or malformed gmon.out file: %s (image count "
		  "extends past the end of the dyld state)", filename);
	memcpy(&image_count, buf + offset, sizeof(uint32_t));
	offset += sizeof(uint32_t);

	dyld_images = (struct dyld_image *)malloc(sizeof(struct dyld_image) *
						  image_count);
	if(dyld_images == NULL)
	    fatal("no room for dyld images (malloc failed)");

	if(magic == GMON_MAGIC)
	    sizeof_vmaddr = sizeof(uint32_t);
	else
	    sizeof_vmaddr = sizeof(uint64_t);
	for(i = 0; i < image_count; i++){
	    if(offset + sizeof_vmaddr > nbytes)
		fatal("truncated or malformed gmon.out file: %s (vmaddr "
		      "for image %u extends past the end of the dyld state)",
		      filename, i);

	    if(magic == GMON_MAGIC){
		memcpy(&vmaddr32, buf + offset, sizeof_vmaddr);
		vmaddr64 = vmaddr32;
	    }
	    else{
		memcpy(&vmaddr64, buf + offset, sizeof_vmaddr);
	    }
	    offset += sizeof_vmaddr;
	
	    if(type == GMONTYPE_DYLD_STATE){
		dyld_images[i].vmaddr_slide = vmaddr64;
		dyld_images[i].image_header = 0;
	    }
	    else{
		dyld_images[i].image_header = vmaddr64;
		dyld_images[i].vmaddr_slide = 0;
	    }

	    dyld_images[i].name = buf + offset;
	    while(buf[offset] != '\0' && offset < nbytes)
		offset++;
	    if(buf[offset] == '\0' && offset < nbytes)
		offset++;
	    if(offset > nbytes)
		fatal("truncated or malformed gmon.out file: %s (name "
		      "for image %u extends past the end of the dyld state)",
		      filename, i);
	}
#ifdef DEBUG
	if(debug & DYLDDEBUG){
	    printf("image_count = %u\n", image_count);
	    for(i = 0; i < image_count; i++){
		printf("dyld_image[%u].name = %s\n", i, dyld_images[i].name);
		printf("dyld_image[%u].vmaddr_slide = 0x%llx\n", i,
			dyld_images[i].vmaddr_slide);
		printf("dyld_image[%u].image_header = 0x%llx\n", i,
			dyld_images[i].image_header);
	    }
	}
#endif
}

static
uint32_t
new_sample_set(
int fd,
char *filename,
uint32_t nbytes,
enum bool old_style,
uint32_t magic)
{
#ifdef __OPENSTEP__
    struct phdr header;
#else
    struct gmonhdr header32;
    struct gmonhdr_64 header;
#endif
    uint64_t i, j, size;
    uint32_t sizeof_header;
    unsigned UNIT sample, *samples;

	if(magic == GMON_MAGIC)
	    sizeof_header = sizeof(struct gmonhdr);
	else
	    sizeof_header = sizeof(struct gmonhdr_64);

	if(nbytes < sizeof_header)
	    fatal("gmon.out file: %s malformed (byte count less than the "
		  "size of the expected header)", filename);
	/*
	 * Read the profile header and check to see if it is valid.
	 */
	if(magic == GMON_MAGIC)
	    size = read(fd, &header32, sizeof_header);
	else
	    size = read(fd, &header, sizeof_header);

	if(size != sizeof_header)
	    system_fatal("malformed gmon.out file: %s (can't read header)",
			 filename);

	if(magic == GMON_MAGIC){
	    header.lpc = header32.lpc;
	    header.hpc = header32.hpc;
	    header.ncnt = header32.ncnt;
	    header.version = header32.version;
	    header.profrate = header32.profrate;
	    header.spare[0] = header32.spare[0];
	    header.spare[1] = header32.spare[1];
	    header.spare[2] = header32.spare[2];
	}

	/*
	 * The ncnt field is a byte count of the header and the number of
	 * bytes of the 2byte samples that follow it.  Try to make sure this
	 * is reasonable and that what's left in the file is at least that big.
	 */
	if(header.ncnt < sizeof_header)
	    fatal("gmon.out file: %s malformed (ncnt field less than the "
		  "size of the expected header)", filename);
	if(header.ncnt > nbytes)
	    fatal("gmon.out file: %s malformed (ncnt field greater than "
		  "the byte count for it in the file)", filename);
	if(header.hpc < header.lpc)
	    fatal("gmon.out file: %s malformed (high pc less than low pc "
		  "in header)", filename);
	if(((header.ncnt - sizeof_header) % sizeof(unsigned short)) != 0)
	    warning("gmon.out file: %s malformed (number of sample bytes "
		    "not a multiple of sizeof(unsigned short))", filename);
#ifndef __OPENSTEP__
	if(header.version != GMONVERSION)
	    warning("gmon.out file: %s unknown version (0x%x)", filename,
		    header.version);
	if(hz == 0){
	    if(header.profrate == 0)
		warning("gmon.out file: %s profrate is zero", filename);
	    else
		hz = header.profrate;
	}
	else{
	    if(hz != header.profrate)
		warning("gmon.out file: %s profrate (%d) does not prevous "
			"profrate (%u)\n", filename, header.profrate, hz);
	}
#endif

	/*
	 * See if this sample range matches another range
	 */
	for(i = 0; i < nsample_sets; i++){
	    if(sample_sets[i].s_lowpc == header.lpc &&
	       sample_sets[i].s_highpc == header.hpc &&
	       sample_sets[i].sampbytes == header.ncnt - sizeof_header)
		break;
	}
	/*
	 * For old_style gmon.out files with one only pc sample range it must
	 * match up if there are any ranges.
	 */
	if(old_style == TRUE && sample_sets != NULL && i != nsample_sets)
	    fatal("gmon.out file: %s incompatible with first gmon.out file",
		  filename);

	/*
	 * If this range does not match up with a previous range then create
	 * a new sample set for it.
	 */
	if(i == nsample_sets){
	    sample_sets = realloc(sample_sets, (nsample_sets + 1) *
				  sizeof(struct sample_set));
	    if(sample_sets == NULL)
		fatal("no room for next pc sample set (malloc failed)");
	    i = nsample_sets;
	    nsample_sets++;
	    memset(sample_sets + i, '\0', sizeof(struct sample_set));

	    sample_sets[i].s_lowpc = header.lpc;
	    sample_sets[i].s_highpc = header.hpc;
	    sample_sets[i].lowpc = header.lpc / sizeof(UNIT);
	    sample_sets[i].highpc = header.hpc / sizeof(UNIT);
	    sample_sets[i].sampbytes = header.ncnt - sizeof_header;
	    sample_sets[i].nsamples = sample_sets[i].sampbytes /
				      sizeof(unsigned UNIT);
	    sample_sets[i].scale = ((double)(sample_sets[i].highpc) -
				    (double)(sample_sets[i].lowpc)) /
				    (double)(sample_sets[i].nsamples);
	    sample_sets[i].samples = calloc(sample_sets[i].sampbytes,
					    sizeof(unsigned UNIT));
	    if(sample_sets[i].samples == NULL)
		fatal("no room for %llu sample pc's\n", 
		      sample_sets[i].sampbytes / sizeof(unsigned UNIT));
#ifndef __OPENSTEP__
	    sample_sets[i].version = header.version;
	    sample_sets[i].profrate = header.profrate;
	    sample_sets[i].spare[0] = header.spare[0];
	    sample_sets[i].spare[1] = header.spare[1];
	    sample_sets[i].spare[2] = header.spare[2];
#endif
	}
#ifdef DEBUG
	if(debug & SAMPLEDEBUG){
	    printf("[new_sample_set] header.lpc 0x%llx header.hpc 0x%llx "
		   "header.ncnt %u\n", header.lpc, header.hpc, header.ncnt);
	    printf("[new_sample_set]   s_lowpc 0x%llx   s_highpc 0x%llx\n",
		   sample_sets[i].s_lowpc, sample_sets[i].s_highpc);
	    printf("[new_sample_set]     lowpc 0x%llx     highpc 0x%llx\n" ,
		   sample_sets[i].lowpc, sample_sets[i].highpc);
	    printf("[new_sample_set] sampbytes %llu nsamples %llu\n" ,
		   sample_sets[i].sampbytes, sample_sets[i].nsamples);
#ifndef __OPENSTEP__
	    printf("[new_sample_set] version 0x%x\n",
		   (unsigned int)(sample_sets[i].version));
	    printf("[new_sample_set] profrate %d\n" ,sample_sets[i].profrate);
	    printf("[new_sample_set] spare[0] %d\n" ,sample_sets[i].spare[0]);
	    printf("[new_sample_set] spare[1] %d\n" ,sample_sets[i].spare[1]);
	    printf("[new_sample_set] spare[2] %d\n" ,sample_sets[i].spare[2]);
#endif
	}
#endif
	/*
	 * Read and sum up the sample counts for this sample set.
	 */
	size = sample_sets[i].nsamples * sizeof(unsigned UNIT);
	samples = malloc(size);
	if(samples == NULL)
	    system_fatal("can't allocate buffer of size: %llu for samples from "
			 "gmon.out file: %s", size, filename);
	if(read(fd, samples, size) != size)
	    system_fatal("can't read samples from gmon.out file: %s", filename);
	for(j = 0; j < sample_sets[i].nsamples; j++){
	    sample = samples[j];
#ifdef DEBUG
	if(debug & 8192){
	    if(sample != 0)
		printf("sample[%llu] = %u\n", j, sample);
	}
#endif
	    sample_sets[i].samples[j] += sample;
	}
	free(samples);
	return(header.ncnt);
}

static
void
readarcs(
int fd,
char *filename,
uint32_t nbytes)
{
    uint32_t i;
    struct rawarc arc;

	/*
	 * Arcs consists of a bunch of <from,self,count> tuples.
	 */
	for(i = 0; i < nbytes; i += sizeof(struct rawarc)){
	    if(read(fd, &arc, sizeof(struct rawarc)) != sizeof(struct rawarc))
		system_fatal("malformed gmon.out file: %s (can't read arcs)",
			     filename);
#ifdef DEBUG
	    if(debug & SAMPLEDEBUG){
		printf("[readarcs] frompc 0x%x selfpc 0x%x count %u\n",
		       arc.raw_frompc, arc.raw_selfpc, arc.raw_count);
	    }
#endif
	    /*
	     * Add this arc.
	     */
	    tally(arc.raw_frompc, arc.raw_selfpc, arc.raw_count, 0);
	}
}

static
void
readarcs_64(
int fd,
char *filename,
uint32_t nbytes)
{
    uint32_t i;
    struct rawarc_64 arc;

	/*
	 * Arcs consists of a bunch of <from,self,count> tuples.
	 */
	for(i = 0; i < nbytes; i += sizeof(struct rawarc_64)){
	    if(read(fd, &arc, sizeof(struct rawarc_64)) !=
	       sizeof(struct rawarc_64))
		system_fatal("malformed gmon.out file: %s (can't read arcs)",
			     filename);
#ifdef DEBUG
	    if(debug & SAMPLEDEBUG){
		printf("[readarcs] frompc 0x%llx selfpc 0x%llx count %u\n",
		       arc.raw_frompc, arc.raw_selfpc, arc.raw_count);
	    }
#endif
	    /*
	     * Add this arc.
	     */
	    tally(arc.raw_frompc, arc.raw_selfpc, arc.raw_count, 0);
	}
}

static
void
readarcs_orders(
int fd,
char *filename,
uint32_t nbytes)
{
    uint32_t i;
    struct rawarc_order arc_order;

	/*
	 * Arcs consists of a bunch of <from,self,count> tuples.
	 */
	for(i = 0; i < nbytes; i += sizeof(struct rawarc_order)){
	    if(read(fd, &arc_order, sizeof(struct rawarc_order)) !=
					sizeof(struct rawarc_order))
		system_fatal("malformed gmon.out file: %s (can't read arcs)",
			     filename);
#ifdef DEBUG
	    if(debug & SAMPLEDEBUG){
		printf("[readarcs_order] frompc 0x%x selfpc 0x%x count %u "
		       "order %u\n", arc_order.raw_frompc, arc_order.raw_selfpc,
		       arc_order.raw_count, arc_order.raw_order);
	    }
#endif

	    /*
	     * Add this arc.
	     */
	    tally(arc_order.raw_frompc, arc_order.raw_selfpc,
		  arc_order.raw_count, arc_order.raw_order);
	}
}

static
void
readarcs_orders_64(
int fd,
char *filename,
uint32_t nbytes)
{
    uint32_t i;
    struct rawarc_order_64 arc_order;

	/*
	 * Arcs consists of a bunch of <from,self,count> tuples.
	 */
	for(i = 0; i < nbytes; i += sizeof(struct rawarc_order_64)){
	    if(read(fd, &arc_order, sizeof(struct rawarc_order_64)) !=
					sizeof(struct rawarc_order_64))
		system_fatal("malformed gmon.out file: %s (can't read arcs)",
			     filename);
#ifdef DEBUG
	    if(debug & SAMPLEDEBUG){
		printf("[readarcs_order] frompc 0x%llx selfpc 0x%llx count %u "
		       "order %u\n" , arc_order.raw_frompc,arc_order.raw_selfpc,
		       arc_order.raw_count, arc_order.raw_order);
	    }
#endif

	    /*
	     * Add this arc.
	     */
	    tally(arc_order.raw_frompc, arc_order.raw_selfpc,
		  arc_order.raw_count, arc_order.raw_order);
	}
}

static
void
tally(
uint64_t frompc,
uint64_t selfpc,
uint32_t count,
uint32_t order)
{
    uint32_t i;
    nltype *parentp;
    nltype *childp;

	parentp = nllookup(frompc);
	childp = nllookup(selfpc);

	if(childp == NULL || parentp == NULL){
	    fprintf(stderr, "bad arc from 0x%llx to 0x%llx, count %u "
		    "(ignored).\n", frompc, selfpc, count);
	    return;
	}

	/*
	 * See if this arc comes from inside a shlib's text.
	 */
	for(i = 0; i < nshlib_text_ranges; i++){
	    if(frompc >= shlib_text_ranges[i].lowpc &&
	       frompc < shlib_text_ranges[i].highpc)
		break;
	}
	if(parentp->name[0] != '+' && parentp->name[0] != '-' &&
	   nshlib_text_ranges != 0 && i != nshlib_text_ranges){
#ifdef DEBUG
	    if(debug & SAMPLEDEBUG){
		printf("[tally] tossing arc frompc 0x%llx selfpc 0x%llx "
		       "count %u order %u\n", frompc, selfpc, count, order);
	    }
#endif
	    return;
	}

	childp->ncall += count;

	/*
	 * Set the call order to the lowest order in the arcs for a call this
	 * child.  Orders in the arcs are start at 1 and thus orders with the
	 * value of zero are unordered.
	 */
	if(order != 0){
	    if(childp->order == 0)
	        childp->order = order;
	    else if(order < childp->order)
	        childp->order = order;
	}

#ifdef DEBUG
	if(debug & TALLYDEBUG){
	    printf("[tally] arc from %s to %s traversed %u times\n",
		   parentp->name, childp->name, count);
	}
#endif /* DEBUG */

	addarc(parentp, childp, count, order);
}

/*
 * Dump out the gmon.sum file.
 */
static
void
dumpsum(
char *sumfile)
{
    uint32_t i, j, magic;
#ifdef __OPENSTEP__
    uint32_t strsize;
    struct phdr header;
#else
    struct gmonhdr header;
#endif
    int fd;
    struct gmon_data data;
    nltype *nlp;
    arctype *arcp;
    struct rawarc_order arc_order;

	if((fd = open(sumfile, O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1)
	    fatal("can't create gmon.sum file: %s", sumfile);

	/*
	 * Write the magic number.
	 */
        magic = GMON_MAGIC;
        if(write(fd, &magic, sizeof(uint32_t)) != sizeof(uint32_t))
	    fatal("can't write magic number to gmon.sum file: %s", sumfile);

#ifdef __OPENSTEP__
	/*
	 * Write the rld_state if any.
	 */
	if(grld_nloaded_states != 0){
	    data.type = GMONTYPE_RLD_STATE;
	    data.size = sizeof(uint32_t) +
		sizeof(uint32_t) * 3 * grld_nloaded_states;
	    for(i = 0; i < grld_nloaded_states; i++){
		data.size += sizeof(uint32_t) *
				 grld_loaded_state[i].nobject_filenames;
		for(j = 0; j < grld_loaded_state[i].nobject_filenames; j++)
		    data.size +=
			strlen(grld_loaded_state[i].object_filenames[j]) + 1;
	    }

	    if(write(fd, &data, sizeof(struct gmon_data)) !=
		     sizeof(struct gmon_data))
		fatal("can't write gmon_data struct to gmon.sum file: %s",
		      sumfile);
	    if(write(fd, &grld_nloaded_states, sizeof(uint32_t)) !=
		     sizeof(uint32_t))
		fatal("can't write to gmon.sum file: %s", sumfile);
	    for(i = 0; i < grld_nloaded_states; i++){
		if(write(fd, &(grld_loaded_state[i].header_addr),
		         sizeof(uint32_t)) != sizeof(uint32_t))
		    fatal("can't write to gmon.sum file: %s", sumfile);
		if(write(fd, &(grld_loaded_state[i].nobject_filenames),
		         sizeof(uint32_t)) != sizeof(uint32_t))
		    fatal("can't write to gmon.sum file: %s", sumfile);
		strsize = 0;
		for(j = 0; j < grld_loaded_state[i].nobject_filenames; j++){
		    if(write(fd, &strsize, sizeof(uint32_t)) != 
			     sizeof(uint32_t))
			fatal("can't write to gmon.sum file: %s", sumfile);
		    strsize +=
			strlen(grld_loaded_state[i].object_filenames[j]) + 1;
		}
		if(write(fd, &strsize, sizeof(uint32_t)) != 
			 sizeof(uint32_t))
		    fatal("can't write to gmon.sum file: %s", sumfile);
		for(j = 0; j < grld_loaded_state[i].nobject_filenames; j++){
		    strsize =
			strlen(grld_loaded_state[i].object_filenames[j]) + 1;
		    if(write(fd, grld_loaded_state[i].object_filenames[j],
			     strsize) != strsize)
			fatal("can't write to gmon.sum file: %s", sumfile);
		}
	    }
	}
#endif

	/*
	 * Write the samples.
	 */
	for(i = 0; i < nsample_sets; i++){
	    data.type = GMONTYPE_SAMPLES;
	    data.size = sample_sets[i].sampbytes + sizeof(header);
	    if(write(fd, &data, sizeof(struct gmon_data)) !=
					sizeof(struct gmon_data))
		fatal("can't write gmon_data struct to gmon.sum file: %s",
		      sumfile);

	    memset(&header, '\0', sizeof(header));
#ifdef __OPENSTEP__
	    header.lpc = (char *)sample_sets[i].s_lowpc;
	    header.hpc = (char *)sample_sets[i].s_highpc;
#else
	    header.lpc = sample_sets[i].s_lowpc;
	    header.hpc = sample_sets[i].s_highpc;
	    header.version = sample_sets[i].version;
	    header.profrate = sample_sets[i].profrate;
	    header.spare[0] = sample_sets[i].spare[0];
	    header.spare[1] = sample_sets[i].spare[1];
	    header.spare[2] = sample_sets[i].spare[2];
#endif
	    header.ncnt = sample_sets[i].sampbytes + sizeof(header);
	    if(write(fd, &header, sizeof(header)) != sizeof(header))
		fatal("can't write header to gmon.sum file: %s", sumfile);

	    for(j = 0; j < sample_sets[i].nsamples; j++){
		if(write(fd, &(sample_sets[i].samples[j]),
			 sizeof(unsigned UNIT)) != sizeof(unsigned UNIT))
		    system_fatal("can't write samples to gmon.sum file: %s",
				 sumfile);
	    }
	}

	/*
	 * Write the arc information
	 */
	data.type = GMONTYPE_ARCS_ORDERS;
	data.size = 0;
	for(nlp = nl; nlp < npe; nlp++){
	    for(arcp = nlp->children; arcp; arcp = arcp->arc_childlist){
		data.size += sizeof(struct rawarc_order);
	    }
	}
	if(write(fd, &data, sizeof(struct gmon_data)) !=
				    sizeof(struct gmon_data))
	    fatal("can't write gmon_data struct to gmon.sum file: %s",
		  sumfile);

	for(nlp = nl; nlp < npe; nlp++){
	    for(arcp = nlp->children; arcp; arcp = arcp->arc_childlist){
		arc_order.raw_frompc = arcp->arc_parentp->value;
		arc_order.raw_selfpc = arcp->arc_childp->value;
		arc_order.raw_count  = arcp->arc_count;
		arc_order.raw_order  = arcp->arc_order;
		if(write(fd, &arc_order, sizeof(struct rawarc_order)) != 
			 sizeof(struct rawarc_order))
		    fatal("can't write arc to gmon.sum file: %s", sumfile);
#ifdef DEBUG
		if(debug & SAMPLEDEBUG){
		    printf("[dumpsum] frompc 0x%x selfpc 0x%x count %u "
			   "order %u\n" ,
			   (unsigned int)arc_order.raw_frompc,
			   (unsigned int)arc_order.raw_selfpc,
			   arc_order.raw_count,
			   arc_order.raw_order);
		}
#endif
	    }
	}
	close(fd);
}


/*
 *	Assign samples to the procedures to which they belong.
 *
 *	There are three cases as to where pcl and pch can be
 *	with respect to the routine entry addresses svalue0 and svalue1
 *	as shown in the following diagram.  overlap computes the
 *	distance between the arrows, the fraction of the sample
 *	that is to be credited to the routine which starts at svalue0.
 *
 *	    svalue0                                         svalue1
 *	       |                                               |
 *	       v                                               v
 *
 *	       +-----------------------------------------------+
 *	       |					       |
 *	  |  ->|    |<-		->|         |<-		->|    |<-  |
 *	  |         |		  |         |		  |         |
 *	  +---------+		  +---------+		  +---------+
 *
 *	  ^         ^		  ^         ^		  ^         ^
 *	  |         |		  |         |		  |         |
 *	 pcl       pch		 pcl       pch		 pcl       pch
 *
 *	For the vax we assert that samples will never fall in the first
 *	two bytes of any routine, since that is the entry mask,
 *	thus we give call alignentries() to adjust the entry points if
 *	the entry mask falls in one bucket but the code for the routine
 *	doesn't start until the next bucket.  In conjunction with the
 *	alignment of routine addresses, this should allow us to have
 *	only one sample for every four bytes of text space and never
 *	have any overlap (the two end cases, above).
 */
static
void
asgnsamples(
struct sample_set *s)
{
    uint32_t i, j;
    unsigned UNIT ccnt;
    double time;
    uint32_t pcl, pch, overlap, svalue0, svalue1;

	/* read samples and assign to namelist symbols */
	for(i = 0, j = 1; i < s->nsamples; i++){
	    ccnt = s->samples[i];
	    if (ccnt == 0)
		continue;
	    pcl = s->lowpc + s->scale * i;
	    pch = s->lowpc + s->scale * (i + 1);
	    time = ccnt;
#ifdef DEBUG
	    if(debug & SAMPLEDEBUG){
		printf("[asgnsamples] pcl 0x%x pch 0x%x ccnt %d\n",
		       (unsigned int)pcl, (unsigned int)pch, ccnt);
	    }
#endif
	    totime += time;
	    for(j = j - 1; j < nname; j++){
		svalue0 = nl[j].svalue;
		svalue1 = nl[j+1].svalue;
		/*
		 * if high end of tick is below entry address, 
		 * go for next tick.
		 */
		if(pch < svalue0)
		    break;
		/*
		 * if low end of tick into next routine,
		 * go for next routine.
		 */
		if(pcl >= svalue1)
		    continue;
		overlap = min(pch, svalue1) - max(pcl, svalue0);
		if(overlap > 0){
#ifdef DEBUG
		    if (debug & SAMPLEDEBUG) {
			printf("[asgnsamples] (0x%x->0x%x-0x%x) %s gets %f "
			       "ticks %u overlap\n",
			       (unsigned int)(nl[j].value/sizeof(UNIT)),
			       (unsigned int)svalue0, (unsigned int)svalue1,
			       nl[j].name, overlap * time / s->scale, overlap);
		    }
#endif
		    nl[j].time += overlap * time / s->scale;
		}
	    }
	}
#ifdef DEBUG
	if(debug & SAMPLEDEBUG){
	    printf("[asgnsamples] totime %f\n", totime);
	}
#endif
}

static
uint64_t
min(
uint64_t a,
uint64_t b)
{
    if(a < b)
	return(a);
    return(b);
}

static
uint64_t
max(
uint64_t a,
uint64_t b)
{
    if(a > b)
	return(a);
    return(b);
}

/*
 * Calculate scaled entry point addresses (to save time in asgnsamples),
 * and possibly push the scaled entry points over the entry mask (vax),
 * if it turns out that the entry point is in one bucket and the code
 * for a routine is in the next bucket.
 */
static
void
alignentries(
void)
{
    struct nl *nlp;
#ifdef vax
    uint32_t i;
    uint32_t bucket_of_entry;
    uint32_t bucket_of_code;
#endif /* vax */

	for(nlp = nl; nlp < npe; nlp++){
	    nlp->svalue = nlp->value / sizeof(UNIT);
#ifdef vax
	    for(i = 0; i < nsample_sets; i++){
		if(nlp->svalue >= sample_sets[i].s_lowpc &&
		   nlp->svalue < sample_sets[i].s_lowpc)
		    break;
	    }
	    if(i == nsample_sets)
		continue;
	    bucket_of_entry = (nlp->svalue - sample_sets[i].lowpc) /
			      sample_sets[i].scale;
	    bucket_of_code = (nlp->svalue + UNITS_TO_CODE -
			      sample_sets[i].lowpc) / sample_sets[i].scale;
	    if(bucket_of_entry < bucket_of_code) {
#ifdef DEBUG
		if(debug & SAMPLEDEBUG){
		    printf("[alignentries] pushing svalue 0x%x to 0x%x\n",
			   (unsigned int)nlp->svalue,
			   (unsigned int)(nlp->svalue + UNITS_TO_CODE));
		}
#endif /* DEBUG */
		nlp->svalue += UNITS_TO_CODE;
	    }
#endif /* vax */
	}
}
                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/gprof.callg                           0100644 0001750 0001750 00000006303 12612724206 023700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        


call graph profile:
          The sum of self and descendents is the major sort
          for this listing.

          function entries:

index     the index of the function in the call graph
          listing, as an aid to locating it (see below).

%time     the percentage of the total time of the program
          accounted for by this function and its
          descendents.

self      the number of seconds spent in this function
          itself.

descendents
          the number of seconds spent in the descendents of
          this function on behalf of this function.

called    the number of times this function is called (other
          than recursive calls).

self      the number of times this function calls itself
          recursively.

name      the name of the function, with an indication of
          its membership in a cycle, if any.

index     the index of the function in the call graph
          listing, as an aid to locating it.



          parent listings:

self*     the number of seconds of this function's self time
          which is due to calls from this parent.

descendents*
          the number of seconds of this function's
          descendent time which is due to calls from this
          parent.

called**  the number of times this function is called by
          this parent.  This is the numerator of the
          fraction which divides up the function's time to
          its parents.

total*    the number of times this function was called by
          all of its parents.  This is the denominator of
          the propagation fraction.

parents   the name of this parent, with an indication of the
          parent's membership in a cycle, if any.

index     the index of this parent in the call graph
          listing, as an aid in locating it.



          children listings:

self*     the number of seconds of this child's self time
          which is due to being called by this function.

descendent*
          the number of seconds of this child's descendent's
          time which is due to being called by this
          function.

called**  the number of times this child is called by this
          function.  This is the numerator of the
          propagation fraction for this child.

total*    the number of times this child is called by all
          functions.  This is the denominator of the
          propagation fraction.

children  the name of this child, and an indication of its
          membership in a cycle, if any.

index     the index of this child in the call graph listing,
          as an aid to locating it.



          * these fields are omitted for parents (or
          children) in the same cycle as the function.  If
          the function (or child) is a member of a cycle,
          the propagated times and propagation denominator
          represent the self time and descendent time of the
          cycle as a whole.

          ** static-only parents and children are indicated
          by a call count of 0.



          cycle listings:
          the cycle as a whole is listed with the same
          fields as a function entry.  Below it are listed
          the members of the cycle, and their contributions
          to the time and call counts of the cycle.

                                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/gprof.flat                            0100644 0001750 0001750 00000002050 12612724206 023537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        


flat profile:

 %         the percentage of the total running time of the
time       program used by this function.

cumulative a running sum of the number of seconds accounted
 seconds   for by this function and those listed above it.

 self      the number of seconds accounted for by this
seconds    function alone.  This is the major sort for this
           listing.

calls      the number of times this function was invoked, if
           this function is profiled, else blank.
 
 self      the average number of milliseconds spent in this
ms/call    function per call, if this function is profiled,
	   else blank.

 total     the average number of milliseconds spent in this
ms/call    function and its descendents per call, if this 
	   function is profiled, else blank.

name       the name of the function.  This is the minor sort
           for this listing. The index shows the location of
	   the function in the gprof listing. If the index is
	   in parenthesis it shows where it would appear in
	   the gprof listing if it were to be printed.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/gprof.h                               0100644 0001750 0001750 00000025130 12612724206 023044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: gprof.h,v 1.4 1996/12/22 20:24:24 rahnds Exp $	*/
/*	$NetBSD: gprof.h,v 1.13 1996/04/01 21:54:06 mark Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)gprof.h	8.1 (Berkeley) 6/6/93
 */
#import <stdio.h>
#import <sys/types.h>
#import <sys/stat.h>
#import <gnu/a.out.h>
#ifdef __OPENSTEP__
#import <mach-o/rld_state.h>
#import <mach-o/gmon.h>
#else
#import <sys/gmon.h>
#endif
#import "stuff/bool.h"

/*
 * Used for comparison routine return values.
 */
#define	LESSTHAN	-1
#define	EQUALTO		0
#define	GREATERTHAN	1

#ifdef	NeXT_MOD
#define	UNIT short		/* unit of profiling */
#else
typedef	short UNIT;		/* unit of profiling */
#endif

/*
 * Progname for error messages.
 */
extern char *progname;

/*
 * Ticks per second.
 */
extern uint32_t hz;

extern char *a_outname;
#define	A_OUTNAME	"a.out"

extern char *gmonname;
#define	GMONNAME	"gmon.out"
#define	GMONSUM		"gmon.sum"
	
/*
 * Blurbs on the flat and graph profiles.
 */
#ifdef __OPENSTEP__
#define	FLAT_BLURB	"/usr/lib/gprof.flat"
#define	CALLG_BLURB	"/usr/lib/gprof.callg"
#else
#define	FLAT_BLURB	"/usr/share/gprof.flat"
#define	CALLG_BLURB	"/usr/share/gprof.callg"
#endif

/*
 * a constructed arc,
 *     with pointers to the namelist entry of the parent and the child,
 *     a count of how many times this arc was traversed,
 *     and pointers to the next parent of this child and
 * 	the next child of this parent.
 */
struct arcstruct {
    struct nl		*arc_parentp;	/* pointer to parent's nl entry */
    struct nl		*arc_childp;	/* pointer to child's nl entry */
    uint32_t		arc_count;	/* how calls from parent to child */
    uint32_t		arc_order;	/* order called */
    double		arc_time;	/* time inherited along arc */
    double		arc_childtime;	/* childtime inherited along arc */
    struct arcstruct	*arc_parentlist; /* parents-of-this-child list */
    struct arcstruct	*arc_childlist;	/* children-of-this-parent list */
};
typedef struct arcstruct	arctype;

/*
 * The symbol table;
 * for each external in the specified file we gather
 * its address, the number of calls and compute its share of cpu time.
 */
struct nl {
    char		*name;		/* the name */
    uint64_t		value;		/* the pc entry point */
    uint64_t		svalue;		/* entry point aligned to histograms */
    double		time;		/* ticks in this routine */
    double		childtime;	/* cumulative ticks in children */
    uint32_t		order;		/* order called */
    int32_t		ncall;		/* how many times called */
    int32_t		selfcalls;	/* how many calls to self */
    double		propfraction;	/* what % of time propagates */
    double		propself;	/* how much self time propagates */
    double		propchild;	/* how much child time propagates */
    enum bool		printflag;	/* should this be printed? */
    int			index;		/* index in the graph list */
    int			toporder;	/* graph call chain top-sort order */
    int			cycleno;	/* internal number of cycle on */
    struct nl		*cyclehead;	/* pointer to head of cycle */
    struct nl		*cnext;		/* pointer to next member of cycle */
    arctype		*parents;	/* list of caller arcs */
    arctype		*children;	/* list of callee arcs */
};
typedef struct nl	nltype;

extern nltype	*nl;			/* the whole namelist */
extern nltype	*npe;			/* the virtual end of the namelist */
extern uint32_t nname;		/* the number of function names */

/*
 * The list of file names and the ranges their pc's cover used for building
 * order files with the -S option.
 */
struct file { 
    uint64_t firstpc;
    uint64_t lastpc; 
    char *name;
    char *what_name;
}; 
extern struct file *files;
extern uint32_t n_files;

/*
 * flag which marks a nl entry as topologically ``busy''
 * flag which marks a nl entry as topologically ``not_numbered''
 */
#define	DFN_BUSY	-1
#define	DFN_NAN		0

/* 
 * namelist entries for cycle headers.
 * the number of discovered cycles.
 */
extern nltype	*cyclenl;	/* cycle header namelist */
extern int	ncycle;		/* number of cycles discovered */

/*
 * The information for the pc sample sets from the gmon.out file.
 */
struct sample_set {
    uint64_t s_lowpc;		/* lowpc from the profile file */
    uint64_t s_highpc;		/* highpc from the profile file */
    uint64_t lowpc;		/* range profiled, in UNIT's */
    uint64_t highpc;
    uint64_t sampbytes;		/* number of bytes of samples */
    uint64_t nsamples;		/* number of samples */
    unsigned UNIT *samples;	/* in core accumulated samples */
    double scale;		/* scale factor converting samples to
				   pc values: each sample covers scale
				   bytes */
#ifndef __OPENSTEP__
    int32_t version;
    int32_t profrate;
    int32_t spare[3];
#endif
};
extern struct sample_set *sample_sets;
extern uint32_t nsample_sets;
    
#ifdef __OPENSTEP__
/*
 * The rld loaded state from the gmon.out file.
 */
struct rld_loaded_state *grld_loaded_state;
extern uint32_t grld_nloaded_states;
extern void get_rld_state_symbols(void);
#endif

/*
 * The dyld images from the gmon.out file.
 */
struct dyld_image {
    char *name;
    uint64_t vmaddr_slide;
    uint64_t image_header;
};
extern uint32_t image_count;
extern struct dyld_image *dyld_images;
extern void get_dyld_state_symbols(void);

extern unsigned char	*textspace;	/* text space of a.out in core */

extern double	totime;			/* total time for all routines */
extern double	printtime;		/* total of time being printed */
extern double	actime;			/* accumulated time thus far for
					   putprofline */

/*
 * Option flags, from a to z.
 */
extern enum bool aflag;		/* suppress static functions */
extern enum bool bflag;		/* blurbs, too */
extern enum bool cflag;		/* discovered call graph, too */
extern enum bool dflag;		/* debugging options */
extern enum bool eflag;		/* specific functions excluded */
extern enum bool Eflag;		/* functions excluded with time */
extern enum bool fflag;		/* specific functions requested */
extern enum bool Fflag;		/* functions requested with time */
extern enum bool sflag;		/* sum multiple gmon.out files */
extern enum bool Sflag;		/* produce order file for scatter loading */
extern enum bool xflag;		/* don't produce gmon.order file */
extern enum bool zflag;		/* zero time/called functions, too */

/*
 * Structure for various string lists.
 */
struct stringlist {
    struct stringlist	*next;
    char		*string;
};
extern struct stringlist *elist;
extern struct stringlist *Elist;
extern struct stringlist *flist;
extern struct stringlist *Flist;

/*
 * The debug value for debugging gprof.
 */
extern uint32_t debug;

#define	DFNDEBUG	1
#define	CYCLEDEBUG	2
#define	ARCDEBUG	4
#define	TALLYDEBUG	8
#define	TIMEDEBUG	16
#define	SAMPLEDEBUG	32
#define	AOUTDEBUG	64
#define	CALLSDEBUG	128
#define	LOOKUPDEBUG	256
#define	PROPDEBUG	512
#define	ANYDEBUG	1024
#define	RLDDEBUG	2048
#define	DYLDDEBUG	4096

struct shlib_text_range {
    uint32_t lowpc;
    uint32_t highpc;
};
extern struct shlib_text_range *shlib_text_ranges;
extern uint32_t nshlib_text_ranges;

/*
 * External function declarations for the functions of the gprof source.
 */

/* arcs.c */
    extern void addarc(
	nltype *parentp,
	nltype *childp,
	uint32_t count,
	uint32_t order);

    extern nltype **doarcs(
	void);

/* calls.c */
    extern void findcalls(
	nltype *parentp,
	uint32_t p_lowpc,
	uint32_t p_highpc);

    /* dfn.c */
    extern void dfn(
	nltype *parentp);

/* getnfile.c */
    extern void getnfile(
	    void);

    extern void get_text_min_max(
	uint64_t *text_min,
	uint64_t *text_max);

/* hertz.c */
    extern uint32_t hertz(
	void);

/* lookup.c */
    extern nltype *nllookup(
	uint64_t address);

    extern arctype *arclookup(
	nltype *parentp,
	nltype *childp);

/* printgprof.c */
    extern void printgprof(
	nltype **timesortnlp);

    extern void printprof(
	void);

    extern void printindex(
	void);

    extern void printname(
	nltype *selfp);

    extern int totalcmp(
	nltype **npp1,
	nltype **npp2);

/* printlist.c */
    extern void addlist(
	struct stringlist *listp,
	char *funcname);

    extern enum bool onlist(
	struct stringlist *listp,
	char *funcname);

/* scatter.c */
    extern void printscatter(
	void);
                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/hertz.c                               0100644 0001750 0001750 00000006601 12612724206 023060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: hertz.c,v 1.2 1996/06/26 05:33:52 deraadt Exp $	*/
/*	$NetBSD: hertz.c,v 1.5 1995/04/19 07:16:03 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <stdint.h>
#include <sys/time.h>

    /*
     *	discover the tick frequency of the machine
     *	if something goes wrong, we return 0, an impossible hertz.
     */
#define	HZ_WRONG	0

uint32_t
hertz(
void)
{
	struct itimerval tim;

	tim.it_interval.tv_sec = 0;
	tim.it_interval.tv_usec = 1;
	tim.it_value.tv_sec = 0;
	tim.it_value.tv_usec = 0;
	setitimer(ITIMER_REAL, &tim, 0);
	setitimer(ITIMER_REAL, 0, &tim);
	if (tim.it_interval.tv_usec < 2)
		return(HZ_WRONG);
	return (1000000 / tim.it_interval.tv_usec);
}
                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/lookup.c                              0100644 0001750 0001750 00000010530 12612724206 023231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: lookup.c,v 1.2 1996/06/26 05:33:53 deraadt Exp $	*/
/*	$NetBSD: lookup.c,v 1.5 1995/04/19 07:16:06 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "gprof.h"

/*
 * look up an address in a sorted-by-address namelist
 *    this deals with misses by mapping them to the next lower 
 *    entry point.
 */
nltype *
nllookup(
uint64_t address)
{
    int32_t low;
    int32_t middle;
    int32_t high;

#ifdef DEBUG
    int probes;

	probes = 0;
#endif
	for(low = 0, high = nname; low != high ; ){
#ifdef DEBUG
	    probes += 1;
#endif
	    middle = (high + low) >> 1;
	    if(nl[middle].value <= address && nl[middle+1].value > address){
#ifdef DEBUG
		if(debug & LOOKUPDEBUG){
		    printf("[nllookup] %d (%u) probes\n", probes, nname-1);
		}
#endif
		return(&nl[middle]);
	    }
	    if(nl[middle].value > address){
		high = middle;
	    }
	    else{
		low = middle + 1;
	    }
	}
	fprintf(stderr, "[nllookup] binary search fails for address 0x%x\n",
		(unsigned int)address );
	return(NULL);
}

arctype *
arclookup(
nltype *parentp,
nltype *childp)
{
    arctype *arcp;

	if(parentp == 0 || childp == 0){
	    printf("[arclookup] parentp == 0 || childp == 0\n");
	    return(NULL);
	}
#ifdef DEBUG
	if(debug & LOOKUPDEBUG){
	    printf("[arclookup] parent %s child %s\n",
		   parentp->name, childp->name);
	}
#endif
	for(arcp = parentp->children; arcp ; arcp = arcp->arc_childlist){
#ifdef DEBUG
	    if(debug & LOOKUPDEBUG){
		printf("[arclookup]\t arc_parent %s arc_child %s\n",
		       arcp->arc_parentp->name,
		       arcp->arc_childp->name);
	    }
#endif
	    if(arcp->arc_childp == childp){
		return(arcp);
	    }
	}
	return(NULL);
}
                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/m68k.h                                0100644 0001750 0001750 00000006331 12612724206 022516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: m68k.h,v 1.2 1996/06/26 05:33:54 deraadt Exp $	*/
/*	$NetBSD: m68k.h,v 1.3 1995/04/19 07:16:09 cgd Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)hp300.h	8.1 (Berkeley) 6/6/93
 */
    /*
     *	offset (in bytes) of the code from the entry address of a routine.
     *	(see asgnsamples for use and explanation.)
     */
#define OFFSET_OF_CODE	0
#define	UNITS_TO_CODE	(OFFSET_OF_CODE / sizeof(UNIT))

#define BSR_OP		0x6100
#define BSR_MASK	0xff00
#define JBSR_OP		0x4e80
#define JBSR_MASK	0xffc0

                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/printgprof.c                          0100644 0001750 0001750 00000050567 12612724206 024130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: printgprof.c,v 1.2 1996/06/26 05:33:59 deraadt Exp $	*/
/*	$NetBSD: printgprof.c,v 1.5 1995/04/19 07:16:21 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <stdlib.h>
#include "gprof.h"
#include "stuff/errors.h"

static int timecmp(
    nltype **npp1,
    nltype **npp2);

static void flatprofheader(
    void);

static void flatprofline(
    nltype *np);

static void gprofheader(
    void);

static void gprofline(
    nltype *np);

static void printparents(
    nltype *childp);

static void printchildren(
    nltype *parentp);

static void sortchildren(
    nltype *parentp);

static void sortparents(
    nltype *childp);

static void printcycle(
    nltype *cyclep);

static void printmembers(
    nltype *cyclep);

static void sortmembers(
    nltype *cyclep);

static int membercmp(
    nltype *this,
    nltype *that);

static int arccmp(
    arctype *thisp,
    arctype *thatp);

static void printblurb(
    char *blurbname);

static int namecmp(
    nltype **npp1,
    nltype **npp2);

void
printprof(
void)
{
    nltype *np;
    nltype **sortednlp;
    uint32_t index;

	actime = 0.0;
	printf("\f\n");
	flatprofheader();
	/*
	 * Sort the symbol table in by time.
	 */
	sortednlp = (nltype **)calloc(nname, sizeof(nltype *));
	if(sortednlp == (nltype **)0)
	    fatal("[printprof] ran out of memory for time sorting");
	for(index = 0; index < nname; index += 1){
	    sortednlp[index] = &nl[index];
	}
	qsort(sortednlp, nname, sizeof(nltype *),
	      (int (*)(const void *, const void *))timecmp);
	for(index = 0; index < nname; index += 1){
	    np = sortednlp[index];
	    flatprofline(np);
	}
	actime = 0.0;
	free(sortednlp);
}

static
int
timecmp(
nltype **npp1,
nltype **npp2)
{
    double timediff;
    int32_t calldiff;

	timediff = (*npp2)->time - (*npp1)->time;
	if(timediff > 0.0)
	    return(1);
	if(timediff < 0.0)
	    return(-1);
	calldiff = (*npp2)->ncall - (*npp1)->ncall;
	if(calldiff > 0)
	    return(1);
	if(calldiff < 0)
	    return(-1);
	return(strcmp((*npp1)->name, (*npp2)->name));
}

/*
 * header for flatprofline
 */
static
void
flatprofheader(
void)
{
    
	if(bflag == TRUE){
	    printblurb(FLAT_BLURB);
	}
	printf("\ngranularity: each sample hit covers %lu byte(s)",
	       (int32_t)sample_sets->scale * sizeof(UNIT) );
	if(totime > 0.0){
	    printf(" for %.2f%% of %.2f seconds\n\n",
		   100.0/totime , totime / hz );
	}
	else{
	    printf(" no time accumulated\n\n");
	    /*
	     * this doesn't hurt since all the numerators will be zero.
	     */
	    totime = 1.0;
	}
	printf("%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
	       "%  ", "cumulative", "self  ", "", "self  ", "total ", "");
	printf("%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
	       "time", "seconds ", "seconds", "calls",
	       "ms/call", "ms/call", "name");
}

static
void
flatprofline(
nltype *np)
{
	if(zflag == FALSE && np->ncall == 0 && np->time == 0){
	    return;
	}
	actime += np->time;
	printf("%5.1f %10.2f %8.2f",
	       100 * np->time / totime, actime / hz, np->time / hz);
	if(np->ncall != 0){
	    printf(" %8d %8.2f %8.2f  ", np->ncall,
		   1000 * np->time / hz / np->ncall,
		   1000 * (np->time + np->childtime) / hz / np->ncall);
	}
	else{
	    printf(" %8.8s %8.8s %8.8s  ", "", "", "");
	}
	printname(np);
	printf("\n");
}

static
void
gprofheader(
void)
{
	if(bflag == TRUE){
	    printblurb(CALLG_BLURB);
	}
	printf("\ngranularity: each sample hit covers %lu byte(s)",
	       (int32_t)sample_sets->scale * sizeof(UNIT));
	if(printtime > 0.0){
	    printf(" for %.2f%% of %.2f seconds\n\n",
		   100.0 / printtime, printtime / hz);
	}
	else{
	    printf(" no time propagated\n\n");
	    /*
	     * this doesn't hurt, since all the numerators will be 0.0
	     */
	    printtime = 1.0;
	}
	printf("%6.6s %5.5s %7.7s %11.11s %7.7s/%-7.7s     %-8.8s\n",
	       "", "", "", "", "called", "total", "parents");
	printf("%-6.6s %5.5s %7.7s %11.11s %7.7s+%-7.7s %-8.8s\t%5.5s\n",
	       "index", "%time", "self", "descendents",
	       "called", "self", "name", "index");
	printf("%6.6s %5.5s %7.7s %11.11s %7.7s/%-7.7s     %-8.8s\n",
	       "", "", "", "", "called", "total", "children");
	printf("\n");
}

static
void
gprofline(
nltype *np)
{
    char kirkbuffer[BUFSIZ];

	sprintf(kirkbuffer, "[%d]", np->index);
	printf("%-6.6s %5.1f %7.2f %11.2f",
		kirkbuffer ,
		100 * ( np -> propself + np -> propchild ) / printtime ,
		np -> propself / hz ,
		np -> propchild / hz );
	if((np->ncall + np->selfcalls) != 0){
	    printf(" %7d", np->ncall);
	    if(np->selfcalls != 0)
		printf("+%-7d", np->selfcalls);
	    else
		printf(" %7.7s ", "");
	}
	else{
	    printf(" %7.7s %7.7s ", "", "");
	}
	printname(np);
	printf("\n");
}

void
printgprof(
nltype **timesortnlp)
{
    uint32_t index;
    nltype *parentp;

	/*
	 * Print out the structured profiling list
	 */
	gprofheader();
	for(index = 0; index < nname + ncycle; index ++){
	    parentp = timesortnlp[index];
	    if(zflag == FALSE &&
	       parentp->ncall == 0 &&
	       parentp->selfcalls == 0 &&
	       parentp->propself == 0 &&
	       parentp->propchild == 0 ){
		continue;
	    }
	    if(!parentp->printflag){
		continue;
	    }
	    if(parentp->name == 0 && parentp->cycleno != 0){
		/*
		 * cycle header
		 */
		printcycle(parentp);
		printmembers(parentp);
	    }
	    else{
		printparents(parentp);
		gprofline(parentp);
		printchildren(parentp);
	    }
	    printf("\n");
	    printf("-----------------------------------------------\n");
	    printf("\n");
	}
	free(timesortnlp);
}

/*
 * sort by decreasing propagated time
 * if times are equal, but one is a cycle header,
 * 	say that's first (e.g. less, i.e. -1).
 * if one's name doesn't have an underscore and the other does,
 * 	say the one is first.
 * all else being equal, sort by names.
 */
int
totalcmp(
nltype **npp1,
nltype **npp2)
{
    nltype *np1, *np2;
    double diff;

	np1 = *npp1;
	np2 = *npp2;
	diff =    (np1->propself + np1->propchild)
		- (np2->propself + np2->propchild);
	if(diff < 0.0)
	    return(1);
	if(diff > 0.0)
	    return(-1);
	if(np1->name == 0 && np1->cycleno != 0) 
	    return(-1);
	if(np2->name == 0 && np2->cycleno != 0)
	    return(1);
	if(np1->name == 0)
	    return(-1);
	if(np2->name == 0)
	    return(1);
	if(*(np1->name) != '_' && *(np2->name) == '_')
	    return(-1);
	if(*(np1->name) == '_' && *(np2->name) != '_')
	    return(1);
	if(np1->ncall > np2->ncall)
	    return(-1);
	if(np1->ncall < np2->ncall) 
	    return(1);
	return(strcmp(np1->name, np2->name));
}

static
void
printparents(
nltype *childp)
{
    nltype *parentp;
    arctype *arcp;
    nltype *cycleheadp;

	if(childp->cyclehead != 0){
	    cycleheadp = childp->cyclehead;
	}
	else{
	    cycleheadp = childp;
	}
	if(childp->parents == 0){
	    printf("%6.6s %5.5s %7.7s %11.11s %7.7s %7.7s     <spontaneous>\n",
		    "" , "" , "" , "" , "" , "" );
	    return;
	}
	sortparents(childp);
	for(arcp = childp->parents; arcp; arcp = arcp->arc_parentlist){
	    parentp = arcp->arc_parentp;
	    if(childp == parentp ||
	       (childp->cycleno != 0 && parentp->cycleno == childp->cycleno)){
		/*
		 * selfcall or call among siblings
		 */
		printf("%6.6s %5.5s %7.7s %11.11s %7u %7.7s     ",
		       "" , "" , "" , "", arcp->arc_count, "");
		printname(parentp);
		printf("\n");
	    }
	    else{
		/*
		 * regular parent of child
		 */
		printf("%6.6s %5.5s %7.2f %11.2f %7u/%-7d     ",
		       "" , "" ,
		       arcp->arc_time / hz, arcp->arc_childtime / hz,
		       arcp->arc_count, cycleheadp->ncall);
		printname(parentp);
		printf("\n");
	    }
	}
}

static
void
printchildren(
nltype *parentp)
{
    nltype *childp;
    arctype *arcp;

	sortchildren(parentp);
	arcp = parentp->children;
	for(arcp = parentp->children; arcp; arcp = arcp->arc_childlist){
	    childp = arcp->arc_childp;
	    if(childp == parentp ||
	       (childp->cycleno != 0 && childp->cycleno == parentp->cycleno)){
		/*
		 * self call or call to sibling
		 */
		printf("%6.6s %5.5s %7.7s %11.11s %7u %7.7s     ",
		       "", "", "", "", arcp->arc_count, "");
		printname(childp);
		printf("\n");
	    }
	    else{
		/*
		 * regular child of parent
		 */
		printf("%6.6s %5.5s %7.2f %11.2f %7u/%-7d     ",
		       "", "",
		       arcp->arc_time / hz, arcp->arc_childtime / hz,
		       arcp->arc_count, childp->cyclehead->ncall);
		printname(childp);
		printf("\n");
	    }
	}
}

void
printname(
nltype *selfp)
{

	if(selfp->name != NULL){
	    printf("%s", selfp->name);
#ifdef DEBUG
	    if(debug & DFNDEBUG){
		printf("{%d} ", selfp->toporder);
	    }
	    if(debug & PROPDEBUG){
		printf("%5.2f%% ", selfp->propfraction);
	    }
#endif
	}
	if(selfp->cycleno != 0){
	    printf(" <cycle %d>", selfp->cycleno);
	}
	if(selfp->index != 0){
	    if(selfp->printflag){
		printf(" [%d]", selfp->index );
	    }else{
		printf(" (%d)", selfp->index );
	    }
	}
}

static
void
sortchildren(
nltype *parentp)
{
    arctype *arcp;
    arctype *detachedp;
    arctype sorted;
    arctype *prevp;

	detachedp = NULL;
	/*
	 * unlink children from parent,
	 * then insertion sort back on to sorted's children.
	 *     *arcp	the arc you have detached and are inserting.
	 *     *detachedp	the rest of the arcs to be sorted.
	 *     sorted	arc list onto which you insertion sort.
	 *     *prevp	arc before the arc you are comparing.
	 */
	sorted.arc_childlist = 0;
#ifdef notdef
	for((arcp = parentp->children) && (detachedp = arcp->arc_childlist);
	    arcp;
	    (arcp = detachedp) && (detachedp = detachedp->arc_childlist)){
#endif
	if((arcp = parentp->children) != NULL)
	    detachedp = arcp->arc_childlist;
	while(arcp != NULL){
	    /*
	     * consider *arcp as disconnected
	     * insert it into sorted
	     */
	    for(prevp = &sorted;
		prevp->arc_childlist;
		prevp = prevp->arc_childlist){
		if(arccmp(arcp, prevp->arc_childlist) != LESSTHAN){
		    break;
		}
	    }
	    arcp->arc_childlist = prevp->arc_childlist;
	    prevp->arc_childlist = arcp;
	    if((arcp = detachedp) != NULL)
		detachedp = detachedp->arc_childlist;
	}
	/*
	 * reattach sorted children to parent
	 */
	parentp->children = sorted.arc_childlist;
}

static
void
sortparents(
nltype *childp)
{
    arctype *arcp;
    arctype *detachedp;
    arctype sorted;
    arctype *prevp;

	detachedp = NULL;
	/*
	 * unlink parents from child,
	 * then insertion sort back on to sorted's parents.
	 *     *arcp	the arc you have detached and are inserting.
	 *     *detachedp	the rest of the arcs to be sorted.
	 *     sorted	arc list onto which you insertion sort.
	 *     *prevp	arc before the arc you are comparing.
	 */
	sorted.arc_parentlist = 0;
#ifdef notdef
	for((arcp = childp->parents) && (detachedp = arcp->arc_parentlist);
	    arcp;
	    (arcp = detachedp) && (detachedp = detachedp->arc_parentlist)){
#endif
	if((arcp = childp->parents) != NULL)
	    detachedp = arcp->arc_parentlist;
	while(arcp != NULL){
	    /*
	     * consider *arcp as disconnected
	     * insert it into sorted
	     */
	    for(prevp = &sorted;
		prevp->arc_parentlist;
		prevp = prevp->arc_parentlist){
		if(arccmp(arcp, prevp->arc_parentlist) != GREATERTHAN){
		    break;
		}
	    }
	    arcp->arc_parentlist = prevp->arc_parentlist;
	    prevp->arc_parentlist = arcp;
	    if((arcp = detachedp) != NULL)
		detachedp = detachedp->arc_parentlist;
	}
	/*
	 * reattach sorted arcs to child
	 */
	childp->parents = sorted.arc_parentlist;
}

/*
 * print a cycle header
 */
static
void
printcycle(
nltype *cyclep)
{
    char kirkbuffer[BUFSIZ];

	sprintf(kirkbuffer, "[%d]", cyclep->index);
	printf("%-6.6s %5.1f %7.2f %11.2f %7d",
	       kirkbuffer,
	       100 * (cyclep->propself + cyclep->propchild) / printtime,
	       cyclep->propself / hz,
	       cyclep->propchild / hz,
	       cyclep->ncall);
	if(cyclep->selfcalls != 0){
	    printf("+%-7d", cyclep->selfcalls);
	}
	else{
	    printf(" %7.7s", "");
	}
	printf(" <cycle %d as a whole>\t[%d]\n",
	       cyclep->cycleno, cyclep->index);
}

/*
 * print the members of a cycle
 */
static
void
printmembers(
nltype *cyclep)
{
    nltype *memberp;

	sortmembers(cyclep);
	for(memberp = cyclep->cnext; memberp; memberp = memberp->cnext){
	    printf("%6.6s %5.5s %7.2f %11.2f %7d", 
		   "", "", memberp->propself / hz, memberp->propchild / hz,
		   memberp->ncall);
	    if(memberp->selfcalls != 0){
		printf("+%-7d", memberp->selfcalls);
	    }
	    else{
		printf(" %7.7s", "");
	    }
	    printf("     ");
	    printname(memberp);
	    printf("\n");
	}
}

/*
 * sort members of a cycle
 */
static
void
sortmembers(
nltype *cyclep)
{
    nltype *todo;
    nltype *doing;
    nltype *prev;

	/*
	 *	detach cycle members from cyclehead,
	 *	and insertion sort them back on.
	 */
	todo = cyclep->cnext;
	cyclep->cnext = 0;
#ifdef notdef
	for((doing = todo) && (todo = doing->cnext);
	    doing;
	    (doing = todo) && (todo = doing->cnext)){
#endif
	if((doing = todo) != NULL)
	    todo = doing->cnext;
	while(doing != NULL){
	    for(prev = cyclep; prev->cnext; prev = prev->cnext){
		if(membercmp(doing, prev->cnext) == GREATERTHAN){
		    break;
		}
	    }
	    doing->cnext = prev->cnext;
	    prev->cnext = doing;
	    if((doing = todo) != NULL)
		todo = doing->cnext;
	}
}

/*
 * major sort is on propself + propchild,
 * next is sort on ncalls + selfcalls.
 */
static
int
membercmp(
nltype *this,
nltype *that)
{
    double thistime, thattime;
    int32_t thiscalls, thatcalls;

    thistime = this->propself + this->propchild;
    thattime = that->propself + that->propchild;
    thiscalls = this->ncall + this->selfcalls;
    thatcalls = that->ncall + that->selfcalls;

    if(thistime > thattime){
	return(GREATERTHAN);
    }
    if(thistime < thattime){
	return(LESSTHAN);
    }
    if(thiscalls > thatcalls){
	return(GREATERTHAN);
    }
    if(thiscalls < thatcalls){
	return(LESSTHAN);
    }
    return(EQUALTO);
}
/*
 * compare two arcs to/from the same child/parent.
 * - if one arc is a self arc, it's least.
 * - if one arc is within a cycle, it's less than.
 * - if both arcs are within a cycle, compare arc counts.
 * - if neither arc is within a cycle, compare with
 * 	arc_time + arc_childtime as major key
 * 	arc count as minor key
 */
static
int
arccmp(
arctype *thisp,
arctype *thatp)
{
    nltype *thisparentp, *thischildp, *thatparentp, *thatchildp;
    double thistime, thattime;

	thisparentp = thisp->arc_parentp;
	thischildp  = thisp->arc_childp;
	thatparentp = thatp->arc_parentp;
	thatchildp  = thatp->arc_childp;

#ifdef DEBUG
	if(debug & TIMEDEBUG){
	    printf("[arccmp] ");
	    printname(thisparentp);
	    printf(" calls ");
	    printname(thischildp);
	    printf(" %f + %f %u/%d\n",
		   thisp->arc_time, thisp->arc_childtime,
		   thisp->arc_count, thischildp->ncall);
	    printf("[arccmp] ");
	    printname(thatparentp);
	    printf(" calls ");
	    printname(thatchildp);
	    printf(" %f + %f %u/%d\n",
		thatp->arc_time, thatp->arc_childtime,
		thatp->arc_count, thatchildp->ncall);
	    printf("\n");
	}
#endif /* DEBUG */
	if(thisparentp == thischildp){
	    /* this is a self call */
	    return(LESSTHAN);
	}
	if(thatparentp == thatchildp){
	    /* that is a self call */
	    return(GREATERTHAN);
	}
	if(thisparentp->cycleno != 0 && thischildp->cycleno != 0 &&
	   thisparentp->cycleno == thischildp->cycleno){
	    /* this is a call within a cycle */
	    if(thatparentp->cycleno != 0 && thatchildp->cycleno != 0 &&
	       thatparentp->cycleno == thatchildp->cycleno){
		/* that is a call within the cycle, too */
		if(thisp->arc_count < thatp->arc_count){
		    return(LESSTHAN);
		}
		if(thisp->arc_count > thatp->arc_count){
		    return(GREATERTHAN);
		}
		return(EQUALTO);
	    }
	    else{
		/* that isn't a call within the cycle */
		return(LESSTHAN);
	    }
	}
	else{
	    /* this isn't a call within a cycle */
	    if(thatparentp->cycleno != 0 && thatchildp->cycleno != 0 &&
	       thatparentp->cycleno == thatchildp->cycleno){
		/* that is a call within a cycle */
		return(GREATERTHAN);
	    }
	    else{
		/* neither is a call within a cycle */
		thistime = thisp->arc_time + thisp->arc_childtime;
		thattime = thatp->arc_time + thatp->arc_childtime;
		if(thistime < thattime)
		    return(LESSTHAN);
		if(thistime > thattime)
		    return(GREATERTHAN);
		if(thisp->arc_count < thatp->arc_count)
		    return(LESSTHAN);
		if(thisp->arc_count > thatp->arc_count)
		    return(GREATERTHAN);
		return(EQUALTO);
	    }
	}
}

static
void
printblurb(
char *blurbname)
{
    FILE *blurbfile;
    int input;

	blurbfile = fopen(blurbname, "r");
	if(blurbfile == NULL){
	    perror(blurbname);
	    return;
	}
	while((input = getc(blurbfile)) != EOF){
	    putchar(input);
	}
	fclose(blurbfile);
}

static
int
namecmp(
nltype **npp1,
nltype **npp2)
{
	return(strcmp((*npp1)->name, (*npp2)->name));
}

void
printindex(
void)
{
    nltype **namesortnlp;
    nltype *nlp;
    uint32_t index, nnames, todo, i, j;
    char peterbuffer[BUFSIZ];

	/*
	 * Now, sort regular function name alphbetically
	 * to create an index.
	 */
	namesortnlp = (nltype **)calloc(nname + ncycle, sizeof(nltype *));
	if(namesortnlp == NULL)
	    fatal("ran out of memory for sorting");

	for(index = 0, nnames = 0; index < nname; index++){
	    if(zflag == 0 && nl[index].ncall == 0 && nl[index].time == 0)
		continue;
	    namesortnlp[nnames++] = &nl[index];
	}
	qsort(namesortnlp, nnames, sizeof(nltype *),
	      (int (*)(const void *, const void *))namecmp);
	for(index = 1, todo = nnames; index <= (uint32_t)ncycle; index++){
	    namesortnlp[todo++] = &cyclenl[index];
	}
	printf("\f\nIndex by function name\n\n");
	index = ( todo + 2 ) / 3;
	for(i = 0; i < index ; i++){
	    for(j = i; j < todo; j += index){
		nlp = namesortnlp[j];
		if(nlp->printflag){
		    sprintf(peterbuffer, "[%d]", nlp->index);
		}
		else{
		    sprintf(peterbuffer, "(%d)", nlp->index);
		}
		if(j < nnames){
		    printf("%6.6s %-19.19s", peterbuffer, nlp->name);
		}
		else{
		    printf("%6.6s ", peterbuffer);
		    sprintf(peterbuffer, "<cycle %d>", nlp->cycleno);
		    printf("%-19.19s", peterbuffer);
		}
	    }
	    printf("\n");
	}
	free(namesortnlp);
}
                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/printlist.c                           0100644 0001750 0001750 00000007740 12612724206 023761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: printlist.c,v 1.2 1996/06/26 05:33:59 deraadt Exp $	*/
/*	$NetBSD: printlist.c,v 1.5 1995/04/19 07:16:23 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <stdlib.h>
#include "stuff/errors.h"
#include "gprof.h"

/*
 * these are the lists of names:
 * there is the list head and then the listname
 * is a pointer to the list head
 * (for ease of passing to stringlist functions).
 */
struct stringlist	fhead = { 0 , 0 };
struct stringlist	*flist = &fhead;
struct stringlist	Fhead = { 0 , 0 };
struct stringlist	*Flist = &Fhead;
struct stringlist	ehead = { 0 , 0 };
struct stringlist	*elist = &ehead;
struct stringlist	Ehead = { 0 , 0 };
struct stringlist	*Elist = &Ehead;

void
addlist(
struct stringlist *listp,
char *funcname)
{
    struct stringlist *slp;

	slp = (struct stringlist *)malloc(sizeof(struct stringlist));
	if(slp == NULL)
	    fatal("ran out room for printlist");
	slp->next = listp->next;
	slp->string = funcname;
	listp->next = slp;
}

enum bool
onlist(
struct stringlist *listp,
char *funcname)
{
    struct stringlist *slp;

	for(slp = listp->next; slp; slp = slp->next){
	    if(!strcmp(slp->string, funcname)){
		return(TRUE);
	    }
	    if(funcname[0] == '_' && !strcmp(slp->string, &funcname[1])){
		return(TRUE);
	    }
	}
	return(FALSE);
}
                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/scatter.c                             0100644 0001750 0001750 00000032324 12612724206 023372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#undef DEBUG
#include <string.h>
#include <stdio.h>
#include <libc.h>
#include <limits.h>
#include <sys/mman.h>
#include "stuff/errors.h"
#include "gprof.h"

static uint64_t text_min = 0;
static uint64_t text_max = 0;

struct Edgestruct { 
    struct Edgestruct *next1;
    struct Edgestruct *next2;
    struct Edgestruct *prev1;
    struct Edgestruct *prev2;
    struct Edgestruct **pqp;
    int v1;
    int v2;
    int w;
};
typedef struct Edgestruct Edge;

struct TreeNodestruct { 
    Edge *next1;
    Edge *next2; 
    int parent;
    int left;
    int right;
};
typedef struct TreeNodestruct TreeNode;

#define NONE -1
#define SEEN -2

static FILE *gmon = NULL;
static FILE *callf = NULL;
static FILE *callo = NULL;
static FILE *callt = NULL;
#ifdef notdef
static FILE *treefile = NULL;
#endif

static TreeNode *tree = NULL;
static int n_nodes = 0;
static Edge **pq = NULL;
static int n_pq = 0;
static char *whatsloaded = NULL;
static Edge *free_edges = NULL;
static Edge pqzero = { NULL, NULL, NULL, NULL, NULL, 0, 0, INT_MAX };

static void pqinsert(
    Edge *edge);
static Edge *pqremove(
    void);
static void pqdelete(
    Edge *edge);
static void upheap(
    int k);
static void downheap(
    int k);

static
void
do_what(
void)
{
    struct file *afile;
    char *start, *stop, *dest, *whatsloadedp, ar_name[16], *namep;

	for(afile = files; afile < &files[n_files]; afile++){
	    if((namep = strrchr(afile->name, '/')))
		namep++; 
	    else
		namep = afile->name;
	    strncpy(ar_name, namep, 15);
	    ar_name[15] = '\0';
	    whatsloadedp = whatsloaded;
	    while((start = stop = strstr(whatsloadedp, ar_name))){
		if((start == whatsloaded) || (*(start-1) == '(') ||
		   (*(start-1) == '/')) {
		    while((*start != '\n') && (start >= whatsloaded))
			start--;
		    while((*stop != '\n') && (*stop != ')'))
			stop++;
		    afile->what_name = dest = malloc(stop - start);
		    for(start++; start < stop; start++){
			*(dest++) = (*start == '(') ? ':' : *start;
		    }
		    *dest = '\0';
		    break;
		}
		whatsloadedp = start + 1;
	    }
	}
} 

static
char *
find_file(
uint64_t pc)
{
    struct file *afile;
    static int flag = 0;

	for(afile = files; afile < &files[n_files]; afile++){
	    if((pc >= afile->firstpc) && (pc < afile->lastpc)){
		return(afile->what_name);
	    }
	}
	if(flag == 0){
	    fprintf(stderr, "In producing order files can't find module name "
		    "for functions (make sure all modules are compiled -g and "
		    "the program is not already ordered)\n");
	    flag = 1;
	}
	return(NULL);
}

static
int
printp(
nltype *node,
FILE *f)
{
	if(f == callt){
	    if(zflag == FALSE && node->ncall == 0 && node->time == 0)
		return(0);
	    else
		return(1);
	}
	if(node->ncall == 0) /* call count 0 (not called) */
	    return(0);
	if(node->order == 0) /* not ordered (not called) */
	    return(0);
	if(node->value < text_min || node->value > text_max)
	    return(0);
	return(1);
/*
	return(!( (node->ncall == 0) &&
		  (node->selfcalls == 0) &&
		  (node->propself == 0) &&
		  (node->propchild == 0) &&
		  (node->value >= text_min && node->value < text_max) ) );
  return ! ((node->ncall == 0) &&
	    (node->selfcalls == 0) &&
	    (node->propself == 0) &&
	    (node->propchild == 0)
	 && (node->value >= text_min && node->value < text_max));
*/
}

/*
  void indent_node(int node, int level)
  for (i = 0; i < level; i++) fprintf(treefile, "  ");
  fprintf(treefile, "%d %s\n", node, (node < npe - nl) ? nl[node].name : "");
  */

static
void
print_node(
int node)
{
    nltype *nlp;
    char *file;

	if((node == NONE) || (tree[node].parent == SEEN))
	    return;
	if(node < (npe - nl)){
	    nlp = &nl[node];
	    if(printp(nlp, NULL)){
		file = find_file(nlp->value);
		fprintf(gmon, "%s:%s\n", file ? file : "", nlp->name);
	    }
	}
	tree[node].parent = SEEN;
	print_node(tree[node].left);
	print_node(tree[node].right);
}

static
void
print_nl(
FILE *f)
{
    nltype *nlp;
    char *file;

	for(nlp = npe-1; nlp >= nl; nlp--){
	    if(printp(nlp, f)){
		file = find_file(nlp->value);
		fprintf(f, "%s:%s\n", file ? file : "", nlp->name);
	    }
	}
}

static
void print_tree(
void)
{
    int i;

	for(i = n_nodes-1; i >= 0; i--){
	    if(tree[i].parent != SEEN)
		print_node(i);
	}
}

static
Edge *
find_edge(
int v1,
int v2,
int w)
{
    Edge *edge;

	for(edge = tree[v1].next1; edge; edge = edge->next1){
	    if(edge->v2 == v2){
		edge->w += w;
		return(edge);
	    }
	}
	return(NULL);
} 

static
Edge *
make_edge(
int v1,
int v2, 
int w)
{
    Edge *edge;

	if(free_edges){
	    edge = free_edges;
	    free_edges = free_edges->next1;
	}
	else
	    edge = (Edge *)malloc(sizeof(Edge));
	edge->v1 = v1;
	edge->v2 = v2; 
	edge->w = w;

	edge->next1 = tree[v1].next1;
	if(edge->next1)
	    edge->next1->prev1 = edge;
	tree[v1].next1 = edge;
	edge->prev1 = NULL;
	
	edge->next2 = tree[v2].next2; 
	if(edge->next2)
	    edge->next2->prev2 = edge;
	tree[v2].next2 = edge;
	edge->prev2 = NULL;

	edge->pqp = NULL;
	return(edge);
}

static
void
free_edge(
Edge *edge)
{
	if(edge->prev1)
	    edge->prev1->next1 = edge->next1;
	else
	    tree[edge->v1].next1 = edge->next1;

	if(edge->next1)
	    edge->next1->prev1 = edge->prev1;

	if(edge->prev2)
	    edge->prev2->next2 = edge->next2;
	else
	    tree[edge->v2].next2 = edge->next2;

	if(edge->next2)
	    edge->next2->prev2 = edge->prev2;

	edge->next1 = free_edges;
	free_edges = edge;
}

static
int
compare_file(
struct file *x,
struct file *y)
{
	if(x->firstpc < y->firstpc)
	    return(-1);
	else if(x->firstpc > y->firstpc)
	    return(1);
	else
	    return(0);
}

static
int
compare_nl(
nltype *x,
nltype *y)
{
	if(x->ncall < y->ncall)
	    return(-1);
	else if(x->ncall > y->ncall)
	    return(1);
	else
	    return(0);
}

static
int
compare_nl_order(
nltype *x,
nltype *y)
{
	if(x->order > y->order)
	    return(-1);
	else if(x->order < y->order)
	    return(1);
	else
	    return(0);
}

static
int
timecmp(
nltype *npp1,
nltype *npp2)
{
    double timediff;
    int32_t calldiff;

	timediff = npp2->time - npp1->time;
	if(timediff > 0.0)
	    return(-1);
	if(timediff < 0.0)
	    return(1);
	calldiff = npp2->ncall - npp1->ncall;
	if(calldiff > 0)
	    return(-1);
	if(calldiff < 0)
	    return(1);
	return(strcmp(npp2->name, npp1->name));
}

static
void
enum_arcs(
void(*proc)(arctype *arc,
	    arctype *backarc))
{
    nltype *nlp;
    arctype *arcp, *backarc;

	for(nlp = nl; nlp < npe; nlp++){
	    for(arcp = nlp->children; arcp ; arcp = arcp->arc_childlist){
		for(backarc = arcp->arc_childp->children;
		    backarc;
		    backarc = backarc->arc_childlist){
		    if(backarc->arc_childp == nlp){
			if(nlp < arcp->arc_childp)
			    proc(arcp, backarc);
			goto skip;
		    }
		}
		proc(arcp, NULL);
skip:
		continue;
	    }
	}
}

static int most_edges = 0;
static
void
most_edges_proc(
arctype *arc,
arctype *backarc)
{ 
	most_edges++; 
}

static
void
enum_edges(
int v,
int(*proc_e1)(Edge *),
int(*proc_e2)(Edge *))
{
    Edge *edge;
    Edge *next1, *next2;

	edge = tree[v].next1; 
	while(edge){
	    next1 = edge->next1; 
	    if(proc_e1(edge))
		free_edge(edge);
	    edge = next1;
	}
	edge = tree[v].next2; 
	while(edge){
	  next2 = edge->next2;
	  if(proc_e2(edge))
		free_edge(edge);
	  edge = next2;
	}
}

static
int
make_edge_e1(
Edge *edge)
{
	if(edge->pqp){
	    pqdelete(edge); 
	    make_edge(n_nodes, edge->v2, edge->w);
	    return(1);
	}
	else{
	    return(0);
	}
}

static
int
make_edge_e2(
Edge *edge)
{
	if(edge->pqp){
	    pqdelete(edge);
	    make_edge(n_nodes, edge->v1, edge->w);
	    return(1);
	}
	else{
	    return(0);
	}
}

static
int
find_edge_e1(
Edge *edge)
{
	if(edge->pqp){
	    pqdelete(edge); 
	    if(!find_edge(n_nodes, edge->v2, edge->w))
		make_edge(n_nodes, edge->v2, edge->w);
	    return(1);
	}
	else{
	    return(0);
	}
}

static
int
find_edge_e2(
Edge *edge)
{
	if(edge->pqp){
	    pqdelete(edge);
	    if(!find_edge(n_nodes, edge->v1, edge->w))
		make_edge(n_nodes, edge->v1, edge->w);
	    return(1);
	}
	else{
	    return(0);
	}
}

static
int
pqinsert_e1(
Edge *edge)
{
	if(!edge->pqp)
	    pqinsert(edge);
	return(0);
}

static
void
main_loop(
void)
{
    Edge *edge;
  
	while(n_pq > 0){
	    edge = pqremove();
	    
	    /* collapse endpoints into combined node */
	    tree[n_nodes].parent = NONE;
	    tree[n_nodes].left = edge->v1;
	    tree[n_nodes].right = edge->v2;
	    tree[edge->v1].parent = n_nodes;
	    tree[edge->v2].parent = n_nodes;
	    if(n_pq == 0)
		break;
	    
	    /* create edges for combined node */
	    enum_edges(edge->v1, make_edge_e1, make_edge_e2);
	    enum_edges(edge->v2, find_edge_e1, find_edge_e2);
	    enum_edges(n_nodes, pqinsert_e1, NULL);
	    
	    if((n_nodes++ % 50) == 0)
		putc('.', stderr);
	}
	putc(';', stderr);
	putc('\n', stderr);
}

static
void
pqinsert_proc(
arctype *arc,
arctype *backarc)
{
	pqinsert(make_edge(arc->arc_parentp - nl, 
			   arc->arc_childp - nl, 
			   (backarc) ? (arc->arc_count + backarc->arc_count) :
				       (arc->arc_count)));
}

static
void
scatter(
void)
{
    int max_nodes;
    TreeNode *tnode;

	if(xflag == FALSE){
	    max_nodes = 2 * (npe - nl);
	    tree = (TreeNode *)malloc(max_nodes * sizeof(TreeNode));
	    n_nodes = npe - nl;
	    for(tnode = tree; tnode < &tree[max_nodes]; tnode++){
		tnode->next1 = tnode->next2 = NULL;
		tnode->parent = tnode->left = tnode->right = NONE;
	    }
	    most_edges = 1;
	    enum_arcs(most_edges_proc);
	    pq = (Edge **)malloc(most_edges * sizeof(Edge *));
	    n_pq = 0;
	    pq[0] = &pqzero;
	    
	    enum_arcs(pqinsert_proc); /* create undirected graph */
	    main_loop();
	    print_tree();
	}

	/* call frequency order file */
	qsort(nl, npe - nl, sizeof(nltype),  
	      (int(*)(const void *, const void *))compare_nl);
	print_nl(callf);

	/* call order order file */
	qsort(nl, npe - nl, sizeof(nltype),  
	      (int(*)(const void *, const void *))compare_nl_order);
	print_nl(callo);

	/* time order file */
	qsort(nl, npe - nl, sizeof(nltype),  
	      (int (*)(const void *, const void *))timecmp);
	print_nl(callt);
}

void
printscatter(
void)
{
    int what_fd;
    struct stat buf;

	if(xflag == FALSE)
	    if((gmon = fopen("gmon.order", "w")) == NULL)
		system_fatal("can't create file: gmon.order");
	if((callf = fopen("callf.order", "w")) == NULL)
	    system_fatal("can't create file: callf.order");
	if((callo = fopen("callo.order", "w")) == NULL)
	    system_fatal("can't create file: callo.order");
	if((callt = fopen("time.order", "w")) == NULL)
	    system_fatal("can't create file: time.order");
	/*
	if((treefile = fopen("gmon.tree", "w")) == NULL)
	    system_fatal("can't create file: gmon.tree");
	*/
	if((what_fd = open("whatsloaded", O_RDONLY)) >= 0){
	    fstat(what_fd, &buf);
	    whatsloaded = mmap(0, buf.st_size, PROT_READ|PROT_WRITE,
			       MAP_FILE|MAP_PRIVATE, what_fd, 0);
	    do_what();
	}
	get_text_min_max(&text_min, &text_max);

	qsort(files, n_files, sizeof(struct file), 
	      (int(*)(const void *, const void *))compare_file);
	scatter();
	if(xflag == FALSE)
	    fclose(gmon);
	fclose(callf);
	fclose(callo);
	fclose(callt);
	if(what_fd >= 0)
	    close(what_fd);
}

#ifdef notdef
static
void
ugh(void)
{
}

static
voids
print_pq(
void)
{
    int i; Edge *edge;

	for(i = 1; i <= n_pq; i++){
	    edge = pq[i];
	    if(edge->pqp != &pq[i])
		ugh();
	    fprintf(stderr, "%4d %4d %4d\n", i, edge->v1, edge->v2);
	}
}
#endif

static
void
upheap(
int k)
{
    Edge *v;

	v = pq[k];
	while(pq[k/2]->w <= v->w){ 
	    pq[k] = pq[k/2]; 
	    pq[k]->pqp = &pq[k];
	    k = k/2;
	}
	pq[k] = v; 
	pq[k]->pqp = &pq[k];
}

static
void
downheap(
int k)
{
    Edge *v;
    int j;

	v = pq[k];
	while(k <= n_pq/2){
	    j = 2 * k;
	    if(j < n_pq)
		if(pq[j]->w < pq[j+1]->w)
		    j++;
	    if (v->w >= pq[j]->w)
		break;
	    pq[k] = pq[j];
	    pq[k]->pqp = &pq[k];
	    k = j;
	}
	pq[k] = v;
	pq[k]->pqp = &pq[k];
}

static
void
pqinsert(
Edge *v)
{
#ifdef DEBUG
	printf("pqinsert %d	%x  %d  %d\n",
	       n_pq, (unsigned int)v, v->v1, v->v2);
#endif
	pq[++n_pq] = v;
	upheap(n_pq);
}

static
Edge *
pqremove(
void)
{
    Edge *v = pq[1];
#ifdef DEBUG
	printf("pqremove %d	%x  %d  %d\n",
	       n_pq, (unsigned int)v, v->v1, v->v2);
#endif
	pq[1]->pqp = NULL;
	pq[1] = pq[n_pq--];
	downheap(1);
	return(v);
}

static
void
pqdelete(
Edge *v)
{
    Edge **peeq = v->pqp;
#ifdef DEBUG
	printf("pqdelete %d	%x  %d  %d\n",
	       n_pq, (unsigned int)v, v->v1, v->v2);
#endif
	v->pqp = NULL;
	if(n_pq == 0)
	    return;
	*peeq = pq[n_pq--];
	upheap(peeq - pq);
	downheap(peeq - pq);
}
                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/gprof/vax.h                                 0100644 0001750 0001750 00000007171 12612724206 022532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$OpenBSD: vax.h,v 1.2 1996/06/26 05:34:03 deraadt Exp $	*/
/*	$NetBSD: vax.h,v 1.4 1995/04/19 07:16:31 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vax.h	8.1 (Berkeley) 6/6/93
 */
    /*
     *	opcode of the `calls' instruction
     */
#define	CALLS	0xfb

    /*
     *	offset (in bytes) of the code from the entry address of a routine.
     *	(see asgnsamples for use and explanation.)
     */
#define OFFSET_OF_CODE	2
#define	UNITS_TO_CODE	(OFFSET_OF_CODE / sizeof(UNIT))

    /*
     *	register for pc relative addressing
     */
#define	PC	0xf

enum opermodes {
    literal, indexed, reg, regdef, autodec, autoinc, autoincdef, 
    bytedisp, bytedispdef, worddisp, worddispdef, longdisp, longdispdef,
    immediate, absolute, byterel, bytereldef, wordrel, wordreldef,
    longrel, longreldef
};
typedef enum opermodes	operandenum;

struct modebyte {
    unsigned int	regfield:4;
    unsigned int	modefield:4;
};

                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/                                    0040755 0001750 0001750 00000000000 12612724206 022066  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/Makefile                            0100644 0001750 0001750 00000016204 12612724206 023526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Note that the macros are not used for the install target any more with the
# change to the install(1) program.  Edit the install commands.

ifneq "" "$(wildcard /bin/mkdirs)"
  MKDIRS = /bin/mkdirs
else
  MKDIRS = /bin/mkdir -p
endif

FILES = mach-o/ldsyms.h mach-o/reloc.h \
	mach-o/nlist.h mach-o/stab.h mach-o/loader.h mach-o/fat.h \
	mach-o/dyld_debug.h mach-o/arch.h mach-o/gmon.h mach-o/ranlib.h \
	mach-o/swap.h mach-o/getsect.h mach-o/i386/swap.h \
	mach-o/ppc/swap.h mach-o/ppc/reloc.h mach-o/x86_64/reloc.h \
	mach-o/dyld.h mach-o/dyld_gdb.h mach-o/arm/reloc.h mach-o/arm64/reloc.h

LOCFILES = mach-o/rld_state.h mach-o/rld.h mach-o/sarld.h mach-o/kld.h \
	   mach-o/redo_prebinding.h \
	   mach-o/i860/swap.h mach-o/i860/reloc.h \
	   mach-o/hppa/swap.h mach-o/hppa/reloc.h \
	   mach-o/m88k/swap.h mach-o/m88k/reloc.h \
	   mach-o/m68k/swap.h \
	   mach-o/sparc/swap.h mach-o/sparc/reloc.h \
	   cbt/libsyminfo.h mach-o/dyld_priv.h

# Note that OTHER_SRCS do NOT get installed
GAS_OTHER_SRCS = stuff/bytesex.h stuff/bool.h stuff/rnd.h stuff/errors.h \
		 stuff/openstep_mach.h opcode/arm.h
OTHER_SRCS = notes gnu/symseg.h \
	     stuff/allocate.h stuff/arch.h stuff/execute.h \
	     stuff/ofile.h stuff/lto.h stuff/llvm.h \
	     stuff/hash_string.h stuff/breakout.h stuff/best_arch.h \
	     stuff/hppa.h stuff/reloc.h stuff/vm_flush_cache.h \
	     stuff/print.h stuff/version_number.h stuff/crc32.h sys/gmon.h \
	     stuff/seg_addr_table.h stuff/dylib_table.h \
	     stuff/SymLoc.h stuff/dylib_roots.h stuff/guess_short_name.h \
	     stuff/macosx_deployment_target.h stuff/symbol_list.h \
	     stuff/symbol.h stuff/unix_standard_mode.h \
	     coff/base_relocs.h coff/bytesex.h coff/ms_dos_stub.h \
	     coff/filehdr.h coff/aouthdr.h coff/scnhdr.h coff/syment.h \
	     coff/debug_directory.h elf/dwarf2.h llvm-c/Disassembler.h \
	     xar/xar.h $(GAS_OTHER_SRCS)

ENCUMBERED_SRCS = gnu/a.out.h gnu/exec.h

# Note that MISSING_SRCS are those may not be on all build machines
GAS_MISSING_SRCS = mach/m68k/thread_status.h \
		   mach/i860/thread_status.h \
		   mach/m88k/thread_status.h \
		   architecture/m88k/fp_regs.h \
		   architecture/m88k/reg_help.h \
		   architecture/nrw/reg_help.h \
		   architecture/nrw/macro_help.h \
		   mach/hppa/thread_status.h \
		   mach/sparc/thread_status.h \
		   architecture/sparc/reg.h \
		   mach/arm/thread_status.h \
		   mach/arm/thread_state.h \
		   mach/arm/_structs.h \
		   mach/ppc/thread_status.h \
		   mach/ppc/_structs.h

MISSING_SRCS = mach/machine.h \
	       architecture/i386/fpu.h architecture/i386/frame.h \
	       i386/eflags.h mach/i386/_structs.h mach/i386/fp_reg.h \
	       mach/i386/thread_state.h mach/i386/thread_status.h \
	       standalone/libsa.h \
	       $(GAS_MISSING_SRCS)
		
nextstep_INCDIR = /NextDeveloper/Headers
nextstep_LOCINCDIR = /LocalDeveloper/Headers

teflon_INCDIR = /System/Library/Frameworks/System.framework/Versions/B/Headers
teflon_LOCINCDIR = /System/Library/Frameworks/System.framework/Versions/B/PrivateHeaders

ifeq "macos" "$(RC_OS)"
 macos_INCDIR := $(shell if [ "$(RC_RELEASE)" = "Beaker" ] ||    \
			    [ "$(RC_RELEASE)" = "Bunsen" ] ||    \
			    [ "$(RC_RELEASE)" = "Gonzo"  ] ||    \
			    [ "$(RC_RELEASE)" = "Kodiak" ]; then \
	 echo /System/Library/Frameworks/System.framework/Versions/B/Headers; \
	 else echo /usr/include; \
	 fi; )
 macos_LOCINCDIR := $(shell if [ "$(RC_RELEASE)" = "Beaker" ] ||    \
			       [ "$(RC_RELEASE)" = "Bunsen" ] ||    \
			       [ "$(RC_RELEASE)" = "Gonzo"  ] ||    \
			       [ "$(RC_RELEASE)" = "Kodiak" ]; then \
 echo /System/Library/Frameworks/System.framework/Versions/B/PrivateHeaders; \
 else echo /usr/local/include; \
 fi; )
else
  macos_INCDIR = /System/Library/Frameworks/System.framework/Versions/B/Headers
  macos_LOCINCDIR = /System/Library/Frameworks/System.framework/Versions/B/PrivateHeaders
endif

SRC_FILES = Makefile $(FILES) $(LOCFILES) $(OTHER_SRCS) $(MISSING_SRCS)
GAS_SRC_FILES = Makefile $(GAS_OTHER_SRCS) $(GAS_MISSING_SRCS)
ENCUMBERED_SRC_FILES = $(SRC_FILES) $(ENCUMBERED_SRCS)

installsrc:
	$(MKDIRS) $(SRCROOT)
	chmod 755 $(SRCROOT)
	gnutar cf - $(ENCUMBERED_SRC_FILES) | (cd $(SRCROOT); gnutar xf -)

installGASsrc:
	$(MKDIRS) $(SRCROOT)
	chmod 755 $(SRCROOT)
	gnutar cf - $(GAS_SRC_FILES) | (cd $(SRCROOT); gnutar xf -)

install: dirs $(RC_OS)_install

teflon_install macos_install: common_install

nextstep_install: common_install
	cd mach-o; \
	    install -c -m 444 ${IFLAGS} gmon.h \
	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o

common_install:
	cd mach-o; \
	    install -c -m 444 ${IFLAGS} arch.h ldsyms.h reloc.h \
	    stab.h loader.h fat.h swap.h getsect.h nlist.h \
	    ranlib.h ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o
	if [ $(OLD_DYLD_STUFF) ];				\
	then							\
	    cd mach-o; install -c -m 444 ${IFLAGS} dyld.h dyld_debug.h	\
		${DSTROOT}${$(RC_OS)_INCDIR}/mach-o ;		\
	fi
	cd mach-o/i386; \
	    install -c -m 444 ${IFLAGS} swap.h \
	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/i386
	cd mach-o/ppc; \
	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/ppc
	cd mach-o/x86_64; \
	    install -c -m 444 ${IFLAGS} reloc.h \
	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/x86_64
	cd mach-o/arm; \
	    install -c -m 444 ${IFLAGS} reloc.h \
	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm
	cd mach-o/arm64; \
	    install -c -m 444 ${IFLAGS} reloc.h \
	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm64
	cd mach-o/m68k; \
	    install -c -m 444 ${IFLAGS} swap.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m68k
	cd mach-o/sparc; \
	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/sparc
	cd mach-o/hppa; \
	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/hppa
	cd mach-o/i860; \
	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/i860
	cd mach-o/m88k; \
	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m88k
	cd mach-o; \
	    install -c -m 444 ${IFLAGS} rld.h rld_state.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o
	if [ $(OLD_DYLD_STUFF) ];					  \
	then								  \
	    cd mach-o; install -c -m 444 ${IFLAGS} dyld_gdb.h dyld_priv.h \
		${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o ;		  \
	fi
	cd mach-o; \
	    install -c -m 444 ${IFLAGS} sarld.h kld.h redo_prebinding.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o
	cd stuff; \
	    install -c -m 444 ${IFLAGS} bool.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/dyld
	cd cbt; \
	    install -c -m 444 ${IFLAGS} libsyminfo.h \
	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/cbt

dirs:
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/i386
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/ppc
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/x86_64
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm64
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m68k
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/sparc
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/hppa
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/i860
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m88k
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/dyld
	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/cbt

depend:

clean shlib_clean:

all:
                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/                       0040755 0001750 0001750 00000000000 12612724206 024550  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/i386/                  0040755 0001750 0001750 00000000000 12612724206 025241  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/i386/fpu.h             0100644 0001750 0001750 00000006035 12612724206 026205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Floating Point unit.
 *
 * HISTORY
 *
 * 5 October 1992 David E. Bohman at NeXT
 *	Added names to previously unamed fields in the mantissa.
 *
 * 5 April 1992 David E. Bohman at NeXT
 *	Created.
 */

/*
 * Data register.
 */

typedef struct fp_data_reg {
    unsigned short		mant;
    unsigned short		mant1	:16,
				mant2	:16,
				mant3	:16;
    unsigned short		exp	:15,
			    	sign	:1;
} fp_data_reg_t;

/*
 * Data register stack.
 */

typedef struct fp_stack {
    fp_data_reg_t		ST[8];
} fp_stack_t;

/*
 * Register stack tag word.
 */

typedef struct fp_tag {
    unsigned short		tag0	:2,
    				tag1	:2,
				tag2	:2,
				tag3	:2,
    				tag4	:2,
				tag5	:2,
				tag6	:2,
				tag7	:2;
#define FP_TAG_VALID		0
#define FP_TAG_ZERO		1
#define FP_TAG_SPEC		2
#define FP_TAG_EMPTY		3
} fp_tag_t;

/*
 * Status word.
 */

typedef struct fp_status {
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
				stkflt	:1,
				errsumm	:1,
				c0	:1,
				c1	:1,
				c2	:1,
				tos	:3,
				c3	:1,
				busy	:1;
} fp_status_t;

/*
 * Control word.
 */

typedef struct fp_control {
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
					:2,
				pc	:2,
#define FP_PREC_24B		0
#define	FP_PREC_53B		2
#define FP_PREC_64B		3
				rc	:2,
#define FP_RND_NEAR		0
#define FP_RND_DOWN		1
#define FP_RND_UP		2
#define FP_CHOP			3
				/*inf*/	:1,
					:3;
} fp_control_t;

#import <architecture/i386/sel.h>

/*
 * Floating point 'environment'
 * used by FSTENV/FLDENV instructions.
 */

typedef struct fp_env {
    fp_control_t		control;
    unsigned short			:16;
    fp_status_t			status;
    unsigned short			:16;
    fp_tag_t			tag;
    unsigned short			:16;
    unsigned int		ip;
    sel_t			cs;
    unsigned short		opcode;
    unsigned int		dp;
    sel_t			ds;
    unsigned short			:16;
} fp_env_t;

/*
 * Floating point state
 * used by FSAVE/FRSTOR instructions.
 */
 
typedef struct fp_state {
    fp_env_t			environ;
    fp_stack_t			stack;
} fp_state_t;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/i386/frame.h           0100644 0001750 0001750 00000006141 12612724206 026503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Processor exception frame.
 *
 * HISTORY
 *
 * 31 August 1992 David E. Bohman at NeXT
 *	Added v86 mode stuff.
 *
 * 8 June 1992 David E. Bohman at NeXT
 *	Changed name of write field in err_code_t
 *	which collided with write() in shlib.
 *
 * 30 March 1992 David E. Bohman at NeXT
 *	Created.
 */

/*
 * Format of the error code
 * generated by the hardware
 * for certain exceptions.
 */
 
typedef union err_code {
    struct err_code_normal {
	unsigned int	ext	:1,
			tbl	:2,
#define ERR_GDT		0
#define ERR_IDT		1
#define ERR_LDT		2
			index	:13,
				:16;
    } normal;
    struct err_code_pgfault {
	unsigned int	prot	:1,
			wrtflt	:1,
			user	:1,
				:29;
    } pgfault;
} err_code_t;

#import <architecture/i386/sel.h>

/*
 * The actual hardware exception frame
 * is variable in size.  An error code is
 * only pushed for certain exceptions.
 * Previous stack information is only
 * pushed for exceptions that cause a
 * change in privilege level.  The dpl
 * field of the saved CS selector can be
 * used to determine whether this is the
 * case.  If the interrupted task was
 * executing in v86 mode, then the data
 * segment registers are also present in
 * the exception frame (in addition to
 * previous stack information).  This
 * case can be determined by examining
 * eflags.
 */

typedef struct except_frame {
    err_code_t		err;
    unsigned int	eip;
    sel_t		cs;
    unsigned int		:0;
    unsigned int	eflags;
    unsigned int	esp;
    sel_t		ss;
    unsigned int		:0;
    unsigned short	v_es;
    unsigned int		:0;
    unsigned short	v_ds;
    unsigned int		:0;
    unsigned short	v_fs;
    unsigned int		:0;
    unsigned short	v_gs;
    unsigned int		:0;
} except_frame_t;

/*
 * Values in eflags.
 */

#define EFL_CF		0x00001
#define EFL_PF		0x00004
#define EFL_AF		0x00010
#define EFL_ZF		0x00040
#define EFL_SF		0x00080
#define EFL_TF		0x00100
#define EFL_IF		0x00200
#define EFL_DF		0x00400
#define EFL_OF		0x00800
#define EFL_IOPL	0x03000
#define EFL_NT		0x04000
#define EFL_RF		0x10000
#define EFL_VM		0x20000
#define EFL_AC		0x40000

#define EFL_CLR		0xfff88028
#define EFL_SET		0x00000002
                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/m88k/                  0040755 0001750 0001750 00000000000 12612724206 025337  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/m88k/fp_regs.h         0100644 0001750 0001750 00000013644 12612724206 027142  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/m88k/fp_regs.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *
 *	This include file defines Motorola 88K architecturally defined
 *	floating point control and status registers.
 *
 * HISTORY
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef	_ARCH_M88K_FP_REGS_H_
#define	_ARCH_M88K_FP_REGS_H_

#import <architecture/m88k/reg_help.h>

/*
 * m88k_xrf_t -- data types that MAY be in extended register file
 * Actual data types supported is implementation dependent
 */
typedef union {
	float		f;		// 32 bit IEEE single
	double		d;		// 64 bit IEEE double
	/*
	 * NOTE: currently compiler implements long double type
	 * simply as double.  In the future, it may implement
	 * this as 80 bit IEEE double extended or 128 bit IEEE quad
	 * as appropriate for the 88K implementation.
	 */
	long double	e;		// 80 or 128 bit IEEE format
	/* Insure compiler aligns struct appropriately */
#ifdef __GNUC__
	unsigned	x[4] __attribute__(( aligned(16) ));
#else
	unsigned	x[4];
#endif
} m88k_xrf_t;

/*
 * FPSR -- Floating Point Status Register
 */
typedef struct {
	unsigned	:BITS_WIDTH(31,17);
	unsigned	xmod:BIT_WIDTH(16);	// extended registers modified
	unsigned	:BITS_WIDTH(15,5);
	unsigned	afinv:BIT_WIDTH(4);	// accumulated invalid flag
	unsigned	afdvz:BIT_WIDTH(3);	// accumulated div by zero flag
	unsigned	afunf:BIT_WIDTH(2);	// accumulated underflow flag
	unsigned	afovf:BIT_WIDTH(1);	// accumulated overflow flag
	unsigned	afinx:BIT_WIDTH(0);	// accumulated inexact flag
} m88k_fpsr_t;

/*
 * FPCR -- Floating Point Control Register
 * 88K architecturally specified form.
 * Does not expose implementation-dependent functions
 */
typedef enum {
	M88K_RM_NEAREST = 0,		// round toward nearest
	M88K_RM_ZERO	= 1,		// round toward zero
	M88K_RM_NEGINF = 2,		// round toward negative infinity
	M88K_RM_POSINF =3		// round toward positive infinity
} m88k_fpcr_rm_t;

typedef struct {
	unsigned	:BITS_WIDTH(31,16);
	m88k_fpcr_rm_t	rm:BITS_WIDTH(15,14);	// rounding mode
	unsigned	:BITS_WIDTH(13,5);
	unsigned	efinv:BIT_WIDTH(4);	// invalid exception enable
	unsigned	efdvz:BIT_WIDTH(3);	// div by zero exception enable
	unsigned	efunf:BIT_WIDTH(2);	// underflow exception enable
	unsigned	efovf:BIT_WIDTH(1);	// overflow exception enable
	unsigned	efinx:BIT_WIDTH(0);	// inexact exception enable
} m88k_fpcr_t;

/*
 * FPCR -- Floating Point Control Register
 * 88110 implementation -- includes "TCFP" features.
 */
typedef struct {
	unsigned	:BITS_WIDTH(31,22);
	unsigned	tcfp:BIT_WIDTH(21);	// def results for INF/NaN
	unsigned	:BITS_WIDTH(20,19);
	unsigned	tcfpunf:BIT_WIDTH(18);	// underflow -> zero
	unsigned	tcfpovf:BIT_WIDTH(17);	// overflow -> inf
	unsigned	:BIT_WIDTH(16);
	m88k_fpcr_rm_t	rm:BITS_WIDTH(15,14);	// rounding mode
	unsigned	:BITS_WIDTH(13,5);
	unsigned	efinv:BIT_WIDTH(4);	// invalid exception enable
	unsigned	efdvz:BIT_WIDTH(3);	// div by zero exception enable
	unsigned	efunf:BIT_WIDTH(2);	// underflow exception enable
	unsigned	efovf:BIT_WIDTH(1);	// overflow exception enable
	unsigned	efinx:BIT_WIDTH(0);	// inexact exception enable
} m88110_fpcr_t;

#ifdef m88k
#ifndef	__STRICT_ANSI__
/*
 * read and write fpsr and fpcr registers
 *
 * FIXME: When the compiler is fixed, convert to style of inlines shown
 * in m88110_sfu0.h which do not use either CONTENTS() macro or
 * *(foo_t *)& casts (and therefore, don't force the compiler to generate
 * a memory reference.
 */
static __inline__ m88k_fpsr_t m88k_get_fpsr()
{
	unsigned	cr_tmp;
	
	__asm__ volatile ("fldcr	 %0,fcr62	; get_fpsr()" : "=r" (cr_tmp));
	return *(m88k_fpsr_t *)&cr_tmp;
}

static __inline__ void m88k_set_fpsr(m88k_fpsr_t fpsr_val)
{
	/*
	 * Must force xmod to 1, since OS uses this to determine
	 * if XRF must be context switched.  Not setting to 1
	 * will NOT corrupt other threads registers, but will
	 * result in loss of this threads register values.
	 */
	fpsr_val.xmod = 1;
	__asm__ volatile ("fstcr	 %0,fcr62	; set_fpsr()"
	  : : "r" (CONTENTS(fpsr_val)));
}

static __inline__ m88k_fpcr_t m88k_get_fpcr()
{
	unsigned	cr_tmp;
	
	__asm__ volatile ("fldcr	 %0,fcr63	; get_fpcr()" : "=r" (cr_tmp));
	return *(m88k_fpcr_t *)&cr_tmp;
}

static __inline__ void m88k_set_fpcr(m88k_fpcr_t fpcr_val)
{
	__asm__ volatile ("fstcr	 %0,fcr63	; set_fpcr()"
	  : : "r" (CONTENTS(fpcr_val)));
}
#endif /* __STRICT_ANSI__ */
#endif /* m88k */

#endif	/* _ARCH_M88K_FP_REGS_H_ */
                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/m88k/reg_help.h        0100644 0001750 0001750 00000005723 12612724206 027301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/m88k/reg_help.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *
 *	This header file defines cpp macros useful for defining
 *	machine register and doing machine-level operations.
 *
 * HISTORY
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef _ARCH_M88K_REG_HELP_H_
#define _ARCH_M88K_REG_HELP_H_

#import <architecture/nrw/reg_help.h>

/* Stack pointer must always be a multiple of 16 */
#define	STACK_INCR	16
#define	ROUND_FRAME(x)	((((unsigned)(x)) + STACK_INCR - 1) & ~(STACK_INCR-1))

/*
 * REG_PAIR_DEF -- define a register pair
 * Register pairs are appropriately aligned to allow access via
 * ld.d and st.d.
 *
 * Usage:
 *	struct foo {
 *		REG_PAIR_DEF(
 *			bar_t *,	barp,
 *			afu_t,		afu
 *		);
 *	};
 *
 * Access to individual entries of the pair is via the REG_PAIR
 * macro (below).
 */
#define	REG_PAIR_DEF(type0, name0, type1, name1)		\
	struct {						\
		type0	name0 __attribute__(( aligned(8) ));	\
		type1	name1;					\
	} name0##_##name1

/*
 * REG_PAIR -- Macro to define names for accessing individual registers
 * of register pairs.
 *
 * Usage:
 *	arg0 is first element of pair
 *	arg1 is second element of pair
 *	arg2 is desired element of pair
 * eg:
 *	#define	foo_barp	REG_PAIR(barp, afu, afu)
 */
#define	REG_PAIR(name0, name1, the_name)			\
	name0##_##name1.the_name

#endif  /* _ARCH_M88K_REG_HELP_H_ */
                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/nrw/                   0040755 0001750 0001750 00000000000 12612724206 025356  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/nrw/macro_help.h       0100644 0001750 0001750 00000004432 12612724206 027640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */
/*
 * HISTORY
 * 	09-23-91 mike	Created from Mach version
 * 
 */
/*
 *	File:	architecture/nrw/macro_help.h
 *
 *	Provide help in making lint-free macro routines
 *
 */

#ifndef	_NRW_MACRO_HELP_H_
#define	_NRW_MACRO_HELP_H_

#ifndef	MACRO_BEGIN
# define		MACRO_BEGIN	do {
#endif	/* MACRO_BEGIN */

#ifndef	MACRO_END
# define		MACRO_END	} while (0)
#endif	/* MACRO_END */

#ifndef	MACRO_RETURN
# define		MACRO_RETURN	if (1) return
#endif	/* MACRO_RETURN */

#endif	/* _NRW_MACRO_HELP_H_ */

                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/nrw/reg_help.h         0100644 0001750 0001750 00000005344 12612724206 027317  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/nrw/reg_help.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *
 *	This header file defines cpp macros useful for defining
 *	machine register and doing machine-level operations.
 *
 * HISTORY
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef	_NRW_REG_HELP_H_
#define	_NRW_REG_HELP_H_

/* Bitfield definition aid */
#define	BITS_WIDTH(msb, lsb)	((msb)-(lsb)+1)
#define	BIT_WIDTH(pos)		(1)	/* mostly to record the position */

/* Mask creation */
#define	MKMASK(width, offset)	(((unsigned)-1)>>(32-(width))<<(offset))
#define	BITSMASK(msb, lsb)	MKMASK(BITS_WIDTH(msb, lsb), lsb & 0x1f)
#define	BITMASK(pos)		MKMASK(BIT_WIDTH(pos), pos & 0x1f)

/* Register addresses */
#if	__ASSEMBLER__
# define	REG_ADDR(type, addr)	(addr)
#else	/* __ASSEMBLER__ */
# define	REG_ADDR(type, addr)	(*(volatile type *)(addr))
#endif	/* __ASSEMBLER__ */

/* Cast a register to be an unsigned */
#define	CONTENTS(foo)	(*(unsigned *) &(foo))

/* STRINGIFY -- perform all possible substitutions, then stringify */
#define	__STR(x)	#x		/* just a helper macro */
#define	STRINGIFY(x)	__STR(x)


#endif	/* _NRW_REG_HELP_H_ */
                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/sparc/                 0040755 0001750 0001750 00000000000 12612724206 025660  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/architecture/sparc/reg.h            0100644 0001750 0001750 00000021660 12612724206 026610  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*	@(#)reg.h 1.16 92/04/28 SMI	*/

/*
 * Copyright (c) 1985 by Sun Microsystems, Inc.
 */

#ifndef _sparc_reg_h
#define	_sparc_reg_h

/*
 * Location of the users' stored
 * registers relative to R0.
 * Usage is u.u_ar0[XX].
 */
#define	PSR	(0)
#define	PC	(1)
#define	nPC	(2)
#define	SPARC_Y	(3)
#define	G1	(4)
#define	G2	(5)
#define	G3	(6)
#define	G4	(7)
#define	G5	(8)
#define	G6	(9)
#define	G7	(10)
#define	O0	(11)
#define	O1	(12)
#define	O2	(13)
#define	O3	(14)
#define	O4	(15)
#define	O5	(16)
#define	O6	(17)
#define	O7	(18)

/* the following defines are for portability */
#define	PS	PSR
#define	SP	O6
#define	R0	O0
#define	R1	O1

/*
 * And now for something completely the same...
 */
#ifndef __ASSEMBLER__
struct regs {
	int	r_psr;		/* processor status register */
	int	r_pc;		/* program counter */
	int	r_npc;		/* next program counter */
	int	r_y;		/* the y register */
	int	r_g1;		/* user global regs */
	int	r_g2;
	int	r_g3;
	int	r_g4;
	int	r_g5;
	int	r_g6;
	int	r_g7;
	int	r_o0;
	int	r_o1;
	int	r_o2;
	int	r_o3;
	int	r_o4;
	int	r_o5;
	int	r_o6;
	int	r_o7;
};

#define	r_ps	r_psr		/* for portablility */
#define	r_r0	r_o0
#define	r_sp	r_o6

#endif /* !__ASSEMBLER__ */

/*
 * Floating point definitions.
 */

#define	FPU			/* we have an external float unit */

#ifndef __ASSEMBLER__

#define	FQ_DEPTH	16		/* maximum instuctions in FQ */

/*
 * struct fpu_status is the floating point processor state
 * struct fpu is the sum total of all possible floating point state
 * which includes the state of external floating point hardware,
 * fpa registers, etc..., if it exists.
 */
struct fpq {
	unsigned int *addr;		/* address */
	unsigned int instr;		/* instruction */
};
struct	fq {
	union {				/* FPU inst/addr queue */
		double	whole;
		struct  fpq fpq;
	} FQu;
};


#define	FPU_REGS_TYPE unsigned
#define	FPU_FSR_TYPE unsigned

struct	fpu {
	union {				 /* FPU floating point regs */
		FPU_REGS_TYPE Fpu_regs[32];	/* 32 singles */
		double	Fpu_dregs[16];		/* 16 doubles */
	} fpu_fr;
	FPU_FSR_TYPE Fpu_fsr;		/* FPU status register */
	unsigned Fpu_flags;		/* control flags */
	unsigned Fpu_extra;		/* extra word */
	unsigned Fpu_qcnt;		/* count of valid entries in fps_q */
	struct fq Fpu_q[FQ_DEPTH];	/* FPU instruction address queue */
};

#define	fpu_regs	fpu_fr.Fpu_regs
#define	fpu_dregs	fpu_fr.Fpu_dregs
#define	fpu_fsr		Fpu_fsr
#define	fpu_flags	Fpu_flags
#define	fpu_extra	Fpu_extra
#define	fpu_q		Fpu_q
#define	fpu_qcnt	Fpu_qcnt

#endif /* !__ASSEMBLER__ */


/*
 * Definition of bits in the Sun-4 FSR (Floating-point Status Register)
 *   ________________________________________________________________________
 *  |  RD |  RP | TEM | NS | res | vers | FTT | QNE | PR | FCC | AEXC | CEXC |
 *  |-----|---- |-----|----|-----|------|-----|-----|----|-----|------|------|
 *   31 30 29 28 27 23  22  21 20 19  17 16 14   13   12  11 10 9    5 4    0
 */
#define	FSR_CEXC	0x0000001f	/* Current Exception */
#define	FSR_AEXC	0x000003e0	/* ieee accrued exceptions */
#define	FSR_FCC		0x00000c00	/* Floating-point Condition Codes */
#define	FSR_PR		0x00001000	/* Partial Remainder */
#define	FSR_QNE		0x00002000	/* Queue not empty */
#define	FSR_FTT		0x0001c000	/* Floating-point Trap Type */
#define FSR_VERS	0x000e0000	/* version field */
#define FSR_RESV	0x00300000	/* reserved */
#define FSR_NS		0x00400000	/* non-standard fp */
#define FSR_TEM		0x0f800000	/* ieee Trap Enable Mask */
#define	FSR_RP		0x30000000	/* Rounding Precision */
#define	FSR_RD		0xc0000000	/* Rounding Direction */

#define FSR_VERS_SHIFT	(17)		/* amount to shift version field */

/*
 * Definition of CEXC (Current EXCeption) bit field of fsr
 */
#define	FSR_CEXC_NX	0x00000001	/* inexact */
#define	FSR_CEXC_DZ	0x00000002	/* divide-by-zero */
#define	FSR_CEXC_UF	0x00000004	/* underflow */.
#define	FSR_CEXC_OF	0x00000008	/* overflow */
#define	FSR_CEXC_NV	0x00000010	/* invalid */

/*
 * Definition of AEXC (Accrued EXCeption) bit field of fsr
 */
#define	FSR_AEXC_NX	(0x1 << 5)	/* inexact */
#define	FSR_AEXC_DZ	(0x2 << 5)	/* divide-by-zero */
#define	FSR_AEXC_UF	(0x4 << 5)	/* underflow */.
#define	FSR_AEXC_OF	(0x8 << 5)	/* overflow */
#define	FSR_AEXC_NV	(0x10 << 5)	/* invalid */

/*
 * Defintion of FTT (Floating-point Trap Type) field within the FSR
 */
#define	FTT_NONE	0		/* no excepitons */
#define	FTT_IEEE	1		/* IEEE exception */
#define	FTT_UNFIN	2		/* unfinished fpop */
#define	FTT_UNIMP	3		/* unimplemented fpop */
#define	FTT_SEQ		4		/* sequence error */
#define	FTT_ALIGN	5	/* alignment, by software convention */
#define	FTT_DFAULT	6	/* data fault, by software convention */
#define	FSR_FTT_SHIFT	14	/* shift needed to justfy ftt field */
#define	FSR_FTT_IEEE	(FTT_IEEE   << FSR_FTT_SHIFT)
#define	FSR_FTT_UNFIN	(FTT_UNFIN  << FSR_FTT_SHIFT)
#define	FSR_FTT_UNIMP	(FTT_UNIMP  << FSR_FTT_SHIFT)
#define	FSR_FTT_SEQ	(FTT_SEQ    << FSR_FTT_SHIFT)
#define	FSR_FTT_ALIGN	(FTT_ALIGN  << FSR_FTT_SHIFT)
#define	FSR_FTT_DFAULT	(FTT_DFAULT << FSR_FTT_SHIFT)

/*
 * Values of VERS (version) field within the FSR
 * NOTE: these values are overloaded; the cpu type must be used to
 * further discriminate amongst these.  For that reason, no #defines are
 * provided.
 *
 * Version	cpu = 21-22, 51-54		cpu = 23-24, 55-57
 *	0	Weitek 1164/5 (FAB 1-4)		TI 8847
 *	1	Weitek 1164/5 (FAB 5-6)		LSI L64814
 *	2	TI 8847				TI TMS390C602A
 *	3	Weitek 3170			Weitek 3171
 *	4	Meiko				?
 *	5	?				?
 *	6	?				?
 *	7	No FP Hardware			No FP Hardware
 */


/*
 * Definition of TEM (Trap Enable Mask) bit field of fsr
 */
#define	FSR_TEM_NX	(0x1 << 23)	/* inexact */
#define	FSR_TEM_DZ	(0x2 << 23)	/* divide-by-zero */
#define	FSR_TEM_UF	(0x4 << 23)	/* underflow */.
#define	FSR_TEM_OF	(0x8 << 23)	/* overflow */
#define	FSR_TEM_NV	(0x10 << 23)	/* invalid */

/*
 * Definition of RP (Rounding Precision) field of fsr
 */
#define	RP_DBLEXT	0		/* double-extended */
#define	RP_SINGLE	1		/* single */
#define	RP_DOUBLE	2		/* double */
#define	RP_RESERVED	3		/* unused and reserved */

/*
 * Defintion of RD (Rounding Direction) field of fsr
 */
#define	RD_NEAR		0		/* nearest or even if tie */
#define	RD_ZER0		1		/* to zero */
#define	RD_POSINF	2		/* positive infinity */
#define	RD_NEGINF	3		/* negative infinity */

/*
 * Definition of the FP enable flags of the pcb struct
 * Normal operation, all flags are zero
 */
#define	FP_UNINITIALIZED	1
#define	FP_STARTSIG		2
#define	FP_DISABLE		4
#define	FP_ENABLE		8

#ifndef __ASSEMBLER__
/*
 * How a register window looks on the stack.
 */
struct rwindow {
	int	rw_local[8];		/* locals */
	int	rw_in[8];		/* ins */
};

#define	rw_fp	rw_in[6]		/* frame pointer */
#define	rw_rtn	rw_in[7]		/* return address */

#endif /* !__ASSEMBLER__ */


/*
 * Definition of bits in the Sun-4 PSR (Processor Status Register)
 *   ____________________________________________________________________
 *  |    IMPL   | VER |  ICC | res | EC | EF |  PIL  | S | PS | ET | CWP |
 *  |-----------|-----|------|-----|----|----|-------|---|----|----|-----|
 *   31       28 27  24 23  20 19 14 13   12  11    8  7    6    5  4    0
 */


struct p_status {
  union {
    unsigned int psr;
    struct {
	unsigned int 
	impl:4,
	ver:4,
	icc:4,
	reserved:6,
	ec:1,
	ef:1,
	pil:4,
	s:1,
	ps:1,
	et:1,
	cwp:5;
      } psr_bits;
  } PSRREG;
};

struct f_status {
  union {
    FPU_FSR_TYPE Fpu_fsr;		/* FPU status register */
    struct {
      unsigned int
      rd:2,
      rp:2,
      tem:5,
      res:6,
      ftt:3,
      qne:1,
      pr:1,
      fcc:2,
      aexc:5,
      cexc:5;
    } Fpu_fsr_bits;
  } FPUREG;
};

#endif /*!_sparc_reg_h*/
                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/cbt/                                0040755 0001750 0001750 00000000000 12612724206 022636  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/cbt/libsyminfo.h                    0100644 0001750 0001750 00000005205 12612724206 025161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <mach/mach.h>

#ifndef __SymInfoTypes__
typedef void *SymInfoList;
typedef void *SymInfoSymbol;
typedef void *SymInfoDependencies;
#endif // __SymInfoTypes__

/* Creates a SymInfoList structure from a binary */
SymInfoList SymInfoCreate(char *fileName);

/*Access to main structures in the SymInfoList */
SymInfoSymbol *SymInfoGetImports(SymInfoList nmList);
SymInfoSymbol *SymInfoGetExports(SymInfoList nmList);
SymInfoDependencies SymInfoGetLibraryInfo(SymInfoList nmList);
char *SymInfoGetShortName(SymInfoList nmList);

/* Access to data inside the SymInfoSymbol type */
char *SymInfoGetSymbolName(SymInfoSymbol symbol);
const char *SymInfoGetSymbolArch(SymInfoSymbol symbol);
char *SymInfoGetSymbolOrdinal(SymInfoSymbol symbol);
unsigned int SymInfoGetExportCount(SymInfoList nmList);
unsigned int SymInfoGetImportCount(SymInfoList nmList);

/* Access to data inside the SymInfoDependencies type */
char **SymInfoGetSubFrameworks(SymInfoDependencies deps);
char **SymInfoGetSubUmbrellas(SymInfoDependencies deps);
unsigned int SymInfoGetSubUmbrellaCount(SymInfoDependencies deps);
unsigned int SymInfoGetSubFrameworkCount(SymInfoDependencies deps);

/* Functions for freeing the SymInfoList structure */
void SymInfoFree(SymInfoList nmList);
void SymInfoFreeSymbols(SymInfoSymbol symbol);
void SymInfoFreeDependencies(SymInfoDependencies deps);

/* Function for creating SymInfoSymbol */
SymInfoSymbol SymInfoCreateSymbols(char *name,
			  	    char *arch,
			 	    char *ordinal);

/* Function for creating SymInfoDependencies */
SymInfoDependencies SymInfoCreateDependencies(char **subUmbrellas,
				 	      char **subFrameworks,
				    	      int nSubUmbrellas,
				  	      int nSubFrameworks);
                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/                               0040755 0001750 0001750 00000000000 12612724206 023003  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/aouthdr.h                      0100644 0001750 0001750 00000011352 12612724206 024621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _COFF_AOUTHDR_H
#define _COFF_AOUTHDR_H
/*
 * These data structures are discribed in the pecoff_v8.doc in section
 * "3.4. Optional Header (Image Only)"
 */
#include <stdint.h>

/*
 * Every image file has an optional header that provides information to the
 * loader. This header is optional in the sense that some files (specifically,
 * object files) do not have it. For image files, this header is required.
 *
 * Since definitions for this header were based from the GNU binutils files
 * coff/external.h, coff/internal.h and other files the copyright info is below.
 */

/* Copyright 2001 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

struct aouthdr
{
	uint16_t magic;		/* type of file				*/
	uint16_t vstamp;	/* version stamp			*/
	uint32_t tsize;		/* text size in bytes, padded to FW bdry*/
	uint32_t dsize;		/* initialized data "  "		*/
	uint32_t bsize;		/* uninitialized data "   "		*/
	uint32_t entry;		/* entry pt.				*/
	uint32_t text_start;	/* base of text used for this file 	*/
	uint32_t data_start;	/* base of data used for this file 	*/

	uint32_t ImageBase;
	uint32_t SectionAlignment;
	uint32_t FileAlignment;
	uint16_t MajorOperatingSystemVersion;
	uint16_t MinorOperatingSystemVersion;
	uint16_t MajorImageVersion;
	uint16_t MinorImageVersion;
	uint16_t MajorSubsystemVersion;
	uint16_t MinorSubsystemVersion;
	uint32_t Win32VersionValue;	/* Reserved, must be zero. */
	uint32_t SizeOfImage;
	uint32_t SizeOfHeaders;
	uint32_t CheckSum;
	uint16_t Subsystem;
	uint16_t DllCharacteristics;
	uint32_t SizeOfStackReserve;
	uint32_t SizeOfStackCommit;
	uint32_t SizeOfHeapReserve;
	uint32_t SizeOfHeapCommit;
	uint32_t LoaderFlags;
	uint32_t NumberOfRvaAndSizes;
	uint32_t DataDirectory[16][2]; /* 16 entries, 2 elements/entry, */
};

struct aouthdr_64
{
	uint16_t magic;		/* type of file				*/
	uint16_t vstamp;	/* version stamp			*/
	uint32_t tsize;		/* text size in bytes, padded to FW bdry*/
	uint32_t dsize;		/* initialized data "  "		*/
	uint32_t bsize;		/* uninitialized data "   "		*/
	uint32_t entry;		/* entry pt.				*/
	uint32_t text_start;	/* base of text used for this file 	*/
	/* note no base of data field in the 64-bit optional header */

	uint64_t ImageBase;
	uint32_t SectionAlignment;
	uint32_t FileAlignment;
	uint16_t MajorOperatingSystemVersion;
	uint16_t MinorOperatingSystemVersion;
	uint16_t MajorImageVersion;
	uint16_t MinorImageVersion;
	uint16_t MajorSubsystemVersion;
	uint16_t MinorSubsystemVersion;
	uint32_t Win32VersionValue;	/* Reserved, must be zero. */
	uint32_t SizeOfImage;
	uint32_t SizeOfHeaders;
	uint32_t CheckSum;
	uint16_t Subsystem;
	uint16_t DllCharacteristics;
	uint64_t SizeOfStackReserve;
	uint64_t SizeOfStackCommit;
	uint64_t SizeOfHeapReserve;
	uint64_t SizeOfHeapCommit;
	uint32_t LoaderFlags;
	uint32_t NumberOfRvaAndSizes;
	uint32_t DataDirectory[16][2]; /* 16 entries, 2 elements/entry, */
};

/* for the magic field */
#define PE32MAGIC       0x10b   /* 32-bit image */
#define PE32PMAGIC	0x20b	/* 32-bit image inside 64-bit address space */

/* for the FileAlignment field */
#define FILEALIGNMENT	0x200	/* The alignment factor (in bytes) that is used
				   to align the raw data of sections in the
				   image file. The value should be a power of 2
				   between 512 and 64 K, inclusive. The default
				   is 512. If the SectionAlignment is less than
				   the architecture's page size, then
				   FileAlignment must match SectionAlignment. */

/* for the SectionAlignment field */
#define SECTIONALIGNMENT 0x1000 /* The alignment (in bytes) of sections when
				   they are loaded into memory. It must be
				   greater than or equal to FileAlignment.
				   The default is the page size for the
				   architecture. */

/* for the vstamp field */
#define LINKER_VERSION 256 /* That is, 2.56 */
/* This piece of magic sets the "linker version" field to LINKER_VERSION.  */
#define VSTAMP (LINKER_VERSION / 100 + (LINKER_VERSION % 100) * 256)

/* for the Subsystem field */
#define IMAGE_SUBSYSTEM_EFI_APPLICATION		10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER	11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER	12

#endif /* _COFF_AOUTHDR_H */
                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/base_relocs.h                  0100644 0001750 0001750 00000005742 12612724206 025442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _EFI_BASE_RELOCS_H_
#define _EFI_BASE_RELOCS_H_
/*
 * These data structures are discribed in the pecoff_v8.doc in section
 * "6.6. The .reloc Section (Image Only)".
 */
#include <stdint.h>

 
/*
 * 6.6. The .reloc Section (Image Only)
 * The base relocation table contains entries for all base relocations in the
 * image.  (For PECOFF) The Base Relocation Table field in the optional header
 * data directories gives the number of bytes in the base relocation table. For 
 * more information, see section 3.4.3, "Optional Header Data Directories
 * (Image Only)."
 *
 * For Mach-O files being conveteted to PECOFF files the relocation table
 * entries are placed in the (__RELOC,__reloc) section after they are created
 * by makerelocs(1) and offset and size are found in the Mach-O section header
 * for this section.
 *
 * The base relocation table is divided into blocks. Each block represents the
 * base relocations for a 4K page. Each block must start on a 32-bit boundary.
 * The loader is not required to process base relocations that are resolved by
 * the linker, unless the load image cannot be loaded at the image base that is
 * specified in the PE header.
 * 
 * 6.6.1. Base Relocation Block
 * Each base relocation block starts with the following structure:
 * Offset	Size	Field	Description
 * 0		4	Page RVA	The image base plus the page RVA is
 *					added to each offset to create the VA
 *					where the base relocation must be
 *					applied.
 * 4		4	Block Size	The total number of bytes in the base
 *					relocation block, including the Page
 *					RVA and Block Size fields and the
 *					Type/Offset fields that follow.
 */
struct base_relocation_block_header {
        uint32_t page_rva;
        uint32_t block_size;
};

/*
 * From "6.6.1. Base Relocation Block""
 * The Block Size field is then followed by any number of Type or Offset field
 * entries. Each entry is a WORD (2 bytes) and has the following structure:
 * Offset	Size	Field	Description
 * 0		4 bits	Type	Stored in the high 4 bits of the WORD, a value
 *				that indicates the type of base relocation to
 *				be applied. For more information, see section
 *				6.6.2, "Base Relocation Types."
 * 0		12 bits	Offset	Stored in the remaining 12 bits of the WORD, an
 *				offset from the starting address that was
 *				specified in the Page RVA field for the block.
 *				This offset specifies where the base relocation
 *				is to be applied.
 */
struct base_relocation_entry {
#if __BIG_ENDIAN__
        uint16_t type:4,
		 offset:12;
#else
        uint16_t offset:12,
		 type:4;
#endif
};

#define	IMAGE_REL_BASED_ABSOLUTE	0 /* The base relocation is skipped.
					     This type can be used to pad a
					     block. */
#define IMAGE_REL_BASED_HIGHLOW		3 /* The base relocation applies all
					     32 bits of the difference to the
					     32-bit field at offset. */
#define IMAGE_REL_BASED_DIR64	       10 /* The base relocation applies the
					     difference to the 64-bit field at
					     offset. */
#endif /* _EFI_BASE_RELOCS_H_ */
                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/bytesex.h                      0100644 0001750 0001750 00000002656 12612724206 024645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _COFF_BYTESEX_H
#define _COFF_BYTESEX_H

#include "stuff/bytesex.h"
#include "coff/base_relocs.h"
#include "coff/ms_dos_stub.h"
#include "coff/filehdr.h"
#include "coff/aouthdr.h"
#include "coff/scnhdr.h"
#include "coff/syment.h"
#include "coff/debug_directory.h"

__private_extern__ void swap_base_relocation_block_header(
    struct base_relocation_block_header *h,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_base_relocation_entry(
    struct base_relocation_entry *b,
    uint32_t n,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_ms_dos_stub(
    struct ms_dos_stub *m,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_filehdr(
    struct filehdr *f,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_aouthdr(
    struct aouthdr *a,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_aouthdr_64(
    struct aouthdr_64 *a,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_scnhdr(
    struct scnhdr *s,
    uint32_t n,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_syment(
    struct syment *s,
    uint32_t n,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_debug_directory_entry(
    struct debug_directory_entry *d,
    enum byte_sex target_byte_sex);

__private_extern__ void swap_mtoc_debug_info(
    struct mtoc_debug_info *m,
    enum byte_sex target_byte_sex);

#endif /* _COFF_BYTESEX_H */
                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/debug_directory.h              0100644 0001750 0001750 00000005325 12612724206 026330  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _EFI_DEBUG_DIRECTORY_H_
#define _EFI_DEBUG_DIRECTORY_H_
/*
 * These data structures are discribed in the pecoff_v8.doc in section
 * "6.1.1. Debug Directory (Image Only)"
 */
#include <stdint.h>

 
/*
 * 6.1.1 Debug Directory (Image Only)
 * Image files contain an optional debug directory that indicates what form of
 * debug information is present and where it is. This directory consists of an
 * array of debug directory entries whose location and size are indicated in
 * the image optional header.
 * 
 * The debug directory can be in a discardable .debug section (if one exists),
 * or it can be included in any other section in the image file, or not be in
 * a section at all.
 * 
 * Each debug directory entry identifies the location and size of a block of
 * debug information. The specified RVA can be zero if the debug information is 
 * not covered by a section header (that is, it resides in the image file and
 * is not mapped into the run-time address space). If it is mapped, the RVA is
 * its address. 
 *
 * A debug directory entry has the following format:
 * Offset	Size	Field		Description
 * 0		4	Characteristics	Reserved, must be zero.
 * 4		4	TimeDateStamp	The time and date that the debug data
 *					was created.
 * 8		2	MajorVersion	The major version number of the debug
 *					data format.
 * 10		2	MinorVersion	The minor version number of the debug
 *					data format.
 * 12		4	Type		The format of debugging information.
 *					This field enables support of multiple
 *					debuggers. For more information, see
 *					section 6.1.2, "Debug Type."
 * 16		4	SizeOfData	The size of the debug data (not
 *					including the debug directory itself).
 * 20		4	AddressOfRawData The address of the debug data when
 *					loaded, relative to the image base.
 * 24		4	PointerToRawData The file pointer to the debug data.
 */
struct debug_directory_entry {
    uint32_t	Characteristics;
    uint32_t	TimeDateStamp;
    uint16_t	MajorVersion;
    uint16_t	MinorVersion;
    uint32_t	Type;
    uint32_t	SizeOfData;
    uint32_t	AddressOfRawData;
    uint32_t	PointerToRawData;
};

/*
 * For mtoc(1)'s -d option it uses a debug directory entry with the Type of
 * IMAGE_DEBUG_TYPE_CODEVIEW pointing to the structure below.
 */
#define IMAGE_DEBUG_TYPE_CODEVIEW 2

/*
 * This structure is directly followed by a null terminated filename of the -d
 * argument file passed to the motc(1) command.
 */
struct mtoc_debug_info {
    uint32_t	Signature;	/* this is be 'MTOC' or 0x434f544d */
    uint8_t     uuid[16];       /* the 128-bit uuid from the LC_UUID command */
    /* argument of the -d mtoc(1) command follows directly after */
};
#define MTOC_SIGNATURE	0x434f544d /* the value of the characters 'MTOC' */

#endif /* _EFI_DEBUG_DIRECTORY_H_ */
                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/filehdr.h                      0100644 0001750 0001750 00000004426 12612724206 024574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _COFF_FILEHDR_H
#define _COFF_FILEHDR_H
/*
 * These data structures are discribed in the pecoff_v8.doc in section
 * "3.3. COFF File Header (Object and Image)"
 */
#include <stdint.h>

/*
 * At the beginning of an object file, or immediately after the signature of an 
 * image file, is a standard COFF file header in the following format. Note
 *
 * Since definitions for this header were based from the GNU binutils
 * coff/pe.h header file that copyright info is below.
 */

/* pe.h  -  PE COFF header information 

   Copyright 2000, 2001, 2003, 2004 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

struct filehdr
{
	uint16_t f_magic;		/* Magic number.		*/
	uint16_t f_nscns;		/* Number of sections.		*/
	uint32_t f_timdat;		/* Time & date stamp.		*/
	uint32_t f_symptr;		/* File pointer to symtab.	*/
	uint32_t f_nsyms;		/* Number of symtab entries.	*/
	uint16_t f_opthdr;		/* Sizeof(optional hdr).	*/
	uint16_t f_flags;		/* Flags.			*/
};

/* Machine numbers (for the f_magic field).  */
#define IMAGE_FILE_MACHINE_ARM               0x01c0
#define IMAGE_FILE_MACHINE_ARM64             0x01c6
#define IMAGE_FILE_MACHINE_I386              0x014c
#define IMAGE_FILE_MACHINE_AMD64             0x8664

/* NT specific file attributes (for the f_flags field).  */
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008
#define IMAGE_FILE_32BIT_MACHINE             0x0100
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200

#endif /* _COFF_FILEHDR_H */
                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/ms_dos_stub.h                  0100644 0001750 0001750 00000006075 12612724206 025502  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _COFF_MS_DOS_STUB_H
#define _COFF_MS_DOS_STUB_H
/*
 * These data structures are discussed be not discribed in detail in
 * pecoff_v8.doc in section "3.1. MS DOS Stub (Image Only)"
 */
#include <stdint.h>

/*
 * The MS DOS stub is a valid application that runs under MS DOS. It is placed
 * at the front of a pecoff image. The default stub prints out the message "This
 * program cannot be run in DOS mode" when the image is run in MS DOS.
 *
 * At location 0x3c (the e_lfanew field), the stub has the file offset to the
 * PE signature. This information enables Windows to properly execute the image 
 * file, even though it has an MS DOS stub. This file offset is placed at
 * location 0x3c during linking.
 *
 * Since definitions for this header were based from the GNU binutils
 * coff/pe.h header file that copyright info is below.
 */

/* pe.h  -  PE COFF header information 

   Copyright 2000, 2001, 2003, 2004 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Magic values that are true for all dos/nt implementations.  */
#define DOSMAGIC       0x5a4d  

struct ms_dos_stub
{
  /* DOS header fields - always at offset zero in the EXE file.  */
  uint16_t e_magic;	/* Magic number, 0x5a4d. (DOSMAGIC above) */
  uint16_t e_cblp;	/* Bytes on last page of file, 0x90.  */
  uint16_t e_cp;	/* Pages in file, 0x3.  */
  uint16_t e_crlc;	/* Relocations, 0x0.  */
  uint16_t e_cparhdr;	/* Size of header in paragraphs, 0x4.  */
  uint16_t e_minalloc;	/* Minimum extra paragraphs needed, 0x0.  */
  uint16_t e_maxalloc;	/* Maximum extra paragraphs needed, 0xFFFF.  */
  uint16_t e_ss;	/* Initial (relative) SS value, 0x0.  */
  uint16_t e_sp;	/* Initial SP value, 0xb8.  */
  uint16_t e_csum;	/* Checksum, 0x0.  */
  uint16_t e_ip;	/* Initial IP value, 0x0.  */
  uint16_t e_cs;	/* Initial (relative) CS value, 0x0.  */
  uint16_t e_lfarlc;	/* File address of relocation table, 0x40.  */
  uint16_t e_ovno;	/* Overlay number, 0x0.  */
  uint16_t e_res[4];	/* Reserved words, all 0x0.  */
  uint16_t e_oemid;	/* OEM identifier (for e_oeminfo), 0x0.  */
  uint16_t e_oeminfo;	/* OEM information; e_oemid specific, 0x0.  */
  uint16_t e_res2[10];	/* Reserved words, all 0x0.  */
  uint32_t e_lfanew;	/* File address of new exe header, usually 0x80.  */
  char dos_program[64];	/* MS-DOS ,stufa always follow DOS header.  */
};

#endif /* _COFF_MS_DOS_STUB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/scnhdr.h                       0100644 0001750 0001750 00000006014 12612724206 024433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _COFF_SCNHDR_H
#define _COFF_SCNHDR_H
/*
 * These data structures are discribed in the pecoff_v8.doc in section
 * "4. Section Table (Section Headers)"
 */
#include <stdint.h>

/*
 * Each row of the section table is, in effect, a section header. This table
 * immediately follows the optional header, if any. This positioning is
 * required because the file header does not contain a direct pointer to the
 * section table. Instead, the location of the section table is determined by
 * calculating the location of the first byte after the headers.
 *
 * The number of entries in the section table is given by the NumberOfSections
 * field in the file header. Entries in the section table are numbered starting
 * from one (1). The code and data memory section entries are in the order
 * chosen by the linker.
 *
 * In an image file, the VAs for sections must be assigned by the linker so
 * that they are in ascending order and adjacent, and they must be a multiple
 * of the SectionAlignment value in the optional header.
 *
 * Since definitions for this header were based from the GNU binutils
 * coff/pe.h header file that copyright info is below.
 */

/* pe.h  -  PE COFF header information 

   Copyright 2000, 2001, 2003, 2004 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

struct scnhdr
{
	char s_name[8];		/* section name				*/
	uint32_t s_vsize;	/* virtual size				*/
	uint32_t s_vaddr;	/* virtual address			*/
	uint32_t s_size;	/* section size				*/
	uint32_t s_scnptr;	/* file ptr to raw data for section 	*/
	uint32_t s_relptr;	/* file ptr to relocation		*/
	uint32_t s_lnnoptr;	/* file ptr to line numbers		*/
	uint16_t s_nreloc;	/* number of relocation entries		*/
	uint16_t s_nlnno;	/* number of line number entries	*/
	uint32_t s_flags;	/* flags				*/
};

/* values or'ed into the s_flags field */
#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000
#define IMAGE_SCN_MEM_EXECUTE     0x20000000
#define IMAGE_SCN_MEM_READ        0x40000000
#define IMAGE_SCN_MEM_WRITE       0x80000000

#define IMAGE_SCN_CNT_CODE                   0x00000020  /* Section contains code. */
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  /* Section contains initialized data. */
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  /* Section contains uninitialized data. */

#endif /* _COFF_SCNHDR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/coff/syment.h                       0100644 0001750 0001750 00000003306 12612724206 024472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _COFF_SYMENT_H
#define _COFF_SYMENT_H
/*
 * These data structures are discribed in the pecoff_v8.doc in section
 * "5.4. COFF Symbol Table"
 */
#include <stdint.h>

/*
 * Since definitions for this header were based from the GNU binutils
 * coff/external.h header file that copyright info is below.
 */

/* external.h  -- External COFF structures
   
   Copyright 2001 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

#define E_SYMNMLEN	8	/* # characters in a symbol name	*/

struct syment 
{
  union
  {
    char e_name[E_SYMNMLEN];

    struct
    {
      uint32_t e_zeroes;
      uint32_t e_offset;
    } e;
  } e;

  uint32_t e_value;
  uint16_t e_scnum;
  uint16_t e_type;
  char e_sclass;
  char e_numaux;
}
/*
 * The symbol table is an array of this struct which must be 18 bytes in size.
 * Which is why the packed and and alignment of 2 bytes is done.
 */
__attribute((packed,aligned(2))) ;

/* constants used in the e_sclass (Storage Class) field */
#define IMAGE_SYM_CLASS_EXTERNAL 2
#endif /* _COFF_SYMENT_H */
                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/elf/                                0040755 0001750 0001750 00000000000 12612724206 022634  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/elf/dwarf2.h                        0100644 0001750 0001750 00000055465 12612724206 024206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* Declarations and definitions of codes relating to the DWARF2 and
   DWARF3 symbolic debugging information formats.
   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.

   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program
   Office (AJPO), Florida State University and Silicon Graphics Inc.
   provided support for this effort -- June 21, 1995.

   Derived from the DWARF 1 implementation written by Ron Guilmette
   (rfg@netcom.com), November 1990.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2, or (at your option) any later
   version.

   GCC is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with GCC; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file is derived from the DWARF specification (a public document)
   Revision 2.0.0 (July 27, 1993) developed by the UNIX International
   Programming Languages Special Interest Group (UI/PLSIG) and distributed
   by UNIX International.  Copies of this specification are available from
   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.

   This file also now contains definitions from the DWARF 3 specification.  */

/* This file is shared between GCC and GDB, and should not contain
   prototypes.  */

#ifndef _ELF_DWARF2_H
#define _ELF_DWARF2_H

/* Structure found in the .debug_line section.  */
typedef struct
{
  unsigned char li_length          [4];
  unsigned char li_version         [2];
  unsigned char li_prologue_length [4];
  unsigned char li_min_insn_length [1];
  unsigned char li_default_is_stmt [1];
  unsigned char li_line_base       [1];
  unsigned char li_line_range      [1];
  unsigned char li_opcode_base     [1];
}
DWARF2_External_LineInfo;

typedef struct
{
  unsigned long  li_length;
  unsigned short li_version;
  unsigned int   li_prologue_length;
  unsigned char  li_min_insn_length;
  unsigned char  li_default_is_stmt;
  int            li_line_base;
  unsigned char  li_line_range;
  unsigned char  li_opcode_base;
}
DWARF2_Internal_LineInfo;

/* Structure found in .debug_pubnames section.  */
typedef struct
{
  unsigned char pn_length  [4];
  unsigned char pn_version [2];
  unsigned char pn_offset  [4];
  unsigned char pn_size    [4];
}
DWARF2_External_PubNames;

typedef struct
{
  unsigned long  pn_length;
  unsigned short pn_version;
  unsigned long  pn_offset;
  unsigned long  pn_size;
}
DWARF2_Internal_PubNames;

/* Structure found in .debug_info section.  */
typedef struct
{
  unsigned char  cu_length        [4];
  unsigned char  cu_version       [2];
  unsigned char  cu_abbrev_offset [4];
  unsigned char  cu_pointer_size  [1];
}
DWARF2_External_CompUnit;

typedef struct
{
  unsigned long  cu_length;
  unsigned short cu_version;
  unsigned long  cu_abbrev_offset;
  unsigned char  cu_pointer_size;
}
DWARF2_Internal_CompUnit;

typedef struct
{
  unsigned char  ar_length       [4];
  unsigned char  ar_version      [2];
  unsigned char  ar_info_offset  [4];
  unsigned char  ar_pointer_size [1];
  unsigned char  ar_segment_size [1];
}
DWARF2_External_ARange;

typedef struct
{
  unsigned long  ar_length;
  unsigned short ar_version;
  unsigned long  ar_info_offset;
  unsigned char  ar_pointer_size;
  unsigned char  ar_segment_size;
}
DWARF2_Internal_ARange;


/* Tag names and codes.  */
enum dwarf_tag
  {
    DW_TAG_padding = 0x00,
    DW_TAG_array_type = 0x01,
    DW_TAG_class_type = 0x02,
    DW_TAG_entry_point = 0x03,
    DW_TAG_enumeration_type = 0x04,
    DW_TAG_formal_parameter = 0x05,
    DW_TAG_imported_declaration = 0x08,
    DW_TAG_label = 0x0a,
    DW_TAG_lexical_block = 0x0b,
    DW_TAG_member = 0x0d,
    DW_TAG_pointer_type = 0x0f,
    DW_TAG_reference_type = 0x10,
    DW_TAG_compile_unit = 0x11,
    DW_TAG_string_type = 0x12,
    DW_TAG_structure_type = 0x13,
    DW_TAG_subroutine_type = 0x15,
    DW_TAG_typedef = 0x16,
    DW_TAG_union_type = 0x17,
    DW_TAG_unspecified_parameters = 0x18,
    DW_TAG_variant = 0x19,
    DW_TAG_common_block = 0x1a,
    DW_TAG_common_inclusion = 0x1b,
    DW_TAG_inheritance = 0x1c,
    DW_TAG_inlined_subroutine = 0x1d,
    DW_TAG_module = 0x1e,
    DW_TAG_ptr_to_member_type = 0x1f,
    DW_TAG_set_type = 0x20,
    DW_TAG_subrange_type = 0x21,
    DW_TAG_with_stmt = 0x22,
    DW_TAG_access_declaration = 0x23,
    DW_TAG_base_type = 0x24,
    DW_TAG_catch_block = 0x25,
    DW_TAG_const_type = 0x26,
    DW_TAG_constant = 0x27,
    DW_TAG_enumerator = 0x28,
    DW_TAG_file_type = 0x29,
    DW_TAG_friend = 0x2a,
    DW_TAG_namelist = 0x2b,
    DW_TAG_namelist_item = 0x2c,
    DW_TAG_packed_type = 0x2d,
    DW_TAG_subprogram = 0x2e,
    DW_TAG_template_type_param = 0x2f,
    DW_TAG_template_value_param = 0x30,
    DW_TAG_thrown_type = 0x31,
    DW_TAG_try_block = 0x32,
    DW_TAG_variant_part = 0x33,
    DW_TAG_variable = 0x34,
    DW_TAG_volatile_type = 0x35,
    /* DWARF 3.  */
    DW_TAG_dwarf_procedure = 0x36,
    DW_TAG_restrict_type = 0x37,
    DW_TAG_interface_type = 0x38,
    DW_TAG_namespace = 0x39,
    DW_TAG_imported_module = 0x3a,
    DW_TAG_unspecified_type = 0x3b,
    DW_TAG_partial_unit = 0x3c,
    DW_TAG_imported_unit = 0x3d,
    DW_TAG_condition = 0x3f,
    DW_TAG_shared_type = 0x40,
    /* SGI/MIPS Extensions.  */
    DW_TAG_MIPS_loop = 0x4081,
    /* HP extensions.  See: ftp://ftp.hp.com/pub/lang/tools/WDB/wdb-4.0.tar.gz .  */
    DW_TAG_HP_array_descriptor = 0x4090,
    /* GNU extensions.  */
    DW_TAG_format_label = 0x4101,	/* For FORTRAN 77 and Fortran 90.  */
    DW_TAG_function_template = 0x4102,	/* For C++.  */
    DW_TAG_class_template = 0x4103,	/* For C++.  */
    DW_TAG_GNU_BINCL = 0x4104,
    DW_TAG_GNU_EINCL = 0x4105,
    /* Extensions for UPC.  See: http://upc.gwu.edu/~upc.  */
    DW_TAG_upc_shared_type = 0x8765,
    DW_TAG_upc_strict_type = 0x8766,
    DW_TAG_upc_relaxed_type = 0x8767,
    /* PGI (STMicroelectronics) extensions.  No documentation available.  */
    DW_TAG_PGI_kanji_type      = 0xA000,
    DW_TAG_PGI_interface_block = 0xA020
  };

#define DW_TAG_lo_user	0x4080
#define DW_TAG_hi_user	0xffff

/* Flag that tells whether entry has a child or not.  */
#define DW_children_no   0
#define	DW_children_yes  1

/* Form names and codes.  */
enum dwarf_form
  {
    DW_FORM_addr = 0x01,
    DW_FORM_block2 = 0x03,
    DW_FORM_block4 = 0x04,
    DW_FORM_data2 = 0x05,
    DW_FORM_data4 = 0x06,
    DW_FORM_data8 = 0x07,
    DW_FORM_string = 0x08,
    DW_FORM_block = 0x09,
    DW_FORM_block1 = 0x0a,
    DW_FORM_data1 = 0x0b,
    DW_FORM_flag = 0x0c,
    DW_FORM_sdata = 0x0d,
    DW_FORM_strp = 0x0e,
    DW_FORM_udata = 0x0f,
    DW_FORM_ref_addr = 0x10,
    DW_FORM_ref1 = 0x11,
    DW_FORM_ref2 = 0x12,
    DW_FORM_ref4 = 0x13,
    DW_FORM_ref8 = 0x14,
    DW_FORM_ref_udata = 0x15,
    DW_FORM_indirect = 0x16
  };

/* Attribute names and codes.  */
enum dwarf_attribute
  {
    DW_AT_sibling = 0x01,
    DW_AT_location = 0x02,
    DW_AT_name = 0x03,
    DW_AT_ordering = 0x09,
    DW_AT_subscr_data = 0x0a,
    DW_AT_byte_size = 0x0b,
    DW_AT_bit_offset = 0x0c,
    DW_AT_bit_size = 0x0d,
    DW_AT_element_list = 0x0f,
    DW_AT_stmt_list = 0x10,
    DW_AT_low_pc = 0x11,
    DW_AT_high_pc = 0x12,
    DW_AT_language = 0x13,
    DW_AT_member = 0x14,
    DW_AT_discr = 0x15,
    DW_AT_discr_value = 0x16,
    DW_AT_visibility = 0x17,
    DW_AT_import = 0x18,
    DW_AT_string_length = 0x19,
    DW_AT_common_reference = 0x1a,
    DW_AT_comp_dir = 0x1b,
    DW_AT_const_value = 0x1c,
    DW_AT_containing_type = 0x1d,
    DW_AT_default_value = 0x1e,
    DW_AT_inline = 0x20,
    DW_AT_is_optional = 0x21,
    DW_AT_lower_bound = 0x22,
    DW_AT_producer = 0x25,
    DW_AT_prototyped = 0x27,
    DW_AT_return_addr = 0x2a,
    DW_AT_start_scope = 0x2c,
    DW_AT_stride_size = 0x2e,
    DW_AT_upper_bound = 0x2f,
    DW_AT_abstract_origin = 0x31,
    DW_AT_accessibility = 0x32,
    DW_AT_address_class = 0x33,
    DW_AT_artificial = 0x34,
    DW_AT_base_types = 0x35,
    DW_AT_calling_convention = 0x36,
    DW_AT_count = 0x37,
    DW_AT_data_member_location = 0x38,
    DW_AT_decl_column = 0x39,
    DW_AT_decl_file = 0x3a,
    DW_AT_decl_line = 0x3b,
    DW_AT_declaration = 0x3c,
    DW_AT_discr_list = 0x3d,
    DW_AT_encoding = 0x3e,
    DW_AT_external = 0x3f,
    DW_AT_frame_base = 0x40,
    DW_AT_friend = 0x41,
    DW_AT_identifier_case = 0x42,
    DW_AT_macro_info = 0x43,
    DW_AT_namelist_items = 0x44,
    DW_AT_priority = 0x45,
    DW_AT_segment = 0x46,
    DW_AT_specification = 0x47,
    DW_AT_static_link = 0x48,
    DW_AT_type = 0x49,
    DW_AT_use_location = 0x4a,
    DW_AT_variable_parameter = 0x4b,
    DW_AT_virtuality = 0x4c,
    DW_AT_vtable_elem_location = 0x4d,
    /* DWARF 3 values.  */
    DW_AT_allocated     = 0x4e,
    DW_AT_associated    = 0x4f,
    DW_AT_data_location = 0x50,
    DW_AT_stride        = 0x51,
    DW_AT_entry_pc      = 0x52,
    DW_AT_use_UTF8      = 0x53,
    DW_AT_extension     = 0x54,
    DW_AT_ranges        = 0x55,
    DW_AT_trampoline    = 0x56,
    DW_AT_call_column   = 0x57,
    DW_AT_call_file     = 0x58,
    DW_AT_call_line     = 0x59,
    DW_AT_description   = 0x5a,
    DW_AT_binary_scale  = 0x5b,
    DW_AT_decimal_scale = 0x5c,
    DW_AT_small         = 0x5d,
    DW_AT_decimal_sign  = 0x5e,
    DW_AT_digit_count   = 0x5f,
    DW_AT_picture_string = 0x60,
    DW_AT_mutable       = 0x61,
    DW_AT_threads_scaled = 0x62,
    DW_AT_explicit      = 0x63,
    DW_AT_object_pointer = 0x64,
    DW_AT_endianity     = 0x65,
    DW_AT_elemental     = 0x66,
    DW_AT_pure          = 0x67,
    DW_AT_recursive     = 0x68,
    /* SGI/MIPS extensions.  */
    DW_AT_MIPS_fde = 0x2001,
    DW_AT_MIPS_loop_begin = 0x2002,
    DW_AT_MIPS_tail_loop_begin = 0x2003,
    DW_AT_MIPS_epilog_begin = 0x2004,
    DW_AT_MIPS_loop_unroll_factor = 0x2005,
    DW_AT_MIPS_software_pipeline_depth = 0x2006,
    DW_AT_MIPS_linkage_name = 0x2007,
    DW_AT_MIPS_stride = 0x2008,
    DW_AT_MIPS_abstract_name = 0x2009,
    DW_AT_MIPS_clone_origin = 0x200a,
    DW_AT_MIPS_has_inlines = 0x200b,
    /* HP extensions.  */
    DW_AT_HP_block_index         = 0x2000,
    DW_AT_HP_unmodifiable        = 0x2001, /* Same as DW_AT_MIPS_fde.  */
    DW_AT_HP_actuals_stmt_list   = 0x2010,
    DW_AT_HP_proc_per_section    = 0x2011,
    DW_AT_HP_raw_data_ptr        = 0x2012,
    DW_AT_HP_pass_by_reference   = 0x2013,
    DW_AT_HP_opt_level           = 0x2014,
    DW_AT_HP_prof_version_id     = 0x2015,
    DW_AT_HP_opt_flags           = 0x2016,
    DW_AT_HP_cold_region_low_pc  = 0x2017,
    DW_AT_HP_cold_region_high_pc = 0x2018,
    DW_AT_HP_all_variables_modifiable = 0x2019,
    DW_AT_HP_linkage_name        = 0x201a,
    DW_AT_HP_prof_flags          = 0x201b,  /* In comp unit of procs_info for -g.  */
    /* GNU extensions.  */
    DW_AT_sf_names   = 0x2101,
    DW_AT_src_info   = 0x2102,
    DW_AT_mac_info   = 0x2103,
    DW_AT_src_coords = 0x2104,
    DW_AT_body_begin = 0x2105,
    DW_AT_body_end   = 0x2106,
    DW_AT_GNU_vector = 0x2107,
    /* VMS extensions.  */
    DW_AT_VMS_rtnbeg_pd_address = 0x2201,
    /* UPC extension.  */
    DW_AT_upc_threads_scaled = 0x3210,
    /* PGI (STMicroelectronics) extensions.  */
    DW_AT_PGI_lbase    = 0x3a00,
    DW_AT_PGI_soffset  = 0x3a01,
    DW_AT_PGI_lstride  = 0x3a02,
    /* Apple extension.  */
    DW_AT_APPLE_flags  = 0x3fe2
  };

#define DW_AT_lo_user	0x2000	/* Implementation-defined range start.  */
#define DW_AT_hi_user	0x3ff0	/* Implementation-defined range end.  */

/* Location atom names and codes.  */
enum dwarf_location_atom
  {
    DW_OP_addr = 0x03,
    DW_OP_deref = 0x06,
    DW_OP_const1u = 0x08,
    DW_OP_const1s = 0x09,
    DW_OP_const2u = 0x0a,
    DW_OP_const2s = 0x0b,
    DW_OP_const4u = 0x0c,
    DW_OP_const4s = 0x0d,
    DW_OP_const8u = 0x0e,
    DW_OP_const8s = 0x0f,
    DW_OP_constu = 0x10,
    DW_OP_consts = 0x11,
    DW_OP_dup = 0x12,
    DW_OP_drop = 0x13,
    DW_OP_over = 0x14,
    DW_OP_pick = 0x15,
    DW_OP_swap = 0x16,
    DW_OP_rot = 0x17,
    DW_OP_xderef = 0x18,
    DW_OP_abs = 0x19,
    DW_OP_and = 0x1a,
    DW_OP_div = 0x1b,
    DW_OP_minus = 0x1c,
    DW_OP_mod = 0x1d,
    DW_OP_mul = 0x1e,
    DW_OP_neg = 0x1f,
    DW_OP_not = 0x20,
    DW_OP_or = 0x21,
    DW_OP_plus = 0x22,
    DW_OP_plus_uconst = 0x23,
    DW_OP_shl = 0x24,
    DW_OP_shr = 0x25,
    DW_OP_shra = 0x26,
    DW_OP_xor = 0x27,
    DW_OP_bra = 0x28,
    DW_OP_eq = 0x29,
    DW_OP_ge = 0x2a,
    DW_OP_gt = 0x2b,
    DW_OP_le = 0x2c,
    DW_OP_lt = 0x2d,
    DW_OP_ne = 0x2e,
    DW_OP_skip = 0x2f,
    DW_OP_lit0 = 0x30,
    DW_OP_lit1 = 0x31,
    DW_OP_lit2 = 0x32,
    DW_OP_lit3 = 0x33,
    DW_OP_lit4 = 0x34,
    DW_OP_lit5 = 0x35,
    DW_OP_lit6 = 0x36,
    DW_OP_lit7 = 0x37,
    DW_OP_lit8 = 0x38,
    DW_OP_lit9 = 0x39,
    DW_OP_lit10 = 0x3a,
    DW_OP_lit11 = 0x3b,
    DW_OP_lit12 = 0x3c,
    DW_OP_lit13 = 0x3d,
    DW_OP_lit14 = 0x3e,
    DW_OP_lit15 = 0x3f,
    DW_OP_lit16 = 0x40,
    DW_OP_lit17 = 0x41,
    DW_OP_lit18 = 0x42,
    DW_OP_lit19 = 0x43,
    DW_OP_lit20 = 0x44,
    DW_OP_lit21 = 0x45,
    DW_OP_lit22 = 0x46,
    DW_OP_lit23 = 0x47,
    DW_OP_lit24 = 0x48,
    DW_OP_lit25 = 0x49,
    DW_OP_lit26 = 0x4a,
    DW_OP_lit27 = 0x4b,
    DW_OP_lit28 = 0x4c,
    DW_OP_lit29 = 0x4d,
    DW_OP_lit30 = 0x4e,
    DW_OP_lit31 = 0x4f,
    DW_OP_reg0 = 0x50,
    DW_OP_reg1 = 0x51,
    DW_OP_reg2 = 0x52,
    DW_OP_reg3 = 0x53,
    DW_OP_reg4 = 0x54,
    DW_OP_reg5 = 0x55,
    DW_OP_reg6 = 0x56,
    DW_OP_reg7 = 0x57,
    DW_OP_reg8 = 0x58,
    DW_OP_reg9 = 0x59,
    DW_OP_reg10 = 0x5a,
    DW_OP_reg11 = 0x5b,
    DW_OP_reg12 = 0x5c,
    DW_OP_reg13 = 0x5d,
    DW_OP_reg14 = 0x5e,
    DW_OP_reg15 = 0x5f,
    DW_OP_reg16 = 0x60,
    DW_OP_reg17 = 0x61,
    DW_OP_reg18 = 0x62,
    DW_OP_reg19 = 0x63,
    DW_OP_reg20 = 0x64,
    DW_OP_reg21 = 0x65,
    DW_OP_reg22 = 0x66,
    DW_OP_reg23 = 0x67,
    DW_OP_reg24 = 0x68,
    DW_OP_reg25 = 0x69,
    DW_OP_reg26 = 0x6a,
    DW_OP_reg27 = 0x6b,
    DW_OP_reg28 = 0x6c,
    DW_OP_reg29 = 0x6d,
    DW_OP_reg30 = 0x6e,
    DW_OP_reg31 = 0x6f,
    DW_OP_breg0 = 0x70,
    DW_OP_breg1 = 0x71,
    DW_OP_breg2 = 0x72,
    DW_OP_breg3 = 0x73,
    DW_OP_breg4 = 0x74,
    DW_OP_breg5 = 0x75,
    DW_OP_breg6 = 0x76,
    DW_OP_breg7 = 0x77,
    DW_OP_breg8 = 0x78,
    DW_OP_breg9 = 0x79,
    DW_OP_breg10 = 0x7a,
    DW_OP_breg11 = 0x7b,
    DW_OP_breg12 = 0x7c,
    DW_OP_breg13 = 0x7d,
    DW_OP_breg14 = 0x7e,
    DW_OP_breg15 = 0x7f,
    DW_OP_breg16 = 0x80,
    DW_OP_breg17 = 0x81,
    DW_OP_breg18 = 0x82,
    DW_OP_breg19 = 0x83,
    DW_OP_breg20 = 0x84,
    DW_OP_breg21 = 0x85,
    DW_OP_breg22 = 0x86,
    DW_OP_breg23 = 0x87,
    DW_OP_breg24 = 0x88,
    DW_OP_breg25 = 0x89,
    DW_OP_breg26 = 0x8a,
    DW_OP_breg27 = 0x8b,
    DW_OP_breg28 = 0x8c,
    DW_OP_breg29 = 0x8d,
    DW_OP_breg30 = 0x8e,
    DW_OP_breg31 = 0x8f,
    DW_OP_regx = 0x90,
    DW_OP_fbreg = 0x91,
    DW_OP_bregx = 0x92,
    DW_OP_piece = 0x93,
    DW_OP_deref_size = 0x94,
    DW_OP_xderef_size = 0x95,
    DW_OP_nop = 0x96,
    /* DWARF 3 extensions.  */
    DW_OP_push_object_address = 0x97,
    DW_OP_call2 = 0x98,
    DW_OP_call4 = 0x99,
    DW_OP_call_ref = 0x9a,
    DW_OP_form_tls_address = 0x9b,
    DW_OP_call_frame_cfa = 0x9c,
    DW_OP_bit_piece = 0x9d,
    /* GNU extensions.  */
    DW_OP_GNU_push_tls_address = 0xe0,
    DW_OP_GNU_uninit     = 0xf0,
    /* HP extensions.  */
    DW_OP_HP_unknown     = 0xe0, /* Ouch, the same as GNU_push_tls_address.  */
    DW_OP_HP_is_value    = 0xe1,
    DW_OP_HP_fltconst4   = 0xe2,
    DW_OP_HP_fltconst8   = 0xe3,
    DW_OP_HP_mod_range   = 0xe4,
    DW_OP_HP_unmod_range = 0xe5,
    DW_OP_HP_tls         = 0xe6
  };

#define DW_OP_lo_user	0xe0	/* Implementation-defined range start.  */
#define DW_OP_hi_user	0xff	/* Implementation-defined range end.  */

/* Type encodings.  */
enum dwarf_type
  {
    DW_ATE_void = 0x0,
    DW_ATE_address = 0x1,
    DW_ATE_boolean = 0x2,
    DW_ATE_complex_float = 0x3,
    DW_ATE_float = 0x4,
    DW_ATE_signed = 0x5,
    DW_ATE_signed_char = 0x6,
    DW_ATE_unsigned = 0x7,
    DW_ATE_unsigned_char = 0x8,
    /* DWARF 3.  */
    DW_ATE_imaginary_float = 0x9,
    DW_ATE_packed_decimal = 0xa,
    DW_ATE_numeric_string = 0xb,
    DW_ATE_edited = 0xc,
    DW_ATE_signed_fixed = 0xd,
    DW_ATE_unsigned_fixed = 0xe,
    DW_ATE_decimal_float = 0xf,
    /* HP extensions.  */
    DW_ATE_HP_float80            = 0x80, /* Floating-point (80 bit).  */
    DW_ATE_HP_complex_float80    = 0x81, /* Complex floating-point (80 bit).  */
    DW_ATE_HP_float128           = 0x82, /* Floating-point (128 bit).  */
    DW_ATE_HP_complex_float128   = 0x83, /* Complex floating-point (128 bit).  */
    DW_ATE_HP_floathpintel       = 0x84, /* Floating-point (82 bit IA64).  */
    DW_ATE_HP_imaginary_float80  = 0x85,
    DW_ATE_HP_imaginary_float128 = 0x86
  };

#define	DW_ATE_lo_user 0x80
#define	DW_ATE_hi_user 0xff

/* Decimal sign encodings.  */
enum dwarf_decimal_sign_encoding
  {
    /* DWARF 3.  */
    DW_DS_unsigned = 0x01,
    DW_DS_leading_overpunch = 0x02,
    DW_DS_trailing_overpunch = 0x03,
    DW_DS_leading_separate = 0x04,
    DW_DS_trailing_separate = 0x05
  };

/* Endianity encodings.  */
enum dwarf_endianity_encoding
  {
    /* DWARF 3.  */
    DW_END_default = 0x00,
    DW_END_big = 0x01,
    DW_END_little = 0x02
  };

#define DW_END_lo_user 0x40
#define DW_END_hi_user 0xff

/* Array ordering names and codes.  */
enum dwarf_array_dim_ordering
  {
    DW_ORD_row_major = 0,
    DW_ORD_col_major = 1
  };

/* Access attribute.  */
enum dwarf_access_attribute
  {
    DW_ACCESS_public = 1,
    DW_ACCESS_protected = 2,
    DW_ACCESS_private = 3
  };

/* Visibility.  */
enum dwarf_visibility_attribute
  {
    DW_VIS_local = 1,
    DW_VIS_exported = 2,
    DW_VIS_qualified = 3
  };

/* Virtuality.  */
enum dwarf_virtuality_attribute
  {
    DW_VIRTUALITY_none = 0,
    DW_VIRTUALITY_virtual = 1,
    DW_VIRTUALITY_pure_virtual = 2
  };

/* Case sensitivity.  */
enum dwarf_id_case
  {
    DW_ID_case_sensitive = 0,
    DW_ID_up_case = 1,
    DW_ID_down_case = 2,
    DW_ID_case_insensitive = 3
  };

/* Calling convention.  */
enum dwarf_calling_convention
  {
    DW_CC_normal = 0x1,
    DW_CC_program = 0x2,
    DW_CC_nocall = 0x3,
    DW_CC_GNU_renesas_sh = 0x40
  };

#define DW_CC_lo_user 0x40
#define DW_CC_hi_user 0xff

/* Inline attribute.  */
enum dwarf_inline_attribute
  {
    DW_INL_not_inlined = 0,
    DW_INL_inlined = 1,
    DW_INL_declared_not_inlined = 2,
    DW_INL_declared_inlined = 3
  };

/* Discriminant lists.  */
enum dwarf_discrim_list
  {
    DW_DSC_label = 0,
    DW_DSC_range = 1
  };

/* Line number opcodes.  */
enum dwarf_line_number_ops
  {
    DW_LNS_extended_op = 0,
    DW_LNS_copy = 1,
    DW_LNS_advance_pc = 2,
    DW_LNS_advance_line = 3,
    DW_LNS_set_file = 4,
    DW_LNS_set_column = 5,
    DW_LNS_negate_stmt = 6,
    DW_LNS_set_basic_block = 7,
    DW_LNS_const_add_pc = 8,
    DW_LNS_fixed_advance_pc = 9,
    /* DWARF 3.  */
    DW_LNS_set_prologue_end = 10,
    DW_LNS_set_epilogue_begin = 11,
    DW_LNS_set_isa = 12
  };

/* Line number extended opcodes.  */
enum dwarf_line_number_x_ops
  {
    DW_LNE_end_sequence = 1,
    DW_LNE_set_address = 2,
    DW_LNE_define_file = 3,
    /* HP extensions.  */
    DW_LNE_HP_negate_is_UV_update      = 0x11,
    DW_LNE_HP_push_context             = 0x12,
    DW_LNE_HP_pop_context              = 0x13,
    DW_LNE_HP_set_file_line_column     = 0x14,
    DW_LNE_HP_set_routine_name         = 0x15,
    DW_LNE_HP_set_sequence             = 0x16,
    DW_LNE_HP_negate_post_semantics    = 0x17,
    DW_LNE_HP_negate_function_exit     = 0x18,
    DW_LNE_HP_negate_front_end_logical = 0x19,
    DW_LNE_HP_define_proc              = 0x20
  };

#define DW_LNE_lo_user 0x80
#define DW_LNE_hi_user 0xff

/* Call frame information.  */
enum dwarf_call_frame_info
  {
    DW_CFA_advance_loc = 0x40,
    DW_CFA_offset = 0x80,
    DW_CFA_restore = 0xc0,
    DW_CFA_nop = 0x00,
    DW_CFA_set_loc = 0x01,
    DW_CFA_advance_loc1 = 0x02,
    DW_CFA_advance_loc2 = 0x03,
    DW_CFA_advance_loc4 = 0x04,
    DW_CFA_offset_extended = 0x05,
    DW_CFA_restore_extended = 0x06,
    DW_CFA_undefined = 0x07,
    DW_CFA_same_value = 0x08,
    DW_CFA_register = 0x09,
    DW_CFA_remember_state = 0x0a,
    DW_CFA_restore_state = 0x0b,
    DW_CFA_def_cfa = 0x0c,
    DW_CFA_def_cfa_register = 0x0d,
    DW_CFA_def_cfa_offset = 0x0e,
    /* DWARF 3.  */
    DW_CFA_def_cfa_expression = 0x0f,
    DW_CFA_expression = 0x10,
    DW_CFA_offset_extended_sf = 0x11,
    DW_CFA_def_cfa_sf = 0x12,
    DW_CFA_def_cfa_offset_sf = 0x13,
    DW_CFA_val_offset = 0x14,
    DW_CFA_val_offset_sf = 0x15,
    DW_CFA_val_expression = 0x16,
    /* SGI/MIPS specific.  */
    DW_CFA_MIPS_advance_loc8 = 0x1d,
    /* GNU extensions.  */
    DW_CFA_GNU_window_save = 0x2d,
    DW_CFA_GNU_args_size = 0x2e,
    DW_CFA_GNU_negative_offset_extended = 0x2f
  };

#define DW_CIE_ID	  0xffffffff
#define DW_CIE_VERSION	  1

#define DW_CFA_extended   0
#define DW_CFA_lo_user    0x1c
#define DW_CFA_hi_user    0x3f

#define DW_CHILDREN_no		     0x00
#define DW_CHILDREN_yes		     0x01

#define DW_ADDR_none		0

/* Source language names and codes.  */
enum dwarf_source_language
  {
    DW_LANG_C89 = 0x0001,
    DW_LANG_C = 0x0002,
    DW_LANG_Ada83 = 0x0003,
    DW_LANG_C_plus_plus = 0x0004,
    DW_LANG_Cobol74 = 0x0005,
    DW_LANG_Cobol85 = 0x0006,
    DW_LANG_Fortran77 = 0x0007,
    DW_LANG_Fortran90 = 0x0008,
    DW_LANG_Pascal83 = 0x0009,
    DW_LANG_Modula2 = 0x000a,
    /* DWARF 3.  */
    DW_LANG_Java = 0x000b,
    DW_LANG_C99 = 0x000c,
    DW_LANG_Ada95 = 0x000d,
    DW_LANG_Fortran95 = 0x000e,
    DW_LANG_PLI = 0x000f,
    DW_LANG_ObjC = 0x0010,
    DW_LANG_ObjC_plus_plus = 0x0011,
    DW_LANG_UPC = 0x0012,
    DW_LANG_D = 0x0013,
    /* MIPS.  */
    DW_LANG_Mips_Assembler = 0x8001,
    /* UPC.  */
    DW_LANG_Upc = 0x8765
  };

#define DW_LANG_lo_user 0x8000	/* Implementation-defined range start.  */
#define DW_LANG_hi_user 0xffff	/* Implementation-defined range start.  */

/* Names and codes for macro information.  */
enum dwarf_macinfo_record_type
  {
    DW_MACINFO_define = 1,
    DW_MACINFO_undef = 2,
    DW_MACINFO_start_file = 3,
    DW_MACINFO_end_file = 4,
    DW_MACINFO_vendor_ext = 255
  };

/* @@@ For use with GNU frame unwind information.  */

#define DW_EH_PE_absptr		0x00
#define DW_EH_PE_omit		0xff

#define DW_EH_PE_uleb128	0x01
#define DW_EH_PE_udata2		0x02
#define DW_EH_PE_udata4		0x03
#define DW_EH_PE_udata8		0x04
#define DW_EH_PE_sleb128	0x09
#define DW_EH_PE_sdata2		0x0A
#define DW_EH_PE_sdata4		0x0B
#define DW_EH_PE_sdata8		0x0C
#define DW_EH_PE_signed		0x08

#define DW_EH_PE_pcrel		0x10
#define DW_EH_PE_textrel	0x20
#define DW_EH_PE_datarel	0x30
#define DW_EH_PE_funcrel	0x40
#define DW_EH_PE_aligned	0x50

#define DW_EH_PE_indirect	0x80

#endif /* _ELF_DWARF2_H */
                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/                            0040755 0001750 0001750 00000000000 12612724206 023517  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/Availability.h              0100644 0001750 0001750 00000000126 12612724206 026276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //fake headers
#ifdef __APPLE__
#include_next <Availability.h>
#endif /* __APPLE__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/AvailabilityMacros.h        0100644 0001750 0001750 00000000115 12612724206 027441  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifdef __APPLE__
#include_next <AvailabilityMacros.h>
#endif /* __APPLE__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/ar.h                        0100644 0001750 0001750 00000005525 12612724206 024276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Hugh Smith at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ar.h	8.2 (Berkeley) 1/21/94
 */

#ifndef _AR_H_
#define	_AR_H_

/* Pre-4BSD archives had these magic numbers in them. */
#define	OARMAG1	0177555
#define	OARMAG2	0177545

#define	ARMAG		"!<arch>\n"	/* ar "magic number" */
#define	SARMAG		8		/* strlen(ARMAG); */

#define	AR_EFMT1	"#1/"		/* extended format #1 */

struct ar_hdr {
	char ar_name[16];		/* name */
	char ar_date[12];		/* modification time */
	char ar_uid[6];			/* user id */
	char ar_gid[6];			/* group id */
	char ar_mode[8];		/* octal file permissions */
	char ar_size[10];		/* size in bytes */
#define	ARFMAG	"`\n"
	char ar_fmag[2];		/* consistency check */
};

#endif /* !_AR_H_ */
                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/               0040755 0001750 0001750 00000000000 12612724206 026201  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/APPLE_LICENSE  0100644 0001750 0001750 00000046565 12612724206 030144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        APPLE PUBLIC SOURCE LICENSE
Version 2.0 - August 6, 2003

Please read this License carefully before downloading this software.
By downloading or using this software, you are agreeing to be bound by
the terms of this License. If you do not or cannot agree to the terms
of this License, please do not download or use the software.

1. General; Definitions. This License applies to any program or other
work which Apple Computer, Inc. ("Apple") makes publicly available and
which contains a notice placed by Apple identifying such program or
work as "Original Code" and stating that it is subject to the terms of
this Apple Public Source License version 2.0 ("License"). As used in
this License:

1.1 "Applicable Patent Rights" mean: (a) in the case where Apple is
the grantor of rights, (i) claims of patents that are now or hereafter
acquired, owned by or assigned to Apple and (ii) that cover subject
matter contained in the Original Code, but only to the extent
necessary to use, reproduce and/or distribute the Original Code
without infringement; and (b) in the case where You are the grantor of
rights, (i) claims of patents that are now or hereafter acquired,
owned by or assigned to You and (ii) that cover subject matter in Your
Modifications, taken alone or in combination with Original Code.

1.2 "Contributor" means any person or entity that creates or
contributes to the creation of Modifications.

1.3 "Covered Code" means the Original Code, Modifications, the
combination of Original Code and any Modifications, and/or any
respective portions thereof.

1.4 "Externally Deploy" means: (a) to sublicense, distribute or
otherwise make Covered Code available, directly or indirectly, to
anyone other than You; and/or (b) to use Covered Code, alone or as
part of a Larger Work, in any way to provide a service, including but
not limited to delivery of content, through electronic communication
with a client other than You.

1.5 "Larger Work" means a work which combines Covered Code or portions
thereof with code not governed by the terms of this License.

1.6 "Modifications" mean any addition to, deletion from, and/or change
to, the substance and/or structure of the Original Code, any previous
Modifications, the combination of Original Code and any previous
Modifications, and/or any respective portions thereof. When code is
released as a series of files, a Modification is: (a) any addition to
or deletion from the contents of a file containing Covered Code;
and/or (b) any new file or other representation of computer program
statements that contains any part of Covered Code.

1.7 "Original Code" means (a) the Source Code of a program or other
work as originally made available by Apple under this License,
including the Source Code of any updates or upgrades to such programs
or works made available by Apple under this License, and that has been
expressly identified by Apple as such in the header file(s) of such
work; and (b) the object code compiled from such Source Code and
originally made available by Apple under this License.

1.8 "Source Code" means the human readable form of a program or other
work that is suitable for making modifications to it, including all
modules it contains, plus any associated interface definition files,
scripts used to control compilation and installation of an executable
(object code).

1.9 "You" or "Your" means an individual or a legal entity exercising
rights under this License. For legal entities, "You" or "Your"
includes any entity which controls, is controlled by, or is under
common control with, You, where "control" means (a) the power, direct
or indirect, to cause the direction or management of such entity,
whether by contract or otherwise, or (b) ownership of fifty percent
(50%) or more of the outstanding shares or beneficial ownership of
such entity.

2. Permitted Uses; Conditions & Restrictions. Subject to the terms
and conditions of this License, Apple hereby grants You, effective on
the date You accept this License and download the Original Code, a
world-wide, royalty-free, non-exclusive license, to the extent of
Apple's Applicable Patent Rights and copyrights covering the Original
Code, to do the following:

2.1 Unmodified Code. You may use, reproduce, display, perform,
internally distribute within Your organization, and Externally Deploy
verbatim, unmodified copies of the Original Code, for commercial or
non-commercial purposes, provided that in each instance:

(a) You must retain and reproduce in all copies of Original Code the
copyright and other proprietary notices and disclaimers of Apple as
they appear in the Original Code, and keep intact all notices in the
Original Code that refer to this License; and

(b) You must include a copy of this License with every copy of Source
Code of Covered Code and documentation You distribute or Externally
Deploy, and You may not offer or impose any terms on such Source Code
that alter or restrict this License or the recipients' rights
hereunder, except as permitted under Section 6.

2.2 Modified Code. You may modify Covered Code and use, reproduce,
display, perform, internally distribute within Your organization, and
Externally Deploy Your Modifications and Covered Code, for commercial
or non-commercial purposes, provided that in each instance You also
meet all of these conditions:

(a) You must satisfy all the conditions of Section 2.1 with respect to
the Source Code of the Covered Code;

(b) You must duplicate, to the extent it does not already exist, the
notice in Exhibit A in each file of the Source Code of all Your
Modifications, and cause the modified files to carry prominent notices
stating that You changed the files and the date of any change; and

(c) If You Externally Deploy Your Modifications, You must make
Source Code of all Your Externally Deployed Modifications either
available to those to whom You have Externally Deployed Your
Modifications, or publicly available. Source Code of Your Externally
Deployed Modifications must be released under the terms set forth in
this License, including the license grants set forth in Section 3
below, for as long as you Externally Deploy the Covered Code or twelve
(12) months from the date of initial External Deployment, whichever is
longer. You should preferably distribute the Source Code of Your
Externally Deployed Modifications electronically (e.g. download from a
web site).

2.3 Distribution of Executable Versions. In addition, if You
Externally Deploy Covered Code (Original Code and/or Modifications) in
object code, executable form only, You must include a prominent
notice, in the code itself as well as in related documentation,
stating that Source Code of the Covered Code is available under the
terms of this License with information on how and where to obtain such
Source Code.

2.4 Third Party Rights. You expressly acknowledge and agree that
although Apple and each Contributor grants the licenses to their
respective portions of the Covered Code set forth herein, no
assurances are provided by Apple or any Contributor that the Covered
Code does not infringe the patent or other intellectual property
rights of any other entity. Apple and each Contributor disclaim any
liability to You for claims brought by any other entity based on
infringement of intellectual property rights or otherwise. As a
condition to exercising the rights and licenses granted hereunder, You
hereby assume sole responsibility to secure any other intellectual
property rights needed, if any. For example, if a third party patent
license is required to allow You to distribute the Covered Code, it is
Your responsibility to acquire that license before distributing the
Covered Code.

3. Your Grants. In consideration of, and as a condition to, the
licenses granted to You under this License, You hereby grant to any
person or entity receiving or distributing Covered Code under this
License a non-exclusive, royalty-free, perpetual, irrevocable license,
under Your Applicable Patent Rights and other intellectual property
rights (other than patent) owned or controlled by You, to use,
reproduce, display, perform, modify, sublicense, distribute and
Externally Deploy Your Modifications of the same scope and extent as
Apple's licenses under Sections 2.1 and 2.2 above.

4. Larger Works. You may create a Larger Work by combining Covered
Code with other code not governed by the terms of this License and
distribute the Larger Work as a single product. In each such instance,
You must make sure the requirements of this License are fulfilled for
the Covered Code or any portion thereof.

5. Limitations on Patent License. Except as expressly stated in
Section 2, no other patent rights, express or implied, are granted by
Apple herein. Modifications and/or Larger Works may require additional
patent licenses from Apple which Apple may grant in its sole
discretion.

6. Additional Terms. You may choose to offer, and to charge a fee for,
warranty, support, indemnity or liability obligations and/or other
rights consistent with the scope of the license granted herein
("Additional Terms") to one or more recipients of Covered Code.
However, You may do so only on Your own behalf and as Your sole
responsibility, and not on behalf of Apple or any Contributor. You
must obtain the recipient's agreement that any such Additional Terms
are offered by You alone, and You hereby agree to indemnify, defend
and hold Apple and every Contributor harmless for any liability
incurred by or claims asserted against Apple or such Contributor by
reason of any such Additional Terms.

7. Versions of the License. Apple may publish revised and/or new
versions of this License from time to time. Each version will be given
a distinguishing version number. Once Original Code has been published
under a particular version of this License, You may continue to use it
under the terms of that version. You may also choose to use such
Original Code under the terms of any subsequent version of this
License published by Apple. No one other than Apple has the right to
modify the terms applicable to Covered Code created under this
License.

8. NO WARRANTY OR SUPPORT. The Covered Code may contain in whole or in
part pre-release, untested, or not fully tested works. The Covered
Code may contain errors that could cause failures or loss of data, and
may be incomplete or contain inaccuracies. You expressly acknowledge
and agree that use of the Covered Code, or any portion thereof, is at
Your sole and entire risk. THE COVERED CODE IS PROVIDED "AS IS" AND
WITHOUT WARRANTY, UPGRADES OR SUPPORT OF ANY KIND AND APPLE AND
APPLE'S LICENSOR(S) (COLLECTIVELY REFERRED TO AS "APPLE" FOR THE
PURPOSES OF SECTIONS 8 AND 9) AND ALL CONTRIBUTORS EXPRESSLY DISCLAIM
ALL WARRANTIES AND/OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES AND/OR CONDITIONS OF
MERCHANTABILITY, OF SATISFACTORY QUALITY, OF FITNESS FOR A PARTICULAR
PURPOSE, OF ACCURACY, OF QUIET ENJOYMENT, AND NONINFRINGEMENT OF THIRD
PARTY RIGHTS. APPLE AND EACH CONTRIBUTOR DOES NOT WARRANT AGAINST
INTERFERENCE WITH YOUR ENJOYMENT OF THE COVERED CODE, THAT THE
FUNCTIONS CONTAINED IN THE COVERED CODE WILL MEET YOUR REQUIREMENTS,
THAT THE OPERATION OF THE COVERED CODE WILL BE UNINTERRUPTED OR
ERROR-FREE, OR THAT DEFECTS IN THE COVERED CODE WILL BE CORRECTED. NO
ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE, AN APPLE
AUTHORIZED REPRESENTATIVE OR ANY CONTRIBUTOR SHALL CREATE A WARRANTY.
You acknowledge that the Covered Code is not intended for use in the
operation of nuclear facilities, aircraft navigation, communication
systems, or air traffic control machines in which case the failure of
the Covered Code could lead to death, personal injury, or severe
physical or environmental damage.

9. LIMITATION OF LIABILITY. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO
EVENT SHALL APPLE OR ANY CONTRIBUTOR BE LIABLE FOR ANY INCIDENTAL,
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR RELATING
TO THIS LICENSE OR YOUR USE OR INABILITY TO USE THE COVERED CODE, OR
ANY PORTION THEREOF, WHETHER UNDER A THEORY OF CONTRACT, WARRANTY,
TORT (INCLUDING NEGLIGENCE), PRODUCTS LIABILITY OR OTHERWISE, EVEN IF
APPLE OR SUCH CONTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES AND NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY
REMEDY. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OF LIABILITY OF
INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS LIMITATION MAY NOT APPLY
TO YOU. In no event shall Apple's total liability to You for all
damages (other than as may be required by applicable law) under this
License exceed the amount of fifty dollars ($50.00).

10. Trademarks. This License does not grant any rights to use the
trademarks or trade names "Apple", "Apple Computer", "Mac", "Mac OS",
"QuickTime", "QuickTime Streaming Server" or any other trademarks,
service marks, logos or trade names belonging to Apple (collectively
"Apple Marks") or to any trademark, service mark, logo or trade name
belonging to any Contributor. You agree not to use any Apple Marks in
or as part of the name of products derived from the Original Code or
to endorse or promote products derived from the Original Code other
than as expressly permitted by and in strict compliance at all times
with Apple's third party trademark usage guidelines which are posted
at http://www.apple.com/legal/guidelinesfor3rdparties.html.

11. Ownership. Subject to the licenses granted under this License,
each Contributor retains all rights, title and interest in and to any
Modifications made by such Contributor. Apple retains all rights,
title and interest in and to the Original Code and any Modifications
made by or on behalf of Apple ("Apple Modifications"), and such Apple
Modifications will not be automatically subject to this License. Apple
may, at its sole discretion, choose to license such Apple
Modifications under this License, or on different terms from those
contained in this License or may choose not to license them at all.

12. Termination.

12.1 Termination. This License and the rights granted hereunder will
terminate:

(a) automatically without notice from Apple if You fail to comply with
any term(s) of this License and fail to cure such breach within 30
days of becoming aware of such breach;

(b) immediately in the event of the circumstances described in Section
13.5(b); or

(c) automatically without notice from Apple if You, at any time during
the term of this License, commence an action for patent infringement
against Apple; provided that Apple did not first commence
an action for patent infringement against You in that instance.

12.2 Effect of Termination. Upon termination, You agree to immediately
stop any further use, reproduction, modification, sublicensing and
distribution of the Covered Code. All sublicenses to the Covered Code
which have been properly granted prior to termination shall survive
any termination of this License. Provisions which, by their nature,
should remain in effect beyond the termination of this License shall
survive, including but not limited to Sections 3, 5, 8, 9, 10, 11,
12.2 and 13. No party will be liable to any other for compensation,
indemnity or damages of any sort solely as a result of terminating
this License in accordance with its terms, and termination of this
License will be without prejudice to any other right or remedy of
any party.

13. Miscellaneous.

13.1 Government End Users. The Covered Code is a "commercial item" as
defined in FAR 2.101. Government software and technical data rights in
the Covered Code include only those rights customarily provided to the
public as defined in this License. This customary commercial license
in technical data and software is provided in accordance with FAR
12.211 (Technical Data) and 12.212 (Computer Software) and, for
Department of Defense purchases, DFAR 252.227-7015 (Technical Data --
Commercial Items) and 227.7202-3 (Rights in Commercial Computer
Software or Computer Software Documentation). Accordingly, all U.S.
Government End Users acquire Covered Code with only those rights set
forth herein.

13.2 Relationship of Parties. This License will not be construed as
creating an agency, partnership, joint venture or any other form of
legal association between or among You, Apple or any Contributor, and
You will not represent to the contrary, whether expressly, by
implication, appearance or otherwise.

13.3 Independent Development. Nothing in this License will impair
Apple's right to acquire, license, develop, have others develop for
it, market and/or distribute technology or products that perform the
same or similar functions as, or otherwise compete with,
Modifications, Larger Works, technology or products that You may
develop, produce, market or distribute.

13.4 Waiver; Construction. Failure by Apple or any Contributor to
enforce any provision of this License will not be deemed a waiver of
future enforcement of that or any other provision. Any law or
regulation which provides that the language of a contract shall be
construed against the drafter will not apply to this License.

13.5 Severability. (a) If for any reason a court of competent
jurisdiction finds any provision of this License, or portion thereof,
to be unenforceable, that provision of the License will be enforced to
the maximum extent permissible so as to effect the economic benefits
and intent of the parties, and the remainder of this License will
continue in full force and effect. (b) Notwithstanding the foregoing,
if applicable law prohibits or restricts You from fully and/or
specifically complying with Sections 2 and/or 3 or prevents the
enforceability of either of those Sections, this License will
immediately terminate and You must immediately discontinue any use of
the Covered Code and destroy all copies of it that are in your
possession or control.

13.6 Dispute Resolution. Any litigation or other dispute resolution
between You and Apple relating to this License shall take place in the
Northern District of California, and You and Apple hereby consent to
the personal jurisdiction of, and venue in, the state and federal
courts within that District with respect to this License. The
application of the United Nations Convention on Contracts for the
International Sale of Goods is expressly excluded.

13.7 Entire Agreement; Governing Law. This License constitutes the
entire agreement between the parties with respect to the subject
matter hereof. This License shall be governed by the laws of the
United States and the State of California, except that body of
California law concerning conflicts of law.

Where You are located in the province of Quebec, Canada, the following
clause applies: The parties hereby confirm that they have requested
that this License and all related documents be drafted in English. Les
parties ont exige que le present contrat et tous les documents
connexes soient rediges en anglais.

EXHIBIT A.

"Portions Copyright (c) 1999-2003 Apple Computer, Inc. All Rights
Reserved.

This file contains Original Code and/or Modifications of Original Code
as defined in and that are subject to the Apple Public Source License
Version 2.0 (the 'License'). You may not use this file except in
compliance with the License. Please obtain a copy of the License at
http://www.opensource.apple.com/apsl/ and read it before using this
file.

The Original Code and all software distributed under the License are
distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
Please see the License for the specific language governing rights and
limitations under the License."
                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/alignment.h    0100644 0001750 0001750 00000002453 12612724206 030331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1996 NeXT Software, Inc.
 *
 * Natural alignment of shorts and longs.
 *
 * HISTORY
 *
 * 2 Sept 1992 Brian Raymor at NeXT
 *	Moved over to architecture.
 * 18 August 1992 Jack Greenfield at NeXT
 *	Created.
 */
 

#if defined (__i386__)
#include "architecture/i386/alignment.h"
#else
#error architecture not supported
#endif


                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/byte_order.h   0100644 0001750 0001750 00000017544 12612724206 030520  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Byte ordering conversion.
 *
 */

#ifndef	_ARCHITECTURE_BYTE_ORDER_H_
#define _ARCHITECTURE_BYTE_ORDER_H_

/*
 * Please note that the byte ordering functions in this file are deprecated.
 * A replacement API exists in libkern/OSByteOrder.h
 */

#include <libkern/OSByteOrder.h>

typedef unsigned long NXSwappedFloat;
typedef unsigned long long NXSwappedDouble;

static __inline__ __attribute__((deprecated))
unsigned short 
NXSwapShort(
    unsigned short inv
)
{
    return (unsigned short)OSSwapInt16((uint16_t)inv);
}

static __inline__ __attribute__((deprecated))
unsigned int
NXSwapInt(
    unsigned int inv
)
{
    return (unsigned int)OSSwapInt32((uint32_t)inv);
}

static __inline__ __attribute__((deprecated))
unsigned long
NXSwapLong(
    unsigned long inv
)
{
    return (unsigned long)OSSwapInt32((uint32_t)inv);
}

static __inline__ __attribute__((deprecated))
unsigned long long
NXSwapLongLong(
    unsigned long long inv
)
{
    return (unsigned long long)OSSwapInt64((uint64_t)inv);
}

static __inline__ __attribute__((deprecated))
NXSwappedFloat
NXConvertHostFloatToSwapped(float x)
{
    union fconv {
        float number;
        NXSwappedFloat sf;
    } u;
    u.number = x;
    return u.sf;
}

static __inline__ __attribute__((deprecated))
float
NXConvertSwappedFloatToHost(NXSwappedFloat x)
{
    union fconv {
        float number;
        NXSwappedFloat sf;
    } u;
    u.sf = x;
    return u.number;
}

static __inline__ __attribute__((deprecated))
NXSwappedDouble
NXConvertHostDoubleToSwapped(double x)
{
    union dconv {
        double number;
        NXSwappedDouble sd;
    } u;
    u.number = x;
    return u.sd;
}

static __inline__ __attribute__((deprecated))
double
NXConvertSwappedDoubleToHost(NXSwappedDouble x)
{
    union dconv {
        double number;
        NXSwappedDouble sd;
    } u;
    u.sd = x;
    return u.number;
}

static __inline__ __attribute__((deprecated))
NXSwappedFloat
NXSwapFloat(NXSwappedFloat x)
{ 
    return (NXSwappedFloat)OSSwapInt32((uint32_t)x);  
}

static __inline__ __attribute__((deprecated))
NXSwappedDouble   
NXSwapDouble(NXSwappedDouble x)
{  
    return (NXSwappedDouble)OSSwapInt64((uint64_t)x);
}

/*
 * Identify the byte order
 * of the current host.
 */

enum NXByteOrder {
    NX_UnknownByteOrder,
    NX_LittleEndian,
    NX_BigEndian
};

static __inline__
enum NXByteOrder
NXHostByteOrder(void)
{
#if defined(__LITTLE_ENDIAN__)
    return NX_LittleEndian;
#elif defined(__BIG_ENDIAN__)
    return NX_BigEndian;
#else
    return NX_UnknownByteOrder;
#endif
}

static __inline__ __attribute__((deprecated))
unsigned short
NXSwapBigShortToHost(
    unsigned short	x
)
{
    return (unsigned short)OSSwapBigToHostInt16((uint16_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned int
NXSwapBigIntToHost(
    unsigned int	x
)
{
    return (unsigned int)OSSwapBigToHostInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long
NXSwapBigLongToHost(
    unsigned long	x
)
{
    return (unsigned long)OSSwapBigToHostInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long long
NXSwapBigLongLongToHost(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapBigToHostInt64((uint64_t)x);
}

static __inline__ __attribute__((deprecated))
double
NXSwapBigDoubleToHost(
    NXSwappedDouble	x
)
{
    return NXConvertSwappedDoubleToHost((NXSwappedDouble)OSSwapBigToHostInt64((uint64_t)x));
}

static __inline__ __attribute__((deprecated))
float
NXSwapBigFloatToHost(
    NXSwappedFloat	x
)
{
    return NXConvertSwappedFloatToHost((NXSwappedFloat)OSSwapBigToHostInt32((uint32_t)x));
}

static __inline__ __attribute__((deprecated))
unsigned short
NXSwapHostShortToBig(
    unsigned short	x
)
{
    return (unsigned short)OSSwapHostToBigInt16((uint16_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned int
NXSwapHostIntToBig(
    unsigned int	x
)
{
    return (unsigned int)OSSwapHostToBigInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long
NXSwapHostLongToBig(
    unsigned long	x
)
{
    return (unsigned long)OSSwapHostToBigInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long long
NXSwapHostLongLongToBig(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapHostToBigInt64((uint64_t)x);
}

static __inline__ __attribute__((deprecated))
NXSwappedDouble
NXSwapHostDoubleToBig(
    double	x
)
{
    return (NXSwappedDouble)OSSwapHostToBigInt64((uint64_t)NXConvertHostDoubleToSwapped(x));
}

static __inline__ __attribute__((deprecated))
NXSwappedFloat
NXSwapHostFloatToBig(
    float	x
)
{
    return (NXSwappedFloat)OSSwapHostToBigInt32((uint32_t)NXConvertHostFloatToSwapped(x));
}

static __inline__ __attribute__((deprecated))
unsigned short
NXSwapLittleShortToHost(
    unsigned short	x
)
{
    return (unsigned short)OSSwapLittleToHostInt16((uint16_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned int
NXSwapLittleIntToHost(
    unsigned int	x
)
{
    return (unsigned int)OSSwapLittleToHostInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long
NXSwapLittleLongToHost(
    unsigned long	x
)
{
    return (unsigned long)OSSwapLittleToHostInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long long
NXSwapLittleLongLongToHost(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapLittleToHostInt64((uint64_t)x);
}

static __inline__ __attribute__((deprecated))
double
NXSwapLittleDoubleToHost(
    NXSwappedDouble	x
)
{
    return NXConvertSwappedDoubleToHost((NXSwappedDouble)OSSwapLittleToHostInt64((uint64_t)x));
}

static __inline__ __attribute__((deprecated))
float
NXSwapLittleFloatToHost(
    NXSwappedFloat	x
)
{
    return NXConvertSwappedFloatToHost((NXSwappedFloat)OSSwapLittleToHostInt32((uint32_t)x));
}

static __inline__ __attribute__((deprecated))
unsigned short
NXSwapHostShortToLittle(
    unsigned short	x
)
{
    return (unsigned short)OSSwapHostToLittleInt16((uint16_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned int
NXSwapHostIntToLittle(
    unsigned int	x
)
{
    return (unsigned int)OSSwapHostToLittleInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long
NXSwapHostLongToLittle(
    unsigned long	x
)
{
    return (unsigned long)OSSwapHostToLittleInt32((uint32_t)x);
}

static __inline__ __attribute__((deprecated))
unsigned long long
NXSwapHostLongLongToLittle(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapHostToLittleInt64((uint64_t)x);
}

static __inline__ __attribute__((deprecated))
NXSwappedDouble
NXSwapHostDoubleToLittle(
    double	x
)
{
    return (NXSwappedDouble)OSSwapHostToLittleInt64((uint64_t)NXConvertHostDoubleToSwapped(x));
}

static __inline__ __attribute__((deprecated))
NXSwappedFloat
NXSwapHostFloatToLittle(
    float	x
)
{
    return (NXSwappedFloat)OSSwapHostToLittleInt32((uint32_t)NXConvertHostFloatToSwapped(x));
}

#endif	/* _ARCHITECTURE_BYTE_ORDER_H_ */
                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/          0040755 0001750 0001750 00000000000 12612724206 026672  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        alignment.h                                                                                         0100644 0001750 0001750 00000003474 12612724206 030747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386                                                                              /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Natural alignment of shorts and longs (for i386)
 *
 * HISTORY
 *
 * 2 Sept 1992 Brian Raymor at NeXT
 *      Moved over to architecture.
 * 18 August 1992 Jack Greenfield at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_ALIGNMENT_H_
#define _ARCH_I386_ALIGNMENT_H_

/*
 * NOP
 */
__inline__ static unsigned short
get_align_short(void *ivalue)
{
    return *((unsigned short *) ivalue);
}

__inline__ static unsigned short 
put_align_short(unsigned short ivalue, void *ovalue)
{
    return *((unsigned short *) ovalue) = ivalue;
}

/*
 * NOP
 */
__inline__ static unsigned long
get_align_long(void *ivalue)
{
    return *((unsigned long *) ivalue);
}

__inline__ static unsigned long 
put_align_long(unsigned long ivalue, void *ovalue)
{
    return *((unsigned long *) ovalue) = ivalue;
}

#endif	/* _ARCH_I386_ALIGNMENT_H_ */
                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/asm_help.h0100644 0001750 0001750 00000021705 12612724206 030635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/i386/asm_help.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *	Modified for i386 by: Bruce Martin, NeXT Computer, Inc.
 *
 *	This header file defines macros useful when writing assembly code
 *	for the Intel i386 family processors.
 *
 * HISTORY
 * 10-Mar-92  Bruce Martin (bmartin@next.com)
 *	Adapted to i386
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef	_ARCH_I386_ASM_HELP_H_
#define	_ARCH_I386_ASM_HELP_H_

#include	<architecture/i386/reg_help.h>


#ifdef	__ASSEMBLER__

#define ALIGN						\
	.align	2, 0x90

#define	ROUND_TO_STACK(len)				\
	(((len) + STACK_INCR - 1) / STACK_INCR * STACK_INCR)

#ifdef notdef
#if defined(__i386__)
#define CALL_MCOUNT						\
	pushl	%ebp						;\
	movl	%esp, %ebp					;\
	.data							;\
	1: .long 0						;\
	.text							;\
	lea 9b,%edx						;\
	call mcount						;\
	popl	%ebp						;
#elif defined(__x86_64__)
#define CALL_MCOUNT						\
	pushq	%rbp						;\
	movq	%rsp, %rbp					;\
	.data							;\
	1: .quad 0						;\
	.text							;\
	lea 9b,%r13						;\
	call mcount						;\
	popq	%rbp					;
#endif
#else
#define CALL_MCOUNT
#endif

/*
 * Prologue for functions that may call other functions.  Saves
 * registers and sets up a C frame.
 */
#if defined(__i386__)
#define NESTED_FUNCTION_PROLOGUE(localvarsize)			\
	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
	.set	L__nested_function, 1				;\
	CALL_MCOUNT						\
	.if L__framesize						;\
	  pushl	%ebp						;\
	  movl	%esp, %ebp					;\
	  subl	$L__framesize, %esp				;\
	.endif							;\
	pushl	%edi						;\
	pushl	%esi						;\
	pushl	%ebx
#elif defined(__x86_64__)
#define NESTED_FUNCTION_PROLOGUE(localvarsize)			\
	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
	.set	L__nested_function, 1				;\
	CALL_MCOUNT						\
	.if L__framesize						;\
	  pushq	%rbp						;\
	  movq	%rsp, %rbp					;\
	  subq	$L__framesize, %rsp				;\
	.endif							;
#endif

/*
 * Prologue for functions that do not call other functions.  Does not
 * save registers (this is the functions responsibility).  Does set
 * up a C frame.
 */
#if defined(__i386__)
#define LEAF_FUNCTION_PROLOGUE(localvarsize)			\
	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
	.set	L__nested_function, 0				;\
	CALL_MCOUNT						\
	.if L__framesize						;\
	  pushl	%ebp						;\
	  movl	%esp, %ebp					;\
	  subl	$L__framesize, %esp				;\
	.endif
#elif defined(__x86_64__)
#define LEAF_FUNCTION_PROLOGUE(localvarsize)			\
	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
	.set	L__nested_function, 0				;\
	CALL_MCOUNT						\
	.if L__framesize						;\
	  pushq	%rbp						;\
	  movq	%rsp, %rbp					;\
	  subq	$L__framesize, %rsp				;\
	.endif
#endif

/*
 * Epilogue for any function.
 *
 * We assume that all Leaf functions will be responsible for saving any
 * local registers they clobber.
 */
#if defined(__i386__)
#define FUNCTION_EPILOGUE					\
	.if L__nested_function					;\
	  popl	%ebx						;\
	  popl	%esi						;\
	  popl	%edi						;\
	.endif							;\
	.if L__framesize						;\
	  movl	%ebp, %esp					;\
	  popl	%ebp						;\
	.endif							;\
	ret
#elif defined(__x86_64__)
#define FUNCTION_EPILOGUE					\
	.if L__framesize						;\
	  movq	%rbp, %rsp					;\
	  popq	%rbp						;\
	.endif							;\
	ret
#endif

/*
 * Macros for declaring procedures
 *
 * Use of these macros allows ctags to have a predictable way
 * to find various types of declarations.  They also simplify
 * inserting appropriate symbol table information.
 *
 * NOTE: these simple stubs will be replaced with more
 * complicated versions once we know what the linker and gdb
 * will require as far as register use masks and frame declarations.
 * These macros may also be ifdef'ed in the future to contain profiling
 * code.
 *
 */

/*
 * TEXT -- declare start of text segment
 */
#define	TEXT						\
	.text

/*
 * DATA -- declare start of data segment
 */
#define DATA						\
	.data

/*
 * LEAF -- declare global leaf procedure
 * NOTE: Control SHOULD NOT FLOW into a LEAF!  A LEAF should only
 * be jumped to.  (A leaf may do an align.)  Use a LABEL() if you
 * need control to flow into the label.
 */
#define	LEAF(name, localvarsize)			\
	.globl	name					;\
	ALIGN						;\
name:							;\
	LEAF_FUNCTION_PROLOGUE(localvarsize)

/*
 * X_LEAF -- declare alternate global label for leaf
 */
#define	X_LEAF(name, value)				\
	.globl	name					;\
	.set	name,value

/*
 * P_LEAF -- declare private leaf procedure
 */
#define	P_LEAF(name, localvarsize)			\
	ALIGN						;\
name:							;\
	LEAF_FUNCTION_PROLOGUE(localvarsize)

/*
 * LABEL -- declare a global code label
 * MUST be used (rather than LEAF, NESTED, etc) if control
 * "flows into" the label.
 */
#define	LABEL(name)					\
	.globl	name					;\
name:

/*
 * NESTED -- declare procedure that invokes other procedures
 */
#define	NESTED(name, localvarsize)			\
	.globl	name					;\
	ALIGN						;\
name:							;\
	NESTED_FUNCTION_PROLOGUE(localvarsize)

/*
 * X_NESTED -- declare alternate global label for nested proc
 */
#define	X_NESTED(name, value)				\
	.globl	name					;\
	.set	name,value

/*
 * P_NESTED -- declare private nested procedure
 */
#define	P_NESTED(name, localvarsize)			\
	ALIGN						;\
name:							;\
	NESTED_FUNCTION_PROLOGUE(localvarsize)

/*
 * END -- mark end of procedure
 */
#define	END(name)					\
	FUNCTION_EPILOGUE


/*
 * Storage definition macros
 * The main purpose of these is to allow an easy handle for ctags
 */

/*
 * IMPORT -- import symbol
 */
#define	IMPORT(name)					\
	.reference	name

/*
 * ABS -- declare global absolute symbol
 */
#define	ABS(name, value)				\
	.globl	name					;\
	.set	name,value

/*
 * P_ABS -- declare private absolute symbol
 */
#define	P_ABS(name, value)				\
	.set	name,value

/*
 * EXPORT -- declare global label for data
 */
#define	EXPORT(name)					\
	.globl	name					;\
name:

/*
 * BSS -- declare global zero'ed storage
 */
#define	BSS(name,size)					\
	.comm	name,size


/*
 * P_BSS -- declare private zero'ed storage
 */
#define	P_BSS(name,size)				\
	.lcomm	name,size

/*
 * dynamic/PIC macros for routines which reference external symbols
 */

#if defined(__DYNAMIC__)
#if defined(__i386__)
#define PICIFY(var)					\
	call	1f					; \
1:							; \
	popl	%edx					; \
	movl	L ## var ## __non_lazy_ptr-1b(%edx),%edx
#elif defined(__x86_64__)
#define PICIFY(var)					\
	movq	var@GOTPCREL(%rip),%r11
#endif

#if defined(__i386__)
#define CALL_EXTERN_AGAIN(func)	\
	PICIFY(func)		; \
	call	*%edx
#elif defined(__x86_64__)
#define CALL_EXTERN_AGAIN(func)	\
	call	func
#endif

#if defined(__i386__)
#define NON_LAZY_STUB(var)	\
.section __IMPORT,__pointers,non_lazy_symbol_pointers	; \
L ## var ## __non_lazy_ptr:	; \
.indirect_symbol var		; \
.long 0				; \
.text
#elif defined(__x86_64__)
#define NON_LAZY_STUB(var)	
#endif

#define CALL_EXTERN(func)	\
	CALL_EXTERN_AGAIN(func)	; \
	NON_LAZY_STUB(func)

#if defined(__i386__)
#define BRANCH_EXTERN(func)	\
	PICIFY(func)		; \
	jmp	*%edx		; \
	NON_LAZY_STUB(func)
#elif defined(__x86_64__)
#define BRANCH_EXTERN(func)	\
	jmp	func
#endif

#if defined(__i386__)
#define PUSH_EXTERN(var)	\
	PICIFY(var)		; \
	movl	(%edx),%edx	; \
	pushl	%edx		; \
	NON_LAZY_STUB(var)
#endif

#if defined(__i386__)
#define REG_TO_EXTERN(reg, var)	\
	PICIFY(var)		; \
	movl	reg, (%edx)	; \
	NON_LAZY_STUB(var)
#elif defined(__x86_64__)
#define REG_TO_EXTERN(reg, var)	\
	PICIFY(var)		; \
	mov		reg, (%r11)
#endif

#if defined(__i386__)
#define EXTERN_TO_REG(var, reg)				\
	call	1f					; \
1:							; \
	popl	%edx					; \
	movl	L ## var ##__non_lazy_ptr-1b(%edx),reg	; \
	NON_LAZY_STUB(var)
#elif defined(__x86_64__)
#define EXTERN_TO_REG(var, reg)				\
	PICIFY(var)		; \
	mov    (%r11), reg
#endif

#else
#define BRANCH_EXTERN(func)	jmp	func
#define PUSH_EXTERN(var)	push	var
#define CALL_EXTERN(func)	call	func
#define CALL_EXTERN_AGAIN(func)	call	func
#if defined(__i386__)
#define REG_TO_EXTERN(reg, var)	mov	reg, var
#define EXTERN_TO_REG(var, reg)	mov	$ ## var, reg
#elif defined(__x86_64__)
#define REG_TO_EXTERN(reg, var)	mov	reg, var ## (%rip)
#define EXTERN_TO_REG(var, reg)	mov	var ## (%rip), reg
#endif
#endif

#endif	/* __ASSEMBLER__ */

#endif	/* _ARCH_I386_ASM_HELP_H_ */
                                                           byte_order.h                                                                                        0100644 0001750 0001750 00000002221 12612724206 031114  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386                                                                              /*
 * Copyright (c) 1999-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _ARCH_I386_BYTE_ORDER_H_
#define _ARCH_I386_BYTE_ORDER_H_

/*
 * Maintain source compatibility
 */

#include <architecture/byte_order.h>

#endif	/* _ARCH_I386_BYTE_ORDER_H_ */
                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/cpu.h     0100644 0001750 0001750 00000003104 12612724206 027625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Special processor registers.
 *
 * HISTORY
 *
 * 5 April 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_CPU_H_
#define _ARCH_I386_CPU_H_

/*
 * Control register 0
 */
 
typedef struct _cr0 {
    unsigned int	pe	:1,
    			mp	:1,
			em	:1,
			ts	:1,
				:1,
			ne	:1,
				:10,
			wp	:1,
				:1,
			am	:1,
				:10,
			nw	:1,
			cd	:1,
			pg	:1;
} cr0_t;

/*
 * Debugging register 6
 */

typedef struct _dr6 {
    unsigned int	b0	:1,
    			b1	:1,
			b2	:1,
			b3	:1,
				:9,
			bd	:1,
			bs	:1,
			bt	:1,
				:16;
} dr6_t;

#endif	/* _ARCH_I386_CPU_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/desc.h    0100644 0001750 0001750 00000006104 12612724206 027757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Segment descriptors.
 *
 * HISTORY
 *
 * 29 March 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_DESC_H_
#define _ARCH_I386_DESC_H_

/*
 * Code segment descriptor.
 */

typedef struct code_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_CODE_EXEC	0x18
#define DESC_CODE_READ	0x1a
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:2,
			opsz	:1,
#define DESC_CODE_16B	0
#define DESC_CODE_32B	1
			granular:1;
#define DESC_GRAN_BYTE	0
#define DESC_GRAN_PAGE	1
    unsigned char	base24;
} code_desc_t;
 
/*
 * Data segment descriptor.
 */

typedef struct data_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_DATA_RONLY	0x10
#define DESC_DATA_WRITE	0x12
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:2,
			stksz	:1,
#define DESC_DATA_16B	0
#define DESC_DATA_32B	1
			granular:1;
    unsigned char	base24;
} data_desc_t;

/*
 * LDT segment descriptor.
 */

typedef struct ldt_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_LDT	0x02
				:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} ldt_desc_t;

#include <architecture/i386/sel.h>

/*
 * Call gate descriptor.
 */
 
typedef struct call_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int	argcnt	:5,
    				:3,
			type	:5,
#define DESC_CALL_GATE	0x0c
			dpl	:2,
			present	:1,
			offset16:16;
} call_gate_t;

/*
 * Trap gate descriptor.
 */
 
typedef struct trap_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
#define DESC_TRAP_GATE	0x0f
			dpl	:2,
			present	:1,
			offset16:16;
} trap_gate_t;


/*
 * Interrupt gate descriptor.
 */
 
typedef struct intr_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
#define DESC_INTR_GATE	0x0e
			dpl	:2,
			present	:1,
			offset16:16;
} intr_gate_t;

#endif	/* _ARCH_I386_DESC_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/fpu.h     0100644 0001750 0001750 00000006737 12612724206 027647  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Floating Point unit.
 *
 * HISTORY
 *
 * 5 October 1992 ? at NeXT
 *	Added names to previously unamed fields in the mantissa.
 *
 * 5 April 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_FPU_H_
#define _ARCH_I386_FPU_H_

/*
 * Data register.
 */

typedef struct fp_data_reg {
    unsigned short		mant;
    unsigned short		mant1	:16,
				mant2	:16,
				mant3	:16;
    unsigned short		exp	:15,
			    	sign	:1;
} fp_data_reg_t;

/*
 * Data register stack.
 */

typedef struct fp_stack {
    fp_data_reg_t		ST[8];
} fp_stack_t;

/*
 * Register stack tag word.
 */

typedef struct fp_tag {
    unsigned short		tag0	:2,
    				tag1	:2,
				tag2	:2,
				tag3	:2,
    				tag4	:2,
				tag5	:2,
				tag6	:2,
				tag7	:2;
#define FP_TAG_VALID		0
#define FP_TAG_ZERO		1
#define FP_TAG_SPEC		2
#define FP_TAG_EMPTY		3
} fp_tag_t;

/*
 * Status word.
 */

typedef struct fp_status {
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
				stkflt	:1,
				errsumm	:1,
				c0	:1,
				c1	:1,
				c2	:1,
				tos	:3,
				c3	:1,
				busy	:1;
} fp_status_t;

/*
 * Control word.
 */

typedef struct fp_control {
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
					:2,
				pc	:2,
#define FP_PREC_24B		0
#define	FP_PREC_53B		2
#define FP_PREC_64B		3
				rc	:2,
#define FP_RND_NEAR		0
#define FP_RND_DOWN		1
#define FP_RND_UP		2
#define FP_CHOP			3
				/*inf*/	:1,
					:3;
} fp_control_t;

#include <architecture/i386/sel.h>

/*
 * Floating point 'environment'
 * used by FSTENV/FLDENV instructions.
 */

typedef struct fp_env {
    fp_control_t		control;
    unsigned short			:16;
    fp_status_t			status;
    unsigned short			:16;
    fp_tag_t			tag;
    unsigned short			:16;
    unsigned int		ip;
    sel_t			cs;
    unsigned short		opcode;
    unsigned int		dp;
    sel_t			ds;
    unsigned short			:16;
} fp_env_t;

/*
 * Floating point state
 * used by FSAVE/FRSTOR instructions.
 */
 
/*
 * To allow the the common idiom of:
 *     #define environ (*_NSGetEnviron())
 * to be used these fields were renamed.  Old code that that does
 * not use this idiom can use the old field names by defining
 * _ARCHITECTURE_I386_FPU_FPSTATE_LEGACY_FIELD_NAMES_ .
 */
typedef struct fp_state {
#if _ARCHITECTURE_I386_FPU_FPSTATE_LEGACY_FIELD_NAMES_
    fp_env_t			environ;
    fp_stack_t			stack;
#else
    fp_env_t			fp_environ;
    fp_stack_t			fp_stack;
#endif
} fp_state_t;

#endif	/* _ARCH_I386_FPU_H_ */
                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/frame.h   0100644 0001750 0001750 00000006223 12612724206 030135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Processor exception frame.
 *
 * HISTORY
 *
 * 31 August 1992 ? at NeXT
 *	Added v86 mode stuff.
 *
 * 8 June 1992 ? at NeXT
 *	Changed name of write field in err_code_t
 *	which collided with write() in shlib.
 *
 * 30 March 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_FRAME_H_
#define _ARCH_I386_FRAME_H_

/*
 * Format of the error code
 * generated by the hardware
 * for certain exceptions.
 */
 
typedef union err_code {
    struct err_code_normal {
	unsigned int	ext	:1,
			tbl	:2,
#define ERR_GDT		0
#define ERR_IDT		1
#define ERR_LDT		2
			index	:13,
				:16;
    } normal;
    struct err_code_pgfault {
	unsigned int	prot	:1,
			wrtflt	:1,
			user	:1,
				:29;
    } pgfault;
} err_code_t;

#include <architecture/i386/sel.h>

/*
 * The actual hardware exception frame
 * is variable in size.  An error code is
 * only pushed for certain exceptions.
 * Previous stack information is only
 * pushed for exceptions that cause a
 * change in privilege level.  The dpl
 * field of the saved CS selector can be
 * used to determine whether this is the
 * case.  If the interrupted task was
 * executing in v86 mode, then the data
 * segment registers are also present in
 * the exception frame (in addition to
 * previous stack information).  This
 * case can be determined by examining
 * eflags.
 */

typedef struct except_frame {
    err_code_t		err;
    unsigned int	eip;
    sel_t		cs;
    unsigned int		:0;
    unsigned int	eflags;
    unsigned int	esp;
    sel_t		ss;
    unsigned int		:0;
    unsigned short	v_es;
    unsigned int		:0;
    unsigned short	v_ds;
    unsigned int		:0;
    unsigned short	v_fs;
    unsigned int		:0;
    unsigned short	v_gs;
    unsigned int		:0;
} except_frame_t;

/*
 * Values in eflags.
 */

#define EFL_CF		0x00001
#define EFL_PF		0x00004
#define EFL_AF		0x00010
#define EFL_ZF		0x00040
#define EFL_SF		0x00080
#define EFL_TF		0x00100
#define EFL_IF		0x00200
#define EFL_DF		0x00400
#define EFL_OF		0x00800
#define EFL_IOPL	0x03000
#define EFL_NT		0x04000
#define EFL_RF		0x10000
#define EFL_VM		0x20000
#define EFL_AC		0x40000

#define EFL_CLR		0xfff88028
#define EFL_SET		0x00000002

#endif	/* _ARCH_I386_FRAME_H_ */
                                                                                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/io.h      0100644 0001750 0001750 00000002377 12612724206 027460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel 386 Family: IO space defines.
 *
 * HISTORY
 *
 * 11 August 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_IO_H_
#define _ARCH_I386_IO_H_

typedef unsigned short		io_addr_t;
typedef unsigned short		io_len_t;

#endif	/* _ARCH_I386_IO_H_ */
                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/pio.h     0100644 0001750 0001750 00000006146 12612724206 027636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/* 
 */
#ifndef _ARCH_I386_PIO_H_
#define _ARCH_I386_PIO_H_

typedef unsigned short i386_ioport_t;

#if defined(__GNUC__)
static __inline__ unsigned long	inl(
				i386_ioport_t port)
{
	unsigned long datum;
	__asm__ volatile("inl %w1, %0" : "=a" (datum) : "Nd" (port));
	return(datum);
}

static __inline__ unsigned short inw(
				i386_ioport_t port)
{
	unsigned short datum;
	__asm__ volatile("inw %w1, %w0" : "=a" (datum) : "Nd" (port));
	return(datum);
}

static __inline__ unsigned char inb(
				i386_ioport_t port)
{
	unsigned char datum;
	__asm__ volatile("inb %w1, %b0" : "=a" (datum) : "Nd" (port));
	return(datum);
}

static __inline__ void outl(
				i386_ioport_t port,
				unsigned long datum)
{
	__asm__ volatile("outl %0, %w1" : : "a" (datum), "Nd" (port));
}

static __inline__ void outw(
				i386_ioport_t port,
				unsigned short datum)
{
	__asm__ volatile("outw %w0, %w1" : : "a" (datum), "Nd" (port));
}

static __inline__ void outb(
				i386_ioport_t port,
				unsigned char datum)
{
	__asm__ volatile("outb %b0, %w1" : : "a" (datum), "Nd" (port));
}
#endif /* defined(__GNUC__) */
#endif /* _ARCH_I386_PIO_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/reg_help.h0100644 0001750 0001750 00000006334 12612724206 030633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/i386/reg_help.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *      Modified for i386 by: Bruce Martin, NeXT Computer, Inc.
 *
 *	This header file defines cpp macros useful for defining
 *	machine register and doing machine-level operations.
 *
 * HISTORY
 * 10-Mar-92  Bruce Martin (bmartin@next.com)
 *	Adapted to i386
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef	_ARCH_I386_REG_HELP_H_
#define	_ARCH_I386_REG_HELP_H_

/* Bitfield definition aid */
#define	BITS_WIDTH(msb, lsb)	((msb)-(lsb)+1)
#define	BIT_WIDTH(pos)		(1)	/* mostly to record the position */

/* Mask creation */
#define	MKMASK(width, offset)	(((unsigned)-1)>>(32-(width))<<(offset))
#define	BITSMASK(msb, lsb)	MKMASK(BITS_WIDTH(msb, lsb), lsb & 0x1f)
#define	BITMASK(pos)		MKMASK(BIT_WIDTH(pos), pos & 0x1f)

/* Register addresses */
#if	__ASSEMBLER__
# define	REG_ADDR(type, addr)	(addr)
#else	/* __ASSEMBLER__ */
# define	REG_ADDR(type, addr)	(*(volatile type *)(addr))
#endif	/* __ASSEMBLER__ */

/* Cast a register to be an unsigned */
#define	CONTENTS(foo)	(*(unsigned *) &(foo))

/* Stack pointer must always be a multiple of 4 */
#define	STACK_INCR	4
#define	ROUND_FRAME(x)	((((unsigned)(x)) + STACK_INCR - 1) & ~(STACK_INCR-1))

/* STRINGIFY -- perform all possible substitutions, then stringify */
#define	__STR(x)	#x		/* just a helper macro */
#define	STRINGIFY(x)	__STR(x)

/*
 * REG_PAIR_DEF -- define a register pair
 * Register pairs are appropriately aligned to allow access via
 * ld.d and st.d.
 *
 * Usage:
 *	struct foo {
 *		REG_PAIR_DEF(
 *			bar_t *,	barp,
 *			afu_t,		afu
 *		);
 *	};
 *
 * Access to individual entries of the pair is via the REG_PAIR
 * macro (below).
 */
#define	REG_PAIR_DEF(type0, name0, type1, name1)		\
	struct {						\
		type0	name0 __attribute__(( aligned(8) ));	\
		type1	name1;					\
	} name0##_##name1

/*
 * REG_PAIR -- Macro to define names for accessing individual registers
 * of register pairs.
 *
 * Usage:
 *	arg0 is first element of pair
 *	arg1 is second element of pair
 *	arg2 is desired element of pair
 * eg:
 *	#define	foo_barp	REG_PAIR(barp, afu, afu)
 */
#define	REG_PAIR(name0, name1, the_name)			\
	name0##_##name1.the_name

#endif	/* _ARCH_I386_REG_HELP_H_ */
                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/sel.h     0100644 0001750 0001750 00000002640 12612724206 027625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Segment selector.
 *
 * HISTORY
 *
 * 29 March 1992 ? at NeXT
 *	Created.
 */

#ifndef	_ARCH_I386_SEL_H_
#define	_ARCH_I386_SEL_H_

/*
 * Segment selector.
 */

typedef struct sel {
    unsigned short	rpl	:2,
#define KERN_PRIV	0
#define USER_PRIV	3
			ti	:1,
#define SEL_GDT		0
#define SEL_LDT		1
			index	:13;
} sel_t;

#define NULL_SEL	((sel_t) { 0, 0, 0 } )

#endif	/* _ARCH_I386_SEL_H_ */
                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/table.h   0100644 0001750 0001750 00000004344 12612724206 030134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Descriptor tables.
 *
 * HISTORY
 *
 * 30 March 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_TABLE_H_
#define _ARCH_I386_TABLE_H_

#include <architecture/i386/desc.h>
#include <architecture/i386/tss.h>

/*
 * A totally generic descriptor
 * table entry.
 */

typedef union dt_entry {
    code_desc_t		code;
    data_desc_t		data;
    ldt_desc_t		ldt;
    tss_desc_t		task_state;
    call_gate_t		call_gate;
    trap_gate_t		trap_gate;
    intr_gate_t		intr_gate;
    task_gate_t		task_gate;
} dt_entry_t;

#define DESC_TBL_MAX	8192

/*
 * Global descriptor table.
 */

typedef union gdt_entry {
    code_desc_t		code;
    data_desc_t		data;
    ldt_desc_t		ldt;
    call_gate_t		call_gate;
    task_gate_t		task_gate;
    tss_desc_t		task_state;
} gdt_entry_t;

typedef gdt_entry_t	gdt_t;

/*
 * Interrupt descriptor table.
 */

typedef union idt_entry {
    trap_gate_t		trap_gate;
    intr_gate_t		intr_gate;
    task_gate_t		task_gate;
} idt_entry_t;

typedef idt_entry_t	idt_t;

/*
 * Local descriptor table.
 */

typedef union ldt_entry {
    code_desc_t		code;
    data_desc_t		data;
    call_gate_t		call_gate;
    task_gate_t		task_gate;
} ldt_entry_t;

typedef ldt_entry_t	ldt_t;

#endif	/* _ARCH_I386_TABLE_H_ */
                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/architecture/i386/tss.h     0100644 0001750 0001750 00000005164 12612724206 027657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Task State Segment.
 *
 * HISTORY
 *
 * 29 March 1992 ? at NeXT
 *	Created.
 */

#ifndef _ARCH_I386_TSS_H_
#define _ARCH_I386_TSS_H_

#include <architecture/i386/sel.h>

/*
 * Task State segment.
 */

typedef struct tss {
    sel_t		oldtss;
    unsigned int		:0;
    unsigned int	esp0;
    sel_t		ss0;
    unsigned int		:0;
    unsigned int	esp1;
    sel_t		ss1;
    unsigned int		:0;
    unsigned int	esp2;
    sel_t		ss2;
    unsigned int		:0;
    unsigned int	cr3;
    unsigned int	eip;
    unsigned int	eflags;
    unsigned int	eax;
    unsigned int	ecx;
    unsigned int	edx;
    unsigned int	ebx;
    unsigned int	esp;
    unsigned int	ebp;
    unsigned int	esi;
    unsigned int	edi;
    sel_t		es;
    unsigned int		:0;
    sel_t		cs;
    unsigned int		:0;
    sel_t		ss;
    unsigned int		:0;
    sel_t		ds;
    unsigned int		:0;
    sel_t		fs;
    unsigned int		:0;
    sel_t		gs;
    unsigned int		:0;
    sel_t		ldt;
    unsigned int		:0;
    unsigned int	t	:1,
    				:15,
			io_bmap	:16;
} tss_t;

#define TSS_SIZE(n)	(sizeof (struct tss) + (n))

/*
 * Task State segment descriptor.
 */

typedef struct tss_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_TSS	0x09
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} tss_desc_t;

/*
 * Task gate descriptor.
 */
 
typedef struct task_gate {
    unsigned short		:16;
    sel_t		tss;
    unsigned int		:8,
    			type	:5,
#define DESC_TASK_GATE	0x05
			dpl	:2,
			present	:1,
				:0;
} task_gate_t;

#endif	/* _ARCH_I386_TSS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/arm                         0120777 0001750 0001750 00000000000 12612724206 024710  2i386/                                                                                               ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/dlfcn.h                     0100644 0001750 0001750 00000000730 12612724206 024753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef __CCTOOLS_PORT_DLFCN_H__
#define __CCTOOLS_PORT_DLFCN_H__
#include_next <dlfcn.h>
#include <stdio.h> /* stderr */
#ifdef __CYGWIN__
typedef struct dl_info {
    const char  *dli_fname;
    void        *dli_fbase;
    const char  *dli_sname;
    void        *dli_saddr;
} Dl_info;

static inline int dladdr(void *addr, Dl_info *info)
{
    fprintf(stderr, "dladdr() not implemented\n");
    return 0;
}
#endif /* __CYGWIN__ */
#endif /* __CCTOOLS_PORT_DLFCN_H__ */
                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/extern.h                    0100644 0001750 0001750 00000000101 12612724206 025162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #define __private_extern__ __attribute__((visibility("hidden")))
                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/fcntl.h                     0100644 0001750 0001750 00000000125 12612724206 024771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include_next <fcntl.h>

#ifndef O_FSYNC
#define O_FSYNC O_SYNC /* Cygwin */
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/                       0040755 0001750 0001750 00000000000 12612724206 024210  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/_limits.h              0100644 0001750 0001750 00000002055 12612724206 026020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef	_I386__LIMITS_H_
#define	_I386__LIMITS_H_

#define	__DARWIN_CLK_TCK		100	/* ticks per second */

#endif	/* _I386__LIMITS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/_param.h               0100644 0001750 0001750 00000003740 12612724206 025621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _I386__PARAM_H_
#define _I386__PARAM_H_

#include <i386/_types.h>

/*
 * Round p (pointer or byte index) up to a correctly-aligned value for all
 * data types (int, long, ...).   The result is unsigned int and must be
 * cast to any desired pointer type.
 */
#define	__DARWIN_ALIGNBYTES	(sizeof(__darwin_size_t) - 1)
#define	__DARWIN_ALIGN(p)	((__darwin_size_t)((char *)(__darwin_size_t)(p) + __DARWIN_ALIGNBYTES) &~ __DARWIN_ALIGNBYTES)

#define      __DARWIN_ALIGNBYTES32     (sizeof(__uint32_t) - 1)
#define       __DARWIN_ALIGN32(p)       ((__darwin_size_t)((char *)(__darwin_size_t)(p) + __DARWIN_ALIGNBYTES32) &~ __DARWIN_ALIGNBYTES32)


#endif /* _I386__PARAM_H_ */
                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/_structs.h             0100644 0001750 0001750 00000007665 12612724206 026242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#include <sys/appleapiopts.h>

#ifdef __need_mcontext_t
#ifndef __need_struct_mcontext
#define __need_struct_mcontext
#endif /* __need_struct_mcontext */
#endif /* __need_mcontext_t */

#if defined(__need_struct_mcontext)
#include <mach/i386/_structs.h>
#endif /* __need_struct_mcontext */


#ifdef __need_struct_mcontext
#undef __need_struct_mcontext

#ifndef _STRUCT_MCONTEXT32
#if __DARWIN_UNIX03
#define	_STRUCT_MCONTEXT32	struct __darwin_mcontext32
_STRUCT_MCONTEXT32
{
	_STRUCT_X86_EXCEPTION_STATE32	__es;
	_STRUCT_X86_THREAD_STATE32	__ss;
	_STRUCT_X86_FLOAT_STATE32	__fs;
};

#define	_STRUCT_MCONTEXT_AVX32	struct __darwin_mcontext_avx32
_STRUCT_MCONTEXT_AVX32
{
	_STRUCT_X86_EXCEPTION_STATE32	__es;
	_STRUCT_X86_THREAD_STATE32	__ss;
	_STRUCT_X86_AVX_STATE32		__fs;
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_MCONTEXT32	struct mcontext32
_STRUCT_MCONTEXT32
{
	_STRUCT_X86_EXCEPTION_STATE32	es;
	_STRUCT_X86_THREAD_STATE32	ss;
	_STRUCT_X86_FLOAT_STATE32	fs;
};

#define	_STRUCT_MCONTEXT_AVX32	struct mcontext_avx32
_STRUCT_MCONTEXT_AVX32
{
	_STRUCT_X86_EXCEPTION_STATE32	es;
	_STRUCT_X86_THREAD_STATE32	ss;
	_STRUCT_X86_AVX_STATE32		fs;
};

#endif /* __DARWIN_UNIX03 */
#endif /* _STRUCT_MCONTEXT32 */

#ifndef _STRUCT_MCONTEXT64
#if __DARWIN_UNIX03
#define	_STRUCT_MCONTEXT64	struct __darwin_mcontext64
_STRUCT_MCONTEXT64
{
	_STRUCT_X86_EXCEPTION_STATE64	__es;
	_STRUCT_X86_THREAD_STATE64	__ss;
	_STRUCT_X86_FLOAT_STATE64	__fs;
};

#define	_STRUCT_MCONTEXT_AVX64	struct __darwin_mcontext_avx64
_STRUCT_MCONTEXT_AVX64
{
	_STRUCT_X86_EXCEPTION_STATE64	__es;
	_STRUCT_X86_THREAD_STATE64	__ss;
	_STRUCT_X86_AVX_STATE64		__fs;
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_MCONTEXT64	struct mcontext64
_STRUCT_MCONTEXT64
{
	_STRUCT_X86_EXCEPTION_STATE64	es;
	_STRUCT_X86_THREAD_STATE64	ss;
	_STRUCT_X86_FLOAT_STATE64	fs;
};

#define	_STRUCT_MCONTEXT_AVX64	struct mcontext_avx64
_STRUCT_MCONTEXT_AVX64
{
	_STRUCT_X86_EXCEPTION_STATE64	es;
	_STRUCT_X86_THREAD_STATE64	ss;
	_STRUCT_X86_AVX_STATE64		fs;
};

#endif /* __DARWIN_UNIX03 */
#endif /* _STRUCT_MCONTEXT64 */
#endif /* __need_struct_mcontext */

#ifdef __need_mcontext_t
#undef __need_mcontext_t
#ifndef _MCONTEXT_T
#define _MCONTEXT_T
#if defined(__LP64__)
typedef _STRUCT_MCONTEXT64	*mcontext_t;
#define _STRUCT_MCONTEXT _STRUCT_MCONTEXT64
#else
typedef _STRUCT_MCONTEXT32	*mcontext_t;
#define _STRUCT_MCONTEXT	_STRUCT_MCONTEXT32
#endif
#endif /* _MCONTEXT_T */
#endif /* __need_mcontext_t */

#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#ifndef I386_MCONTEXT_SIZE
#define I386_MCONTEXT_SIZE	sizeof(struct mcontext)	
#endif /* I386_MCONTEXT_SIZE */
#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/_types.h               0100644 0001750 0001750 00000012313 12612724206 025661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef	_BSD_I386__TYPES_H_
#define	_BSD_I386__TYPES_H_

/*
 * This header file contains integer types.  It's intended to also contain
 * flotaing point and other arithmetic types, as needed, later.
 */

/*
 * Silence old glibc -Wtypedef-redefinition warnings.
 * https://github.com/tpoechtrager/cctools-port/pull/8
 */
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wtypedef-redefinition"
#endif

#ifndef __CYGWIN__
#ifdef __GNUC__
typedef __signed char           __int8_t;
#else	/* !__GNUC__ */
typedef char                    __int8_t;
#endif	/* !__GNUC__ */
#endif  /* __CYGWIN__ */

typedef unsigned char           __uint8_t;
typedef short                   __int16_t;
typedef unsigned short          __uint16_t;
typedef int                     __int32_t;
typedef unsigned int            __uint32_t;

#ifdef __INT64_TYPE__
typedef __INT64_TYPE__          __int64_t;
typedef unsigned __INT64_TYPE__ __uint64_t;
#else
#if __SIZEOF_POINTER__ == 8 && !defined(__CYGWIN__)
typedef long int                __int64_t;
typedef unsigned long int       __uint64_t;
#else
typedef long long int           __int64_t;
typedef unsigned long long int  __uint64_t;
#endif
#endif

typedef long                    __darwin_intptr_t;
#ifdef __CYGWIN__
typedef unsigned long           __darwin_natural_t;
#else
typedef unsigned int            __darwin_natural_t;
#endif

/*
 * The rune type below is declared to be an ``int'' instead of the more natural
 * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
 * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
 * it looks like 10646 will be a 31 bit standard.  This means that if your
 * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
 * chosen over a long is that the is*() and to*() routines take ints (says
 * ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
 * here, you lose a bit of ANSI conformance, but your programs will still
 * work.
 *
 * NOTE: rune_t is not covered by ANSI nor other standards, and should not
 * be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
 * rune_t must be the same type.  Also wint_t must be no narrower than
 * wchar_t, and should also be able to hold all members of the largest
 * character set plus one extra value (WEOF). wint_t must be at least 16 bits.
 */

typedef int			__darwin_ct_rune_t;	/* ct_rune_t */

/*
 * mbstate_t is an opaque object to keep conversion state, during multibyte
 * stream conversions.  The content must not be referenced by user programs.
 */
typedef union {
	char		__mbstate8[128];
	long long	_mbstateL;			/* for alignment */
} __mb_state_t;

typedef __mb_state_t		__darwin_mbstate_t;	/* mbstate_t */

#if defined(__GNUC__) && defined(__PTRDIFF_TYPE__)
typedef __PTRDIFF_TYPE__	__darwin_ptrdiff_t;	/* ptr1 - ptr2 */
#else
typedef int			__darwin_ptrdiff_t;	/* ptr1 - ptr2 */
#endif /* __GNUC__ */

#if defined(__GNUC__) && defined(__SIZE_TYPE__)
typedef __SIZE_TYPE__		__darwin_size_t;	/* sizeof() */
#else
typedef unsigned long		__darwin_size_t;	/* sizeof() */
#endif

#if (__GNUC__ > 2)
typedef __builtin_va_list	__darwin_va_list;	/* va_list */
#else
typedef void *			__darwin_va_list;	/* va_list */
#endif

#if defined(__GNUC__) && defined(__WCHAR_TYPE__)
typedef __WCHAR_TYPE__		__darwin_wchar_t;	/* wchar_t */
#else
typedef __darwin_ct_rune_t	__darwin_wchar_t;	/* wchar_t */
#endif

typedef __darwin_wchar_t	__darwin_rune_t;	/* rune_t */

#if defined(__GNUC__) && defined(__WINT_TYPE__)
typedef __WINT_TYPE__		__darwin_wint_t;	/* wint_t */
#else
typedef __darwin_ct_rune_t	__darwin_wint_t;	/* wint_t */
#endif

typedef unsigned long		__darwin_clock_t;	/* clock() */
typedef __uint32_t		__darwin_socklen_t;	/* socklen_t (duh) */
typedef long			__darwin_ssize_t;	/* byte count or error */
typedef long			__darwin_time_t;	/* time() */

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif	/* _BSD_I386__TYPES_H_ */
                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/eflags.h               0100644 0001750 0001750 00000007036 12612724206 025625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_I386_EFLAGS_H_
#define	_I386_EFLAGS_H_

/*
 *	i386 flags register
 */

#ifndef EFL_CF
#define	EFL_CF		0x00000001		/* carry */
#define	EFL_PF		0x00000004		/* parity of low 8 bits */
#define	EFL_AF		0x00000010		/* carry out of bit 3 */
#define	EFL_ZF		0x00000040		/* zero */
#define	EFL_SF		0x00000080		/* sign */
#define	EFL_TF		0x00000100		/* trace trap */
#define	EFL_IF		0x00000200		/* interrupt enable */
#define	EFL_DF		0x00000400		/* direction */
#define	EFL_OF		0x00000800		/* overflow */
#define	EFL_IOPL	0x00003000		/* IO privilege level: */
#define	EFL_IOPL_KERNEL	0x00000000			/* kernel */
#define	EFL_IOPL_USER	0x00003000			/* user */
#define	EFL_NT		0x00004000		/* nested task */
#define	EFL_RF		0x00010000		/* resume without tracing */
#define	EFL_VM		0x00020000		/* virtual 8086 mode */
#define EFL_AC		0x00040000		/* alignment check */
#define EFL_VIF		0x00080000		/* virtual interrupt flag */
#define EFL_VIP		0x00100000		/* virtual interrupt pending */
#define EFL_ID		0x00200000		/* cpuID instruction */
#endif

#define EFL_CLR		0xfff88028
#define EFL_SET		0x00000002

#define	EFL_USER_SET	(EFL_IF)
#define	EFL_USER_CLEAR	(EFL_IOPL|EFL_NT|EFL_RF)

#endif	/* _I386_EFLAGS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/endian.h               0100644 0001750 0001750 00000010644 12612724206 025621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)endian.h	8.1 (Berkeley) 6/11/93
 */

#ifndef _I386__ENDIAN_H_
#define	_I386__ENDIAN_H_

#include <sys/cdefs.h>
/*
 * Define _NOQUAD if the compiler does NOT support 64-bit integers.
 */
/* #define _NOQUAD */

/*
 * Define the order of 32-bit words in 64-bit words.
 */
#define _QUAD_HIGHWORD 1
#define _QUAD_LOWWORD 0

/*
 * Definitions for byte order, according to byte significance from low
 * address to high.
 */
#define	__DARWIN_LITTLE_ENDIAN	1234	/* LSB first: i386, vax */
#define	__DARWIN_BIG_ENDIAN	4321	/* MSB first: 68000, ibm, net */
#define	__DARWIN_PDP_ENDIAN	3412	/* LSB first in word, MSW first in long */

#define	__DARWIN_BYTE_ORDER	__DARWIN_LITTLE_ENDIAN

#if	defined(KERNEL) || (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))

#undef LITTLE_ENDIAN
#undef BIG_ENDIAN
#undef PDP_ENDIAN
#undef BYTE_ORDER

#define	LITTLE_ENDIAN	__DARWIN_LITTLE_ENDIAN
#define	BIG_ENDIAN	__DARWIN_BIG_ENDIAN
#define	PDP_ENDIAN	__DARWIN_PDP_ENDIAN

#define	BYTE_ORDER	__DARWIN_BYTE_ORDER

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/_endian.h>
#endif /* __FreeBSD__ || __NetBSD__ || __OpenBSD__ */

#endif /* defined(KERNEL) || (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)) */
#endif /* !_I386__ENDIAN_H_ */
                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/fasttrap_isa.h         0100644 0001750 0001750 00000006534 12612724206 027046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_FASTTRAP_ISA_H
#define	_FASTTRAP_ISA_H

/*
 * #pragma ident	"@(#)fasttrap_isa.h	1.6	06/09/19 SMI"
 */

#include <sys/types.h>
#include <stdint.h>

#ifdef	__cplusplus
extern "C" {
#endif

#define	FASTTRAP_MAX_INSTR_SIZE		15

#define	FASTTRAP_INSTR			0xcc

#define	FASTTRAP_SUNWDTRACE_SIZE	64

typedef	uint8_t		fasttrap_instr_t;

typedef struct fasttrap_machtp {
	uint8_t		ftmt_instr[FASTTRAP_MAX_INSTR_SIZE]; /* orig. instr. */
	uint8_t		ftmt_size;	/* instruction size */
#if __sol64 || defined(__APPLE__)
	uint8_t		ftmt_ripmode;	/* %rip-relative handling mode */
	uint8_t		ftmt_modrm;	/* saved modrm byte */
#endif
	uint8_t		ftmt_type;	/* emulation type */
	uint8_t		ftmt_code;	/* branch condition */
	uint8_t		ftmt_base;	/* branch base */
	uint8_t		ftmt_index;	/* branch index */
	uint8_t		ftmt_scale;	/* branch scale */
	uint8_t		ftmt_segment;	/* segment for memory accesses */
	user_addr_t	ftmt_dest;	/* destination of control flow */
} fasttrap_machtp_t;

#define	ftt_instr	ftt_mtp.ftmt_instr
#if __sol64 || defined(__APPLE__)
#define	ftt_ripmode	ftt_mtp.ftmt_ripmode
#define	ftt_modrm	ftt_mtp.ftmt_modrm
#endif
#define	ftt_size	ftt_mtp.ftmt_size
#define	ftt_type	ftt_mtp.ftmt_type
#define	ftt_code	ftt_mtp.ftmt_code
#define	ftt_base	ftt_mtp.ftmt_base
#define	ftt_index	ftt_mtp.ftmt_index
#define	ftt_scale	ftt_mtp.ftmt_scale
#define	ftt_segment	ftt_mtp.ftmt_segment
#define	ftt_dest	ftt_mtp.ftmt_dest

#define	FASTTRAP_T_COMMON	0x00	/* common case -- no emulation */
#define	FASTTRAP_T_JCC		0x01	/* near and far conditional jumps */
#define	FASTTRAP_T_LOOP		0x02	/* loop instructions */
#define	FASTTRAP_T_JCXZ		0x03	/* jump if %ecx/%rcx is zero */
#define	FASTTRAP_T_JMP		0x04	/* relative jump */
#define	FASTTRAP_T_CALL		0x05	/* near call (and link) */
#define	FASTTRAP_T_RET		0x06	/* ret */
#define	FASTTRAP_T_RET16	0x07	/* ret <imm16> */

/*
 * For performance rather than correctness.
 */
#define	FASTTRAP_T_PUSHL_EBP	0x10	/* pushl %ebp (for function entry) */
#define	FASTTRAP_T_NOP		0x11	/* nop */

#define	FASTTRAP_RIP_1		0x1
#define	FASTTRAP_RIP_2		0x2
#define	FASTTRAP_RIP_X		0x4

/*
 * Segment values.
 */
#define	FASTTRAP_SEG_NONE		0
#define	FASTTRAP_SEG_CS			1
#define	FASTTRAP_SEG_DS			2
#define	FASTTRAP_SEG_ES			3
#define	FASTTRAP_SEG_FS			4
#define	FASTTRAP_SEG_GS			5
#define	FASTTRAP_SEG_SS			6

#define	FASTTRAP_RETURN_AFRAMES		6	
#define	FASTTRAP_ENTRY_AFRAMES		5
#define	FASTTRAP_OFFSET_AFRAMES		5

#ifdef	__cplusplus
}
#endif

#endif	/* _FASTTRAP_ISA_H */
                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/limits.h               0100644 0001750 0001750 00000011146 12612724206 025662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)limits.h	8.3 (Berkeley) 1/4/94
 */

#ifndef _I386_LIMITS_H_
#define _I386_LIMITS_H_

#include <sys/cdefs.h>
#include <i386/_limits.h>

#define	CHAR_BIT	8		/* number of bits in a char */
#define	MB_LEN_MAX	6		/* Allow 31 bit UTF2 */

#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
#define	CLK_TCK		__DARWIN_CLK_TCK	/* ticks per second */
#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * According to ANSI (section 2.2.4.2), the values below must be usable by
 * #if preprocessing directives.  Additionally, the expression must have the
 * same type as would an expression that is an object of the corresponding
 * type converted according to the integral promotions.  The subtraction for
 * INT_MIN and LONG_MIN is so the value is not unsigned; 2147483648 is an
 * unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
 * These numbers work for pcc as well.  The UINT_MAX and ULONG_MAX values
 * are written as hex so that GCC will be quiet about large integer constants.
 */
#define	SCHAR_MAX	127		/* min value for a signed char */
#define	SCHAR_MIN	(-128)		/* max value for a signed char */

#define	UCHAR_MAX	255		/* max value for an unsigned char */
#define	CHAR_MAX	127		/* max value for a char */
#define	CHAR_MIN	(-128)		/* min value for a char */

#define	USHRT_MAX	65535		/* max value for an unsigned short */
#define	SHRT_MAX	32767		/* max value for a short */
#define	SHRT_MIN	(-32768)	/* min value for a short */

#define	UINT_MAX	0xffffffff	/* max value for an unsigned int */
#define	INT_MAX		2147483647	/* max value for an int */
#define	INT_MIN		(-2147483647-1)	/* min value for an int */

#ifdef __LP64__
#define	ULONG_MAX	0xffffffffffffffffUL	/* max unsigned long */
#define	LONG_MAX	0x7fffffffffffffffL	/* max signed long */
#define	LONG_MIN	(-0x7fffffffffffffffL-1) /* min signed long */
#else /* !__LP64__ */
#define	ULONG_MAX	0xffffffffUL	/* max unsigned long */
#define	LONG_MAX	2147483647L	/* max signed long */
#define	LONG_MIN	(-2147483647L-1) /* min signed long */
#endif /* __LP64__ */

#define	ULLONG_MAX	0xffffffffffffffffULL	/* max unsigned long long */
#define	LLONG_MAX	0x7fffffffffffffffLL	/* max signed long long */
#define	LLONG_MIN	(-0x7fffffffffffffffLL-1) /* min signed long long */

#if !defined(_ANSI_SOURCE)
#ifdef __LP64__
#define LONG_BIT	64
#else /* !__LP64__ */
#define LONG_BIT	32
#endif /* __LP64__ */
#define	SSIZE_MAX	LONG_MAX	/* max value for a ssize_t */
#define WORD_BIT	32

#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)
#define	SIZE_T_MAX	ULONG_MAX	/* max value for a size_t */

#define	UQUAD_MAX	ULLONG_MAX
#define	QUAD_MAX	LLONG_MAX
#define	QUAD_MIN	LLONG_MIN

#endif /* (!_POSIX_C_SOURCE && !_XOPEN_SOURCE) || _DARWIN_C_SOURCE */
#endif /* !_ANSI_SOURCE */

#endif /* _I386_LIMITS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/param.h                0100644 0001750 0001750 00000014472 12612724206 025466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)param.h	8.1 (Berkeley) 4/4/95
 */

/*
 * Machine dependent constants for Intel 386.
 */

#ifndef _I386_PARAM_H_
#define _I386_PARAM_H_

#include <i386/_param.h>

/*
 * Round p (pointer or byte index) up to a correctly-aligned value for all
 * data types (int, long, ...).   The result is unsigned int and must be
 * cast to any desired pointer type.
 */
#define	ALIGNBYTES	__DARWIN_ALIGNBYTES
#define	ALIGN(p)	__DARWIN_ALIGN(p)

#define	NBPG		4096		/* bytes/page */
#define	PGOFSET		(NBPG-1)	/* byte offset into page */
#define	PGSHIFT		12		/* LOG2(NBPG) */

#define	DEV_BSIZE	512
#define	DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
#define BLKDEV_IOSIZE	2048
#define	MAXPHYS		(128 * 1024)	/* max raw I/O transfer size */

#define	CLSIZE		1
#define	CLSIZELOG2	0

/*
 * Constants related to network buffer management.
 * MCLBYTES must be no larger than CLBYTES (the software page size), and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
 */
#define	MSIZE		256		/* size of an mbuf */
#define	MCLBYTES	2048		/* large enough for ether MTU */
#define	MCLSHIFT	11
#define	MCLOFSET	(MCLBYTES - 1)
#ifndef NMBCLUSTERS
#ifdef GATEWAY
#define	NMBCLUSTERS	((1024 * 1024) / MCLBYTES)	/* cl map size: 1MB */
#else
#define	NMBCLUSTERS	((1024 * 512) / MCLBYTES)	/* cl map size: 0.5MB */
#endif
#endif

/*
 * Some macros for units conversion
 */
/* Core clicks (NeXT_page_size bytes) to segments and vice versa */
#define	ctos(x)	(x)
#define	stoc(x)	(x)

/* Core clicks (4096 bytes) to disk blocks */
#define	ctod(x)	((x)<<(PGSHIFT-DEV_BSHIFT))
#define	dtoc(x)	((x)>>(PGSHIFT-DEV_BSHIFT))
#define	dtob(x)	((x)<<DEV_BSHIFT)

/* clicks to bytes */
#define	ctob(x)	((x)<<PGSHIFT)

/* bytes to clicks */
#define	btoc(x)	(((unsigned)(x)+(NBPG-1))>>PGSHIFT)

#ifdef __APPLE__
#define  btodb(bytes, devBlockSize)         \
        ((unsigned)(bytes) / devBlockSize)
#define  dbtob(db, devBlockSize)            \
        ((unsigned)(db) * devBlockSize)
#else
#define	btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
	((unsigned)(bytes) >> DEV_BSHIFT)
#define	dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
	((unsigned)(db) << DEV_BSHIFT)
#endif

/*
 * Map a ``block device block'' to a file system block.
 * This should be device dependent, and will be if we
 * add an entry to cdevsw/bdevsw for that purpose.
 * For now though just use DEV_BSIZE.
 */
#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))

/*
 * Macros to decode (and encode) processor status word.
 */
#define STATUS_WORD(rpl, ipl)	(((ipl) << 8) | (rpl))
#define	USERMODE(x)		(((x) & 3) == 3)
#define	BASEPRI(x)		(((x) & (255 << 8)) == 0)


#if	defined(KERNEL) || defined(STANDALONE)
#define	DELAY(n) delay(n)

#else	/* defined(KERNEL) || defined(STANDALONE) */
#define	DELAY(n)	{ register int N = (n); while (--N > 0); }
#endif	/* defined(KERNEL) || defined(STANDALONE) */

#endif /* _I386_PARAM_H_ */
                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/profile.h              0100644 0001750 0001750 00000003004 12612724206 026013  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997, Apple Computer, Inc. All rights reserved.
 *
 */

#ifndef _BSD_I386_PROFILE_H_
#define _BSD_I386_PROFILE_H_

#include <sys/appleapiopts.h>


#endif /* _BSD_I386_PROFILE_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/setjmp.h               0100644 0001750 0001750 00000005131 12612724206 025660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	setjmp.h
 *
 *	Declaration of setjmp routines and data structures.
 */
#ifndef _BSD_I386_SETJMP_H
#define _BSD_I386_SETJMP_H

#include <sys/cdefs.h>

#if defined(__x86_64__)
/*
 * _JBLEN is number of ints required to save the following:
 * rflags, rip, rbp, rsp, rbx, r12, r13, r14, r15... these are 8 bytes each
 * mxcsr, fp control word, sigmask... these are 4 bytes each
 * add 16 ints for future expansion needs...
 */
#define _JBLEN ((9 * 2) + 3 + 16)
typedef int jmp_buf[_JBLEN];
typedef int sigjmp_buf[_JBLEN + 1];

#else

/*
 * _JBLEN is number of ints required to save the following:
 * eax, ebx, ecx, edx, edi, esi, ebp, esp, ss, eflags, eip,
 * cs, de, es, fs, gs == 16 ints
 * onstack, mask = 2 ints
 */

#define _JBLEN (18)
typedef int jmp_buf[_JBLEN];
typedef int sigjmp_buf[_JBLEN + 1];

#endif

__BEGIN_DECLS
int	setjmp(jmp_buf);
void	longjmp(jmp_buf, int);

#ifndef _ANSI_SOURCE
int	_setjmp(jmp_buf);
void	_longjmp(jmp_buf, int);
int	sigsetjmp(sigjmp_buf, int);
void	siglongjmp(sigjmp_buf, int);
#endif /* _ANSI_SOURCE  */

#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
void	longjmperror(void);
#endif /* neither ANSI nor POSIX */
__END_DECLS
#endif /* !_BSD_I386_SETJMP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/signal.h               0100644 0001750 0001750 00000004375 12612724206 025644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 */

#ifndef	_I386_SIGNAL_H_
#define	_I386_SIGNAL_H_ 1

#include <sys/cdefs.h>

#ifndef _ANSI_SOURCE
typedef int sig_atomic_t; 

#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)

#if !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__DragonFly__)
#include <sys/appleapiopts.h>
#endif /* !__FreeBSD__ && !__NetBSD__ && !__OpenBSD__ && !__DragonFly__ */

#ifdef __APPLE_API_OBSOLETE

/*
 * Information pushed on stack when a signal is delivered.
 * This is used by the kernel to restore state following
 * execution of the signal handler.  It is also made available
 * to the handler to allow it to properly restore state if
 * a non-standard exit is performed.
 */
#define __need_struct_sigcontext
#include <i386/_structs.h>

#endif /* __APPLE_API_OBSOLETE */
#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
#endif /* ! _ANSI_SOURCE */

#endif	/* _I386_SIGNAL_H_ */

                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/types.h                0100644 0001750 0001750 00000012642 12612724206 025527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.3 (Berkeley) 1/5/94
 */

#ifndef	_MACHTYPES_H_
#define	_MACHTYPES_H_

#ifndef __ASSEMBLER__
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include_next <machine/types.h> /* __cpu_simple_lock_t */
#endif /* __NetBSD__ || __OpenBSD__ */
#ifdef __DragonFly__
#include <cpu/types.h>
#endif /* __DragonFly__ */
#include <i386/_types.h>
#include <sys/cdefs.h>
/*
 * Basic integral types.  Omit the typedef if
 * not possible for a machine/compiler combination.
 */
#ifndef _INT8_T
#define _INT8_T
typedef	__signed char		int8_t;
#endif
typedef	unsigned char		u_int8_t;
#ifndef _INT16_T
#define _INT16_T
typedef	short			int16_t;
#endif
typedef	unsigned short		u_int16_t;
#ifndef _INT32_T
#define _INT32_T
typedef	int			int32_t;
#endif
typedef	unsigned int		u_int32_t;
#ifndef _INT64_T
#define _INT64_T
#if !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__DragonFly__)
typedef	long long		int64_t;
#else
typedef long            int64_t;
#endif /* ! __NetBSD__ && !__OpenBSD__ && !__DragonFly__  */
#endif
#if !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__DragonFly__)
typedef	unsigned long long	u_int64_t;
#else
typedef unsigned long       u_int64_t;
#endif /* ! __NetBSD__ && !__OpenBSD__ && !__DragonFly__ */

#if __LP64__
typedef int64_t			register_t;
#else
typedef int32_t			register_t;
#endif

#ifndef _INTPTR_T
#define _INTPTR_T
typedef __darwin_intptr_t	intptr_t;
#endif
#ifndef _UINTPTR_T
#define _UINTPTR_T
typedef unsigned long		uintptr_t;
#endif

#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
/* These types are used for reserving the largest possible size. */
typedef u_int64_t		user_addr_t;	
typedef u_int64_t		user_size_t;	
typedef int64_t			user_ssize_t;
typedef int64_t			user_long_t;
typedef u_int64_t		user_ulong_t;
typedef int64_t			user_time_t;
typedef int64_t			user_off_t;
#define USER_ADDR_NULL	((user_addr_t) 0)
#define CAST_USER_ADDR_T(a_ptr)   ((user_addr_t)((uintptr_t)(a_ptr)))


#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* This defines the size of syscall arguments after copying into the kernel: */
typedef u_int64_t		syscall_arg_t;

#ifndef __offsetof
#define __offsetof(type, field) ((size_t)(&((type *)0)->field))
#endif

#endif /* __ASSEMBLER__ */
#endif	/* _MACHTYPES_H_ */
                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/user_ldt.h             0100644 0001750 0001750 00000005276 12612724206 026211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon 
 * the rights to redistribute these changes.
 */

/*
 */

#ifndef	_I386_USER_LDT_H_
#define	_I386_USER_LDT_H_

/*
 * User LDT management.
 *
 * Each task may have its own LDT.
 */

#define	LDT_AUTO_ALLOC	0xffffffff

#include <sys/cdefs.h>

union ldt_entry;

__BEGIN_DECLS
int i386_get_ldt(int, union ldt_entry *, int);
int i386_set_ldt(int, const union ldt_entry *, int);
__END_DECLS

#endif	/* _I386_USER_LDT_H_ */
                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/i386/vmparam.h              0100644 0001750 0001750 00000004112 12612724206 026017  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef	_BSD_I386_VMPARAM_H_
#define	_BSD_I386_VMPARAM_H_ 1

#include <sys/resource.h>

/* Rosetta dependency on this address */
#define	USRSTACK	VM_USRSTACK32

#define	USRSTACK64	VM_USRSTACK64


/*
 * Virtual memory related constants, all in bytes
 */
#ifndef DFLDSIZ
#define	DFLDSIZ		(RLIM_INFINITY)		/* initial data size limit */
#endif
#ifndef MAXDSIZ
#define	MAXDSIZ		(RLIM_INFINITY)		/* max data size */
#endif
#ifndef	DFLSSIZ
#define	DFLSSIZ		(8*1024*1024)		/* initial stack size limit */
#endif
#ifndef	MAXSSIZ
#define	MAXSSIZ		(64*1024*1024)		/* max stack size */
#endif
#ifndef	DFLCSIZ
#define DFLCSIZ		(0)			/* initial core size limit */
#endif
#ifndef	MAXCSIZ
#define MAXCSIZ		(RLIM_INFINITY)		/* max core size */
#endif	/* MAXCSIZ */

#endif	/* _BSD_I386_VMPARAM_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libc.h                      0100644 0001750 0001750 00000000413 12612724206 024574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _LIBC_H
#define _LIBC_H

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stdarg.h>
#include <string.h>

#include <fcntl.h>

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/param.h>

#endif
                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/                    0040755 0001750 0001750 00000000000 12612724206 025145  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSAtomic.h          0100644 0001750 0001750 00000022707 12612724206 027001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _OSATOMIC_H_
#define _OSATOMIC_H_

#include    <stddef.h>
#include    <sys/cdefs.h>
#include    <stdint.h>
#include    <stdbool.h>

/* These are the preferred versions of the atomic and synchronization operations.
 * Their implementation is customized at boot time for the platform, including
 * late-breaking errata fixes as necessary.   They are thread safe.
 *
 * WARNING: all addresses passed to these functions must be "naturally aligned", ie
 * int32_t's must be 32-bit aligned (low 2 bits of address zero), and int64_t's
 * must be 64-bit aligned (low 3 bits of address zero.)
 *
 * Note that some versions of the atomic functions incorporate memory barriers,
 * and some do not.  Barriers strictly order memory access on a weakly-ordered
 * architecture such as PPC.  All loads and stores executed in sequential program
 * order before the barrier will complete before any load or store executed after
 * the barrier.  On a uniprocessor, the barrier operation is typically a nop.
 * On a multiprocessor, the barrier can be quite expensive on some platforms,
 * eg PPC.
 *
 * Most code will want to use the barrier functions to insure that memory shared
 * between threads is properly synchronized.  For example, if you want to initialize
 * a shared data structure and then atomically increment a variable to indicate
 * that the initialization is complete, then you must use OSAtomicIncrement32Barrier()
 * to ensure that the stores to your data structure complete before the atomic add.
 * Likewise, the consumer of that data structure must use OSAtomicDecrement32Barrier(),
 * in order to ensure that their loads of the structure are not executed before
 * the atomic decrement.  On the other hand, if you are simply incrementing a global
 * counter, then it is safe and potentially faster to use OSAtomicIncrement32().
 *
 * If you are unsure which version to use, prefer the barrier variants as they are
 * safer.
 *
 * The spinlock and queue operations always incorporate a barrier.
 */ 
__BEGIN_DECLS


/* Arithmetic functions.  They return the new value.
 */
int32_t	OSAtomicAdd32( int32_t __theAmount, volatile int32_t *__theValue );
int32_t	OSAtomicAdd32Barrier( int32_t __theAmount, volatile int32_t *__theValue );

__inline static
int32_t	OSAtomicIncrement32( volatile int32_t *__theValue )
            { return OSAtomicAdd32(  1, __theValue); }
__inline static
int32_t	OSAtomicIncrement32Barrier( volatile int32_t *__theValue )
            { return OSAtomicAdd32Barrier(  1, __theValue); }

__inline static
int32_t	OSAtomicDecrement32( volatile int32_t *__theValue )
            { return OSAtomicAdd32( -1, __theValue); }
__inline static
int32_t	OSAtomicDecrement32Barrier( volatile int32_t *__theValue )
            { return OSAtomicAdd32Barrier( -1, __theValue); }

/* cctools-port: added defined(__ppc__) || */
#if defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)

int64_t	OSAtomicAdd64( int64_t __theAmount, volatile int64_t *__theValue );
int64_t	OSAtomicAdd64Barrier( int64_t __theAmount, volatile int64_t *__theValue );

__inline static
int64_t	OSAtomicIncrement64( volatile int64_t *__theValue )
            { return OSAtomicAdd64(  1, __theValue); }
__inline static
int64_t	OSAtomicIncrement64Barrier( volatile int64_t *__theValue )
            { return OSAtomicAdd64Barrier(  1, __theValue); }

__inline static
int64_t	OSAtomicDecrement64( volatile int64_t *__theValue )
            { return OSAtomicAdd64( -1, __theValue); }
__inline static
int64_t	OSAtomicDecrement64Barrier( volatile int64_t *__theValue )
            { return OSAtomicAdd64Barrier( -1, __theValue); }

#endif  /* defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__) */


/* Boolean functions (and, or, xor.)  These come in four versions for each operation:
 * with and without barriers, and returning the old or new value of the operation.
 * The "Orig" versions return the original value, ie before the operation, the non-Orig
 * versions return the value after the operation.  All are layered on top of
 * compare-and-swap.
 */
int32_t	OSAtomicOr32( uint32_t __theMask, volatile uint32_t *__theValue );
int32_t	OSAtomicOr32Barrier( uint32_t __theMask, volatile uint32_t *__theValue );
int32_t	OSAtomicOr32Orig( uint32_t __theMask, volatile uint32_t *__theValue );
int32_t	OSAtomicOr32OrigBarrier( uint32_t __theMask, volatile uint32_t *__theValue );

int32_t	OSAtomicAnd32( uint32_t __theMask, volatile uint32_t *__theValue ); 
int32_t	OSAtomicAnd32Barrier( uint32_t __theMask, volatile uint32_t *__theValue ); 
int32_t	OSAtomicAnd32Orig( uint32_t __theMask, volatile uint32_t *__theValue ); 
int32_t	OSAtomicAnd32OrigBarrier( uint32_t __theMask, volatile uint32_t *__theValue ); 

int32_t	OSAtomicXor32( uint32_t __theMask, volatile uint32_t *__theValue );
int32_t	OSAtomicXor32Barrier( uint32_t __theMask, volatile uint32_t *__theValue );
int32_t	OSAtomicXor32Orig( uint32_t __theMask, volatile uint32_t *__theValue );
int32_t	OSAtomicXor32OrigBarrier( uint32_t __theMask, volatile uint32_t *__theValue );
 

/* Compare and swap.  They return true if the swap occured.  There are several versions,
 * depending on data type and whether or not a barrier is used.
 */
bool    OSAtomicCompareAndSwap32( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue );
bool    OSAtomicCompareAndSwap32Barrier( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue );
bool	OSAtomicCompareAndSwapPtr( void *__oldValue, void *__newValue, void * volatile *__theValue );
bool	OSAtomicCompareAndSwapPtrBarrier( void *__oldValue, void *__newValue, void * volatile *__theValue );
bool	OSAtomicCompareAndSwapInt( int __oldValue, int __newValue, volatile int *__theValue );
bool	OSAtomicCompareAndSwapIntBarrier( int __oldValue, int __newValue, volatile int *__theValue );
bool	OSAtomicCompareAndSwapLong( long __oldValue, long __newValue, volatile long *__theValue );
bool	OSAtomicCompareAndSwapLongBarrier( long __oldValue, long __newValue, volatile long *__theValue );

#if defined(__ppc64__) || defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)

bool    OSAtomicCompareAndSwap64( int64_t __oldValue, int64_t __newValue, volatile int64_t *__theValue );
bool    OSAtomicCompareAndSwap64Barrier( int64_t __oldValue, int64_t __newValue, volatile int64_t *__theValue );

#endif  /* defined(__ppc64__) || defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__) */


/* Test and set.  They return the original value of the bit, and operate on bit (0x80>>(n&7))
 * in byte ((char*)theAddress + (n>>3)).
 */
bool    OSAtomicTestAndSet( uint32_t __n, volatile void *__theAddress );
bool    OSAtomicTestAndSetBarrier( uint32_t __n, volatile void *__theAddress );
bool    OSAtomicTestAndClear( uint32_t __n, volatile void *__theAddress );
bool    OSAtomicTestAndClearBarrier( uint32_t __n, volatile void *__theAddress );
 

/* Spinlocks.  These use memory barriers as required to synchronize access to shared
 * memory protected by the lock.  The lock operation spins, but employs various strategies
 * to back off if the lock is held, making it immune to most priority-inversion livelocks.
 * The try operation immediately returns false if the lock was held, true if it took the
 * lock.  The convention is that unlocked is zero, locked is nonzero.
 */
#define	OS_SPINLOCK_INIT    0

typedef int32_t OSSpinLock;

bool    OSSpinLockTry( volatile OSSpinLock *__lock );
void    OSSpinLockLock( volatile OSSpinLock *__lock );
void    OSSpinLockUnlock( volatile OSSpinLock *__lock );


/* Lockless atomic enqueue and dequeue.  These routines manipulate singly
 * linked LIFO lists.  Ie, a dequeue will return the most recently enqueued
 * element, or NULL if the list is empty.  The "offset" parameter is the offset
 * in bytes of the link field within the data structure being queued.  The
 * link field should be a pointer type.  Memory barriers are incorporated as 
 * needed to permit thread-safe access to the queue element.
 */
#if defined(__x86_64__)

typedef volatile struct {
	void	*opaque1;
	long	 opaque2;
} OSQueueHead __attribute__ ((aligned (16)));

#else

typedef volatile struct {
	void	*opaque1;
	long	 opaque2;
} OSQueueHead;

#endif

#define	OS_ATOMIC_QUEUE_INIT	{ NULL, 0 }

void  OSAtomicEnqueue( OSQueueHead *__list, void *__new, size_t __offset);
void* OSAtomicDequeue( OSQueueHead *__list, size_t __offset);


/* Memory barrier.  It is both a read and write barrier.
 */
void    OSMemoryBarrier( void );


__END_DECLS

#endif /* _OSATOMIC_H_ */
                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSByteOrder.h       0100644 0001750 0001750 00000024641 12612724206 027463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS_OSBYTEORDER_H
#define _OS_OSBYTEORDER_H

#include <stdint.h>
#include <libkern/_OSByteOrder.h>

/* Macros for swapping constant values in the preprocessing stage. */
#define OSSwapConstInt16(x)	__DARWIN_OSSwapConstInt16(x)
#define OSSwapConstInt32(x)	__DARWIN_OSSwapConstInt32(x)
#define OSSwapConstInt64(x)	__DARWIN_OSSwapConstInt64(x)

#if defined(__GNUC__)

#if (defined(__ppc__) || defined(__ppc64__))
#include <libkern/ppc/OSByteOrder.h>
#elif (defined(__i386__) || defined(__x86_64__))
#include <libkern/i386/OSByteOrder.h>
#elif defined(__arm__) || defined(__arm64__)
#include <libkern/arm/OSByteOrder.h>
#else
#include <libkern/machine/OSByteOrder.h>
#endif

#else /* ! __GNUC__ */

#include <libkern/machine/OSByteOrder.h>

#endif /* __GNUC__ */

#define OSSwapInt16(x)	__DARWIN_OSSwapInt16(x)
#define OSSwapInt32(x)	__DARWIN_OSSwapInt32(x)
#define OSSwapInt64(x)	__DARWIN_OSSwapInt64(x)

enum {
    OSUnknownByteOrder,
    OSLittleEndian,
    OSBigEndian
};

OS_INLINE
int32_t
OSHostByteOrder(void) {
#if defined(__LITTLE_ENDIAN__)
    return OSLittleEndian;
#elif defined(__BIG_ENDIAN__)
    return OSBigEndian;
#else
    return OSUnknownByteOrder;
#endif
}

#define OSReadBigInt(x, y)		OSReadBigInt32(x, y)
#define OSWriteBigInt(x, y, z)		OSWriteBigInt32(x, y, z)
#define OSSwapBigToHostInt(x)		OSSwapBigToHostInt32(x)
#define OSSwapHostToBigInt(x)		OSSwapHostToBigInt32(x)
#define OSReadLittleInt(x, y)		OSReadLittleInt32(x, y)
#define OSWriteLittleInt(x, y, z)	OSWriteLittleInt32(x, y, z)
#define OSSwapHostToLittleInt(x)	OSSwapHostToLittleInt32(x)
#define OSSwapLittleToHostInt(x)	OSSwapLittleToHostInt32(x)

/* Functions for loading native endian values. */

OS_INLINE
uint16_t
_OSReadInt16(
    const volatile void               * base,
    uintptr_t                     byteOffset
)
{
    return *(volatile uint16_t *)((uintptr_t)base + byteOffset);
}

OS_INLINE
uint32_t
_OSReadInt32(
    const volatile void               * base,
    uintptr_t                     byteOffset
)
{
    return *(volatile uint32_t *)((uintptr_t)base + byteOffset);
}

OS_INLINE
uint64_t
_OSReadInt64(
    const volatile void               * base,
    uintptr_t                     byteOffset
)
{
    return *(volatile uint64_t *)((uintptr_t)base + byteOffset);
}

/* Functions for storing native endian values. */

OS_INLINE
void
_OSWriteInt16(
    volatile void               * base,
    uintptr_t                     byteOffset,
    uint16_t                      data
)
{
    *(volatile uint16_t *)((uintptr_t)base + byteOffset) = data;
}

OS_INLINE
void
_OSWriteInt32(
    volatile void               * base,
    uintptr_t                     byteOffset,
    uint32_t                      data
)
{
    *(volatile uint32_t *)((uintptr_t)base + byteOffset) = data;
}

OS_INLINE
void
_OSWriteInt64(
    volatile void               * base,
    uintptr_t                     byteOffset,
    uint64_t                      data
)
{
    *(volatile uint64_t *)((uintptr_t)base + byteOffset) = data;
}

#if		defined(__BIG_ENDIAN__)

/* Functions for loading big endian to host endianess. */

#define OSReadBigInt16(base, byteOffset) _OSReadInt16(base, byteOffset)
#define OSReadBigInt32(base, byteOffset) _OSReadInt32(base, byteOffset)
#define OSReadBigInt64(base, byteOffset) _OSReadInt64(base, byteOffset)

/* Functions for storing host endianess to big endian. */

#define OSWriteBigInt16(base, byteOffset, data) _OSWriteInt16(base, byteOffset, data)
#define OSWriteBigInt32(base, byteOffset, data) _OSWriteInt32(base, byteOffset, data)
#define OSWriteBigInt64(base, byteOffset, data) _OSWriteInt64(base, byteOffset, data)

/* Functions for loading little endian to host endianess. */

#define OSReadLittleInt16(base, byteOffset) OSReadSwapInt16(base, byteOffset)
#define OSReadLittleInt32(base, byteOffset) OSReadSwapInt32(base, byteOffset)
#define OSReadLittleInt64(base, byteOffset) OSReadSwapInt64(base, byteOffset)

/* Functions for storing host endianess to little endian. */

#define OSWriteLittleInt16(base, byteOffset, data) OSWriteSwapInt16(base, byteOffset, data)
#define OSWriteLittleInt32(base, byteOffset, data) OSWriteSwapInt32(base, byteOffset, data)
#define OSWriteLittleInt64(base, byteOffset, data) OSWriteSwapInt64(base, byteOffset, data)

/* Host endianess to big endian byte swapping macros for constants. */

#define OSSwapHostToBigConstInt16(x) ((uint16_t)(x))
#define OSSwapHostToBigConstInt32(x) ((uint32_t)(x))
#define OSSwapHostToBigConstInt64(x) ((uint64_t)(x))

/* Generic host endianess to big endian byte swapping functions. */

#define OSSwapHostToBigInt16(x) ((uint16_t)(x))
#define OSSwapHostToBigInt32(x) ((uint32_t)(x))
#define OSSwapHostToBigInt64(x) ((uint64_t)(x))

/* Host endianess to little endian byte swapping macros for constants. */

#define OSSwapHostToLittleConstInt16(x) OSSwapConstInt16(x)
#define OSSwapHostToLittleConstInt32(x) OSSwapConstInt32(x) 
#define OSSwapHostToLittleConstInt64(x) OSSwapConstInt64(x) 

/* Generic host endianess to little endian byte swapping functions. */

#define OSSwapHostToLittleInt16(x) OSSwapInt16(x)
#define OSSwapHostToLittleInt32(x) OSSwapInt32(x)
#define OSSwapHostToLittleInt64(x) OSSwapInt64(x)

/* Big endian to host endianess byte swapping macros for constants. */
    
#define OSSwapBigToHostConstInt16(x) ((uint16_t)(x))
#define OSSwapBigToHostConstInt32(x) ((uint32_t)(x))
#define OSSwapBigToHostConstInt64(x) ((uint64_t)(x))

/* Generic big endian to host endianess byte swapping functions. */

#define OSSwapBigToHostInt16(x) ((uint16_t)(x))
#define OSSwapBigToHostInt32(x) ((uint32_t)(x))
#define OSSwapBigToHostInt64(x) ((uint64_t)(x))

/* Little endian to host endianess byte swapping macros for constants. */
   
#define OSSwapLittleToHostConstInt16(x) OSSwapConstInt16(x)
#define OSSwapLittleToHostConstInt32(x) OSSwapConstInt32(x)
#define OSSwapLittleToHostConstInt64(x) OSSwapConstInt64(x)

/* Generic little endian to host endianess byte swapping functions. */

#define OSSwapLittleToHostInt16(x) OSSwapInt16(x)
#define OSSwapLittleToHostInt32(x) OSSwapInt32(x)
#define OSSwapLittleToHostInt64(x) OSSwapInt64(x)

#elif		defined(__LITTLE_ENDIAN__)

/* Functions for loading big endian to host endianess. */

#define OSReadBigInt16(base, byteOffset) OSReadSwapInt16(base, byteOffset)
#define OSReadBigInt32(base, byteOffset) OSReadSwapInt32(base, byteOffset)
#define OSReadBigInt64(base, byteOffset) OSReadSwapInt64(base, byteOffset)

/* Functions for storing host endianess to big endian. */

#define OSWriteBigInt16(base, byteOffset, data) OSWriteSwapInt16(base, byteOffset, data)
#define OSWriteBigInt32(base, byteOffset, data) OSWriteSwapInt32(base, byteOffset, data)
#define OSWriteBigInt64(base, byteOffset, data) OSWriteSwapInt64(base, byteOffset, data)

/* Functions for loading little endian to host endianess. */

#define OSReadLittleInt16(base, byteOffset) _OSReadInt16(base, byteOffset)
#define OSReadLittleInt32(base, byteOffset) _OSReadInt32(base, byteOffset)
#define OSReadLittleInt64(base, byteOffset) _OSReadInt64(base, byteOffset)

/* Functions for storing host endianess to little endian. */

#define OSWriteLittleInt16(base, byteOffset, data) _OSWriteInt16(base, byteOffset, data)
#define OSWriteLittleInt32(base, byteOffset, data) _OSWriteInt32(base, byteOffset, data)
#define OSWriteLittleInt64(base, byteOffset, data) _OSWriteInt64(base, byteOffset, data)

/* Host endianess to big endian byte swapping macros for constants. */

#define OSSwapHostToBigConstInt16(x) OSSwapConstInt16(x)
#define OSSwapHostToBigConstInt32(x) OSSwapConstInt32(x)
#define OSSwapHostToBigConstInt64(x) OSSwapConstInt64(x)

/* Generic host endianess to big endian byte swapping functions. */

#define OSSwapHostToBigInt16(x) OSSwapInt16(x)
#define OSSwapHostToBigInt32(x) OSSwapInt32(x)
#define OSSwapHostToBigInt64(x) OSSwapInt64(x)

/* Host endianess to little endian byte swapping macros for constants. */

#define OSSwapHostToLittleConstInt16(x) ((uint16_t)(x))
#define OSSwapHostToLittleConstInt32(x) ((uint32_t)(x))
#define OSSwapHostToLittleConstInt64(x) ((uint64_t)(x)) 

/* Generic host endianess to little endian byte swapping functions. */

#define OSSwapHostToLittleInt16(x) ((uint16_t)(x))
#define OSSwapHostToLittleInt32(x) ((uint32_t)(x))
#define OSSwapHostToLittleInt64(x) ((uint64_t)(x))

/* Big endian to host endianess byte swapping macros for constants. */

#define OSSwapBigToHostConstInt16(x) OSSwapConstInt16(x)
#define OSSwapBigToHostConstInt32(x) OSSwapConstInt32(x)
#define OSSwapBigToHostConstInt64(x) OSSwapConstInt64(x)

/* Generic big endian to host endianess byte swapping functions. */

#define OSSwapBigToHostInt16(x) OSSwapInt16(x)
#define OSSwapBigToHostInt32(x) OSSwapInt32(x)
#define OSSwapBigToHostInt64(x) OSSwapInt64(x)

/* Little endian to host endianess byte swapping macros for constants. */

#define OSSwapLittleToHostConstInt16(x) ((uint16_t)(x))
#define OSSwapLittleToHostConstInt32(x) ((uint32_t)(x))
#define OSSwapLittleToHostConstInt64(x) ((uint64_t)(x))

/* Generic little endian to host endianess byte swapping functions. */

#define OSSwapLittleToHostInt16(x) ((uint16_t)(x))
#define OSSwapLittleToHostInt32(x) ((uint32_t)(x))
#define OSSwapLittleToHostInt64(x) ((uint64_t)(x))

#else
#error Unknown endianess.
#endif

#endif /* ! _OS_OSBYTEORDER_H */


                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSCacheControl.h    0100644 0001750 0001750 00000004162 12612724206 030124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _OS_CACHE_CONTROL_H_
#define _OS_CACHE_CONTROL_H_

#include    <stddef.h>
#include    <sys/cdefs.h>
#include    <stdint.h>

__BEGIN_DECLS


/* Functions performed by sys_cache_control(): */

/* Prepare memory for execution.  This should be called
 * after writing machine instructions to memory, before
 * executing them.  It syncs the dcache and icache.
 * On IA32 processors this function is a NOP, because
 * no synchronization is required.
 */
#define	kCacheFunctionPrepareForExecution	1

/* Flush data cache(s).  This ensures that cached data 
 * makes it all the way out to DRAM, and then removes
 * copies of the data from all processor caches.
 * It can be useful when dealing with cache incoherent
 * devices or DMA.
 */
#define	kCacheFunctionFlushDcache	2


/* perform one of the above cache functions: */
int	sys_cache_control( int function, void *start, size_t len);
 
/* equivalent to sys_cache_control(kCacheFunctionPrepareForExecution): */
void	sys_icache_invalidate( void *start, size_t len);

/* equivalent to sys_cache_control(kCacheFunctionFlushDcache): */
void	sys_dcache_flush( void *start, size_t len);


__END_DECLS

#endif /* _OS_CACHE_CONTROL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSDebug.h           0100644 0001750 0001750 00000004477 12612724206 026617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */

#ifndef _OS_OSDEBBUG_H
#define _OS_OSDEBBUG_H

#include <sys/cdefs.h>
#include <mach/mach_types.h>

__BEGIN_DECLS

extern int log_leaks;

/* Use kernel_debug() to log a backtrace */ 
extern void trace_backtrace(unsigned int debugid, unsigned int debugid2, unsigned long size, unsigned long data);
/* Report a message with a 4 entry backtrace - very slow */
extern void OSReportWithBacktrace(const char *str, ...);
extern unsigned OSBacktrace(void **bt, unsigned maxAddrs);

/*! @function OSKernelStackRemaining
    @abstract Returns bytes available below the current stack frame.
    @discussion Returns bytes available below the current stack frame. Safe for interrupt or thread context.
    @result Approximate byte count available. */

vm_offset_t OSKernelStackRemaining( void );

__END_DECLS

#define TRACE_MACHLEAKS(a,b,c,d)	\
do {					\
    if (log_leaks)			\
        trace_backtrace(a,b,c,d);	\
} while(0)

#endif /* !_OS_OSDEBBUG_H */
                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSKextLib.h         0100644 0001750 0001750 00000036661 12612724206 027133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _LIBKERN_OSKEXTLIB_H
#define _LIBKERN_OSKEXTLIB_H

#include <sys/cdefs.h>
__BEGIN_DECLS

#include <stdint.h>
#include <mach/kmod.h>
#include <mach/vm_types.h>

#include <CoreFoundation/CoreFoundation.h>
#include <System/libkern/OSReturn.h>

/*!
 * @header
 *
 * Declares functions, basic return values, and other constants
 * related to kernel extensions (kexts).
 */

#if PRAGMA_MARK
#pragma mark -
/********************************************************************/
#pragma mark OSReturn Values for Kernel Extensions
/********************************************************************/
#endif
/*!
 * @group OSReturn Values for Kernel Extensions
 * Many kext-related functions return these values,
 * as well as those defined under
 * <code>@link //apple_ref/c/tdef/OSReturn OSReturn@/link</code>
 * and other variants of <code>kern_return_t</code>.
 */


#define sub_libkern_kext           err_sub(2)
#define libkern_kext_err(code)     (sys_libkern|sub_libkern_kext|(code))


/*!
 * @define   kOSKextReturnInternalError
 * @abstract An internal error in the kext library.
 *           Contrast with <code>@link //apple_ref/c/econst/OSReturnError
 *           OSReturnError@/link</code>.
 */
#define kOSKextReturnInternalError                   libkern_kext_err(0x1)

/*!
 * @define   kOSKextReturnNoMemory
 * @abstract Memory allocation failed.
 */
#define kOSKextReturnNoMemory                        libkern_kext_err(0x2)

/*!
 * @define   kOSKextReturnNoResources
 * @abstract Some resource other than memory (such as available load tags)
 *           is exhausted.
 */
#define kOSKextReturnNoResources                     libkern_kext_err(0x3)

/*!
 * @define   kOSKextReturnNotPrivileged
 * @abstract The caller lacks privileges to perform the requested operation.
 */
#define kOSKextReturnNotPrivileged                   libkern_kext_err(0x4)

/*!
 * @define   kOSKextReturnInvalidArgument
 * @abstract Invalid argument.
 */
#define kOSKextReturnInvalidArgument                 libkern_kext_err(0x5)

/*!
 * @define   kOSKextReturnNotFound
 * @abstract Search item not found.
 */
#define kOSKextReturnNotFound                        libkern_kext_err(0x6)

/*!
 * @define   kOSKextReturnBadData
 * @abstract Malformed data (not used for XML).
 */
#define kOSKextReturnBadData                         libkern_kext_err(0x7)

/*!
 * @define   kOSKextReturnSerialization
 * @abstract Error converting or (un)serializing URL, string, or XML.
 */
#define kOSKextReturnSerialization                   libkern_kext_err(0x8)

/*!
 * @define   kOSKextReturnUnsupported
 * @abstract Operation is no longer or not yet supported.
 */
#define kOSKextReturnUnsupported                     libkern_kext_err(0x9)

/*!
 * @define   kOSKextReturnDisabled
 * @abstract Operation is currently disabled.
 */
#define kOSKextReturnDisabled                        libkern_kext_err(0xa)

/*!
 * @define   kOSKextReturnNotAKext
 * @abstract Bundle is not a kernel extension.
 */
#define kOSKextReturnNotAKext                        libkern_kext_err(0xb)

/*!
 * @define   kOSKextReturnValidation
 * @abstract Validation failures encountered; check diagnostics for details.
 */
#define kOSKextReturnValidation                      libkern_kext_err(0xc)

/*!
 * @define   kOSKextReturnAuthentication
 * @abstract Authetication failures encountered; check diagnostics for details.
 */
#define kOSKextReturnAuthentication                  libkern_kext_err(0xd)

/*!
 * @define   kOSKextReturnDependencies
 * @abstract Dependency resolution failures encountered; check diagnostics for details.
 */
#define kOSKextReturnDependencies                    libkern_kext_err(0xe)

/*!
 * @define   kOSKextReturnArchNotFound
 * @abstract Kext does not contain code for the requested architecture.
 */
#define kOSKextReturnArchNotFound                    libkern_kext_err(0xf)

/*!
 * @define   kOSKextReturnCache
 * @abstract An error occurred processing a system kext cache.
 */
#define kOSKextReturnCache                           libkern_kext_err(0x10)

/*!
 * @define   kOSKextReturnDeferred
 * @abstract Operation has been posted asynchronously to user space (kernel only).
 */
#define kOSKextReturnDeferred                        libkern_kext_err(0x11)

/*!
 * @define   kOSKextReturnBootLevel
 * @abstract Kext not loadable or operation not allowed at current boot level.
 */
#define kOSKextReturnBootLevel                       libkern_kext_err(0x12)

/*!
 * @define   kOSKextReturnNotLoadable
 * @abstract Kext cannot be loaded; check diagnostics for details.
 */
#define kOSKextReturnNotLoadable                     libkern_kext_err(0x13)

/*!
 * @define   kOSKextReturnLoadedVersionDiffers
 * @abstract A different version (or executable UUID, or executable by checksum)
 *           of the requested kext is already loaded.
 */
#define kOSKextReturnLoadedVersionDiffers            libkern_kext_err(0x14)

/*!
 * @define   kOSKextReturnDependencyLoadError
 * @abstract A load error occurred on a dependency of the kext being loaded.
 */
#define kOSKextReturnDependencyLoadError             libkern_kext_err(0x15)

/*!
 * @define   kOSKextReturnLinkError
 * @abstract A link failure occured with this kext or a dependency.
 */
#define kOSKextReturnLinkError                       libkern_kext_err(0x16)

/*!
 * @define   kOSKextReturnStartStopError
 * @abstract The kext start or stop routine returned an error.
 */
#define kOSKextReturnStartStopError                  libkern_kext_err(0x17)

/*!
 * @define   kOSKextReturnInUse
 * @abstract The kext is currently in use or has outstanding references,
 *           and cannot be unloaded.
 */
#define kOSKextReturnInUse                           libkern_kext_err(0x18)

/*!
 * @define   kOSKextReturnTimeout
 * @abstract A kext request has timed out.
 */
#define kOSKextReturnTimeout                         libkern_kext_err(0x19)

/*!
 * @define   kOSKextReturnStopping
 * @abstract The kext is in the process of stopping; requests cannot be made.
 */
#define kOSKextReturnStopping                        libkern_kext_err(0x1a)

#if PRAGMA_MARK
#pragma mark -
/********************************************************************/
#pragma mark Kext/OSBundle Property List Keys
/********************************************************************/
#endif
/*!
 * @group Kext Property List Keys
 * These constants cover CFBundle properties defined for kernel extensions.
 * Because they are used in the kernel, if you want to use one with
 * CFBundle APIs you'll need to wrap it in a <code>CFSTR()</code> macro.
 */


/*!
 * @define   kOSBundleCompatibleVersionKey
 * @abstract A string giving the backwards-compatible version of a library kext
 *           in extended Mac OS 'vers' format (####.##.##s{1-255} where 's'
 *           is a build stage 'd', 'a', 'b', 'f' or 'fc').
 */
#define kOSBundleCompatibleVersionKey           "OSBundleCompatibleVersion"

/*!
 * @define   kOSBundleEnableKextLoggingKey
 * @abstract Set to true to have the kernel kext logging spec applied
 *           to the kext.
 *           See <code>@link //apple_ref/c/econst/OSKextLogSpec
 *           OSKextLogSpec@/link</code>.
 */
#define kOSBundleEnableKextLoggingKey           "OSBundleEnableKextLogging"

/*!
 * @define   kOSBundleIsInterfaceKey
 * @abstract A boolean value indicating whether the kext executable
 *           contains only symbol references.
 */
#define kOSBundleIsInterfaceKey                 "OSBundleIsInterface"

/*!
 * @define   kOSBundleLibrariesKey
 * @abstract A dictionary listing link dependencies for this kext.
 *           Keys are bundle identifiers, values are version strings.
 */
#define kOSBundleLibrariesKey                   "OSBundleLibraries"

/*!
 * @define   kOSBundleRequiredKey
 * @abstract A string indicating in which kinds of startup this kext
 *           may need to load during early startup (before
 *           <code>@link //apple_ref/doc/man/8/kextd kextcache(8)@/link</code>).
 * @discussion
 * The value is one of:
 * <ul>
 * <li>@link kOSBundleRequiredRoot "OSBundleRequiredRoot"@/link</li>
 * <li>@link kOSBundleRequiredLocalRoot "OSBundleRequiredLocalRoot"@/link</li>
 * <li>@link kOSBundleRequiredNetworkRoot "OSBundleRequiredNetworkRoot"@/link</li>
 * <li>@link kOSBundleRequiredSafeBoot "OSBundleRequiredSafeBoot"@/link</li>
 * <li>@link kOSBundleRequiredConsole "OSBundleRequiredConsole"@/link</li>
 * </ul>
 *
 * Use this property judiciously.
 * Every kext that declares a value other than "OSBundleRequiredSafeBoot"
 * increases startup time, as the booter must read it into memory,
 * or startup kext caches must include it.
 */
#define kOSBundleRequiredKey                    "OSBundleRequired"

/*!
 * @define   kOSBundleAllowUserLoadKey
 * @abstract A boolean value indicating whether
 *           <code>@link //apple_ref/doc/man/8/kextd kextcache(8)@/link</code>
 *           will honor a non-root process's request to load a kext.
 * @discussion
 * See <code>@link //apple_ref/doc/compositePage/c/func/KextManagerLoadKextWithURL
 * KextManagerLoadKextWithURL@/link</code>
 * and <code>@link //apple_ref/doc/compositePage/c/func/KextManagerLoadKextWithIdentifier
 * KextManagerLoadKextWithIdentifier@/link</code>.
 */
#define kOSBundleAllowUserLoadKey               "OSBundleAllowUserLoad"

/*!
 * @define   kOSKernelResourceKey
 * @abstract A boolean value indicating whether the kext represents a built-in
 *           component of the kernel.
 */
#define kOSKernelResourceKey                    "OSKernelResource"

/*!
 * @define   kIOKitPersonalitiesKey
 * @abstract A dictionary of dictionaries used in matching for I/O Kit drivers.
 */
#define kIOKitPersonalitiesKey                  "IOKitPersonalities"

/*
 * @define   kIOPersonalityPublisherKey
 * @abstract Used in personalities sent to the I/O Kit,
 *           contains the CFBundleIdentifier of the kext
 *           that the personality originated in.
 */
#define kIOPersonalityPublisherKey              "IOPersonalityPublisher"


#if PRAGMA_MARK
/********************************************************************/
#pragma mark Kext/OSBundle Property Deprecated Keys
/********************************************************************/
#endif
/*
 * @define   kOSBundleDebugLevelKey
 * @abstract
 * Deprecated (used on some releases of Mac OS X prior to 10.6 Snow Leopard).
 * Value is an integer from 1-6, corresponding to the verbose levels
 * of kext tools on those releases.
 * On 10.6 Snow Leopard, use <code>@link OSKextEnableKextLogging
 * OSKextEnableKextLogging@/link</code>.
 */
#define kOSBundleDebugLevelKey                  "OSBundleDebugLevel"

/*!
 * @define   kOSBundleSharedExecutableIdentifierKey
 * @abstract Deprecated (used on some releases of Mac OS X
 *           prior to 10.6 Snow Leopard).
 *           Value is the bundle identifier of the pseudokext
 *           that contains an executable shared by this kext.
 */
#define kOSBundleSharedExecutableIdentifierKey  "OSBundleSharedExecutableIdentifier"


#if PRAGMA_MARK
/********************************************************************/
#pragma mark Kext/OSBundle Property List Values
/********************************************************************/
#endif

/*!
 * @group Kext Property List Values
 * These constants encompass established values
 * for kernel extension bundle properties.
 */

/*!
* @define   kOSKextKernelIdentifier
* @abstract
* This is the CFBundleIdentifier user for the kernel itself.
*/
#define kOSKextKernelIdentifier                 "__kernel__"

/*!
* @define   kOSBundleRequiredRoot
* @abstract
* This <code>@link kOSBundleRequiredKey OSBundleRequired@/link</code>
* value indicates that the kext may be needed to mount the root filesystem
* whether starting from a local or a network volume.
*/
#define kOSBundleRequiredRoot                   "Root"

/*!
* @define   kOSBundleRequiredLocalRoot
* @abstract
* This <code>@link kOSBundleRequiredKey OSBundleRequired@/link</code>
* value indicates that the kext may be needed to mount the root filesystem
* when starting from a local disk.
*/
#define kOSBundleRequiredLocalRoot              "Local-Root"

/*!
* @define   kOSBundleRequiredNetworkRoot
* @abstract
* This <code>@link kOSBundleRequiredKey OSBundleRequired@/link</code>
* value indicates that the kext may be needed to mount the root filesystem
* when starting over a network connection.
*/
#define kOSBundleRequiredNetworkRoot            "Network-Root"

/*!
* @define   kOSBundleRequiredSafeBoot
* @abstract
* This <code>@link kOSBundleRequiredKey OSBundleRequired@/link</code>
* value indicates that the kext can be loaded during a safe startup.
* This value does not normally cause the kext to be read by the booter
* or included in startup kext caches.
*/
#define kOSBundleRequiredSafeBoot               "Safe Boot"

/*!
* @define   kOSBundleRequiredConsole
* @abstract
* This <code>@link kOSBundleRequiredKey OSBundleRequired@/link</code>
* value indicates that the kext may be needed for console access
* (specifically in a single-user startup when
* <code>@link //apple_ref/doc/man/8/kextd kextd(8)@/link</code>.
* does not run)
* and should be loaded during early startup.
*/
#define kOSBundleRequiredConsole                "Console"


#if PRAGMA_MARK
#pragma mark -
/********************************************************************/
#pragma mark Kext Information
/********************************************************************/
#endif
/*!
 * @group Kext Information
 * Types, constants, and macros providing a kext with information
 * about itself.
 */

/*!
 * @typedef OSKextLoadTag
 *
 * @abstract
 * A unique identifier assigned to a loaded instanace of a kext.
 *
 * @discussion
 * If a kext is unloaded and later reloaded, the new instance
 * has a different load tag.
 *
 * A kext can get its own load tag in the <code>kmod_info_t</code>
 * structure passed into its module start routine, as the
 * <code>id</code> field (cast to this type).
 * You can use the load tag with the functions
 * <code>@link OSKextRetainKextWithLoadTag
 * OSKextRetainKextWithLoadTag@/link</code> and
 * <code>@link OSKextReleaseKextWithLoadTag
 * OSKextReleaseKextWithLoadTag@/link</code>.
 */
typedef uint32_t  OSKextLoadTag;

/*!
 * @define kOSKextInvalidLoadTag
 *
 * @abstract
 * A load tag value that will never be used for a loaded kext;
 * indicates kext not found.
 */
#define  kOSKextInvalidLoadTag  ((OSKextLoadTag)(-1))



__END_DECLS

#endif /* _LIBKERN_OSKEXTLIB_H */
                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSReturn.h          0100644 0001750 0001750 00000014233 12612724206 027037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998 Apple Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */
 
/*
 * Core OSReturn values.
 */

#ifndef __LIBKERN_OSRETURN_H
#define __LIBKERN_OSRETURN_H

#include <sys/cdefs.h>

__BEGIN_DECLS

#include <mach/error.h>


/*!
 * @header
 *
 * Declares functions, basic return values, and other constants
 * related to kernel extensions (kexts).
 */

#if PRAGMA_MARK
#pragma mark Core OSReturn Values for Libkern
#endif
/*********************************************************************
* Core OSReturn Values for Libkern
*********************************************************************/
/*!
 * @group Core OSReturn Values for Libkern
 * Some kext and I/O Kit functions can return these values,
 * as well as  other values of
 * <code>kern_return_t</code>.
 *
 * Many of these return values represent internal errors
 * in the Libkern C++ run-time typing information system
 * based on @link //apple_ref/doc/class/OSMetaClass OSMetaClass@/link;
 * you are unlikely to ever see them.
 * 
 */


/*!
 * @typedef  OSReturn
 * @abstract The return type for many Libkern functions.
 */
typedef kern_return_t OSReturn;

#ifndef sys_libkern
#define sys_libkern                   err_system(0x37)
#endif /* sys_libkern */

#define sub_libkern_common            err_sub(0)
#define sub_libkern_metaclass         err_sub(1)
#define sub_libkern_reserved          err_sub(-1)

#define libkern_common_err(return)    (sys_libkern|sub_libkern_common|(return))
#define libkern_metaclass_err(return) (sys_libkern|sub_libkern_metaclass|(return))

/* See OSKextLib.h for these
 * #define sub_libkern_kext           err_sub(2)
 * #define libkern_kext_err(code)     (sys_libkern|sub_libkern_kext|(code))
 */

/*!
 * @define   kOSReturnSuccess
 * @abstract Operation successful.
 *           Equal to <code>@link //apple_ref/c/econst/KERN_SUCCESS
 *           KERN_SUCCESS@/link</code>.
 */
#define kOSReturnSuccess              KERN_SUCCESS

/*!
 * @define   kOSReturnError
 * @abstract Unspecified Libkern error.
 *           <b>Not equal</b> to 
 *           <code>@link //apple_ref/c/econst/KERN_FAILURE
 *           KERN_FAILURE@/link</code>.
 */
#define kOSReturnError                libkern_common_err(1)

/*!
 * @define   kOSMetaClassInternal
 * @abstract Internal OSMetaClass run-time error.
 */
#define kOSMetaClassInternal          libkern_metaclass_err(1)

/*!
 * @define   kOSMetaClassHasInstances
 * @abstract A kext cannot be unloaded because there are instances
 *           derived from Libkern C++ classes that it defines.
 */
#define kOSMetaClassHasInstances      libkern_metaclass_err(2)

/*!
 * @define   kOSMetaClassNoInit
 * @abstract Internal error: The Libkern C++ class registration system
 *           was not properly initialized during kext loading.
 */
#define kOSMetaClassNoInit            libkern_metaclass_err(3)
// OSMetaClass::preModLoad wasn't called, runtime internal error

/*!
 * @define   kOSMetaClassNoTempData
 * @abstract Internal error: An allocation failure occurred
 *           registering Libkern C++ classes during kext loading.
 */
#define kOSMetaClassNoTempData        libkern_metaclass_err(4)
// Allocation failure internal data

/*!
 * @define   kOSMetaClassNoDicts
 * @abstract Internal error: An allocation failure occurred
 *           registering Libkern C++ classes during kext loading.
 */
#define kOSMetaClassNoDicts           libkern_metaclass_err(5)
// Allocation failure for Metaclass internal dictionaries

/*!
 * @define   kOSMetaClassNoKModSet
 * @abstract Internal error: An allocation failure occurred
 *           registering Libkern C++ classes during kext loading.
 */
#define kOSMetaClassNoKModSet         libkern_metaclass_err(6)
// Allocation failure for internal kmodule set

/*!
 * @define   kOSMetaClassNoInsKModSet
 * @abstract Internal error: An error occurred registering
 *           a specific Libkern C++ class during kext loading.
 */
#define kOSMetaClassNoInsKModSet      libkern_metaclass_err(7)
// Can't insert the KMod set into the module dictionary

/*!
 * @define   kOSMetaClassNoSuper
 * @abstract Internal error: No superclass can be found
 *           for a specific Libkern C++ class during kext loading.
 */
#define kOSMetaClassNoSuper           libkern_metaclass_err(8)

/*!
 * @define   kOSMetaClassInstNoSuper
 * @abstract Internal error: No superclass can be found when constructing
 *           an instance of a Libkern C++ class.
 */
#define kOSMetaClassInstNoSuper       libkern_metaclass_err(9)

/*!
 * @define   kOSMetaClassDuplicateClass
 * @abstract A duplicate Libkern C++ classname was encountered
 *           during kext loading.
 */
#define kOSMetaClassDuplicateClass    libkern_metaclass_err(10)

/*!
 * @define   kOSMetaClassNoKext
 * @abstract Internal error: The kext for a Libkern C++ class
 *           can't be found during kext loading.
 */
#define kOSMetaClassNoKext            libkern_metaclass_err(11)

__END_DECLS

#endif /* ! __LIBKERN_OSRETURN_H */
                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/OSTypes.h           0100644 0001750 0001750 00000007102 12612724206 026661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */

#ifndef _OS_OSTYPES_H
#define _OS_OSTYPES_H

#define OSTYPES_K64_REV		2

typedef unsigned int 	   UInt;
typedef signed int         SInt;

#ifndef __MACTYPES__	/* CF MacTypes.h */
#ifndef __TYPES__	/* guess... Mac Types.h */

typedef unsigned char 	   UInt8;
typedef unsigned short 	   UInt16;
#if __LP64__
typedef unsigned int       UInt32;
#else
typedef unsigned long      UInt32;
#endif
typedef unsigned long long UInt64;
#if		defined(__BIG_ENDIAN__)
typedef	struct UnsignedWide {
			UInt32		hi;
			UInt32		lo;
}							UnsignedWide;
#elif		defined(__LITTLE_ENDIAN__)
typedef	struct UnsignedWide {
			UInt32		lo;
			UInt32		hi;
}							UnsignedWide;
#else
#error Unknown endianess.
#endif

typedef signed char 	   SInt8;
typedef signed short 	   SInt16;
#if __LP64__
typedef signed int         SInt32;
#else
typedef signed long        SInt32;
#endif
typedef signed long long   SInt64;
#if		defined(__BIG_ENDIAN__)
typedef	struct wide {
			SInt32		hi;
			UInt32		lo;
}							wide;
#elif		defined(__LITTLE_ENDIAN__)
typedef	struct wide {
			UInt32		lo;
			SInt32		hi;
}							wide;
#else
#error Unknown endianess.
#endif

typedef SInt32				OSStatus;

#if defined(__LP64__) && defined(KERNEL)
#ifndef ABSOLUTETIME_SCALAR_TYPE
#define ABSOLUTETIME_SCALAR_TYPE    1
#endif
typedef UInt64		AbsoluteTime;
#else
typedef UnsignedWide		AbsoluteTime;
#endif

typedef UInt32				OptionBits;

#if defined(KERNEL) && defined(__LP64__)
/*
 * Use intrinsic boolean types for the LP64 kernel, otherwise maintain
 * source and binary backward compatibility.  This attempts to resolve
 * the "(x == true)" vs. "(x)" conditional issue.
 */
#ifdef __cplusplus
typedef bool Boolean;
#else	/* !__cplusplus */
#if defined(__STDC_VERSION__) && ((__STDC_VERSION__ - 199901L) > 0L)
/* only use this if we are sure we are using a c99 compiler */
typedef _Bool Boolean;
#else	/* !c99 */
/* Fall back to previous definition unless c99 */
typedef unsigned char Boolean;
#endif	/* !c99 */
#endif	/* !__cplusplus */
#else	/* !(KERNEL && __LP64__) */
typedef unsigned char Boolean;
#endif	/* !(KERNEL && __LP64__) */

#endif /* __TYPES__ */
#endif /* __MACTYPES__ */

#if !defined(OS_INLINE)
#	define OS_INLINE static inline
#endif

#endif /* _OS_OSTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/_OSByteOrder.h      0100644 0001750 0001750 00000010406 12612724206 027614  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS__OSBYTEORDER_H
#define _OS__OSBYTEORDER_H

/*
 * This header is normally included from <libkern/OSByteOrder.h>.  However,
 * <sys/_endian.h> also includes this in the case of little-endian
 * architectures, so that we can map OSByteOrder routines to the hton* and ntoh*
 * macros.  This results in the asymmetry below; we only include
 * <libkern/arch/_OSByteOrder.h> for little-endian architectures.
 */

#include <sys/_types.h>

/* Macros for swapping constant values in the preprocessing stage. */
#define __DARWIN_OSSwapConstInt16(x) \
    ((__uint16_t)((((__uint16_t)(x) & 0xff00) >> 8) | \
                (((__uint16_t)(x) & 0x00ff) << 8)))

#define __DARWIN_OSSwapConstInt32(x) \
    ((__uint32_t)((((__uint32_t)(x) & 0xff000000) >> 24) | \
                (((__uint32_t)(x) & 0x00ff0000) >>  8) | \
                (((__uint32_t)(x) & 0x0000ff00) <<  8) | \
                (((__uint32_t)(x) & 0x000000ff) << 24)))

#define __DARWIN_OSSwapConstInt64(x) \
    ((__uint64_t)((((__uint64_t)(x) & 0xff00000000000000ULL) >> 56) | \
                (((__uint64_t)(x) & 0x00ff000000000000ULL) >> 40) | \
                (((__uint64_t)(x) & 0x0000ff0000000000ULL) >> 24) | \
                (((__uint64_t)(x) & 0x000000ff00000000ULL) >>  8) | \
                (((__uint64_t)(x) & 0x00000000ff000000ULL) <<  8) | \
                (((__uint64_t)(x) & 0x0000000000ff0000ULL) << 24) | \
                (((__uint64_t)(x) & 0x000000000000ff00ULL) << 40) | \
                (((__uint64_t)(x) & 0x00000000000000ffULL) << 56)))

#if defined(__GNUC__)

#if defined(__i386__) || defined(__x86_64__)
#include <libkern/i386/_OSByteOrder.h>
#endif

#if defined(__arm__) || defined(__arm64__)
#include <libkern/arm/OSByteOrder.h>
#endif


#define __DARWIN_OSSwapInt16(x) \
    (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt16(x) : _OSSwapInt16(x))

#define __DARWIN_OSSwapInt32(x) \
    (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt32(x) : _OSSwapInt32(x))

#define __DARWIN_OSSwapInt64(x) \
    (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt64(x) : _OSSwapInt64(x))

#else /* ! __GNUC__ */

#if defined(__i386__) || defined(__x86_64__)

#if !defined(__DARWIN_OS_INLINE)
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#        define __DARWIN_OS_INLINE static inline
# elif defined(__MWERKS__) || defined(__cplusplus)
#        define __DARWIN_OS_INLINE static inline
# else
#        define __DARWIN_OS_INLINE static __inline__
# endif
#endif

__DARWIN_OS_INLINE
uint16_t
_OSSwapInt16(
    uint16_t			data
)
{
    return __DARWIN_OSSwapConstInt16(data);
}

__DARWIN_OS_INLINE
uint32_t
_OSSwapInt32(
    uint32_t			data
)
{
    return __DARWIN_OSSwapConstInt32(data);
}

__DARWIN_OS_INLINE
uint64_t
_OSSwapInt64(
    uint64_t			data
)
{
    return __DARWIN_OSSwapConstInt64(data);
}
#endif

#define __DARWIN_OSSwapInt16(x) _OSSwapInt16(x)

#define __DARWIN_OSSwapInt32(x) _OSSwapInt32(x)

#define __DARWIN_OSSwapInt64(x) _OSSwapInt64(x)

#endif /* __GNUC__ */

#endif /* ! _OS__OSBYTEORDER_H */
                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/arm/                0040755 0001750 0001750 00000000000 12612724206 025724  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/arm/OSByteOrder.h   0100644 0001750 0001750 00000006072 12612724206 030240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _OS_OSBYTEORDERARM_H
#define _OS_OSBYTEORDERARM_H

#include <stdint.h>

#ifndef OS_INLINE
#define OS_INLINE static __inline__
#endif

OS_INLINE
uint16_t _OSSwapInt16(uint16_t data)
{
    return __builtin_bswap16(data);
}

OS_INLINE
uint32_t _OSSwapInt32(uint32_t data)
{
    return __builtin_bswap32(data);
}

OS_INLINE
uint64_t _OSSwapInt64(uint64_t data)
{
    return __builtin_bswap64(data);
}

/*
 * Copyright (c) 1999-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

OS_INLINE
uint16_t
OSReadSwapInt16(
    const volatile void   * base,
    uintptr_t       byteOffset
)
{
    uint16_t result;

    result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt16(result);
}

OS_INLINE
uint32_t
OSReadSwapInt32(
    const volatile void   * base,
    uintptr_t       byteOffset
)
{
    uint32_t result;

    result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt32(result);
}

OS_INLINE
uint64_t
OSReadSwapInt64(
    const volatile void   * base,
    uintptr_t       byteOffset
)
{
    uint64_t result;

    result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt64(result);
}

/* Functions for byte reversed stores. */

OS_INLINE
void
OSWriteSwapInt16(
    volatile void   * base,
    uintptr_t       byteOffset,
    uint16_t        data
)
{
    *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
}

OS_INLINE
void
OSWriteSwapInt32(
    volatile void   * base,
    uintptr_t       byteOffset,
    uint32_t        data
)
{
    *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
}

OS_INLINE
void
OSWriteSwapInt64(
    volatile void    * base,
    uintptr_t        byteOffset,
    uint64_t         data
)
{
    *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
}

#endif /* ! _OS_OSBYTEORDERARM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/arm/_OSByteOrder.h  0100644 0001750 0001750 00000006763 12612724206 030406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS__OSBYTEORDER_H
#define _OS__OSBYTEORDER_H

/*
 * This header is normally included from <libkern/OSByteOrder.h>.  However,
 * <sys/_endian.h> also includes this in the case of little-endian
 * architectures, so that we can map OSByteOrder routines to the hton* and ntoh*
 * macros.  This results in the asymmetry below; we only include
 * <libkern/arch/_OSByteOrder.h> for little-endian architectures.
 */

#include <sys/_types.h>

/* Macros for swapping constant values in the preprocessing stage. */
#define __DARWIN_OSSwapConstInt16(x) \
    ((__uint16_t)((((__uint16_t)(x) & 0xff00) >> 8) | \
                (((__uint16_t)(x) & 0x00ff) << 8)))

#define __DARWIN_OSSwapConstInt32(x) \
    ((__uint32_t)((((__uint32_t)(x) & 0xff000000) >> 24) | \
                (((__uint32_t)(x) & 0x00ff0000) >>  8) | \
                (((__uint32_t)(x) & 0x0000ff00) <<  8) | \
                (((__uint32_t)(x) & 0x000000ff) << 24)))

#define __DARWIN_OSSwapConstInt64(x) \
    ((__uint64_t)((((__uint64_t)(x) & 0xff00000000000000ULL) >> 56) | \
                (((__uint64_t)(x) & 0x00ff000000000000ULL) >> 40) | \
                (((__uint64_t)(x) & 0x0000ff0000000000ULL) >> 24) | \
                (((__uint64_t)(x) & 0x000000ff00000000ULL) >>  8) | \
                (((__uint64_t)(x) & 0x00000000ff000000ULL) <<  8) | \
                (((__uint64_t)(x) & 0x0000000000ff0000ULL) << 24) | \
                (((__uint64_t)(x) & 0x000000000000ff00ULL) << 40) | \
                (((__uint64_t)(x) & 0x00000000000000ffULL) << 56)))

#if defined(__GNUC__)


#if defined (__arm__) || defined(__arm64__)
#include <libkern/arm/OSByteOrder.h>
#endif


#define __DARWIN_OSSwapInt16(x) \
    ((__uint16_t)(__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt16(x) : _OSSwapInt16(x)))

#define __DARWIN_OSSwapInt32(x) \
    (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt32(x) : _OSSwapInt32(x))

#define __DARWIN_OSSwapInt64(x) \
    (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt64(x) : _OSSwapInt64(x))

#else /* ! __GNUC__ */


#define __DARWIN_OSSwapInt16(x) _OSSwapInt16(x)

#define __DARWIN_OSSwapInt32(x) _OSSwapInt32(x)

#define __DARWIN_OSSwapInt64(x) _OSSwapInt64(x)

#endif /* __GNUC__ */

#endif /* ! _OS__OSBYTEORDER_H */
             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/i386/               0040755 0001750 0001750 00000000000 12612724206 025636  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/i386/OSByteOrder.h  0100644 0001750 0001750 00000005615 12612724206 030154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS_OSBYTEORDERI386_H
#define _OS_OSBYTEORDERI386_H

#include <stdint.h>
#include <libkern/i386/_OSByteOrder.h>

#if !defined(OS_INLINE)
#define OS_INLINE	__DARWIN_OS_INLINE
#endif

/* Functions for byte reversed loads. */

OS_INLINE
uint16_t
OSReadSwapInt16(
    const volatile void   * base,
    uintptr_t       byteOffset
)
{
    uint16_t result;

    result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt16(result);
}

OS_INLINE
uint32_t
OSReadSwapInt32(
    const volatile void   * base,
    uintptr_t       byteOffset
)
{
    uint32_t result;

    result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt32(result);
}

OS_INLINE
uint64_t
OSReadSwapInt64(
    const volatile void   * base,
    uintptr_t       byteOffset
)
{
    uint64_t result;

    result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt64(result);
}

/* Functions for byte reversed stores. */

OS_INLINE
void
OSWriteSwapInt16(
    volatile void   * base,
    uintptr_t       byteOffset,
    uint16_t        data
)
{
    *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
}

OS_INLINE
void
OSWriteSwapInt32(
    volatile void   * base,
    uintptr_t       byteOffset,
    uint32_t        data
)
{
    *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
}

OS_INLINE
void
OSWriteSwapInt64(
    volatile void    * base,
    uintptr_t        byteOffset,
    uint64_t         data
)
{
    *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
}

#endif /* ! _OS_OSBYTEORDERI386_H */
                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/i386/_OSByteOrder.h 0100644 0001750 0001750 00000005247 12612724206 030314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS__OSBYTEORDERI386_H
#define _OS__OSBYTEORDERI386_H

#if !defined(__DARWIN_OS_INLINE)
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#        define __DARWIN_OS_INLINE static inline
# elif defined(__MWERKS__) || defined(__cplusplus)
#        define __DARWIN_OS_INLINE static inline
# else
#        define __DARWIN_OS_INLINE static __inline__
# endif
#endif

/* Generic byte swapping functions. */

__DARWIN_OS_INLINE
__uint16_t
_OSSwapInt16(
    __uint16_t        _data
)
{
    return ((_data << 8) | (_data >> 8));
}

__DARWIN_OS_INLINE
__uint32_t
_OSSwapInt32(
    __uint32_t        _data
)
{
#if defined(__llvm__)
    return __builtin_bswap32(_data);
#else
    __asm__ ("bswap   %0" : "+r" (_data));
    return _data;
#endif
}

#if defined(__llvm__)
__DARWIN_OS_INLINE
__uint64_t
_OSSwapInt64(
    __uint64_t        _data
)
{
    return __builtin_bswap64(_data);
}

#elif defined(__i386__)
__DARWIN_OS_INLINE
__uint64_t
_OSSwapInt64(
    __uint64_t        _data
)
{
    __asm__ ("bswap   %%eax\n\t"
             "bswap   %%edx\n\t" 
             "xchgl   %%eax, %%edx"
             : "+A" (_data));
    return _data;
}
#elif defined(__x86_64__)
__DARWIN_OS_INLINE
__uint64_t
_OSSwapInt64(
    __uint64_t        _data
)
{
    __asm__ ("bswap   %0" : "+r" (_data));
    return _data;
}
#else
#error Unknown architecture
#endif

#endif /* ! _OS__OSBYTEORDERI386_H */
                                                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/machine/            0040755 0001750 0001750 00000000000 12612724206 026551  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        OSByteOrder.h                                                                                       0100644 0001750 0001750 00000007126 12612724206 031007  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/machine                                                                                /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS_OSBYTEORDERMACHINE_H
#define _OS_OSBYTEORDERMACHINE_H

#include <stdint.h>

#if !defined(OS_INLINE)
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#        define OS_INLINE static inline
# elif defined(__MWERKS__) || defined(__cplusplus)
#        define OS_INLINE static inline
# else
#        define OS_INLINE static __inline__
# endif
#endif

/* Generic byte swapping functions. */

OS_INLINE
uint16_t
_OSSwapInt16(
    uint16_t                      data
)
{
    return OSSwapConstInt16(data);
}

OS_INLINE
uint32_t
_OSSwapInt32(
    uint32_t                      data
)
{
    return OSSwapConstInt32(data);
}

OS_INLINE
uint64_t
_OSSwapInt64(
    uint64_t                        data
)
{
    return OSSwapConstInt64(data);
}

/* Functions for byte reversed loads. */

OS_INLINE
uint16_t
OSReadSwapInt16(
    const volatile void               * base,
    uintptr_t                     byteOffset
)
{
    uint16_t data = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt16(data);
}

OS_INLINE
uint32_t
OSReadSwapInt32(
    const volatile void               * base,
    uintptr_t                     byteOffset
)
{
    uint32_t data = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt32(data);
}

OS_INLINE
uint64_t
OSReadSwapInt64(
    const volatile void               * base,
    uintptr_t                     byteOffset
)
{
    uint64_t data = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt64(data);
}

/* Functions for byte reversed stores. */

OS_INLINE
void
OSWriteSwapInt16(
    volatile void               * base,
    uintptr_t                     byteOffset,
    uint16_t                      data
)
{
    *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
}

OS_INLINE
void
OSWriteSwapInt32(
    volatile void               * base,
    uintptr_t                     byteOffset,
    uint32_t                      data
)
{
    *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
}

OS_INLINE
void
OSWriteSwapInt64(
    volatile void               * base,
    uintptr_t                     byteOffset,
    uint64_t                      data
)
{
    *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
}

#endif /* ! _OS_OSBYTEORDERMACHINE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/ppc/                0040755 0001750 0001750 00000000000 12612724206 025727  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libkern/ppc/OSByteOrder.h   0100644 0001750 0001750 00000011542 12612724206 030241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _OS_OSBYTEORDERPPC_H
#define _OS_OSBYTEORDERPPC_H

#include <stdint.h>

#if !defined(OS_INLINE)
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#        define OS_INLINE static inline
# elif defined(__MWERKS__) || defined(__cplusplus)
#        define OS_INLINE static inline
# else
#        define OS_INLINE static __inline__
# endif
#endif

/* Functions for byte reversed loads. */

OS_INLINE
uint16_t
OSReadSwapInt16(
    const volatile void * base,
    uintptr_t             byteOffset
)
{
    uint16_t result;
    volatile uint16_t *addr = (volatile uint16_t *)((uintptr_t)base + byteOffset);

#if defined(__llvm__)
    result = *addr;
    result = ((result << 8) | (result >> 8));
#else
    __asm__ ("lhbrx %0, %2, %1"
             : "=r" (result)
             : "r"  (base), "bO" (byteOffset), "m" (*addr));
#endif

    return result;
}

OS_INLINE
uint32_t
OSReadSwapInt32(
    const volatile void * base,
    uintptr_t             byteOffset
)
{
    uint32_t result;
    volatile uint32_t *addr = (volatile uint32_t *)((uintptr_t)base + byteOffset);

#if defined(__llvm__)
    result = __builtin_bswap32(*addr);
#else
    __asm__ ("lwbrx %0, %2, %1"
             : "=r" (result)
             : "r"  (base), "bO" (byteOffset), "m" (*addr));
#endif

    return result;
}

OS_INLINE
uint64_t
OSReadSwapInt64(
    const volatile void * base,
    uintptr_t             byteOffset
)
{
    volatile uint64_t *addr = (volatile uint64_t *)((uintptr_t)base + byteOffset);
    union {
        uint64_t u64;
        uint32_t u32[2];
    } u;

#if defined(__llvm__)
    u.u64 = __builtin_bswap64(*addr);
#else
    __asm__ ("lwbrx %0, %3, %2\n\t"
             "lwbrx %1, %4, %2"
             : "=&r" (u.u32[1]), "=r" (u.u32[0])
             : "r"  (base), "bO" (byteOffset), "b" (byteOffset + 4), "m" (*addr));
#endif

    return u.u64;
}

/* Functions for byte reversed stores. */

OS_INLINE
void
OSWriteSwapInt16(
    volatile void * base,
    uintptr_t       byteOffset,
    uint16_t        data
)
{
    volatile uint16_t *addr = (volatile uint16_t *)((uintptr_t)base + byteOffset);

#if defined(__llvm__)
    *addr = ((data >> 8) | (data << 8));
#else
    __asm__ ("sthbrx %1, %3, %2"
             : "=m" (*addr)
             : "r" (data), "r" (base), "bO" (byteOffset));
#endif
}

OS_INLINE
void
OSWriteSwapInt32(
    volatile void * base,
    uintptr_t       byteOffset,
    uint32_t        data
)
{
    volatile uint32_t *addr = (volatile uint32_t *)((uintptr_t)base + byteOffset);

#if defined(__llvm__)
    *addr = __builtin_bswap32(data);
#else
    __asm__ ("stwbrx %1, %3, %2"
             : "=m" (*addr)
             : "r" (data), "r" (base), "bO" (byteOffset));
#endif
}

OS_INLINE
void
OSWriteSwapInt64(
    volatile void * base,
    uintptr_t       byteOffset,
    uint64_t        data
)
{
    volatile uint64_t *addr = (volatile uint64_t *)((uintptr_t)base + byteOffset);

#if defined(__llvm__)
    *addr = __builtin_bswap64(data);
#else
    uint32_t hi = (uint32_t)(data >> 32);
    uint32_t lo = (uint32_t)(data & 0xffffffff);

    __asm__ ("stwbrx %1, %4, %3\n\t"
             "stwbrx %2, %5, %3"
             : "=m" (*addr)
             : "r" (lo), "r" (hi), "r" (base), "bO" (byteOffset), "b" (byteOffset + 4));
#endif
}

/* Generic byte swapping functions. */

OS_INLINE
uint16_t
_OSSwapInt16(
    uint16_t data
)
{
    return OSReadSwapInt16(&data, 0);
}

OS_INLINE
uint32_t
_OSSwapInt32(
    uint32_t data
)
{
    return OSReadSwapInt32(&data, 0);
}

OS_INLINE
uint64_t
_OSSwapInt64(
    uint64_t data
)
{
    return OSReadSwapInt64(&data, 0);
}

#endif /* ! _OS_OSBYTEORDERPPC_H */
                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/libunwind.h                 0100644 0001750 0001750 00000021305 12612724206 025661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C; c-basic-offset: 4; -*- 
 *
 * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 * 
 * 
 *            C interface to libuwind 
 *
 * Source compatible with libuwind API documented at:
 *    http://www.nongnu.org/libunwind/man/libunwind(3).html
 * 
 */


#ifndef __LIBUNWIND__
#define __LIBUNWIND__

#include <stdint.h>
#include <stddef.h>
#include <mach/mach_types.h>

/* error codes */
enum {
    UNW_ESUCCESS           = 0,            /* no error */
    UNW_EUNSPEC            = -6540,        /* unspecified (general) error */
    UNW_ENOMEM             = -6541,        /* out of memory */
    UNW_EBADREG            = -6542,        /* bad register number */
    UNW_EREADONLYREG       = -6543,        /* attempt to write read-only register */
    UNW_ESTOPUNWIND        = -6544,        /* stop unwinding */
    UNW_EINVALIDIP         = -6545,        /* invalid IP */
    UNW_EBADFRAME          = -6546,        /* bad frame */
    UNW_EINVAL             = -6547,        /* unsupported operation or bad value */
    UNW_EBADVERSION        = -6548,        /* unwind info has unsupported version */
    UNW_ENOINFO            = -6549         /* no unwind info found */
};


struct unw_context_t { uint64_t data[128]; };
typedef struct unw_context_t     unw_context_t;

struct unw_cursor_t { uint64_t data[140]; };
typedef struct unw_cursor_t      unw_cursor_t;

typedef struct unw_addr_space*   unw_addr_space_t;

typedef int                      unw_regnum_t;
typedef uint64_t                 unw_word_t;
typedef double                   unw_fpreg_t;

struct unw_proc_info_t
{
    unw_word_t    start_ip;         /* start address of function */
    unw_word_t    end_ip;           /* address after end of function */
    unw_word_t    lsda;             /* address of language specific data area, or zero if not used */
    unw_word_t    handler;          /* personality routine, or zero if not used */
    unw_word_t    gp;               /* not used */
    unw_word_t    flags;            /* not used */
    uint32_t      format;           /* compact unwind encoding, or zero if none */
    uint32_t      unwind_info_size; /* size of dwarf unwind info, or zero if none */
    unw_word_t    unwind_info;      /* address of dwarf unwind info, or zero if none */
    unw_word_t    extra;            /* mach_header of mach-o image containing function */
};
typedef struct unw_proc_info_t unw_proc_info_t;


#ifdef __cplusplus
extern "C" {
#endif

#if !__arm__
extern int         unw_getcontext(unw_context_t*)                               ;
extern int         unw_init_local(unw_cursor_t*, unw_context_t*)                ;
extern int         unw_step(unw_cursor_t*)                                      ;
extern int         unw_get_reg(unw_cursor_t*, unw_regnum_t, unw_word_t*)        ;
extern int         unw_get_fpreg(unw_cursor_t*, unw_regnum_t, unw_fpreg_t*)     ;
extern int         unw_set_reg(unw_cursor_t*, unw_regnum_t, unw_word_t)         ;
extern int         unw_set_fpreg(unw_cursor_t*, unw_regnum_t, unw_fpreg_t)      ;
extern int         unw_resume(unw_cursor_t*)                                    ;

extern const char* unw_regname(unw_cursor_t*, unw_regnum_t)                     ;
extern int         unw_get_proc_info(unw_cursor_t*, unw_proc_info_t*)           ;
extern int         unw_is_fpreg(unw_cursor_t*, unw_regnum_t)                    ;
extern int         unw_is_signal_frame(unw_cursor_t*)                           ;
extern int         unw_get_proc_name(unw_cursor_t*, char*, size_t, unw_word_t*) ;
//extern int       unw_get_save_loc(unw_cursor_t*, int, unw_save_loc_t*);
#endif


#if UNW_REMOTE
/* 
 * Mac OS X "remote" API for unwinding other processes on same machine
 *
 */
extern unw_addr_space_t    unw_local_addr_space;
extern unw_addr_space_t    unw_create_addr_space_for_task(task_t);
extern void                unw_destroy_addr_space(unw_addr_space_t);
extern int                 unw_init_remote_thread(unw_cursor_t*, unw_addr_space_t, thread_t*);
#endif


/* 
 * traditional libuwind "remote" API 
 *   NOT IMPLEMENTED on Mac OS X
 *
 * extern int               unw_init_remote(unw_cursor_t*, unw_addr_space_t, thread_t*);
 * extern unw_accessors_t   unw_get_accessors(unw_addr_space_t);
 * extern unw_addr_space_t  unw_create_addr_space(unw_accessors_t, int);
 * extern void              unw_flush_cache(unw_addr_space_t, unw_word_t, unw_word_t);
 * extern int               unw_set_caching_policy(unw_addr_space_t, unw_caching_policy_t);
 * extern void              _U_dyn_register(unw_dyn_info_t*);
 * extern void              _U_dyn_cancel(unw_dyn_info_t*);
 */


#ifdef __cplusplus
}
#endif


// architecture independent register numbers 
enum {
    UNW_REG_IP = -1,        // instruction pointer
    UNW_REG_SP = -2,        // stack pointer
};


// 32-bit x86 registers
enum {
    UNW_X86_EAX = 0,
    UNW_X86_ECX = 1,
    UNW_X86_EDX = 2,
    UNW_X86_EBX = 3,
    UNW_X86_EBP = 4,
    UNW_X86_ESP = 5,
    UNW_X86_ESI = 6,
    UNW_X86_EDI = 7
};


// 64-bit x86_64 registers
enum {
    UNW_X86_64_RAX =  0,
    UNW_X86_64_RDX =  1,
    UNW_X86_64_RCX =  2,
    UNW_X86_64_RBX =  3,
    UNW_X86_64_RSI =  4,
    UNW_X86_64_RDI =  5,
    UNW_X86_64_RBP =  6,
    UNW_X86_64_RSP =  7,
    UNW_X86_64_R8  =  8,
    UNW_X86_64_R9  =  9,
    UNW_X86_64_R10 = 10,
    UNW_X86_64_R11 = 11,
    UNW_X86_64_R12 = 12,
    UNW_X86_64_R13 = 13,
    UNW_X86_64_R14 = 14,
    UNW_X86_64_R15 = 15
};


// 32-bit ppc register numbers
enum {
    UNW_PPC_R0  =  0,
    UNW_PPC_R1  =  1,
    UNW_PPC_R2  =  2,
    UNW_PPC_R3  =  3,
    UNW_PPC_R4  =  4,
    UNW_PPC_R5  =  5,
    UNW_PPC_R6  =  6,
    UNW_PPC_R7  =  7,
    UNW_PPC_R8  =  8,
    UNW_PPC_R9  =  9,
    UNW_PPC_R10 = 10,
    UNW_PPC_R11 = 11,
    UNW_PPC_R12 = 12,
    UNW_PPC_R13 = 13,
    UNW_PPC_R14 = 14,
    UNW_PPC_R15 = 15,
    UNW_PPC_R16 = 16,
    UNW_PPC_R17 = 17,
    UNW_PPC_R18 = 18,
    UNW_PPC_R19 = 19,
    UNW_PPC_R20 = 20,
    UNW_PPC_R21 = 21,
    UNW_PPC_R22 = 22,
    UNW_PPC_R23 = 23,
    UNW_PPC_R24 = 24,
    UNW_PPC_R25 = 25,
    UNW_PPC_R26 = 26,
    UNW_PPC_R27 = 27,
    UNW_PPC_R28 = 28,
    UNW_PPC_R29 = 29,
    UNW_PPC_R30 = 30,
    UNW_PPC_R31 = 31,
    UNW_PPC_F0  = 32,
    UNW_PPC_F1  = 33,
    UNW_PPC_F2  = 34,
    UNW_PPC_F3  = 35,
    UNW_PPC_F4  = 36,
    UNW_PPC_F5  = 37,
    UNW_PPC_F6  = 38,
    UNW_PPC_F7  = 39,
    UNW_PPC_F8  = 40,
    UNW_PPC_F9  = 41,
    UNW_PPC_F10 = 42,
    UNW_PPC_F11 = 43,
    UNW_PPC_F12 = 44,
    UNW_PPC_F13 = 45,
    UNW_PPC_F14 = 46,
    UNW_PPC_F15 = 47,
    UNW_PPC_F16 = 48,
    UNW_PPC_F17 = 49,
    UNW_PPC_F18 = 50,
    UNW_PPC_F19 = 51,
    UNW_PPC_F20 = 52,
    UNW_PPC_F21 = 53,
    UNW_PPC_F22 = 54,
    UNW_PPC_F23 = 55,
    UNW_PPC_F24 = 56,
    UNW_PPC_F25 = 57,
    UNW_PPC_F26 = 58,
    UNW_PPC_F27 = 59,
    UNW_PPC_F28 = 60,
    UNW_PPC_F29 = 61,
    UNW_PPC_F30 = 62,
    UNW_PPC_F31 = 63,
    UNW_PPC_MQ  = 64,
    UNW_PPC_LR  = 65,
    UNW_PPC_CTR = 66,
    UNW_PPC_AP  = 67,
	UNW_PPC_CR0 = 68,
    UNW_PPC_CR1 = 69,
	UNW_PPC_CR2 = 70,
	UNW_PPC_CR3 = 71,
	UNW_PPC_CR4 = 72,
	UNW_PPC_CR5 = 73,
	UNW_PPC_CR6 = 74,
	UNW_PPC_CR7 = 75,
	UNW_PPC_XER = 76,
	UNW_PPC_V0  = 77,
    UNW_PPC_V1  = 78,
    UNW_PPC_V2  = 79,
    UNW_PPC_V3  = 80,
    UNW_PPC_V4  = 81,
    UNW_PPC_V5  = 82,
    UNW_PPC_V6  = 83,
    UNW_PPC_V7  = 84,
    UNW_PPC_V8  = 85,
    UNW_PPC_V9  = 86,
    UNW_PPC_V10 = 87,
    UNW_PPC_V11 = 88,
    UNW_PPC_V12 = 89,
    UNW_PPC_V13 = 90,
    UNW_PPC_V14 = 91,
    UNW_PPC_V15 = 92,
    UNW_PPC_V16 = 93,
    UNW_PPC_V17 = 94,
    UNW_PPC_V18 = 95,
    UNW_PPC_V19 = 96,
    UNW_PPC_V20 = 97,
    UNW_PPC_V21 = 98,
    UNW_PPC_V22 = 99,
    UNW_PPC_V23 = 100,
    UNW_PPC_V24 = 101,
    UNW_PPC_V25 = 102,
    UNW_PPC_V26 = 103,
    UNW_PPC_V27 = 104,
    UNW_PPC_V28 = 105,
    UNW_PPC_V29 = 106,
    UNW_PPC_V30 = 107,
    UNW_PPC_V31 = 108,
    UNW_PPC_VRSAVE  = 109,
    UNW_PPC_VSCR    = 110,
    UNW_PPC_SPE_ACC = 111,
    UNW_PPC_SPEFSCR = 112
	
};




#endif

                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/                       0040755 0001750 0001750 00000000000 12612724206 024427  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/arm                    0120777 0001750 0001750 00000000000 12612724206 025620  2i386/                                                                                               ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/audit_triggers.defs    0100644 0001750 0001750 00000003633 12612724206 030310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2008, Apple Inc.  All rights reserved.
 * 
 * @APPLE_BSD_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * @APPLE_BSD_LICENSE_HEADER_END@
*/

/*
 *  Interface definition for the audit logging facility.
 */

subsystem
#if	KERNEL_USER
    KernelUser
#endif	/* KERNEL_USER */
    audit_triggers 123;

#include <mach/std_types.defs>
#include <mach/mach_types.defs>

simpleroutine	audit_triggers(
		audit_port	: mach_port_t; 
	in	flags		: int);

                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/boolean.h              0100644 0001750 0001750 00000005410 12612724206 026214  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	File:	mach/boolean.h
 *
 *	Boolean data type.
 *
 */

#ifndef	_MACH_BOOLEAN_H_
#define	_MACH_BOOLEAN_H_

/*
 *	Pick up "boolean_t" type definition
 */

#ifndef	ASSEMBLER
#include <mach/machine/boolean.h>
#endif	/* ASSEMBLER */

/*
 *	Define TRUE and FALSE if not defined.
 */

#ifndef	TRUE
#define TRUE	1
#endif	/* TRUE */

#ifndef	FALSE
#define FALSE	0
#endif	/* FALSE */

#endif	/* _MACH_BOOLEAN_H_ */
                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/bootstrap.h            0100644 0001750 0001750 00000002744 12612724206 026621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Mach bootstrap interfaces (obsolete: header included only for compatibility)
 */
#ifndef	_MACH_BOOTSTRAP_H_
#define _MACH_BOOTSTRAP_H_

#endif /* _MACH_BOOTSTRAP_H_ */
                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock.defs             0100644 0001750 0001750 00000004626 12612724206 026372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/*
 * 	File:		mach/clock.defs
 *	Purpose:	Kernel clock subsystem definitions. This
 *			file defines the clock request interface.
 */

subsystem
#if	KERNEL_SERVER
	  KernelServer
#endif	/* KERNEL_SERVER */
		       clock 1000;

#include <mach/std_types.defs>
#include <mach/mach_types.defs>
#include <mach/clock_types.defs>

/*
 * References to clock objects are returned by:
 *	host_get_clock_service(host_t,...)
 *	host_get_clock_control(host_priv_t,...) - Priviledged subclass
 */

/*
 *	Get the clock time.
 *	Available to all.
 */
routine	clock_get_time(
		clock_serv	: clock_serv_t;
	out	cur_time	: mach_timespec_t);

/*
 *	Get clock attributes.
 *	Available to all.
 */
routine	clock_get_attributes(
		clock_serv	: clock_serv_t;
	in	flavor		: clock_flavor_t;
	out	clock_attr	: clock_attr_t, CountInOut);

/*
 *	Setup a clock alarm.
 *	Available to all.
 */
routine clock_alarm(
		clock_serv	: clock_serv_t;
		alarm_type	: alarm_type_t;
		alarm_time	: mach_timespec_t;
                alarm_port      : clock_reply_t =
			MACH_MSG_TYPE_MAKE_SEND_ONCE|polymorphic);

/* vim: set ft=c : */
                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock.h                0100644 0001750 0001750 00000012146 12612724206 025674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_clock_user_
#define	_clock_user_

/* Module clock */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	clock_MSG_COUNT
#define	clock_MSG_COUNT	3
#endif	/* clock_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine clock_get_time */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t clock_get_time
(
	clock_serv_t clock_serv,
	mach_timespec_t *cur_time
);

/* Routine clock_get_attributes */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t clock_get_attributes
(
	clock_serv_t clock_serv,
	clock_flavor_t flavor,
	clock_attr_t clock_attr,
	mach_msg_type_number_t *clock_attrCnt
);

/* Routine clock_alarm */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t clock_alarm
(
	clock_serv_t clock_serv,
	alarm_type_t alarm_type,
	mach_timespec_t alarm_time,
	clock_reply_t alarm_port
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__clock_subsystem__defined
#define __Request__clock_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__clock_get_time_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		clock_flavor_t flavor;
		mach_msg_type_number_t clock_attrCnt;
	} __Request__clock_get_attributes_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t alarm_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		alarm_type_t alarm_type;
		mach_timespec_t alarm_time;
	} __Request__clock_alarm_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__clock_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__clock_subsystem__defined
#define __RequestUnion__clock_subsystem__defined
union __RequestUnion__clock_subsystem {
	__Request__clock_get_time_t Request_clock_get_time;
	__Request__clock_get_attributes_t Request_clock_get_attributes;
	__Request__clock_alarm_t Request_clock_alarm;
};
#endif /* !__RequestUnion__clock_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__clock_subsystem__defined
#define __Reply__clock_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_timespec_t cur_time;
	} __Reply__clock_get_time_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t clock_attrCnt;
		int clock_attr[1];
	} __Reply__clock_get_attributes_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__clock_alarm_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__clock_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__clock_subsystem__defined
#define __ReplyUnion__clock_subsystem__defined
union __ReplyUnion__clock_subsystem {
	__Reply__clock_get_time_t Reply_clock_get_time;
	__Reply__clock_get_attributes_t Reply_clock_get_attributes;
	__Reply__clock_alarm_t Reply_clock_alarm;
};
#endif /* !__RequestUnion__clock_subsystem__defined */

#ifndef subsystem_to_name_map_clock
#define subsystem_to_name_map_clock \
    { "clock_get_time", 1000 },\
    { "clock_get_attributes", 1001 },\
    { "clock_alarm", 1002 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _clock_user_ */
                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock_priv.defs        0100644 0001750 0001750 00000004137 12612724206 027427  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/*
 * 	File:		mach/clock_priv.defs
 *	Purpose:	Kernel clock subsystem definitions. This
 *			file defines the clock request interface.
 */

subsystem
#if	KERNEL_SERVER
	  KernelServer
#endif	/* KERNEL_SERVER */
		       clock_priv 1200;

#include <mach/std_types.defs>
#include <mach/mach_types.defs>
#include <mach/clock_types.defs>

/*
 * References to clock_priv objects are returned by:
 *	host_get_clock_control(host_priv_t,...) - Priviledged subclass
 */

/*
 *	Set the clock time.
 *	Privileged.
 */
routine	clock_set_time(
		clock_ctrl	: clock_ctrl_t;
		new_time	: mach_timespec_t);

/*
 *	Set clock attributes.
 *	Privileged.
 */
routine	clock_set_attributes(
		clock_ctrl	: clock_ctrl_t;
	in	flavor		: clock_flavor_t;
	in	clock_attr	: clock_attr_t);

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock_priv.h           0100644 0001750 0001750 00000010372 12612724206 026733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_clock_priv_user_
#define	_clock_priv_user_

/* Module clock_priv */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	clock_priv_MSG_COUNT
#define	clock_priv_MSG_COUNT	2
#endif	/* clock_priv_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine clock_set_time */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t clock_set_time
(
	clock_ctrl_t clock_ctrl,
	mach_timespec_t new_time
);

/* Routine clock_set_attributes */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t clock_set_attributes
(
	clock_ctrl_t clock_ctrl,
	clock_flavor_t flavor,
	clock_attr_t clock_attr,
	mach_msg_type_number_t clock_attrCnt
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__clock_priv_subsystem__defined
#define __Request__clock_priv_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_timespec_t new_time;
	} __Request__clock_set_time_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		clock_flavor_t flavor;
		mach_msg_type_number_t clock_attrCnt;
		int clock_attr[1];
	} __Request__clock_set_attributes_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__clock_priv_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__clock_priv_subsystem__defined
#define __RequestUnion__clock_priv_subsystem__defined
union __RequestUnion__clock_priv_subsystem {
	__Request__clock_set_time_t Request_clock_set_time;
	__Request__clock_set_attributes_t Request_clock_set_attributes;
};
#endif /* !__RequestUnion__clock_priv_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__clock_priv_subsystem__defined
#define __Reply__clock_priv_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__clock_set_time_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__clock_set_attributes_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__clock_priv_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__clock_priv_subsystem__defined
#define __ReplyUnion__clock_priv_subsystem__defined
union __ReplyUnion__clock_priv_subsystem {
	__Reply__clock_set_time_t Reply_clock_set_time;
	__Reply__clock_set_attributes_t Reply_clock_set_attributes;
};
#endif /* !__RequestUnion__clock_priv_subsystem__defined */

#ifndef subsystem_to_name_map_clock_priv
#define subsystem_to_name_map_clock_priv \
    { "clock_set_time", 1200 },\
    { "clock_set_attributes", 1201 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _clock_priv_user_ */
                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock_reply.defs       0100644 0001750 0001750 00000003605 12612724206 027601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/*
 *	File:		clock_reply.defs
 *	Purpose:	Kernel clock subsystem definitions. This
 *			file defines the clock reply interface.
 */

subsystem
#if	KERNEL_USER
	  KernelUser
#endif	/* KERNEL_USER */
		     clock_reply 3125107;  /* Matches up with old value */

#include <mach/std_types.defs>
#include <mach/clock_types.defs>


/*
 *	Reply routine for clock_alarm. 
 */
simpleroutine clock_alarm_reply(
                alarm_port      : clock_reply_t;
		alarm_code	: kern_return_t;
		alarm_type	: alarm_type_t;
		alarm_time	: mach_timespec_t);

/* vim: set ft=c : */
                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock_reply.h          0100644 0001750 0001750 00000007013 12612724206 027104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_clock_reply_user_
#define	_clock_reply_user_

/* Module clock_reply */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	clock_reply_MSG_COUNT
#define	clock_reply_MSG_COUNT	1
#endif	/* clock_reply_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* SimpleRoutine clock_alarm_reply */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t clock_alarm_reply
(
	clock_reply_t alarm_port,
	mach_msg_type_name_t alarm_portPoly,
	kern_return_t alarm_code,
	alarm_type_t alarm_type,
	mach_timespec_t alarm_time
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__clock_reply_subsystem__defined
#define __Request__clock_reply_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t alarm_code;
		alarm_type_t alarm_type;
		mach_timespec_t alarm_time;
	} __Request__clock_alarm_reply_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__clock_reply_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__clock_reply_subsystem__defined
#define __RequestUnion__clock_reply_subsystem__defined
union __RequestUnion__clock_reply_subsystem {
	__Request__clock_alarm_reply_t Request_clock_alarm_reply;
};
#endif /* !__RequestUnion__clock_reply_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__clock_reply_subsystem__defined
#define __Reply__clock_reply_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__clock_alarm_reply_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__clock_reply_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__clock_reply_subsystem__defined
#define __ReplyUnion__clock_reply_subsystem__defined
union __ReplyUnion__clock_reply_subsystem {
	__Reply__clock_alarm_reply_t Reply_clock_alarm_reply;
};
#endif /* !__RequestUnion__clock_reply_subsystem__defined */

#ifndef subsystem_to_name_map_clock_reply
#define subsystem_to_name_map_clock_reply \
    { "clock_alarm_reply", 3125107 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _clock_reply_user_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock_types.defs       0100644 0001750 0001750 00000004522 12612724206 027611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/*
 *	File:		clock_types.defs
 *	Purpose:
 *		Clock kernel interface type declarations
 */

#ifndef	_MACH_CLOCK_TYPES_DEFS_
#define _MACH_CLOCK_TYPES_DEFS_

#include <mach/std_types.defs>

type clock_serv_t = mach_port_t
		cusertype: clock_serv_t
#if	KERNEL_SERVER
		intran: clock_serv_t convert_port_to_clock(mach_port_t)
		outtran: mach_port_t convert_clock_to_port(clock_serv_t)
#endif	/* KERNEL_SERVER */
		;

type clock_ctrl_t = mach_port_t
		cusertype: clock_ctrl_t
#if	KERNEL_SERVER
		intran: clock_ctrl_t convert_port_to_clock_ctrl(mach_port_t)
		outtran: mach_port_t convert_clock_ctrl_to_port(clock_ctrl_t)
#endif	/* KERNEL_SERVER */
		;

type clock_reply_t = polymorphic|MACH_MSG_TYPE_MAKE_SEND_ONCE;

type clock_flavor_t = int;
type clock_attr_t = array[*:1] of int;
type mach_timespec_t	= struct[2] of int;
type time_t = int;
type sleep_type_t = int;
type alarm_type_t = int;
type clock_res_t = int;
type clock_id_t = int;

import <mach/mach_types.h>;

#endif	/* _MACH_CLOCK_TYPES_DEFS_ */

/* vim: set ft=c : */
                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/clock_types.h          0100644 0001750 0001750 00000007726 12612724206 027130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/*
 *	File:		clock_types.h
 *	Purpose:	Clock facility header definitions. These
 *				definitons are needed by both kernel and
 *				user-level software.
 */

/*
 *	All interfaces defined here are obsolete.
 */

#ifndef	_MACH_CLOCK_TYPES_H_
#define	_MACH_CLOCK_TYPES_H_

#include <stdint.h>
#include <mach/time_value.h>

/*
 * Type definitions.
 */
typedef	int	alarm_type_t;		/* alarm time type */
typedef int	sleep_type_t;		/* sleep time type */
typedef	int	clock_id_t;			/* clock identification type */
typedef int	clock_flavor_t;		/* clock flavor type */
typedef int	*clock_attr_t;		/* clock attribute type */
typedef int	clock_res_t;		/* clock resolution type */

/*
 * Normal time specification used by the kernel clock facility.
 */
struct mach_timespec {
	unsigned int	tv_sec;			/* seconds */
	clock_res_t		tv_nsec;		/* nanoseconds */
};
typedef struct mach_timespec	mach_timespec_t;

/*
 * Reserved clock id values for default clocks.
 */
#define SYSTEM_CLOCK		0
#define CALENDAR_CLOCK		1

#define REALTIME_CLOCK		0

/*
 * Attribute names.
 */
#define	CLOCK_GET_TIME_RES	1	/* get_time call resolution */
/*							2	 * was map_time call resolution */
#define CLOCK_ALARM_CURRES	3	/* current alarm resolution */
#define CLOCK_ALARM_MINRES	4	/* minimum alarm resolution */
#define CLOCK_ALARM_MAXRES	5	/* maximum alarm resolution */

#define NSEC_PER_USEC	1000		/* nanoseconds per microsecond */
#define USEC_PER_SEC	1000000		/* microseconds per second */
#define NSEC_PER_SEC	1000000000	/* nanoseconds per second */

#define BAD_MACH_TIMESPEC(t)						\
	((t)->tv_nsec < 0 || (t)->tv_nsec >= NSEC_PER_SEC)

/* t1 <=> t2, also (t1 - t2) in nsec with max of +- 1 sec */
#define CMP_MACH_TIMESPEC(t1, t2)					\
	((t1)->tv_sec > (t2)->tv_sec ? +NSEC_PER_SEC :	\
	((t1)->tv_sec < (t2)->tv_sec ? -NSEC_PER_SEC :	\
			(t1)->tv_nsec - (t2)->tv_nsec))

/* t1  += t2 */
#define ADD_MACH_TIMESPEC(t1, t2)								\
  do {															\
	if (((t1)->tv_nsec += (t2)->tv_nsec) >= NSEC_PER_SEC) {		\
		(t1)->tv_nsec -= NSEC_PER_SEC;							\
		(t1)->tv_sec  += 1;										\
	}															\
	(t1)->tv_sec += (t2)->tv_sec;								\
  } while (0)

/* t1  -= t2 */
#define SUB_MACH_TIMESPEC(t1, t2)								\
  do {															\
	if (((t1)->tv_nsec -= (t2)->tv_nsec) < 0) {					\
		(t1)->tv_nsec += NSEC_PER_SEC;							\
		(t1)->tv_sec  -= 1;										\
	}															\
	(t1)->tv_sec -= (t2)->tv_sec;								\
  } while (0)

/*
 * Alarm parameter defines.
 */
#define ALRMTYPE			0xff		/* type (8-bit field)	*/
#define TIME_ABSOLUTE		0x00		/* absolute time */
#define	TIME_RELATIVE		0x01		/* relative time */

#define BAD_ALRMTYPE(t)		(((t) &~ TIME_RELATIVE) != 0)

#endif /* _MACH_CLOCK_TYPES_H_ */
                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/error.h                0100644 0001750 0001750 00000007442 12612724206 025735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 * File:	mach/error.h
 * Purpose:
 *	error module definitions
 *
 */

#ifndef	_MACH_ERROR_H_
#define	_MACH_ERROR_H_

#include <mach/kern_return.h>

/*
 *	error number layout as follows:
 *
 *	hi		 		       lo
 *	| system(6) | subsystem(12) | code(14) |
 */


#define	err_none		(mach_error_t)0
#define ERR_SUCCESS		(mach_error_t)0
#define	ERR_ROUTINE_NIL		(mach_error_fn_t)0


#define	err_system(x)		(((x)&0x3f)<<26)
#define err_sub(x)		(((x)&0xfff)<<14)

#define err_get_system(err)	(((err)>>26)&0x3f)
#define err_get_sub(err)	(((err)>>14)&0xfff)
#define err_get_code(err)	((err)&0x3fff)

#define system_emask		(err_system(0x3f))
#define sub_emask		(err_sub(0xfff))
#define code_emask		(0x3fff)


/*	major error systems	*/
#define	err_kern		err_system(0x0)		/* kernel */
#define	err_us			err_system(0x1)		/* user space library */
#define	err_server		err_system(0x2)		/* user space servers */
#define	err_ipc			err_system(0x3)		/* old ipc errors */
#define err_mach_ipc		err_system(0x4)		/* mach-ipc errors */
#define	err_dipc		err_system(0x7)		/* distributed ipc */
#define err_local		err_system(0x3e)	/* user defined errors */
#define	err_ipc_compat		err_system(0x3f)	/* (compatibility) mach-ipc errors */

#define	err_max_system		0x3f


/*	unix errors get lumped into one subsystem  */
#define	unix_err(errno)		(err_kern|err_sub(3)|errno)

typedef	kern_return_t	mach_error_t;
typedef mach_error_t	(* mach_error_fn_t)( void );

#endif	/* _MACH_ERROR_H_ */
                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/exc.defs               0100644 0001750 0001750 00000007567 12612724206 026065  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 * Abstract:
 *	MiG definitions file for Mach exception interface.
 */

subsystem
#if	KERNEL_USER
	  KernelUser
#endif
		     exc 2401;

#include <mach/std_types.defs>
#include <mach/mach_types.defs>

ServerPrefix catch_;

type exception_data_t		= array[*:2] of integer_t;
type exception_type_t		= int;

routine		exception_raise(
#if	KERNEL_USER
			exception_port	: mach_port_move_send_t;
			thread		: mach_port_move_send_t;
			task		: mach_port_move_send_t;
#else	/* KERNEL_USER */
			exception_port	: mach_port_t;
			thread		: mach_port_t;
			task		: mach_port_t;
#endif	/* KERNEL_USER */
			exception	: exception_type_t;
			code		: exception_data_t
			);

routine		exception_raise_state(
#if	KERNEL_USER
			exception_port	: mach_port_move_send_t;
#else	/* KERNEL_USER */
			exception_port	: mach_port_t;
#endif	/* KERNEL_USER */
			exception	: exception_type_t;
			code		: exception_data_t, const;
		  inout flavor		: int;
			old_state	: thread_state_t, const;
		    out new_state	: thread_state_t);

routine		exception_raise_state_identity(
#if	KERNEL_USER
			exception_port  : mach_port_move_send_t;
			thread		: mach_port_move_send_t;
			task		: mach_port_move_send_t;
#else	/* KERNEL_USER */
			exception_port  : mach_port_t;
			thread          : mach_port_t;
			task            : mach_port_t;
#endif	/* KERNEL_USER */
			exception       : exception_type_t;
			code            : exception_data_t;
		  inout flavor          : int;
			old_state       : thread_state_t;
		    out new_state       : thread_state_t);

/* vim: set ft=c : */
                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/exc.h                  0100644 0001750 0001750 00000014365 12612724206 025365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_exc_user_
#define	_exc_user_

/* Module exc */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	exc_MSG_COUNT
#define	exc_MSG_COUNT	3
#endif	/* exc_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine exception_raise */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t exception_raise
(
	mach_port_t exception_port,
	mach_port_t thread,
	mach_port_t task,
	exception_type_t exception,
	exception_data_t code,
	mach_msg_type_number_t codeCnt
);

/* Routine exception_raise_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t exception_raise_state
(
	mach_port_t exception_port,
	exception_type_t exception,
	const exception_data_t code,
	mach_msg_type_number_t codeCnt,
	int *flavor,
	const thread_state_t old_state,
	mach_msg_type_number_t old_stateCnt,
	thread_state_t new_state,
	mach_msg_type_number_t *new_stateCnt
);

/* Routine exception_raise_state_identity */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t exception_raise_state_identity
(
	mach_port_t exception_port,
	mach_port_t thread,
	mach_port_t task,
	exception_type_t exception,
	exception_data_t code,
	mach_msg_type_number_t codeCnt,
	int *flavor,
	thread_state_t old_state,
	mach_msg_type_number_t old_stateCnt,
	thread_state_t new_state,
	mach_msg_type_number_t *new_stateCnt
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__exc_subsystem__defined
#define __Request__exc_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		integer_t code[2];
	} __Request__exception_raise_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		integer_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[144];
	} __Request__exception_raise_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		integer_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[144];
	} __Request__exception_raise_state_identity_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__exc_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__exc_subsystem__defined
#define __RequestUnion__exc_subsystem__defined
union __RequestUnion__exc_subsystem {
	__Request__exception_raise_t Request_exception_raise;
	__Request__exception_raise_state_t Request_exception_raise_state;
	__Request__exception_raise_state_identity_t Request_exception_raise_state_identity;
};
#endif /* !__RequestUnion__exc_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__exc_subsystem__defined
#define __Reply__exc_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__exception_raise_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[144];
	} __Reply__exception_raise_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[144];
	} __Reply__exception_raise_state_identity_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__exc_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__exc_subsystem__defined
#define __ReplyUnion__exc_subsystem__defined
union __ReplyUnion__exc_subsystem {
	__Reply__exception_raise_t Reply_exception_raise;
	__Reply__exception_raise_state_t Reply_exception_raise_state;
	__Reply__exception_raise_state_identity_t Reply_exception_raise_state_identity;
};
#endif /* !__RequestUnion__exc_subsystem__defined */

#ifndef subsystem_to_name_map_exc
#define subsystem_to_name_map_exc \
    { "exception_raise", 2401 },\
    { "exception_raise_state", 2402 },\
    { "exception_raise_state_identity", 2403 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _exc_user_ */
                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/exception.h            0100644 0001750 0001750 00000004742 12612724206 026602  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#ifndef	_MACH_EXCEPTION_H_
#define	_MACH_EXCEPTION_H_

#include <mach/exception_types.h>

#endif	/* _MACH_EXCEPTION_H_ */
                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/exception_types.h      0100644 0001750 0001750 00000013746 12612724206 030032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_MACH_EXCEPTION_TYPES_H_
#define	_MACH_EXCEPTION_TYPES_H_

#include <mach/machine/exception.h>

/*
 *	Machine-independent exception definitions.
 */

#define EXC_BAD_ACCESS		1	/* Could not access memory */
		/* Code contains kern_return_t describing error. */
		/* Subcode contains bad memory address. */

#define EXC_BAD_INSTRUCTION	2	/* Instruction failed */
		/* Illegal or undefined instruction or operand */

#define EXC_ARITHMETIC		3	/* Arithmetic exception */
		/* Exact nature of exception is in code field */

#define EXC_EMULATION		4	/* Emulation instruction */
		/* Emulation support instruction encountered */
		/* Details in code and subcode fields	*/

#define EXC_SOFTWARE		5	/* Software generated exception */
		/* Exact exception is in code field. */
		/* Codes 0 - 0xFFFF reserved to hardware */
		/* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */

#define EXC_BREAKPOINT		6	/* Trace, breakpoint, etc. */
		/* Details in code field. */

#define EXC_SYSCALL		7	/* System calls. */

#define EXC_MACH_SYSCALL	8	/* Mach system calls. */

#define EXC_RPC_ALERT		9	/* RPC alert */
 
#define EXC_CRASH		10	/* Abnormal process exit */

/*
 *	Machine-independent exception behaviors
 */

# define EXCEPTION_DEFAULT		1
/*	Send a catch_exception_raise message including the identity.
 */

# define EXCEPTION_STATE		2
/*	Send a catch_exception_raise_state message including the
 *	thread state.
 */

# define EXCEPTION_STATE_IDENTITY	3
/*	Send a catch_exception_raise_state_identity message including
 *	the thread identity and state.
 */

#define MACH_EXCEPTION_CODES		0x80000000
/*	Send 64-bit code and subcode in the exception header */

/*
 * Masks for exception definitions, above
 * bit zero is unused, therefore 1 word = 31 exception types
 */

#define EXC_MASK_BAD_ACCESS		(1 << EXC_BAD_ACCESS)
#define EXC_MASK_BAD_INSTRUCTION	(1 << EXC_BAD_INSTRUCTION)
#define EXC_MASK_ARITHMETIC		(1 << EXC_ARITHMETIC)
#define EXC_MASK_EMULATION		(1 << EXC_EMULATION)
#define EXC_MASK_SOFTWARE		(1 << EXC_SOFTWARE)
#define EXC_MASK_BREAKPOINT		(1 << EXC_BREAKPOINT)
#define EXC_MASK_SYSCALL		(1 << EXC_SYSCALL)
#define EXC_MASK_MACH_SYSCALL		(1 << EXC_MACH_SYSCALL)
#define EXC_MASK_RPC_ALERT		(1 << EXC_RPC_ALERT)
#define EXC_MASK_CRASH			(1 << EXC_CRASH)

#define EXC_MASK_ALL	(EXC_MASK_BAD_ACCESS |			\
			 EXC_MASK_BAD_INSTRUCTION |		\
			 EXC_MASK_ARITHMETIC |			\
			 EXC_MASK_EMULATION |			\
			 EXC_MASK_SOFTWARE |			\
			 EXC_MASK_BREAKPOINT |			\
			 EXC_MASK_SYSCALL |			\
			 EXC_MASK_MACH_SYSCALL |		\
			 EXC_MASK_RPC_ALERT |			\
			 EXC_MASK_MACHINE)


#define FIRST_EXCEPTION		1	/* ZERO is illegal */

/*
 * Machine independent codes for EXC_SOFTWARE
 * Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) 
 * 0x10000 - 0x10002 in use for unix signals
 */
#define	EXC_SOFT_SIGNAL		0x10003	/* Unix signal exceptions */

#ifndef	ASSEMBLER

#include <mach/port.h>
#include <mach/thread_status.h>
#include <mach/machine/vm_types.h>
/*
 * Exported types
 */

typedef int				exception_type_t;
typedef	integer_t			exception_data_type_t;
typedef	int64_t				mach_exception_data_type_t;
typedef int				exception_behavior_t;
typedef exception_data_type_t		*exception_data_t;
typedef mach_exception_data_type_t	*mach_exception_data_t;
typedef	unsigned int			exception_mask_t;
typedef	exception_mask_t		*exception_mask_array_t;
typedef exception_behavior_t		*exception_behavior_array_t;
typedef thread_state_flavor_t		*exception_flavor_array_t;
typedef mach_port_t			*exception_port_array_t;
typedef	mach_exception_data_type_t	mach_exception_code_t;
typedef	mach_exception_data_type_t	mach_exception_subcode_t;

#endif	/* ASSEMBLER */

#endif	/* _MACH_EXCEPTION_TYPES_H_ */
                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_info.h            0100644 0001750 0001750 00000017153 12612724206 026574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

/*
 *	File:	mach/host_info.h
 *
 *	Definitions for host_info call.
 */

#ifndef	_MACH_HOST_INFO_H_
#define	_MACH_HOST_INFO_H_

#include <mach/message.h>
#include <mach/vm_statistics.h>
#include <mach/machine.h>
#include <mach/machine/vm_types.h>
#include <mach/time_value.h>

#include <sys/cdefs.h>

/*
 *	Generic information structure to allow for expansion.
 */
typedef integer_t	*host_info_t;		/* varying array of int. */
typedef integer_t	*host_info64_t;		/* varying array of int. */

#define	HOST_INFO_MAX	(1024)		/* max array size */
typedef integer_t	host_info_data_t[HOST_INFO_MAX];

#define KERNEL_VERSION_MAX (512)
typedef char	kernel_version_t[KERNEL_VERSION_MAX];

#define KERNEL_BOOT_INFO_MAX (4096)
typedef char	kernel_boot_info_t[KERNEL_BOOT_INFO_MAX];

/*
 *	Currently defined information.
 */
/* host_info() */
typedef	integer_t	host_flavor_t;
#define HOST_BASIC_INFO		1	/* basic info */
#define HOST_SCHED_INFO		3	/* scheduling info */
#define HOST_RESOURCE_SIZES	4	/* kernel struct sizes */
#define HOST_PRIORITY_INFO	5	/* priority information */
#define HOST_SEMAPHORE_TRAPS	7	/* Has semaphore traps */
#define HOST_MACH_MSG_TRAP	8	/* Has mach_msg_trap */


#pragma pack(4)

struct host_basic_info {
	integer_t		max_cpus;		/* max number of CPUs possible */
	integer_t		avail_cpus;		/* number of CPUs now available */
	natural_t		memory_size;		/* size of memory in bytes, capped at 2 GB */
	cpu_type_t		cpu_type;		/* cpu type */
	cpu_subtype_t		cpu_subtype;		/* cpu subtype */
	cpu_threadtype_t	cpu_threadtype;		/* cpu threadtype */
	integer_t		physical_cpu;		/* number of physical CPUs now available */
	integer_t		physical_cpu_max;	/* max number of physical CPUs possible */
	integer_t		logical_cpu;		/* number of logical cpu now available */
	integer_t		logical_cpu_max;	/* max number of physical CPUs possible */
	uint64_t		max_mem;		/* actual size of physical memory */
};

#pragma pack()

typedef	struct host_basic_info	host_basic_info_data_t;
typedef struct host_basic_info	*host_basic_info_t;
#define HOST_BASIC_INFO_COUNT ((mach_msg_type_number_t) \
		(sizeof(host_basic_info_data_t)/sizeof(integer_t)))

struct host_sched_info {
	integer_t	min_timeout;	/* minimum timeout in milliseconds */
	integer_t	min_quantum;	/* minimum quantum in milliseconds */
};

typedef	struct host_sched_info	host_sched_info_data_t;
typedef struct host_sched_info	*host_sched_info_t;
#define HOST_SCHED_INFO_COUNT ((mach_msg_type_number_t) \
		(sizeof(host_sched_info_data_t)/sizeof(integer_t)))

struct kernel_resource_sizes {
	natural_t	task;
        natural_t	thread;
        natural_t	port;
        natural_t	memory_region;
        natural_t	memory_object;
};

typedef struct kernel_resource_sizes	kernel_resource_sizes_data_t;
typedef struct kernel_resource_sizes	*kernel_resource_sizes_t;
#define HOST_RESOURCE_SIZES_COUNT ((mach_msg_type_number_t) \
		(sizeof(kernel_resource_sizes_data_t)/sizeof(integer_t)))

struct host_priority_info {
    	integer_t	kernel_priority;
    	integer_t	system_priority;
    	integer_t	server_priority;
    	integer_t	user_priority;
    	integer_t	depress_priority;
    	integer_t	idle_priority;
    	integer_t	minimum_priority;
	integer_t	maximum_priority;
};

typedef struct host_priority_info	host_priority_info_data_t;
typedef struct host_priority_info	*host_priority_info_t;
#define HOST_PRIORITY_INFO_COUNT ((mach_msg_type_number_t) \
		(sizeof(host_priority_info_data_t)/sizeof(integer_t)))

/* host_statistics() */
#define	HOST_LOAD_INFO		1	/* System loading stats */
#define HOST_VM_INFO		2	/* Virtual memory stats */
#define HOST_CPU_LOAD_INFO	3	/* CPU load stats */

/* host_statistics64() */
#define HOST_VM_INFO64		4	/* 64-bit virtual memory stats */


struct host_load_info {
	integer_t	avenrun[3];	/* scaled by LOAD_SCALE */
	integer_t	mach_factor[3];	/* scaled by LOAD_SCALE */
};

typedef struct host_load_info	host_load_info_data_t;
typedef struct host_load_info	*host_load_info_t;
#define	HOST_LOAD_INFO_COUNT ((mach_msg_type_number_t) \
		(sizeof(host_load_info_data_t)/sizeof(integer_t)))

/* in <mach/vm_statistics.h> */
/* vm_statistics64 */
#define	HOST_VM_INFO64_COUNT ((mach_msg_type_number_t) \
		(sizeof(vm_statistics64_data_t)/sizeof(integer_t)))

/* size of the latest version of the structure */
#define HOST_VM_INFO64_LATEST_COUNT HOST_VM_INFO64_COUNT


/* vm_statistics */
#define	HOST_VM_INFO_COUNT ((mach_msg_type_number_t) \
		(sizeof(vm_statistics_data_t)/sizeof(integer_t)))

/* size of the latest version of the structure */
#define HOST_VM_INFO_LATEST_COUNT HOST_VM_INFO_COUNT
#define	HOST_VM_INFO_REV2_COUNT HOST_VM_INFO_LATEST_COUNT
/* previous versions: adjust the size according to what was added each time */
#define	HOST_VM_INFO_REV1_COUNT /* added "speculative_count" (1 int) */	\
	((mach_msg_type_number_t) \
	 (HOST_VM_INFO_REV2_COUNT - 1))
#define	HOST_VM_INFO_REV0_COUNT /* added "purgable" info (2 ints) */ 	\
	((mach_msg_type_number_t) \
	 (HOST_VM_INFO_REV1_COUNT - 2))

struct host_cpu_load_info {		/* number of ticks while running... */
	natural_t	cpu_ticks[CPU_STATE_MAX]; /* ... in the given mode */
};

typedef struct host_cpu_load_info	host_cpu_load_info_data_t;
typedef struct host_cpu_load_info	*host_cpu_load_info_t;
#define HOST_CPU_LOAD_INFO_COUNT ((mach_msg_type_number_t) \
		(sizeof (host_cpu_load_info_data_t) / sizeof (integer_t)))

#endif	/* _MACH_HOST_INFO_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_notify.h          0100644 0001750 0001750 00000003010 12612724206 027134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef	_MACH_HOST_NOTIFY_H_
#define	_MACH_HOST_NOTIFY_H_

#define HOST_NOTIFY_CALENDAR_CHANGE		0
#define HOST_NOTIFY_TYPE_MAX			0

#define HOST_CALENDAR_CHANGED_REPLYID	950

#endif /* _MACH_HOST_NOTIFY_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_notify_reply.defs 0100644 0001750 0001750 00000003031 12612724206 031044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

subsystem
#if	KERNEL_USER
		KernelUser
#endif	/* KERN_USER */
			host_notify_reply 950;

#include <mach/std_types.defs>

simpleroutine host_calendar_changed(
		notify_port	: mach_port_move_send_once_t);

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_priv.defs         0100644 0001750 0001750 00000026517 12612724206 027317  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2004 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

/*
 *	Matchmaker definitions file for Mach kernel interface.
 */
subsystem
#if	KERNEL_USER
	  KernelUser
#endif	/* KERNEL_USER */
#if	KERNEL_SERVER
	  KernelServer
#endif	/* KERNEL_SERVER */
		       host_priv 400;

#ifdef	KERNEL_USER
userprefix r_;
#endif	/* KERNEL_USER */

#include <mach/std_types.defs>
#include <mach/mach_types.defs>
#include <mach/clock_types.defs>
#include <mach_debug/mach_debug_types.defs>

/*
 *      Get boot configuration information from kernel.
 */
routine host_get_boot_info(
		host_priv	: host_priv_t;
	out	boot_info	: kernel_boot_info_t);

/*
 *	Reboot this host.
 *	Only available to privileged users.
 */
routine host_reboot(
		host_priv	: host_priv_t;
		options		: int);


/*
 *	Return privileged statistics from this host.
 */
routine host_priv_statistics(
		host_priv	: host_priv_t;
		flavor		: host_flavor_t;
	out	host_info_out	: host_info_t, CountInOut);

/*
 *	Sets the default memory manager, the port to which
 *	newly-created temporary memory objects are delivered.
 *	[See (memory_object_default)memory_object_create.]
 *	Also sets the default cluster size used for pagein/pageout
 *	to this port.
 *	The old memory manager port is returned.
 */
routine host_default_memory_manager(
		host_priv	: host_priv_t;
	inout	default_manager	: memory_object_default_t = 
					MACH_MSG_TYPE_MAKE_SEND;
		cluster_size	: memory_object_cluster_size_t);


/*
 *	Specify that the range of the virtual address space
 *	of the target task must not cause page faults for
 *	the indicated accesses.
 *
 *	[ To unwire the pages, specify VM_PROT_NONE. ]
 */
routine	vm_wire(
		host_priv	: host_priv_t;
		task		: vm_map_t;
		address		: vm_address_t;
		size		: vm_size_t;
		desired_access	: vm_prot_t);

/*
 *	Specify that the target thread must always be able
 *	to run and to allocate memory.
 */
routine	thread_wire(
		host_priv	: host_priv_t;
		thread		: thread_act_t;
		wired		: boolean_t);

/*
 *	Allocate zero-filled, wired, contiguous physical memory
 *	in the address space of the target task, either at the
 *	specified address, or wherever space can be found (if
 *	anywhere is TRUE), of the specified size.  The address
 *	at which the allocation actually took place is returned.
 *	All pages will be entered into the task's pmap immediately,
 *	with VM_PROT_ALL.
 *
 *	In addition to all the failure modes of its cousin,
 *	vm_allocate, this call may also fail if insufficient
 *	contiguous memory exists to satisfy the request.
 *
 *	Memory obtained from this call should be freed the
 *	normal way, via vm_deallocate.
 *
 *	N.B.  This is an EXPERIMENTAL interface!
 */
routine	vm_allocate_cpm(
		host_priv	: host_priv_t;
		task		: vm_map_t;
	inout	address		: vm_address_t;
		size		: vm_size_t;
		flags		: int);

/*
 *	Get list of processors on this host.
 */
routine host_processors(
		host_priv		: host_priv_t;
	out	out_processor_list	: processor_array_t);


/*
 *	Get control port for a system-wide clock.
 *	Privileged.
 */
routine host_get_clock_control(
		host_priv	: host_priv_t;
		clock_id	: clock_id_t;
	out	clock_ctrl	: clock_ctrl_t);


/*
 * kernel module interface (obsolete as of SnowLeopard)
 * see mach/kmod.h
 */
/* kmod_ MIG calls now return KERN_NOT_SUPPORTED on PPC/i386/x86_64. */
routine kmod_create(
		host_priv	: host_priv_t;
		info		: vm_address_t;
	out	module		: kmod_t);

routine kmod_destroy(
		host_priv	: host_priv_t;
		module		: kmod_t);

routine	kmod_control(
		host_priv	: host_priv_t;
		module		: kmod_t;
		flavor		: kmod_control_flavor_t;
	inout	data		: kmod_args_t);

/*
 * 	Get a given special port for a given node.
 * 	Special ports are defined in host_special_ports.h;
 * 	examples include the master device port.
 * 	There are a limited number of slots available for system servers.
 */
routine host_get_special_port(
                host_priv       : host_priv_t;
                node            : int;
                which           : int;
        out     port            : mach_port_t);

/*
 * 	Set a given special port for the local node.
 * 	See host_get_special_port.
 */
routine host_set_special_port(
                host_priv       : host_priv_t;
                which           : int;
                port            : mach_port_t);

/*
 * Set an exception handler for a host on one or more exception types.
 * These handlers are invoked for all threads on the host if there are
 * no task or thread-specific exception handlers or those handlers returned
 * an error.
 */
routine	host_set_exception_ports(
		host_priv	: host_priv_t;
		exception_mask	: exception_mask_t;
		new_port	: mach_port_t;
		behavior	: exception_behavior_t;
		new_flavor	: thread_state_flavor_t);


/*
 * Lookup some of the old exception handlers for a host
 */
routine	host_get_exception_ports(
		host_priv	: host_priv_t;
		exception_mask	: exception_mask_t;
	  out	masks		: exception_mask_array_t;
	  out	old_handlers	: exception_handler_array_t, SameCount;
	  out	old_behaviors	: exception_behavior_array_t, SameCount;
	  out	old_flavors	: exception_flavor_array_t, SameCount);


/*
 * Set an exception handler for a host on one or more exception types.
 * At the same time, return the previously defined exception handlers for
 * those types.
 */
routine	host_swap_exception_ports(
		host_priv	: host_priv_t;
		exception_mask	: exception_mask_t;
		new_port	: mach_port_t;
		behavior	: exception_behavior_t;
		new_flavor	: thread_state_flavor_t;
	  out	masks		: exception_mask_array_t;
	  out	old_handlerss	: exception_handler_array_t, SameCount;
	  out	old_behaviors	: exception_behavior_array_t, SameCount;
	  out	old_flavors	: exception_flavor_array_t, SameCount);

/*
 *	Loads a symbol table for an external file into the kernel debugger.
 *	The symbol table data is an array of characters.  It is assumed that
 *	the caller and the kernel debugger agree on its format.
 *      This call is only supported in MACH_DEBUG and MACH_KDB kernels,
 *      otherwise KERN_FAILURE is returned.
 */
routine host_load_symbol_table(
		host		: host_priv_t;
		task		: task_t;
		name		: symtab_name_t;
		symtab		: pointer_t);

/*
 *	Specify that the range of the virtual address space
 *	of the target task must not cause page faults for
 *	the indicated accesses.
 *
 *	[ To unwire the pages, specify VM_PROT_NONE. ]
 */
routine	mach_vm_wire(
		host_priv	: host_priv_t;
		task		: vm_map_t;
		address		: mach_vm_address_t;
		size		: mach_vm_size_t;
		desired_access	: vm_prot_t);

/*
 * JMM - Keep all processor_set related items at the end for easy
 * removal.
 */
/*
 *	List all processor sets on host.
 */
routine host_processor_sets(
		host_priv	: host_priv_t;
	out	processor_sets	: processor_set_name_array_t);

/*
 *	Get control port for a processor set.
 */
routine host_processor_set_priv(
		host_priv	: host_priv_t;
		set_name	: processor_set_name_t;
	out	set		: processor_set_t);

/************************** Warning *************************************/
/*       The following routines are going away in a future release	*/
/*	use the appropriate variant of host_set_special_port instead	*/
/************************************************************************/
 
/*
 *	Set the dynamic_pager control port. Other entities
 *	can request a send right to this port to talk with
 *	the dynamic_pager utility, setting behavioral parameters
 *	within the dynamic pager and getting low/high backing store
 *	resource notifications.
 */
routine set_dp_control_port(    
		host		: host_priv_t;
	in	control_port	: mach_port_t);

/*
 *	Get the dynamic_pager control port.  This port
 *	allows the holder to talk directly with the dynamic
 *	pager utility.
 */
routine get_dp_control_port(    
		host		: host_priv_t;
	out	contorl_port    :mach_port_t);

/*
 *	Set the UserNotification daemon access port for this host. 
 *	If this value is already set, the kernel will discard its
 *	reference to the previously registered port.
 */
routine host_set_UNDServer(    
		host		: host_priv_t;
	in	server		: UNDServerRef);

/*
 *	Get the UserNotification daemon access port for this host.
 *	This can then be used to communicate with that daemon, which
 *	in turn communicates with the User through whatever means
 *	available (pop-up-menus for GUI systems, text for non-GUI, etc..).
 *
 *	Access to this port is restricted to privileged clients because
 *	it is a special purpose port intended for kernel clients.  User
 *	level clients should go directly to the CFUserNotifcation services.
 */
routine host_get_UNDServer(    
		host		: host_priv_t;
	out	server		: UNDServerRef);

/*
 * Perform an operation with a kernel extension, on the kext loading system,
 * or request information about loaded kexts or the state of the kext loading
 * system.
 * Active operations (load, unload, disable/enable) require host_priv/root access.
 * Info retrieval does not.
 *
 * WARNING: THIS ROUTINE IS PRIVATE TO THE KEXT-MANAGEMENT STACK AND IS
 * SUBJECT TO CHANGE AT ANY TIME.
 */
routine kext_request(
        host_priv      : host_priv_t;
    in  user_log_flags : uint32_t;
    in  request_data   : pointer_t;
    out response_data  : pointer_t;
    out log_data       : pointer_t;
    out op_result      : kern_return_t);

/* vim: set ft=c : */
                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_priv.h            0100644 0001750 0001750 00000070613 12612724206 026621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_host_priv_user_
#define	_host_priv_user_

/* Module host_priv */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	host_priv_MSG_COUNT
#define	host_priv_MSG_COUNT	26
#endif	/* host_priv_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/mach_types.h>
#include <mach_debug/mach_debug_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine host_get_boot_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_boot_info
(
	host_priv_t host_priv,
	kernel_boot_info_t boot_info
);

/* Routine host_reboot */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_reboot
(
	host_priv_t host_priv,
	int options
);

/* Routine host_priv_statistics */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_priv_statistics
(
	host_priv_t host_priv,
	host_flavor_t flavor,
	host_info_t host_info_out,
	mach_msg_type_number_t *host_info_outCnt
);

/* Routine host_default_memory_manager */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_default_memory_manager
(
	host_priv_t host_priv,
	memory_object_default_t *default_manager,
	memory_object_cluster_size_t cluster_size
);

/* Routine vm_wire */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t vm_wire
(
	host_priv_t host_priv,
	vm_map_t task,
	vm_address_t address,
	vm_size_t size,
	vm_prot_t desired_access
);

/* Routine thread_wire */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_wire
(
	host_priv_t host_priv,
	thread_act_t thread,
	boolean_t wired
);

/* Routine vm_allocate_cpm */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t vm_allocate_cpm
(
	host_priv_t host_priv,
	vm_map_t task,
	vm_address_t *address,
	vm_size_t size,
	int flags
);

/* Routine host_processors */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_processors
(
	host_priv_t host_priv,
	processor_array_t *out_processor_list,
	mach_msg_type_number_t *out_processor_listCnt
);

/* Routine host_get_clock_control */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_clock_control
(
	host_priv_t host_priv,
	clock_id_t clock_id,
	clock_ctrl_t *clock_ctrl
);

/* Routine kmod_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t kmod_create
(
	host_priv_t host_priv,
	vm_address_t info,
	kmod_t *module
);

/* Routine kmod_destroy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t kmod_destroy
(
	host_priv_t host_priv,
	kmod_t module
);

/* Routine kmod_control */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t kmod_control
(
	host_priv_t host_priv,
	kmod_t module,
	kmod_control_flavor_t flavor,
	kmod_args_t *data,
	mach_msg_type_number_t *dataCnt
);

/* Routine host_get_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_special_port
(
	host_priv_t host_priv,
	int node,
	int which,
	mach_port_t *port
);

/* Routine host_set_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_set_special_port
(
	host_priv_t host_priv,
	int which,
	mach_port_t port
);

/* Routine host_set_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_set_exception_ports
(
	host_priv_t host_priv,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
);

/* Routine host_get_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_exception_ports
(
	host_priv_t host_priv,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine host_swap_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_swap_exception_ports
(
	host_priv_t host_priv,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlerss,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine host_load_symbol_table */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_load_symbol_table
(
	host_priv_t host,
	task_t task,
	symtab_name_t name,
	vm_offset_t symtab,
	mach_msg_type_number_t symtabCnt
);

/* Routine mach_vm_wire */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_vm_wire
(
	host_priv_t host_priv,
	vm_map_t task,
	mach_vm_address_t address,
	mach_vm_size_t size,
	vm_prot_t desired_access
);

/* Routine host_processor_sets */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_processor_sets
(
	host_priv_t host_priv,
	processor_set_name_array_t *processor_sets,
	mach_msg_type_number_t *processor_setsCnt
);

/* Routine host_processor_set_priv */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_processor_set_priv
(
	host_priv_t host_priv,
	processor_set_name_t set_name,
	processor_set_t *set
);

/* Routine set_dp_control_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t set_dp_control_port
(
	host_priv_t host,
	mach_port_t control_port
);

/* Routine get_dp_control_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t get_dp_control_port
(
	host_priv_t host,
	mach_port_t *contorl_port
);

/* Routine host_set_UNDServer */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_set_UNDServer
(
	host_priv_t host,
	UNDServerRef server
);

/* Routine host_get_UNDServer */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_UNDServer
(
	host_priv_t host,
	UNDServerRef *server
);

/* Routine kext_request */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t kext_request
(
	host_priv_t host_priv,
	uint32_t user_log_flags,
	vm_offset_t request_data,
	mach_msg_type_number_t request_dataCnt,
	vm_offset_t *response_data,
	mach_msg_type_number_t *response_dataCnt,
	vm_offset_t *log_data,
	mach_msg_type_number_t *log_dataCnt,
	kern_return_t *op_result
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__host_priv_subsystem__defined
#define __Request__host_priv_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_get_boot_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int options;
	} __Request__host_reboot_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info_outCnt;
	} __Request__host_priv_statistics_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t default_manager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		memory_object_cluster_size_t cluster_size;
	} __Request__host_default_memory_manager_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		vm_address_t address;
		vm_size_t size;
		vm_prot_t desired_access;
	} __Request__vm_wire_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t wired;
	} __Request__thread_wire_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		vm_address_t address;
		vm_size_t size;
		int flags;
	} __Request__vm_allocate_cpm_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_processors_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		clock_id_t clock_id;
	} __Request__host_get_clock_control_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t info;
	} __Request__kmod_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kmod_t module;
	} __Request__kmod_destroy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kmod_t module;
		kmod_control_flavor_t flavor;
		mach_msg_type_number_t dataCnt;
	} __Request__kmod_control_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int node;
		int which;
	} __Request__host_get_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which;
	} __Request__host_set_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__host_set_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__host_get_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__host_swap_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task;
		mach_msg_ool_descriptor_t symtab;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[32];
		mach_msg_type_number_t symtabCnt;
	} __Request__host_load_symbol_table_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_address_t address;
		mach_vm_size_t size;
		vm_prot_t desired_access;
	} __Request__mach_vm_wire_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_processor_sets_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t set_name;
		/* end of the kernel processed data */
	} __Request__host_processor_set_priv_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t control_port;
		/* end of the kernel processed data */
	} __Request__set_dp_control_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__get_dp_control_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t server;
		/* end of the kernel processed data */
	} __Request__host_set_UNDServer_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_get_UNDServer_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t request_data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t user_log_flags;
		mach_msg_type_number_t request_dataCnt;
	} __Request__kext_request_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__host_priv_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__host_priv_subsystem__defined
#define __RequestUnion__host_priv_subsystem__defined
union __RequestUnion__host_priv_subsystem {
	__Request__host_get_boot_info_t Request_host_get_boot_info;
	__Request__host_reboot_t Request_host_reboot;
	__Request__host_priv_statistics_t Request_host_priv_statistics;
	__Request__host_default_memory_manager_t Request_host_default_memory_manager;
	__Request__vm_wire_t Request_vm_wire;
	__Request__thread_wire_t Request_thread_wire;
	__Request__vm_allocate_cpm_t Request_vm_allocate_cpm;
	__Request__host_processors_t Request_host_processors;
	__Request__host_get_clock_control_t Request_host_get_clock_control;
	__Request__kmod_create_t Request_kmod_create;
	__Request__kmod_destroy_t Request_kmod_destroy;
	__Request__kmod_control_t Request_kmod_control;
	__Request__host_get_special_port_t Request_host_get_special_port;
	__Request__host_set_special_port_t Request_host_set_special_port;
	__Request__host_set_exception_ports_t Request_host_set_exception_ports;
	__Request__host_get_exception_ports_t Request_host_get_exception_ports;
	__Request__host_swap_exception_ports_t Request_host_swap_exception_ports;
	__Request__host_load_symbol_table_t Request_host_load_symbol_table;
	__Request__mach_vm_wire_t Request_mach_vm_wire;
	__Request__host_processor_sets_t Request_host_processor_sets;
	__Request__host_processor_set_priv_t Request_host_processor_set_priv;
	__Request__set_dp_control_port_t Request_set_dp_control_port;
	__Request__get_dp_control_port_t Request_get_dp_control_port;
	__Request__host_set_UNDServer_t Request_host_set_UNDServer;
	__Request__host_get_UNDServer_t Request_host_get_UNDServer;
	__Request__kext_request_t Request_kext_request;
};
#endif /* !__RequestUnion__host_priv_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__host_priv_subsystem__defined
#define __Reply__host_priv_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t boot_infoOffset; /* MiG doesn't use it */
		mach_msg_type_number_t boot_infoCnt;
		char boot_info[4096];
	} __Reply__host_get_boot_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_reboot_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[15];
	} __Reply__host_priv_statistics_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t default_manager;
		/* end of the kernel processed data */
	} __Reply__host_default_memory_manager_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__vm_wire_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_wire_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_address_t address;
	} __Reply__vm_allocate_cpm_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t out_processor_list;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t out_processor_listCnt;
	} __Reply__host_processors_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t clock_ctrl;
		/* end of the kernel processed data */
	} __Reply__host_get_clock_control_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kmod_t module;
	} __Reply__kmod_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__kmod_destroy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dataCnt;
	} __Reply__kmod_control_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
	} __Reply__host_get_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_set_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_set_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__host_get_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlerss[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__host_swap_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_load_symbol_table_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__mach_vm_wire_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t processor_sets;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t processor_setsCnt;
	} __Reply__host_processor_sets_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t set;
		/* end of the kernel processed data */
	} __Reply__host_processor_set_priv_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__set_dp_control_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t contorl_port;
		/* end of the kernel processed data */
	} __Reply__get_dp_control_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_set_UNDServer_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t server;
		/* end of the kernel processed data */
	} __Reply__host_get_UNDServer_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t response_data;
		mach_msg_ool_descriptor_t log_data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t response_dataCnt;
		mach_msg_type_number_t log_dataCnt;
		kern_return_t op_result;
	} __Reply__kext_request_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__host_priv_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__host_priv_subsystem__defined
#define __ReplyUnion__host_priv_subsystem__defined
union __ReplyUnion__host_priv_subsystem {
	__Reply__host_get_boot_info_t Reply_host_get_boot_info;
	__Reply__host_reboot_t Reply_host_reboot;
	__Reply__host_priv_statistics_t Reply_host_priv_statistics;
	__Reply__host_default_memory_manager_t Reply_host_default_memory_manager;
	__Reply__vm_wire_t Reply_vm_wire;
	__Reply__thread_wire_t Reply_thread_wire;
	__Reply__vm_allocate_cpm_t Reply_vm_allocate_cpm;
	__Reply__host_processors_t Reply_host_processors;
	__Reply__host_get_clock_control_t Reply_host_get_clock_control;
	__Reply__kmod_create_t Reply_kmod_create;
	__Reply__kmod_destroy_t Reply_kmod_destroy;
	__Reply__kmod_control_t Reply_kmod_control;
	__Reply__host_get_special_port_t Reply_host_get_special_port;
	__Reply__host_set_special_port_t Reply_host_set_special_port;
	__Reply__host_set_exception_ports_t Reply_host_set_exception_ports;
	__Reply__host_get_exception_ports_t Reply_host_get_exception_ports;
	__Reply__host_swap_exception_ports_t Reply_host_swap_exception_ports;
	__Reply__host_load_symbol_table_t Reply_host_load_symbol_table;
	__Reply__mach_vm_wire_t Reply_mach_vm_wire;
	__Reply__host_processor_sets_t Reply_host_processor_sets;
	__Reply__host_processor_set_priv_t Reply_host_processor_set_priv;
	__Reply__set_dp_control_port_t Reply_set_dp_control_port;
	__Reply__get_dp_control_port_t Reply_get_dp_control_port;
	__Reply__host_set_UNDServer_t Reply_host_set_UNDServer;
	__Reply__host_get_UNDServer_t Reply_host_get_UNDServer;
	__Reply__kext_request_t Reply_kext_request;
};
#endif /* !__RequestUnion__host_priv_subsystem__defined */

#ifndef subsystem_to_name_map_host_priv
#define subsystem_to_name_map_host_priv \
    { "host_get_boot_info", 400 },\
    { "host_reboot", 401 },\
    { "host_priv_statistics", 402 },\
    { "host_default_memory_manager", 403 },\
    { "vm_wire", 404 },\
    { "thread_wire", 405 },\
    { "vm_allocate_cpm", 406 },\
    { "host_processors", 407 },\
    { "host_get_clock_control", 408 },\
    { "kmod_create", 409 },\
    { "kmod_destroy", 410 },\
    { "kmod_control", 411 },\
    { "host_get_special_port", 412 },\
    { "host_set_special_port", 413 },\
    { "host_set_exception_ports", 414 },\
    { "host_get_exception_ports", 415 },\
    { "host_swap_exception_ports", 416 },\
    { "host_load_symbol_table", 417 },\
    { "mach_vm_wire", 418 },\
    { "host_processor_sets", 419 },\
    { "host_processor_set_priv", 420 },\
    { "set_dp_control_port", 421 },\
    { "get_dp_control_port", 422 },\
    { "host_set_UNDServer", 423 },\
    { "host_get_UNDServer", 424 },\
    { "kext_request", 425 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _host_priv_user_ */
                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_reboot.h          0100644 0001750 0001750 00000003040 12612724206 027121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef _MACH_HOST_REBOOT_
#define _MACH_HOST_REBOOT_

#define HOST_REBOOT_HALT        0x0008
#define HOST_REBOOT_UPSDELAY    0x0100
#define	HOST_REBOOT_DEBUGGER	0x1000

#endif	/* _MACH_HOST_REBOOT_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_security.defs     0100644 0001750 0001750 00000006274 12612724206 030204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

/*
 * File:	mach/host_security.defs
 *
 * Abstract:
 *	Mach host security operations support.
 */
subsystem
#if	KERNEL_SERVER
	  KernelServer
#endif	/* KERNEL_SERVER */
		      host_security 600;

/*
 *	Basic types
 */
#include <mach/std_types.defs>
#include <mach/mach_types.defs>


/*
 *	Create a new task with an explicit security token
 */
routine host_security_create_task_token(
		host_security	: host_security_t;
		parent_task	: task_t;
		sec_token	: security_token_t;
		audit_token	: audit_token_t;
		host		: host_t;
		ledgers		: ledger_array_t;
		inherit_memory	: boolean_t;
	out	child_task	: task_t);

/*
 *	Change a task's security token
 */
routine host_security_set_task_token(
		host_security	: host_security_t;
		target_task	: task_t;
		sec_token	: security_token_t;
		audit_token	: audit_token_t;
		host		: host_t);

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_security.h        0100644 0001750 0001750 00000012427 12612724206 027507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_host_security_user_
#define	_host_security_user_

/* Module host_security */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	host_security_MSG_COUNT
#define	host_security_MSG_COUNT	2
#endif	/* host_security_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine host_security_create_task_token */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_security_create_task_token
(
	host_security_t host_security,
	task_t parent_task,
	security_token_t sec_token,
	audit_token_t audit_token,
	host_t host,
	ledger_array_t ledgers,
	mach_msg_type_number_t ledgersCnt,
	boolean_t inherit_memory,
	task_t *child_task
);

/* Routine host_security_set_task_token */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_security_set_task_token
(
	host_security_t host_security,
	task_t target_task,
	security_token_t sec_token,
	audit_token_t audit_token,
	host_t host
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__host_security_subsystem__defined
#define __Request__host_security_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t parent_task;
		mach_msg_port_descriptor_t host;
		mach_msg_ool_ports_descriptor_t ledgers;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		security_token_t sec_token;
		audit_token_t audit_token;
		mach_msg_type_number_t ledgersCnt;
		boolean_t inherit_memory;
	} __Request__host_security_create_task_token_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t target_task;
		mach_msg_port_descriptor_t host;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		security_token_t sec_token;
		audit_token_t audit_token;
	} __Request__host_security_set_task_token_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__host_security_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__host_security_subsystem__defined
#define __RequestUnion__host_security_subsystem__defined
union __RequestUnion__host_security_subsystem {
	__Request__host_security_create_task_token_t Request_host_security_create_task_token;
	__Request__host_security_set_task_token_t Request_host_security_set_task_token;
};
#endif /* !__RequestUnion__host_security_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__host_security_subsystem__defined
#define __Reply__host_security_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_task;
		/* end of the kernel processed data */
	} __Reply__host_security_create_task_token_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_security_set_task_token_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__host_security_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__host_security_subsystem__defined
#define __ReplyUnion__host_security_subsystem__defined
union __ReplyUnion__host_security_subsystem {
	__Reply__host_security_create_task_token_t Reply_host_security_create_task_token;
	__Reply__host_security_set_task_token_t Reply_host_security_set_task_token;
};
#endif /* !__RequestUnion__host_security_subsystem__defined */

#ifndef subsystem_to_name_map_host_security
#define subsystem_to_name_map_host_security \
    { "host_security_create_task_token", 600 },\
    { "host_security_set_task_token", 601 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _host_security_user_ */
                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/host_special_ports.h   0100644 0001750 0001750 00000015510 12612724206 030503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	File:	mach/host_special_ports.h
 *
 *	Defines codes for access to host-wide special ports.
 */

#ifndef _MACH_HOST_SPECIAL_PORTS_H_
#define _MACH_HOST_SPECIAL_PORTS_H_

/*
 * Cannot be set or gotten from user space
 */
#define HOST_SECURITY_PORT               0

/*
 * Always provided by kernel (cannot be set from user-space).
 */
#define HOST_PORT                        1
#define HOST_PRIV_PORT                   2
#define HOST_IO_MASTER_PORT              3
#define HOST_MAX_SPECIAL_KERNEL_PORT     7 /* room to grow */

/*
 * Not provided by kernel
 */
#define HOST_DYNAMIC_PAGER_PORT         (1 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_AUDIT_CONTROL_PORT         (2 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_USER_NOTIFICATION_PORT     (3 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_AUTOMOUNTD_PORT            (4 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_LOCKD_PORT                 (5 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_SEATBELT_PORT              (7 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_KEXTD_PORT                 (8 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_CHUD_PORT                  (9 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_UNFREED_PORT		(10 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_AMFID_PORT			(11 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_MAX_SPECIAL_PORT           (12 + HOST_MAX_SPECIAL_KERNEL_PORT)
                                        /* room to grow here as well */

/*
 * Special node identifier to always represent the local node.
 */
#define HOST_LOCAL_NODE	                 -1
			
/*
 * Definitions for ease of use.
 *
 * In the get call, the host parameter can be any host, but will generally
 * be the local node host port. In the set call, the host must the per-node
 * host port for the node being affected.
 */
#define host_get_host_port(host, port)	\
	(host_get_special_port((host), 	\
	HOST_LOCAL_NODE, HOST_PORT, (port)))
#define host_set_host_port(host, port) (KERN_INVALID_ARGUMENT)

#define host_get_host_priv_port(host, port)	\
	(host_get_special_port((host), 		\
	HOST_LOCAL_NODE, HOST_PRIV_PORT, (port)))
#define host_set_host_priv_port(host, port) (KERN_INVALID_ARGUMENT)

#define host_get_io_master_port(host, port)	\
	(host_get_special_port((host), 		\
	HOST_LOCAL_NODE, HOST_IO_MASTER_PORT, (port)))
#define host_set_io_master_port(host, port) (KERN_INVALID_ARGUMENT)

/*
 * User-settable special ports.
 */
#define host_get_dynamic_pager_port(host, port)	\
	(host_get_special_port((host),			\
	HOST_LOCAL_NODE, HOST_DYNAMIC_PAGER_PORT, (port)))
#define host_set_dynamic_pager_port(host, port)	\
	(host_set_special_port((host), HOST_DYNAMIC_PAGER_PORT, (port)))

#define host_get_audit_control_port(host, port)	\
	(host_get_special_port((host), 		\
	HOST_LOCAL_NODE, HOST_AUDIT_CONTROL_PORT, (port)))
#define host_set_audit_control_port(host, port)	\
	(host_set_special_port((host), HOST_AUDIT_CONTROL_PORT, (port)))

#define host_get_user_notification_port(host, port)	\
	(host_get_special_port((host), 			\
	HOST_LOCAL_NODE, HOST_USER_NOTIFICATION_PORT, (port)))
#define host_set_user_notification_port(host, port)	\
	(host_set_special_port((host), HOST_USER_NOTIFICATION_PORT, (port)))

#define host_get_automountd_port(host, port)	\
	(host_get_special_port((host), 		\
	HOST_LOCAL_NODE, HOST_AUTOMOUNTD_PORT, (port)))
#define host_set_automountd_port(host, port)	\
	(host_set_special_port((host), HOST_AUTOMOUNTD_PORT, (port)))

#define host_get_lockd_port(host, port)	\
	(host_get_special_port((host), 			\
	HOST_LOCAL_NODE, HOST_LOCKD_PORT, (port)))
#define host_set_lockd_port(host, port)	\
	(host_set_special_port((host), HOST_LOCKD_PORT, (port)))

#define host_get_kextd_port(host, port)	\
	(host_get_special_port((host), 			\
	HOST_LOCAL_NODE, HOST_KEXTD_PORT, (port)))
#define host_set_kextd_port(host, port)	\
	(host_set_special_port((host), HOST_KEXTD_PORT, (port)))

#define host_get_chud_port(host, port)	\
	(host_get_special_port((host), 			\
	HOST_LOCAL_NODE, HOST_CHUD_PORT, (port)))
#define host_set_chud_port(host, port)	\
	(host_set_special_port((host), HOST_CHUD_PORT, (port)))

#define host_get_unfreed_port(host, port)	\
	(host_get_special_port((host), 			\
	HOST_LOCAL_NODE, HOST_UNFREED_PORT, (port)))
#define host_set_unfreed_port(host, port)	\
	(host_set_special_port((host), HOST_UNFREED_PORT, (port)))

#define host_get_amfid_port(host, port)	\
	(host_get_special_port((host), 			\
	HOST_LOCAL_NODE, HOST_AMFID_PORT, (port)))
#define host_set_amfid_port(host, port)	\
	(host_set_special_port((host), HOST_AMFID_PORT, (port)))

#endif	/* _MACH_HOST_SPECIAL_PORTS_H_ */
                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/                  0040755 0001750 0001750 00000000000 12612724206 025120  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/_structs.h        0100644 0001750 0001750 00000061265 12612724206 027146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_MACH_I386__STRUCTS_H_
#define	_MACH_I386__STRUCTS_H_

/*
 * i386 is the structure that is exported to user threads for 
 * use in status/mutate calls.  This structure should never change.
 *
 */

#if __DARWIN_UNIX03
#define	_STRUCT_X86_THREAD_STATE32	struct __darwin_i386_thread_state
_STRUCT_X86_THREAD_STATE32
{
    unsigned int	__eax;
    unsigned int	__ebx;
    unsigned int	__ecx;
    unsigned int	__edx;
    unsigned int	__edi;
    unsigned int	__esi;
    unsigned int	__ebp;
    unsigned int	__esp;
    unsigned int	__ss;
    unsigned int	__eflags;
    unsigned int	__eip;
    unsigned int	__cs;
    unsigned int	__ds;
    unsigned int	__es;
    unsigned int	__fs;
    unsigned int	__gs;
};
#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_THREAD_STATE32	struct i386_thread_state
_STRUCT_X86_THREAD_STATE32
{
    unsigned int	eax;
    unsigned int	ebx;
    unsigned int	ecx;
    unsigned int	edx;
    unsigned int	edi;
    unsigned int	esi;
    unsigned int	ebp;
    unsigned int	esp;
    unsigned int	ss;
    unsigned int	eflags;
    unsigned int	eip;
    unsigned int	cs;
    unsigned int	ds;
    unsigned int	es;
    unsigned int	fs;
    unsigned int	gs;
};
#endif /* !__DARWIN_UNIX03 */
/* This structure should be double-word aligned for performance */

#if __DARWIN_UNIX03
#define _STRUCT_FP_CONTROL	struct __darwin_fp_control
_STRUCT_FP_CONTROL
{
    unsigned short		__invalid	:1,
    				__denorm	:1,
				__zdiv		:1,
				__ovrfl		:1,
				__undfl		:1,
				__precis	:1,
						:2,
				__pc		:2,
//#if defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define FP_PREC_24B		0
#define	FP_PREC_53B		2
#define FP_PREC_64B		3
//#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */
				__rc		:2,
//#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define FP_RND_NEAR		0
#define FP_RND_DOWN		1
#define FP_RND_UP		2
#define FP_CHOP			3
//#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */
					/*inf*/	:1,
						:3;
};
typedef _STRUCT_FP_CONTROL	__darwin_fp_control_t;
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_FP_CONTROL	struct fp_control
_STRUCT_FP_CONTROL
{
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
					:2,
				pc	:2,
#define FP_PREC_24B		0
#define	FP_PREC_53B		2
#define FP_PREC_64B		3
				rc	:2,
#define FP_RND_NEAR		0
#define FP_RND_DOWN		1
#define FP_RND_UP		2
#define FP_CHOP			3
				/*inf*/	:1,
					:3;
};
typedef _STRUCT_FP_CONTROL	fp_control_t;
#endif /* !__DARWIN_UNIX03 */

/*
 * Status word.
 */

#if __DARWIN_UNIX03
#define _STRUCT_FP_STATUS	struct __darwin_fp_status
_STRUCT_FP_STATUS
{
    unsigned short		__invalid	:1,
    				__denorm	:1,
				__zdiv		:1,
				__ovrfl		:1,
				__undfl		:1,
				__precis	:1,
				__stkflt	:1,
				__errsumm	:1,
				__c0		:1,
				__c1		:1,
				__c2		:1,
				__tos		:3,
				__c3		:1,
				__busy		:1;
};
typedef _STRUCT_FP_STATUS	__darwin_fp_status_t;
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_FP_STATUS	struct fp_status
_STRUCT_FP_STATUS
{
    unsigned short		invalid	:1,
    				denorm	:1,
				zdiv	:1,
				ovrfl	:1,
				undfl	:1,
				precis	:1,
				stkflt	:1,
				errsumm	:1,
				c0	:1,
				c1	:1,
				c2	:1,
				tos	:3,
				c3	:1,
				busy	:1;
};
typedef _STRUCT_FP_STATUS	fp_status_t;
#endif /* !__DARWIN_UNIX03 */
				
/* defn of 80bit x87 FPU or MMX register  */

#if __DARWIN_UNIX03
#define _STRUCT_MMST_REG	struct __darwin_mmst_reg
_STRUCT_MMST_REG
{
	char	__mmst_reg[10];
	char	__mmst_rsrv[6];
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_MMST_REG	struct mmst_reg
_STRUCT_MMST_REG
{
	char	mmst_reg[10];
	char	mmst_rsrv[6];
};
#endif /* !__DARWIN_UNIX03 */


/* defn of 128 bit XMM regs */

#if __DARWIN_UNIX03
#define _STRUCT_XMM_REG		struct __darwin_xmm_reg
_STRUCT_XMM_REG
{
	char		__xmm_reg[16];
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_XMM_REG		struct xmm_reg
_STRUCT_XMM_REG
{
	char		xmm_reg[16];
};
#endif /* !__DARWIN_UNIX03 */

/* 
 * Floating point state.
 */

//#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define FP_STATE_BYTES		512	/* number of chars worth of data from fpu_fcw */
//#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */

#if __DARWIN_UNIX03
#define	_STRUCT_X86_FLOAT_STATE32	struct __darwin_i386_float_state
_STRUCT_X86_FLOAT_STATE32
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
	__uint16_t		__fpu_rsrv2;		/* reserved */
	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	char			__fpu_rsrv4[14*16];	/* reserved */
	int 			__fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE32	struct __darwin_i386_avx_state
_STRUCT_X86_AVX_STATE32
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
	__uint16_t		__fpu_rsrv2;		/* reserved */
	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	char			__fpu_rsrv4[14*16];	/* reserved */
	int 			__fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_FLOAT_STATE32	struct i386_float_state
_STRUCT_X86_FLOAT_STATE32
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		fpu_ip;			/* x87 FPU Instruction Pointer offset */
	__uint16_t		fpu_cs;			/* x87 FPU Instruction Pointer Selector */
	__uint16_t		fpu_rsrv2;		/* reserved */
	__uint32_t		fpu_dp;			/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		fpu_ds;			/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	char			fpu_rsrv4[14*16];	/* reserved */
	int 			fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE32	struct i386_avx_state
_STRUCT_X86_AVX_STATE32
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */
	__uint32_t		fpu_ip;			/* x87 FPU Instruction Pointer offset */
	__uint16_t		fpu_cs;			/* x87 FPU Instruction Pointer Selector */
	__uint16_t		fpu_rsrv2;		/* reserved */
	__uint32_t		fpu_dp;			/* x87 FPU Instruction Operand(Data) Pointer offset */
	__uint16_t		fpu_ds;			/* x87 FPU Instruction Operand(Data) Pointer Selector */
	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	char			fpu_rsrv4[14*16];	/* reserved */
	int 			fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
};

#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_EXCEPTION_STATE32	struct __darwin_i386_exception_state
_STRUCT_X86_EXCEPTION_STATE32
{
    unsigned int	__trapno;
    unsigned int	__err;
    unsigned int	__faultvaddr;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_EXCEPTION_STATE32	struct i386_exception_state
_STRUCT_X86_EXCEPTION_STATE32
{
    unsigned int	trapno;
    unsigned int	err;
    unsigned int	faultvaddr;
};
#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_DEBUG_STATE32	struct __darwin_x86_debug_state32
_STRUCT_X86_DEBUG_STATE32
{
	unsigned int	__dr0;
	unsigned int	__dr1;
	unsigned int	__dr2;
	unsigned int	__dr3;
	unsigned int	__dr4;
	unsigned int	__dr5;
	unsigned int	__dr6;
	unsigned int	__dr7;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_DEBUG_STATE32	struct x86_debug_state32
_STRUCT_X86_DEBUG_STATE32
{
	unsigned int	dr0;
	unsigned int	dr1;
	unsigned int	dr2;
	unsigned int	dr3;
	unsigned int	dr4;
	unsigned int	dr5;
	unsigned int	dr6;
	unsigned int	dr7;
};
#endif /* !__DARWIN_UNIX03 */

/*
 * 64 bit versions of the above
 */

#if __DARWIN_UNIX03
#define	_STRUCT_X86_THREAD_STATE64	struct __darwin_x86_thread_state64
_STRUCT_X86_THREAD_STATE64
{
	__uint64_t	__rax;
	__uint64_t	__rbx;
	__uint64_t	__rcx;
	__uint64_t	__rdx;
	__uint64_t	__rdi;
	__uint64_t	__rsi;
	__uint64_t	__rbp;
	__uint64_t	__rsp;
	__uint64_t	__r8;
	__uint64_t	__r9;
	__uint64_t	__r10;
	__uint64_t	__r11;
	__uint64_t	__r12;
	__uint64_t	__r13;
	__uint64_t	__r14;
	__uint64_t	__r15;
	__uint64_t	__rip;
	__uint64_t	__rflags;
	__uint64_t	__cs;
	__uint64_t	__fs;
	__uint64_t	__gs;
};
#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_THREAD_STATE64	struct x86_thread_state64
_STRUCT_X86_THREAD_STATE64
{
	__uint64_t	rax;
	__uint64_t	rbx;
	__uint64_t	rcx;
	__uint64_t	rdx;
	__uint64_t	rdi;
	__uint64_t	rsi;
	__uint64_t	rbp;
	__uint64_t	rsp;
	__uint64_t	r8;
	__uint64_t	r9;
	__uint64_t	r10;
	__uint64_t	r11;
	__uint64_t	r12;
	__uint64_t	r13;
	__uint64_t	r14;
	__uint64_t	r15;
	__uint64_t	rip;
	__uint64_t	rflags;
	__uint64_t	cs;
	__uint64_t	fs;
	__uint64_t	gs;
};
#endif /* !__DARWIN_UNIX03 */


#if __DARWIN_UNIX03
#define	_STRUCT_X86_FLOAT_STATE64	struct __darwin_x86_float_state64
_STRUCT_X86_FLOAT_STATE64
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		__fpu_ip;		/* offset */
	__uint16_t		__fpu_cs;		/* Selector */

	__uint16_t		__fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		__fpu_dp;		/* offset */
	__uint16_t		__fpu_ds;		/* Selector */

	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
	char			__fpu_rsrv4[6*16];	/* reserved */
	int 			__fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE64	struct __darwin_x86_avx_state64
_STRUCT_X86_AVX_STATE64
{
	int 			__fpu_reserved[2];
	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		__fpu_rsrv1;		/* reserved */ 
	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		__fpu_ip;		/* offset */
	__uint16_t		__fpu_cs;		/* Selector */

	__uint16_t		__fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		__fpu_dp;		/* offset */
	__uint16_t		__fpu_ds;		/* Selector */

	__uint16_t		__fpu_rsrv3;		/* reserved */
	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
	char			__fpu_rsrv4[6*16];	/* reserved */
	int 			__fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
	_STRUCT_XMM_REG		__fpu_ymmh8;		/* YMMH 8  */
	_STRUCT_XMM_REG		__fpu_ymmh9;		/* YMMH 9  */
	_STRUCT_XMM_REG		__fpu_ymmh10;		/* YMMH 10  */
	_STRUCT_XMM_REG		__fpu_ymmh11;		/* YMMH 11  */
	_STRUCT_XMM_REG		__fpu_ymmh12;		/* YMMH 12  */
	_STRUCT_XMM_REG		__fpu_ymmh13;		/* YMMH 13  */
	_STRUCT_XMM_REG		__fpu_ymmh14;		/* YMMH 14  */
	_STRUCT_XMM_REG		__fpu_ymmh15;		/* YMMH 15  */
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_X86_FLOAT_STATE64	struct x86_float_state64
_STRUCT_X86_FLOAT_STATE64
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		fpu_ip;			/* offset */
	__uint16_t		fpu_cs;			/* Selector */

	__uint16_t		fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		fpu_dp;			/* offset */
	__uint16_t		fpu_ds;			/* Selector */

	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		fpu_xmm15;		/* XMM 15  */
	char			fpu_rsrv4[6*16];	/* reserved */
	int 			fpu_reserved1;
};

#define	_STRUCT_X86_AVX_STATE64	struct x86_avx_state64
_STRUCT_X86_AVX_STATE64
{
	int 			fpu_reserved[2];
	_STRUCT_FP_CONTROL	fpu_fcw;		/* x87 FPU control word */
	_STRUCT_FP_STATUS	fpu_fsw;		/* x87 FPU status word */
	__uint8_t		fpu_ftw;		/* x87 FPU tag word */
	__uint8_t		fpu_rsrv1;		/* reserved */ 
	__uint16_t		fpu_fop;		/* x87 FPU Opcode */

	/* x87 FPU Instruction Pointer */
	__uint32_t		fpu_ip;			/* offset */
	__uint16_t		fpu_cs;			/* Selector */

	__uint16_t		fpu_rsrv2;		/* reserved */

	/* x87 FPU Instruction Operand(Data) Pointer */
	__uint32_t		fpu_dp;			/* offset */
	__uint16_t		fpu_ds;			/* Selector */

	__uint16_t		fpu_rsrv3;		/* reserved */
	__uint32_t		fpu_mxcsr;		/* MXCSR Register state */
	__uint32_t		fpu_mxcsrmask;		/* MXCSR mask */
	_STRUCT_MMST_REG	fpu_stmm0;		/* ST0/MM0   */
	_STRUCT_MMST_REG	fpu_stmm1;		/* ST1/MM1  */
	_STRUCT_MMST_REG	fpu_stmm2;		/* ST2/MM2  */
	_STRUCT_MMST_REG	fpu_stmm3;		/* ST3/MM3  */
	_STRUCT_MMST_REG	fpu_stmm4;		/* ST4/MM4  */
	_STRUCT_MMST_REG	fpu_stmm5;		/* ST5/MM5  */
	_STRUCT_MMST_REG	fpu_stmm6;		/* ST6/MM6  */
	_STRUCT_MMST_REG	fpu_stmm7;		/* ST7/MM7  */
	_STRUCT_XMM_REG		fpu_xmm0;		/* XMM 0  */
	_STRUCT_XMM_REG		fpu_xmm1;		/* XMM 1  */
	_STRUCT_XMM_REG		fpu_xmm2;		/* XMM 2  */
	_STRUCT_XMM_REG		fpu_xmm3;		/* XMM 3  */
	_STRUCT_XMM_REG		fpu_xmm4;		/* XMM 4  */
	_STRUCT_XMM_REG		fpu_xmm5;		/* XMM 5  */
	_STRUCT_XMM_REG		fpu_xmm6;		/* XMM 6  */
	_STRUCT_XMM_REG		fpu_xmm7;		/* XMM 7  */
	_STRUCT_XMM_REG		fpu_xmm8;		/* XMM 8  */
	_STRUCT_XMM_REG		fpu_xmm9;		/* XMM 9  */
	_STRUCT_XMM_REG		fpu_xmm10;		/* XMM 10  */
	_STRUCT_XMM_REG		fpu_xmm11;		/* XMM 11 */
	_STRUCT_XMM_REG		fpu_xmm12;		/* XMM 12  */
	_STRUCT_XMM_REG		fpu_xmm13;		/* XMM 13  */
	_STRUCT_XMM_REG		fpu_xmm14;		/* XMM 14  */
	_STRUCT_XMM_REG		fpu_xmm15;		/* XMM 15  */
	char			fpu_rsrv4[6*16];	/* reserved */
	int 			fpu_reserved1;
	char			__avx_reserved1[64];
	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
	_STRUCT_XMM_REG		__fpu_ymmh8;		/* YMMH 8  */
	_STRUCT_XMM_REG		__fpu_ymmh9;		/* YMMH 9  */
	_STRUCT_XMM_REG		__fpu_ymmh10;		/* YMMH 10  */
	_STRUCT_XMM_REG		__fpu_ymmh11;		/* YMMH 11  */
	_STRUCT_XMM_REG		__fpu_ymmh12;		/* YMMH 12  */
	_STRUCT_XMM_REG		__fpu_ymmh13;		/* YMMH 13  */
	_STRUCT_XMM_REG		__fpu_ymmh14;		/* YMMH 14  */
	_STRUCT_XMM_REG		__fpu_ymmh15;		/* YMMH 15  */
};

#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_EXCEPTION_STATE64	struct __darwin_x86_exception_state64
_STRUCT_X86_EXCEPTION_STATE64
{
    unsigned int	__trapno;
    unsigned int	__err;
    __uint64_t		__faultvaddr;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_EXCEPTION_STATE64	struct x86_exception_state64
_STRUCT_X86_EXCEPTION_STATE64
{
    unsigned int	trapno;
    unsigned int	err;
    __uint64_t		faultvaddr;
};
#endif /* !__DARWIN_UNIX03 */

#if __DARWIN_UNIX03
#define _STRUCT_X86_DEBUG_STATE64	struct __darwin_x86_debug_state64
_STRUCT_X86_DEBUG_STATE64
{
	__uint64_t	__dr0;
	__uint64_t	__dr1;
	__uint64_t	__dr2;
	__uint64_t	__dr3;
	__uint64_t	__dr4;
	__uint64_t	__dr5;
	__uint64_t	__dr6;
	__uint64_t	__dr7;
};
#else /* !__DARWIN_UNIX03 */
#define _STRUCT_X86_DEBUG_STATE64	struct x86_debug_state64
_STRUCT_X86_DEBUG_STATE64
{
	__uint64_t	dr0;
	__uint64_t	dr1;
	__uint64_t	dr2;
	__uint64_t	dr3;
	__uint64_t	dr4;
	__uint64_t	dr5;
	__uint64_t	dr6;
	__uint64_t	dr7;
};
#endif /* !__DARWIN_UNIX03 */

#endif /* _MACH_I386__STRUCTS_H_ */
                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/asm.h             0100644 0001750 0001750 00000021337 12612724206 026054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#ifndef	_I386_ASM_H_
#define	_I386_ASM_H_

#ifdef _KERNEL
#include <gprof.h>
#endif	/* _KERNEL */

#ifdef MACH_KERNEL
#include <mach_kdb.h>
#else	/* !MACH_KERNEL */
#define	MACH_KDB 0
#endif	/* !MACH_KERNEL */


#if	defined(MACH_KERNEL) || defined(_KERNEL)
#include <gprof.h>
#endif	/* MACH_KERNEL || _KERNEL */

#if defined(__i386__)

#define S_PC	 (%esp)
#define S_ARG0	 4(%esp)
#define S_ARG1	 8(%esp)
#define S_ARG2	12(%esp)
#define S_ARG3	16(%esp)
#define S_ARG4	20(%esp)

#define FRAME	pushl %ebp; movl %esp, %ebp
#define EMARF	leave

#define B_LINK	 (%ebp)
#define B_PC	 4(%ebp)
#define B_ARG0	 8(%ebp)
#define B_ARG1	12(%ebp)
#define B_ARG2	16(%ebp)
#define B_ARG3	20(%ebp)

#elif defined(__x86_64__)

#define S_PC	 (%rsp)

#define FRAME	pushq %rbp; movq %rsp, %rbp
#define EMARF	leave

#define B_LINK	 (%rbp)
#define B_PC	 8(%rbp)

#else
#error unsupported architecture
#endif

/* There is another definition of ALIGN for .c sources */
#ifdef ASSEMBLER
#define ALIGN 4,0x90
#endif /* ASSEMBLER */

#ifndef FALIGN
#define FALIGN ALIGN
#endif

#define LB(x,n) n
#if	__STDC__
#ifndef __NO_UNDERSCORES__
#define	LCL(x)	L ## x
#define EXT(x) _ ## x
#define LEXT(x) _ ## x ## :
#else
#define	LCL(x)	.L ## x
#define EXT(x) x
#define LEXT(x) x ## :
#endif
#define LBc(x,n) n ## :
#define LBb(x,n) n ## b
#define LBf(x,n) n ## f
#else /* __STDC__ */
#ifndef __NO_UNDERSCORES__
#define LCL(x) L/**/x
#define EXT(x) _/**/x
#define LEXT(x) _/**/x/**/:
#else /* __NO_UNDERSCORES__ */
#define	LCL(x)	.L/**/x
#define EXT(x) x
#define LEXT(x) x/**/:
#endif /* __NO_UNDERSCORES__ */
#define LBc(x,n) n/**/:
#define LBb(x,n) n/**/b
#define LBf(x,n) n/**/f
#endif /* __STDC__ */

#define SVC .byte 0x9a; .long 0; .word 0x7

#define RPC_SVC .byte 0x9a; .long 0; .word 0xf

#define String	.asciz
#define Value	.word
#define Times(a,b) (a*b)
#define Divide(a,b) (a/b)

#define INB	inb	%dx, %al
#define OUTB	outb	%al, %dx
#define INL	inl	%dx, %eax
#define OUTL	outl	%eax, %dx

#define data16	.byte 0x66
#define addr16	.byte 0x67

#if !GPROF
#define MCOUNT

#elif defined(__SHARED__)
#define MCOUNT		; .data;\
			.align ALIGN;\
			LBc(x, 8) .long 0;\
			.text;\
			Gpush;\
			Gload;\
			leal Gotoff(LBb(x,8)),%edx;\
			Egaddr(%eax,_mcount_ptr);\
			Gpop;\
			call *(%eax);

#else	/* !GPROF, !__SHARED__ */
#define MCOUNT		; call mcount;
#endif /* GPROF */

#ifdef __ELF__
#define ELF_FUNC(x)	.type x,@function
#define ELF_DATA(x)	.type x,@object
#define ELF_SIZE(x,s)	.size x,s
#else
#define ELF_FUNC(x)
#define ELF_DATA(x)
#define ELF_SIZE(x,s)
#endif

#define	Entry(x)	.globl EXT(x); ELF_FUNC(EXT(x)); .align FALIGN; LEXT(x)
#define	ENTRY(x)	Entry(x) MCOUNT
#define	ENTRY2(x,y)	.globl EXT(x); .globl EXT(y); \
			ELF_FUNC(EXT(x)); ELF_FUNC(EXT(y)); \
			.align FALIGN; LEXT(x); LEXT(y) \
			MCOUNT
#if __STDC__
#define	ASENTRY(x) 	.globl x; .align FALIGN; x ## : ELF_FUNC(x) MCOUNT
#else
#define	ASENTRY(x) 	.globl x; .align FALIGN; x: ELF_FUNC(x) MCOUNT
#endif /* __STDC__ */

#define	DATA(x)		.globl EXT(x); ELF_DATA(EXT(x)); .align ALIGN; LEXT(x)

#define End(x)		ELF_SIZE(x,.-x)
#define END(x)		End(EXT(x))
#define ENDDATA(x)	END(x)
#define Enddata(x)	End(x)

/*
 * ELF shared library accessor macros.
 * Gpush saves the %ebx register used for the GOT address
 * Gpop pops %ebx if we need a GOT
 * Gload loads %ebx with the GOT address if shared libraries are used
 * Gcall calls an external function.
 * Gotoff allows you to reference local labels.
 * Gotoff2 allows you to reference local labels with an index reg.
 * Gotoff3 allows you to reference local labels with an index reg & size.
 * Gaddr loads up a register with an address of an external item.
 * Gstack is the number of bytes that Gpush pushes on the stack.
 *
 * Varients of the above with E or L prefixes do EXT(name) or LCL(name)
 * respectively.
 */

#ifndef __SHARED__
#define Gpush
#define Gpop
#define Gload
#define Gcall(func)		call func
#define Gotoff(lab)		lab
#define Gotoff2(l,r)		l(r)
#define Gotoff3(l,r,s)		l(,r,s)
#define Gaddr(to,lab)		movl $lab,to
#define Gcmp(lab,reg)		cmpl $lab,reg
#define Gmemload(lab,reg)	movl lab,reg
#define Gmemstore(reg,lab,tmp)	movl reg,lab
#define Gstack			0

#else
#ifdef __ELF__			/* ELF shared libraries */
#define Gpush			pushl %ebx
#define Gpop			popl %ebx
#define Gload			call 9f; 9: popl %ebx; addl $_GLOBAL_OFFSET_TABLE_+[.-9b],%ebx
#define Gcall(func)		call EXT(func)@PLT
#define Gotoff(lab)		lab@GOTOFF(%ebx)
#define Gotoff2(l,r)		l@GOTOFF(%ebx,r)
#define Gotoff3(l,r,s)		l@GOTOFF(%ebx,r,s)
#define Gaddr(to,lab)		movl lab@GOT(%ebx),to
#define Gcmp(lab,reg)		cmpl reg,lab@GOT(%ebx)
#define Gmemload(lab,reg)	movl lab@GOT(%ebx),reg; movl (reg),reg
#define Gmemstore(reg,lab,tmp)	movl lab@GOT(%ebx),tmp; movl reg,(tmp)
#define Gstack			4

#else				/* ROSE shared libraries */
#define Gpush
#define Gpop
#define Gload
#define Gcall(func)		call *9f; .data; .align ALIGN; 9: .long func; .text
#define Gotoff(lab)		lab
#define Gotoff2(l,r)		l(r)
#define Gotoff3(l,r,s)		l(,r,s)
#define Gaddr(to,lab)		movl 9f,to; .data; .align ALIGN; 9: .long lab; .text
#define Gcmp(lab,reg)		cmpl reg,9f; .data; .align ALIGN; 9: .long lab; .text
#define Gmemload(lab,reg)	movl 9f,reg; movl (reg),reg; .data; .align ALIGN; 9: .long lab; .text
#define Gmemstore(reg,lab,tmp)	movl 9f,tmp; movl reg,(tmp); .data; .align ALIGN; 9: .long lab; .text
#define Gstack			0
#endif	/* __ELF__ */
#endif	/* __SHARED__ */

/* Egotoff is not provided, since external symbols should not use @GOTOFF
   relocations.  */
#define Egcall(func)		Gcall(EXT(func))
#define Egaddr(to,lab)		Gaddr(to,EXT(lab))
#define Egcmp(lab,reg)		Gcmp(EXT(lab),reg)
#define Egmemload(lab,reg)	Gmemload(EXT(lab),reg)
#define Egmemstore(reg,lab,tmp)	Gmemstore(reg,EXT(lab),tmp)

#define Lgotoff(lab)		Gotoff(LCL(lab))
#define Lgotoff2(l,r)		Gotoff2(LCL(l),r)
#define Lgotoff3(l,r,s)		Gotoff3(LCL(l),r,s)
#define Lgcmp(lab,reg)		Gcmp(LCL(lab),reg)
#define Lgmemload(lab,reg)	movl Lgotoff(lab),reg
#define Lgmemstore(reg,lab,tmp)	movl reg,Lgotoff(lab)

#ifdef ASSEMBLER
#if	MACH_KDB
#include <ddb/stab.h>
/*
 * This pseudo-assembler line is added so that there will be at least
 *	one N_SO entry in the symbol stable to define the current file name.
 */
#endif	/* MACH_KDB */

#else /* NOT ASSEMBLER */

/* These defines are here for .c files that wish to reference global symbols
 * within __asm__ statements. 
 */
#ifndef __NO_UNDERSCORES__
#define CC_SYM_PREFIX "_"
#else
#define CC_SYM_PREFIX ""
#endif /* __NO_UNDERSCORES__ */
#endif /* ASSEMBLER */

#endif /* _I386_ASM_H_ */
                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/boolean.h         0100644 0001750 0001750 00000005165 12612724206 026714  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

/*
 *	File:	boolean.h
 *
 *	Boolean type, for I386.
 */

#ifndef	_MACH_I386_BOOLEAN_H_
#define _MACH_I386_BOOLEAN_H_

#if defined(__x86_64__) && !defined(KERNEL)
typedef unsigned int	boolean_t;
#else
typedef int		boolean_t;
#endif

#endif	/* _MACH_I386_BOOLEAN_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/exception.h       0100644 0001750 0001750 00000010356 12612724206 027271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_MACH_I386_EXCEPTION_H_
#define _MACH_I386_EXCEPTION_H_

/*
 * No machine dependent types for the 80386
 */

#define	EXC_TYPES_COUNT	11	/* incl. illegal exception 0 */

/*
 *	Codes and subcodes for 80386 exceptions.
 */

#define EXCEPTION_CODE_MAX	2	/* currently code and subcode */

/*
 *	EXC_BAD_INSTRUCTION
 */

#define EXC_I386_INVOP			1

/*
 *	EXC_ARITHMETIC
 */

#define EXC_I386_DIV			1
#define EXC_I386_INTO			2
#define EXC_I386_NOEXT			3
#define EXC_I386_EXTOVR			4
#define EXC_I386_EXTERR			5
#define EXC_I386_EMERR			6
#define EXC_I386_BOUND			7
#define EXC_I386_SSEEXTERR              8

/*
 *	EXC_SOFTWARE
 *	Note: 0x10000-0x10003 in use for unix signal
 */

/*
 *	EXC_BAD_ACCESS
 */

/*
 *	EXC_BREAKPOINT
 */

#define EXC_I386_SGL			1
#define EXC_I386_BPT			2

#define EXC_I386_DIVERR		0	/* divide by 0 eprror		*/
#define EXC_I386_SGLSTP		1	/* single step			*/
#define EXC_I386_NMIFLT		2	/* NMI				*/
#define EXC_I386_BPTFLT		3	/* breakpoint fault		*/
#define EXC_I386_INTOFLT	4	/* INTO overflow fault		*/
#define EXC_I386_BOUNDFLT	5	/* BOUND instruction fault	*/
#define EXC_I386_INVOPFLT	6	/* invalid opcode fault		*/
#define EXC_I386_NOEXTFLT	7	/* extension not available fault*/
#define EXC_I386_DBLFLT		8	/* double fault			*/
#define EXC_I386_EXTOVRFLT	9	/* extension overrun fault	*/
#define EXC_I386_INVTSSFLT	10	/* invalid TSS fault		*/
#define EXC_I386_SEGNPFLT	11	/* segment not present fault	*/
#define EXC_I386_STKFLT		12	/* stack fault			*/
#define EXC_I386_GPFLT		13	/* general protection fault	*/
#define EXC_I386_PGFLT		14	/* page fault			*/
#define EXC_I386_EXTERRFLT	16	/* extension error fault	*/
#define	EXC_I386_ALIGNFLT	17	/* Alignment fault */
#define EXC_I386_ENDPERR	33	/* emulated extension error flt	*/
#define EXC_I386_ENOEXTFLT	32	/* emulated ext not present	*/


/*
 *	machine dependent exception masks
 */
#define	EXC_MASK_MACHINE	0

#endif	/* _MACH_I386_EXCEPTION_H_ */
                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/fp_reg.h          0100644 0001750 0001750 00000010663 12612724206 026536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1992-1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_I386_FP_SAVE_H_
#define	_I386_FP_SAVE_H_

/*
 * Control register
 */
#define	FPC_IE		0x0001		/* enable invalid operation
					   exception */
#define FPC_IM		FPC_IE
#define	FPC_DE		0x0002		/* enable denormalized operation
					   exception */
#define FPC_DM		FPC_DE
#define	FPC_ZE		0x0004		/* enable zero-divide exception */
#define FPC_ZM		FPC_ZE
#define	FPC_OE		0x0008		/* enable overflow exception */
#define FPC_OM		FPC_OE
#define	FPC_UE		0x0010		/* enable underflow exception */
#define	FPC_PE		0x0020		/* enable precision exception */
#define	FPC_PC		0x0300		/* precision control: */
#define	FPC_PC_24	0x0000			/* 24 bits */
#define	FPC_PC_53	0x0200			/* 53 bits */
#define	FPC_PC_64	0x0300			/* 64 bits */
#define	FPC_RC		0x0c00		/* rounding control: */
#define	FPC_RC_RN	0x0000			/* round to nearest or even */
#define	FPC_RC_RD	0x0400			/* round down */
#define	FPC_RC_RU	0x0800			/* round up */
#define	FPC_RC_CHOP	0x0c00			/* chop */
#define	FPC_IC		0x1000		/* infinity control (obsolete) */
#define	FPC_IC_PROJ	0x0000			/* projective infinity */
#define	FPC_IC_AFF	0x1000			/* affine infinity (std) */

/*
 * Status register
 */
#define	FPS_IE		0x0001		/* invalid operation */
#define	FPS_DE		0x0002		/* denormalized operand */
#define	FPS_ZE		0x0004		/* divide by zero */
#define	FPS_OE		0x0008		/* overflow */
#define	FPS_UE		0x0010		/* underflow */
#define	FPS_PE		0x0020		/* precision */
#define	FPS_SF		0x0040		/* stack flag */
#define	FPS_ES		0x0080		/* error summary */
#define	FPS_C0		0x0100		/* condition code bit 0 */
#define	FPS_C1		0x0200		/* condition code bit 1 */
#define	FPS_C2		0x0400		/* condition code bit 2 */
#define	FPS_TOS		0x3800		/* top-of-stack pointer */
#define	FPS_TOS_SHIFT	11
#define	FPS_C3		0x4000		/* condition code bit 3 */
#define	FPS_BUSY	0x8000		/* FPU busy */

/*
 * Kind of floating-point support provided by kernel.
 */
#define	FP_NO		0		/* no floating point */
#define	FP_SOFT		1		/* software FP emulator */
#define	FP_287		2		/* 80287 */
#define	FP_387		3		/* 80387 or 80486 */
#define FP_FXSR		4		/* Fast save/restore SIMD Extension */

#endif	/* _I386_FP_SAVE_H_ */
                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/kern_return.h     0100644 0001750 0001750 00000005254 12612724206 027632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

/*
 *	File:	kern_return.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Machine-dependent kernel return definitions.
 */

#ifndef	_MACH_I386_KERN_RETURN_H_
#define _MACH_I386_KERN_RETURN_H_

#ifndef	ASSEMBLER
typedef	int		kern_return_t;
#endif	/* ASSEMBLER */

#endif	/* _MACH_I386_KERN_RETURN_H_ */
                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/machine_types.defs0100644 0001750 0001750 00000006725 12612724206 030622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

/*
 *	Header file for basic, machine-dependent data types.  i386 version.
 */

#ifndef	_MACHINE_VM_TYPES_DEFS_
#define	_MACHINE_VM_TYPES_DEFS_	1

type short = int16_t;
type int = int32_t;
type unsigned = uint32_t;

type float = MACH_MSG_TYPE_REAL_32;
type double = MACH_MSG_TYPE_REAL_64;


/* from ISO/IEC 988:1999 spec */
/* 7.18.1.4 Integer types capable of hgolding object pointers */
/*
 * The [u]intptr_t types for the native
 * integer type, e.g. 32 or 64 or.. whatever
 * register size the machine has.  They are
 * used for entities that might be either
 * [unsigned] integers or pointers, and for
 * type-casting between the two.
 *
 * For instance, the IPC system represents
 * a port in user space as an integer and
 * in kernel space as a pointer.
 */
#if defined(__LP64__)
type uintptr_t = uint64_t;
type intptr_t = int64_t;
#else
type uintptr_t = uint32_t;
type intptr_t = int32_t;
#endif

/*
 * These are the legacy Mach types that are
 * the [rough] equivalents of the standards above.
 * They were defined in terms of int, not
 * long int, so they remain separate.
 */
#if defined(__LP64__)
type register_t = int64_t;
#else
type register_t = int32_t;
#endif
type integer_t = int32_t;
type natural_t = uint32_t;

/*
 * These are the VM types that scale with the address
 * space size of a given process.
 */

#if defined(__LP64__)
type vm_address_t = uint64_t;
type vm_offset_t = uint64_t;
type vm_size_t = uint64_t;
#else
type vm_address_t = natural_t;
type vm_offset_t = natural_t;
type vm_size_t = natural_t;
#endif

/*
 * The mach_vm_xxx_t types are sized to hold the
 * maximum pointer, offset, etc... supported on the
 * platform.
 */
type mach_vm_address_t = uint64_t;
type mach_vm_offset_t = uint64_t;
type mach_vm_size_t = uint64_t;

#if	MACH_IPC_COMPAT
/*
 * For the old IPC interface
 */
#define	MSG_TYPE_PORT_NAME	natural_t

#endif	/* MACH_IPC_COMPAT */

/*
 * These are types used internal to Mach to implement the
 * legacy 32-bit VM APIs published by the kernel.
 */
#define	VM32_SUPPORT	1

type vm32_address_t = uint32_t;
type vm32_offset_t = uint32_t;
type vm32_size_t = uint32_t;

#endif	/* _MACHINE_VM_TYPES_DEFS_ */

/* vim: set ft=c : */
                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/ndr_def.h         0100644 0001750 0001750 00000003106 12612724206 026667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

/* NDR record for Intel x86s */

#include <mach/ndr.h>

NDR_record_t NDR_record = {
	0,			/* mig_reserved */
	0,			/* mig_reserved */
	0,			/* mig_reserved */
	NDR_PROTOCOL_2_0,		
	NDR_INT_LITTLE_ENDIAN,
	NDR_CHAR_ASCII,
	NDR_FLOAT_IEEE,
	0,
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/processor_info.h  0100644 0001750 0001750 00000003034 12612724206 030320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 *	File:	mach/i386/processor_info.h
 *
 *	Data structure definitions for i386 specific processor control
 */

#ifndef	_MACH_I386_PROCESSOR_INFO_H_
#define _MACH_I386_PROCESSOR_INFO_H_

#endif	/* _MACH_I386_PROCESSOR_INFO_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/rpc.h             0100644 0001750 0001750 00000002653 12612724206 026060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2002,2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_MACH_I386_RPC_H_
#define	_MACH_I386_RPC_H_

#endif	/* _MACH_I386_RPC_H_ */

                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/sdt_isa.h         0100644 0001750 0001750 00000036552 12612724206 026727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef _MACH_I386_SDT_ISA_H
#define	_MACH_I386_SDT_ISA_H

/*
 * Only define when testing.  This makes the calls into actual calls to
 * test functions.
 */
/* #define DTRACE_CALL_TEST */

#define DTRACE_STRINGIFY(s) #s
#define DTRACE_TOSTRING(s) DTRACE_STRINGIFY(s)
#define DTRACE_LABEL(p, n)									\
	"__dtrace_probe$" DTRACE_TOSTRING(__LINE__) DTRACE_STRINGIFY(_##p##___##n) ":"	"\n\t"

#ifdef DTRACE_CALL_TEST

#define DTRACE_CALL(p,n)	\
	DTRACE_LABEL(p,n)	\
	DTRACE_CALL_INSN(p,n)

#else

#define DTRACE_CALL(p,n)	\
	DTRACE_LABEL(p,n)	\
	DTRACE_NOPS

#endif

#ifdef __x86_64__

#define DTRACE_NOPS			\
	"nop"			"\n\t"	\
	"nop"			"\n\t"	\
	"nop"			"\n\t"	

#define DTRACE_CALL_INSN(p,n)						\
	"call _dtracetest" DTRACE_STRINGIFY(_##p##_##n)	"\n\t"

#define ARG1_EXTENT	1
#define ARGS2_EXTENT	2
#define ARGS3_EXTENT	3
#define ARGS4_EXTENT	4
#define ARGS5_EXTENT	5
#define ARGS6_EXTENT	6
#define ARGS7_EXTENT	7
#define ARGS8_EXTENT	8
#define ARGS9_EXTENT	10	
#define ARGS10_EXTENT	10	

#define DTRACE_CALL0ARGS(provider, name)							\
	asm volatile (										\
		      DTRACE_CALL(provider, name)						\
	);

#define DTRACE_CALL1ARG(provider, name)								\
	asm volatile ("movq\t0x0(%0),%%rdi"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi"								\
	);

#define DTRACE_CALL2ARGS(provider, name)							\
	asm volatile ("movq\t0x0(%0),%%rdi"						"\n\t"	\
	              "movq\t0x8(%0),%%rsi"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi", "rsi"							\
	);

#define DTRACE_CALL3ARGS(provider, name)							\
	asm volatile ("movq\t0x0(%0),%%rdi"						"\n\t"	\
	              "movq\t0x8(%0),%%rsi"						"\n\t"	\
	              "movq\t0x10(%0),%%rdx"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi", "rsi", "rdx"						\
	);

#define DTRACE_CALL4ARGS(provider, name)							\
	asm volatile ("movq\t0x0(%0),%%rdi"						"\n\t"	\
	              "movq\t0x8(%0),%%rsi"						"\n\t"	\
	              "movq\t0x10(%0),%%rdx"						"\n\t"	\
	              "movq\t0x18(%0),%%rcx"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi", "rsi", "rdx", "rcx"					\
	);

#define DTRACE_CALL5ARGS(provider, name)							\
	asm volatile ("movq\t0x0(%0),%%rdi"						"\n\t"	\
	              "movq\t0x8(%0),%%rsi"						"\n\t"	\
	              "movq\t0x10(%0),%%rdx"						"\n\t"	\
	              "movq\t0x18(%0),%%rcx"						"\n\t"	\
	              "movq\t0x20(%0),%%r8"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi", "rsi", "rdx", "rcx", "r8"				\
	);

#define DTRACE_CALL6ARGS(provider, name)							\
	asm volatile ("movq\t0x0(%0),%%rdi"						"\n\t"	\
	              "movq\t0x8(%0),%%rsi"						"\n\t"	\
	              "movq\t0x10(%0),%%rdx"						"\n\t"	\
	              "movq\t0x18(%0),%%rcx"						"\n\t"	\
	              "movq\t0x20(%0),%%r8"						"\n\t"	\
	              "movq\t0x28(%0),%%r9"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi", "rsi", "rdx", "rcx", "r8", "r9"			\
	);

#define DTRACE_CALL7ARGS(provider, name)							\
	asm volatile ("subq\t$0x8,%%rsp"						"\n\t"	\
	              "movq\t0x0(%0),%%rdi"						"\n\t"	\
	              "movq\t0x8(%0),%%rsi"						"\n\t"	\
	              "movq\t0x10(%0),%%rdx"						"\n\t"	\
	              "movq\t0x18(%0),%%rcx"						"\n\t"	\
	              "movq\t0x20(%0),%%r8"						"\n\t"	\
	              "movq\t0x28(%0),%%r9"						"\n\t"	\
	              "movq\t0x30(%0),%%rax"						"\n\t"	\
	              "movq\t%%rax,0x0(%%rsp)"						"\n\t"	\
		      DTRACE_CALL(provider, name)						\
	              "addq\t$0x8,%%rsp"						"\n\t"	\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "rdi", "rsi", "rdx", "rcx", "r8", "r9", "rax"			\
	);

#endif // __x86_64__

#ifdef __i386__

#define DTRACE_NOPS			\
	"nop"			"\n\t"	\
	"leal 0(%%esi), %%esi"	"\n\t"	

#define DTRACE_CALL_INSN(p,n)						\
	"call _dtracetest" DTRACE_STRINGIFY(_##p##_##n)	"\n\t"

#define ARG1_EXTENT	1
#define ARGS2_EXTENT	2
#define ARGS3_EXTENT	4
#define ARGS4_EXTENT	4
#define ARGS5_EXTENT	8
#define ARGS6_EXTENT	8
#define ARGS7_EXTENT	8
#define ARGS8_EXTENT	8
#define ARGS9_EXTENT	12	
#define ARGS10_EXTENT	12	

/*
 * Because this code is used in the kernel, we must not touch any floating point
 * or specialized registers. This leaves the following registers:
 *
 * eax ; volatile, safe to use
 * ebx ; PIC register, gcc error when used
 * ecx ; volatile, safe to use
 * edx ; volatile, safe to use
 * esi ; non-volatile, otherwise safe to use
 * edi ; non-volatile, otherwise safe to use
 *
 * Using any of the non volatile register causes a spill to stack which is almost
 * certainly a net performance loss. Also, note that the array ref (__dtrace_args)
 * consumes one free register. If all three of the volatile regs are used for load/store,
 * the compiler will spill a register to hold the array ref.
 *
 * The end result is that we only pipeline two loads/stores at a time. Blech.
 */

#define DTRACE_CALL0ARGS(provider, name)							\
	asm volatile (										\
	              DTRACE_CALL(provider, name)						\
	              "# eat trailing nl +tabfrom DTRACE_CALL"					\
	              :										\
	              :										\
	);

#define DTRACE_CALL1ARG(provider, name)								\
	asm volatile ("subl\t$0x10,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x10,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)		       					\
	              : "memory", "eax"								\
	);

#define DTRACE_CALL2ARGS(provider, name)							\
	asm volatile ("subl\t$0x10,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x10,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"							\
	);

#define DTRACE_CALL3ARGS(provider, name)							\
	asm volatile ("subl\t$0x10,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x10,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"							\
	);

#define DTRACE_CALL4ARGS(provider, name)							\
	asm volatile ("subl\t$0x10,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x10,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#define DTRACE_CALL5ARGS(provider, name)							\
	asm volatile ("subl\t$0x20,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              "movl\t0x10(%0),%%eax"						"\n\t"	\
	              "movl\t%%eax,0x10(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x20,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#define DTRACE_CALL6ARGS(provider, name)							\
	asm volatile ("subl\t$0x20,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              "movl\t0x10(%0),%%eax"						"\n\t"	\
		      "movl\t0x14(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x10(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x14(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x20,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#define DTRACE_CALL7ARGS(provider, name)							\
	asm volatile ("subl\t$0x20,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              "movl\t0x10(%0),%%eax"						"\n\t"	\
		      "movl\t0x14(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x10(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x14(%%esp)"						"\n\t"	\
	              "movl\t0x18(%0),%%eax"						"\n\t"	\
	              "movl\t%%eax,0x18(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x20,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#define DTRACE_CALL8ARGS(provider, name)							\
	asm volatile ("subl\t$0x20,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              "movl\t0x10(%0),%%eax"						"\n\t"	\
		      "movl\t0x14(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x10(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x14(%%esp)"						"\n\t"	\
	              "movl\t0x18(%0),%%eax"						"\n\t"	\
		      "movl\t0x1C(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x18(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x1C(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x20,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#define DTRACE_CALL9ARGS(provider, name)							\
	asm volatile ("subl\t$0x30,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              "movl\t0x10(%0),%%eax"						"\n\t"	\
		      "movl\t0x14(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x10(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x14(%%esp)"						"\n\t"	\
	              "movl\t0x18(%0),%%eax"						"\n\t"	\
		      "movl\t0x1C(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x18(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x1C(%%esp)"						"\n\t"	\
	              "movl\t0x20(%0),%%eax"						"\n\t"	\
	              "movl\t%%eax,0x20(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x30,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#define DTRACE_CALL10ARGS(provider, name)							\
	asm volatile ("subl\t$0x30,%%esp"						"\n\t"	\
	              "movl\t0x0(%0),%%eax"						"\n\t"	\
		      "movl\t0x4(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x0(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x4(%%esp)"						"\n\t"	\
	              "movl\t0x8(%0),%%eax"						"\n\t"	\
		      "movl\t0xC(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x8(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0xC(%%esp)"						"\n\t"	\
	              "movl\t0x10(%0),%%eax"						"\n\t"	\
		      "movl\t0x14(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x10(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x14(%%esp)"						"\n\t"	\
	              "movl\t0x18(%0),%%eax"						"\n\t"	\
		      "movl\t0x1C(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x18(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x1C(%%esp)"						"\n\t"	\
	              "movl\t0x20(%0),%%eax"						"\n\t"	\
		      "movl\t0x24(%0),%%edx"						"\n\t"	\
	              "movl\t%%eax,0x20(%%esp)"						"\n\t"	\
	              "movl\t%%edx,0x24(%%esp)"						"\n\t"	\
	              DTRACE_CALL(provider, name)						\
                      "addl\t$0x30,%%esp"							\
	              :										\
	              : "r" (__dtrace_args)							\
	              : "memory", "eax", "edx"	       						\
	);

#endif // __i386__

#endif	/* _MACH_I386_SDT_ISA_H */
                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/task.h            0100644 0001750 0001750 00000103620 12612724206 026232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_task_user_
#define	_task_user_

/* Module task */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	task_MSG_COUNT
#define	task_MSG_COUNT	35
#endif	/* task_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine task_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_create
(
	task_t target_task,
	ledger_array_t ledgers,
	mach_msg_type_number_t ledgersCnt,
	boolean_t inherit_memory,
	task_t *child_task
);

/* Routine task_terminate */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_terminate
(
	task_t target_task
);

/* Routine task_threads */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_threads
(
	task_t target_task,
	thread_act_array_t *act_list,
	mach_msg_type_number_t *act_listCnt
);

/* Routine mach_ports_register */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_ports_register
(
	task_t target_task,
	mach_port_array_t init_port_set,
	mach_msg_type_number_t init_port_setCnt
);

/* Routine mach_ports_lookup */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_ports_lookup
(
	task_t target_task,
	mach_port_array_t *init_port_set,
	mach_msg_type_number_t *init_port_setCnt
);

/* Routine task_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_info
(
	task_name_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_out,
	mach_msg_type_number_t *task_info_outCnt
);

/* Routine task_set_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_info
(
	task_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_in,
	mach_msg_type_number_t task_info_inCnt
);

/* Routine task_suspend */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_suspend
(
	task_t target_task
);

/* Routine task_resume */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_resume
(
	task_t target_task
);

/* Routine task_get_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_special_port
(
	task_t task,
	int which_port,
	mach_port_t *special_port
);

/* Routine task_set_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_special_port
(
	task_t task,
	int which_port,
	mach_port_t special_port
);

/* Routine thread_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_create
(
	task_t parent_task,
	thread_act_t *child_act
);

/* Routine thread_create_running */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_create_running
(
	task_t parent_task,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt,
	thread_act_t *child_act
);

/* Routine task_set_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
);

/* Routine task_get_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine task_swap_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_swap_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlerss,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine lock_set_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t lock_set_create
(
	task_t task,
	lock_set_t *new_lock_set,
	int n_ulocks,
	int policy
);

/* Routine lock_set_destroy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t lock_set_destroy
(
	task_t task,
	lock_set_t lock_set
);

/* Routine semaphore_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t semaphore_create
(
	task_t task,
	semaphore_t *semaphore,
	int policy,
	int value
);

/* Routine semaphore_destroy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t semaphore_destroy
(
	task_t task,
	semaphore_t semaphore
);

/* Routine task_policy_set */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_policy_set
(
	task_t task,
	task_policy_flavor_t flavor,
	task_policy_t policy_info,
	mach_msg_type_number_t policy_infoCnt
);

/* Routine task_policy_get */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_policy_get
(
	task_t task,
	task_policy_flavor_t flavor,
	task_policy_t policy_info,
	mach_msg_type_number_t *policy_infoCnt,
	boolean_t *get_default
);

/* Routine task_sample */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_sample
(
	task_t task,
	mach_port_t reply
);

/* Routine task_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_policy
(
	task_t task,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	boolean_t set_limit,
	boolean_t change
);

/* Routine task_set_emulation */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_emulation
(
	task_t target_port,
	vm_address_t routine_entry_pt,
	int routine_number
);

/* Routine task_get_emulation_vector */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_emulation_vector
(
	task_t task,
	int *vector_start,
	emulation_vector_t *emulation_vector,
	mach_msg_type_number_t *emulation_vectorCnt
);

/* Routine task_set_emulation_vector */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_emulation_vector
(
	task_t task,
	int vector_start,
	emulation_vector_t emulation_vector,
	mach_msg_type_number_t emulation_vectorCnt
);

/* Routine task_set_ras_pc */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_ras_pc
(
	task_t target_task,
	vm_address_t basepc,
	vm_address_t boundspc
);

/* Routine task_assign */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_assign
(
	task_t task,
	processor_set_t new_set,
	boolean_t assign_threads
);

/* Routine task_assign_default */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_assign_default
(
	task_t task,
	boolean_t assign_threads
);

/* Routine task_get_assignment */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_assignment
(
	task_t task,
	processor_set_name_t *assigned_set
);

/* Routine task_set_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_policy
(
	task_t task,
	processor_set_t pset,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	policy_limit_t limit,
	mach_msg_type_number_t limitCnt,
	boolean_t change
);

/* Routine task_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_state
(
	task_t task,
	thread_state_flavor_t flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
);

/* Routine task_set_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_state
(
	task_t task,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__task_subsystem__defined
#define __Request__task_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t ledgers;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ledgersCnt;
		boolean_t inherit_memory;
	} __Request__task_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_terminate_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_threads_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
	} __Request__mach_ports_register_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__mach_ports_lookup_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_outCnt;
	} __Request__task_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_inCnt;
		integer_t task_info_in[10];
	} __Request__task_set_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_suspend_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_resume_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} __Request__task_get_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which_port;
	} __Request__task_set_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[144];
	} __Request__thread_create_running_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__task_set_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__task_get_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__task_swap_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int n_ulocks;
		int policy;
	} __Request__lock_set_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t lock_set;
		/* end of the kernel processed data */
	} __Request__lock_set_destroy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int policy;
		int value;
	} __Request__semaphore_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Request__semaphore_destroy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
	} __Request__task_policy_set_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		boolean_t get_default;
	} __Request__task_policy_get_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t reply;
		/* end of the kernel processed data */
	} __Request__task_sample_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		boolean_t set_limit;
		boolean_t change;
	} __Request__task_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t routine_entry_pt;
		int routine_number;
	} __Request__task_set_emulation_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_get_emulation_vector_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
	} __Request__task_set_emulation_vector_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t basepc;
		vm_address_t boundspc;
	} __Request__task_set_ras_pc_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t assign_threads;
	} __Request__task_assign_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t assign_threads;
	} __Request__task_assign_default_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_get_assignment_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pset;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		mach_msg_type_number_t limitCnt;
		integer_t limit[1];
		boolean_t change;
	} __Request__task_set_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t old_stateCnt;
	} __Request__task_get_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[144];
	} __Request__task_set_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__task_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__task_subsystem__defined
#define __RequestUnion__task_subsystem__defined
union __RequestUnion__task_subsystem {
	__Request__task_create_t Request_task_create;
	__Request__task_terminate_t Request_task_terminate;
	__Request__task_threads_t Request_task_threads;
	__Request__mach_ports_register_t Request_mach_ports_register;
	__Request__mach_ports_lookup_t Request_mach_ports_lookup;
	__Request__task_info_t Request_task_info;
	__Request__task_set_info_t Request_task_set_info;
	__Request__task_suspend_t Request_task_suspend;
	__Request__task_resume_t Request_task_resume;
	__Request__task_get_special_port_t Request_task_get_special_port;
	__Request__task_set_special_port_t Request_task_set_special_port;
	__Request__thread_create_t Request_thread_create;
	__Request__thread_create_running_t Request_thread_create_running;
	__Request__task_set_exception_ports_t Request_task_set_exception_ports;
	__Request__task_get_exception_ports_t Request_task_get_exception_ports;
	__Request__task_swap_exception_ports_t Request_task_swap_exception_ports;
	__Request__lock_set_create_t Request_lock_set_create;
	__Request__lock_set_destroy_t Request_lock_set_destroy;
	__Request__semaphore_create_t Request_semaphore_create;
	__Request__semaphore_destroy_t Request_semaphore_destroy;
	__Request__task_policy_set_t Request_task_policy_set;
	__Request__task_policy_get_t Request_task_policy_get;
	__Request__task_sample_t Request_task_sample;
	__Request__task_policy_t Request_task_policy;
	__Request__task_set_emulation_t Request_task_set_emulation;
	__Request__task_get_emulation_vector_t Request_task_get_emulation_vector;
	__Request__task_set_emulation_vector_t Request_task_set_emulation_vector;
	__Request__task_set_ras_pc_t Request_task_set_ras_pc;
	__Request__task_assign_t Request_task_assign;
	__Request__task_assign_default_t Request_task_assign_default;
	__Request__task_get_assignment_t Request_task_get_assignment;
	__Request__task_set_policy_t Request_task_set_policy;
	__Request__task_get_state_t Request_task_get_state;
	__Request__task_set_state_t Request_task_set_state;
};
#endif /* !__RequestUnion__task_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__task_subsystem__defined
#define __Reply__task_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_task;
		/* end of the kernel processed data */
	} __Reply__task_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_terminate_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t act_list;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t act_listCnt;
	} __Reply__task_threads_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__mach_ports_register_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
	} __Reply__mach_ports_lookup_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t task_info_outCnt;
		integer_t task_info_out[10];
	} __Reply__task_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_suspend_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_resume_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply__task_get_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
	} __Reply__thread_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
	} __Reply__thread_create_running_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__task_get_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlerss[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__task_swap_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_lock_set;
		/* end of the kernel processed data */
	} __Reply__lock_set_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__lock_set_destroy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Reply__semaphore_create_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__semaphore_destroy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_policy_set_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
	} __Reply__task_policy_get_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_sample_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_emulation_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
	} __Reply__task_get_emulation_vector_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_emulation_vector_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_ras_pc_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_assign_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_assign_default_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
	} __Reply__task_get_assignment_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[144];
	} __Reply__task_get_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__task_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__task_subsystem__defined
#define __ReplyUnion__task_subsystem__defined
union __ReplyUnion__task_subsystem {
	__Reply__task_create_t Reply_task_create;
	__Reply__task_terminate_t Reply_task_terminate;
	__Reply__task_threads_t Reply_task_threads;
	__Reply__mach_ports_register_t Reply_mach_ports_register;
	__Reply__mach_ports_lookup_t Reply_mach_ports_lookup;
	__Reply__task_info_t Reply_task_info;
	__Reply__task_set_info_t Reply_task_set_info;
	__Reply__task_suspend_t Reply_task_suspend;
	__Reply__task_resume_t Reply_task_resume;
	__Reply__task_get_special_port_t Reply_task_get_special_port;
	__Reply__task_set_special_port_t Reply_task_set_special_port;
	__Reply__thread_create_t Reply_thread_create;
	__Reply__thread_create_running_t Reply_thread_create_running;
	__Reply__task_set_exception_ports_t Reply_task_set_exception_ports;
	__Reply__task_get_exception_ports_t Reply_task_get_exception_ports;
	__Reply__task_swap_exception_ports_t Reply_task_swap_exception_ports;
	__Reply__lock_set_create_t Reply_lock_set_create;
	__Reply__lock_set_destroy_t Reply_lock_set_destroy;
	__Reply__semaphore_create_t Reply_semaphore_create;
	__Reply__semaphore_destroy_t Reply_semaphore_destroy;
	__Reply__task_policy_set_t Reply_task_policy_set;
	__Reply__task_policy_get_t Reply_task_policy_get;
	__Reply__task_sample_t Reply_task_sample;
	__Reply__task_policy_t Reply_task_policy;
	__Reply__task_set_emulation_t Reply_task_set_emulation;
	__Reply__task_get_emulation_vector_t Reply_task_get_emulation_vector;
	__Reply__task_set_emulation_vector_t Reply_task_set_emulation_vector;
	__Reply__task_set_ras_pc_t Reply_task_set_ras_pc;
	__Reply__task_assign_t Reply_task_assign;
	__Reply__task_assign_default_t Reply_task_assign_default;
	__Reply__task_get_assignment_t Reply_task_get_assignment;
	__Reply__task_set_policy_t Reply_task_set_policy;
	__Reply__task_get_state_t Reply_task_get_state;
	__Reply__task_set_state_t Reply_task_set_state;
};
#endif /* !__RequestUnion__task_subsystem__defined */

#ifndef subsystem_to_name_map_task
#define subsystem_to_name_map_task \
    { "task_create", 3400 },\
    { "task_terminate", 3401 },\
    { "task_threads", 3402 },\
    { "mach_ports_register", 3403 },\
    { "mach_ports_lookup", 3404 },\
    { "task_info", 3405 },\
    { "task_set_info", 3406 },\
    { "task_suspend", 3407 },\
    { "task_resume", 3408 },\
    { "task_get_special_port", 3409 },\
    { "task_set_special_port", 3410 },\
    { "thread_create", 3411 },\
    { "thread_create_running", 3412 },\
    { "task_set_exception_ports", 3413 },\
    { "task_get_exception_ports", 3414 },\
    { "task_swap_exception_ports", 3415 },\
    { "lock_set_create", 3416 },\
    { "lock_set_destroy", 3417 },\
    { "semaphore_create", 3418 },\
    { "semaphore_destroy", 3419 },\
    { "task_policy_set", 3420 },\
    { "task_policy_get", 3421 },\
    { "task_sample", 3422 },\
    { "task_policy", 3423 },\
    { "task_set_emulation", 3424 },\
    { "task_get_emulation_vector", 3425 },\
    { "task_set_emulation_vector", 3426 },\
    { "task_set_ras_pc", 3427 },\
    { "task_assign", 3429 },\
    { "task_assign_default", 3430 },\
    { "task_get_assignment", 3431 },\
    { "task_set_policy", 3432 },\
    { "task_get_state", 3433 },\
    { "task_set_state", 3434 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _task_user_ */
                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/thread_act.h      0100644 0001750 0001750 00000062066 12612724206 027376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef	_thread_act_user_
#define	_thread_act_user_

/* Module thread_act */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	thread_act_MSG_COUNT
#define	thread_act_MSG_COUNT	25
#endif	/* thread_act_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine thread_terminate */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_terminate
(
	thread_act_t target_act
);

/* Routine act_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t act_get_state
(
	thread_act_t target_act,
	int flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
);

/* Routine act_set_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t act_set_state
(
	thread_act_t target_act,
	int flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
);

/* Routine thread_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_state
(
	thread_act_t target_act,
	thread_state_flavor_t flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
);

/* Routine thread_set_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_state
(
	thread_act_t target_act,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
);

/* Routine thread_suspend */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_suspend
(
	thread_act_t target_act
);

/* Routine thread_resume */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_resume
(
	thread_act_t target_act
);

/* Routine thread_abort */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_abort
(
	thread_act_t target_act
);

/* Routine thread_abort_safely */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_abort_safely
(
	thread_act_t target_act
);

/* Routine thread_depress_abort */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_depress_abort
(
	thread_act_t thread
);

/* Routine thread_get_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_special_port
(
	thread_act_t thr_act,
	int which_port,
	mach_port_t *special_port
);

/* Routine thread_set_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_special_port
(
	thread_act_t thr_act,
	int which_port,
	mach_port_t special_port
);

/* Routine thread_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_info
(
	thread_act_t target_act,
	thread_flavor_t flavor,
	thread_info_t thread_info_out,
	mach_msg_type_number_t *thread_info_outCnt
);

/* Routine thread_set_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
);

/* Routine thread_get_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine thread_swap_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_swap_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine thread_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_policy
(
	thread_act_t thr_act,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	boolean_t set_limit
);

/* Routine thread_policy_set */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_policy_set
(
	thread_act_t thread,
	thread_policy_flavor_t flavor,
	thread_policy_t policy_info,
	mach_msg_type_number_t policy_infoCnt
);

/* Routine thread_policy_get */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_policy_get
(
	thread_act_t thread,
	thread_policy_flavor_t flavor,
	thread_policy_t policy_info,
	mach_msg_type_number_t *policy_infoCnt,
	boolean_t *get_default
);

/* Routine thread_sample */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_sample
(
	thread_act_t thread,
	mach_port_t reply
);

/* Routine etap_trace_thread */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t etap_trace_thread
(
	thread_act_t target_act,
	boolean_t trace_status
);

/* Routine thread_assign */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_assign
(
	thread_act_t thread,
	processor_set_t new_set
);

/* Routine thread_assign_default */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_assign_default
(
	thread_act_t thread
);

/* Routine thread_get_assignment */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_assignment
(
	thread_act_t thread,
	processor_set_name_t *assigned_set
);

/* Routine thread_set_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_policy
(
	thread_act_t thr_act,
	processor_set_t pset,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	policy_limit_t limit,
	mach_msg_type_number_t limitCnt
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__thread_act_subsystem__defined
#define __Request__thread_act_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_terminate_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int flavor;
		mach_msg_type_number_t old_stateCnt;
	} __Request__act_get_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[144];
	} __Request__act_set_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t old_stateCnt;
	} __Request__thread_get_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[144];
	} __Request__thread_set_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_suspend_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_resume_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_abort_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_abort_safely_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_depress_abort_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} __Request__thread_get_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which_port;
	} __Request__thread_set_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_flavor_t flavor;
		mach_msg_type_number_t thread_info_outCnt;
	} __Request__thread_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__thread_set_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__thread_get_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__thread_swap_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		boolean_t set_limit;
	} __Request__thread_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
	} __Request__thread_policy_set_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		boolean_t get_default;
	} __Request__thread_policy_get_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t reply;
		/* end of the kernel processed data */
	} __Request__thread_sample_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t trace_status;
	} __Request__etap_trace_thread_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		/* end of the kernel processed data */
	} __Request__thread_assign_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_assign_default_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_get_assignment_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pset;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		mach_msg_type_number_t limitCnt;
		integer_t limit[1];
	} __Request__thread_set_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__thread_act_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__thread_act_subsystem__defined
#define __RequestUnion__thread_act_subsystem__defined
union __RequestUnion__thread_act_subsystem {
	__Request__thread_terminate_t Request_thread_terminate;
	__Request__act_get_state_t Request_act_get_state;
	__Request__act_set_state_t Request_act_set_state;
	__Request__thread_get_state_t Request_thread_get_state;
	__Request__thread_set_state_t Request_thread_set_state;
	__Request__thread_suspend_t Request_thread_suspend;
	__Request__thread_resume_t Request_thread_resume;
	__Request__thread_abort_t Request_thread_abort;
	__Request__thread_abort_safely_t Request_thread_abort_safely;
	__Request__thread_depress_abort_t Request_thread_depress_abort;
	__Request__thread_get_special_port_t Request_thread_get_special_port;
	__Request__thread_set_special_port_t Request_thread_set_special_port;
	__Request__thread_info_t Request_thread_info;
	__Request__thread_set_exception_ports_t Request_thread_set_exception_ports;
	__Request__thread_get_exception_ports_t Request_thread_get_exception_ports;
	__Request__thread_swap_exception_ports_t Request_thread_swap_exception_ports;
	__Request__thread_policy_t Request_thread_policy;
	__Request__thread_policy_set_t Request_thread_policy_set;
	__Request__thread_policy_get_t Request_thread_policy_get;
	__Request__thread_sample_t Request_thread_sample;
	__Request__etap_trace_thread_t Request_etap_trace_thread;
	__Request__thread_assign_t Request_thread_assign;
	__Request__thread_assign_default_t Request_thread_assign_default;
	__Request__thread_get_assignment_t Request_thread_get_assignment;
	__Request__thread_set_policy_t Request_thread_set_policy;
};
#endif /* !__RequestUnion__thread_act_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__thread_act_subsystem__defined
#define __Reply__thread_act_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_terminate_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[144];
	} __Reply__act_get_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__act_set_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[144];
	} __Reply__thread_get_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_state_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_suspend_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_resume_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_abort_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_abort_safely_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_depress_abort_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply__thread_get_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_special_port_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t thread_info_outCnt;
		integer_t thread_info_out[12];
	} __Reply__thread_info_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__thread_get_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__thread_swap_exception_ports_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_policy_set_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
	} __Reply__thread_policy_get_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_sample_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__etap_trace_thread_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_assign_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_assign_default_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
	} __Reply__thread_get_assignment_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_policy_t;
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__thread_act_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__thread_act_subsystem__defined
#define __ReplyUnion__thread_act_subsystem__defined
union __ReplyUnion__thread_act_subsystem {
	__Reply__thread_terminate_t Reply_thread_terminate;
	__Reply__act_get_state_t Reply_act_get_state;
	__Reply__act_set_state_t Reply_act_set_state;
	__Reply__thread_get_state_t Reply_thread_get_state;
	__Reply__thread_set_state_t Reply_thread_set_state;
	__Reply__thread_suspend_t Reply_thread_suspend;
	__Reply__thread_resume_t Reply_thread_resume;
	__Reply__thread_abort_t Reply_thread_abort;
	__Reply__thread_abort_safely_t Reply_thread_abort_safely;
	__Reply__thread_depress_abort_t Reply_thread_depress_abort;
	__Reply__thread_get_special_port_t Reply_thread_get_special_port;
	__Reply__thread_set_special_port_t Reply_thread_set_special_port;
	__Reply__thread_info_t Reply_thread_info;
	__Reply__thread_set_exception_ports_t Reply_thread_set_exception_ports;
	__Reply__thread_get_exception_ports_t Reply_thread_get_exception_ports;
	__Reply__thread_swap_exception_ports_t Reply_thread_swap_exception_ports;
	__Reply__thread_policy_t Reply_thread_policy;
	__Reply__thread_policy_set_t Reply_thread_policy_set;
	__Reply__thread_policy_get_t Reply_thread_policy_get;
	__Reply__thread_sample_t Reply_thread_sample;
	__Reply__etap_trace_thread_t Reply_etap_trace_thread;
	__Reply__thread_assign_t Reply_thread_assign;
	__Reply__thread_assign_default_t Reply_thread_assign_default;
	__Reply__thread_get_assignment_t Reply_thread_get_assignment;
	__Reply__thread_set_policy_t Reply_thread_set_policy;
};
#endif /* !__RequestUnion__thread_act_subsystem__defined */

#ifndef subsystem_to_name_map_thread_act
#define subsystem_to_name_map_thread_act \
    { "thread_terminate", 3600 },\
    { "act_get_state", 3601 },\
    { "act_set_state", 3602 },\
    { "thread_get_state", 3603 },\
    { "thread_set_state", 3604 },\
    { "thread_suspend", 3605 },\
    { "thread_resume", 3606 },\
    { "thread_abort", 3607 },\
    { "thread_abort_safely", 3608 },\
    { "thread_depress_abort", 3609 },\
    { "thread_get_special_port", 3610 },\
    { "thread_set_special_port", 3611 },\
    { "thread_info", 3612 },\
    { "thread_set_exception_ports", 3613 },\
    { "thread_get_exception_ports", 3614 },\
    { "thread_swap_exception_ports", 3615 },\
    { "thread_policy", 3616 },\
    { "thread_policy_set", 3617 },\
    { "thread_policy_get", 3618 },\
    { "thread_sample", 3619 },\
    { "etap_trace_thread", 3620 },\
    { "thread_assign", 3621 },\
    { "thread_assign_default", 3622 },\
    { "thread_get_assignment", 3623 },\
    { "thread_set_policy", 3624 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _thread_act_user_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/thread_state.h    0100644 0001750 0001750 00000003254 12612724206 027741  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef _MACH_I386_THREAD_STATE_H_
#define _MACH_I386_THREAD_STATE_H_

/* Size of maximum exported thread state in words */
#define I386_THREAD_STATE_MAX	(144)    /* Size of biggest state possible */

#if defined (__i386__) || defined(__x86_64__)
#define THREAD_STATE_MAX	I386_THREAD_STATE_MAX
#endif

#endif	/* _MACH_I386_THREAD_STATE_H_ */
                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/thread_status.h   0100644 0001750 0001750 00000023531 12612724206 030144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	File:	thread_status.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1985
 *
 *	This file contains the structure definitions for the thread
 *	state as applied to I386 processors.
 */

#ifndef	_MACH_I386_THREAD_STATUS_H_
#define _MACH_I386_THREAD_STATUS_H_

#include <mach/i386/_structs.h>
#include <mach/message.h>
#include <mach/i386/fp_reg.h>
#include <mach/i386/thread_state.h>
#include <i386/eflags.h>

/*
 * the i386_xxxx form is kept for legacy purposes since these types
 * are externally known... eventually they should be deprecated.
 * our internal implementation has moved to the following naming convention
 *
 *   x86_xxxx32 names are used to deal with 32 bit states
 *   x86_xxxx64 names are used to deal with 64 bit states
 *   x86_xxxx   names are used to deal with either 32 or 64 bit states
 *	via a self-describing mechanism
 */

/*
 * these are the legacy names which should be deprecated in the future
 * they are externally known which is the only reason we don't just get
 * rid of them
 */
#define i386_THREAD_STATE		1
#define i386_FLOAT_STATE		2
#define i386_EXCEPTION_STATE		3

/*
 * THREAD_STATE_FLAVOR_LIST 0
 * 	these are the supported flavors
 */
#define x86_THREAD_STATE32		1
#define x86_FLOAT_STATE32		2
#define x86_EXCEPTION_STATE32		3
#define x86_THREAD_STATE64		4
#define x86_FLOAT_STATE64		5
#define x86_EXCEPTION_STATE64		6
#define x86_THREAD_STATE		7
#define x86_FLOAT_STATE			8
#define x86_EXCEPTION_STATE		9
#define x86_DEBUG_STATE32		10
#define x86_DEBUG_STATE64		11
#define x86_DEBUG_STATE			12
#define THREAD_STATE_NONE		13
/* 15 and 16 are used for the internal x86_SAVED_STATE flavours */
#define x86_AVX_STATE32			16
#define x86_AVX_STATE64			17


/*
 * Largest state on this machine:
 * (be sure mach/machine/thread_state.h matches!)
 */
#define THREAD_MACHINE_STATE_MAX	THREAD_STATE_MAX

/*
 * VALID_THREAD_STATE_FLAVOR is a platform specific macro that when passed
 * an exception flavor will return if that is a defined flavor for that
 * platform. The macro must be manually updated to include all of the valid
 * exception flavors as defined above.
 */
#define VALID_THREAD_STATE_FLAVOR(x)       \
	 ((x == x86_THREAD_STATE32)	|| \
	  (x == x86_FLOAT_STATE32)	|| \
	  (x == x86_EXCEPTION_STATE32)	|| \
	  (x == x86_DEBUG_STATE32)	|| \
	  (x == x86_THREAD_STATE64)	|| \
	  (x == x86_FLOAT_STATE64)	|| \
	  (x == x86_EXCEPTION_STATE64)	|| \
	  (x == x86_DEBUG_STATE64)	|| \
	  (x == x86_THREAD_STATE)	|| \
	  (x == x86_FLOAT_STATE)	|| \
	  (x == x86_EXCEPTION_STATE)	|| \
	  (x == x86_DEBUG_STATE)	|| \
	  (x == x86_AVX_STATE32)	|| \
	  (x == x86_AVX_STATE64)	|| \
	  (x == THREAD_STATE_NONE))

struct x86_state_hdr {
	int	flavor;
	int	count;
};
typedef struct x86_state_hdr x86_state_hdr_t;

/*
 * Default segment register values.
 */
    
#define USER_CODE_SELECTOR	0x0017
#define USER_DATA_SELECTOR	0x001f
#define KERN_CODE_SELECTOR	0x0008
#define KERN_DATA_SELECTOR	0x0010

/*
 * to be deprecated in the future
 */
typedef _STRUCT_X86_THREAD_STATE32 i386_thread_state_t;
#define i386_THREAD_STATE_COUNT	((mach_msg_type_number_t) \
    ( sizeof (i386_thread_state_t) / sizeof (int) ))

typedef _STRUCT_X86_THREAD_STATE32 x86_thread_state32_t;
#define x86_THREAD_STATE32_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_thread_state32_t) / sizeof (int) ))

/*
 * to be deprecated in the future
 */
typedef _STRUCT_X86_FLOAT_STATE32 i386_float_state_t;
#define i386_FLOAT_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(i386_float_state_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_FLOAT_STATE32 x86_float_state32_t;
#define x86_FLOAT_STATE32_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_float_state32_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_AVX_STATE32 x86_avx_state32_t;
#define x86_AVX_STATE32_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_avx_state32_t)/sizeof(unsigned int)))

/*
 * to be deprecated in the future
 */
typedef _STRUCT_X86_EXCEPTION_STATE32 i386_exception_state_t;
#define i386_EXCEPTION_STATE_COUNT	((mach_msg_type_number_t) \
    ( sizeof (i386_exception_state_t) / sizeof (int) ))

typedef _STRUCT_X86_EXCEPTION_STATE32 x86_exception_state32_t;
#define x86_EXCEPTION_STATE32_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_exception_state32_t) / sizeof (int) ))

#define I386_EXCEPTION_STATE_COUNT i386_EXCEPTION_STATE_COUNT

typedef _STRUCT_X86_DEBUG_STATE32 x86_debug_state32_t;
#define x86_DEBUG_STATE32_COUNT       ((mach_msg_type_number_t) \
	( sizeof (x86_debug_state32_t) / sizeof (int) ))

#define X86_DEBUG_STATE32_COUNT x86_DEBUG_STATE32_COUNT

typedef _STRUCT_X86_THREAD_STATE64 x86_thread_state64_t;
#define x86_THREAD_STATE64_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_thread_state64_t) / sizeof (int) ))

typedef _STRUCT_X86_FLOAT_STATE64 x86_float_state64_t;
#define x86_FLOAT_STATE64_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_float_state64_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_AVX_STATE64 x86_avx_state64_t;
#define x86_AVX_STATE64_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_avx_state64_t)/sizeof(unsigned int)))

typedef _STRUCT_X86_EXCEPTION_STATE64 x86_exception_state64_t;
#define x86_EXCEPTION_STATE64_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_exception_state64_t) / sizeof (int) ))

#define X86_EXCEPTION_STATE64_COUNT x86_EXCEPTION_STATE64_COUNT

typedef _STRUCT_X86_DEBUG_STATE64 x86_debug_state64_t;
#define x86_DEBUG_STATE64_COUNT	((mach_msg_type_number_t) \
    ( sizeof (x86_debug_state64_t) / sizeof (int) ))

#define X86_DEBUG_STATE64_COUNT x86_DEBUG_STATE64_COUNT

/*
 * Combined thread, float and exception states
 */
struct x86_thread_state {
	x86_state_hdr_t			tsh;
	union {
	    x86_thread_state32_t	ts32;
	    x86_thread_state64_t	ts64;
	} uts;
};

struct x86_float_state {
	x86_state_hdr_t			fsh;
	union {
		x86_float_state32_t	fs32;
		x86_float_state64_t	fs64;
	} ufs;
};

struct x86_exception_state {
	x86_state_hdr_t			esh;
	union {
		x86_exception_state32_t	es32;
		x86_exception_state64_t	es64;
	} ues;
};

struct x86_debug_state {
	x86_state_hdr_t			dsh;
	union {
		x86_debug_state32_t	ds32;
		x86_debug_state64_t	ds64;
	} uds;
};

typedef struct x86_thread_state x86_thread_state_t;
#define x86_THREAD_STATE_COUNT	((mach_msg_type_number_t) \
		( sizeof (x86_thread_state_t) / sizeof (int) ))

typedef struct x86_float_state x86_float_state_t;
#define x86_FLOAT_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_float_state_t)/sizeof(unsigned int)))

typedef struct x86_exception_state x86_exception_state_t;
#define x86_EXCEPTION_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_exception_state_t)/sizeof(unsigned int)))

typedef struct x86_debug_state x86_debug_state_t;
#define x86_DEBUG_STATE_COUNT ((mach_msg_type_number_t) \
		(sizeof(x86_debug_state_t)/sizeof(unsigned int)))

/*
 * Machine-independent way for servers and Mach's exception mechanism to
 * choose the most efficient state flavor for exception RPC's:
 */
#define MACHINE_THREAD_STATE		x86_THREAD_STATE
#define MACHINE_THREAD_STATE_COUNT	x86_THREAD_STATE_COUNT

/*
 * when reloading the segment registers on
 * a return out of the kernel, we may take
 * a GeneralProtection or SegmentNotPresent
 * fault if one or more of the segment
 * registers in the saved state was improperly
 * specified via an x86_THREAD_STATE32 call
 * the frame we push on top of the existing
 * save area looks like this... we need to
 * carry this as part of the save area
 * in case we get hit so that we have a big
 * enough stack
 */
struct x86_seg_load_fault32 {
	unsigned int    trapno;
	unsigned int    err;
	unsigned int    eip;
	unsigned int    cs;
	unsigned int    efl;
};


#endif	/* _MACH_I386_THREAD_STATUS_H_ */
                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/vm_param.h        0100644 0001750 0001750 00000013367 12612724206 027102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/* 
 * Copyright (c) 1994 The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 */

/*
 *	File:	vm_param.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1985
 *
 *	I386 machine dependent virtual memory parameters.
 *	Most of the declarations are preceeded by I386_ (or i386_)
 *	which is OK because only I386 specific code will be using
 *	them.
 */

#ifndef	_MACH_I386_VM_PARAM_H_
#define _MACH_I386_VM_PARAM_H_

#define BYTE_SIZE		8		/* byte size in bits */

#define I386_PGBYTES		4096		/* bytes per 80386 page */
#define I386_PGSHIFT		12		/* bitshift for pages */

#undef	PAGE_SIZE				/* Cygwin */
#define	PAGE_SIZE		I386_PGBYTES
#define	PAGE_SHIFT		I386_PGSHIFT
#define	PAGE_MASK		(PAGE_SIZE - 1)

#define I386_LPGBYTES		2*1024*1024	/* bytes per large page */
#define I386_LPGSHIFT		21		/* bitshift for large pages */
#define I386_LPGMASK		(I386_LPGBYTES-1)

/*
 *	Convert bytes to pages and convert pages to bytes.
 *	No rounding is used.
 */

#define i386_btop(x)		((ppnum_t)((x) >> I386_PGSHIFT))
#define machine_btop(x)		i386_btop(x)
#define i386_ptob(x)		(((pmap_paddr_t)(x)) << I386_PGSHIFT)

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define i386_round_page(x)	((((pmap_paddr_t)(x)) + I386_PGBYTES - 1) & \
					~(I386_PGBYTES-1))
#define i386_trunc_page(x)	(((pmap_paddr_t)(x)) & ~(I386_PGBYTES-1))



#define VM_MIN_ADDRESS64	((user_addr_t) 0x0000000000000000ULL)
/*
 * default top of user stack... it grows down from here
 */
#define VM_USRSTACK64		((user_addr_t) 0x00007FFF5FC00000ULL)
#define VM_DYLD64		((user_addr_t) 0x00007FFF5FC00000ULL)
#define VM_LIB64_SHR_DATA	((user_addr_t) 0x00007FFF60000000ULL)
#define VM_LIB64_SHR_TEXT	((user_addr_t) 0x00007FFF80000000ULL)
/*
 * the end of the usable user address space , for now about 47 bits.
 * the 64 bit commpage is past the end of this
 */
#define VM_MAX_PAGE_ADDRESS	((user_addr_t) 0x00007FFFFFE00000ULL)
/*
 * canonical end of user address space for limits checking
 */
#define VM_MAX_USER_PAGE_ADDRESS ((user_addr_t)0x00007FFFFFFFF000ULL)


/* system-wide values */
#define MACH_VM_MIN_ADDRESS		((mach_vm_offset_t) 0)
#define MACH_VM_MAX_ADDRESS		((mach_vm_offset_t) VM_MAX_PAGE_ADDRESS)

/* process-relative values (all 32-bit legacy only for now) */
#define VM_MIN_ADDRESS		((vm_offset_t) 0)
#define VM_USRSTACK32		((vm_offset_t) 0xC0000000)
#define VM_MAX_ADDRESS		((vm_offset_t) 0xFFE00000)



#endif	/* _MACH_I386_VM_PARAM_H_ */
                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/include/foreign/mach/i386/vm_types.h        0100644 0001750 0001750 00000011066 12612724206 027140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * C